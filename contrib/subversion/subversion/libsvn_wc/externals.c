begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * externals.c :  routines dealing with (file) externals in the working copy  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"props.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/** Externals **/
end_comment

begin_comment
comment|/*  * Look for either  *  *   -r N  *   -rN  *  * in the LINE_PARTS array and update the revision field in ITEM with  * the revision if the revision is found.  Set REV_IDX to the index in  * LINE_PARTS where the revision specification starts.  Remove from  * LINE_PARTS the element(s) that specify the revision.  * PARENT_DIRECTORY_DISPLAY and LINE are given to return a nice error  * string.  *  * If this function returns successfully, then LINE_PARTS will have  * only two elements in it.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_and_remove_externals_revision
parameter_list|(
name|int
modifier|*
name|rev_idx
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|line_parts
parameter_list|,
name|int
name|num_line_parts
parameter_list|,
name|svn_wc_external_item2_t
modifier|*
name|item
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_directory_display
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|token
init|=
name|line_parts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|token
index|[
literal|1
index|]
operator|==
literal|'r'
condition|)
block|{
name|svn_opt_revision_t
name|end_revision
init|=
block|{
name|svn_opt_revision_unspecified
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|digits_ptr
decl_stmt|;
name|int
name|shift_count
decl_stmt|;
name|int
name|j
decl_stmt|;
operator|*
name|rev_idx
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|token
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* There must be a total of four elements in the line if                  -r N is used. */
if|if
condition|(
name|num_line_parts
operator|!=
literal|4
condition|)
goto|goto
name|parse_error
goto|;
name|shift_count
operator|=
literal|2
expr_stmt|;
name|digits_ptr
operator|=
name|line_parts
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* There must be a total of three elements in the line                  if -rN is used. */
if|if
condition|(
name|num_line_parts
operator|!=
literal|3
condition|)
goto|goto
name|parse_error
goto|;
name|shift_count
operator|=
literal|1
expr_stmt|;
name|digits_ptr
operator|=
name|token
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|svn_opt_parse_revision
argument_list|(
operator|&
name|item
operator|->
name|revision
argument_list|,
operator|&
name|end_revision
argument_list|,
name|digits_ptr
argument_list|,
name|pool
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|parse_error
goto|;
comment|/* We want a single revision, not a range. */
if|if
condition|(
name|end_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
goto|goto
name|parse_error
goto|;
comment|/* Allow only numbers and dates, not keywords. */
if|if
condition|(
name|item
operator|->
name|revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_number
operator|&&
name|item
operator|->
name|revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_date
condition|)
goto|goto
name|parse_error
goto|;
comment|/* Shift any line elements past the revision specification              down over the revision specification. */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|num_line_parts
operator|-
name|shift_count
condition|;
operator|++
name|j
control|)
name|line_parts
index|[
name|j
index|]
operator|=
name|line_parts
index|[
name|j
operator|+
name|shift_count
index|]
expr_stmt|;
name|line_parts
index|[
name|num_line_parts
operator|-
name|shift_count
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Found the revision, so leave the function immediately, do            * not continue looking for additional revisions. */
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* No revision was found, so there must be exactly two items in the      line array. */
if|if
condition|(
name|num_line_parts
operator|==
literal|2
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|parse_error
label|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error parsing %s property on '%s': '%s'"
argument_list|)
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|,
name|parent_directory_display
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_parse_externals_description3
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|externals_p
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_directory
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|,
name|svn_boolean_t
name|canonicalize_url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|externals
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|lines
init|=
name|svn_cstring_split
argument_list|(
name|desc
argument_list|,
literal|"\n\r"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_directory_display
init|=
name|svn_path_is_url
argument_list|(
name|parent_directory
argument_list|)
condition|?
name|parent_directory
else|:
name|svn_dirent_local_style
argument_list|(
name|parent_directory
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* If an error occurs halfway through parsing, *externals_p should stay    * untouched. So, store the list in a local var first. */
if|if
condition|(
name|externals_p
condition|)
name|externals
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc_external_item2_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
name|APR_ARRAY_IDX
argument_list|(
name|lines
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|char
modifier|*
modifier|*
name|line_parts
decl_stmt|;
name|int
name|num_line_parts
decl_stmt|;
name|svn_wc_external_item2_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|token0
decl_stmt|;
specifier|const
name|char
modifier|*
name|token1
decl_stmt|;
name|svn_boolean_t
name|token0_is_url
decl_stmt|;
name|svn_boolean_t
name|token1_is_url
decl_stmt|;
comment|/* Index into line_parts where the revision specification          started. */
name|int
name|rev_idx
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|line
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
condition|)
continue|continue;
comment|/* else proceed */
name|status
operator|=
name|apr_tokenize_to_argv
argument_list|(
name|line
argument_list|,
operator|&
name|line_parts
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't split line into components: '%s'"
argument_list|)
argument_list|,
name|line
argument_list|)
return|;
comment|/* Count the number of tokens. */
for|for
control|(
name|num_line_parts
operator|=
literal|0
init|;
name|line_parts
index|[
name|num_line_parts
index|]
condition|;
name|num_line_parts
operator|++
control|)
empty_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_external_item2_create
argument_list|(
operator|&
name|item
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|item
operator|->
name|peg_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
comment|/*        * There are six different formats of externals:        *        * 1) DIR URL        * 2) DIR -r N URL        * 3) DIR -rN  URL        * 4) URL DIR        * 5) -r N URL DIR        * 6) -rN URL DIR        *        * The last three allow peg revisions in the URL.        *        * With relative URLs and no '-rN' or '-r N', there is no way to        * distinguish between 'DIR URL' and 'URL DIR' when URL is a        * relative URL like /svn/repos/trunk, so this case is taken as        * case 4).        */
if|if
condition|(
name|num_line_parts
operator|<
literal|2
operator|||
name|num_line_parts
operator|>
literal|4
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error parsing %s property on '%s': '%s'"
argument_list|)
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|,
name|parent_directory_display
argument_list|,
name|line
argument_list|)
return|;
comment|/* To make it easy to check for the forms, find and remove -r N          or -rN from the line item array.  If it is found, rev_idx          contains the index into line_parts where '-r' was found and          set item->revision to the parsed revision. */
comment|/* ### ugh. stupid cast. */
name|SVN_ERR
argument_list|(
name|find_and_remove_externals_revision
argument_list|(
operator|&
name|rev_idx
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|line_parts
argument_list|,
name|num_line_parts
argument_list|,
name|item
argument_list|,
name|parent_directory_display
argument_list|,
name|line
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|token0
operator|=
name|line_parts
index|[
literal|0
index|]
expr_stmt|;
name|token1
operator|=
name|line_parts
index|[
literal|1
index|]
expr_stmt|;
name|token0_is_url
operator|=
name|svn_path_is_url
argument_list|(
name|token0
argument_list|)
expr_stmt|;
name|token1_is_url
operator|=
name|svn_path_is_url
argument_list|(
name|token1
argument_list|)
expr_stmt|;
if|if
condition|(
name|token0_is_url
operator|&&
name|token1_is_url
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid %s property on '%s': "
literal|"cannot use two absolute URLs ('%s' and '%s') in an external; "
literal|"one must be a path where an absolute or relative URL is "
literal|"checked out to"
argument_list|)
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|,
name|parent_directory_display
argument_list|,
name|token0
argument_list|,
name|token1
argument_list|)
return|;
if|if
condition|(
literal|0
operator|==
name|rev_idx
operator|&&
name|token1_is_url
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid %s property on '%s': "
literal|"cannot use a URL '%s' as the target directory for an external "
literal|"definition"
argument_list|)
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|,
name|parent_directory_display
argument_list|,
name|token1
argument_list|)
return|;
if|if
condition|(
literal|1
operator|==
name|rev_idx
operator|&&
name|token0_is_url
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid %s property on '%s': "
literal|"cannot use a URL '%s' as the target directory for an external "
literal|"definition"
argument_list|)
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|,
name|parent_directory_display
argument_list|,
name|token0
argument_list|)
return|;
comment|/* The appearence of -r N or -rN forces the type of external.          If -r is at the beginning of the line or the first token is          an absolute URL or if the second token is not an absolute          URL, then the URL supports peg revisions. */
if|if
condition|(
literal|0
operator|==
name|rev_idx
operator|||
operator|(
operator|-
literal|1
operator|==
name|rev_idx
operator|&&
operator|(
name|token0_is_url
operator|||
operator|!
name|token1_is_url
operator|)
operator|)
condition|)
block|{
comment|/* The URL is passed to svn_opt_parse_path in              uncanonicalized form so that the scheme relative URL              //hostname/foo is not collapsed to a server root relative              URL /hostname/foo. */
name|SVN_ERR
argument_list|(
name|svn_opt_parse_path
argument_list|(
operator|&
name|item
operator|->
name|peg_revision
argument_list|,
operator|&
name|item
operator|->
name|url
argument_list|,
name|token0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|target_dir
operator|=
name|token1
expr_stmt|;
block|}
else|else
block|{
name|item
operator|->
name|target_dir
operator|=
name|token0
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|token1
expr_stmt|;
name|item
operator|->
name|peg_revision
operator|=
name|item
operator|->
name|revision
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_opt_resolve_revisions
argument_list|(
operator|&
name|item
operator|->
name|peg_revision
argument_list|,
operator|&
name|item
operator|->
name|revision
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|target_dir
operator|=
name|svn_dirent_internal_style
argument_list|(
name|item
operator|->
name|target_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|target_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|svn_dirent_is_absolute
argument_list|(
name|item
operator|->
name|target_dir
argument_list|)
operator|||
name|svn_path_is_backpath_present
argument_list|(
name|item
operator|->
name|target_dir
argument_list|)
operator|||
operator|!
name|svn_dirent_skip_ancestor
argument_list|(
literal|"dummy"
argument_list|,
name|svn_dirent_join
argument_list|(
literal|"dummy"
argument_list|,
name|item
operator|->
name|target_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid %s property on '%s': "
literal|"target '%s' is an absolute path or involves '..'"
argument_list|)
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|,
name|parent_directory_display
argument_list|,
name|item
operator|->
name|target_dir
argument_list|)
return|;
if|if
condition|(
name|canonicalize_url
condition|)
block|{
comment|/* Uh... this is stupid.  But it's consistent with what our              code did before we split up the relpath/dirent/uri APIs.              Still, given this, it's no wonder that our own libraries              don't ask this function to canonicalize the results.  */
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|item
operator|->
name|url
argument_list|)
condition|)
name|item
operator|->
name|url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|item
operator|->
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|item
operator|->
name|url
operator|=
name|svn_dirent_canonicalize
argument_list|(
name|item
operator|->
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|externals
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|externals
argument_list|,
name|svn_wc_external_item2_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
if|if
condition|(
name|externals_p
condition|)
operator|*
name|externals_p
operator|=
name|externals
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__externals_find_target_dups
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|duplicate_targets
parameter_list|,
name|apr_array_header_t
modifier|*
name|externals
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|len2
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|apr_hash_t
modifier|*
name|targets
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|targets2
init|=
name|NULL
decl_stmt|;
operator|*
name|duplicate_targets
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|externals
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|externals
argument_list|,
name|i
argument_list|,
name|svn_wc_external_item2_t
operator|*
argument_list|)
operator|->
name|target_dir
expr_stmt|;
name|len
operator|=
name|apr_hash_count
argument_list|(
name|targets
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|targets
argument_list|,
name|target
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|apr_hash_count
argument_list|(
name|targets
argument_list|)
condition|)
block|{
comment|/* Hashtable length is unchanged. This must be a duplicate. */
comment|/* Collapse multiple duplicates of the same target by using a second            * hash layer. */
if|if
condition|(
operator|!
name|targets2
condition|)
name|targets2
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|len2
operator|=
name|apr_hash_count
argument_list|(
name|targets2
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|targets2
argument_list|,
name|target
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
operator|<
name|apr_hash_count
argument_list|(
name|targets2
argument_list|)
condition|)
block|{
comment|/* The second hash list just got bigger, i.e. this target has                * not been counted as duplicate before. */
if|if
condition|(
operator|!
operator|*
name|duplicate_targets
condition|)
block|{
operator|*
name|duplicate_targets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc_external_item2_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
operator|(
operator|*
name|duplicate_targets
operator|)
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|target
expr_stmt|;
block|}
comment|/* Else, this same target has already been recorded as a duplicate,            * don't count it again. */
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|edit_baton
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
comment|/* We explicitly use wri_abspath and local_abspath here, because we      might want to install file externals in an obstructing working copy */
specifier|const
name|char
modifier|*
name|wri_abspath
decl_stmt|;
comment|/* The working defining the file external */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* The file external itself */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The basename of the file external itself */
comment|/* Information from the caller */
name|svn_boolean_t
name|use_commit_times
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|ext_patterns
decl_stmt|;
specifier|const
name|char
modifier|*
name|diff3cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|record_ancestor_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|recorded_repos_relpath
decl_stmt|;
name|svn_revnum_t
name|recorded_peg_revision
decl_stmt|;
name|svn_revnum_t
name|recorded_revision
decl_stmt|;
comment|/* Introducing a new file external */
name|svn_boolean_t
name|added
decl_stmt|;
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
decl_stmt|;
name|void
modifier|*
name|conflict_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
name|svn_wc_notify_func2_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|svn_revnum_t
modifier|*
name|target_revision
decl_stmt|;
comment|/* What was there before the update */
name|svn_revnum_t
name|original_revision
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|original_checksum
decl_stmt|;
comment|/* What we are installing now */
specifier|const
name|char
modifier|*
name|new_pristine_abspath
decl_stmt|;
name|svn_checksum_t
modifier|*
name|new_sha1_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|new_md5_checksum
decl_stmt|;
comment|/* List of incoming propchanges */
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|;
comment|/* Array of svn_prop_inherited_item_t * structures representing the      properties inherited by the base node at LOCAL_ABSPATH. */
name|apr_array_header_t
modifier|*
name|iprops
decl_stmt|;
comment|/* The last change information */
name|svn_revnum_t
name|changed_rev
decl_stmt|;
name|apr_time_t
name|changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|changed_author
decl_stmt|;
name|svn_boolean_t
name|had_props
decl_stmt|;
name|svn_boolean_t
name|file_closed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* svn_delta_editor_t function for svn_wc__get_file_external_editor */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_target_revision
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
operator|*
name|eb
operator|->
name|target_revision
operator|=
name|target_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* svn_delta_editor_t function for svn_wc__get_file_external_editor */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|dir_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
operator|*
name|root_baton
operator|=
name|edit_baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* svn_delta_editor_t function for svn_wc__get_file_external_editor */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|file_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|parent_baton
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
name|eb
operator|->
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"This editor can only update '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|eb
operator|->
name|local_abspath
argument_list|,
name|file_pool
argument_list|)
argument_list|)
return|;
operator|*
name|file_baton
operator|=
name|eb
expr_stmt|;
name|eb
operator|->
name|original_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|eb
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* svn_delta_editor_t function for svn_wc__get_file_external_editor */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|file_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|parent_baton
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
name|eb
operator|->
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"This editor can only update '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|eb
operator|->
name|local_abspath
argument_list|,
name|file_pool
argument_list|)
argument_list|)
return|;
operator|*
name|file_baton
operator|=
name|eb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|eb
operator|->
name|original_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|eb
operator|->
name|changed_rev
argument_list|,
operator|&
name|eb
operator|->
name|changed_date
argument_list|,
operator|&
name|eb
operator|->
name|changed_author
argument_list|,
name|NULL
argument_list|,
operator|&
name|eb
operator|->
name|original_checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|eb
operator|->
name|had_props
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|pool
argument_list|,
name|file_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node '%s' is no existing file external"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|eb
operator|->
name|local_abspath
argument_list|,
name|file_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* svn_delta_editor_t function for svn_wc__get_file_external_editor */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum_digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|file_baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|src_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|dest_stream
decl_stmt|;
if|if
condition|(
name|eb
operator|->
name|original_checksum
condition|)
block|{
if|if
condition|(
name|base_checksum_digest
condition|)
block|{
name|svn_checksum_t
modifier|*
name|expected_checksum
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|original_md5
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|expected_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|base_checksum_digest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|original_checksum
operator|->
name|kind
operator|!=
name|svn_checksum_md5
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_md5
argument_list|(
operator|&
name|original_md5
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|wri_abspath
argument_list|,
name|eb
operator|->
name|original_checksum
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|original_md5
operator|=
name|eb
operator|->
name|original_checksum
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|expected_checksum
argument_list|,
name|original_md5
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_checksum_mismatch_err
argument_list|(
name|expected_checksum
argument_list|,
name|original_md5
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Base checksum mismatch for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|eb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_read
argument_list|(
operator|&
name|src_stream
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|wri_abspath
argument_list|,
name|eb
operator|->
name|original_checksum
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|src_stream
operator|=
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__open_writable_base
argument_list|(
operator|&
name|dest_stream
argument_list|,
operator|&
name|eb
operator|->
name|new_pristine_abspath
argument_list|,
operator|&
name|eb
operator|->
name|new_md5_checksum
argument_list|,
operator|&
name|eb
operator|->
name|new_sha1_checksum
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|wri_abspath
argument_list|,
name|eb
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_txdelta_apply
argument_list|(
name|src_stream
argument_list|,
name|dest_stream
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* svn_delta_editor_t function for svn_wc__get_file_external_editor */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|file_baton
decl_stmt|;
name|svn_prop_t
modifier|*
name|propchange
decl_stmt|;
name|propchange
operator|=
name|apr_array_push
argument_list|(
name|eb
operator|->
name|propchanges
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|eb
operator|->
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|value
operator|=
name|value
condition|?
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* svn_delta_editor_t function for svn_wc__get_file_external_editor */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|expected_md5_digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|file_baton
decl_stmt|;
name|svn_wc_notify_state_t
name|prop_state
init|=
name|svn_wc_notify_state_unknown
decl_stmt|;
name|svn_wc_notify_state_t
name|content_state
init|=
name|svn_wc_notify_state_unknown
decl_stmt|;
name|svn_boolean_t
name|obstructed
init|=
name|FALSE
decl_stmt|;
name|eb
operator|->
name|file_closed
operator|=
name|TRUE
expr_stmt|;
comment|/* We bump the revision here */
comment|/* Check the checksum, if provided */
if|if
condition|(
name|expected_md5_digest
condition|)
block|{
name|svn_checksum_t
modifier|*
name|expected_md5_checksum
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|actual_md5_checksum
init|=
name|eb
operator|->
name|new_md5_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|expected_md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|expected_md5_digest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_md5_checksum
operator|==
name|NULL
condition|)
block|{
name|actual_md5_checksum
operator|=
name|eb
operator|->
name|original_checksum
expr_stmt|;
if|if
condition|(
name|actual_md5_checksum
operator|!=
name|NULL
operator|&&
name|actual_md5_checksum
operator|->
name|kind
operator|!=
name|svn_checksum_md5
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_md5
argument_list|(
operator|&
name|actual_md5_checksum
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|wri_abspath
argument_list|,
name|actual_md5_checksum
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|expected_md5_checksum
argument_list|,
name|actual_md5_checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|expected_md5_checksum
argument_list|,
name|actual_md5_checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|eb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* First move the file in the pristine store; this hands over the cleanup      behavior to the pristine store. */
if|if
condition|(
name|eb
operator|->
name|new_sha1_checksum
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_install
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|new_pristine_abspath
argument_list|,
name|eb
operator|->
name|new_sha1_checksum
argument_list|,
name|eb
operator|->
name|new_md5_checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|new_pristine_abspath
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Merge the changes */
block|{
name|svn_skel_t
modifier|*
name|all_work_items
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_skel
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|apr_hash_t
modifier|*
name|base_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|actual_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_pristine_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_actual_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_dav_props
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|new_checksum
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|original_checksum
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|added
init|=
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|eb
operator|->
name|original_revision
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|eb
operator|->
name|repos_root_url
argument_list|,
name|eb
operator|->
name|url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|new_checksum
operator|=
name|eb
operator|->
name|original_checksum
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|had_props
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_props
argument_list|(
operator|&
name|base_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|actual_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|base_props
condition|)
name|base_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|actual_props
condition|)
name|actual_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|new_sha1_checksum
condition|)
name|new_checksum
operator|=
name|eb
operator|->
name|new_sha1_checksum
expr_stmt|;
comment|/* Merge the properties */
block|{
name|apr_array_header_t
modifier|*
name|entry_prop_changes
decl_stmt|;
name|apr_array_header_t
modifier|*
name|dav_prop_changes
decl_stmt|;
name|apr_array_header_t
modifier|*
name|regular_prop_changes
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|eb
operator|->
name|propchanges
argument_list|,
operator|&
name|entry_prop_changes
argument_list|,
operator|&
name|dav_prop_changes
argument_list|,
operator|&
name|regular_prop_changes
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the entry-prop changes to update the last-changed info. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry_prop_changes
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entry_prop_changes
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|value
condition|)
continue|continue;
comment|/* authz or something */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|)
condition|)
name|eb
operator|->
name|changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|prop
operator|->
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|)
condition|)
block|{
name|apr_int64_t
name|rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|rev
argument_list|,
name|prop
operator|->
name|value
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|changed_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|rev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|eb
operator|->
name|changed_date
argument_list|,
name|prop
operator|->
name|value
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Store the DAV-prop (aka WC-prop) changes.  (This treats a list        * of changes as a list of new props, but we only use this when        * adding a new file and it's equivalent in that case.) */
if|if
condition|(
name|dav_prop_changes
operator|->
name|nelts
operator|>
literal|0
condition|)
name|new_dav_props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|dav_prop_changes
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Merge the regular prop changes. */
if|if
condition|(
name|regular_prop_changes
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|new_pristine_props
operator|=
name|svn_prop__patch
argument_list|(
name|base_props
argument_list|,
name|regular_prop_changes
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__merge_props
argument_list|(
operator|&
name|conflict_skel
argument_list|,
operator|&
name|prop_state
argument_list|,
operator|&
name|new_actual_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|NULL
comment|/* server_baseprops*/
argument_list|,
name|base_props
argument_list|,
name|actual_props
argument_list|,
name|regular_prop_changes
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_pristine_props
operator|=
name|base_props
expr_stmt|;
name|new_actual_props
operator|=
name|actual_props
expr_stmt|;
block|}
block|}
comment|/* Merge the text */
if|if
condition|(
name|eb
operator|->
name|new_sha1_checksum
condition|)
block|{
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|svn_boolean_t
name|install_pristine
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|install_from
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|eb
operator|->
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* Just install the file */
name|install_pristine
operator|=
name|TRUE
expr_stmt|;
name|content_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|disk_kind
operator|!=
name|svn_node_file
operator|||
operator|(
name|eb
operator|->
name|added
operator|&&
name|disk_kind
operator|==
name|svn_node_file
operator|)
condition|)
block|{
comment|/* The node is obstructed; we just change the DB */
name|obstructed
operator|=
name|TRUE
expr_stmt|;
name|content_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
block|}
else|else
block|{
name|svn_boolean_t
name|is_mod
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__internal_file_modified_p
argument_list|(
operator|&
name|is_mod
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_mod
condition|)
block|{
name|install_pristine
operator|=
name|TRUE
expr_stmt|;
name|content_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
block|}
else|else
block|{
name|svn_boolean_t
name|found_text_conflict
decl_stmt|;
comment|/* Ok, we have to do some work to merge a local change */
name|SVN_ERR
argument_list|(
name|svn_wc__perform_file_merge
argument_list|(
operator|&
name|work_item
argument_list|,
operator|&
name|conflict_skel
argument_list|,
operator|&
name|found_text_conflict
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|wri_abspath
argument_list|,
name|new_checksum
argument_list|,
name|original_checksum
argument_list|,
name|actual_props
argument_list|,
name|eb
operator|->
name|ext_patterns
argument_list|,
name|eb
operator|->
name|original_revision
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|eb
operator|->
name|propchanges
argument_list|,
name|eb
operator|->
name|diff3cmd
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_text_conflict
condition|)
name|content_state
operator|=
name|svn_wc_notify_state_conflicted
expr_stmt|;
else|else
name|content_state
operator|=
name|svn_wc_notify_state_merged
expr_stmt|;
block|}
block|}
if|if
condition|(
name|install_pristine
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|install_from
argument_list|,
name|eb
operator|->
name|use_commit_times
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|content_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
comment|/* ### Retranslate on magic property changes, etc. */
block|}
comment|/* Generate a conflict description, if needed */
if|if
condition|(
name|conflict_skel
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_switch
argument_list|(
name|conflict_skel
argument_list|,
name|svn_wc_conflict_version_create2
argument_list|(
name|eb
operator|->
name|repos_root_url
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
name|repos_relpath
argument_list|,
name|eb
operator|->
name|original_revision
argument_list|,
name|svn_node_file
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_wc_conflict_version_create2
argument_list|(
name|eb
operator|->
name|repos_root_url
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
name|repos_relpath
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|svn_node_file
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_create_markers
argument_list|(
operator|&
name|work_item
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Install the file in the DB */
name|SVN_ERR
argument_list|(
name|svn_wc__db_external_add_file
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|wri_abspath
argument_list|,
name|repos_relpath
argument_list|,
name|eb
operator|->
name|repos_root_url
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|new_pristine_props
argument_list|,
name|eb
operator|->
name|iprops
argument_list|,
name|eb
operator|->
name|changed_rev
argument_list|,
name|eb
operator|->
name|changed_date
argument_list|,
name|eb
operator|->
name|changed_author
argument_list|,
name|new_checksum
argument_list|,
name|new_dav_props
argument_list|,
name|eb
operator|->
name|record_ancestor_abspath
argument_list|,
name|eb
operator|->
name|recorded_repos_relpath
argument_list|,
name|eb
operator|->
name|recorded_peg_revision
argument_list|,
name|eb
operator|->
name|recorded_revision
argument_list|,
name|TRUE
argument_list|,
name|new_actual_props
argument_list|,
name|FALSE
comment|/* keep_recorded_info */
argument_list|,
name|conflict_skel
argument_list|,
name|all_work_items
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* close_edit may also update iprops for switched files, catching        those for which close_file is never called (e.g. an update of a        file external with no changes).  So as a minor optimization we        clear the iprops so as not to set them again in close_edit. */
name|eb
operator|->
name|iprops
operator|=
name|NULL
expr_stmt|;
comment|/* Run the work queue to complete the installation */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|wri_abspath
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Notify */
if|if
condition|(
name|eb
operator|->
name|notify_func
condition|)
block|{
name|svn_wc_notify_action_t
name|action
decl_stmt|;
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
if|if
condition|(
operator|!
name|eb
operator|->
name|added
condition|)
name|action
operator|=
name|obstructed
condition|?
name|svn_wc_notify_update_shadowed_update
else|:
name|svn_wc_notify_update_update
expr_stmt|;
else|else
name|action
operator|=
name|obstructed
condition|?
name|svn_wc_notify_update_shadowed_add
else|:
name|svn_wc_notify_update_add
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|eb
operator|->
name|local_abspath
argument_list|,
name|action
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
operator|*
name|eb
operator|->
name|target_revision
expr_stmt|;
name|notify
operator|->
name|prop_state
operator|=
name|prop_state
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|content_state
expr_stmt|;
name|notify
operator|->
name|old_revision
operator|=
name|eb
operator|->
name|original_revision
expr_stmt|;
name|eb
operator|->
name|notify_func
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* svn_delta_editor_t function for svn_wc__get_file_external_editor */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
if|if
condition|(
operator|!
name|eb
operator|->
name|file_closed
operator|||
name|eb
operator|->
name|iprops
condition|)
block|{
name|apr_hash_t
modifier|*
name|wcroot_iprops
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|eb
operator|->
name|iprops
condition|)
block|{
name|wcroot_iprops
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|wcroot_iprops
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|iprops
argument_list|)
expr_stmt|;
block|}
comment|/* The node wasn't updated, so we just have to bump its revision */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_bump_revisions_post_update
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|local_abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
argument_list|,
name|wcroot_iprops
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_file_external_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
modifier|*
name|target_revision
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_uuid
parameter_list|,
name|apr_array_header_t
modifier|*
name|iprops
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
specifier|const
name|char
modifier|*
name|diff3_cmd
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|preserved_exts
parameter_list|,
specifier|const
name|char
modifier|*
name|record_ancestor_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|recorded_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|recorded_peg_rev
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|recorded_rev
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
name|apr_pool_t
modifier|*
name|edit_pool
init|=
name|result_pool
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|apr_pcalloc
argument_list|(
name|edit_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
name|svn_delta_editor_t
modifier|*
name|tree_editor
init|=
name|svn_delta_default_editor
argument_list|(
name|edit_pool
argument_list|)
decl_stmt|;
name|eb
operator|->
name|pool
operator|=
name|edit_pool
expr_stmt|;
name|eb
operator|->
name|db
operator|=
name|db
expr_stmt|;
name|eb
operator|->
name|local_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|edit_pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|wri_abspath
condition|)
name|eb
operator|->
name|wri_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|edit_pool
argument_list|,
name|wri_abspath
argument_list|)
expr_stmt|;
else|else
name|eb
operator|->
name|wri_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|edit_pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|name
operator|=
name|svn_dirent_basename
argument_list|(
name|eb
operator|->
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eb
operator|->
name|target_revision
operator|=
name|target_revision
expr_stmt|;
name|eb
operator|->
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|edit_pool
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|eb
operator|->
name|repos_root_url
operator|=
name|apr_pstrdup
argument_list|(
name|edit_pool
argument_list|,
name|repos_root_url
argument_list|)
expr_stmt|;
name|eb
operator|->
name|repos_uuid
operator|=
name|apr_pstrdup
argument_list|(
name|edit_pool
argument_list|,
name|repos_uuid
argument_list|)
expr_stmt|;
name|eb
operator|->
name|iprops
operator|=
name|iprops
expr_stmt|;
name|eb
operator|->
name|use_commit_times
operator|=
name|use_commit_times
expr_stmt|;
name|eb
operator|->
name|ext_patterns
operator|=
name|preserved_exts
expr_stmt|;
name|eb
operator|->
name|diff3cmd
operator|=
name|diff3_cmd
expr_stmt|;
name|eb
operator|->
name|record_ancestor_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|edit_pool
argument_list|,
name|record_ancestor_abspath
argument_list|)
expr_stmt|;
name|eb
operator|->
name|recorded_repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|recorded_url
argument_list|,
name|edit_pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|recorded_peg_rev
operator|->
name|kind
operator|==
name|svn_opt_revision_number
condition|)
name|eb
operator|->
name|recorded_peg_revision
operator|=
name|recorded_peg_rev
operator|->
name|value
operator|.
name|number
expr_stmt|;
else|else
name|eb
operator|->
name|recorded_peg_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Not fixed/HEAD */
if|if
condition|(
name|recorded_rev
operator|->
name|kind
operator|==
name|svn_opt_revision_number
condition|)
name|eb
operator|->
name|recorded_revision
operator|=
name|recorded_rev
operator|->
name|value
operator|.
name|number
expr_stmt|;
else|else
name|eb
operator|->
name|recorded_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Not fixed/HEAD */
name|eb
operator|->
name|conflict_func
operator|=
name|conflict_func
expr_stmt|;
name|eb
operator|->
name|conflict_baton
operator|=
name|conflict_baton
expr_stmt|;
name|eb
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|eb
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|eb
operator|->
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|eb
operator|->
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|eb
operator|->
name|propchanges
operator|=
name|apr_array_make
argument_list|(
name|edit_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
expr_stmt|;
name|tree_editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|tree_editor
operator|->
name|set_target_revision
operator|=
name|set_target_revision
expr_stmt|;
name|tree_editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|tree_editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|tree_editor
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|tree_editor
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|tree_editor
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|tree_editor
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
return|return
name|svn_delta_get_cancellation_editor
argument_list|(
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|tree_editor
argument_list|,
name|eb
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__crawl_file_external
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
name|report_baton
parameter_list|,
name|svn_boolean_t
name|restore_files
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_wc__db_lock_t
modifier|*
name|lock
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_boolean_t
name|update_root
decl_stmt|;
name|err
operator|=
name|svn_wc__db_base_get_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|revision
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|lock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|update_root
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|kind
operator|==
name|svn_node_dir
operator|||
operator|!
name|update_root
condition|)
block|{
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We don't know about this node, so all we have to do is tell          the reporter that we don't know this node.           But first we have to start the report by sending some basic          information for the root. */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|delete_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finish the report, which causes the update editor to be          driven. */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|finish_report
argument_list|(
name|report_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
if|if
condition|(
name|restore_files
condition|)
block|{
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|==
name|svn_node_none
condition|)
block|{
name|err
operator|=
name|svn_wc_restore
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|use_commit_times
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Report that we know the path */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|revision
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For compatibility with the normal update editor report we report          the target as switched.           ### We can probably report a parent url and unswitched later */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|link_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|revision
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
comment|/* start_empty*/
argument_list|,
name|lock
condition|?
name|lock
operator|->
name|token
else|:
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|reporter
operator|->
name|finish_report
argument_list|(
name|report_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__read_external_info
parameter_list|(
name|svn_node_kind_t
modifier|*
name|external_kind
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|defining_abspath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|defining_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|defining_operational_revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|defining_revision
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc__db_external_read
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|defining_abspath
argument_list|,
name|defining_url
condition|?
operator|&
name|repos_root_url
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
name|defining_url
argument_list|,
name|defining_operational_revision
argument_list|,
name|defining_revision
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|wri_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|||
operator|!
name|ignore_enoent
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_kind
condition|)
operator|*
name|external_kind
operator|=
name|svn_node_none
expr_stmt|;
if|if
condition|(
name|defining_abspath
condition|)
operator|*
name|defining_abspath
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|defining_url
condition|)
operator|*
name|defining_url
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|defining_operational_revision
condition|)
operator|*
name|defining_operational_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|defining_revision
condition|)
operator|*
name|defining_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|external_kind
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|svn_wc__db_status_normal
condition|)
operator|*
name|external_kind
operator|=
name|svn_node_unknown
expr_stmt|;
else|else
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|svn_node_file
case|:
case|case
name|svn_node_symlink
case|:
operator|*
name|external_kind
operator|=
name|svn_node_file
expr_stmt|;
break|break;
case|case
name|svn_node_dir
case|:
operator|*
name|external_kind
operator|=
name|svn_node_dir
expr_stmt|;
break|break;
default|default:
operator|*
name|external_kind
operator|=
name|svn_node_none
expr_stmt|;
block|}
block|}
if|if
condition|(
name|defining_url
operator|&&
operator|*
name|defining_url
condition|)
operator|*
name|defining_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
operator|*
name|defining_url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE in *IS_ROLLED_OUT iff a node exists at XINFO->LOCAL_ABSPATH and  * if that node's origin corresponds with XINFO->REPOS_ROOT_URL and  * XINFO->REPOS_RELPATH.  All allocations are made in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|is_external_rolled_out
parameter_list|(
name|svn_boolean_t
modifier|*
name|is_rolled_out
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|svn_wc__committable_external_info_t
modifier|*
name|xinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
operator|*
name|is_rolled_out
operator|=
name|FALSE
expr_stmt|;
name|err
operator|=
name|svn_wc__db_base_get_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|xinfo
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
operator|*
name|is_rolled_out
operator|=
operator|(
name|strcmp
argument_list|(
name|xinfo
operator|->
name|repos_root_url
argument_list|,
name|repos_root_url
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|xinfo
operator|->
name|repos_relpath
argument_list|,
name|repos_relpath
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__committable_externals_below
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|externals
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|orig_externals
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* For svn_depth_files, this also fetches dirs. They are filtered later. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_committable_externals_below
argument_list|(
operator|&
name|orig_externals
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|depth
operator|!=
name|svn_depth_infinity
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_externals
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orig_externals
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_boolean_t
name|is_rolled_out
decl_stmt|;
name|svn_wc__committable_external_info_t
modifier|*
name|xinfo
init|=
name|APR_ARRAY_IDX
argument_list|(
name|orig_externals
argument_list|,
name|i
argument_list|,
name|svn_wc__committable_external_info_t
operator|*
argument_list|)
decl_stmt|;
comment|/* Discard dirs for svn_depth_files (s.a.). */
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|&&
name|xinfo
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Discard those externals that are not currently checked out. */
name|SVN_ERR
argument_list|(
name|is_external_rolled_out
argument_list|(
operator|&
name|is_rolled_out
argument_list|,
name|wc_ctx
argument_list|,
name|xinfo
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_rolled_out
condition|)
continue|continue;
if|if
condition|(
operator|*
name|externals
operator|==
name|NULL
condition|)
operator|*
name|externals
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc__committable_external_info_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|externals
argument_list|,
name|svn_wc__committable_external_info_t
operator|*
argument_list|)
operator|=
name|xinfo
expr_stmt|;
if|if
condition|(
name|depth
operator|!=
name|svn_depth_infinity
condition|)
continue|continue;
comment|/* Are there any nested externals? */
name|SVN_ERR
argument_list|(
name|svn_wc__committable_externals_below
argument_list|(
name|externals
argument_list|,
name|wc_ctx
argument_list|,
name|xinfo
operator|->
name|local_abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__externals_defined_below
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|externals
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_externals_defined_below
argument_list|(
name|externals
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__external_register
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|defining_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_uuid
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|svn_revnum_t
name|operational_revision
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|kind
operator|==
name|svn_node_dir
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_external_add_dir
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|defining_abspath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|defining_abspath
argument_list|,
name|repos_relpath
argument_list|,
name|operational_revision
argument_list|,
name|revision
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__external_remove
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|declaration_only
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_external_read
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_external_remove
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|wri_abspath
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|declaration_only
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc_remove_from_revision_control2
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_remove
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* keep_as_working */
argument_list|,
name|TRUE
comment|/* queue_deletes */
argument_list|,
name|FALSE
comment|/* remove_locks */
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__externals_gather_definitions
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|externals
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|depths
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
name|svn_depth_infinity
operator|||
name|depth
operator|==
name|svn_depth_unknown
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_externals_gather_definitions
argument_list|(
name|externals
argument_list|,
name|depths
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
operator|*
name|externals
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc_prop_get2
argument_list|(
operator|&
name|value
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|value
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|externals
argument_list|,
name|local_abspath
argument_list|,
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
name|depths
condition|)
block|{
name|svn_depth_t
name|node_depth
decl_stmt|;
operator|*
name|depths
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|node_depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|depths
argument_list|,
name|local_abspath
argument_list|,
name|svn_depth_to_word
argument_list|(
name|node_depth
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__close_db
parameter_list|(
specifier|const
name|char
modifier|*
name|external_abspath
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_drop_root
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|external_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the scheme of @a uri in @a scheme allocated from @a pool.    If @a uri does not appear to be a valid URI, then @a scheme will    not be updated.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|uri_scheme
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|scheme
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|uri
index|[
name|i
index|]
operator|&&
name|uri
index|[
name|i
index|]
operator|!=
literal|':'
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|uri
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|uri
index|[
name|i
index|]
operator|==
literal|':'
operator|&&
name|uri
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|uri
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
operator|*
name|scheme
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|uri
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|error
label|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"URL '%s' does not begin with a scheme"
argument_list|)
argument_list|,
name|uri
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__resolve_relative_external_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|resolved_url
parameter_list|,
specifier|const
name|svn_wc_external_item2_t
modifier|*
name|item
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_dir_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|url
init|=
name|item
operator|->
name|url
decl_stmt|;
name|apr_uri_t
name|parent_dir_uri
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
operator|*
name|resolved_url
operator|=
name|item
operator|->
name|url
expr_stmt|;
comment|/* If the URL is already absolute, there is nothing to do. */
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|url
argument_list|)
condition|)
block|{
comment|/* "http://server/path" */
operator|*
name|resolved_url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|url
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* "/path", "//path", and "///path" */
name|int
name|num_leading_slashes
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|url
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|num_leading_slashes
operator|++
expr_stmt|;
if|if
condition|(
name|url
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
name|num_leading_slashes
operator|++
expr_stmt|;
block|}
comment|/* "//schema-relative" and in some cases "///schema-relative".          This last format is supported on file:// schema relative. */
name|url
operator|=
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
name|apr_pstrndup
argument_list|(
name|scratch_pool
argument_list|,
name|url
argument_list|,
name|num_leading_slashes
argument_list|)
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|url
operator|+
name|num_leading_slashes
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* "^/path" and "../path" */
name|url
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Parse the parent directory URL into its parts. */
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|scratch_pool
argument_list|,
name|parent_dir_url
argument_list|,
operator|&
name|parent_dir_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Illegal parent directory URL '%s'"
argument_list|)
argument_list|,
name|parent_dir_url
argument_list|)
return|;
comment|/* If the parent directory URL is at the server root, then the URL      may have no / after the hostname so apr_uri_parse() will leave      the URL's path as NULL. */
if|if
condition|(
operator|!
name|parent_dir_uri
operator|.
name|path
condition|)
name|parent_dir_uri
operator|.
name|path
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|parent_dir_uri
operator|.
name|query
operator|=
name|NULL
expr_stmt|;
name|parent_dir_uri
operator|.
name|fragment
operator|=
name|NULL
expr_stmt|;
comment|/* Handle URLs relative to the current directory or to the      repository root.  The backpaths may only remove path elements,      not the hostname.  This allows an external to refer to another      repository in the same server relative to the location of this      repository, say using SVNParentPath. */
if|if
condition|(
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"../"
argument_list|,
name|url
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"^/"
argument_list|,
name|url
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|apr_array_header_t
modifier|*
name|base_components
decl_stmt|;
name|apr_array_header_t
modifier|*
name|relative_components
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Decompose either the parent directory's URL path or the          repository root's URL path into components.  */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"../"
argument_list|,
name|url
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|base_components
operator|=
name|svn_path_decompose
argument_list|(
name|parent_dir_uri
operator|.
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|relative_components
operator|=
name|svn_path_decompose
argument_list|(
name|url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_uri_t
name|repos_root_uri
decl_stmt|;
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|scratch_pool
argument_list|,
name|repos_root_url
argument_list|,
operator|&
name|repos_root_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Illegal repository root URL '%s'"
argument_list|)
argument_list|,
name|repos_root_url
argument_list|)
return|;
comment|/* If the repository root URL is at the server root, then              the URL may have no / after the hostname so              apr_uri_parse() will leave the URL's path as NULL. */
if|if
condition|(
operator|!
name|repos_root_uri
operator|.
name|path
condition|)
name|repos_root_uri
operator|.
name|path
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base_components
operator|=
name|svn_path_decompose
argument_list|(
name|repos_root_uri
operator|.
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|relative_components
operator|=
name|svn_path_decompose
argument_list|(
name|url
operator|+
literal|2
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relative_components
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|component
init|=
name|APR_ARRAY_IDX
argument_list|(
name|relative_components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|".."
argument_list|,
name|component
argument_list|)
condition|)
block|{
comment|/* Constructing the final absolute URL together with                  apr_uri_unparse() requires that the path be absolute,                  so only pop a component if the component being popped                  is not the component for the root directory. */
if|if
condition|(
name|base_components
operator|->
name|nelts
operator|>
literal|1
condition|)
name|apr_array_pop
argument_list|(
name|base_components
argument_list|)
expr_stmt|;
block|}
else|else
name|APR_ARRAY_PUSH
argument_list|(
name|base_components
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|component
expr_stmt|;
block|}
name|parent_dir_uri
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|svn_path_compose
argument_list|(
name|base_components
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|resolved_url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|apr_uri_unparse
argument_list|(
name|scratch_pool
argument_list|,
operator|&
name|parent_dir_uri
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The remaining URLs are relative to either the scheme or server root      and can only refer to locations inside that scope, so backpaths are      not allowed. */
if|if
condition|(
name|svn_path_is_backpath_present
argument_list|(
name|url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The external relative URL '%s' cannot have "
literal|"backpaths, i.e. '..'"
argument_list|)
argument_list|,
name|item
operator|->
name|url
argument_list|)
return|;
comment|/* Relative to the scheme: Build a new URL from the parts we know. */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"//"
argument_list|,
name|url
argument_list|,
literal|2
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|scheme
decl_stmt|;
name|SVN_ERR
argument_list|(
name|uri_scheme
argument_list|(
operator|&
name|scheme
argument_list|,
name|repos_root_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|resolved_url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
name|scheme
argument_list|,
literal|":"
argument_list|,
name|url
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Relative to the server root: Just replace the path portion of the      parent's URL. */
if|if
condition|(
name|url
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|parent_dir_uri
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|url
expr_stmt|;
operator|*
name|resolved_url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|apr_uri_unparse
argument_list|(
name|scratch_pool
argument_list|,
operator|&
name|parent_dir_uri
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Unrecognized format for the relative external "
literal|"URL '%s'"
argument_list|)
argument_list|,
name|item
operator|->
name|url
argument_list|)
return|;
block|}
end_function

end_unit

