begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * status.c: construct a status structure from an entry structure  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"props.h"
end_include

begin_include
include|#
directive|include
file|"entries.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_include
include|#
directive|include
file|"tree_conflicts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_editor.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Baton used for walking the local status */
end_comment

begin_struct
struct|struct
name|walk_status_baton
block|{
comment|/* The DB handle for managing the working copy state. */
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
comment|/*** External handling ***/
comment|/* Target of the status */
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
comment|/* Should we ignore text modifications? */
name|svn_boolean_t
name|ignore_text_mods
decl_stmt|;
comment|/* Externals info harvested during the status run. */
name|apr_hash_t
modifier|*
name|externals
decl_stmt|;
comment|/*** Repository lock handling ***/
comment|/* The repository root URL, if set. */
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
comment|/* Repository locks, if set. */
name|apr_hash_t
modifier|*
name|repos_locks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*** Editor batons ***/
end_comment

begin_struct
struct|struct
name|edit_baton
block|{
comment|/* For status, the "destination" of the edit.  */
specifier|const
name|char
modifier|*
name|anchor_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_basename
decl_stmt|;
comment|/* The DB handle for managing the working copy state.  */
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
comment|/* The overall depth of this edit (a dir baton may override this).    *    * If this is svn_depth_unknown, the depths found in the working    * copy will govern the edit; or if the edit depth indicates a    * descent deeper than the found depths are capable of, the found    * depths also govern, of course (there's no point descending into    * something that's not there).    */
name|svn_depth_t
name|default_depth
decl_stmt|;
comment|/* Do we want all statuses (instead of just the interesting ones) ? */
name|svn_boolean_t
name|get_all
decl_stmt|;
comment|/* Ignore the svn:ignores. */
name|svn_boolean_t
name|no_ignore
decl_stmt|;
comment|/* The comparison revision in the repository.  This is a reference      because this editor returns this rev to the driver directly, as      well as in each statushash entry. */
name|svn_revnum_t
modifier|*
name|target_revision
decl_stmt|;
comment|/* Status function/baton. */
name|svn_wc_status_func4_t
name|status_func
decl_stmt|;
name|void
modifier|*
name|status_baton
decl_stmt|;
comment|/* Cancellation function/baton. */
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
comment|/* The configured set of default ignores. */
specifier|const
name|apr_array_header_t
modifier|*
name|ignores
decl_stmt|;
comment|/* Status item for the path represented by the anchor of the edit. */
name|svn_wc_status3_t
modifier|*
name|anchor_status
decl_stmt|;
comment|/* Was open_root() called for this edit drive? */
name|svn_boolean_t
name|root_opened
decl_stmt|;
comment|/* The local status baton */
name|struct
name|walk_status_baton
name|wb
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dir_baton
block|{
comment|/* The path to this directory. */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* Basename of this directory. */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The global edit baton. */
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
comment|/* Baton for this directory's parent, or NULL if this is the root      directory. */
name|struct
name|dir_baton
modifier|*
name|parent_baton
decl_stmt|;
comment|/* The ambient requested depth below this point in the edit.  This      can differ from the parent baton's depth (with the edit baton      considered the ultimate parent baton).  For example, if the      parent baton has svn_depth_immediates, then here we should have      svn_depth_empty, because there would be no further recursion, not      even to file children. */
name|svn_depth_t
name|depth
decl_stmt|;
comment|/* Is this directory filtered out due to depth?  (Note that if this      is TRUE, the depth field is undefined.) */
name|svn_boolean_t
name|excluded
decl_stmt|;
comment|/* 'svn status' shouldn't print status lines for things that are      added;  we're only interest in asking if objects that the user      *already* has are up-to-date or not.  Thus if this flag is set,      the next two will be ignored.  :-)  */
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* Gets set iff there's a change to this directory's properties, to      guide us when syncing adm files later. */
name|svn_boolean_t
name|prop_changed
decl_stmt|;
comment|/* This means (in terms of 'svn status') that some child was deleted      or added to the directory */
name|svn_boolean_t
name|text_changed
decl_stmt|;
comment|/* Working copy status structures for children of this directory.      This hash maps const char * abspaths  to svn_wc_status3_t *      status items. */
name|apr_hash_t
modifier|*
name|statii
decl_stmt|;
comment|/* The pool in which this baton itself is allocated. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The repository root relative path to this item in the repository. */
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
comment|/* out-of-date info corresponding to ood_* fields in svn_wc_status3_t. */
name|svn_node_kind_t
name|ood_kind
decl_stmt|;
name|svn_revnum_t
name|ood_changed_rev
decl_stmt|;
name|apr_time_t
name|ood_changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|ood_changed_author
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|file_baton
block|{
comment|/* Absolute local path to this file */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* The global edit baton. */
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
comment|/* Baton for this file's parent directory. */
name|struct
name|dir_baton
modifier|*
name|dir_baton
decl_stmt|;
comment|/* Pool specific to this file_baton. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Basename of this file */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 'svn status' shouldn't print status lines for things that are      added;  we're only interest in asking if objects that the user      *already* has are up-to-date or not.  Thus if this flag is set,      the next two will be ignored.  :-)  */
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* This gets set if the file underwent a text change, which guides      the code that syncs up the adm dir and working copy. */
name|svn_boolean_t
name|text_changed
decl_stmt|;
comment|/* This gets set if the file underwent a prop change, which guides      the code that syncs up the adm dir and working copy. */
name|svn_boolean_t
name|prop_changed
decl_stmt|;
comment|/* The repository root relative path to this item in the repository. */
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
comment|/* out-of-date info corresponding to ood_* fields in svn_wc_status3_t. */
name|svn_node_kind_t
name|ood_kind
decl_stmt|;
name|svn_revnum_t
name|ood_changed_rev
decl_stmt|;
name|apr_time_t
name|ood_changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|ood_changed_author
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** Code **/
end_comment

begin_comment
comment|/* Return *REPOS_RELPATH and *REPOS_ROOT_URL for LOCAL_ABSPATH using    information in INFO if available, falling back on    PARENT_REPOS_RELPATH and PARENT_REPOS_ROOT_URL if available, and    finally falling back on querying DB. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_repos_root_url_relpath
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|repos_uuid
parameter_list|,
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_uuid
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|repos_relpath
operator|&&
name|info
operator|->
name|repos_root_url
condition|)
block|{
operator|*
name|repos_relpath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|info
operator|->
name|repos_relpath
argument_list|)
expr_stmt|;
operator|*
name|repos_root_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|info
operator|->
name|repos_root_url
argument_list|)
expr_stmt|;
operator|*
name|repos_uuid
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|info
operator|->
name|repos_uuid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent_repos_relpath
operator|&&
name|parent_repos_root_url
condition|)
block|{
operator|*
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|parent_repos_relpath
argument_list|,
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|repos_root_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|parent_repos_root_url
argument_list|)
expr_stmt|;
operator|*
name|repos_uuid
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|parent_repos_uuid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_added
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|repos_relpath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_deleted
operator|&&
operator|!
name|info
operator|->
name|have_more_work
operator|&&
name|info
operator|->
name|have_base
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
name|repos_relpath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_deleted
condition|)
block|{
specifier|const
name|char
modifier|*
name|work_del_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|add_abspath
decl_stmt|;
comment|/* Handles working DELETE and the special case where there is just          svn_wc__db_status_not_present in WORKING */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_deletion
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|work_del_abspath
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The parent of what has been deleted must be added */
name|add_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|work_del_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|repos_relpath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|add_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
operator|*
name|repos_relpath
argument_list|,
name|svn_dirent_skip_ancestor
argument_list|(
name|add_abspath
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|repos_relpath
operator|=
name|NULL
expr_stmt|;
operator|*
name|repos_root_url
operator|=
name|NULL
expr_stmt|;
operator|*
name|repos_uuid
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|internal_status
parameter_list|(
name|svn_wc_status3_t
modifier|*
modifier|*
name|status
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Fill in *STATUS for LOCAL_ABSPATH, using DB. Allocate *STATUS in    RESULT_POOL and use SCRATCH_POOL for temporary allocations.     PARENT_REPOS_ROOT_URL and PARENT_REPOS_RELPATH are the repository root    and repository relative path of the parent of LOCAL_ABSPATH or NULL if    LOCAL_ABSPATH doesn't have a versioned parent directory.     DIRENT is the local representation of LOCAL_ABSPATH in the working copy or    NULL if the node does not exist on disk.     If GET_ALL is FALSE, and LOCAL_ABSPATH is not locally modified, then    *STATUS will be set to NULL.  If GET_ALL is non-zero, then *STATUS will be    allocated and returned no matter what.  If IGNORE_TEXT_MODS is TRUE then    don't check for text mods, assume there are none and set and *STATUS    returned to reflect that assumption.     The status struct's repos_lock field will be set to REPOS_LOCK. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|assemble_status
parameter_list|(
name|svn_wc_status3_t
modifier|*
modifier|*
name|status
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_uuid
parameter_list|,
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|info
parameter_list|,
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_boolean_t
name|ignore_text_mods
parameter_list|,
specifier|const
name|svn_lock_t
modifier|*
name|repos_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_status3_t
modifier|*
name|stat
decl_stmt|;
name|svn_boolean_t
name|switched_p
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|copied
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
specifier|const
name|char
modifier|*
name|moved_from_abspath
init|=
name|NULL
decl_stmt|;
name|svn_filesize_t
name|filesize
init|=
operator|(
name|dirent
operator|&&
operator|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
operator|)
condition|?
name|dirent
operator|->
name|filesize
else|:
name|SVN_INVALID_FILESIZE
decl_stmt|;
comment|/* Defaults for two main variables. */
name|enum
name|svn_wc_status_kind
name|node_status
init|=
name|svn_wc_status_normal
decl_stmt|;
name|enum
name|svn_wc_status_kind
name|text_status
init|=
name|svn_wc_status_normal
decl_stmt|;
name|enum
name|svn_wc_status_kind
name|prop_status
init|=
name|svn_wc_status_none
decl_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_single_info
argument_list|(
operator|&
name|info
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|repos_relpath
operator|||
operator|!
name|parent_repos_relpath
condition|)
name|switched_p
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
comment|/* A node is switched if it doesn't have the implied repos_relpath */
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_relpath_skip_ancestor
argument_list|(
name|parent_repos_relpath
argument_list|,
name|info
operator|->
name|repos_relpath
argument_list|)
decl_stmt|;
name|switched_p
operator|=
operator|!
name|name
operator|||
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_incomplete
operator|||
name|info
operator|->
name|incomplete
condition|)
block|{
comment|/* Highest precedence.  */
name|node_status
operator|=
name|svn_wc_status_incomplete
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_deleted
condition|)
block|{
name|node_status
operator|=
name|svn_wc_status_deleted
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|have_base
operator|||
name|info
operator|->
name|have_more_work
operator|||
name|info
operator|->
name|copied
condition|)
name|copied
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|have_more_work
operator|&&
name|info
operator|->
name|have_base
condition|)
name|copied
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|work_del_abspath
decl_stmt|;
comment|/* Find out details of our deletion.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_deletion
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|work_del_abspath
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_del_abspath
condition|)
name|copied
operator|=
name|TRUE
expr_stmt|;
comment|/* Working deletion */
block|}
block|}
else|else
block|{
comment|/* Examine whether our target is missing or obstructed. To detect        * obstructions, we have to look at the on-disk status in DIRENT. */
name|svn_node_kind_t
name|expected_kind
init|=
operator|(
name|info
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
condition|?
name|svn_node_dir
else|:
name|svn_node_file
decl_stmt|;
if|if
condition|(
operator|!
name|dirent
operator|||
name|dirent
operator|->
name|kind
operator|!=
name|expected_kind
condition|)
block|{
comment|/* A present or added node should be on disk, so it is              reported missing or obstructed.  */
if|if
condition|(
operator|!
name|dirent
operator|||
name|dirent
operator|->
name|kind
operator|==
name|svn_node_none
condition|)
name|node_status
operator|=
name|svn_wc_status_missing
expr_stmt|;
else|else
name|node_status
operator|=
name|svn_wc_status_obstructed
expr_stmt|;
block|}
block|}
comment|/* Does the node have props? */
if|if
condition|(
name|info
operator|->
name|status
operator|!=
name|svn_wc__db_status_deleted
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|props_mod
condition|)
name|prop_status
operator|=
name|svn_wc_status_modified
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|had_props
condition|)
name|prop_status
operator|=
name|svn_wc_status_normal
expr_stmt|;
block|}
comment|/* If NODE_STATUS is still normal, after the above checks, then      we should proceed to refine the status.       If it was changed, then the subdir is incomplete or missing/obstructed.    */
if|if
condition|(
name|info
operator|->
name|kind
operator|!=
name|svn_node_dir
operator|&&
name|node_status
operator|==
name|svn_wc_status_normal
condition|)
block|{
name|svn_boolean_t
name|text_modified_p
init|=
name|FALSE
decl_stmt|;
comment|/* Implement predecence rules: */
comment|/* 1. Set the two main variables to "discovered" values first (M, C).             Together, these two stati are of lowest precedence, and C has             precedence over M. */
comment|/* If the entry is a file, check for textual modifications */
if|if
condition|(
operator|(
name|info
operator|->
name|kind
operator|==
name|svn_node_file
operator|||
name|info
operator|->
name|kind
operator|==
name|svn_node_symlink
operator|)
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
operator|&&
operator|(
name|info
operator|->
name|special
operator|==
operator|(
name|dirent
operator|&&
name|dirent
operator|->
name|special
operator|)
operator|)
endif|#
directive|endif
comment|/* HAVE_SYMLINK */
condition|)
block|{
comment|/* If the on-disk dirent exactly matches the expected state              skip all operations in svn_wc__internal_text_modified_p()              to avoid an extra filestat for every file, which can be              expensive on network drives as a filestat usually can't              be cached there */
if|if
condition|(
operator|!
name|info
operator|->
name|has_checksum
condition|)
name|text_modified_p
operator|=
name|TRUE
expr_stmt|;
comment|/* Local addition -> Modified */
elseif|else
if|if
condition|(
name|ignore_text_mods
operator|||
operator|(
name|dirent
operator|&&
name|info
operator|->
name|recorded_size
operator|!=
name|SVN_INVALID_FILESIZE
operator|&&
name|info
operator|->
name|recorded_time
operator|!=
literal|0
operator|&&
name|info
operator|->
name|recorded_size
operator|==
name|dirent
operator|->
name|filesize
operator|&&
name|info
operator|->
name|recorded_time
operator|==
name|dirent
operator|->
name|mtime
operator|)
condition|)
name|text_modified_p
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc__internal_file_modified_p
argument_list|(
operator|&
name|text_modified_p
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_ACCESS_DENIED
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* An access denied is very common on Windows when another                      application has the file open.  Previously we ignored                      this error in svn_wc__text_modified_internal_p, where it                      should have really errored. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|text_modified_p
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
elseif|else
if|if
condition|(
name|info
operator|->
name|special
operator|!=
operator|(
name|dirent
operator|&&
name|dirent
operator|->
name|special
operator|)
condition|)
name|node_status
operator|=
name|svn_wc_status_obstructed
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SYMLINK */
if|if
condition|(
name|text_modified_p
condition|)
name|text_status
operator|=
name|svn_wc_status_modified
expr_stmt|;
block|}
name|conflicted
operator|=
name|info
operator|->
name|conflicted
expr_stmt|;
if|if
condition|(
name|conflicted
condition|)
block|{
name|svn_boolean_t
name|text_conflicted
decl_stmt|,
name|prop_conflicted
decl_stmt|,
name|tree_conflicted
decl_stmt|;
comment|/* ### Check if the conflict was resolved by removing the marker files.          ### This should really be moved to the users of this API */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_conflicted_p
argument_list|(
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_conflicted
operator|&&
operator|!
name|prop_conflicted
operator|&&
operator|!
name|tree_conflicted
condition|)
name|conflicted
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|node_status
operator|==
name|svn_wc_status_normal
condition|)
block|{
comment|/* 2. Possibly overwrite the text_status variable with "scheduled"             states from the entry (A, D, R).  As a group, these states are             of medium precedence.  They also override any C or M that may             be in the prop_status field at this point, although they do not             override a C text status.*/
if|if
condition|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_added
condition|)
block|{
name|copied
operator|=
name|info
operator|->
name|copied
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|op_root
condition|)
block|{
comment|/* Keep status normal */
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|have_base
operator|&&
operator|!
name|info
operator|->
name|have_more_work
condition|)
block|{
comment|/* Simple addition or copy, no replacement */
name|node_status
operator|=
name|svn_wc_status_added
expr_stmt|;
block|}
else|else
block|{
name|svn_wc__db_status_t
name|below_working
decl_stmt|;
name|svn_boolean_t
name|have_base
decl_stmt|,
name|have_work
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_info_below_working
argument_list|(
operator|&
name|have_base
argument_list|,
operator|&
name|have_work
argument_list|,
operator|&
name|below_working
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the node is not present or deleted (read: not present                  in working), then the node is not a replacement */
if|if
condition|(
name|below_working
operator|!=
name|svn_wc__db_status_not_present
operator|&&
name|below_working
operator|!=
name|svn_wc__db_status_deleted
condition|)
block|{
name|node_status
operator|=
name|svn_wc_status_replaced
expr_stmt|;
block|}
else|else
name|node_status
operator|=
name|svn_wc_status_added
expr_stmt|;
block|}
comment|/* Get moved-from info (only for potential op-roots of a move). */
if|if
condition|(
name|info
operator|->
name|moved_here
operator|&&
name|info
operator|->
name|op_root
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc__db_scan_moved
argument_list|(
operator|&
name|moved_from_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We are no longer moved... So most likely we are somehow                      changing the db for things like resolving conflicts. */
name|moved_from_abspath
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|node_status
operator|==
name|svn_wc_status_normal
condition|)
name|node_status
operator|=
name|text_status
expr_stmt|;
if|if
condition|(
name|node_status
operator|==
name|svn_wc_status_normal
operator|&&
name|prop_status
operator|!=
name|svn_wc_status_none
condition|)
name|node_status
operator|=
name|prop_status
expr_stmt|;
comment|/* 5. Easy out:  unless we're fetching -every- entry, don't bother      to allocate a struct for an uninteresting entry. */
if|if
condition|(
operator|!
name|get_all
condition|)
if|if
condition|(
operator|(
operator|(
name|node_status
operator|==
name|svn_wc_status_none
operator|)
operator|||
operator|(
name|node_status
operator|==
name|svn_wc_status_normal
operator|)
operator|)
operator|&&
operator|(
operator|!
name|switched_p
operator|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|locked
operator|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|lock
operator|)
operator|&&
operator|(
operator|!
name|repos_lock
operator|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|changelist
operator|)
operator|&&
operator|(
operator|!
name|conflicted
operator|)
condition|)
block|{
operator|*
name|status
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* 6. Build and return a status structure. */
name|stat
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_dir
case|:
name|stat
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
break|break;
case|case
name|svn_node_file
case|:
case|case
name|svn_node_symlink
case|:
name|stat
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
break|break;
case|case
name|svn_node_unknown
case|:
default|default:
name|stat
operator|->
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
block|}
name|stat
operator|->
name|depth
operator|=
name|info
operator|->
name|depth
expr_stmt|;
name|stat
operator|->
name|filesize
operator|=
name|filesize
expr_stmt|;
name|stat
operator|->
name|node_status
operator|=
name|node_status
expr_stmt|;
name|stat
operator|->
name|text_status
operator|=
name|text_status
expr_stmt|;
name|stat
operator|->
name|prop_status
operator|=
name|prop_status
expr_stmt|;
name|stat
operator|->
name|repos_node_status
operator|=
name|svn_wc_status_none
expr_stmt|;
comment|/* default */
name|stat
operator|->
name|repos_text_status
operator|=
name|svn_wc_status_none
expr_stmt|;
comment|/* default */
name|stat
operator|->
name|repos_prop_status
operator|=
name|svn_wc_status_none
expr_stmt|;
comment|/* default */
name|stat
operator|->
name|switched
operator|=
name|switched_p
expr_stmt|;
name|stat
operator|->
name|copied
operator|=
name|copied
expr_stmt|;
name|stat
operator|->
name|repos_lock
operator|=
name|repos_lock
expr_stmt|;
name|stat
operator|->
name|revision
operator|=
name|info
operator|->
name|revnum
expr_stmt|;
name|stat
operator|->
name|changed_rev
operator|=
name|info
operator|->
name|changed_rev
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|changed_author
condition|)
name|stat
operator|->
name|changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|info
operator|->
name|changed_author
argument_list|)
expr_stmt|;
name|stat
operator|->
name|changed_date
operator|=
name|info
operator|->
name|changed_date
expr_stmt|;
name|stat
operator|->
name|ood_kind
operator|=
name|svn_node_none
expr_stmt|;
name|stat
operator|->
name|ood_changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|stat
operator|->
name|ood_changed_date
operator|=
literal|0
expr_stmt|;
name|stat
operator|->
name|ood_changed_author
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_repos_root_url_relpath
argument_list|(
operator|&
name|stat
operator|->
name|repos_relpath
argument_list|,
operator|&
name|stat
operator|->
name|repos_root_url
argument_list|,
operator|&
name|stat
operator|->
name|repos_uuid
argument_list|,
name|info
argument_list|,
name|parent_repos_relpath
argument_list|,
name|parent_repos_root_url
argument_list|,
name|parent_repos_uuid
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lock
condition|)
block|{
name|svn_lock_t
modifier|*
name|lck
init|=
name|svn_lock_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|lck
operator|->
name|path
operator|=
name|stat
operator|->
name|repos_relpath
expr_stmt|;
name|lck
operator|->
name|token
operator|=
name|info
operator|->
name|lock
operator|->
name|token
expr_stmt|;
name|lck
operator|->
name|owner
operator|=
name|info
operator|->
name|lock
operator|->
name|owner
expr_stmt|;
name|lck
operator|->
name|comment
operator|=
name|info
operator|->
name|lock
operator|->
name|comment
expr_stmt|;
name|lck
operator|->
name|creation_date
operator|=
name|info
operator|->
name|lock
operator|->
name|date
expr_stmt|;
name|stat
operator|->
name|lock
operator|=
name|lck
expr_stmt|;
block|}
else|else
name|stat
operator|->
name|lock
operator|=
name|NULL
expr_stmt|;
name|stat
operator|->
name|locked
operator|=
name|info
operator|->
name|locked
expr_stmt|;
name|stat
operator|->
name|conflicted
operator|=
name|conflicted
expr_stmt|;
name|stat
operator|->
name|versioned
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|changelist
condition|)
name|stat
operator|->
name|changelist
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|info
operator|->
name|changelist
argument_list|)
expr_stmt|;
name|stat
operator|->
name|moved_from_abspath
operator|=
name|moved_from_abspath
expr_stmt|;
comment|/* ### TODO: Handle multiple moved_to values properly */
if|if
condition|(
name|info
operator|->
name|moved_to
condition|)
name|stat
operator|->
name|moved_to_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|info
operator|->
name|moved_to
operator|->
name|moved_to_abspath
argument_list|)
expr_stmt|;
name|stat
operator|->
name|file_external
operator|=
name|info
operator|->
name|file_external
expr_stmt|;
operator|*
name|status
operator|=
name|stat
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fill in *STATUS for the unversioned path LOCAL_ABSPATH, using data    available in DB. Allocate *STATUS in POOL. Use SCRATCH_POOL for    temporary allocations.     If IS_IGNORED is non-zero and this is a non-versioned entity, set    the node_status to svn_wc_status_none.  Otherwise set the    node_status to svn_wc_status_unversioned.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|assemble_unversioned
parameter_list|(
name|svn_wc_status3_t
modifier|*
modifier|*
name|status
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
parameter_list|,
name|svn_boolean_t
name|tree_conflicted
parameter_list|,
name|svn_boolean_t
name|is_ignored
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_status3_t
modifier|*
name|stat
decl_stmt|;
comment|/* return a fairly blank structure. */
name|stat
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stat
argument_list|)
argument_list|)
expr_stmt|;
comment|/*stat->versioned = FALSE;*/
name|stat
operator|->
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
comment|/* not versioned */
name|stat
operator|->
name|depth
operator|=
name|svn_depth_unknown
expr_stmt|;
name|stat
operator|->
name|filesize
operator|=
operator|(
name|dirent
operator|&&
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
condition|?
name|dirent
operator|->
name|filesize
else|:
name|SVN_INVALID_FILESIZE
expr_stmt|;
name|stat
operator|->
name|node_status
operator|=
name|svn_wc_status_none
expr_stmt|;
name|stat
operator|->
name|text_status
operator|=
name|svn_wc_status_none
expr_stmt|;
name|stat
operator|->
name|prop_status
operator|=
name|svn_wc_status_none
expr_stmt|;
name|stat
operator|->
name|repos_node_status
operator|=
name|svn_wc_status_none
expr_stmt|;
name|stat
operator|->
name|repos_text_status
operator|=
name|svn_wc_status_none
expr_stmt|;
name|stat
operator|->
name|repos_prop_status
operator|=
name|svn_wc_status_none
expr_stmt|;
comment|/* If this path has no entry, but IS present on disk, it's      unversioned.  If this file is being explicitly ignored (due      to matching an ignore-pattern), the node_status is set to      svn_wc_status_ignored.  Otherwise the node_status is set to      svn_wc_status_unversioned. */
if|if
condition|(
name|dirent
operator|&&
name|dirent
operator|->
name|kind
operator|!=
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|is_ignored
condition|)
name|stat
operator|->
name|node_status
operator|=
name|svn_wc_status_ignored
expr_stmt|;
else|else
name|stat
operator|->
name|node_status
operator|=
name|svn_wc_status_unversioned
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_conflicted
condition|)
block|{
comment|/* If this path has no entry, is NOT present on disk, and IS a          tree conflict victim, report it as conflicted. */
name|stat
operator|->
name|node_status
operator|=
name|svn_wc_status_conflicted
expr_stmt|;
block|}
name|stat
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|stat
operator|->
name|changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|stat
operator|->
name|ood_changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|stat
operator|->
name|ood_kind
operator|=
name|svn_node_none
expr_stmt|;
comment|/* For the case of an incoming delete to a locally deleted path during      an update, we get a tree conflict. */
name|stat
operator|->
name|conflicted
operator|=
name|tree_conflicted
expr_stmt|;
name|stat
operator|->
name|changelist
operator|=
name|NULL
expr_stmt|;
operator|*
name|status
operator|=
name|stat
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given an ENTRY object representing PATH, build a status structure    and pass it off to the STATUS_FUNC/STATUS_BATON.  All other    arguments are the same as those passed to assemble_status().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_status_structure
parameter_list|(
specifier|const
name|struct
name|walk_status_baton
modifier|*
name|wb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_uuid
parameter_list|,
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|info
parameter_list|,
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_wc_status_func4_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_status3_t
modifier|*
name|statstruct
decl_stmt|;
specifier|const
name|svn_lock_t
modifier|*
name|repos_lock
init|=
name|NULL
decl_stmt|;
comment|/* Check for a repository lock. */
if|if
condition|(
name|wb
operator|->
name|repos_locks
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|,
modifier|*
name|repos_root_url
decl_stmt|,
modifier|*
name|repos_uuid
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_repos_root_url_relpath
argument_list|(
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|info
argument_list|,
name|parent_repos_relpath
argument_list|,
name|parent_repos_root_url
argument_list|,
name|parent_repos_uuid
argument_list|,
name|wb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_relpath
condition|)
block|{
comment|/* repos_lock still uses the deprecated filesystem absolute path              format */
name|repos_lock
operator|=
name|svn_hash_gets
argument_list|(
name|wb
operator|->
name|repos_locks
argument_list|,
name|svn_fspath__join
argument_list|(
literal|"/"
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|assemble_status
argument_list|(
operator|&
name|statstruct
argument_list|,
name|wb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|parent_repos_root_url
argument_list|,
name|parent_repos_relpath
argument_list|,
name|parent_repos_uuid
argument_list|,
name|info
argument_list|,
name|dirent
argument_list|,
name|get_all
argument_list|,
name|wb
operator|->
name|ignore_text_mods
argument_list|,
name|repos_lock
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|statstruct
operator|&&
name|status_func
condition|)
return|return
name|svn_error_trace
argument_list|(
call|(
modifier|*
name|status_func
call|)
argument_list|(
name|status_baton
argument_list|,
name|local_abspath
argument_list|,
name|statstruct
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store in *PATTERNS a list of ignores collected from svn:ignore properties    on LOCAL_ABSPATH and svn:global-ignores on LOCAL_ABSPATH and its    repository ancestors (as cached in the working copy), including the default    ignores passed in as IGNORES.     Upon return, *PATTERNS will contain zero or more (const char *)    patterns from the value of the SVN_PROP_IGNORE property set on    the working directory path.     IGNORES is a list of patterns to include; typically this will    be the default ignores as, for example, specified in a config file.     DB, LOCAL_ABSPATH is used to access the working copy.     Allocate results in RESULT_POOL, temporary stuffs in SCRATCH_POOL.     None of the arguments may be NULL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|collect_ignore_patterns
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|patterns
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ignores
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* ### assert we are passed a directory? */
operator|*
name|patterns
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy default ignores into the local PATTERNS array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ignores
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|ignore
init|=
name|APR_ARRAY_IDX
argument_list|(
name|ignores
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|patterns
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_wc__db_read_inherited_props
argument_list|(
operator|&
name|inherited_props
argument_list|,
operator|&
name|props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|SVN_PROP_INHERITABLE_IGNORES
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|props
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_IGNORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|svn_cstring_split_append
argument_list|(
operator|*
name|patterns
argument_list|,
name|value
operator|->
name|data
argument_list|,
literal|"\n\r"
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_INHERITABLE_IGNORES
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|svn_cstring_split_append
argument_list|(
operator|*
name|patterns
argument_list|,
name|value
operator|->
name|data
argument_list|,
literal|"\n\r"
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inherited_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|inherited_props
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|elt
operator|->
name|prop_hash
argument_list|,
name|SVN_PROP_INHERITABLE_IGNORES
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|svn_cstring_split_append
argument_list|(
operator|*
name|patterns
argument_list|,
name|value
operator|->
name|data
argument_list|,
literal|"\n\r"
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compare LOCAL_ABSPATH with items in the EXTERNALS hash to see if    LOCAL_ABSPATH is the drop location for, or an intermediate directory    of the drop location for, an externals definition.  Use SCRATCH_POOL    for scratchwork.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_external_path
parameter_list|(
name|apr_hash_t
modifier|*
name|externals
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* First try: does the path exist as a key in the hash? */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|externals
argument_list|,
name|local_abspath
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Failing that, we need to check if any external is a child of      LOCAL_ABSPATH.  */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|externals
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|external_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_dirent_is_child
argument_list|(
name|local_abspath
argument_list|,
name|external_abspath
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Assuming that LOCAL_ABSPATH is unversioned, send a status structure    for it through STATUS_FUNC/STATUS_BATON unless this path is being    ignored.  This function should never be called on a versioned entry.     LOCAL_ABSPATH is the path to the unversioned file whose status is being    requested.  PATH_KIND is the node kind of NAME as determined by the    caller.  PATH_SPECIAL is the special status of the path, also determined    by the caller.    PATTERNS points to a list of filename patterns which are marked as ignored.    None of these parameter may be NULL.     If NO_IGNORE is TRUE, the item will be added regardless of    whether it is ignored; otherwise we will only add the item if it    does not match any of the patterns in PATTERN or INHERITED_IGNORES.     Allocate everything in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_unversioned_item
parameter_list|(
specifier|const
name|struct
name|walk_status_baton
modifier|*
name|wb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
parameter_list|,
name|svn_boolean_t
name|tree_conflicted
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|patterns
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_wc_status_func4_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_ignored
decl_stmt|;
name|svn_boolean_t
name|is_external
decl_stmt|;
name|svn_wc_status3_t
modifier|*
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_name
init|=
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|is_ignored
operator|=
name|svn_wc_match_ignore_list
argument_list|(
name|base_name
argument_list|,
name|patterns
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|assemble_unversioned
argument_list|(
operator|&
name|status
argument_list|,
name|wb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|dirent
argument_list|,
name|tree_conflicted
argument_list|,
name|is_ignored
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|is_external
operator|=
name|is_external_path
argument_list|(
name|wb
operator|->
name|externals
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_external
condition|)
name|status
operator|->
name|node_status
operator|=
name|svn_wc_status_external
expr_stmt|;
comment|/* We can have a tree conflict on an unversioned path, i.e. an incoming    * delete on a locally deleted path during an update. Don't ever ignore    * those! */
if|if
condition|(
name|status
operator|->
name|conflicted
condition|)
name|is_ignored
operator|=
name|FALSE
expr_stmt|;
comment|/* If we aren't ignoring it, or if it's an externals path, pass this      entry to the status func. */
if|if
condition|(
name|no_ignore
operator|||
operator|!
name|is_ignored
operator|||
name|is_external
condition|)
return|return
name|svn_error_trace
argument_list|(
call|(
modifier|*
name|status_func
call|)
argument_list|(
name|status_baton
argument_list|,
name|local_abspath
argument_list|,
name|status
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|get_dir_status
parameter_list|(
specifier|const
name|struct
name|walk_status_baton
modifier|*
name|wb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|skip_this_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_uuid
parameter_list|,
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|dir_info
parameter_list|,
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ignore_patterns
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_wc_status_func4_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Send out a status structure according to the information gathered on one  * child node. (Basically this function is the guts of the loop in  * get_dir_status() and of get_child_status().)  *  * Send a status structure of LOCAL_ABSPATH. PARENT_ABSPATH must be the  * dirname of LOCAL_ABSPATH.  *  * INFO should reflect the information on LOCAL_ABSPATH; LOCAL_ABSPATH must  * be an unversioned file or dir, or a versioned file.  For versioned  * directories use get_dir_status() instead.  *  * INFO may be NULL for an unversioned node. If such node has a tree conflict,  * UNVERSIONED_TREE_CONFLICTED may be set to TRUE. If INFO is non-NULL,  * UNVERSIONED_TREE_CONFLICTED is ignored.  *  * DIRENT should reflect LOCAL_ABSPATH's dirent information.  *  * DIR_REPOS_* should reflect LOCAL_ABSPATH's parent URL, i.e. LOCAL_ABSPATH's  * URL treated with svn_uri_dirname(). ### TODO verify this (externals)  *  * If *COLLECTED_IGNORE_PATTERNS is NULL and ignore patterns are needed in this  * call, then *COLLECTED_IGNORE_PATTERNS will be set to an apr_array_header_t*  * containing all ignore patterns, as returned by collect_ignore_patterns() on  * PARENT_ABSPATH and IGNORE_PATTERNS. If *COLLECTED_IGNORE_PATTERNS is passed  * non-NULL, it is assumed it already holds those results.  * This speeds up repeated calls with the same PARENT_ABSPATH.  *  * *COLLECTED_IGNORE_PATTERNS will be allocated in RESULT_POOL. All other  * allocations are made in SCRATCH_POOL.  *  * The remaining parameters correspond to get_dir_status(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|one_child_status
parameter_list|(
specifier|const
name|struct
name|walk_status_baton
modifier|*
name|wb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_abspath
parameter_list|,
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|info
parameter_list|,
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_repos_uuid
parameter_list|,
name|svn_boolean_t
name|unversioned_tree_conflicted
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|collected_ignore_patterns
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ignore_patterns
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_wc_status_func4_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|conflicted
init|=
name|info
condition|?
name|info
operator|->
name|conflicted
else|:
name|unversioned_tree_conflicted
decl_stmt|;
if|if
condition|(
name|info
operator|&&
name|info
operator|->
name|status
operator|!=
name|svn_wc__db_status_not_present
operator|&&
name|info
operator|->
name|status
operator|!=
name|svn_wc__db_status_excluded
operator|&&
name|info
operator|->
name|status
operator|!=
name|svn_wc__db_status_server_excluded
operator|&&
operator|!
operator|(
name|info
operator|->
name|kind
operator|==
name|svn_node_unknown
operator|&&
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_normal
operator|)
condition|)
block|{
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|&&
name|info
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|send_status_structure
argument_list|(
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|dir_repos_root_url
argument_list|,
name|dir_repos_relpath
argument_list|,
name|dir_repos_uuid
argument_list|,
name|info
argument_list|,
name|dirent
argument_list|,
name|get_all
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Descend in subdirectories. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_infinity
operator|&&
name|info
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_dir_status
argument_list|(
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|dir_repos_root_url
argument_list|,
name|dir_repos_relpath
argument_list|,
name|dir_repos_uuid
argument_list|,
name|info
argument_list|,
name|dirent
argument_list|,
name|ignore_patterns
argument_list|,
name|svn_depth_infinity
argument_list|,
name|get_all
argument_list|,
name|no_ignore
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If conflicted, fall right through to unversioned.    * With depth_files, show all conflicts, even if their report is only    * about directories. A tree conflict may actually report two different    * kinds, so it's not so easy to define what depth=files means. We could go    * look up the kinds in the conflict ... just show all. */
if|if
condition|(
operator|!
name|conflicted
condition|)
block|{
comment|/* Selected node, but not found */
if|if
condition|(
name|dirent
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|&&
name|dirent
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|svn_wc_is_adm_dir
argument_list|(
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The node exists on disk but there is no versioned information about it,    * or it doesn't exist but is a tree conflicted path or should be    * reported not-present. */
comment|/* Why pass ignore patterns on a tree conflicted node, even if it should    * always show up in clients' status reports anyway? Because the calling    * client decides whether to ignore, and thus this flag needs to be    * determined.  For example, in 'svn status', plain unversioned nodes show    * as '?  C', where ignored ones show as 'I  C'. */
if|if
condition|(
name|ignore_patterns
operator|&&
operator|!
operator|*
name|collected_ignore_patterns
condition|)
name|SVN_ERR
argument_list|(
name|collect_ignore_patterns
argument_list|(
name|collected_ignore_patterns
argument_list|,
name|wb
operator|->
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|ignore_patterns
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|send_unversioned_item
argument_list|(
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|dirent
argument_list|,
name|conflicted
argument_list|,
operator|*
name|collected_ignore_patterns
argument_list|,
name|no_ignore
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Send svn_wc_status3_t * structures for the directory LOCAL_ABSPATH and    for all its child nodes (according to DEPTH) through STATUS_FUNC /    STATUS_BATON.     If SKIP_THIS_DIR is TRUE, the directory's own status will not be reported.    All subdirs reached by recursion will be reported regardless of this    parameter's value.     PARENT_REPOS_* parameters can be set to refer to LOCAL_ABSPATH's parent's    URL, i.e. the URL the WC reflects at the dirname of LOCAL_ABSPATH, to avoid    retrieving them again. Otherwise they must be NULL.     DIR_INFO can be set to the information of LOCAL_ABSPATH, to avoid retrieving    it again. Otherwise it must be NULL.     DIRENT is LOCAL_ABSPATH's own dirent and is only needed if it is reported,    so if SKIP_THIS_DIR is TRUE, DIRENT can be left NULL.     Other arguments are the same as those passed to    svn_wc_get_status_editor5().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dir_status
parameter_list|(
specifier|const
name|struct
name|walk_status_baton
modifier|*
name|wb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|skip_this_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_repos_uuid
parameter_list|,
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|dir_info
parameter_list|,
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ignore_patterns
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_wc_status_func4_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dir_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_repos_uuid
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|,
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|conflicts
decl_stmt|,
modifier|*
name|all_children
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_children
decl_stmt|;
name|apr_array_header_t
modifier|*
name|collected_ignore_patterns
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|dirents
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir_info
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_single_info
argument_list|(
operator|&
name|dir_info
argument_list|,
name|wb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_repos_root_url_relpath
argument_list|(
operator|&
name|dir_repos_relpath
argument_list|,
operator|&
name|dir_repos_root_url
argument_list|,
operator|&
name|dir_repos_uuid
argument_list|,
name|dir_info
argument_list|,
name|parent_repos_relpath
argument_list|,
name|parent_repos_root_url
argument_list|,
name|parent_repos_uuid
argument_list|,
name|wb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a hash containing all children.  The source hashes      don't all map the same types, but only the keys of the result      hash are subsequently used. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children_info
argument_list|(
operator|&
name|nodes
argument_list|,
operator|&
name|conflicts
argument_list|,
name|wb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|all_children
operator|=
name|apr_hash_overlay
argument_list|(
name|scratch_pool
argument_list|,
name|nodes
argument_list|,
name|dirents
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|conflicts
argument_list|)
operator|>
literal|0
condition|)
name|all_children
operator|=
name|apr_hash_overlay
argument_list|(
name|scratch_pool
argument_list|,
name|conflicts
argument_list|,
name|all_children
argument_list|)
expr_stmt|;
comment|/* Handle "this-dir" first. */
if|if
condition|(
operator|!
name|skip_this_dir
condition|)
block|{
comment|/* This code is not conditional on HAVE_SYMLINK as some systems that do          not allow creating symlinks (!HAVE_SYMLINK) can still encounter          symlinks (or in case of Windows also 'Junctions') created by other          methods.           Without this block a working copy in the root of a junction is          reported as an obstruction, because the junction itself is reported as          special.           Systems that have no symlink support at all, would always see          dirent->special as FALSE, so even there enabling this code shouldn't          produce problems.        */
if|if
condition|(
name|dirent
operator|->
name|special
condition|)
block|{
name|svn_io_dirent2_t
modifier|*
name|this_dirent
init|=
name|svn_io_dirent2_dup
argument_list|(
name|dirent
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
comment|/* We're being pointed to "this-dir" via a symlink.            * Get the real node kind and pretend the path is not a symlink.            * This prevents send_status_structure() from treating this-dir            * as a directory obstructed by a file. */
name|SVN_ERR
argument_list|(
name|svn_io_check_resolved_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|this_dirent
operator|->
name|kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|this_dirent
operator|->
name|special
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|send_status_structure
argument_list|(
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|parent_repos_root_url
argument_list|,
name|parent_repos_relpath
argument_list|,
name|parent_repos_uuid
argument_list|,
name|dir_info
argument_list|,
name|this_dirent
argument_list|,
name|get_all
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|send_status_structure
argument_list|(
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|parent_repos_root_url
argument_list|,
name|parent_repos_relpath
argument_list|,
name|parent_repos_uuid
argument_list|,
name|dir_info
argument_list|,
name|dirent
argument_list|,
name|get_all
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the requested depth is empty, we only need status on this-dir. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_empty
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Walk all the children of this directory. */
name|sorted_children
operator|=
name|svn_sort__hash
argument_list|(
name|all_children
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_children
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_sort__item_t
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|;
name|svn_io_dirent2_t
modifier|*
name|child_dirent
decl_stmt|;
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|child_info
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_children
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
expr_stmt|;
name|key
operator|=
name|item
operator|.
name|key
expr_stmt|;
name|klen
operator|=
name|item
operator|.
name|klen
expr_stmt|;
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|key
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|child_dirent
operator|=
name|apr_hash_get
argument_list|(
name|dirents
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|child_info
operator|=
name|apr_hash_get
argument_list|(
name|nodes
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|one_child_status
argument_list|(
name|wb
argument_list|,
name|child_abspath
argument_list|,
name|local_abspath
argument_list|,
name|child_info
argument_list|,
name|child_dirent
argument_list|,
name|dir_repos_root_url
argument_list|,
name|dir_repos_relpath
argument_list|,
name|dir_repos_uuid
argument_list|,
name|apr_hash_get
argument_list|(
name|conflicts
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
operator|!=
name|NULL
argument_list|,
operator|&
name|collected_ignore_patterns
argument_list|,
name|ignore_patterns
argument_list|,
name|depth
argument_list|,
name|get_all
argument_list|,
name|no_ignore
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy our subpools. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Send an svn_wc_status3_t * structure for the versioned file, or for the  * unversioned file or directory, LOCAL_ABSPATH, which is not ignored (an  * explicit target). Does not recurse.  *  * INFO should reflect LOCAL_ABSPATH's information, but should be NULL for  * unversioned nodes. An unversioned and tree-conflicted node however should  * pass a non-NULL INFO as returned by read_info() (INFO->CONFLICTED = TRUE).  *  * DIRENT should reflect LOCAL_ABSPATH.  *  * All allocations made in SCRATCH_POOL.  *  * The remaining parameters correspond to get_dir_status(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_child_status
parameter_list|(
specifier|const
name|struct
name|walk_status_baton
modifier|*
name|wb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|info
parameter_list|,
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ignore_patterns
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_wc_status_func4_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dir_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_repos_uuid
decl_stmt|;
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|dir_info
decl_stmt|;
name|apr_array_header_t
modifier|*
name|collected_ignore_patterns
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_none
condition|)
name|dirent
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_single_info
argument_list|(
operator|&
name|dir_info
argument_list|,
name|wb
operator|->
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_repos_root_url_relpath
argument_list|(
operator|&
name|dir_repos_relpath
argument_list|,
operator|&
name|dir_repos_root_url
argument_list|,
operator|&
name|dir_repos_uuid
argument_list|,
name|dir_info
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wb
operator|->
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* An unversioned node with a tree conflict will see an INFO != NULL here,    * in which case the FALSE passed for UNVERSIONED_TREE_CONFLICTED has no    * effect and INFO->CONFLICTED counts.    * ### Maybe svn_wc__db_read_children_info() and read_info() should be more    * ### alike? */
name|SVN_ERR
argument_list|(
name|one_child_status
argument_list|(
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|parent_abspath
argument_list|,
name|info
argument_list|,
name|dirent
argument_list|,
name|dir_repos_root_url
argument_list|,
name|dir_repos_relpath
argument_list|,
name|dir_repos_uuid
argument_list|,
name|FALSE
argument_list|,
comment|/* unversioned_tree_conflicted */
operator|&
name|collected_ignore_patterns
argument_list|,
name|ignore_patterns
argument_list|,
name|svn_depth_empty
argument_list|,
name|get_all
argument_list|,
name|TRUE
argument_list|,
comment|/* no_ignore. This is an explicit target. */
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Helpers ***/
end_comment

begin_comment
comment|/* A faux status callback function for stashing STATUS item in an hash    (which is the BATON), keyed on PATH.  This implements the    svn_wc_status_func4_t interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hash_stash
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|stat_hash
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|hash_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|stat_hash
argument_list|)
decl_stmt|;
name|assert
argument_list|(
operator|!
name|svn_hash_gets
argument_list|(
name|stat_hash
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|stat_hash
argument_list|,
name|apr_pstrdup
argument_list|(
name|hash_pool
argument_list|,
name|path
argument_list|)
argument_list|,
name|svn_wc_dup_status3
argument_list|(
name|status
argument_list|,
name|hash_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Look up the key PATH in BATON->STATII.  IS_DIR_BATON indicates whether    baton is a struct *dir_baton or struct *file_baton.  If the value doesn't    yet exist, and the REPOS_NODE_STATUS indicates that this is an addition,    create a new status struct using the hash's pool.     If IS_DIR_BATON is true, THIS_DIR_BATON is a *dir_baton cotaining the out    of date (ood) information we want to set in BATON.  This is necessary    because this function tweaks the status of out-of-date directories    (BATON == THIS_DIR_BATON) and out-of-date directories' parents    (BATON == THIS_DIR_BATON->parent_baton).  In the latter case THIS_DIR_BATON    contains the ood info we want to bubble up to ancestor directories so these    accurately reflect the fact they have an ood descendant.     Merge REPOS_NODE_STATUS, REPOS_TEXT_STATUS and REPOS_PROP_STATUS into the    status structure's "network" fields.     Iff IS_DIR_BATON is true, DELETED_REV is used as follows, otherwise it    is ignored:         If REPOS_NODE_STATUS is svn_wc_status_deleted then DELETED_REV is        optionally the revision path was deleted, in all other cases it must        be set to SVN_INVALID_REVNUM.  If DELETED_REV is not        SVN_INVALID_REVNUM and REPOS_TEXT_STATUS is svn_wc_status_deleted,        then use DELETED_REV to set PATH's ood_last_cmt_rev field in BATON.        If DELETED_REV is SVN_INVALID_REVNUM and REPOS_NODE_STATUS is        svn_wc_status_deleted, set PATH's ood_last_cmt_rev to its parent's        ood_last_cmt_rev value - see comment below.     If a new struct was added, set the repos_lock to REPOS_LOCK. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tweak_statushash
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|void
modifier|*
name|this_dir_baton
parameter_list|,
name|svn_boolean_t
name|is_dir_baton
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|enum
name|svn_wc_status_kind
name|repos_node_status
parameter_list|,
name|enum
name|svn_wc_status_kind
name|repos_text_status
parameter_list|,
name|enum
name|svn_wc_status_kind
name|repos_prop_status
parameter_list|,
name|svn_revnum_t
name|deleted_rev
parameter_list|,
specifier|const
name|svn_lock_t
modifier|*
name|repos_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_status3_t
modifier|*
name|statstruct
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_hash_t
modifier|*
name|statushash
decl_stmt|;
if|if
condition|(
name|is_dir_baton
condition|)
name|statushash
operator|=
operator|(
operator|(
expr|struct
name|dir_baton
operator|*
operator|)
name|baton
operator|)
operator|->
name|statii
expr_stmt|;
else|else
name|statushash
operator|=
operator|(
operator|(
expr|struct
name|file_baton
operator|*
operator|)
name|baton
operator|)
operator|->
name|dir_baton
operator|->
name|statii
expr_stmt|;
name|pool
operator|=
name|apr_hash_pool_get
argument_list|(
name|statushash
argument_list|)
expr_stmt|;
comment|/* Is PATH already a hash-key? */
name|statstruct
operator|=
name|svn_hash_gets
argument_list|(
name|statushash
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
comment|/* If not, make it so. */
if|if
condition|(
operator|!
name|statstruct
condition|)
block|{
comment|/* If this item isn't being added, then we're most likely          dealing with a non-recursive (or at least partially          non-recursive) working copy.  Due to bugs in how the client          reports the state of non-recursive working copies, the          repository can send back responses about paths that don't          even exist locally.  Our best course here is just to ignore          those responses.  After all, if the client had reported          correctly in the first, that path would either be mentioned          as an 'add' or not mentioned at all, depending on how we          eventually fix the bugs in non-recursivity.  See issue          #2122 for details. */
if|if
condition|(
name|repos_node_status
operator|!=
name|svn_wc_status_added
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Use the public API to get a statstruct, and put it into the hash. */
name|SVN_ERR
argument_list|(
name|internal_status
argument_list|(
operator|&
name|statstruct
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|statstruct
operator|->
name|repos_lock
operator|=
name|repos_lock
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|statushash
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|statstruct
argument_list|)
expr_stmt|;
block|}
comment|/* Merge a repos "delete" + "add" into a single "replace". */
if|if
condition|(
operator|(
name|repos_node_status
operator|==
name|svn_wc_status_added
operator|)
operator|&&
operator|(
name|statstruct
operator|->
name|repos_node_status
operator|==
name|svn_wc_status_deleted
operator|)
condition|)
name|repos_node_status
operator|=
name|svn_wc_status_replaced
expr_stmt|;
comment|/* Tweak the structure's repos fields. */
if|if
condition|(
name|repos_node_status
condition|)
name|statstruct
operator|->
name|repos_node_status
operator|=
name|repos_node_status
expr_stmt|;
if|if
condition|(
name|repos_text_status
condition|)
name|statstruct
operator|->
name|repos_text_status
operator|=
name|repos_text_status
expr_stmt|;
if|if
condition|(
name|repos_prop_status
condition|)
name|statstruct
operator|->
name|repos_prop_status
operator|=
name|repos_prop_status
expr_stmt|;
comment|/* Copy out-of-date info. */
if|if
condition|(
name|is_dir_baton
condition|)
block|{
name|struct
name|dir_baton
modifier|*
name|b
init|=
name|this_dir_baton
decl_stmt|;
if|if
condition|(
operator|!
name|statstruct
operator|->
name|repos_relpath
operator|&&
name|b
operator|->
name|repos_relpath
condition|)
block|{
if|if
condition|(
name|statstruct
operator|->
name|repos_node_status
operator|==
name|svn_wc_status_deleted
condition|)
block|{
comment|/* When deleting PATH, BATON is for PATH's parent,                  so we must construct PATH's real statstruct->url. */
name|statstruct
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|b
operator|->
name|repos_relpath
argument_list|,
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
name|statstruct
operator|->
name|repos_relpath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|b
operator|->
name|repos_relpath
argument_list|)
expr_stmt|;
name|statstruct
operator|->
name|repos_root_url
operator|=
name|b
operator|->
name|edit_baton
operator|->
name|anchor_status
operator|->
name|repos_root_url
expr_stmt|;
name|statstruct
operator|->
name|repos_uuid
operator|=
name|b
operator|->
name|edit_baton
operator|->
name|anchor_status
operator|->
name|repos_uuid
expr_stmt|;
block|}
comment|/* The last committed date, and author for deleted items          isn't available. */
if|if
condition|(
name|statstruct
operator|->
name|repos_node_status
operator|==
name|svn_wc_status_deleted
condition|)
block|{
name|statstruct
operator|->
name|ood_kind
operator|=
name|statstruct
operator|->
name|kind
expr_stmt|;
comment|/* Pre 1.5 servers don't provide the revision a path was deleted.              So we punt and use the last committed revision of the path's              parent, which has some chance of being correct.  At worse it              is a higher revision than the path was deleted, but this is              better than nothing... */
if|if
condition|(
name|deleted_rev
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|statstruct
operator|->
name|ood_changed_rev
operator|=
operator|(
operator|(
expr|struct
name|dir_baton
operator|*
operator|)
name|baton
operator|)
operator|->
name|ood_changed_rev
expr_stmt|;
else|else
name|statstruct
operator|->
name|ood_changed_rev
operator|=
name|deleted_rev
expr_stmt|;
block|}
else|else
block|{
name|statstruct
operator|->
name|ood_kind
operator|=
name|b
operator|->
name|ood_kind
expr_stmt|;
name|statstruct
operator|->
name|ood_changed_rev
operator|=
name|b
operator|->
name|ood_changed_rev
expr_stmt|;
name|statstruct
operator|->
name|ood_changed_date
operator|=
name|b
operator|->
name|ood_changed_date
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ood_changed_author
condition|)
name|statstruct
operator|->
name|ood_changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|b
operator|->
name|ood_changed_author
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|file_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|statstruct
operator|->
name|ood_changed_rev
operator|=
name|b
operator|->
name|ood_changed_rev
expr_stmt|;
name|statstruct
operator|->
name|ood_changed_date
operator|=
name|b
operator|->
name|ood_changed_date
expr_stmt|;
if|if
condition|(
operator|!
name|statstruct
operator|->
name|repos_relpath
operator|&&
name|b
operator|->
name|repos_relpath
condition|)
block|{
name|statstruct
operator|->
name|repos_relpath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|b
operator|->
name|repos_relpath
argument_list|)
expr_stmt|;
name|statstruct
operator|->
name|repos_root_url
operator|=
name|b
operator|->
name|edit_baton
operator|->
name|anchor_status
operator|->
name|repos_root_url
expr_stmt|;
name|statstruct
operator|->
name|repos_uuid
operator|=
name|b
operator|->
name|edit_baton
operator|->
name|anchor_status
operator|->
name|repos_uuid
expr_stmt|;
block|}
name|statstruct
operator|->
name|ood_kind
operator|=
name|b
operator|->
name|ood_kind
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ood_changed_author
condition|)
name|statstruct
operator|->
name|ood_changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|b
operator|->
name|ood_changed_author
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Returns the URL for DB */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_dir_repos_relpath
parameter_list|(
specifier|const
name|struct
name|dir_baton
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* If we have no name, we're the root, return the anchor URL. */
if|if
condition|(
operator|!
name|db
operator|->
name|name
condition|)
return|return
name|db
operator|->
name|edit_baton
operator|->
name|anchor_status
operator|->
name|repos_relpath
return|;
else|else
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|db
operator|->
name|parent_baton
decl_stmt|;
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
init|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|statii
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|)
decl_stmt|;
comment|/* Note that status->repos_relpath could be NULL in the case of a missing        * directory, which means we need to recurse up another level to get        * a useful relpath. */
if|if
condition|(
name|status
operator|&&
name|status
operator|->
name|repos_relpath
condition|)
return|return
name|status
operator|->
name|repos_relpath
return|;
name|repos_relpath
operator|=
name|find_dir_repos_relpath
argument_list|(
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_relpath_join
argument_list|(
name|repos_relpath
argument_list|,
name|db
operator|->
name|name
argument_list|,
name|pool
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new dir_baton for subdir PATH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_dir_baton
parameter_list|(
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|edit_baton
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
specifier|const
name|svn_wc_status3_t
modifier|*
name|status_in_parent
decl_stmt|;
name|apr_pool_t
modifier|*
name|dir_pool
decl_stmt|;
if|if
condition|(
name|parent_baton
condition|)
name|dir_pool
operator|=
name|svn_pool_create
argument_list|(
name|parent_baton
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
name|dir_pool
operator|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|d
operator|=
name|apr_pcalloc
argument_list|(
name|dir_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|path
operator|||
operator|(
operator|!
name|pb
operator|)
argument_list|)
expr_stmt|;
comment|/* Construct the absolute path of this directory. */
if|if
condition|(
name|pb
condition|)
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|path
argument_list|,
name|dir_pool
argument_list|)
expr_stmt|;
else|else
name|local_abspath
operator|=
name|eb
operator|->
name|anchor_abspath
expr_stmt|;
comment|/* Finish populating the baton members. */
name|d
operator|->
name|pool
operator|=
name|dir_pool
expr_stmt|;
name|d
operator|->
name|local_abspath
operator|=
name|local_abspath
expr_stmt|;
name|d
operator|->
name|name
operator|=
name|path
condition|?
name|svn_dirent_basename
argument_list|(
name|path
argument_list|,
name|dir_pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|d
operator|->
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|d
operator|->
name|parent_baton
operator|=
name|parent_baton
expr_stmt|;
name|d
operator|->
name|statii
operator|=
name|apr_hash_make
argument_list|(
name|dir_pool
argument_list|)
expr_stmt|;
name|d
operator|->
name|ood_changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|d
operator|->
name|ood_changed_date
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|repos_relpath
operator|=
name|find_dir_repos_relpath
argument_list|(
name|d
argument_list|,
name|dir_pool
argument_list|)
expr_stmt|;
name|d
operator|->
name|ood_kind
operator|=
name|svn_node_dir
expr_stmt|;
name|d
operator|->
name|ood_changed_author
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pb
condition|)
block|{
if|if
condition|(
name|pb
operator|->
name|excluded
condition|)
name|d
operator|->
name|excluded
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|pb
operator|->
name|depth
operator|==
name|svn_depth_immediates
condition|)
name|d
operator|->
name|depth
operator|=
name|svn_depth_empty
expr_stmt|;
elseif|else
if|if
condition|(
name|pb
operator|->
name|depth
operator|==
name|svn_depth_files
operator|||
name|pb
operator|->
name|depth
operator|==
name|svn_depth_empty
condition|)
name|d
operator|->
name|excluded
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|pb
operator|->
name|depth
operator|==
name|svn_depth_unknown
condition|)
comment|/* This is only tentative, it can be overridden from d's entry            later. */
name|d
operator|->
name|depth
operator|=
name|svn_depth_unknown
expr_stmt|;
else|else
name|d
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|depth
operator|=
name|eb
operator|->
name|default_depth
expr_stmt|;
block|}
comment|/* Get the status for this path's children.  Of course, we only want      to do this if the path is versioned as a directory. */
if|if
condition|(
name|pb
condition|)
name|status_in_parent
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|statii
argument_list|,
name|d
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
else|else
name|status_in_parent
operator|=
name|eb
operator|->
name|anchor_status
expr_stmt|;
if|if
condition|(
name|status_in_parent
operator|&&
name|status_in_parent
operator|->
name|versioned
operator|&&
operator|(
name|status_in_parent
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
operator|&&
operator|(
operator|!
name|d
operator|->
name|excluded
operator|)
operator|&&
operator|(
name|d
operator|->
name|depth
operator|==
name|svn_depth_unknown
operator|||
name|d
operator|->
name|depth
operator|==
name|svn_depth_infinity
operator|||
name|d
operator|->
name|depth
operator|==
name|svn_depth_files
operator|||
name|d
operator|->
name|depth
operator|==
name|svn_depth_immediates
operator|)
condition|)
block|{
specifier|const
name|svn_wc_status3_t
modifier|*
name|this_dir_status
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|ignores
init|=
name|eb
operator|->
name|ignores
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dir_status
argument_list|(
operator|&
name|eb
operator|->
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|status_in_parent
operator|->
name|repos_root_url
argument_list|,
name|NULL
comment|/*parent_repos_relpath*/
argument_list|,
name|status_in_parent
operator|->
name|repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* dirent */
argument_list|,
name|ignores
argument_list|,
name|d
operator|->
name|depth
operator|==
name|svn_depth_files
condition|?
name|svn_depth_files
else|:
name|svn_depth_immediates
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|hash_stash
argument_list|,
name|d
operator|->
name|statii
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|dir_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we found a depth here, it should govern. */
name|this_dir_status
operator|=
name|svn_hash_gets
argument_list|(
name|d
operator|->
name|statii
argument_list|,
name|d
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_dir_status
operator|&&
name|this_dir_status
operator|->
name|versioned
operator|&&
operator|(
name|d
operator|->
name|depth
operator|==
name|svn_depth_unknown
operator|||
name|d
operator|->
name|depth
operator|>
name|status_in_parent
operator|->
name|depth
operator|)
condition|)
block|{
name|d
operator|->
name|depth
operator|=
name|this_dir_status
operator|->
name|depth
expr_stmt|;
block|}
block|}
operator|*
name|dir_baton
operator|=
name|d
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make a file baton, using a new subpool of PARENT_DIR_BATON's pool.    NAME is just one component, not a path. */
end_comment

begin_function
specifier|static
name|struct
name|file_baton
modifier|*
name|make_file_baton
parameter_list|(
name|struct
name|dir_baton
modifier|*
name|parent_dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|f
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Finish populating the baton members. */
name|f
operator|->
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|svn_dirent_basename
argument_list|(
name|f
operator|->
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|f
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|f
operator|->
name|dir_baton
operator|=
name|pb
expr_stmt|;
name|f
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
name|f
operator|->
name|ood_changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|f
operator|->
name|ood_changed_date
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|find_dir_repos_relpath
argument_list|(
name|pb
argument_list|,
name|pool
argument_list|)
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|f
operator|->
name|ood_kind
operator|=
name|svn_node_file
expr_stmt|;
name|f
operator|->
name|ood_changed_author
operator|=
name|NULL
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/**  * Return a boolean answer to the question "Is @a status something that  * should be reported?".  @a no_ignore and @a get_all are the same as  * svn_wc_get_status_editor4().  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_sendable_status
parameter_list|(
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|)
block|{
comment|/* If the repository status was touched at all, it's interesting. */
if|if
condition|(
name|status
operator|->
name|repos_node_status
operator|!=
name|svn_wc_status_none
condition|)
return|return
name|TRUE
return|;
comment|/* If there is a lock in the repository, send it. */
if|if
condition|(
name|status
operator|->
name|repos_lock
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|status
operator|->
name|conflicted
condition|)
return|return
name|TRUE
return|;
comment|/* If the item is ignored, and we don't want ignores, skip it. */
if|if
condition|(
operator|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_ignored
operator|)
operator|&&
operator|(
operator|!
name|no_ignore
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we want everything, we obviously want this single-item subset      of everything. */
if|if
condition|(
name|get_all
condition|)
return|return
name|TRUE
return|;
comment|/* If the item is unversioned, display it. */
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_unversioned
condition|)
return|return
name|TRUE
return|;
comment|/* If the text, property or tree state is interesting, send it. */
if|if
condition|(
operator|(
name|status
operator|->
name|node_status
operator|!=
name|svn_wc_status_none
operator|&&
operator|(
name|status
operator|->
name|node_status
operator|!=
name|svn_wc_status_normal
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* If it's switched, send it. */
if|if
condition|(
name|status
operator|->
name|switched
condition|)
return|return
name|TRUE
return|;
comment|/* If there is a lock token, send it. */
if|if
condition|(
name|status
operator|->
name|versioned
operator|&&
name|status
operator|->
name|lock
condition|)
return|return
name|TRUE
return|;
comment|/* If the entry is associated with a changelist, send it. */
if|if
condition|(
name|status
operator|->
name|changelist
condition|)
return|return
name|TRUE
return|;
comment|/* Otherwise, don't send it. */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Baton for mark_status. */
end_comment

begin_struct
struct|struct
name|status_baton
block|{
name|svn_wc_status_func4_t
name|real_status_func
decl_stmt|;
comment|/* real status function */
name|void
modifier|*
name|real_status_baton
decl_stmt|;
comment|/* real status baton */
block|}
struct|;
end_struct

begin_comment
comment|/* A status callback function which wraps the *real* status    function/baton.   It simply sets the "repos_node_status" field of the    STATUS to svn_wc_status_deleted and passes it off to the real    status func/baton. Implements svn_wc_status_func4_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_deleted
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|status_baton
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
name|svn_wc_status3_t
modifier|*
name|new_status
init|=
name|svn_wc_dup_status3
argument_list|(
name|status
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|new_status
operator|->
name|repos_node_status
operator|=
name|svn_wc_status_deleted
expr_stmt|;
return|return
name|sb
operator|->
name|real_status_func
argument_list|(
name|sb
operator|->
name|real_status_baton
argument_list|,
name|local_abspath
argument_list|,
name|new_status
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle a directory's STATII hash.  EB is the edit baton.  DIR_PATH    and DIR_ENTRY are the on-disk path and entry, respectively, for the    directory itself.  Descend into subdirectories according to DEPTH.    Also, if DIR_WAS_DELETED is set, each status that is reported    through this function will have its repos_text_status field showing    a deletion.  Use POOL for all allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_statii
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_repos_uuid
parameter_list|,
name|apr_hash_t
modifier|*
name|statii
parameter_list|,
name|svn_boolean_t
name|dir_was_deleted
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|ignores
init|=
name|eb
operator|->
name|ignores
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_wc_status_func4_t
name|status_func
init|=
name|eb
operator|->
name|status_func
decl_stmt|;
name|void
modifier|*
name|status_baton
init|=
name|eb
operator|->
name|status_baton
decl_stmt|;
name|struct
name|status_baton
name|sb
decl_stmt|;
if|if
condition|(
name|dir_was_deleted
condition|)
block|{
name|sb
operator|.
name|real_status_func
operator|=
name|eb
operator|->
name|status_func
expr_stmt|;
name|sb
operator|.
name|real_status_baton
operator|=
name|eb
operator|->
name|status_baton
expr_stmt|;
name|status_func
operator|=
name|mark_deleted
expr_stmt|;
name|status_baton
operator|=
operator|&
name|sb
expr_stmt|;
block|}
comment|/* Loop over all the statii still in our hash, handling each one. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|statii
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_wc_status3_t
modifier|*
name|status
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
comment|/* Clear the subpool. */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Now, handle the status.  We don't recurse for svn_depth_immediates          because we already have the subdirectories' statii. */
if|if
condition|(
name|status
operator|->
name|versioned
operator|&&
name|status
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
operator|(
name|depth
operator|==
name|svn_depth_unknown
operator|||
name|depth
operator|==
name|svn_depth_infinity
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_dir_status
argument_list|(
operator|&
name|eb
operator|->
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|dir_repos_root_url
argument_list|,
name|dir_repos_relpath
argument_list|,
name|dir_repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* dirent */
argument_list|,
name|ignores
argument_list|,
name|depth
argument_list|,
name|eb
operator|->
name|get_all
argument_list|,
name|eb
operator|->
name|no_ignore
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir_was_deleted
condition|)
name|status
operator|->
name|repos_node_status
operator|=
name|svn_wc_status_deleted
expr_stmt|;
if|if
condition|(
name|is_sendable_status
argument_list|(
name|status
argument_list|,
name|eb
operator|->
name|no_ignore
argument_list|,
name|eb
operator|->
name|get_all
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
call|(
name|eb
operator|->
name|status_func
call|)
argument_list|(
name|eb
operator|->
name|status_baton
argument_list|,
name|local_abspath
argument_list|,
name|status
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy the subpool. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** The callbacks we'll plug into an svn_delta_editor_t structure. ***/
end_comment

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_target_revision
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
operator|*
operator|(
name|eb
operator|->
name|target_revision
operator|)
operator|=
name|target_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|eb
operator|->
name|root_opened
operator|=
name|TRUE
expr_stmt|;
return|return
name|make_dir_baton
argument_list|(
name|dir_baton
argument_list|,
name|NULL
argument_list|,
name|eb
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* Note:  when something is deleted, it's okay to tweak the      statushash immediately.  No need to wait until close_file or      close_dir, because there's no risk of having to honor the 'added'      flag.  We already know this item exists in the working copy. */
name|SVN_ERR
argument_list|(
name|tweak_statushash
argument_list|(
name|db
argument_list|,
name|db
argument_list|,
name|TRUE
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|svn_wc_status_deleted
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|revision
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the parent dir -- it lost an entry (unless that parent dir      is the root node and we're not supposed to report on the root      node).  */
if|if
condition|(
name|db
operator|->
name|parent_baton
operator|&&
operator|(
operator|!
operator|*
name|eb
operator|->
name|target_basename
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|tweak_statushash
argument_list|(
name|db
operator|->
name|parent_baton
argument_list|,
name|db
argument_list|,
name|TRUE
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_wc_status_modified
argument_list|,
name|svn_wc_status_modified
argument_list|,
literal|0
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_dir_baton
argument_list|(
name|child_baton
argument_list|,
name|path
argument_list|,
name|eb
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make this dir as added. */
name|new_db
operator|=
operator|*
name|child_baton
expr_stmt|;
name|new_db
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
comment|/* Mark the parent as changed;  it gained an entry. */
name|pb
operator|->
name|text_changed
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
return|return
name|make_dir_baton
argument_list|(
name|child_baton
argument_list|,
name|path
argument_list|,
name|pb
operator|->
name|edit_baton
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
if|if
condition|(
name|svn_wc_is_normal_prop
argument_list|(
name|name
argument_list|)
condition|)
name|db
operator|->
name|prop_changed
operator|=
name|TRUE
expr_stmt|;
comment|/* Note any changes to the repository. */
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|)
operator|==
literal|0
condition|)
name|db
operator|->
name|ood_changed_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|)
operator|==
literal|0
condition|)
name|db
operator|->
name|ood_changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|pool
argument_list|,
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_time_t
name|tm
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|tm
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|ood_changed_date
operator|=
name|tm
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|db
operator|->
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|db
operator|->
name|pool
decl_stmt|;
comment|/* If nothing has changed and directory has no out of      date descendants, return. */
if|if
condition|(
name|db
operator|->
name|added
operator|||
name|db
operator|->
name|prop_changed
operator|||
name|db
operator|->
name|text_changed
operator|||
name|db
operator|->
name|ood_changed_rev
operator|!=
name|SVN_INVALID_REVNUM
condition|)
block|{
name|enum
name|svn_wc_status_kind
name|repos_node_status
decl_stmt|;
name|enum
name|svn_wc_status_kind
name|repos_text_status
decl_stmt|;
name|enum
name|svn_wc_status_kind
name|repos_prop_status
decl_stmt|;
comment|/* If this is a new directory, add it to the statushash. */
if|if
condition|(
name|db
operator|->
name|added
condition|)
block|{
name|repos_node_status
operator|=
name|svn_wc_status_added
expr_stmt|;
name|repos_text_status
operator|=
name|svn_wc_status_none
expr_stmt|;
name|repos_prop_status
operator|=
name|db
operator|->
name|prop_changed
condition|?
name|svn_wc_status_added
else|:
name|svn_wc_status_none
expr_stmt|;
block|}
else|else
block|{
name|repos_node_status
operator|=
operator|(
name|db
operator|->
name|text_changed
operator|||
name|db
operator|->
name|prop_changed
operator|)
condition|?
name|svn_wc_status_modified
else|:
name|svn_wc_status_none
expr_stmt|;
name|repos_text_status
operator|=
name|db
operator|->
name|text_changed
condition|?
name|svn_wc_status_modified
else|:
name|svn_wc_status_none
expr_stmt|;
name|repos_prop_status
operator|=
name|db
operator|->
name|prop_changed
condition|?
name|svn_wc_status_modified
else|:
name|svn_wc_status_none
expr_stmt|;
block|}
comment|/* Maybe add this directory to its parent's status hash.  Note          that tweak_statushash won't do anything if repos_text_status          is not svn_wc_status_added. */
if|if
condition|(
name|pb
condition|)
block|{
comment|/* ### When we add directory locking, we need to find a              ### directory lock here. */
name|SVN_ERR
argument_list|(
name|tweak_statushash
argument_list|(
name|pb
argument_list|,
name|db
argument_list|,
name|TRUE
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|repos_node_status
argument_list|,
name|repos_text_status
argument_list|,
name|repos_prop_status
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're editing the root dir of the WC.  As its repos              status info isn't otherwise set, set it directly to              trigger invocation of the status callback below. */
name|eb
operator|->
name|anchor_status
operator|->
name|repos_node_status
operator|=
name|repos_node_status
expr_stmt|;
name|eb
operator|->
name|anchor_status
operator|->
name|repos_prop_status
operator|=
name|repos_prop_status
expr_stmt|;
name|eb
operator|->
name|anchor_status
operator|->
name|repos_text_status
operator|=
name|repos_text_status
expr_stmt|;
comment|/* If the root dir is out of date set the ood info directly too. */
if|if
condition|(
name|db
operator|->
name|ood_changed_rev
operator|!=
name|eb
operator|->
name|anchor_status
operator|->
name|revision
condition|)
block|{
name|eb
operator|->
name|anchor_status
operator|->
name|ood_changed_rev
operator|=
name|db
operator|->
name|ood_changed_rev
expr_stmt|;
name|eb
operator|->
name|anchor_status
operator|->
name|ood_changed_date
operator|=
name|db
operator|->
name|ood_changed_date
expr_stmt|;
name|eb
operator|->
name|anchor_status
operator|->
name|ood_kind
operator|=
name|db
operator|->
name|ood_kind
expr_stmt|;
name|eb
operator|->
name|anchor_status
operator|->
name|ood_changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|db
operator|->
name|ood_changed_author
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Handle this directory's statuses, and then note in the parent      that this has been done. */
if|if
condition|(
name|pb
operator|&&
operator|!
name|db
operator|->
name|excluded
condition|)
block|{
name|svn_boolean_t
name|was_deleted
init|=
name|FALSE
decl_stmt|;
specifier|const
name|svn_wc_status3_t
modifier|*
name|dir_status
decl_stmt|;
comment|/* See if the directory was deleted or replaced. */
name|dir_status
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|statii
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_status
operator|&&
operator|(
operator|(
name|dir_status
operator|->
name|repos_node_status
operator|==
name|svn_wc_status_deleted
operator|)
operator|||
operator|(
name|dir_status
operator|->
name|repos_node_status
operator|==
name|svn_wc_status_replaced
operator|)
operator|)
condition|)
name|was_deleted
operator|=
name|TRUE
expr_stmt|;
comment|/* Now do the status reporting. */
name|SVN_ERR
argument_list|(
name|handle_statii
argument_list|(
name|eb
argument_list|,
name|dir_status
condition|?
name|dir_status
operator|->
name|repos_root_url
else|:
name|NULL
argument_list|,
name|dir_status
condition|?
name|dir_status
operator|->
name|repos_relpath
else|:
name|NULL
argument_list|,
name|dir_status
condition|?
name|dir_status
operator|->
name|repos_uuid
else|:
name|NULL
argument_list|,
name|db
operator|->
name|statii
argument_list|,
name|was_deleted
argument_list|,
name|db
operator|->
name|depth
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_status
operator|&&
name|is_sendable_status
argument_list|(
name|dir_status
argument_list|,
name|eb
operator|->
name|no_ignore
argument_list|,
name|eb
operator|->
name|get_all
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
call|(
name|eb
operator|->
name|status_func
call|)
argument_list|(
name|eb
operator|->
name|status_baton
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|dir_status
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|statii
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pb
condition|)
block|{
comment|/* If this is the top-most directory, and the operation had a          target, we should only report the target. */
if|if
condition|(
operator|*
name|eb
operator|->
name|target_basename
condition|)
block|{
specifier|const
name|svn_wc_status3_t
modifier|*
name|tgt_status
decl_stmt|;
name|tgt_status
operator|=
name|svn_hash_gets
argument_list|(
name|db
operator|->
name|statii
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgt_status
condition|)
block|{
if|if
condition|(
name|tgt_status
operator|->
name|versioned
operator|&&
name|tgt_status
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_dir_status
argument_list|(
operator|&
name|eb
operator|->
name|wb
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* dirent */
argument_list|,
name|eb
operator|->
name|ignores
argument_list|,
name|eb
operator|->
name|default_depth
argument_list|,
name|eb
operator|->
name|get_all
argument_list|,
name|eb
operator|->
name|no_ignore
argument_list|,
name|eb
operator|->
name|status_func
argument_list|,
name|eb
operator|->
name|status_baton
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_sendable_status
argument_list|(
name|tgt_status
argument_list|,
name|eb
operator|->
name|no_ignore
argument_list|,
name|eb
operator|->
name|get_all
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
call|(
name|eb
operator|->
name|status_func
call|)
argument_list|(
name|eb
operator|->
name|status_baton
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|tgt_status
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise, we report on all our children and ourself.              Note that our directory couldn't have been deleted,              because it is the root of the edit drive. */
name|SVN_ERR
argument_list|(
name|handle_statii
argument_list|(
name|eb
argument_list|,
name|eb
operator|->
name|anchor_status
operator|->
name|repos_root_url
argument_list|,
name|eb
operator|->
name|anchor_status
operator|->
name|repos_relpath
argument_list|,
name|eb
operator|->
name|anchor_status
operator|->
name|repos_uuid
argument_list|,
name|db
operator|->
name|statii
argument_list|,
name|FALSE
argument_list|,
name|eb
operator|->
name|default_depth
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sendable_status
argument_list|(
name|eb
operator|->
name|anchor_status
argument_list|,
name|eb
operator|->
name|no_ignore
argument_list|,
name|eb
operator|->
name|get_all
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
call|(
name|eb
operator|->
name|status_func
call|)
argument_list|(
name|eb
operator|->
name|status_baton
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|anchor_status
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|anchor_status
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|svn_pool_clear
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Clear baton and its pool */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|new_fb
init|=
name|make_file_baton
argument_list|(
name|pb
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* Mark parent dir as changed */
name|pb
operator|->
name|text_changed
operator|=
name|TRUE
expr_stmt|;
comment|/* Make this file as added. */
name|new_fb
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
operator|*
name|file_baton
operator|=
name|new_fb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|new_fb
init|=
name|make_file_baton
argument_list|(
name|pb
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
operator|*
name|file_baton
operator|=
name|new_fb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
comment|/* Mark file as having textual mods. */
name|fb
operator|->
name|text_changed
operator|=
name|TRUE
expr_stmt|;
comment|/* Send back a NULL window handler -- we don't need the actual diffs. */
operator|*
name|handler_baton
operator|=
name|NULL
expr_stmt|;
operator|*
name|handler
operator|=
name|svn_delta_noop_window_handler
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
if|if
condition|(
name|svn_wc_is_normal_prop
argument_list|(
name|name
argument_list|)
condition|)
name|fb
operator|->
name|prop_changed
operator|=
name|TRUE
expr_stmt|;
comment|/* Note any changes to the repository. */
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|->
name|ood_changed_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|->
name|ood_changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|fb
operator|->
name|dir_baton
operator|->
name|pool
argument_list|,
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_time_t
name|tm
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|tm
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|fb
operator|->
name|dir_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|ood_changed_date
operator|=
name|tm
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_checksum
parameter_list|,
comment|/* ignored, as we receive no data */
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|enum
name|svn_wc_status_kind
name|repos_node_status
decl_stmt|;
name|enum
name|svn_wc_status_kind
name|repos_text_status
decl_stmt|;
name|enum
name|svn_wc_status_kind
name|repos_prop_status
decl_stmt|;
specifier|const
name|svn_lock_t
modifier|*
name|repos_lock
init|=
name|NULL
decl_stmt|;
comment|/* If nothing has changed, return. */
if|if
condition|(
operator|!
operator|(
name|fb
operator|->
name|added
operator|||
name|fb
operator|->
name|prop_changed
operator|||
name|fb
operator|->
name|text_changed
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If this is a new file, add it to the statushash. */
if|if
condition|(
name|fb
operator|->
name|added
condition|)
block|{
name|repos_node_status
operator|=
name|svn_wc_status_added
expr_stmt|;
name|repos_text_status
operator|=
name|fb
operator|->
name|text_changed
condition|?
name|svn_wc_status_modified
else|:
literal|0
comment|/* don't tweak */
expr_stmt|;
name|repos_prop_status
operator|=
name|fb
operator|->
name|prop_changed
condition|?
name|svn_wc_status_modified
else|:
literal|0
comment|/* don't tweak */
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|edit_baton
operator|->
name|wb
operator|.
name|repos_locks
condition|)
block|{
specifier|const
name|char
modifier|*
name|dir_repos_relpath
init|=
name|find_dir_repos_relpath
argument_list|(
name|fb
operator|->
name|dir_baton
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* repos_lock still uses the deprecated filesystem absolute path              format */
specifier|const
name|char
modifier|*
name|repos_relpath
init|=
name|svn_relpath_join
argument_list|(
name|dir_repos_relpath
argument_list|,
name|fb
operator|->
name|name
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|repos_lock
operator|=
name|svn_hash_gets
argument_list|(
name|fb
operator|->
name|edit_baton
operator|->
name|wb
operator|.
name|repos_locks
argument_list|,
name|svn_fspath__join
argument_list|(
literal|"/"
argument_list|,
name|repos_relpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|repos_node_status
operator|=
operator|(
name|fb
operator|->
name|text_changed
operator|||
name|fb
operator|->
name|prop_changed
operator|)
condition|?
name|svn_wc_status_modified
else|:
literal|0
comment|/* don't tweak */
expr_stmt|;
name|repos_text_status
operator|=
name|fb
operator|->
name|text_changed
condition|?
name|svn_wc_status_modified
else|:
literal|0
comment|/* don't tweak */
expr_stmt|;
name|repos_prop_status
operator|=
name|fb
operator|->
name|prop_changed
condition|?
name|svn_wc_status_modified
else|:
literal|0
comment|/* don't tweak */
expr_stmt|;
block|}
return|return
name|tweak_statushash
argument_list|(
name|fb
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|fb
operator|->
name|edit_baton
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|repos_node_status
argument_list|,
name|repos_text_status
argument_list|,
name|repos_prop_status
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|repos_lock
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
comment|/* If we get here and the root was not opened as part of the edit,      we need to transmit statuses for everything.  Otherwise, we      should be done. */
if|if
condition|(
name|eb
operator|->
name|root_opened
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc_walk_status
argument_list|(
name|eb
operator|->
name|wc_ctx
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|eb
operator|->
name|default_depth
argument_list|,
name|eb
operator|->
name|get_all
argument_list|,
name|eb
operator|->
name|no_ignore
argument_list|,
name|FALSE
argument_list|,
name|eb
operator|->
name|ignores
argument_list|,
name|eb
operator|->
name|status_func
argument_list|,
name|eb
operator|->
name|status_baton
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public API ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_status_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|void
modifier|*
modifier|*
name|set_locks_baton
parameter_list|,
name|svn_revnum_t
modifier|*
name|edit_revision
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target_basename
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|depth_as_sticky
parameter_list|,
name|svn_boolean_t
name|server_performs_filtering
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ignore_patterns
parameter_list|,
name|svn_wc_status_func4_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
decl_stmt|;
name|svn_delta_editor_t
modifier|*
name|tree_editor
init|=
name|svn_delta_default_editor
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|void
modifier|*
name|inner_baton
decl_stmt|;
name|struct
name|svn_wc__shim_fetch_baton_t
modifier|*
name|sfb
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|inner_editor
decl_stmt|;
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
comment|/* Construct an edit baton. */
name|eb
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|default_depth
operator|=
name|depth
expr_stmt|;
name|eb
operator|->
name|target_revision
operator|=
name|edit_revision
expr_stmt|;
name|eb
operator|->
name|db
operator|=
name|wc_ctx
operator|->
name|db
expr_stmt|;
name|eb
operator|->
name|wc_ctx
operator|=
name|wc_ctx
expr_stmt|;
name|eb
operator|->
name|get_all
operator|=
name|get_all
expr_stmt|;
name|eb
operator|->
name|no_ignore
operator|=
name|no_ignore
expr_stmt|;
name|eb
operator|->
name|status_func
operator|=
name|status_func
expr_stmt|;
name|eb
operator|->
name|status_baton
operator|=
name|status_baton
expr_stmt|;
name|eb
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|eb
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|eb
operator|->
name|anchor_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|anchor_abspath
argument_list|)
expr_stmt|;
name|eb
operator|->
name|target_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|anchor_abspath
argument_list|,
name|target_basename
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|target_basename
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|target_basename
argument_list|)
expr_stmt|;
name|eb
operator|->
name|root_opened
operator|=
name|FALSE
expr_stmt|;
name|eb
operator|->
name|wb
operator|.
name|db
operator|=
name|wc_ctx
operator|->
name|db
expr_stmt|;
name|eb
operator|->
name|wb
operator|.
name|target_abspath
operator|=
name|eb
operator|->
name|target_abspath
expr_stmt|;
name|eb
operator|->
name|wb
operator|.
name|ignore_text_mods
operator|=
name|FALSE
expr_stmt|;
name|eb
operator|->
name|wb
operator|.
name|repos_locks
operator|=
name|NULL
expr_stmt|;
name|eb
operator|->
name|wb
operator|.
name|repos_root
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_externals_defined_below
argument_list|(
operator|&
name|eb
operator|->
name|wb
operator|.
name|externals
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the caller-provided ignore patterns if provided; the build-time      configured defaults otherwise. */
if|if
condition|(
name|ignore_patterns
condition|)
block|{
name|eb
operator|->
name|ignores
operator|=
name|ignore_patterns
expr_stmt|;
block|}
else|else
block|{
name|apr_array_header_t
modifier|*
name|ignores
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_get_default_ignores
argument_list|(
operator|&
name|ignores
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|ignores
operator|=
name|ignores
expr_stmt|;
block|}
comment|/* The edit baton's status structure maps to PATH, and the editor      have to be aware of whether that is the anchor or the target. */
name|SVN_ERR
argument_list|(
name|internal_status
argument_list|(
operator|&
operator|(
name|eb
operator|->
name|anchor_status
operator|)
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|anchor_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Construct an editor. */
name|tree_editor
operator|->
name|set_target_revision
operator|=
name|set_target_revision
expr_stmt|;
name|tree_editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|tree_editor
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|tree_editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|tree_editor
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
name|tree_editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|tree_editor
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|tree_editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|tree_editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|tree_editor
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|tree_editor
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|tree_editor
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|tree_editor
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
name|inner_editor
operator|=
name|tree_editor
expr_stmt|;
name|inner_baton
operator|=
name|eb
expr_stmt|;
if|if
condition|(
operator|!
name|server_performs_filtering
operator|&&
operator|!
name|depth_as_sticky
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__ambient_depth_filter_editor
argument_list|(
operator|&
name|inner_editor
argument_list|,
operator|&
name|inner_baton
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|anchor_abspath
argument_list|,
name|target_basename
argument_list|,
name|inner_editor
argument_list|,
name|inner_baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Conjoin a cancellation editor with our status editor. */
name|SVN_ERR
argument_list|(
name|svn_delta_get_cancellation_editor
argument_list|(
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|inner_editor
argument_list|,
name|inner_baton
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_locks_baton
condition|)
operator|*
name|set_locks_baton
operator|=
name|eb
expr_stmt|;
name|sfb
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sfb
argument_list|)
argument_list|)
expr_stmt|;
name|sfb
operator|->
name|db
operator|=
name|wc_ctx
operator|->
name|db
expr_stmt|;
name|sfb
operator|->
name|base_abspath
operator|=
name|eb
operator|->
name|anchor_abspath
expr_stmt|;
name|sfb
operator|->
name|fetch_base
operator|=
name|FALSE
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_kind_func
operator|=
name|svn_wc__fetch_kind_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_props_func
operator|=
name|svn_wc__fetch_props_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_base_func
operator|=
name|svn_wc__fetch_base_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_baton
operator|=
name|sfb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor__insert_shims
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|*
name|editor
argument_list|,
operator|*
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|shim_callbacks
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Like svn_io_stat_dirent, but works case sensitive inside working    copies. Before 1.8 we handled this with a selection filter inside    a directory */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stat_wc_dirent_case_sensitive
parameter_list|(
specifier|const
name|svn_io_dirent2_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_wcroot
decl_stmt|;
comment|/* The wcroot is "" inside the wc; handle it as not in the wc, as      the case of the root is indifferent to us. */
comment|/* Note that for performance this is really just a few hashtable lookups,      as we just used local_abspath for a db call in both our callers */
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_wcroot
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
name|dirent
argument_list|,
name|local_abspath
argument_list|,
operator|!
name|is_wcroot
comment|/* verify_truename */
argument_list|,
name|TRUE
comment|/* ignore_enoent */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_walk_status
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|ignore_text_mods
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ignore_patterns
parameter_list|,
name|svn_wc_status_func4_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|walk_status_baton
name|wb
decl_stmt|;
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
decl_stmt|;
specifier|const
name|struct
name|svn_wc__db_info_t
modifier|*
name|info
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|wb
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|wb
operator|.
name|target_abspath
operator|=
name|local_abspath
expr_stmt|;
name|wb
operator|.
name|ignore_text_mods
operator|=
name|ignore_text_mods
expr_stmt|;
name|wb
operator|.
name|repos_root
operator|=
name|NULL
expr_stmt|;
name|wb
operator|.
name|repos_locks
operator|=
name|NULL
expr_stmt|;
comment|/* Use the caller-provided ignore patterns if provided; the build-time      configured defaults otherwise. */
if|if
condition|(
operator|!
name|ignore_patterns
condition|)
block|{
name|apr_array_header_t
modifier|*
name|ignores
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_get_default_ignores
argument_list|(
operator|&
name|ignores
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_patterns
operator|=
name|ignores
expr_stmt|;
block|}
name|err
operator|=
name|svn_wc__db_read_single_info
argument_list|(
operator|&
name|info
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|info
operator|=
name|NULL
expr_stmt|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|wb
operator|.
name|externals
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|dirent
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_externals_defined_below
argument_list|(
operator|&
name|wb
operator|.
name|externals
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stat_wc_dirent_case_sensitive
argument_list|(
operator|&
name|dirent
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|&&
name|info
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
name|info
operator|->
name|status
operator|!=
name|svn_wc__db_status_not_present
operator|&&
name|info
operator|->
name|status
operator|!=
name|svn_wc__db_status_excluded
operator|&&
name|info
operator|->
name|status
operator|!=
name|svn_wc__db_status_server_excluded
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_dir_status
argument_list|(
operator|&
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* skip_root */
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
argument_list|,
name|dirent
argument_list|,
name|ignore_patterns
argument_list|,
name|depth
argument_list|,
name|get_all
argument_list|,
name|no_ignore
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It may be a file or an unversioned item. And this is an explicit        * target, so no ignoring. An unversioned item (file or dir) shows a        * status like '?', and can yield a tree conflicted path. */
name|err
operator|=
name|get_child_status
argument_list|(
operator|&
name|wb
argument_list|,
name|local_abspath
argument_list|,
name|info
argument_list|,
name|dirent
argument_list|,
name|ignore_patterns
argument_list|,
name|get_all
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|&&
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
comment|/* The parent is also not versioned, but it is not nice to show              an error about a path a user didn't intend to touch. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' was not found."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_walk_status
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|ignore_text_mods
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ignore_patterns
parameter_list|,
name|svn_wc_status_func4_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__internal_walk_status
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|get_all
argument_list|,
name|no_ignore
argument_list|,
name|ignore_text_mods
argument_list|,
name|ignore_patterns
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_status_set_repos_locks
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|locks
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|eb
operator|->
name|wb
operator|.
name|repos_locks
operator|=
name|locks
expr_stmt|;
name|eb
operator|->
name|wb
operator|.
name|repos_root
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|repos_root
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_get_default_ignores
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|patterns
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|cfg
init|=
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
comment|/* Check the Subversion run-time configuration for global ignores.      If no configuration value exists, we fall back to our defaults. */
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|val
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_GLOBAL_IGNORES
argument_list|,
name|SVN_CONFIG_DEFAULT_GLOBAL_IGNORES
argument_list|)
expr_stmt|;
operator|*
name|patterns
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split the patterns on whitespace, and stuff them into *PATTERNS. */
name|svn_cstring_split_append
argument_list|(
operator|*
name|patterns
argument_list|,
name|val
argument_list|,
literal|"\n\r\t\v "
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|internal_status
parameter_list|(
name|svn_wc_status3_t
modifier|*
modifier|*
name|status
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_repos_uuid
decl_stmt|;
name|svn_wc__db_status_t
name|node_status
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_boolean_t
name|is_root
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|node_status
argument_list|,
operator|&
name|node_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|node_kind
operator|=
name|svn_node_unknown
expr_stmt|;
comment|/* Ensure conflicted is always set, but don't hide tree conflicts          on 'hidden' nodes. */
name|conflicted
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|dirent
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|stat_wc_dirent_case_sensitive
argument_list|(
operator|&
name|dirent
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|!=
name|svn_node_unknown
operator|&&
operator|(
name|node_status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|node_status
operator|==
name|svn_wc__db_status_server_excluded
operator|||
name|node_status
operator|==
name|svn_wc__db_status_excluded
operator|)
condition|)
block|{
name|node_kind
operator|=
name|svn_node_unknown
expr_stmt|;
block|}
if|if
condition|(
name|node_kind
operator|==
name|svn_node_unknown
condition|)
return|return
name|svn_error_trace
argument_list|(
name|assemble_unversioned
argument_list|(
name|status
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|dirent
argument_list|,
name|conflicted
argument_list|,
name|FALSE
comment|/* is_ignored */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|svn_dirent_is_root
argument_list|(
name|local_abspath
argument_list|,
name|strlen
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
condition|)
name|is_root
operator|=
name|TRUE
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_root
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_root
condition|)
block|{
name|svn_wc__db_status_t
name|parent_status
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|parent_status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|parent_repos_relpath
argument_list|,
operator|&
name|parent_repos_root_url
argument_list|,
operator|&
name|parent_repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|||
name|SVN_WC__ERR_IS_NOT_CURRENT_WC
argument_list|(
name|err
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|parent_repos_root_url
operator|=
name|NULL
expr_stmt|;
name|parent_repos_relpath
operator|=
name|NULL
expr_stmt|;
name|parent_repos_uuid
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parent_repos_root_url
operator|=
name|NULL
expr_stmt|;
name|parent_repos_relpath
operator|=
name|NULL
expr_stmt|;
name|parent_repos_uuid
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|assemble_status
argument_list|(
name|status
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|parent_repos_root_url
argument_list|,
name|parent_repos_relpath
argument_list|,
name|parent_repos_uuid
argument_list|,
name|NULL
argument_list|,
name|dirent
argument_list|,
name|TRUE
comment|/* get_all */
argument_list|,
name|FALSE
argument_list|,
name|NULL
comment|/* repos_lock */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_status3
parameter_list|(
name|svn_wc_status3_t
modifier|*
modifier|*
name|status
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|internal_status
argument_list|(
name|status
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_wc_status3_t
modifier|*
name|svn_wc_dup_status3
parameter_list|(
specifier|const
name|svn_wc_status3_t
modifier|*
name|orig_stat
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_status3_t
modifier|*
name|new_stat
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_stat
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Shallow copy all members. */
operator|*
name|new_stat
operator|=
operator|*
name|orig_stat
expr_stmt|;
comment|/* Now go back and dup the deep items into this pool. */
if|if
condition|(
name|orig_stat
operator|->
name|repos_lock
condition|)
name|new_stat
operator|->
name|repos_lock
operator|=
name|svn_lock_dup
argument_list|(
name|orig_stat
operator|->
name|repos_lock
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stat
operator|->
name|changed_author
condition|)
name|new_stat
operator|->
name|changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|orig_stat
operator|->
name|changed_author
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stat
operator|->
name|ood_changed_author
condition|)
name|new_stat
operator|->
name|ood_changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|orig_stat
operator|->
name|ood_changed_author
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stat
operator|->
name|lock
condition|)
name|new_stat
operator|->
name|lock
operator|=
name|svn_lock_dup
argument_list|(
name|orig_stat
operator|->
name|lock
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stat
operator|->
name|changelist
condition|)
name|new_stat
operator|->
name|changelist
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|orig_stat
operator|->
name|changelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stat
operator|->
name|repos_root_url
condition|)
name|new_stat
operator|->
name|repos_root_url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|orig_stat
operator|->
name|repos_root_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stat
operator|->
name|repos_relpath
condition|)
name|new_stat
operator|->
name|repos_relpath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|orig_stat
operator|->
name|repos_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stat
operator|->
name|repos_uuid
condition|)
name|new_stat
operator|->
name|repos_uuid
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|orig_stat
operator|->
name|repos_uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stat
operator|->
name|moved_from_abspath
condition|)
name|new_stat
operator|->
name|moved_from_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|orig_stat
operator|->
name|moved_from_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stat
operator|->
name|moved_to_abspath
condition|)
name|new_stat
operator|->
name|moved_to_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|orig_stat
operator|->
name|moved_to_abspath
argument_list|)
expr_stmt|;
comment|/* Return the new hotness. */
return|return
name|new_stat
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_get_ignores2
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|patterns
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|default_ignores
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_get_default_ignores
argument_list|(
operator|&
name|default_ignores
argument_list|,
name|config
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|collect_ignore_patterns
argument_list|(
name|patterns
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|default_ignores
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

