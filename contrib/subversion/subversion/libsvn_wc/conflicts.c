begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * conflicts.c: routines for managing conflict data.  *            NOTE: this code doesn't know where the conflict is  *            actually stored.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"wc_db.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"props.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* --------------------------------------------------------------------  * Conflict skel management  */
end_comment

begin_function
name|svn_skel_t
modifier|*
name|svn_wc__conflict_skel_create
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|conflict_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
comment|/* Add empty CONFLICTS list */
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|conflict_skel
argument_list|)
expr_stmt|;
comment|/* Add empty WHY list */
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|conflict_skel
argument_list|)
expr_stmt|;
return|return
name|conflict_skel
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_is_complete
parameter_list|(
name|svn_boolean_t
modifier|*
name|complete
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|)
block|{
operator|*
name|complete
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|svn_skel__list_length
argument_list|(
name|conflict_skel
argument_list|)
operator|<
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Not a conflict skel"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|svn_skel__list_length
argument_list|(
name|conflict_skel
operator|->
name|children
argument_list|)
operator|<
literal|2
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* WHY is not set */
if|if
condition|(
name|svn_skel__list_length
argument_list|(
name|conflict_skel
operator|->
name|children
operator|->
name|next
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* No conflict set */
operator|*
name|complete
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Serialize a svn_wc_conflict_version_t before the existing data in skel */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict__prepend_location
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|location
parameter_list|,
name|svn_boolean_t
name|allow_NULL
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|loc
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|location
operator|||
name|allow_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|location
condition|)
block|{
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* ("subversion" repos_root_url repos_uuid repos_relpath rev kind) */
name|loc
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|svn_node_kind_to_word
argument_list|(
name|location
operator|->
name|node_kind
argument_list|)
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_int
argument_list|(
name|location
operator|->
name|peg_rev
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|location
operator|->
name|path_in_repos
argument_list|)
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|location
operator|->
name|repos_uuid
condition|)
comment|/* Can theoretically be NULL */
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend_str
argument_list|(
name|location
operator|->
name|repos_uuid
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|location
operator|->
name|repos_url
argument_list|)
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_SRC_SUBVERSION
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|loc
argument_list|,
name|skel
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Deserialize a svn_wc_conflict_version_t from the skel.    Set *LOCATION to NULL when the data is not a svn_wc_conflict_version_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict__read_location
parameter_list|(
name|svn_wc_conflict_version_t
modifier|*
modifier|*
name|location
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|apr_int64_t
name|v
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
comment|/* note that 'none' is a legitimate value */
specifier|const
name|char
modifier|*
name|kind_str
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|c
init|=
name|skel
operator|->
name|children
decl_stmt|;
if|if
condition|(
operator|!
name|svn_skel__matches_atom
argument_list|(
name|c
argument_list|,
name|SVN_WC__CONFLICT_SRC_SUBVERSION
argument_list|)
condition|)
block|{
operator|*
name|location
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|repos_root_url
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|is_atom
condition|)
name|repos_uuid
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
name|repos_uuid
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|repos_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__parse_int
argument_list|(
operator|&
name|v
argument_list|,
name|c
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|revision
operator|=
operator|(
name|svn_revnum_t
operator|)
name|v
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|kind_str
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
expr_stmt|;
name|node_kind
operator|=
name|svn_node_kind_from_word
argument_list|(
name|kind_str
argument_list|)
expr_stmt|;
operator|*
name|location
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|repos_relpath
argument_list|,
name|revision
argument_list|,
name|node_kind
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get the operation part of CONFLICT_SKELL or NULL if no operation is set    at this time */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict__get_operation
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|why
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
operator|*
name|why
operator|=
name|conflict_skel
operator|->
name|children
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|why
operator|)
operator|->
name|children
condition|)
operator|*
name|why
operator|=
name|NULL
expr_stmt|;
comment|/* Operation is not set yet */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_set_op_update
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|why
decl_stmt|;
name|svn_skel_t
modifier|*
name|origins
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|why
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|why
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No operation set */
name|why
operator|=
name|conflict_skel
operator|->
name|children
expr_stmt|;
name|origins
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|target
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|original
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|origins
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_OP_UPDATE
argument_list|,
name|why
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_set_op_switch
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|why
decl_stmt|;
name|svn_skel_t
modifier|*
name|origins
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|why
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|why
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No operation set */
name|why
operator|=
name|conflict_skel
operator|->
name|children
expr_stmt|;
name|origins
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|target
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|original
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|origins
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_OP_SWITCH
argument_list|,
name|why
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_set_op_merge
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|why
decl_stmt|;
name|svn_skel_t
modifier|*
name|origins
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|why
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|why
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No operation set */
name|why
operator|=
name|conflict_skel
operator|->
name|children
expr_stmt|;
name|origins
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|right
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|left
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|origins
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_OP_MERGE
argument_list|,
name|why
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Gets the conflict data of the specified type CONFLICT_TYPE from    CONFLICT_SKEL, or NULL if no such conflict is recorded */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict__get_conflict
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|conflict
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_type
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|children
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|c
operator|->
name|children
argument_list|,
name|conflict_type
argument_list|)
condition|)
block|{
operator|*
name|conflict
operator|=
name|c
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
operator|*
name|conflict
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_add_text_conflict
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|mine_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|their_old_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|their_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|text_conflict
decl_stmt|;
name|svn_skel_t
modifier|*
name|markers
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|text_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|text_conflict
argument_list|)
expr_stmt|;
comment|/* ### Use proper error? */
comment|/* Current skel format      ("text"       (OLD MINE OLD-THEIRS THEIRS)) */
name|text_conflict
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|markers
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|their_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|their_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|their_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|their_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|their_relpath
argument_list|,
name|markers
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|markers
argument_list|)
expr_stmt|;
if|if
condition|(
name|mine_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|mine_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|mine_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|mine_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|mine_relpath
argument_list|,
name|markers
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|markers
argument_list|)
expr_stmt|;
if|if
condition|(
name|their_old_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|original_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|original_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|their_old_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|original_relpath
argument_list|,
name|markers
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|markers
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|markers
argument_list|,
name|text_conflict
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|,
name|text_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* And add it to the conflict skel */
name|svn_skel__prepend
argument_list|(
name|text_conflict
argument_list|,
name|conflict_skel
operator|->
name|children
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_add_prop_conflict
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|marker_abspath
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|mine_props
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|their_old_props
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|their_props
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|conflicted_prop_names
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|prop_conflict
decl_stmt|;
name|svn_skel_t
modifier|*
name|props
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_names
decl_stmt|;
name|svn_skel_t
modifier|*
name|markers
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|prop_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|prop_conflict
argument_list|)
expr_stmt|;
comment|/* ### Use proper error? */
comment|/* This function currently implements:      ("prop"       ("marker_relpath")       prop-conflicted_prop_names       old-props       mine-props       their-props)      NULL lists are recorded as "" */
comment|/* ### Seems that this may not match what we read out.  Read-out of    * 'theirs-old' comes as NULL. */
name|prop_conflict
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|their_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|their_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|props
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend_str
argument_list|(
literal|""
argument_list|,
name|prop_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* No their_props */
if|if
condition|(
name|mine_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|mine_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|props
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend_str
argument_list|(
literal|""
argument_list|,
name|prop_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* No mine_props */
if|if
condition|(
name|their_old_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|their_old_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|props
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend_str
argument_list|(
literal|""
argument_list|,
name|prop_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* No old_props */
name|conflict_names
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
operator|(
name|apr_hash_t
operator|*
operator|)
name|conflicted_prop_names
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_skel__prepend_str
argument_list|(
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|,
name|conflict_names
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|svn_skel__prepend
argument_list|(
name|conflict_names
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
name|markers
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|marker_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|marker_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|marker_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|marker_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|marker_relpath
argument_list|,
name|markers
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
comment|/*else // ### set via svn_wc__conflict_create_markers     svn_skel__prepend(svn_skel__make_empty_list(result_pool), markers);*/
name|svn_skel__prepend
argument_list|(
name|markers
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|,
name|prop_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* And add it to the conflict skel */
name|svn_skel__prepend
argument_list|(
name|prop_conflict
argument_list|,
name|conflict_skel
operator|->
name|children
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A map for svn_wc_conflict_reason_t values. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|reason_map
index|[]
init|=
block|{
block|{
literal|"edited"
block|,
name|svn_wc_conflict_reason_edited
block|}
block|,
block|{
literal|"obstructed"
block|,
name|svn_wc_conflict_reason_obstructed
block|}
block|,
block|{
literal|"deleted"
block|,
name|svn_wc_conflict_reason_deleted
block|}
block|,
block|{
literal|"missing"
block|,
name|svn_wc_conflict_reason_missing
block|}
block|,
block|{
literal|"unversioned"
block|,
name|svn_wc_conflict_reason_unversioned
block|}
block|,
block|{
literal|"added"
block|,
name|svn_wc_conflict_reason_added
block|}
block|,
block|{
literal|"replaced"
block|,
name|svn_wc_conflict_reason_replaced
block|}
block|,
block|{
literal|"moved-away"
block|,
name|svn_wc_conflict_reason_moved_away
block|}
block|,
block|{
literal|"moved-here"
block|,
name|svn_wc_conflict_reason_moved_here
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|action_map
index|[]
init|=
block|{
block|{
literal|"edited"
block|,
name|svn_wc_conflict_action_edit
block|}
block|,
block|{
literal|"added"
block|,
name|svn_wc_conflict_action_add
block|}
block|,
block|{
literal|"deleted"
block|,
name|svn_wc_conflict_action_delete
block|}
block|,
block|{
literal|"replaced"
block|,
name|svn_wc_conflict_action_replace
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_add_tree_conflict
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_wc_conflict_reason_t
name|reason
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
specifier|const
name|char
modifier|*
name|move_src_op_root_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|tree_conflict
decl_stmt|;
name|svn_skel_t
modifier|*
name|markers
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|tree_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|tree_conflict
argument_list|)
expr_stmt|;
comment|/* ### Use proper error? */
name|SVN_ERR_ASSERT
argument_list|(
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|||
operator|!
name|move_src_op_root_abspath
argument_list|)
expr_stmt|;
comment|/* ### Use proper error? */
name|tree_conflict
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|&&
name|move_src_op_root_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_src_op_root_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|move_src_op_root_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|move_src_op_root_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|move_src_op_root_relpath
argument_list|,
name|tree_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|svn_skel__prepend_str
argument_list|(
name|svn_token__to_word
argument_list|(
name|action_map
argument_list|,
name|action
argument_list|)
argument_list|,
name|tree_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|svn_token__to_word
argument_list|(
name|reason_map
argument_list|,
name|reason
argument_list|)
argument_list|,
name|tree_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Tree conflicts have no marker files */
name|markers
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|markers
argument_list|,
name|tree_conflict
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|,
name|tree_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* And add it to the conflict skel */
name|svn_skel__prepend
argument_list|(
name|tree_conflict
argument_list|,
name|conflict_skel
operator|->
name|children
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_resolve
parameter_list|(
name|svn_boolean_t
modifier|*
name|completely_resolved
parameter_list|,
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_boolean_t
name|resolve_text
parameter_list|,
specifier|const
name|char
modifier|*
name|resolve_prop
parameter_list|,
name|svn_boolean_t
name|resolve_tree
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|op
decl_stmt|;
name|svn_skel_t
modifier|*
modifier|*
name|pconflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|op
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Not a completed conflict skel"
argument_list|)
argument_list|)
return|;
comment|/* We are going to drop items from a linked list. Instead of keeping      a pointer to the item we want to drop we store a pointer to the      pointer of what we may drop, to allow setting it to the next item. */
name|pconflict
operator|=
operator|&
operator|(
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|children
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|pconflict
condition|)
block|{
name|svn_skel_t
modifier|*
name|c
init|=
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|children
decl_stmt|;
if|if
condition|(
name|resolve_text
operator|&&
name|svn_skel__matches_atom
argument_list|(
name|c
argument_list|,
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|)
condition|)
block|{
comment|/* Remove the text conflict from the linked list */
operator|*
name|pconflict
operator|=
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|resolve_prop
operator|&&
name|svn_skel__matches_atom
argument_list|(
name|c
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
condition|)
block|{
name|svn_skel_t
modifier|*
modifier|*
name|ppropnames
init|=
operator|&
operator|(
name|c
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|)
decl_stmt|;
if|if
condition|(
name|resolve_prop
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|ppropnames
operator|=
name|NULL
expr_stmt|;
comment|/* remove all conflicted property names */
else|else
while|while
condition|(
operator|*
name|ppropnames
condition|)
block|{
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
operator|*
name|ppropnames
argument_list|,
name|resolve_prop
argument_list|)
condition|)
block|{
operator|*
name|ppropnames
operator|=
operator|(
operator|*
name|ppropnames
operator|)
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|ppropnames
operator|=
operator|&
operator|(
operator|(
operator|*
name|ppropnames
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
comment|/* If no conflicted property names left */
if|if
condition|(
operator|!
name|c
operator|->
name|next
operator|->
name|next
operator|->
name|children
condition|)
block|{
comment|/* Remove the propery conflict skel from the linked list */
operator|*
name|pconflict
operator|=
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|resolve_tree
operator|&&
name|svn_skel__matches_atom
argument_list|(
name|c
argument_list|,
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|)
condition|)
block|{
comment|/* Remove the tree conflict from the linked list */
operator|*
name|pconflict
operator|=
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
name|pconflict
operator|=
operator|&
operator|(
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|completely_resolved
condition|)
block|{
comment|/* Nice, we can just call the complete function */
name|svn_boolean_t
name|complete_conflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_is_complete
argument_list|(
operator|&
name|complete_conflict
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|completely_resolved
operator|=
operator|!
name|complete_conflict
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A map for svn_wc_operation_t values. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|operation_map
index|[]
init|=
block|{
block|{
literal|""
block|,
name|svn_wc_operation_none
block|}
block|,
block|{
name|SVN_WC__CONFLICT_OP_UPDATE
block|,
name|svn_wc_operation_update
block|}
block|,
block|{
name|SVN_WC__CONFLICT_OP_SWITCH
block|,
name|svn_wc_operation_switch
block|}
block|,
block|{
name|SVN_WC__CONFLICT_OP_MERGE
block|,
name|svn_wc_operation_merge
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_info
parameter_list|(
name|svn_wc_operation_t
modifier|*
name|operation
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
modifier|*
name|locations
parameter_list|,
name|svn_boolean_t
modifier|*
name|text_conflicted
parameter_list|,
name|svn_boolean_t
modifier|*
name|prop_conflicted
parameter_list|,
name|svn_boolean_t
modifier|*
name|tree_conflicted
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|op
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|op
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Not a completed conflict skel"
argument_list|)
argument_list|)
return|;
name|c
operator|=
name|op
operator|->
name|children
expr_stmt|;
if|if
condition|(
name|operation
condition|)
block|{
name|int
name|value
init|=
name|svn_token__from_mem
argument_list|(
name|operation_map
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|SVN_TOKEN_UNKNOWN
condition|)
operator|*
name|operation
operator|=
name|value
expr_stmt|;
else|else
operator|*
name|operation
operator|=
name|svn_wc_operation_none
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|c
operator|->
name|children
condition|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|loc_skel
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|loc
decl_stmt|;
name|apr_array_header_t
modifier|*
name|locs
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|loc
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|loc_skel
operator|=
name|c
operator|->
name|children
init|;
name|loc_skel
condition|;
name|loc_skel
operator|=
name|loc_skel
operator|->
name|next
control|)
block|{
name|SVN_ERR
argument_list|(
name|conflict__read_location
argument_list|(
operator|&
name|loc
argument_list|,
name|loc_skel
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|locs
argument_list|,
name|svn_wc_conflict_version_t
operator|*
argument_list|)
operator|=
name|loc
expr_stmt|;
block|}
operator|*
name|locations
operator|=
name|locs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locations
condition|)
operator|*
name|locations
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|text_conflicted
condition|)
block|{
name|svn_skel_t
modifier|*
name|c_skel
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|c_skel
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|text_conflicted
operator|=
operator|(
name|c_skel
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|prop_conflicted
condition|)
block|{
name|svn_skel_t
modifier|*
name|c_skel
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|c_skel
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|prop_conflicted
operator|=
operator|(
name|c_skel
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tree_conflicted
condition|)
block|{
name|svn_skel_t
modifier|*
name|c_skel
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|c_skel
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tree_conflicted
operator|=
operator|(
name|c_skel
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_text_conflict
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|mine_abspath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|their_old_abspath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|their_abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|text_conflict
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|m
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|text_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_conflict
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_MISSING
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict not set"
argument_list|)
argument_list|)
return|;
name|m
operator|=
name|text_conflict
operator|->
name|children
operator|->
name|next
operator|->
name|children
expr_stmt|;
if|if
condition|(
name|their_old_abspath
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|is_atom
condition|)
block|{
specifier|const
name|char
modifier|*
name|original_relpath
decl_stmt|;
name|original_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|m
operator|->
name|data
argument_list|,
name|m
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|their_old_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|original_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|their_old_abspath
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|mine_abspath
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|is_atom
condition|)
block|{
specifier|const
name|char
modifier|*
name|mine_relpath
decl_stmt|;
name|mine_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|m
operator|->
name|data
argument_list|,
name|m
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|mine_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|mine_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|mine_abspath
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|their_abspath
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|is_atom
condition|)
block|{
specifier|const
name|char
modifier|*
name|their_relpath
decl_stmt|;
name|their_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|m
operator|->
name|data
argument_list|,
name|m
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|their_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|their_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|their_abspath
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_prop_conflict
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|marker_abspath
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|mine_props
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|their_old_props
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|their_props
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|conflicted_prop_names
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|prop_conflict
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|prop_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_conflict
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_MISSING
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict not set"
argument_list|)
argument_list|)
return|;
name|c
operator|=
name|prop_conflict
operator|->
name|children
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Skip "prop" */
comment|/* Get marker file */
if|if
condition|(
name|marker_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|marker_relpath
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|children
operator|&&
name|c
operator|->
name|children
operator|->
name|is_atom
condition|)
block|{
name|marker_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|c
operator|->
name|children
operator|->
name|data
argument_list|,
name|c
operator|->
name|children
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|marker_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|marker_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|marker_abspath
operator|=
name|NULL
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Get conflicted properties */
if|if
condition|(
name|conflicted_prop_names
condition|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|name
decl_stmt|;
operator|*
name|conflicted_prop_names
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|name
operator|=
name|c
operator|->
name|children
init|;
name|name
condition|;
name|name
operator|=
name|name
operator|->
name|next
control|)
block|{
name|svn_hash_sets
argument_list|(
operator|*
name|conflicted_prop_names
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|name
operator|->
name|data
argument_list|,
name|name
operator|->
name|len
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Get original properties */
if|if
condition|(
name|their_old_props
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|is_atom
condition|)
operator|*
name|their_old_props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
name|their_old_props
argument_list|,
name|c
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Get mine properties */
if|if
condition|(
name|mine_props
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|is_atom
condition|)
operator|*
name|mine_props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
name|mine_props
argument_list|,
name|c
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Get their properties */
if|if
condition|(
name|their_props
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|is_atom
condition|)
operator|*
name|their_props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
name|their_props
argument_list|,
name|c
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_tree_conflict
parameter_list|(
name|svn_wc_conflict_reason_t
modifier|*
name|reason
parameter_list|,
name|svn_wc_conflict_action_t
modifier|*
name|action
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|move_src_op_root_abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|tree_conflict
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|c
decl_stmt|;
name|svn_boolean_t
name|is_moved_away
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|tree_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_conflict
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_MISSING
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict not set"
argument_list|)
argument_list|)
return|;
name|c
operator|=
name|tree_conflict
operator|->
name|children
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Skip "tree" */
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Skip markers */
block|{
name|int
name|value
init|=
name|svn_token__from_mem
argument_list|(
name|reason_map
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|reason
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|SVN_TOKEN_UNKNOWN
condition|)
operator|*
name|reason
operator|=
name|value
expr_stmt|;
else|else
operator|*
name|reason
operator|=
name|svn_wc_conflict_reason_edited
expr_stmt|;
block|}
name|is_moved_away
operator|=
operator|(
name|value
operator|==
name|svn_wc_conflict_reason_moved_away
operator|)
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|action
condition|)
block|{
name|int
name|value
init|=
name|svn_token__from_mem
argument_list|(
name|action_map
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|SVN_TOKEN_UNKNOWN
condition|)
operator|*
name|action
operator|=
name|value
expr_stmt|;
else|else
operator|*
name|action
operator|=
name|svn_wc_conflict_action_edit
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|move_src_op_root_abspath
condition|)
block|{
comment|/* Only set for update and switch tree conflicts */
if|if
condition|(
name|c
operator|&&
name|is_moved_away
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_src_op_root_relpath
init|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|move_src_op_root_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|move_src_op_root_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|move_src_op_root_abspath
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_markers
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
modifier|*
name|markers
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk the conflicts */
for|for
control|(
name|conflict
operator|=
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|children
init|;
name|conflict
condition|;
name|conflict
operator|=
name|conflict
operator|->
name|next
control|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|marker
decl_stmt|;
comment|/* Get the list of markers stored per conflict */
for|for
control|(
name|marker
operator|=
name|conflict
operator|->
name|children
operator|->
name|next
operator|->
name|children
init|;
name|marker
condition|;
name|marker
operator|=
name|marker
operator|->
name|next
control|)
block|{
comment|/* Skip placeholders */
if|if
condition|(
operator|!
name|marker
operator|->
name|is_atom
condition|)
continue|continue;
if|if
condition|(
operator|!
name|list
condition|)
name|list
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|list
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|marker
operator|->
name|data
argument_list|,
name|marker
operator|->
name|len
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|markers
operator|=
name|list
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_create_markers
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_conflicted
condition|)
block|{
specifier|const
name|char
modifier|*
name|marker_abspath
init|=
name|NULL
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|marker_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|marker_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|marker_relpath
decl_stmt|;
comment|/* Ok, currently we have to do a few things for property conflicts:          - Create a marker file          - Store the name in the conflict_skel          - Create a WQ item that fills the marker with the expected data */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|marker_dir
operator|=
name|local_abspath
expr_stmt|;
name|marker_name
operator|=
name|SVN_WC__THIS_DIR_PREJ
expr_stmt|;
block|}
else|else
name|svn_dirent_split
argument_list|(
operator|&
name|marker_dir
argument_list|,
operator|&
name|marker_name
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
operator|&
name|marker_abspath
argument_list|,
name|marker_dir
argument_list|,
name|marker_name
argument_list|,
name|SVN_WC__PROP_REJ_EXT
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|marker_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|marker_abspath
argument_list|,
name|result_pool
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And store the marker in the skel */
block|{
name|svn_skel_t
modifier|*
name|prop_conflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|prop_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|marker_relpath
argument_list|,
name|prop_conflict
operator|->
name|children
operator|->
name|next
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_prej_install
argument_list|(
name|work_items
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function for the three apply_* functions below, used when  * merging properties together.  *  * Given property PROPNAME on LOCAL_ABSPATH, and four possible property  * values, generate four tmpfiles and pass them to CONFLICT_FUNC callback.  * This gives the client an opportunity to interactively resolve the  * property conflict.  *  * BASE_VAL/WORKING_VAL represent the current state of the working  * copy, and INCOMING_OLD_VAL/INCOMING_NEW_VAL represents the incoming  * propchange.  Any of these values might be NULL, indicating either  * non-existence or intent-to-delete.  *  * If the callback isn't available, or if it responds with  * 'choose_postpone', then set *CONFLICT_REMAINS to TRUE and return.  *  * If the callback responds with a choice of 'base', 'theirs', 'mine',  * or 'merged', then install the proper value into ACTUAL_PROPS and  * set *CONFLICT_REMAINS to FALSE.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|generate_propconflict
parameter_list|(
name|svn_boolean_t
modifier|*
name|conflict_remains
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|base_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|working_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|incoming_old_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|incoming_new_val
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_conflict_result_t
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|svn_wc_conflict_description2_t
modifier|*
name|cdesc
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirpath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|new_value
init|=
name|NULL
decl_stmt|;
name|cdesc
operator|=
name|svn_wc_conflict_description_create_prop2
argument_list|(
name|local_abspath
argument_list|,
name|kind
argument_list|,
name|propname
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|cdesc
operator|->
name|src_left_version
operator|=
name|left_version
expr_stmt|;
name|cdesc
operator|->
name|src_right_version
operator|=
name|right_version
expr_stmt|;
comment|/* Create a tmpfile for each of the string_t's we've got.  */
if|if
condition|(
name|working_val
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|file_name
argument_list|,
name|dirpath
argument_list|,
name|working_val
operator|->
name|data
argument_list|,
name|working_val
operator|->
name|len
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|my_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|file_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|prop_value_working
operator|=
name|working_val
expr_stmt|;
block|}
if|if
condition|(
name|incoming_new_val
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|file_name
argument_list|,
name|dirpath
argument_list|,
name|incoming_new_val
operator|->
name|data
argument_list|,
name|incoming_new_val
operator|->
name|len
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### For property conflicts, cd2 stores prop_reject_abspath in        * ### their_abspath, and stores theirs_abspath in merged_file. */
name|cdesc
operator|->
name|merged_file
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|file_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|prop_value_incoming_new
operator|=
name|incoming_new_val
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|base_val
operator|&&
operator|!
name|incoming_old_val
condition|)
block|{
comment|/* If base and old are both NULL, then that's fine, we just let          base_file stay NULL as-is.  Both agents are attempting to add a          new property.  */
block|}
elseif|else
if|if
condition|(
operator|(
name|base_val
operator|&&
operator|!
name|incoming_old_val
operator|)
operator|||
operator|(
operator|!
name|base_val
operator|&&
name|incoming_old_val
operator|)
condition|)
block|{
comment|/* If only one of base and old are defined, then we've got a          situation where one agent is attempting to add the property          for the first time, and the other agent is changing a          property it thinks already exists.  In this case, we return          whichever older-value happens to be defined, so that the          conflict-callback can still attempt a 3-way merge. */
specifier|const
name|svn_string_t
modifier|*
name|conflict_base_val
init|=
name|base_val
condition|?
name|base_val
else|:
name|incoming_old_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|file_name
argument_list|,
name|dirpath
argument_list|,
name|conflict_base_val
operator|->
name|data
argument_list|,
name|conflict_base_val
operator|->
name|len
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|base_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|file_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* base and old are both non-NULL */
block|{
specifier|const
name|svn_string_t
modifier|*
name|conflict_base_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
if|if
condition|(
operator|!
name|svn_string_compare
argument_list|(
name|base_val
argument_list|,
name|incoming_old_val
argument_list|)
condition|)
block|{
comment|/* What happens if 'base' and 'old' don't match up?  In an              ideal situation, they would.  But if they don't, this is              a classic example of a patch 'hunk' failing to apply due              to a lack of context.  For example: imagine that the user              is busy changing the property from a value of "cat" to              "dog", but the incoming propchange wants to change the              same property value from "red" to "green".  Total context              mismatch.               HOWEVER: we can still pass one of the two base values as              'base_file' to the callback anyway.  It's still useful to              present the working and new values to the user to              compare. */
if|if
condition|(
name|working_val
operator|&&
name|svn_string_compare
argument_list|(
name|base_val
argument_list|,
name|working_val
argument_list|)
condition|)
name|conflict_base_val
operator|=
name|incoming_old_val
expr_stmt|;
else|else
name|conflict_base_val
operator|=
name|base_val
expr_stmt|;
block|}
else|else
block|{
name|conflict_base_val
operator|=
name|base_val
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|file_name
argument_list|,
name|dirpath
argument_list|,
name|conflict_base_val
operator|->
name|data
argument_list|,
name|conflict_base_val
operator|->
name|len
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|base_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|file_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|prop_value_base
operator|=
name|base_val
expr_stmt|;
name|cdesc
operator|->
name|prop_value_incoming_old
operator|=
name|incoming_old_val
expr_stmt|;
if|if
condition|(
name|working_val
operator|&&
name|incoming_new_val
condition|)
block|{
name|svn_stream_t
modifier|*
name|mergestream
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|options
init|=
name|svn_diff_file_options_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|mergestream
argument_list|,
operator|&
name|cdesc
operator|->
name|prop_reject_abspath
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_mem_string_diff3
argument_list|(
operator|&
name|diff
argument_list|,
name|conflict_base_val
argument_list|,
name|working_val
argument_list|,
name|incoming_new_val
argument_list|,
name|options
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_mem_string_output_merge3
argument_list|(
name|mergestream
argument_list|,
name|diff
argument_list|,
name|conflict_base_val
argument_list|,
name|working_val
argument_list|,
name|incoming_new_val
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_diff_conflict_display_modified_latest
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|mergestream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### For property conflicts, cd2 stores prop_reject_abspath in            * ### their_abspath, and stores theirs_abspath in merged_file. */
name|cdesc
operator|->
name|their_abspath
operator|=
name|cdesc
operator|->
name|prop_reject_abspath
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|incoming_old_val
operator|&&
name|incoming_new_val
condition|)
name|cdesc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_add
expr_stmt|;
elseif|else
if|if
condition|(
name|incoming_old_val
operator|&&
operator|!
name|incoming_new_val
condition|)
name|cdesc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_delete
expr_stmt|;
else|else
name|cdesc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_edit
expr_stmt|;
if|if
condition|(
name|base_val
operator|&&
operator|!
name|working_val
condition|)
name|cdesc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|base_val
operator|&&
name|working_val
condition|)
name|cdesc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_obstructed
expr_stmt|;
else|else
name|cdesc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_edited
expr_stmt|;
comment|/* Invoke the interactive conflict callback. */
name|SVN_ERR
argument_list|(
name|conflict_func
argument_list|(
operator|&
name|result
argument_list|,
name|cdesc
argument_list|,
name|conflict_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict callback violated API:"
literal|" returned no results"
argument_list|)
argument_list|)
return|;
block|}
switch|switch
condition|(
name|result
operator|->
name|choice
condition|)
block|{
default|default:
case|case
name|svn_wc_conflict_choose_postpone
case|:
block|{
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_mine_full
case|:
block|{
comment|/* No need to change actual_props; it already contains working_val */
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
name|new_value
operator|=
name|working_val
expr_stmt|;
break|break;
block|}
comment|/* I think _mine_full and _theirs_full are appropriate for prop          behavior as well as the text behavior.  There should even be          analogous behaviors for _mine and _theirs when those are          ready, namely: fold in all non-conflicting prop changes, and          then choose _mine side or _theirs side for conflicting ones. */
case|case
name|svn_wc_conflict_choose_theirs_full
case|:
block|{
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
name|new_value
operator|=
name|incoming_new_val
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_base
case|:
block|{
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
name|new_value
operator|=
name|base_val
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_merged
case|:
block|{
name|svn_stringbuf_t
modifier|*
name|merged_stringbuf
decl_stmt|;
if|if
condition|(
operator|!
name|cdesc
operator|->
name|merged_file
operator|&&
operator|(
operator|!
name|result
operator|->
name|merged_file
operator|&&
operator|!
name|result
operator|->
name|merged_value
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict callback violated API:"
literal|" returned no merged file"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|result
operator|->
name|merged_value
condition|)
name|new_value
operator|=
name|result
operator|->
name|merged_value
expr_stmt|;
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|merged_stringbuf
argument_list|,
name|result
operator|->
name|merged_file
condition|?
name|result
operator|->
name|merged_file
else|:
name|cdesc
operator|->
name|merged_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_value
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|merged_stringbuf
argument_list|)
expr_stmt|;
block|}
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|conflict_remains
condition|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* For now, just set the property values. This should really do some of the          more advanced things from svn_wc_prop_set() */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_set_props
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|props
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform a 3-way merge in which conflicts are expected, showing the  * conflicts in the way specified by STYLE, and using MERGE_OPTIONS.  *  * The three input files are LEFT_ABSPATH (the base), DETRANSLATED_TARGET  * and RIGHT_ABSPATH.  The output is stored in a new temporary file,  * whose name is put into *CHOSEN_ABSPATH.  *  * The output file will be deleted according to DELETE_WHEN.  If  * DELETE_WHEN is 'on pool cleanup', it refers to RESULT_POOL.  *  * DB and WRI_ABSPATH are used to choose a directory for the output file.  *  * Allocate *CHOSEN_ABSPATH in RESULT_POOL.  Use SCRATCH_POOL for temporary  * allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_showing_conflicts
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|chosen_abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_diff_conflict_display_style_t
name|style
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|detranslated_target
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
name|svn_io_file_del_t
name|delete_when
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|temp_dir
decl_stmt|;
name|svn_stream_t
modifier|*
name|chosen_stream
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|diff3_options
decl_stmt|;
name|diff3_options
operator|=
name|svn_diff_file_options_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_options
condition|)
name|SVN_ERR
argument_list|(
name|svn_diff_file_options_parse
argument_list|(
name|diff3_options
argument_list|,
name|merge_options
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|temp_dir
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to open the stream in RESULT_POOL because that controls the    * lifetime of the file if DELETE_WHEN is 'on pool cleanup'.  (We also    * want to allocate CHOSEN_ABSPATH in RESULT_POOL, but we don't care    * about the stream itself.) */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|chosen_stream
argument_list|,
name|chosen_abspath
argument_list|,
name|temp_dir
argument_list|,
name|delete_when
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff3_2
argument_list|(
operator|&
name|diff
argument_list|,
name|left_abspath
argument_list|,
name|detranslated_target
argument_list|,
name|right_abspath
argument_list|,
name|diff3_options
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_output_merge3
argument_list|(
name|chosen_stream
argument_list|,
name|diff
argument_list|,
name|left_abspath
argument_list|,
name|detranslated_target
argument_list|,
name|right_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* markers */
name|style
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|chosen_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Prepare to delete an artifact file at ARTIFACT_FILE_ABSPATH in the  * working copy at DB/WRI_ABSPATH.  *  * Set *WORK_ITEMS to a new work item that, when run, will delete the  * artifact file; or to NULL if there is no file to delete.  *  * Set *FILE_FOUND to TRUE if the artifact file is found on disk and its  * node kind is 'file'; otherwise do not change *FILE_FOUND.  FILE_FOUND  * may be NULL if not required.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_artifact_file_if_exists
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_boolean_t
modifier|*
name|file_found
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|artifact_file_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|artifact_file_abspath
condition|)
block|{
name|svn_node_kind_t
name|node_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|artifact_file_abspath
argument_list|,
operator|&
name|node_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
name|work_items
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|artifact_file_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_found
condition|)
operator|*
name|file_found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a new file in the same directory as LOCAL_ABSPATH, with the    same basename as LOCAL_ABSPATH, with a ".edited" extension, and set    *WORK_ITEM to a new work item that will copy and translate from the file    SOURCE_ABSPATH to that new file.  It will be translated from repository-    normal form to working-copy form according to the versioned properties    of LOCAL_ABSPATH that are current when the work item is executed.     DB should have a write lock for the directory containing SOURCE.     Allocate *WORK_ITEM in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|save_merge_result
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|source_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|edited_copy_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|dir_abspath
argument_list|,
operator|&
name|filename
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* ### Should use preserved-conflict-file-exts. */
comment|/* Create the .edited file within this file's DIR_ABSPATH  */
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
operator|&
name|edited_copy_abspath
argument_list|,
name|dir_abspath
argument_list|,
name|filename
argument_list|,
literal|".edited"
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_copy_translated
argument_list|(
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|source_abspath
argument_list|,
name|edited_copy_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Resolve the text conflict in CONFLICT, which is currently recorded  * on DB/LOCAL_ABSPATH in the manner specified by CHOICE.  *  * Set *WORK_ITEMS to new work items that will make the on-disk changes  * needed to complete the resolution (but not to mark it as resolved).  *  * Set *FOUND_ARTIFACT to true if conflict markers are removed; otherwise  * (which is only if CHOICE is 'postpone') to false.  *  * CHOICE, MERGED_FILE and SAVE_MERGED are typically values provided by  * the conflict resolver.  *  * MERGE_OPTIONS allows customizing the diff handling when using  * per hunk conflict resolving.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|build_text_conflict_resolve_items
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_boolean_t
modifier|*
name|found_artifact
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict
parameter_list|,
name|svn_wc_conflict_choice_t
name|choice
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_file
parameter_list|,
name|svn_boolean_t
name|save_merged
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mine_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|their_old_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|their_abspath
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
specifier|const
name|char
modifier|*
name|install_from_abspath
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|remove_source
init|=
name|FALSE
decl_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|found_artifact
condition|)
operator|*
name|found_artifact
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_text_conflict
argument_list|(
operator|&
name|mine_abspath
argument_list|,
operator|&
name|their_old_abspath
argument_list|,
operator|&
name|their_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_merged
condition|)
name|SVN_ERR
argument_list|(
name|save_merge_result
argument_list|(
name|work_items
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|merged_file
condition|?
name|merged_file
else|:
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|choice
operator|==
name|svn_wc_conflict_choose_postpone
condition|)
return|return
name|SVN_NO_ERROR
return|;
switch|switch
condition|(
name|choice
condition|)
block|{
comment|/* If the callback wants to use one of the fulltexts          to resolve the conflict, so be it.*/
case|case
name|svn_wc_conflict_choose_base
case|:
block|{
name|install_from_abspath
operator|=
name|their_old_abspath
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_theirs_full
case|:
block|{
name|install_from_abspath
operator|=
name|their_abspath
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_mine_full
case|:
block|{
comment|/* In case of selecting to resolve the conflict choosing the full              own file, allow the text conflict resolution to just take the              existing local file if no merged file was present (case: binary              file conflicts do not generate a locally merge file).           */
name|install_from_abspath
operator|=
name|mine_abspath
condition|?
name|mine_abspath
else|:
name|local_abspath
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_theirs_conflict
case|:
case|case
name|svn_wc_conflict_choose_mine_conflict
case|:
block|{
name|svn_diff_conflict_display_style_t
name|style
init|=
name|choice
operator|==
name|svn_wc_conflict_choose_theirs_conflict
condition|?
name|svn_diff_conflict_display_latest
else|:
name|svn_diff_conflict_display_modified
decl_stmt|;
if|if
condition|(
name|mine_abspath
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict on '%s' cannot be resolved to "
literal|"'theirs-conflict' or 'mine-conflict' "
literal|"because a merged version of the file "
literal|"cannot be created."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|merge_showing_conflicts
argument_list|(
operator|&
name|install_from_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|style
argument_list|,
name|merge_options
argument_list|,
name|their_old_abspath
argument_list|,
name|mine_abspath
argument_list|,
name|their_abspath
argument_list|,
comment|/* ### why not same as other caller? */
name|svn_io_file_del_none
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|remove_source
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* For the case of 3-way file merging, we don't            really distinguish between these return values;            if the callback claims to have "generally            resolved" the situation, we still interpret            that as "OK, we'll assume the merged version is            good to use". */
case|case
name|svn_wc_conflict_choose_merged
case|:
block|{
name|install_from_abspath
operator|=
name|merged_file
condition|?
name|merged_file
else|:
name|local_abspath
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_postpone
case|:
block|{
comment|/* Assume conflict remains. */
return|return
name|SVN_NO_ERROR
return|;
block|}
default|default:
name|SVN_ERR_ASSERT
argument_list|(
name|choice
operator|==
name|svn_wc_conflict_choose_postpone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|install_from_abspath
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict on '%s' could not be resolved "
literal|"because the chosen version of the file "
literal|"is not available."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* ### It would be nice if we could somehow pass RECORD_FILEINFO          as true in some easy cases. */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|install_from_abspath
argument_list|,
name|FALSE
comment|/* use_commit_times */
argument_list|,
name|FALSE
comment|/* record_fileinfo */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_source
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|install_from_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|remove_artifact_file_if_exists
argument_list|(
operator|&
name|work_item
argument_list|,
name|found_artifact
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|their_old_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remove_artifact_file_if_exists
argument_list|(
operator|&
name|work_item
argument_list|,
name|found_artifact
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|their_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remove_artifact_file_if_exists
argument_list|(
operator|&
name|work_item
argument_list|,
name|found_artifact
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|mine_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *DESC to a new description of the text conflict in  * CONFLICT_SKEL.  If there is no text conflict in CONFLICT_SKEL, return  * an error.  *  * Use OPERATION and shallow copies of LEFT_VERSION and RIGHT_VERSION,  * rather than reading them from CONFLICT_SKEL.  Use IS_BINARY and  * MIME_TYPE for the corresponding fields of *DESC.  *  * Allocate results in RESULT_POOL.  SCRATCH_POOL is used for temporary  * allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_text_conflict_desc
parameter_list|(
name|svn_wc_conflict_description2_t
modifier|*
modifier|*
name|desc
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|char
modifier|*
name|mime_type
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|desc
operator|=
name|svn_wc_conflict_description_create_text2
argument_list|(
name|local_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|mime_type
operator|=
name|mime_type
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|is_binary
operator|=
name|mime_type
condition|?
name|svn_mime_type_is_binary
argument_list|(
name|mime_type
argument_list|)
else|:
name|FALSE
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|src_left_version
operator|=
name|left_version
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|src_right_version
operator|=
name|right_version
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_text_conflict
argument_list|(
operator|&
operator|(
operator|*
name|desc
operator|)
operator|->
name|my_abspath
argument_list|,
operator|&
operator|(
operator|*
name|desc
operator|)
operator|->
name|base_abspath
argument_list|,
operator|&
operator|(
operator|*
name|desc
operator|)
operator|->
name|their_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|merged_file
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *CONFLICT_DESC to a new description of the tree conflict in  * CONFLICT_SKEL.  If there is no tree conflict in CONFLICT_SKEL, return  * an error.  *  * Use OPERATION and shallow copies of LEFT_VERSION and RIGHT_VERSION,  * rather than reading them from CONFLICT_SKEL.  *  * Allocate results in RESULT_POOL.  SCRATCH_POOL is used for temporary  * allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_tree_conflict_desc
parameter_list|(
name|svn_wc_conflict_description2_t
modifier|*
modifier|*
name|desc
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|local_kind
decl_stmt|;
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
name|svn_wc_conflict_action_t
name|action
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
operator|&
name|action
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_missing
condition|)
name|local_kind
operator|=
name|svn_node_none
expr_stmt|;
elseif|else
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_unversioned
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_obstructed
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|local_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|action
operator|==
name|svn_wc_conflict_action_delete
operator|&&
name|left_version
operator|&&
operator|(
name|operation
operator|==
name|svn_wc_operation_update
operator|||
name|operation
operator|==
name|svn_wc_operation_switch
operator|)
operator|&&
operator|(
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|)
condition|)
block|{
comment|/* We have nothing locally to take the kind from */
name|local_kind
operator|=
name|left_version
operator|->
name|node_kind
expr_stmt|;
block|}
else|else
name|local_kind
operator|=
name|node_kind
expr_stmt|;
operator|*
name|desc
operator|=
name|svn_wc_conflict_description_create_tree2
argument_list|(
name|local_abspath
argument_list|,
name|local_kind
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|reason
operator|=
name|reason
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|action
operator|=
name|action
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Forward definition */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|resolve_tree_conflict_on_node
parameter_list|(
name|svn_boolean_t
modifier|*
name|did_resolve
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
name|apr_hash_t
modifier|*
name|resolve_later
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_invoke_resolver
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|resolver_func
parameter_list|,
name|void
modifier|*
name|resolver_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|text_conflicted
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|locations
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
operator|&
name|locations
argument_list|,
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|0
condition|)
name|left_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|0
argument_list|,
specifier|const
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|1
condition|)
name|right_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|1
argument_list|,
specifier|const
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Quick and dirty compatibility wrapper. My guess would be that most resolvers      would want to look at all properties at the same time.       ### svn currently only invokes this from the merge code to collect the list of      ### conflicted paths. Eventually this code will be the base for 'svn resolve'      ### and at that time the test coverage will improve      */
if|if
condition|(
name|prop_conflicted
condition|)
block|{
name|apr_hash_t
modifier|*
name|old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|mine_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_their_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|mark_resolved
init|=
name|TRUE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
name|NULL
argument_list|,
operator|&
name|mine_props
argument_list|,
operator|&
name|old_their_props
argument_list|,
operator|&
name|their_props
argument_list|,
operator|&
name|conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_merge
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|old_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old_props
operator|=
name|old_their_props
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|conflicted
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|conflict_remains
init|=
name|TRUE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|generate_propconflict
argument_list|(
operator|&
name|conflict_remains
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|kind
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|propname
argument_list|,
name|old_props
condition|?
name|svn_hash_gets
argument_list|(
name|old_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|mine_props
condition|?
name|svn_hash_gets
argument_list|(
name|mine_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|old_their_props
condition|?
name|svn_hash_gets
argument_list|(
name|old_their_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|their_props
condition|?
name|svn_hash_gets
argument_list|(
name|their_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|resolver_func
argument_list|,
name|resolver_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_remains
condition|)
name|mark_resolved
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|mark_resolved
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__mark_resolved_prop_conflicts
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|text_conflicted
condition|)
block|{
name|svn_skel_t
modifier|*
name|work_items
decl_stmt|;
name|svn_boolean_t
name|was_resolved
decl_stmt|;
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_wc_conflict_result_t
modifier|*
name|result
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_text_conflict_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|svn_prop_get_value
argument_list|(
name|props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|NULL
expr_stmt|;
name|was_resolved
operator|=
name|FALSE
expr_stmt|;
comment|/* Give the conflict resolution callback a chance to clean          up the conflicts before we mark the file 'conflicted' */
name|SVN_ERR
argument_list|(
name|resolver_func
argument_list|(
operator|&
name|result
argument_list|,
name|desc
argument_list|,
name|resolver_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict callback violated API:"
literal|" returned no results"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|build_text_conflict_resolve_items
argument_list|(
operator|&
name|work_items
argument_list|,
operator|&
name|was_resolved
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|result
operator|->
name|choice
argument_list|,
name|result
operator|->
name|merged_file
argument_list|,
name|result
operator|->
name|save_merged
argument_list|,
name|merge_options
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|choice
operator|!=
name|svn_wc_conflict_choose_postpone
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tree_conflicted
condition|)
block|{
name|svn_wc_conflict_result_t
modifier|*
name|result
decl_stmt|;
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|svn_boolean_t
name|resolved
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_kind
argument_list|(
operator|&
name|node_kind
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_tree_conflict_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
name|conflict_skel
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the resolver func about this conflict. */
name|SVN_ERR
argument_list|(
name|resolver_func
argument_list|(
operator|&
name|result
argument_list|,
name|desc
argument_list|,
name|resolver_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict callback violated API:"
literal|" returned no results"
argument_list|)
argument_list|)
return|;
comment|/* Pass retry hash to avoid erroring out on cases where update          can continue safely. ### Need notify handling */
if|if
condition|(
name|result
operator|->
name|choice
operator|!=
name|svn_wc_conflict_choose_postpone
condition|)
name|SVN_ERR
argument_list|(
name|resolve_tree_conflict_on_node
argument_list|(
operator|&
name|resolved
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|result
operator|->
name|choice
argument_list|,
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* ### notify */
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read all property conflicts contained in CONFLICT_SKEL into  * individual conflict descriptions, and append those descriptions  * to the CONFLICTS array.  If there is no property conflict in  * CONFLICT_SKEL, return an error.  *  * If NOT create_tempfiles, always create a legacy property conflict  * descriptor.  *  * Use NODE_KIND, OPERATION and shallow copies of LEFT_VERSION and  * RIGHT_VERSION, rather than reading them from CONFLICT_SKEL.  *  * Allocate results in RESULT_POOL. SCRATCH_POOL is used for temporary  * allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_prop_conflict_descs
parameter_list|(
name|apr_array_header_t
modifier|*
name|conflicts
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_boolean_t
name|create_tempfiles
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prop_reject_abspath
decl_stmt|;
name|apr_hash_t
modifier|*
name|base_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|my_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted_props
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_conflicted
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
operator|&
name|prop_reject_abspath
argument_list|,
operator|&
name|my_props
argument_list|,
operator|&
name|their_old_props
argument_list|,
operator|&
name|their_props
argument_list|,
operator|&
name|conflicted_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|prop_reject_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|prop_reject_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|conflicted_props
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Legacy prop conflict with only a .reject file. */
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|svn_wc_conflict_description_create_prop2
argument_list|(
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
literal|""
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* ### For property conflicts, cd2 stores prop_reject_abspath in        * ### their_abspath, and stores theirs_abspath in merged_file. */
name|desc
operator|->
name|prop_reject_abspath
operator|=
name|prop_reject_abspath
expr_stmt|;
comment|/* in result_pool */
name|desc
operator|->
name|their_abspath
operator|=
name|desc
operator|->
name|prop_reject_abspath
expr_stmt|;
name|desc
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|desc
operator|->
name|src_left_version
operator|=
name|left_version
expr_stmt|;
name|desc
operator|->
name|src_right_version
operator|=
name|right_version
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|conflicts
argument_list|,
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
operator|=
name|desc
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_merge
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|base_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|base_props
operator|=
name|NULL
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|conflicted_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|old_value
decl_stmt|;
name|svn_string_t
modifier|*
name|my_value
decl_stmt|;
name|svn_string_t
modifier|*
name|their_value
decl_stmt|;
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|desc
operator|=
name|svn_wc_conflict_description_create_prop2
argument_list|(
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
name|propname
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|desc
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|desc
operator|->
name|src_left_version
operator|=
name|left_version
expr_stmt|;
name|desc
operator|->
name|src_right_version
operator|=
name|right_version
expr_stmt|;
name|desc
operator|->
name|property_name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|my_value
operator|=
name|svn_hash_gets
argument_list|(
name|my_props
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|their_value
operator|=
name|svn_hash_gets
argument_list|(
name|their_props
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|old_value
operator|=
name|svn_hash_gets
argument_list|(
name|their_old_props
argument_list|,
name|propname
argument_list|)
expr_stmt|;
comment|/* Compute the incoming side of the conflict ('action'). */
if|if
condition|(
name|their_value
operator|==
name|NULL
condition|)
name|desc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_delete
expr_stmt|;
elseif|else
if|if
condition|(
name|old_value
operator|==
name|NULL
condition|)
name|desc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_add
expr_stmt|;
else|else
name|desc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_edit
expr_stmt|;
comment|/* Compute the local side of the conflict ('reason'). */
if|if
condition|(
name|my_value
operator|==
name|NULL
condition|)
name|desc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
elseif|else
if|if
condition|(
name|old_value
operator|==
name|NULL
condition|)
name|desc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_added
expr_stmt|;
else|else
name|desc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_edited
expr_stmt|;
comment|/* ### For property conflicts, cd2 stores prop_reject_abspath in        * ### their_abspath, and stores theirs_abspath in merged_file. */
name|desc
operator|->
name|prop_reject_abspath
operator|=
name|prop_reject_abspath
expr_stmt|;
comment|/* in result_pool */
name|desc
operator|->
name|their_abspath
operator|=
name|desc
operator|->
name|prop_reject_abspath
expr_stmt|;
name|desc
operator|->
name|prop_value_base
operator|=
name|base_props
condition|?
name|svn_hash_gets
argument_list|(
name|base_props
argument_list|,
name|propname
argument_list|)
else|:
name|desc
operator|->
name|prop_value_incoming_old
expr_stmt|;
if|if
condition|(
name|my_value
condition|)
block|{
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
if|if
condition|(
name|create_tempfiles
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|desc
operator|->
name|my_abspath
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|my_value
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|s
argument_list|,
name|my_value
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|prop_value_working
operator|=
name|svn_string_dup
argument_list|(
name|my_value
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|their_value
condition|)
block|{
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* ### For property conflicts, cd2 stores prop_reject_abspath in            * ### their_abspath, and stores theirs_abspath in merged_file. */
if|if
condition|(
name|create_tempfiles
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|desc
operator|->
name|merged_file
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|their_value
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|s
argument_list|,
name|their_value
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|prop_value_incoming_new
operator|=
name|svn_string_dup
argument_list|(
name|their_value
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_value
condition|)
block|{
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
if|if
condition|(
name|create_tempfiles
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|desc
operator|->
name|base_abspath
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|old_value
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|s
argument_list|,
name|old_value
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|prop_value_incoming_old
operator|=
name|svn_string_dup
argument_list|(
name|old_value
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|conflicts
argument_list|,
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
operator|=
name|desc
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__read_conflicts
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
modifier|*
name|conflicts
parameter_list|,
name|svn_skel_t
modifier|*
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|create_tempfiles
parameter_list|,
name|svn_boolean_t
name|only_tree_conflict
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|the_conflict_skel
decl_stmt|;
name|apr_array_header_t
modifier|*
name|cflcts
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|svn_boolean_t
name|text_conflicted
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|locations
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
init|=
name|NULL
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
if|if
condition|(
operator|!
name|conflict_skel
condition|)
name|conflict_skel
operator|=
operator|&
name|the_conflict_skel
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
name|conflict_skel
argument_list|,
operator|&
name|node_kind
argument_list|,
operator|&
name|props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
operator|(
name|conflict_skel
operator|==
operator|&
name|the_conflict_skel
operator|)
condition|?
name|scratch_pool
else|:
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|conflict_skel
condition|)
block|{
comment|/* Some callers expect not NULL */
operator|*
name|conflicts
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
operator|&
name|locations
argument_list|,
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
operator|*
name|conflict_skel
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cflcts
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|0
condition|)
name|left_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|0
argument_list|,
specifier|const
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|1
condition|)
name|right_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|1
argument_list|,
specifier|const
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_conflicted
operator|&&
operator|!
name|only_tree_conflict
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_prop_conflict_descs
argument_list|(
name|cflcts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
operator|*
name|conflict_skel
argument_list|,
name|create_tempfiles
argument_list|,
name|node_kind
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|text_conflicted
operator|&&
operator|!
name|only_tree_conflict
condition|)
block|{
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_text_conflict_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
operator|*
name|conflict_skel
argument_list|,
name|svn_prop_get_value
argument_list|(
name|props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|cflcts
argument_list|,
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
operator|=
name|desc
expr_stmt|;
block|}
if|if
condition|(
name|tree_conflicted
condition|)
block|{
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_tree_conflict_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
operator|*
name|conflict_skel
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|cflcts
argument_list|,
specifier|const
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
operator|=
name|desc
expr_stmt|;
block|}
operator|*
name|conflicts
operator|=
name|cflcts
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Resolving a conflict automatically ***/
end_comment

begin_comment
comment|/*  * Resolve the property conflicts found in DB/LOCAL_ABSPATH according  * to CONFLICT_CHOICE.  *  * It is not an error if there is no prop conflict. If a prop conflict  * existed and was resolved, set *DID_RESOLVE to TRUE, else set it to FALSE.  *  * Note: When there are no conflict markers on-disk to remove there is  * no existing text conflict (unless we are still in the process of  * creating the text conflict and we didn't register a marker file yet).  * In this case the database contains old information, which we should  * remove to avoid checking the next time. Resolving a property conflict  * by just removing the marker file is a fully supported scenario since  * Subversion 1.0.  *  * ### TODO [JAF] The '*_full' and '*_conflict' choices should differ.  *     In my opinion, 'mine_full'/'theirs_full' should select  *     the entire set of properties from 'mine' or 'theirs' respectively,  *     while 'mine_conflict'/'theirs_conflict' should select just the  *     properties that are in conflict.  Or, '_full' should select the  *     entire property whereas '_conflict' should do a text merge within  *     each property, selecting hunks.  Or all three kinds of behaviour  *     should be available (full set of props, full value of conflicting  *     props, or conflicting text hunks).  * ### BH: If we make *_full select the full set of properties, we should  *     check if we shouldn't make it also select the full text for files.  *  * ### TODO [JAF] All this complexity should not be down here in libsvn_wc  *     but in a layer above.  *  * ### TODO [JAF] Options for 'base' should be like options for 'mine' and  *     for 'theirs' -- choose full set of props, full value of conflicting  *     props, or conflicting text hunks.  *  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_prop_conflict_on_node
parameter_list|(
name|svn_boolean_t
modifier|*
name|did_resolve
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_skel_t
modifier|*
name|conflicts
parameter_list|,
specifier|const
name|char
modifier|*
name|conflicted_propname
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_file
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|merged_value
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prop_reject_file
decl_stmt|;
name|apr_hash_t
modifier|*
name|mine_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|resolve_from
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|apr_hash_t
modifier|*
name|actual_props
decl_stmt|;
name|svn_boolean_t
name|resolved_all
decl_stmt|,
name|resolved_all_prop
decl_stmt|;
operator|*
name|did_resolve
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_conflicted
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
operator|&
name|prop_reject_file
argument_list|,
operator|&
name|mine_props
argument_list|,
operator|&
name|their_old_props
argument_list|,
operator|&
name|their_props
argument_list|,
operator|&
name|conflicted_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflicted_props
condition|)
block|{
comment|/* We have a pre 1.8 property conflict. Just mark it resolved */
name|SVN_ERR
argument_list|(
name|remove_artifact_file_if_exists
argument_list|(
operator|&
name|work_items
argument_list|,
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|prop_reject_file
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|conflicted_propname
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|svn_hash_gets
argument_list|(
name|conflicted_props
argument_list|,
name|conflicted_propname
argument_list|)
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
comment|/* This property is not conflicted! */
block|}
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_merge
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|old_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old_props
operator|=
name|their_old_props
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|actual_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We currently handle *_conflict as *_full as this argument is currently      always applied for all conflicts on a node at the same time. Giving      an error would break some tests that assumed that this would just      resolve property conflicts to working.       An alternative way to handle these conflicts would be to just copy all      property state from mine/theirs on the _full option instead of just the      conflicted properties. In some ways this feels like a sensible option as      that would take both properties and text from mine/theirs, but when not      both properties and text are conflicted we would fail in doing so.    */
switch|switch
condition|(
name|conflict_choice
condition|)
block|{
case|case
name|svn_wc_conflict_choose_base
case|:
name|resolve_from
operator|=
name|their_old_props
condition|?
name|their_old_props
else|:
name|old_props
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_mine_full
case|:
case|case
name|svn_wc_conflict_choose_mine_conflict
case|:
name|resolve_from
operator|=
name|mine_props
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_theirs_full
case|:
case|case
name|svn_wc_conflict_choose_theirs_conflict
case|:
name|resolve_from
operator|=
name|their_props
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_merged
case|:
if|if
condition|(
operator|(
name|merged_file
operator|||
name|merged_value
operator|)
operator|&&
name|conflicted_propname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|resolve_from
operator|=
name|apr_hash_copy
argument_list|(
name|scratch_pool
argument_list|,
name|actual_props
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merged_value
condition|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_string_t
modifier|*
name|merged_propval
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|merged_file
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_string_from_stream
argument_list|(
operator|&
name|merged_propval
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|merged_value
operator|=
name|merged_propval
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|resolve_from
argument_list|,
name|conflicted_propname
argument_list|,
name|merged_value
argument_list|)
expr_stmt|;
block|}
else|else
name|resolve_from
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid 'conflict_result' argument"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|resolve_from
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|apply_on_props
decl_stmt|;
if|if
condition|(
name|conflicted_propname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Apply to all conflicted properties */
name|apply_on_props
operator|=
name|conflicted_props
expr_stmt|;
block|}
else|else
block|{
comment|/* Apply to a single property */
name|apply_on_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|apply_on_props
argument_list|,
name|conflicted_propname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Apply the selected changes */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|apply_on_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|new_value
init|=
name|NULL
decl_stmt|;
name|new_value
operator|=
name|svn_hash_gets
argument_list|(
name|resolve_from
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|actual_props
argument_list|,
name|propname
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*else the user accepted the properties as-is */
comment|/* This function handles conflicted_propname "" as resolving      all property conflicts... Just what we need here */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_resolve
argument_list|(
operator|&
name|resolved_all
argument_list|,
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|conflicted_propname
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resolved_all
condition|)
block|{
comment|/* Are there still property conflicts left? (or only...) */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|resolved_all_prop
operator|=
operator|(
operator|!
name|prop_conflicted
operator|)
expr_stmt|;
block|}
else|else
block|{
name|resolved_all_prop
operator|=
name|TRUE
expr_stmt|;
name|conflicts
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|resolved_all_prop
condition|)
block|{
comment|/* Legacy behavior: Only report property conflicts as resolved when the          property reject file exists           If not the UI shows the conflict as already resolved          (and in this case we just remove the in-db conflict) */
name|SVN_ERR
argument_list|(
name|remove_artifact_file_if_exists
argument_list|(
operator|&
name|work_items
argument_list|,
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|prop_reject_file
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a new prej file, based on the remaining conflicts */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_prej_install
argument_list|(
operator|&
name|work_items
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
comment|/* We resolved a property conflict */
block|}
comment|/* This installs the updated conflict skel */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_set_props
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|actual_props
argument_list|,
name|FALSE
argument_list|,
name|conflicts
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolved_all
condition|)
block|{
comment|/* Remove the whole conflict. Should probably be integrated          into the op_set_props() call */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve the tree conflict found in DB/LOCAL_ABSPATH according to  * CONFLICT_CHOICE.  *  * It is not an error if there is no tree conflict. If a tree conflict  * existed and was resolved, set *DID_RESOLVE to TRUE, else set it to FALSE.  *  * It is not an error if there is no tree conflict.  *  * If the conflict can't be resolved yet because another tree conflict is  * blocking a storage location, store the tree conflict in the RESOLVE_LATER  * hash.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_tree_conflict_on_node
parameter_list|(
name|svn_boolean_t
modifier|*
name|did_resolve
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflicts
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
name|apr_hash_t
modifier|*
name|resolve_later
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
name|svn_wc_conflict_action_t
name|action
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_op_root_abspath
decl_stmt|;
operator|*
name|did_resolve
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_conflicted
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|src_op_root_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_update
operator|||
name|operation
operator|==
name|svn_wc_operation_switch
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_replaced
condition|)
block|{
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_merged
condition|)
block|{
comment|/* Break moves for any children moved out of this directory,                * and leave this directory deleted. */
if|if
condition|(
name|action
operator|!=
name|svn_wc_conflict_action_delete
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_break_moved_away
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|src_op_root_abspath
argument_list|,
name|TRUE
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* Marked resolved by function*/
block|}
comment|/* else # The move is/moves are already broken */
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_mine_conflict
condition|)
block|{
name|svn_skel_t
modifier|*
name|new_conflicts
decl_stmt|;
comment|/* Raise moved-away conflicts on any children moved out of                * this directory, and leave this directory as-is.                *                * The newly conflicted moved-away children will be updated                * if they are resolved with 'mine_conflict' as well. */
name|err
operator|=
name|svn_wc__db_op_raise_moved_away
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
specifier|const
name|char
modifier|*
name|dup_abspath
decl_stmt|;
if|if
condition|(
operator|!
name|resolve_later
operator|||
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|dup_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|resolve_later
argument_list|)
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|resolve_later
argument_list|,
name|dup_abspath
argument_list|,
name|dup_abspath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* Retry after other conflicts */
block|}
comment|/* We might now have a moved-away on *this* path, let's                  try to resolve that directly if that is the case */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|new_conflicts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_conflicts
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|new_conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_conflicts
operator|||
operator|!
name|tree_conflicted
condition|)
block|{
comment|/* TC is marked resolved by calling                      svn_wc__db_resolve_delete_raise_moved_away */
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|src_op_root_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|new_conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|!=
name|svn_wc_conflict_reason_moved_away
condition|)
block|{
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* We fixed one, but... */
block|}
name|conflicts
operator|=
name|new_conflicts
expr_stmt|;
comment|/* Fall through in moved_away handling */
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Tree conflict can only be resolved to "
literal|"'working' or 'mine-conflict' state; "
literal|"'%s' not resolved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|&&
name|action
operator|==
name|svn_wc_conflict_action_edit
condition|)
block|{
comment|/* After updates, we can resolve local moved-away            * vs. any incoming change, either by updating the            * moved-away node (mine-conflict) or by breaking the            * move (theirs-conflict). */
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_mine_conflict
condition|)
block|{
name|err
operator|=
name|svn_wc__db_update_moved_away_conflict_victim
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|src_op_root_abspath
argument_list|,
name|operation
argument_list|,
name|action
argument_list|,
name|reason
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
specifier|const
name|char
modifier|*
name|dup_abspath
decl_stmt|;
if|if
condition|(
operator|!
name|resolve_later
operator|||
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|dup_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|resolve_later
argument_list|)
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|resolve_later
argument_list|,
name|dup_abspath
argument_list|,
name|dup_abspath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* Retry after other conflicts */
block|}
else|else
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_merged
condition|)
block|{
comment|/* We must break the move if the user accepts the current                * working copy state instead of updating the move.                * Else the move would be left in an invalid state. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_break_moved_away
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|src_op_root_abspath
argument_list|,
name|TRUE
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* Conflict is marked resolved */
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Tree conflict can only be resolved to "
literal|"'working' or 'mine-conflict' state; "
literal|"'%s' not resolved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|&&
name|action
operator|!=
name|svn_wc_conflict_action_edit
condition|)
block|{
comment|/* action added is impossible, because that would imply that              something was added, but before that already moved...              (which would imply a replace) */
name|SVN_ERR_ASSERT
argument_list|(
name|action
operator|==
name|svn_wc_conflict_action_delete
operator|||
name|action
operator|==
name|svn_wc_conflict_action_replace
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_merged
condition|)
block|{
comment|/* Whatever was moved is removed at its original location by the                  update. That must also remove the recording of the move, so                  we don't have to do anything here. */
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_mine_conflict
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Tree conflict can only be "
literal|"resolved to 'working' state; "
literal|"'%s' is no longer moved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|did_resolve
condition|)
block|{
if|if
condition|(
name|conflict_choice
operator|!=
name|svn_wc_conflict_choose_merged
condition|)
block|{
comment|/* For other tree conflicts, there is no way to pick            * theirs-full or mine-full, etc. Throw an error if the            * user expects us to be smarter than we really are. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Tree conflict can only be "
literal|"resolved to 'working' state; "
literal|"'%s' not resolved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|did_resolve
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__mark_resolved_text_conflict
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|work_items
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflict
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|build_text_conflict_resolve_items
argument_list|(
operator|&
name|work_items
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict
argument_list|,
name|svn_wc_conflict_choose_merged
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__mark_resolved_prop_conflicts
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|ignored_result
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflicts
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflicts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflicts
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_trace
argument_list|(
name|resolve_prop_conflict_on_node
argument_list|(
operator|&
name|ignored_result
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
literal|""
argument_list|,
name|svn_wc_conflict_choose_merged
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton for conflict_status_walker */
end_comment

begin_struct
struct|struct
name|conflict_status_walker_baton
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
name|svn_boolean_t
name|resolve_text
decl_stmt|;
specifier|const
name|char
modifier|*
name|resolve_prop
decl_stmt|;
name|svn_boolean_t
name|resolve_tree
decl_stmt|;
name|svn_wc_conflict_choice_t
name|conflict_choice
decl_stmt|;
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
decl_stmt|;
name|void
modifier|*
name|conflict_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
name|svn_wc_notify_func2_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|svn_boolean_t
name|resolved_one
decl_stmt|;
name|apr_hash_t
modifier|*
name|resolve_later
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_wc_notify_func2_t to collect new conflicts caused by    resolving a tree conflict. */
end_comment

begin_function
specifier|static
name|void
name|tree_conflict_collector
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_wc_notify_t
modifier|*
name|notify
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|conflict_status_walker_baton
modifier|*
name|cswb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|cswb
operator|->
name|notify_func
condition|)
name|cswb
operator|->
name|notify_func
argument_list|(
name|cswb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cswb
operator|->
name|resolve_later
operator|&&
operator|(
name|notify
operator|->
name|action
operator|==
name|svn_wc_notify_tree_conflict
operator|||
name|notify
operator|->
name|prop_state
operator|==
name|svn_wc_notify_state_conflicted
operator|||
name|notify
operator|->
name|content_state
operator|==
name|svn_wc_notify_state_conflicted
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|cswb
operator|->
name|resolve_later
argument_list|,
name|notify
operator|->
name|path
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|dup_path
decl_stmt|;
name|dup_path
operator|=
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|cswb
operator|->
name|resolve_later
argument_list|)
argument_list|,
name|notify
operator|->
name|path
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|cswb
operator|->
name|resolve_later
argument_list|,
name|dup_path
argument_list|,
name|dup_path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Implements svn_wc_status4_t to walk all conflicts to resolve.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict_status_walker
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|conflict_status_walker_baton
modifier|*
name|cswb
init|=
name|baton
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
init|=
name|cswb
operator|->
name|db
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|conflicts
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|resolved
init|=
name|FALSE
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
if|if
condition|(
operator|!
name|status
operator|->
name|conflicted
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__read_conflicts
argument_list|(
operator|&
name|conflicts
argument_list|,
operator|&
name|conflict
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
operator|(
name|cswb
operator|->
name|conflict_func
operator|!=
name|NULL
operator|)
comment|/* tmp files */
argument_list|,
name|FALSE
comment|/* only tree conflicts */
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|conflicts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|cd
decl_stmt|;
name|svn_boolean_t
name|did_resolve
decl_stmt|;
name|svn_wc_conflict_choice_t
name|my_choice
init|=
name|cswb
operator|->
name|conflict_choice
decl_stmt|;
name|svn_wc_conflict_result_t
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_items
decl_stmt|;
name|cd
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|conflicts
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_property
operator|&&
operator|(
operator|!
name|cswb
operator|->
name|resolve_prop
operator|||
operator|(
operator|*
name|cswb
operator|->
name|resolve_prop
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|cswb
operator|->
name|resolve_prop
argument_list|,
name|cd
operator|->
name|property_name
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|cd
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_text
operator|&&
operator|!
name|cswb
operator|->
name|resolve_text
operator|)
operator|||
operator|(
name|cd
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_tree
operator|&&
operator|!
name|cswb
operator|->
name|resolve_tree
operator|)
condition|)
block|{
continue|continue;
comment|/* Easy out. Don't call resolver func and ignore result */
block|}
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_choice
operator|==
name|svn_wc_conflict_choose_unspecified
condition|)
block|{
if|if
condition|(
operator|!
name|cswb
operator|->
name|conflict_func
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No conflict-callback and no "
literal|"pre-defined conflict-choice provided"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|cswb
operator|->
name|conflict_func
argument_list|(
operator|&
name|result
argument_list|,
name|cd
argument_list|,
name|cswb
operator|->
name|conflict_baton
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|my_choice
operator|=
name|result
operator|->
name|choice
expr_stmt|;
block|}
if|if
condition|(
name|my_choice
operator|==
name|svn_wc_conflict_choose_postpone
condition|)
continue|continue;
switch|switch
condition|(
name|cd
operator|->
name|kind
condition|)
block|{
case|case
name|svn_wc_conflict_kind_tree
case|:
name|SVN_ERR
argument_list|(
name|resolve_tree_conflict_on_node
argument_list|(
operator|&
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict
argument_list|,
name|my_choice
argument_list|,
name|cswb
operator|->
name|resolve_later
argument_list|,
name|tree_conflict_collector
argument_list|,
name|cswb
argument_list|,
name|cswb
operator|->
name|cancel_func
argument_list|,
name|cswb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_resolve
condition|)
name|resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_kind_text
case|:
name|SVN_ERR
argument_list|(
name|build_text_conflict_resolve_items
argument_list|(
operator|&
name|work_items
argument_list|,
operator|&
name|resolved
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict
argument_list|,
name|my_choice
argument_list|,
name|result
condition|?
name|result
operator|->
name|merged_file
else|:
name|NULL
argument_list|,
name|result
condition|?
name|result
operator|->
name|save_merged
else|:
name|FALSE
argument_list|,
name|NULL
comment|/* merge_options */
argument_list|,
name|cswb
operator|->
name|cancel_func
argument_list|,
name|cswb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|work_items
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cswb
operator|->
name|cancel_func
argument_list|,
name|cswb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_kind_property
case|:
name|SVN_ERR
argument_list|(
name|resolve_prop_conflict_on_node
argument_list|(
operator|&
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict
argument_list|,
name|cd
operator|->
name|property_name
argument_list|,
name|my_choice
argument_list|,
name|result
condition|?
name|result
operator|->
name|merged_file
else|:
name|NULL
argument_list|,
name|result
condition|?
name|result
operator|->
name|merged_value
else|:
name|NULL
argument_list|,
name|cswb
operator|->
name|cancel_func
argument_list|,
name|cswb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_resolve
condition|)
name|resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
comment|/* We can't resolve other conflict types */
break|break;
block|}
block|}
comment|/* Notify */
if|if
condition|(
name|cswb
operator|->
name|notify_func
operator|&&
name|resolved
condition|)
name|cswb
operator|->
name|notify_func
argument_list|(
name|cswb
operator|->
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_resolved
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolved
condition|)
name|cswb
operator|->
name|resolved_one
operator|=
name|TRUE
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__resolve_conflicts
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|resolve_text
parameter_list|,
specifier|const
name|char
modifier|*
name|resolve_prop
parameter_list|,
name|svn_boolean_t
name|resolve_tree
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|struct
name|conflict_status_walker_baton
name|cswb
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* ### Just a versioned check? */
comment|/* Conflicted is set to allow invoking on actual only nodes */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When the implementation still used the entry walker, depth      unknown was translated to infinity. */
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
name|depth
operator|=
name|svn_depth_empty
expr_stmt|;
elseif|else
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|cswb
operator|.
name|db
operator|=
name|wc_ctx
operator|->
name|db
expr_stmt|;
name|cswb
operator|.
name|resolve_text
operator|=
name|resolve_text
expr_stmt|;
name|cswb
operator|.
name|resolve_prop
operator|=
name|resolve_prop
expr_stmt|;
name|cswb
operator|.
name|resolve_tree
operator|=
name|resolve_tree
expr_stmt|;
name|cswb
operator|.
name|conflict_choice
operator|=
name|conflict_choice
expr_stmt|;
name|cswb
operator|.
name|conflict_func
operator|=
name|conflict_func
expr_stmt|;
name|cswb
operator|.
name|conflict_baton
operator|=
name|conflict_baton
expr_stmt|;
name|cswb
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|cswb
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|cswb
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|cswb
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|cswb
operator|.
name|resolved_one
operator|=
name|FALSE
expr_stmt|;
name|cswb
operator|.
name|resolve_later
operator|=
operator|(
name|depth
operator|!=
name|svn_depth_empty
operator|)
condition|?
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_conflict_resolver_starting
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc_walk_status
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|FALSE
comment|/* get_all */
argument_list|,
name|FALSE
comment|/* no_ignore */
argument_list|,
name|TRUE
comment|/* ignore_text_mods */
argument_list|,
name|NULL
comment|/* ignore_patterns */
argument_list|,
name|conflict_status_walker
argument_list|,
operator|&
name|cswb
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If we got new tree conflicts (or delayed conflicts) during the initial      walk, we now walk them one by one as closure. */
while|while
condition|(
operator|!
name|err
operator|&&
name|cswb
operator|.
name|resolve_later
operator|&&
name|apr_hash_count
argument_list|(
name|cswb
operator|.
name|resolve_later
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_wc_status3_t
modifier|*
name|status
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|tc_abspath
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|iterpool
condition|)
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
else|else
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|cswb
operator|.
name|resolve_later
argument_list|)
expr_stmt|;
name|cswb
operator|.
name|resolve_later
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|cswb
operator|.
name|resolved_one
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
name|hi
operator|&&
operator|!
name|err
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|tc_abspath
operator|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|local_abspath
argument_list|,
name|tc_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relpath
operator|||
operator|(
name|depth
operator|>=
name|svn_depth_empty
operator|&&
name|depth
operator|<
name|svn_depth_infinity
operator|&&
name|strchr
argument_list|(
name|relpath
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc_status3
argument_list|(
operator|&
name|status
argument_list|,
name|wc_ctx
argument_list|,
name|tc_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|&&
name|status
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
continue|continue;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|conflict_status_walker
argument_list|(
operator|&
name|cswb
argument_list|,
name|tc_abspath
argument_list|,
name|status
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* None of the remaining conflicts got resolved, and non did provide          an error...           We can fix that if we disable the 'resolve_later' option...        */
if|if
condition|(
operator|!
name|cswb
operator|.
name|resolved_one
operator|&&
operator|!
name|err
operator|&&
name|tc_abspath
operator|&&
name|apr_hash_count
argument_list|(
name|cswb
operator|.
name|resolve_later
argument_list|)
condition|)
block|{
comment|/* Run the last resolve operation again. We still have status              and tc_abspath for that one. */
name|cswb
operator|.
name|resolve_later
operator|=
name|NULL
expr_stmt|;
comment|/* Produce proper error! */
comment|/* Recreate the error */
name|err
operator|=
name|svn_error_trace
argument_list|(
name|conflict_status_walker
argument_list|(
operator|&
name|cswb
argument_list|,
name|tc_abspath
argument_list|,
name|status
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|err
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Unable to resolve pending conflict on '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|tc_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|iterpool
condition|)
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
condition|)
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Unable to resolve conflicts on '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_conflict_resolver_done
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_resolved_conflict5
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|resolve_text
parameter_list|,
specifier|const
name|char
modifier|*
name|resolve_prop
parameter_list|,
name|svn_boolean_t
name|resolve_tree
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__resolve_conflicts
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|resolve_text
argument_list|,
name|resolve_prop
argument_list|,
name|resolve_tree
argument_list|,
name|conflict_choice
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Constructor for the result-structure returned by conflict callbacks. */
end_comment

begin_function
name|svn_wc_conflict_result_t
modifier|*
name|svn_wc_create_conflict_result
parameter_list|(
name|svn_wc_conflict_choice_t
name|choice
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_conflict_result_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|choice
operator|=
name|choice
expr_stmt|;
name|result
operator|->
name|merged_file
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|merged_file
argument_list|)
expr_stmt|;
name|result
operator|->
name|save_merged
operator|=
name|FALSE
expr_stmt|;
comment|/* If we add more fields to svn_wc_conflict_result_t, add them here. */
return|return
name|result
return|;
block|}
end_function

end_unit

