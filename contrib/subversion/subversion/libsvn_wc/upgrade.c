begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * upgrade.c:  routines for upgrading a working copy  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"entries.h"
end_include

begin_include
include|#
directive|include
file|"wc_db.h"
end_include

begin_include
include|#
directive|include
file|"tree_conflicts.h"
end_include

begin_include
include|#
directive|include
file|"wc-queries.h"
end_include

begin_comment
comment|/* for STMT_*  */
end_comment

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sqlite.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_token.h"
end_include

begin_comment
comment|/* WC-1.0 administrative area extensions */
end_comment

begin_define
define|#
directive|define
name|SVN_WC__BASE_EXT
value|".svn-base"
end_define

begin_comment
comment|/* for text and prop bases */
end_comment

begin_define
define|#
directive|define
name|SVN_WC__WORK_EXT
value|".svn-work"
end_define

begin_comment
comment|/* for working propfiles */
end_comment

begin_define
define|#
directive|define
name|SVN_WC__REVERT_EXT
value|".svn-revert"
end_define

begin_comment
comment|/* for reverting a replaced                                                file */
end_comment

begin_comment
comment|/* Old locations for storing "wcprops" (aka "dav cache").  */
end_comment

begin_define
define|#
directive|define
name|WCPROPS_SUBDIR_FOR_FILES
value|"wcprops"
end_define

begin_define
define|#
directive|define
name|WCPROPS_FNAME_FOR_DIR
value|"dir-wcprops"
end_define

begin_define
define|#
directive|define
name|WCPROPS_ALL_DATA
value|"all-wcprops"
end_define

begin_comment
comment|/* Old property locations. */
end_comment

begin_define
define|#
directive|define
name|PROPS_SUBDIR
value|"props"
end_define

begin_define
define|#
directive|define
name|PROP_BASE_SUBDIR
value|"prop-base"
end_define

begin_define
define|#
directive|define
name|PROP_BASE_FOR_DIR
value|"dir-prop-base"
end_define

begin_define
define|#
directive|define
name|PROP_REVERT_FOR_DIR
value|"dir-prop-revert"
end_define

begin_define
define|#
directive|define
name|PROP_WORKING_FOR_DIR
value|"dir-props"
end_define

begin_comment
comment|/* Old textbase location. */
end_comment

begin_define
define|#
directive|define
name|TEXT_BASE_SUBDIR
value|"text-base"
end_define

begin_define
define|#
directive|define
name|TEMP_DIR
value|"tmp"
end_define

begin_comment
comment|/* Old data files that we no longer need/use.  */
end_comment

begin_define
define|#
directive|define
name|ADM_README
value|"README.txt"
end_define

begin_define
define|#
directive|define
name|ADM_EMPTY_FILE
value|"empty-file"
end_define

begin_define
define|#
directive|define
name|ADM_LOG
value|"log"
end_define

begin_define
define|#
directive|define
name|ADM_LOCK
value|"lock"
end_define

begin_comment
comment|/* New pristine location */
end_comment

begin_define
define|#
directive|define
name|PRISTINE_STORAGE_RELPATH
value|"pristine"
end_define

begin_define
define|#
directive|define
name|PRISTINE_STORAGE_EXT
value|".svn-base"
end_define

begin_comment
comment|/* Number of characters in a pristine file basename, in WC format<= 28. */
end_comment

begin_define
define|#
directive|define
name|PRISTINE_BASENAME_OLD_LEN
value|40
end_define

begin_define
define|#
directive|define
name|SDB_FILE
value|"wc.db"
end_define

begin_comment
comment|/* Read the properties from the file at PROPFILE_ABSPATH, returning them    as a hash in *PROPS. If the propfile is NOT present, then NULL will    be returned in *PROPS.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_propfile
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|propfile_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|err
operator|=
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|propfile_abspath
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* The propfile was not there. Signal with a NULL.  */
operator|*
name|props
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* A 0-bytes file signals an empty property list.      (mostly used for revert-props) */
if|if
condition|(
name|finfo
operator|.
name|size
operator|==
literal|0
condition|)
block|{
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|propfile_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### does this function need to be smarter? will we see zero-length      ### files? see props.c::load_props(). there may be more work here.      ### need a historic analysis of 1.x property storage. what will we      ### actually run into?  */
comment|/* ### loggy_write_properties() and immediate_install_props() write      ### zero-length files for "no props", so we should be a bit smarter      ### in here.  */
comment|/* ### should we be forgiving in here? I say "no". if we can't be sure,      ### then we could effectively corrupt the local working copy.  */
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
operator|*
name|props
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read one proplist (allocated from RESULT_POOL) from STREAM, and place it    into ALL_WCPROPS at NAME.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_one_proplist
parameter_list|(
name|apr_hash_t
modifier|*
name|all_wcprops
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|all_wcprops
argument_list|,
name|name
argument_list|,
name|proplist
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the wcprops from all the files in the admin area of DIR_ABSPATH,    returning them in *ALL_WCPROPS. Results are allocated in RESULT_POOL,    and temporary allocations are performed in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_many_wcprops
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|all_wcprops
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|propfile_abspath
decl_stmt|;
name|apr_hash_t
modifier|*
name|wcprops
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
specifier|const
name|char
modifier|*
name|props_dir_abspath
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
operator|*
name|all_wcprops
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* First, look at dir-wcprops. */
name|propfile_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|WCPROPS_FNAME_FOR_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_propfile
argument_list|(
operator|&
name|wcprops
argument_list|,
name|propfile_abspath
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcprops
operator|!=
name|NULL
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|all_wcprops
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|,
name|wcprops
argument_list|)
expr_stmt|;
name|props_dir_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|WCPROPS_SUBDIR_FOR_FILES
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Now walk the wcprops directory. */
name|SVN_ERR
argument_list|(
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|props_dir_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|propfile_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|props_dir_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_propfile
argument_list|(
operator|&
name|wcprops
argument_list|,
name|propfile_abspath
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|wcprops
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|all_wcprops
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|wcprops
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For wcprops stored in a single file in this working copy, read that    file and return it in *ALL_WCPROPS, allocated in RESULT_POOL.   Use    SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_wcprops
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|all_wcprops
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
operator|*
name|all_wcprops
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__open_adm_stream
argument_list|(
operator|&
name|stream
argument_list|,
name|dir_abspath
argument_list|,
name|WCPROPS_ALL_DATA
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* A non-existent file means there are no props. */
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Read the proplist for THIS_DIR. */
name|SVN_ERR
argument_list|(
name|read_one_proplist
argument_list|(
operator|*
name|all_wcprops
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And now, the children. */
while|while
condition|(
literal|1729
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|line
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
if|if
condition|(
name|line
operator|->
name|len
operator|>
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing end of line in wcprops file for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
break|break;
block|}
name|SVN_ERR
argument_list|(
name|read_one_proplist
argument_list|(
operator|*
name|all_wcprops
argument_list|,
name|line
operator|->
name|data
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return in CHILDREN, the list of all 1.6 versioned subdirectories    which also exist on disk as directories.     If DELETE_DIR is not NULL set *DELETE_DIR to TRUE if the directory    should be deleted after migrating to WC-NG, otherwise to FALSE.     If SKIP_MISSING is TRUE, don't add missing or obstructed subdirectories    to the list of children.    */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_versioned_subdirs
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|children
parameter_list|,
name|svn_boolean_t
modifier|*
name|delete_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|svn_boolean_t
name|skip_missing
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_wc_entry_t
modifier|*
name|this_dir
init|=
name|NULL
decl_stmt|;
operator|*
name|children
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|10
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__read_entries_old
argument_list|(
operator|&
name|entries
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_wc_entry_t
modifier|*
name|entry
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|;
name|svn_boolean_t
name|hidden
decl_stmt|;
comment|/* skip "this dir"  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
name|this_dir
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If a directory is 'hidden' skip it as subdir */
name|SVN_ERR
argument_list|(
name|svn_wc__entry_is_hidden
argument_list|(
operator|&
name|hidden
argument_list|,
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hidden
condition|)
continue|continue;
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dir_abspath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_missing
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|child_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
continue|continue;
block|}
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|children
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|child_abspath
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_dir
operator|!=
name|NULL
condition|)
block|{
operator|*
name|delete_dir
operator|=
operator|(
name|this_dir
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|this_dir
operator|->
name|schedule
operator|==
name|svn_wc_schedule_delete
operator|)
operator|&&
operator|!
name|this_dir
operator|->
name|keep_local
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return in CHILDREN the names of all versioned *files* in SDB that    are children of PARENT_RELPATH.  These files' existence on disk is    not tested.     This set of children is intended for property upgrades.    Subdirectory's properties exist in the subdirs.     Note that this uses just the SDB to locate children, which means    that the children must have been upgraded to wc-ng format. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_versioned_files
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
modifier|*
name|children
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_relpath
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_int64_t
name|wc_id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|apr_array_header_t
modifier|*
name|child_names
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
comment|/* ### just select 'file' children. do we need 'symlink' in the future?  */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_SELECT_ALL_FILES
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"is"
argument_list|,
name|wc_id
argument_list|,
name|parent_relpath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### 10 is based on Subversion's average of 8.5 files per versioned      ### directory in its repository. maybe use a different value? or      ### count rows first?  */
name|child_names
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|10
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
specifier|const
name|char
modifier|*
name|local_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|child_names
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_relpath_basename
argument_list|(
name|local_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|children
operator|=
name|child_names
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the path of the old-school administrative lock file    associated with LOCAL_DIR_ABSPATH, allocated from RESULT_POOL. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|build_lockfile_path
parameter_list|(
specifier|const
name|char
modifier|*
name|local_dir_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
return|return
name|svn_dirent_join_many
argument_list|(
name|result_pool
argument_list|,
name|local_dir_abspath
argument_list|,
name|svn_wc_get_adm_dir
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|ADM_LOCK
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a physical lock file in the admin directory for ABSPATH.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_physical_lock
parameter_list|(
specifier|const
name|char
modifier|*
name|abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|lock_abspath
init|=
name|build_lockfile_path
argument_list|(
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|lock_abspath
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_EXCL
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* Congratulations, we just stole a physical lock from somebody */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wipe out all the obsolete files/dirs from the administrative area.  */
end_comment

begin_function
specifier|static
name|void
name|wipe_obsolete_files
parameter_list|(
specifier|const
name|char
modifier|*
name|wcroot_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Zap unused files.  */
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|SVN_WC__ADM_FORMAT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|SVN_WC__ADM_ENTRIES
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|ADM_EMPTY_FILE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|ADM_README
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For formats<= SVN_WC__WCPROPS_MANY_FILES_VERSION, we toss the wcprops      for the directory itself, and then all the wcprops for the files.  */
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|WCPROPS_FNAME_FOR_DIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|WCPROPS_SUBDIR_FOR_FILES
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And for later formats, they are aggregated into one file.  */
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|WCPROPS_ALL_DATA
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the old text-base directory and the old text-base files. */
name|svn_error_clear
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|TEXT_BASE_SUBDIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the old properties files... whole directories at a time.  */
name|svn_error_clear
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|PROPS_SUBDIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|PROP_BASE_SUBDIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|PROP_WORKING_FOR_DIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|PROP_BASE_FOR_DIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|PROP_REVERT_FOR_DIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ### this checks for a write-lock, and we are not (always) taking out      ### a write lock in all callers.  */
block|SVN_ERR(svn_wc__adm_cleanup_tmp_area(db, wcroot_abspath, iterpool));
endif|#
directive|endif
comment|/* Remove the old-style lock file LAST.  */
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|build_lockfile_path
argument_list|(
name|wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wipe_postupgrade
parameter_list|(
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|svn_boolean_t
name|whole_admin
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|subdirs
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|delete_dir
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|cancel_func
call|)
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_versioned_subdirs
argument_list|(
operator|&
name|subdirs
argument_list|,
operator|&
name|delete_dir
argument_list|,
name|dir_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* An unversioned dir is obstructing a versioned dir */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdirs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|child_abspath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|subdirs
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wipe_postupgrade
argument_list|(
name|child_abspath
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### Should we really be ignoring errors here? */
if|if
condition|(
name|whole_admin
condition|)
name|svn_error_clear
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
literal|""
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|wipe_obsolete_files
argument_list|(
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_dir
condition|)
block|{
comment|/* If this was a WC-NG single database copy, this directory wouldn't          be here (unless it was deleted with --keep-local)           If the directory is empty, we can just delete it; if not we          keep it.        */
name|svn_error_clear
argument_list|(
name|svn_io_dir_remove_nonrecursive
argument_list|(
name|dir_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Ensure that ENTRY has its REPOS and UUID fields set. These will be    used to establish the REPOSITORY row in the new database, and then    used within the upgraded entries as they are written into the database.     If one or both are not available, then it attempts to retrieve this    information from REPOS_CACHE. And if that fails from REPOS_INFO_FUNC,    passing REPOS_INFO_BATON.    Returns a user understandable error using LOCAL_ABSPATH if the    information cannot be obtained.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_repos_info
parameter_list|(
name|svn_wc_entry_t
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc_upgrade_get_repos_info_t
name|repos_info_func
parameter_list|,
name|void
modifier|*
name|repos_info_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|repos_cache
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Easy exit.  */
if|if
condition|(
name|entry
operator|->
name|repos
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|uuid
operator|!=
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|(
name|entry
operator|->
name|repos
operator|==
name|NULL
operator|||
name|entry
operator|->
name|uuid
operator|==
name|NULL
operator|)
operator|&&
name|entry
operator|->
name|url
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|repos_cache
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
if|if
condition|(
name|svn_uri__is_ancestor
argument_list|(
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
argument_list|,
name|entry
operator|->
name|url
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|entry
operator|->
name|repos
condition|)
name|entry
operator|->
name|repos
operator|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|uuid
condition|)
name|entry
operator|->
name|uuid
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
if|if
condition|(
name|entry
operator|->
name|repos
operator|==
name|NULL
operator|&&
name|repos_info_func
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Working copy '%s' can't be upgraded because the repository root is "
literal|"not available and can't be retrieved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|entry
operator|->
name|uuid
operator|==
name|NULL
operator|&&
name|repos_info_func
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Working copy '%s' can't be upgraded because the repository uuid is "
literal|"not available and can't be retrieved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|entry
operator|->
name|url
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Working copy '%s' can't be upgraded because it doesn't have a url"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
call|(
modifier|*
name|repos_info_func
call|)
argument_list|(
operator|&
name|entry
operator|->
name|repos
argument_list|,
operator|&
name|entry
operator|->
name|uuid
argument_list|,
name|repos_info_baton
argument_list|,
name|entry
operator|->
name|url
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read tree conflict descriptions from @a conflict_data.  Set @a *conflicts  * to a hash of pointers to svn_wc_conflict_description2_t objects indexed by  * svn_wc_conflict_description2_t.local_abspath, all newly allocated in @a  * pool.  @a dir_path is the path to the working copy directory whose conflicts  * are being read.  The conflicts read are the tree conflicts on the immediate  * child nodes of @a dir_path.  Do all allocations in @a pool.  *  * Note: There were some concerns about this function:  *  * ### this is BAD. the CONFLICTS structure should not be dependent upon  * ### DIR_PATH. each conflict should be labeled with an entry name, not  * ### a whole path. (and a path which happens to vary based upon invocation  * ### of the user client and these APIs)  *  * those assumptions were baked into former versions of the data model, so  * they have to stick around here.  But they have been removed from the  * New Way. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_tree_conflicts
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|conflicts
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_data
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
operator|*
name|conflicts
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_data
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|skel
operator|=
name|svn_skel__parse
argument_list|(
name|conflict_data
argument_list|,
name|strlen
argument_list|(
name|conflict_data
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|skel
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error parsing tree conflict skel"
argument_list|)
argument_list|)
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|skel
operator|=
name|skel
operator|->
name|children
init|;
name|skel
operator|!=
name|NULL
condition|;
name|skel
operator|=
name|skel
operator|->
name|next
control|)
block|{
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|conflict
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__deserialize_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|skel
argument_list|,
name|dir_path
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict
operator|!=
name|NULL
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|conflicts
argument_list|,
name|svn_dirent_basename
argument_list|(
name|conflict
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|,
name|conflict
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|migrate_single_tree_conflict_data
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
specifier|const
name|char
modifier|*
name|tree_conflict_data
parameter_list|,
name|apr_int64_t
name|wc_id
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|conflicts
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_tree_conflicts
argument_list|(
operator|&
name|conflicts
argument_list|,
name|tree_conflict_data
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|conflicts
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|conflict
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_data
decl_stmt|;
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|conflict_relpath
operator|=
name|svn_dirent_join
argument_list|(
name|local_relpath
argument_list|,
name|svn_dirent_basename
argument_list|(
name|conflict
operator|->
name|local_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__serialize_conflict
argument_list|(
operator|&
name|skel
argument_list|,
name|conflict
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|conflict_data
operator|=
name|svn_skel__unparse
argument_list|(
name|skel
argument_list|,
name|iterpool
argument_list|)
operator|->
name|data
expr_stmt|;
comment|/* See if we need to update or insert an ACTUAL node. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_SELECT_ACTUAL_NODE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"is"
argument_list|,
name|wc_id
argument_list|,
name|conflict_relpath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_row
condition|)
block|{
comment|/* There is an existing ACTUAL row, so just update it. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_UPDATE_ACTUAL_CONFLICT_DATA
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to insert an ACTUAL row with the tree conflict data. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_INSERT_ACTUAL_CONFLICT_DATA
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"iss"
argument_list|,
name|wc_id
argument_list|,
name|conflict_relpath
argument_list|,
name|conflict_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_row
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_text
argument_list|(
name|stmt
argument_list|,
literal|4
argument_list|,
name|local_relpath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|migrate_tree_conflict_data
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Iterate over each node which has a set of tree conflicts, then insert      all of them into the new schema.  */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_UPGRADE_21_SELECT_OLD_TREE_CONFLICT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get all the existing tree conflict data. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
name|apr_int64_t
name|wc_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|tree_conflict_data
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|wc_id
operator|=
name|svn_sqlite__column_int64
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|local_relpath
operator|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|tree_conflict_data
operator|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|migrate_single_tree_conflict_data
argument_list|(
name|sdb
argument_list|,
name|tree_conflict_data
argument_list|,
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't need to do anything but step over the previously          prepared statement. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Erase all the old tree conflict data.  */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_UPGRADE_21_ERASE_OLD_CONFLICTS
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|bump_baton
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Migrate the properties for one node (LOCAL_ABSPATH).  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|migrate_node_props
parameter_list|(
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|new_wcroot_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|int
name|original_format
parameter_list|,
name|apr_int64_t
name|wc_id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base_abspath
decl_stmt|;
comment|/* old name. nowadays: "pristine"  */
specifier|const
name|char
modifier|*
name|revert_abspath
decl_stmt|;
comment|/* old name. nowadays: "BASE"  */
specifier|const
name|char
modifier|*
name|working_abspath
decl_stmt|;
comment|/* old name. nowadays: "ACTUAL"  */
name|apr_hash_t
modifier|*
name|base_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|revert_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|working_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_wcroot_abspath
init|=
name|svn_dirent_get_longest_ancestor
argument_list|(
name|dir_abspath
argument_list|,
name|new_wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_relpath
init|=
name|svn_dirent_skip_ancestor
argument_list|(
name|old_wcroot_abspath
argument_list|,
name|dir_abspath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
name|base_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|PROP_BASE_FOR_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|revert_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|PROP_REVERT_FOR_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|working_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|PROP_WORKING_FOR_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|basedir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|propsdir_abspath
decl_stmt|;
name|propsdir_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|PROPS_SUBDIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|basedir_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|PROP_BASE_SUBDIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|base_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|basedir_abspath
argument_list|,
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
name|name
argument_list|,
name|SVN_WC__BASE_EXT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|revert_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|basedir_abspath
argument_list|,
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
name|name
argument_list|,
name|SVN_WC__REVERT_EXT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|working_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|propsdir_abspath
argument_list|,
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
name|name
argument_list|,
name|SVN_WC__WORK_EXT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|read_propfile
argument_list|(
operator|&
name|base_props
argument_list|,
name|base_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_propfile
argument_list|(
operator|&
name|revert_props
argument_list|,
name|revert_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_propfile
argument_list|(
operator|&
name|working_props
argument_list|,
name|working_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_upgrade_apply_props
argument_list|(
name|sdb
argument_list|,
name|new_wcroot_abspath
argument_list|,
name|svn_relpath_join
argument_list|(
name|dir_relpath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|base_props
argument_list|,
name|revert_props
argument_list|,
name|working_props
argument_list|,
name|original_format
argument_list|,
name|wc_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|migrate_props
parameter_list|(
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|new_wcroot_abspath
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|int
name|original_format
parameter_list|,
name|apr_int64_t
name|wc_id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* General logic here: iterate over all the immediate children of the root      (since we aren't yet in a centralized system), and for any properties that      exist, map them as follows:       if (revert props exist):        revert  -> BASE        base    -> WORKING        working -> ACTUAL      else if (prop pristine is working [as defined in props.c] ):        base    -> WORKING        working -> ACTUAL      else:        base    -> BASE        working -> ACTUAL       ### the middle "test" should simply look for a WORKING_NODE row       Note that it is legal for "working" props to be missing. That implies      no local changes to the properties.   */
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_wcroot_abspath
init|=
name|svn_dirent_get_longest_ancestor
argument_list|(
name|dir_abspath
argument_list|,
name|new_wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_relpath
init|=
name|svn_dirent_skip_ancestor
argument_list|(
name|old_wcroot_abspath
argument_list|,
name|dir_abspath
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Migrate the props for "this dir".  */
name|SVN_ERR
argument_list|(
name|migrate_node_props
argument_list|(
name|dir_abspath
argument_list|,
name|new_wcroot_abspath
argument_list|,
literal|""
argument_list|,
name|sdb
argument_list|,
name|original_format
argument_list|,
name|wc_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Iterate over all the files in this SDB.  */
name|SVN_ERR
argument_list|(
name|get_versioned_files
argument_list|(
operator|&
name|children
argument_list|,
name|dir_relpath
argument_list|,
name|sdb
argument_list|,
name|wc_id
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|migrate_node_props
argument_list|(
name|dir_abspath
argument_list|,
name|new_wcroot_abspath
argument_list|,
name|name
argument_list|,
name|sdb
argument_list|,
name|original_format
argument_list|,
name|wc_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If STR ends with SUFFIX and is longer than SUFFIX, return the part of  * STR that comes before SUFFIX; else return NULL. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remove_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|size_t
name|str_len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|size_t
name|suffix_len
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|str_len
operator|>
name|suffix_len
operator|&&
name|strcmp
argument_list|(
name|str
operator|+
name|str_len
operator|-
name|suffix_len
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|str
argument_list|,
name|str_len
operator|-
name|suffix_len
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Copy all the text-base files from the administrative area of WC directory    DIR_ABSPATH into the pristine store of SDB which is located in directory    NEW_WCROOT_ABSPATH.     Set *TEXT_BASES_INFO to a new hash, allocated in RESULT_POOL, that maps    (const char *) name of the versioned file to (svn_wc__text_base_info_t *)    information about the pristine text. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|migrate_text_bases
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|text_bases_info
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|new_wcroot_abspath
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|text_base_dir
init|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|TEXT_BASE_SUBDIR
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
operator|*
name|text_bases_info
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Iterate over the text-base files */
name|SVN_ERR
argument_list|(
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|text_base_dir
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|text_base_basename
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|sha1_checksum
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Calculate its checksums and copy it to the pristine store */
block|{
specifier|const
name|char
modifier|*
name|pristine_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|text_base_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_path
decl_stmt|;
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|svn_stream_t
modifier|*
name|read_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|result_stream
decl_stmt|;
name|text_base_path
operator|=
name|svn_dirent_join
argument_list|(
name|text_base_dir
argument_list|,
name|text_base_basename
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Create a copy and calculate a checksum in one step */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|result_stream
argument_list|,
operator|&
name|temp_path
argument_list|,
name|new_wcroot_abspath
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|read_stream
argument_list|,
name|text_base_path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|read_stream
operator|=
name|svn_stream_checksummed2
argument_list|(
name|read_stream
argument_list|,
operator|&
name|md5_checksum
argument_list|,
name|NULL
argument_list|,
name|svn_checksum_md5
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|read_stream
operator|=
name|svn_stream_checksummed2
argument_list|(
name|read_stream
argument_list|,
operator|&
name|sha1_checksum
argument_list|,
name|NULL
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* This calculates the hash, creates a copy and closes the stream */
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|read_stream
argument_list|,
name|result_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|text_base_path
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert a row into the pristine table. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_INSERT_OR_IGNORE_PRISTINE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_checksum
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|sha1_checksum
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_checksum
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|,
name|md5_checksum
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_int64
argument_list|(
name|stmt
argument_list|,
literal|3
argument_list|,
name|finfo
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__insert
argument_list|(
name|NULL
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_future_path
argument_list|(
operator|&
name|pristine_path
argument_list|,
name|new_wcroot_abspath
argument_list|,
name|sha1_checksum
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ensure any sharding directories exist. */
name|SVN_ERR
argument_list|(
name|svn_wc__ensure_directory
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|pristine_path
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now move the file into the pristine store, overwriting            existing files with the same checksum. */
name|SVN_ERR
argument_list|(
name|svn_io_file_move
argument_list|(
name|temp_path
argument_list|,
name|pristine_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the checksums for this text-base to *TEXT_BASES_INFO. */
block|{
specifier|const
name|char
modifier|*
name|versioned_file_name
decl_stmt|;
name|svn_boolean_t
name|is_revert_base
decl_stmt|;
name|svn_wc__text_base_info_t
modifier|*
name|info
decl_stmt|;
name|svn_wc__text_base_file_info_t
modifier|*
name|file_info
decl_stmt|;
comment|/* Determine the versioned file name and whether this is a normal base          * or a revert base. */
name|versioned_file_name
operator|=
name|remove_suffix
argument_list|(
name|text_base_basename
argument_list|,
name|SVN_WC__REVERT_EXT
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|versioned_file_name
condition|)
block|{
name|is_revert_base
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|versioned_file_name
operator|=
name|remove_suffix
argument_list|(
name|text_base_basename
argument_list|,
name|SVN_WC__BASE_EXT
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|is_revert_base
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|versioned_file_name
condition|)
block|{
comment|/* Some file that doesn't end with .svn-base or .svn-revert.                 No idea why that would be in our administrative area, but                 we shouldn't segfault on this case.                  Note that we already copied this file in the pristine store,                 but the next cleanup will take care of that.               */
continue|continue;
block|}
comment|/* Create a new info struct for this versioned file, or fill in the          * existing one if this is the second text-base we've found for it. */
name|info
operator|=
name|svn_hash_gets
argument_list|(
operator|*
name|text_bases_info
argument_list|,
name|versioned_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
name|info
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|file_info
operator|=
operator|(
name|is_revert_base
condition|?
operator|&
name|info
operator|->
name|revert_base
else|:
operator|&
name|info
operator|->
name|normal_base
operator|)
expr_stmt|;
name|file_info
operator|->
name|sha1_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|sha1_checksum
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|file_info
operator|->
name|md5_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|md5_checksum
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|text_bases_info
argument_list|,
name|versioned_file_name
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_20
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_CREATE_NODES
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_20
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_21
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_21
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|migrate_tree_conflict_data
argument_list|(
name|sdb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_22
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_22
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_23
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
init|=
operator|(
operator|(
expr|struct
name|bump_baton
operator|*
operator|)
name|baton
operator|)
operator|->
name|wcroot_abspath
decl_stmt|;
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_UPGRADE_23_HAS_WORKING_NODES
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_row
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The working copy at '%s' is format 22 with "
literal|"WORKING nodes; use a format 22 client to "
literal|"diff/revert before using this client"
argument_list|)
argument_list|,
name|wcroot_abspath
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_23
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_24
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_24
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_CREATE_NODES_TRIGGERS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_25
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_25
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_26
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_26
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_27
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
init|=
operator|(
operator|(
expr|struct
name|bump_baton
operator|*
operator|)
name|baton
operator|)
operator|->
name|wcroot_abspath
decl_stmt|;
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_UPGRADE_27_HAS_ACTUAL_NODES_CONFLICTS
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_row
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The working copy at '%s' is format 26 with "
literal|"conflicts; use a format 26 client to resolve "
literal|"before using this client"
argument_list|)
argument_list|,
name|wcroot_abspath
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_27
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_28
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_28
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If FINFO indicates that ABSPATH names a file, rename it to  * '<ABSPATH>.svn-base'.  *  * Ignore any file whose name is not the expected length, in order to make  * life easier for any developer who runs this code twice or has some  * non-standard files in the pristine directory.  *  * A callback for bump_to_29(), implementing #svn_io_walk_func_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rename_pristine_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|abspath
parameter_list|,
specifier|const
name|apr_finfo_t
modifier|*
name|finfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|finfo
operator|->
name|filetype
operator|==
name|APR_REG
operator|&&
operator|(
name|strlen
argument_list|(
name|svn_dirent_basename
argument_list|(
name|abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
operator|==
name|PRISTINE_BASENAME_OLD_LEN
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|new_abspath
init|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|abspath
argument_list|,
name|PRISTINE_STORAGE_EXT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|abspath
argument_list|,
name|new_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|upgrade_externals
parameter_list|(
name|struct
name|bump_baton
modifier|*
name|bb
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_sqlite__stmt_t
modifier|*
name|stmt_add
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_SELECT_EXTERNAL_PROPERTIES
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt_add
argument_list|,
name|sdb
argument_list|,
name|STMT_INSERT_EXTERNAL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### For this intermediate upgrade we just assume WC_ID = 1.      ### Before this bump we lost track of externals all the time,      ### so lets keep this easy. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"is"
argument_list|,
operator|(
name|apr_int64_t
operator|)
literal|1
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|char
modifier|*
name|externals
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__column_properties
argument_list|(
operator|&
name|props
argument_list|,
name|stmt
argument_list|,
literal|0
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|externals
operator|=
name|svn_prop_get_value
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|)
expr_stmt|;
if|if
condition|(
name|externals
condition|)
block|{
name|apr_array_header_t
modifier|*
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|int
name|i
decl_stmt|;
name|local_relpath
operator|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|bb
operator|->
name|wcroot_abspath
argument_list|,
name|local_relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_parse_externals_description3
argument_list|(
operator|&
name|ext
argument_list|,
name|local_abspath
argument_list|,
name|externals
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ext
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_wc_external_item2_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|item_relpath
decl_stmt|;
name|item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|ext
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_wc_external_item2_t
operator|*
argument_list|)
expr_stmt|;
name|item_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|local_relpath
argument_list|,
name|item
operator|->
name|target_dir
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Insert dummy externals definitions: Insert an unknown                  external, to make sure it will be cleaned up when it is not                  updated on the next update. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt_add
argument_list|,
literal|"isssssis"
argument_list|,
operator|(
name|apr_int64_t
operator|)
literal|1
argument_list|,
comment|/* wc_id */
name|item_relpath
argument_list|,
name|svn_relpath_dirname
argument_list|(
name|item_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
literal|"normal"
argument_list|,
literal|"unknown"
argument_list|,
name|local_relpath
argument_list|,
operator|(
name|apr_int64_t
operator|)
literal|1
argument_list|,
comment|/* repos_id */
literal|""
comment|/* repos_relpath */
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__insert
argument_list|(
name|NULL
argument_list|,
name|stmt_add
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_29
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|bump_baton
modifier|*
name|bb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcroot_abspath
init|=
name|bb
operator|->
name|wcroot_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|pristine_dir_abspath
decl_stmt|;
comment|/* Rename all pristine files, adding a ".svn-base" suffix. */
name|pristine_dir_abspath
operator|=
name|svn_dirent_join_many
argument_list|(
name|scratch_pool
argument_list|,
name|wcroot_abspath
argument_list|,
name|svn_wc_get_adm_dir
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
name|PRISTINE_STORAGE_RELPATH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_dir_walk2
argument_list|(
name|pristine_dir_abspath
argument_list|,
name|APR_FINFO_MIN
argument_list|,
name|rename_pristine_file
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Externals */
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_CREATE_EXTERNALS
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|upgrade_externals
argument_list|(
name|bb
argument_list|,
name|sdb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_29
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__upgrade_conflict_skel_from_raw
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|conflicts
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_old
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_wrk
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_new
parameter_list|,
specifier|const
name|char
modifier|*
name|prej_file
parameter_list|,
specifier|const
name|char
modifier|*
name|tree_conflict_data
parameter_list|,
name|apr_size_t
name|tree_conflict_len
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|conflict_data
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_old
operator|||
name|conflict_new
operator|||
name|conflict_wrk
condition|)
block|{
specifier|const
name|char
modifier|*
name|old_abspath
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_abspath
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|wrk_abspath
init|=
name|NULL
decl_stmt|;
name|conflict_data
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_old
condition|)
name|old_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|wcroot_abspath
argument_list|,
name|conflict_old
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_new
condition|)
name|new_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|wcroot_abspath
argument_list|,
name|conflict_new
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_wrk
condition|)
name|wrk_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|wcroot_abspath
argument_list|,
name|conflict_wrk
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_text_conflict
argument_list|(
name|conflict_data
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|wrk_abspath
argument_list|,
name|old_abspath
argument_list|,
name|new_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prej_file
condition|)
block|{
specifier|const
name|char
modifier|*
name|prej_abspath
decl_stmt|;
if|if
condition|(
operator|!
name|conflict_data
condition|)
name|conflict_data
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|prej_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|wcroot_abspath
argument_list|,
name|prej_file
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_prop_conflict
argument_list|(
name|conflict_data
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|prej_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tree_conflict_data
condition|)
block|{
name|svn_skel_t
modifier|*
name|tc_skel
decl_stmt|;
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|tc
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
if|if
condition|(
operator|!
name|conflict_data
condition|)
name|conflict_data
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|tc_skel
operator|=
name|svn_skel__parse
argument_list|(
name|tree_conflict_data
argument_list|,
name|tree_conflict_len
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|wcroot_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__deserialize_conflict
argument_list|(
operator|&
name|tc
argument_list|,
name|tc_skel
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_tree_conflict
argument_list|(
name|conflict_data
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|tc
operator|->
name|reason
argument_list|,
name|tc
operator|->
name|action
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tc
operator|->
name|operation
condition|)
block|{
case|case
name|svn_wc_operation_update
case|:
default|default:
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_update
argument_list|(
name|conflict_data
argument_list|,
name|tc
operator|->
name|src_left_version
argument_list|,
name|tc
operator|->
name|src_right_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc_operation_switch
case|:
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_switch
argument_list|(
name|conflict_data
argument_list|,
name|tc
operator|->
name|src_left_version
argument_list|,
name|tc
operator|->
name|src_right_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc_operation_merge
case|:
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_merge
argument_list|(
name|conflict_data
argument_list|,
name|tc
operator|->
name|src_left_version
argument_list|,
name|tc
operator|->
name|src_right_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|conflict_data
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_update
argument_list|(
name|conflict_data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|conflicts
operator|=
name|conflict_data
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function to upgrade a single conflict from bump_to_30 */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_30_upgrade_one_conflict
parameter_list|(
name|svn_wc__db_t
modifier|*
name|wc_db
parameter_list|,
specifier|const
name|char
modifier|*
name|wcroot_abspath
parameter_list|,
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt_store
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|skel_data
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_data
decl_stmt|;
name|apr_int64_t
name|wc_id
init|=
name|svn_sqlite__column_int64
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_old
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_wrk
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_new
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_reject
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|5
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|apr_size_t
name|tree_conflict_size
decl_stmt|;
specifier|const
name|char
modifier|*
name|tree_conflict_data
init|=
name|svn_sqlite__column_blob
argument_list|(
name|stmt
argument_list|,
literal|6
argument_list|,
operator|&
name|tree_conflict_size
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__upgrade_conflict_skel_from_raw
argument_list|(
operator|&
name|conflict_data
argument_list|,
name|wc_db
argument_list|,
name|wcroot_abspath
argument_list|,
name|local_relpath
argument_list|,
name|conflict_old
argument_list|,
name|conflict_wrk
argument_list|,
name|conflict_new
argument_list|,
name|prop_reject
argument_list|,
name|tree_conflict_data
argument_list|,
name|tree_conflict_size
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|skel_data
operator|=
name|svn_skel__unparse
argument_list|(
name|conflict_data
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt_store
argument_list|,
name|sdb
argument_list|,
name|STMT_UPGRADE_30_SET_CONFLICT
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt_store
argument_list|,
literal|"isb"
argument_list|,
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|skel_data
operator|->
name|data
argument_list|,
name|skel_data
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt_store
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_30
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|bump_baton
modifier|*
name|bb
init|=
name|baton
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
comment|/* Read only temp db */
name|SVN_ERR
argument_list|(
name|svn_wc__db_open
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
argument_list|,
name|TRUE
comment|/* open_without_upgrade */
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_UPGRADE_30_SELECT_CONFLICT_SEPARATE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|bump_30_upgrade_one_conflict
argument_list|(
name|db
argument_list|,
name|bb
operator|->
name|wcroot_abspath
argument_list|,
name|stmt
argument_list|,
name|sdb
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_30
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_close
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_to_31
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|,
modifier|*
name|stmt_mark_switch_roots
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|empty_iprops
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_inherited_item_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|iprops_column_exists
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Add the inherited_props column to NODES if it does not yet exist.    *    * When using a format>= 31 client to upgrade from old formats which    * did not yet have a NODES table, the inherited_props column has    * already been created as part of the NODES table. Attemping to add    * the inherited_props column will raise an error in this case, so check    * if the column exists first.    *    * Checking for the existence of a column before ALTER TABLE is not    * possible within SQLite. We need to run a separate query and evaluate    * its result in C first.    */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_PRAGMA_TABLE_INFO_NODES
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
specifier|const
name|char
modifier|*
name|column_name
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|column_name
argument_list|,
literal|"inherited_props"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iprops_column_exists
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iprops_column_exists
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_31_ALTER_TABLE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run additional statements to finalize the upgrade to format 31. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_UPGRADE_TO_31_FINALIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set inherited_props to an empty array for the roots of all      switched subtrees in the WC.  This allows subsequent updates      to recognize these roots as needing an iprops cache. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_UPGRADE_31_SELECT_WCROOT_NODES
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt_mark_switch_roots
argument_list|,
name|sdb
argument_list|,
name|STMT_UPDATE_IPROP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
while|while
condition|(
name|have_row
condition|)
block|{
specifier|const
name|char
modifier|*
name|switched_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|apr_int64_t
name|wc_id
init|=
name|svn_sqlite__column_int64
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|err
operator|=
name|svn_sqlite__bindf
argument_list|(
name|stmt_mark_switch_roots
argument_list|,
literal|"is"
argument_list|,
name|wc_id
argument_list|,
name|switched_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_sqlite__bind_iprops
argument_list|(
name|stmt_mark_switch_roots
argument_list|,
literal|3
argument_list|,
name|empty_iprops
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_sqlite__step_done
argument_list|(
name|stmt_mark_switch_roots
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_error_compose_create
argument_list|(
comment|/* Reset in either order is OK. */
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt_mark_switch_roots
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|err
operator|=
name|svn_sqlite__reset
argument_list|(
name|stmt_mark_switch_roots
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|upgrade_data_t
block|{
name|svn_sqlite__db_t
modifier|*
name|sdb
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_abspath
decl_stmt|;
name|apr_int64_t
name|repos_id
decl_stmt|;
name|apr_int64_t
name|wc_id
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Upgrade the working copy directory represented by DB/DIR_ABSPATH    from OLD_FORMAT to the wc-ng format (SVN_WC__WC_NG_VERSION)'.     Pass REPOS_INFO_FUNC, REPOS_INFO_BATON and REPOS_CACHE to    ensure_repos_info. Add the found repository root and UUID to    REPOS_CACHE if it doesn't have a cached entry for this    repository.     *DATA refers to the single root db.     Uses SCRATCH_POOL for all temporary allocation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|upgrade_to_wcng
parameter_list|(
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|int
name|old_format
parameter_list|,
name|apr_int64_t
name|wc_id
parameter_list|,
name|svn_wc_upgrade_get_repos_info_t
name|repos_info_func
parameter_list|,
name|void
modifier|*
name|repos_info_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|repos_cache
parameter_list|,
specifier|const
name|struct
name|upgrade_data_t
modifier|*
name|data
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|logfile_path
init|=
name|svn_wc__adm_child
argument_list|(
name|dir_abspath
argument_list|,
name|ADM_LOG
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|logfile_on_disk_kind
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|svn_wc_entry_t
modifier|*
name|this_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_wcroot_abspath
decl_stmt|,
modifier|*
name|dir_relpath
decl_stmt|;
name|apr_hash_t
modifier|*
name|text_bases_info
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Don't try to mess with the WC if there are old log files left. */
comment|/* Is the (first) log file present?  */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|logfile_path
argument_list|,
operator|&
name|logfile_on_disk_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile_on_disk_kind
operator|==
name|svn_node_file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot upgrade with existing logs; run a "
literal|"cleanup operation on this working copy using "
literal|"a client version which is compatible with this "
literal|"working copy's format (such as the version "
literal|"you are upgrading from), then retry the "
literal|"upgrade with the current version"
argument_list|)
argument_list|)
return|;
comment|/* Lock this working copy directory, or steal an existing lock. Do this      BEFORE we read the entries. We don't want another process to modify the      entries after we've read them into memory.  */
name|SVN_ERR
argument_list|(
name|create_physical_lock
argument_list|(
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* What's going on here?    *    * We're attempting to upgrade an older working copy to the new wc-ng format.    * The semantics and storage mechanisms between the two are vastly different,    * so it's going to be a bit painful.  Here's a plan for the operation:    *    * 1) Read the old 'entries' using the old-format reader.    *    * 2) Create the new DB if it hasn't already been created.    *    * 3) Use our compatibility code for writing entries to fill out the (new)    *    DB state.  Use the remembered checksums, since an entry has only the    *    MD5 not the SHA1 checksum, and in the case of a revert-base doesn't    *    even have that.    *    * 4) Convert wcprop to the wc-ng format    *    * 5) Migrate regular properties to the WC-NG DB.    */
comment|/***** ENTRIES - READ *****/
name|SVN_ERR
argument_list|(
name|svn_wc__read_entries_old
argument_list|(
operator|&
name|entries
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|this_dir
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_repos_info
argument_list|(
name|this_dir
argument_list|,
name|dir_abspath
argument_list|,
name|repos_info_func
argument_list|,
name|repos_info_baton
argument_list|,
name|repos_cache
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cache repos UUID pairs for when a subdir doesn't have this information */
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|repos_cache
argument_list|,
name|this_dir
operator|->
name|repos
argument_list|)
condition|)
block|{
name|apr_pool_t
modifier|*
name|hash_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|repos_cache
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|repos_cache
argument_list|,
name|apr_pstrdup
argument_list|(
name|hash_pool
argument_list|,
name|this_dir
operator|->
name|repos
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|hash_pool
argument_list|,
name|this_dir
operator|->
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|old_wcroot_abspath
operator|=
name|svn_dirent_get_longest_ancestor
argument_list|(
name|dir_abspath
argument_list|,
name|data
operator|->
name|root_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|dir_relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|old_wcroot_abspath
argument_list|,
name|dir_abspath
argument_list|)
expr_stmt|;
comment|/***** TEXT BASES *****/
name|SVN_ERR
argument_list|(
name|migrate_text_bases
argument_list|(
operator|&
name|text_bases_info
argument_list|,
name|dir_abspath
argument_list|,
name|data
operator|->
name|root_abspath
argument_list|,
name|data
operator|->
name|sdb
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/***** ENTRIES - WRITE *****/
name|err
operator|=
name|svn_wc__write_upgraded_entries
argument_list|(
name|dir_baton
argument_list|,
name|parent_baton
argument_list|,
name|db
argument_list|,
name|data
operator|->
name|sdb
argument_list|,
name|data
operator|->
name|repos_id
argument_list|,
name|data
operator|->
name|wc_id
argument_list|,
name|dir_abspath
argument_list|,
name|data
operator|->
name|root_abspath
argument_list|,
name|entries
argument_list|,
name|text_bases_info
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_CORRUPT
condition|)
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"This working copy is corrupt and "
literal|"cannot be upgraded. Please check out "
literal|"a new working copy."
argument_list|)
argument_list|)
return|;
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/***** WC PROPS *****/
comment|/* If we don't know precisely where the wcprops are, ignore them.  */
if|if
condition|(
name|old_format
operator|!=
name|SVN_WC__WCPROPS_LOST
condition|)
block|{
name|apr_hash_t
modifier|*
name|all_wcprops
decl_stmt|;
if|if
condition|(
name|old_format
operator|<=
name|SVN_WC__WCPROPS_MANY_FILES_VERSION
condition|)
name|SVN_ERR
argument_list|(
name|read_many_wcprops
argument_list|(
operator|&
name|all_wcprops
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|read_wcprops
argument_list|(
operator|&
name|all_wcprops
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_upgrade_apply_dav_cache
argument_list|(
name|data
operator|->
name|sdb
argument_list|,
name|dir_relpath
argument_list|,
name|all_wcprops
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Upgrade all the properties (including "this dir").       Note: this must come AFTER the entries have been migrated into the      database. The upgrade process needs the children in BASE_NODE and      WORKING_NODE, and to examine the resultant WORKING state.  */
name|SVN_ERR
argument_list|(
name|migrate_props
argument_list|(
name|dir_abspath
argument_list|,
name|data
operator|->
name|root_abspath
argument_list|,
name|data
operator|->
name|sdb
argument_list|,
name|old_format
argument_list|,
name|wc_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_wc__version_string_from_format
parameter_list|(
name|int
name|wc_format
parameter_list|)
block|{
switch|switch
condition|(
name|wc_format
condition|)
block|{
case|case
literal|4
case|:
return|return
literal|"<=1.3"
return|;
case|case
literal|8
case|:
return|return
literal|"1.4"
return|;
case|case
literal|9
case|:
return|return
literal|"1.5"
return|;
case|case
literal|10
case|:
return|return
literal|"1.6"
return|;
case|case
name|SVN_WC__WC_NG_VERSION
case|:
return|return
literal|"1.7"
return|;
block|}
return|return
name|_
argument_list|(
literal|"(unreleased development version)"
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__upgrade_sdb
parameter_list|(
name|int
modifier|*
name|result_format
parameter_list|,
specifier|const
name|char
modifier|*
name|wcroot_abspath
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|int
name|start_format
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|bump_baton
name|bb
decl_stmt|;
name|bb
operator|.
name|wcroot_abspath
operator|=
name|wcroot_abspath
expr_stmt|;
if|if
condition|(
name|start_format
operator|<
name|SVN_WC__WC_NG_VERSION
comment|/* 12 */
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_UPGRADE_REQUIRED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Working copy '%s' is too old (format %d, "
literal|"created by Subversion %s)"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|start_format
argument_list|,
name|svn_wc__version_string_from_format
argument_list|(
name|start_format
argument_list|)
argument_list|)
return|;
comment|/* Early WCNG formats no longer supported. */
if|if
condition|(
name|start_format
operator|<
literal|19
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_UPGRADE_REQUIRED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Working copy '%s' is an old development "
literal|"version (format %d); to upgrade it, "
literal|"use a format 18 client, then "
literal|"use 'tools/dev/wc-ng/bump-to-19.py', then "
literal|"use the current client"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|start_format
argument_list|)
return|;
comment|/* ### need lock-out. only one upgrade at a time. note that other code      ### cannot use this un-upgraded database until we finish the upgrade.  */
comment|/* Note: none of these have "break" statements; the fall-through is      intentional. */
switch|switch
condition|(
name|start_format
condition|)
block|{
case|case
literal|19
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_20
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|20
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|20
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_21
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|21
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|21
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_22
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|22
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|22
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_23
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|23
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|23
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_24
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|24
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|24
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_25
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|25
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|25
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_26
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|26
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|26
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_27
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|27
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|27
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_28
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|28
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|28
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_29
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|29
expr_stmt|;
comment|/* FALLTHROUGH  */
case|case
literal|29
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_30
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|30
expr_stmt|;
case|case
literal|30
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_transaction
argument_list|(
name|sdb
argument_list|,
name|bump_to_31
argument_list|,
operator|&
name|bb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_format
operator|=
literal|31
expr_stmt|;
comment|/* FALLTHROUGH  */
comment|/* ### future bumps go here.  */
if|#
directive|if
literal|0
block|case XXX-1:
comment|/* Revamp the recording of tree conflicts.  */
block|SVN_ERR(svn_sqlite__with_transaction(sdb, bump_to_XXX,&bb,                                              scratch_pool));         *result_format = XXX;
comment|/* FALLTHROUGH  */
endif|#
directive|endif
case|case
name|SVN_WC__VERSION
case|:
comment|/* already upgraded */
operator|*
name|result_format
operator|=
name|SVN_WC__VERSION
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SVN_DEBUG
if|if
condition|(
operator|*
name|result_format
operator|!=
name|start_format
condition|)
block|{
name|int
name|schema_version
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__read_schema_version
argument_list|(
operator|&
name|schema_version
argument_list|,
name|sdb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this assertion fails the schema isn't updated correctly */
name|SVN_ERR_ASSERT
argument_list|(
name|schema_version
operator|==
operator|*
name|result_format
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Zap anything that might be remaining or escaped our notice.  */
name|wipe_obsolete_files
argument_list|(
name|wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|upgrade_working_copy
parameter_list|(
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|svn_wc_upgrade_get_repos_info_t
name|repos_info_func
parameter_list|,
name|void
modifier|*
name|repos_info_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|repos_cache
parameter_list|,
specifier|const
name|struct
name|upgrade_data_t
modifier|*
name|data
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|void
modifier|*
name|dir_baton
decl_stmt|;
name|int
name|old_format
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|subdirs
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_get_format
argument_list|(
operator|&
name|old_format
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_format
operator|>=
name|SVN_WC__WC_NG_VERSION
condition|)
block|{
if|if
condition|(
name|notify_func
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|dir_abspath
argument_list|,
name|svn_wc_notify_skip
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|err
operator|=
name|get_versioned_subdirs
argument_list|(
operator|&
name|subdirs
argument_list|,
name|NULL
argument_list|,
name|dir_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* An unversioned dir is obstructing a versioned dir */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|dir_abspath
argument_list|,
name|svn_wc_notify_skip
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|SVN_ERR
argument_list|(
name|upgrade_to_wcng
argument_list|(
operator|&
name|dir_baton
argument_list|,
name|parent_baton
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|old_format
argument_list|,
name|data
operator|->
name|wc_id
argument_list|,
name|repos_info_func
argument_list|,
name|repos_info_baton
argument_list|,
name|repos_cache
argument_list|,
name|data
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|dir_abspath
argument_list|,
name|svn_wc_notify_upgraded_path
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdirs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|child_abspath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|subdirs
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|upgrade_working_copy
argument_list|(
name|dir_baton
argument_list|,
name|db
argument_list|,
name|child_abspath
argument_list|,
name|repos_info_func
argument_list|,
name|repos_info_baton
argument_list|,
name|repos_cache
argument_list|,
name|data
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a verbose error if LOCAL_ABSPATH is a not a pre-1.7 working    copy root */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|is_old_wcroot
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|svn_wc_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_wc__read_entries_old
argument_list|(
operator|&
name|entries
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_INVALID_OP_ON_CWD
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Can't upgrade '%s' as it is not a working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|svn_dirent_is_root
argument_list|(
name|local_abspath
argument_list|,
name|strlen
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|svn_dirent_split
argument_list|(
operator|&
name|parent_abspath
argument_list|,
operator|&
name|name
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__read_entries_old
argument_list|(
operator|&
name|entries
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|entry
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|||
name|entry
operator|->
name|absent
operator|||
operator|(
name|entry
operator|->
name|deleted
operator|&&
name|entry
operator|->
name|schedule
operator|!=
name|svn_wc_schedule_add
operator|)
operator|||
name|entry
operator|->
name|depth
operator|==
name|svn_depth_exclude
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
while|while
condition|(
operator|!
name|svn_dirent_is_root
argument_list|(
name|parent_abspath
argument_list|,
name|strlen
argument_list|(
name|parent_abspath
argument_list|)
argument_list|)
condition|)
block|{
name|svn_dirent_split
argument_list|(
operator|&
name|parent_abspath
argument_list|,
operator|&
name|name
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__read_entries_old
argument_list|(
operator|&
name|entries
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|parent_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|parent_abspath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
break|break;
block|}
name|entry
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|||
name|entry
operator|->
name|absent
operator|||
operator|(
name|entry
operator|->
name|deleted
operator|&&
name|entry
operator|->
name|schedule
operator|!=
name|svn_wc_schedule_add
operator|)
operator|||
name|entry
operator|->
name|depth
operator|==
name|svn_depth_exclude
condition|)
block|{
name|parent_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|parent_abspath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_INVALID_OP_ON_CWD
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't upgrade '%s' as it is not a working copy root,"
literal|" the root is '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Data for upgrade_working_copy_txn(). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|upgrade_working_copy_baton_t
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
name|svn_wc_upgrade_get_repos_info_t
name|repos_info_func
decl_stmt|;
name|void
modifier|*
name|repos_info_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|repos_cache
decl_stmt|;
specifier|const
name|struct
name|upgrade_data_t
modifier|*
name|data
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
name|svn_wc_notify_func2_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
name|upgrade_working_copy_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Helper for svn_wc_upgrade. Implements svn_sqlite__transaction_callback_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|upgrade_working_copy_txn
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|upgrade_working_copy_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* Upgrade the pre-wcng into a wcng in a temporary location. */
return|return
operator|(
name|upgrade_working_copy
argument_list|(
name|NULL
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|b
operator|->
name|dir_abspath
argument_list|,
name|b
operator|->
name|repos_info_func
argument_list|,
name|b
operator|->
name|repos_info_baton
argument_list|,
name|b
operator|->
name|repos_cache
argument_list|,
name|b
operator|->
name|data
argument_list|,
name|b
operator|->
name|cancel_func
argument_list|,
name|b
operator|->
name|cancel_baton
argument_list|,
name|b
operator|->
name|notify_func
argument_list|,
name|b
operator|->
name|notify_baton
argument_list|,
name|b
operator|->
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_upgrade
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc_upgrade_get_repos_info_t
name|repos_info_func
parameter_list|,
name|void
modifier|*
name|repos_info_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
name|struct
name|upgrade_data_t
name|data
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|,
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|pristine_from
decl_stmt|,
modifier|*
name|pristine_to
decl_stmt|,
modifier|*
name|db_from
decl_stmt|,
modifier|*
name|db_to
decl_stmt|;
name|apr_hash_t
modifier|*
name|repos_cache
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_wc_entry_t
modifier|*
name|this_dir
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_adm_abspath
decl_stmt|;
name|upgrade_working_copy_baton_t
name|cb_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|result_format
decl_stmt|;
comment|/* Try upgrading a wc-ng-style working copy. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_open
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
comment|/* ### config */
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_bump_format
argument_list|(
operator|&
name|result_format
argument_list|,
name|local_abspath
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_UPGRADE_REQUIRED
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_wc__db_close
argument_list|(
name|db
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Pre 1.7: Fall through */
block|}
else|else
block|{
comment|/* Auto-upgrade worked! */
name|SVN_ERR
argument_list|(
name|svn_wc__db_close
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|result_format
operator|==
name|SVN_WC__VERSION
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|is_old_wcroot
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Given a pre-wcng root some/wc we create a temporary wcng in      some/wc/.svn/tmp/wcng/wc.db and copy the metadata from one to the      other, then the temporary wc.db file gets moved into the original      root.  Until the wc.db file is moved the original working copy      remains a pre-wcng and 'cleanup' with an old client will remove      the partial upgrade.  Moving the wc.db file creates a wcng, and      'cleanup' with a new client will complete any outstanding      upgrade. */
name|SVN_ERR
argument_list|(
name|svn_wc__read_entries_old
argument_list|(
operator|&
name|entries
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|this_dir
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_repos_info
argument_list|(
name|this_dir
argument_list|,
name|local_abspath
argument_list|,
name|repos_info_func
argument_list|,
name|repos_info_baton
argument_list|,
name|repos_cache
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cache repos UUID pairs for when a subdir doesn't have this information */
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|repos_cache
argument_list|,
name|this_dir
operator|->
name|repos
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|repos_cache
argument_list|,
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|this_dir
operator|->
name|repos
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|this_dir
operator|->
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new DB in the temporary root wc/.svn/tmp/wcng/.svn */
name|data
operator|.
name|root_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|svn_wc__adm_child
argument_list|(
name|local_abspath
argument_list|,
literal|"tmp"
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
literal|"wcng"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|root_adm_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|data
operator|.
name|root_abspath
argument_list|,
literal|""
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|root_adm_abspath
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__ensure_directory
argument_list|(
name|root_adm_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create an empty sqlite database for this directory and store it in DB. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_upgrade_begin
argument_list|(
operator|&
name|data
operator|.
name|sdb
argument_list|,
operator|&
name|data
operator|.
name|repos_id
argument_list|,
operator|&
name|data
operator|.
name|wc_id
argument_list|,
name|db
argument_list|,
name|data
operator|.
name|root_abspath
argument_list|,
name|this_dir
operator|->
name|repos
argument_list|,
name|this_dir
operator|->
name|uuid
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Migrate the entries over to the new database.    ### We need to think about atomicity here.     entries_write_new() writes in current format rather than    f12. Thus, this function bumps a working copy all the way to    current.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_obtain
argument_list|(
name|db
argument_list|,
name|data
operator|.
name|root_abspath
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cb_baton
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|cb_baton
operator|.
name|dir_abspath
operator|=
name|local_abspath
expr_stmt|;
name|cb_baton
operator|.
name|repos_info_func
operator|=
name|repos_info_func
expr_stmt|;
name|cb_baton
operator|.
name|repos_info_baton
operator|=
name|repos_info_baton
expr_stmt|;
name|cb_baton
operator|.
name|repos_cache
operator|=
name|repos_cache
expr_stmt|;
name|cb_baton
operator|.
name|data
operator|=
operator|&
name|data
expr_stmt|;
name|cb_baton
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|cb_baton
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|cb_baton
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|cb_baton
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|cb_baton
operator|.
name|result_pool
operator|=
name|scratch_pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__with_lock
argument_list|(
name|data
operator|.
name|sdb
argument_list|,
name|upgrade_working_copy_txn
argument_list|,
operator|&
name|cb_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A workqueue item to move the pristine dir into place */
name|pristine_from
operator|=
name|svn_wc__adm_child
argument_list|(
name|data
operator|.
name|root_abspath
argument_list|,
name|PRISTINE_STORAGE_RELPATH
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|pristine_to
operator|=
name|svn_wc__adm_child
argument_list|(
name|local_abspath
argument_list|,
name|PRISTINE_STORAGE_RELPATH
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__ensure_directory
argument_list|(
name|pristine_from
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_move
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pristine_from
argument_list|,
name|pristine_to
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* A workqueue item to remove pre-wcng metadata */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_postupgrade
argument_list|(
operator|&
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_add
argument_list|(
name|db
argument_list|,
name|data
operator|.
name|root_abspath
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_release
argument_list|(
name|db
argument_list|,
name|data
operator|.
name|root_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_close
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Renaming the db file is what makes the pre-wcng into a wcng */
name|db_from
operator|=
name|svn_wc__adm_child
argument_list|(
name|data
operator|.
name|root_abspath
argument_list|,
name|SDB_FILE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|db_to
operator|=
name|svn_wc__adm_child
argument_list|(
name|local_abspath
argument_list|,
name|SDB_FILE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|db_from
argument_list|,
name|db_to
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now we have a working wcng, tidy up the droppings */
name|SVN_ERR
argument_list|(
name|svn_wc__db_open
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
comment|/* ### config */
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_close
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Should we have the workqueue remove this empty dir? */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|data
operator|.
name|root_abspath
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__upgrade_add_external_info
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|def_local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_uuid
parameter_list|,
name|svn_revnum_t
name|def_peg_revision
parameter_list|,
name|svn_revnum_t
name|def_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|db_kind
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|svn_node_dir
case|:
name|db_kind
operator|=
name|svn_node_dir
expr_stmt|;
break|break;
case|case
name|svn_node_file
case|:
name|db_kind
operator|=
name|svn_node_file
expr_stmt|;
break|break;
case|case
name|svn_node_unknown
case|:
name|db_kind
operator|=
name|svn_node_unknown
expr_stmt|;
break|break;
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_upgrade_insert_external
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|db_kind
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|def_local_abspath
argument_list|,
name|repos_relpath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|def_peg_revision
argument_list|,
name|def_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

