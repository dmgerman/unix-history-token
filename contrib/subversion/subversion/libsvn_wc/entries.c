begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * entries.c :  manipulating the administrative `entries' file.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"entries.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"tree_conflicts.h"
end_include

begin_include
include|#
directive|include
file|"wc_db.h"
end_include

begin_include
include|#
directive|include
file|"wc-queries.h"
end_include

begin_comment
comment|/* for STMT_*  */
end_comment

begin_define
define|#
directive|define
name|SVN_WC__I_AM_WC_DB
end_define

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sqlite.h"
end_include

begin_include
include|#
directive|include
file|"token-map.h"
end_include

begin_include
include|#
directive|include
file|"wc_db_private.h"
end_include

begin_define
define|#
directive|define
name|MAYBE_ALLOC
parameter_list|(
name|x
parameter_list|,
name|p
parameter_list|)
value|((x) ? (x) : apr_pcalloc((p), sizeof(*(x))))
end_define

begin_comment
comment|/* Temporary structures which mirror the tables in wc-metadata.sql.    For detailed descriptions of each field, see that file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|db_node_t
block|{
name|apr_int64_t
name|wc_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
name|int
name|op_depth
decl_stmt|;
name|apr_int64_t
name|repos_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_relpath
decl_stmt|;
name|svn_wc__db_status_t
name|presence
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_filesize_t
name|recorded_size
decl_stmt|;
name|svn_revnum_t
name|changed_rev
decl_stmt|;
name|apr_time_t
name|changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|changed_author
decl_stmt|;
name|svn_depth_t
name|depth
decl_stmt|;
name|apr_time_t
name|recorded_time
decl_stmt|;
name|apr_hash_t
modifier|*
name|properties
decl_stmt|;
name|svn_boolean_t
name|file_external
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
decl_stmt|;
block|}
name|db_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|db_actual_node_t
block|{
name|apr_int64_t
name|wc_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_relpath
decl_stmt|;
name|apr_hash_t
modifier|*
name|properties
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_old
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_new
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_working
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_reject
decl_stmt|;
specifier|const
name|char
modifier|*
name|changelist
decl_stmt|;
comment|/* ### enum for text_mod */
specifier|const
name|char
modifier|*
name|tree_conflict_data
decl_stmt|;
block|}
name|db_actual_node_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/*** reading and writing the entries file ***/
end_comment

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_wc_entry_t
modifier|*
name|alloc_entry
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_entry_t
modifier|*
name|entry
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
decl_stmt|;
name|entry
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|cmt_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|entry
operator|->
name|working_size
operator|=
name|SVN_WC_ENTRY_WORKING_SIZE_UNKNOWN
expr_stmt|;
name|entry
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|entry
operator|->
name|file_external_peg_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|entry
operator|->
name|file_external_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Is the entry in a 'hidden' state in the sense of the 'show_hidden'  * switches on svn_wc_entries_read(), svn_wc_walk_entries*(), etc.? */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__entry_is_hidden
parameter_list|(
name|svn_boolean_t
modifier|*
name|hidden
parameter_list|,
specifier|const
name|svn_wc_entry_t
modifier|*
name|entry
parameter_list|)
block|{
comment|/* In English, the condition is: "the entry is not present, and I haven't      scheduled something over the top of it."  */
if|if
condition|(
name|entry
operator|->
name|deleted
operator|||
name|entry
operator|->
name|absent
operator|||
name|entry
operator|->
name|depth
operator|==
name|svn_depth_exclude
condition|)
block|{
comment|/* These kinds of nodes cannot be marked for deletion (which also          means no "replace" either).  */
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|schedule
operator|==
name|svn_wc_schedule_add
operator|||
name|entry
operator|->
name|schedule
operator|==
name|svn_wc_schedule_normal
argument_list|)
expr_stmt|;
comment|/* Hidden if something hasn't been added over it.           ### is this even possible with absent or excluded nodes?  */
operator|*
name|hidden
operator|=
name|entry
operator|->
name|schedule
operator|!=
name|svn_wc_schedule_add
expr_stmt|;
block|}
else|else
operator|*
name|hidden
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Hit the database to check the file external information for the given    entry.  The entry will be modified in place. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_file_external
parameter_list|(
name|svn_wc_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_revnum_t
name|peg_revision
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc__db_external_read
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|peg_revision
argument_list|,
operator|&
name|revision
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|wri_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_normal
operator|&&
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|entry
operator|->
name|file_external_path
operator|=
name|repos_relpath
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|peg_revision
argument_list|)
condition|)
block|{
name|entry
operator|->
name|file_external_peg_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|entry
operator|->
name|file_external_peg_rev
operator|.
name|value
operator|.
name|number
operator|=
name|peg_revision
expr_stmt|;
name|entry
operator|->
name|file_external_rev
operator|=
name|entry
operator|->
name|file_external_peg_rev
expr_stmt|;
block|}
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
name|entry
operator|->
name|file_external_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|entry
operator|->
name|file_external_rev
operator|.
name|value
operator|.
name|number
operator|=
name|revision
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fill in the following fields of ENTRY:       REVISION      REPOS      UUID      CMT_REV      CMT_DATE      CMT_AUTHOR      DEPTH      DELETED     Return: KIND, REPOS_RELPATH, CHECKSUM */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_info_for_deleted
parameter_list|(
name|svn_wc_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|repos_relpath
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_wc__db_lock_t
modifier|*
modifier|*
name|lock
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|entry_abspath
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|entry_relpath
parameter_list|,
specifier|const
name|svn_wc_entry_t
modifier|*
name|parent_entry
parameter_list|,
name|svn_boolean_t
name|have_base
parameter_list|,
name|svn_boolean_t
name|have_more_work
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|have_base
operator|&&
operator|!
name|have_more_work
condition|)
block|{
name|apr_int64_t
name|repos_id
decl_stmt|;
comment|/* This is the delete of a BASE node */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info_internal
argument_list|(
name|NULL
argument_list|,
name|kind
argument_list|,
operator|&
name|entry
operator|->
name|revision
argument_list|,
name|repos_relpath
argument_list|,
operator|&
name|repos_id
argument_list|,
operator|&
name|entry
operator|->
name|cmt_rev
argument_list|,
operator|&
name|entry
operator|->
name|cmt_date
argument_list|,
operator|&
name|entry
operator|->
name|cmt_author
argument_list|,
operator|&
name|entry
operator|->
name|depth
argument_list|,
name|checksum
argument_list|,
name|NULL
argument_list|,
name|lock
argument_list|,
operator|&
name|entry
operator|->
name|has_props
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|entry
operator|->
name|repos
argument_list|,
operator|&
name|entry
operator|->
name|uuid
argument_list|,
name|wcroot
argument_list|,
name|repos_id
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|work_del_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_relpath
decl_stmt|;
name|apr_int64_t
name|repos_id
decl_stmt|;
comment|/* This is a deleted child of a copy/move-here,          so we need to scan up the WORKING tree to find the root of          the deletion. Then examine its parent to discover its          future location in the repository.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_info
argument_list|(
name|NULL
argument_list|,
name|kind
argument_list|,
operator|&
name|entry
operator|->
name|cmt_rev
argument_list|,
operator|&
name|entry
operator|->
name|cmt_date
argument_list|,
operator|&
name|entry
operator|->
name|cmt_author
argument_list|,
operator|&
name|entry
operator|->
name|depth
argument_list|,
name|checksum
argument_list|,
name|NULL
argument_list|,
operator|&
name|entry
operator|->
name|has_props
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|entry_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* working_size and text_time unavailable */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_deletion_internal
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|work_del_relpath
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|work_del_relpath
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|parent_relpath
operator|=
name|svn_relpath_dirname
argument_list|(
name|work_del_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* The parent directory of the delete root must be added, so we          can find the required information there */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition_internal
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|parent_repos_relpath
argument_list|,
operator|&
name|repos_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|parent_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|entry
operator|->
name|repos
argument_list|,
operator|&
name|entry
operator|->
name|uuid
argument_list|,
name|wcroot
argument_list|,
name|repos_id
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now glue it all together */
operator|*
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|parent_repos_relpath
argument_list|,
name|svn_relpath_skip_ancestor
argument_list|(
name|parent_relpath
argument_list|,
name|entry_relpath
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Even though this is the delete of a WORKING node, there might still          be a BASE node somewhere below with an interesting revision */
if|if
condition|(
name|have_base
condition|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info_internal
argument_list|(
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
operator|&
name|entry
operator|->
name|revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|lock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_not_present
condition|)
name|entry
operator|->
name|deleted
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Do some extra work for the child nodes.  */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|entry
operator|->
name|revision
argument_list|)
operator|&&
name|parent_entry
operator|!=
name|NULL
condition|)
block|{
comment|/* For child nodes without a revision, pick up the parent's          revision.  */
name|entry
operator|->
name|revision
operator|=
name|parent_entry
operator|->
name|revision
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Encode tree conflict descriptions into a single string.  *  * Set *CONFLICT_DATA to a string, allocated in POOL, that encodes the tree  * conflicts in CONFLICTS in a form suitable for storage in a single string  * field in a WC entry. CONFLICTS is a hash of zero or more pointers to  * svn_wc_conflict_description2_t objects, index by their basenames. All of the  * conflict victim paths must be siblings.  *  * Do all allocations in POOL.  *  * @see svn_wc__read_tree_conflicts()  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_tree_conflicts
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|conflict_data
parameter_list|,
name|apr_hash_t
modifier|*
name|conflicts
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|conflicts
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_skel_t
modifier|*
name|c_skel
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__serialize_conflict
argument_list|(
operator|&
name|c_skel
argument_list|,
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|c_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
operator|*
name|conflict_data
operator|=
name|svn_skel__unparse
argument_list|(
name|skel
argument_list|,
name|pool
argument_list|)
operator|->
name|data
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read one entry from wc_db. It will be allocated in RESULT_POOL and    returned in *NEW_ENTRY.     DIR_ABSPATH is the name of the directory to read this entry from, and    it will be named NAME (use "" for "this dir").     DB specifies the wc_db database, and WC_ID specifies which working copy    this information is being read from.     If this node is "this dir", then PARENT_ENTRY should be NULL. Otherwise,    it should refer to the entry for the child's parent directory.     ### All database read operations should really use wcroot, dir_relpath,        as that restores obstruction compatibility with<= 1.6.0        but that has been the case since the introduction of WC-NG in 1.7.0     Temporary allocations are made in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_one_entry
parameter_list|(
specifier|const
name|svn_wc_entry_t
modifier|*
modifier|*
name|new_entry
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_wc_entry_t
modifier|*
name|parent_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_wc__db_lock_t
modifier|*
name|lock
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_filesize_t
name|translated_size
decl_stmt|;
name|svn_wc_entry_t
modifier|*
name|entry
init|=
name|alloc_entry
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry_abspath
decl_stmt|;
name|apr_int64_t
name|repos_id
decl_stmt|;
name|apr_int64_t
name|original_repos_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_root_url
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_boolean_t
name|have_base
decl_stmt|;
name|svn_boolean_t
name|have_more_work
decl_stmt|;
name|svn_boolean_t
name|op_root
decl_stmt|;
name|entry
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|entry_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|dir_relpath
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|entry_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dir_abspath
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info_internal
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|entry
operator|->
name|revision
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_id
argument_list|,
operator|&
name|entry
operator|->
name|cmt_rev
argument_list|,
operator|&
name|entry
operator|->
name|cmt_date
argument_list|,
operator|&
name|entry
operator|->
name|cmt_author
argument_list|,
operator|&
name|entry
operator|->
name|depth
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|,
operator|&
name|original_repos_relpath
argument_list|,
operator|&
name|original_repos_id
argument_list|,
operator|&
name|entry
operator|->
name|copyfrom_rev
argument_list|,
operator|&
name|lock
argument_list|,
operator|&
name|translated_size
argument_list|,
operator|&
name|entry
operator|->
name|text_time
argument_list|,
operator|&
name|entry
operator|->
name|changelist
argument_list|,
operator|&
name|conflicted
argument_list|,
operator|&
name|op_root
argument_list|,
operator|&
name|entry
operator|->
name|has_props
comment|/* have_props */
argument_list|,
operator|&
name|entry
operator|->
name|has_prop_mods
comment|/* props_mod */
argument_list|,
operator|&
name|have_base
argument_list|,
operator|&
name|have_more_work
argument_list|,
name|NULL
comment|/* have_work */
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|entry
operator|->
name|repos
argument_list|,
operator|&
name|entry
operator|->
name|uuid
argument_list|,
name|wcroot
argument_list|,
name|repos_id
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|original_root_url
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|original_repos_id
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|has_prop_mods
condition|)
name|entry
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* get the tree conflict data. */
name|apr_hash_t
modifier|*
name|tree_conflicts
init|=
name|NULL
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|conflict_victims
decl_stmt|;
name|int
name|k
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict_victims
argument_list|(
operator|&
name|conflict_victims
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|conflict_victims
operator|->
name|nelts
condition|;
name|k
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|child_conflicts
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|;
name|child_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|conflict_victims
argument_list|,
name|k
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dir_abspath
argument_list|,
name|child_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__read_conflicts
argument_list|(
operator|&
name|child_conflicts
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|child_abspath
argument_list|,
name|FALSE
comment|/* create tempfiles */
argument_list|,
name|TRUE
comment|/* tree_conflicts_only */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|child_conflicts
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|conflict
init|=
name|APR_ARRAY_IDX
argument_list|(
name|child_conflicts
argument_list|,
name|j
argument_list|,
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|conflict
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_tree
condition|)
block|{
if|if
condition|(
operator|!
name|tree_conflicts
condition|)
name|tree_conflicts
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|tree_conflicts
argument_list|,
name|child_name
argument_list|,
name|conflict
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tree_conflicts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|write_tree_conflicts
argument_list|(
operator|&
name|entry
operator|->
name|tree_conflict_data
argument_list|,
name|tree_conflicts
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_normal
operator|||
name|status
operator|==
name|svn_wc__db_status_incomplete
condition|)
block|{
comment|/* Plain old BASE node.  */
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
comment|/* Grab inherited repository information, if necessary. */
if|if
condition|(
name|repos_relpath
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info_internal
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|entry
operator|->
name|repos
argument_list|,
operator|&
name|entry
operator|->
name|uuid
argument_list|,
name|wcroot
argument_list|,
name|repos_id
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|entry
operator|->
name|incomplete
operator|=
operator|(
name|status
operator|==
name|svn_wc__db_status_incomplete
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_deleted
condition|)
block|{
name|svn_node_kind_t
name|path_kind
decl_stmt|;
comment|/* ### we don't have to worry about moves, so this is a delete. */
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_delete
expr_stmt|;
comment|/* If there are multiple working layers or no BASE layer, then          this is a WORKING delete or WORKING not-present. */
if|if
condition|(
name|have_more_work
operator|||
operator|!
name|have_base
condition|)
name|entry
operator|->
name|copied
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|have_base
operator|&&
operator|!
name|have_more_work
condition|)
name|entry
operator|->
name|copied
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|work_del_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_deletion_internal
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|work_del_relpath
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_del_relpath
condition|)
name|entry
operator|->
name|copied
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If there is still a directory on-disk we keep it, if not it is          already deleted. Simple, isn't it?           Before single-db we had to keep the administative area alive until          after the commit really deletes it. Setting keep alive stopped the          commit processing from deleting the directory. We don't delete it          any more, so all we have to do is provide some 'sane' value.        */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|entry_abspath
argument_list|,
operator|&
name|path_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|keep_local
operator|=
operator|(
name|path_kind
operator|==
name|svn_node_dir
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_added
condition|)
block|{
name|svn_wc__db_status_t
name|work_status
decl_stmt|;
specifier|const
name|char
modifier|*
name|op_root_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|scanned_original_relpath
decl_stmt|;
name|svn_revnum_t
name|original_revision
decl_stmt|;
comment|/* For child nodes, pick up the parent's revision.  */
if|if
condition|(
operator|*
name|entry
operator|->
name|name
operator|!=
literal|'\0'
condition|)
block|{
name|assert
argument_list|(
name|parent_entry
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|entry
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
argument_list|)
expr_stmt|;
name|entry
operator|->
name|revision
operator|=
name|parent_entry
operator|->
name|revision
expr_stmt|;
block|}
if|if
condition|(
name|have_base
condition|)
block|{
name|svn_wc__db_status_t
name|base_status
decl_stmt|;
comment|/* ENTRY->REVISION is overloaded. When a node is schedule-add              or -replace, then REVISION refers to the BASE node's revision              that is being overwritten. We need to fetch it now.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info_internal
argument_list|(
operator|&
name|base_status
argument_list|,
name|NULL
argument_list|,
operator|&
name|entry
operator|->
name|revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_status
operator|==
name|svn_wc__db_status_not_present
condition|)
block|{
comment|/* The underlying node is DELETED in this revision.  */
name|entry
operator|->
name|deleted
operator|=
name|TRUE
expr_stmt|;
comment|/* This is an add since there isn't a node to replace.  */
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_add
expr_stmt|;
block|}
else|else
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_replace
expr_stmt|;
block|}
else|else
block|{
comment|/* There is NO 'not-present' BASE_NODE for this node.              Therefore, we are looking at some kind of add/copy              rather than a replace.  */
comment|/* ### if this looks like a plain old add, then rev=0.  */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|entry
operator|->
name|copyfrom_rev
argument_list|)
operator|&&
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|entry
operator|->
name|cmt_rev
argument_list|)
condition|)
name|entry
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_add
expr_stmt|;
block|}
comment|/* If we don't have "real" data from the entry (obstruction),          then we cannot begin a scan for data. The original node may          have important data. Set up stuff to kill that idea off,          and finish up this entry.  */
block|{
specifier|const
name|char
modifier|*
name|op_root_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition_internal
argument_list|(
operator|&
name|work_status
argument_list|,
operator|&
name|op_root_relpath
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_id
argument_list|,
operator|&
name|scanned_original_relpath
argument_list|,
name|NULL
comment|/* original_repos_id */
argument_list|,
operator|&
name|original_revision
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|entry
operator|->
name|repos
argument_list|,
operator|&
name|entry
operator|->
name|uuid
argument_list|,
name|wcroot
argument_list|,
name|repos_id
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op_root_relpath
condition|)
name|op_root_abspath
operator|=
name|NULL
expr_stmt|;
else|else
name|op_root_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|op_root_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* In wc.db we want to keep the valid revision of the not-present              BASE_REV, but when we used entries we set the revision to 0              when adding a new node over a not present base node. */
if|if
condition|(
name|work_status
operator|==
name|svn_wc__db_status_added
operator|&&
name|entry
operator|->
name|deleted
condition|)
name|entry
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|entry
operator|->
name|cmt_rev
argument_list|)
operator|&&
name|scanned_original_relpath
operator|==
name|NULL
condition|)
block|{
comment|/* There is NOT a last-changed revision (last-changed date and              author may be unknown, but we can always check the rev).              The absence of a revision implies this node was added WITHOUT              any history. Avoid the COPIED checks in the else block.  */
comment|/* ### scan_addition may need to be updated to avoid returning              ### status_copied in this case.  */
block|}
comment|/* For backwards-compatibility purposes we treat moves just like        * regular copies. */
elseif|else
if|if
condition|(
name|work_status
operator|==
name|svn_wc__db_status_copied
operator|||
name|work_status
operator|==
name|svn_wc__db_status_moved_here
condition|)
block|{
name|entry
operator|->
name|copied
operator|=
name|TRUE
expr_stmt|;
comment|/* If this is a child of a copied subtree, then it should be              schedule_normal.  */
if|if
condition|(
name|original_repos_relpath
operator|==
name|NULL
condition|)
block|{
comment|/* ### what if there is a BASE node under there? */
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
block|}
comment|/* Copied nodes need to mirror their copyfrom_rev, if they              don't have a revision of their own already. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|entry
operator|->
name|revision
argument_list|)
operator|||
name|entry
operator|->
name|revision
operator|==
literal|0
comment|/* added */
condition|)
name|entry
operator|->
name|revision
operator|=
name|original_revision
expr_stmt|;
block|}
comment|/* Does this node have copyfrom_* information?  */
if|if
condition|(
name|scanned_original_relpath
operator|!=
name|NULL
condition|)
block|{
name|svn_boolean_t
name|is_copied_child
decl_stmt|;
name|svn_boolean_t
name|is_mixed_rev
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|work_status
operator|==
name|svn_wc__db_status_copied
operator|||
name|work_status
operator|==
name|svn_wc__db_status_moved_here
argument_list|)
expr_stmt|;
comment|/* If this node inherits copyfrom information from an              ancestor node, then it must be a copied child.  */
name|is_copied_child
operator|=
operator|(
name|original_repos_relpath
operator|==
name|NULL
operator|)
expr_stmt|;
comment|/* If this node has copyfrom information on it, then it may              be an actual copy-root, or it could be participating in              a mixed-revision copied tree. So if we don't already know              this is a copied child, then we need to look for this              mixed-revision situation.  */
if|if
condition|(
operator|!
name|is_copied_child
condition|)
block|{
specifier|const
name|char
modifier|*
name|parent_relpath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_root_url
decl_stmt|;
name|apr_int64_t
name|parent_repos_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|op_root_relpath
decl_stmt|;
comment|/* When we insert entries into the database, we will                  construct additional copyfrom records for mixed-revision                  copies. The old entries would simply record the different                  revision in the entry->revision field. That is not                  available within wc-ng, so additional copies are made                  (see the logic inside write_entry()). However, when                  reading these back *out* of the database, the additional                  copies look like new "Added" nodes rather than a simple                  mixed-rev working copy.                   That would be a behavior change if we did not compensate.                  If there is copyfrom information for this node, then the                  code below looks at the parent to detect if it *also* has                  copyfrom information, and if the copyfrom_url would align                  properly. If it *does*, then we omit storing copyfrom_url                  and copyfrom_rev (ie. inherit the copyfrom info like a                  normal child), and update entry->revision with the                  copyfrom_rev in order to (re)create the mixed-rev copied                  subtree that was originally presented for storage.  */
comment|/* Get the copyfrom information from our parent.                   Note that the parent could be added/copied/moved-here.                  There is no way for it to be deleted/moved-away and                  have *this* node appear as copied.  */
name|parent_relpath
operator|=
name|svn_relpath_dirname
argument_list|(
name|entry_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_scan_addition_internal
argument_list|(
name|NULL
argument_list|,
operator|&
name|op_root_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|parent_repos_relpath
argument_list|,
operator|&
name|parent_repos_id
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|parent_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|op_root_abspath
operator|=
name|NULL
expr_stmt|;
name|parent_repos_relpath
operator|=
name|NULL
expr_stmt|;
name|parent_root_url
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|parent_root_url
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|parent_repos_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|op_root_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|op_root_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent_root_url
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|original_root_url
argument_list|,
name|parent_root_url
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|relpath_to_entry
init|=
name|svn_dirent_is_child
argument_list|(
name|op_root_abspath
argument_list|,
name|entry_abspath
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry_repos_relpath
init|=
name|svn_relpath_join
argument_list|(
name|parent_repos_relpath
argument_list|,
name|relpath_to_entry
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* The copyfrom repos roots matched.                       Now we look to see if the copyfrom path of the parent                      would align with our own path. If so, then it means                      this copyfrom was spontaneously created and inserted                      for mixed-rev purposes and can be eliminated without                      changing the semantics of a mixed-rev copied subtree.                       See notes/api-errata/wc003.txt for some additional                      detail, and potential issues.  */
if|if
condition|(
name|strcmp
argument_list|(
name|entry_repos_relpath
argument_list|,
name|original_repos_relpath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|is_copied_child
operator|=
name|TRUE
expr_stmt|;
name|is_mixed_rev
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|is_copied_child
condition|)
block|{
comment|/* We won't be settig the  copyfrom_url, yet need to                  clear out the copyfrom_rev. Thus, this node becomes a                  child of a copied subtree (rather than its own root).  */
name|entry
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Children in a copied subtree are schedule normal                  since we don't plan to actually *do* anything with                  them. Their operation is implied by ancestors.  */
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
comment|/* And *finally* we turn this entry into the mixed                  revision node that it was intended to be. This                  node's revision is taken from the copyfrom record                  that we spontaneously constructed.  */
if|if
condition|(
name|is_mixed_rev
condition|)
name|entry
operator|->
name|revision
operator|=
name|original_revision
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|original_repos_relpath
operator|!=
name|NULL
condition|)
block|{
name|entry
operator|->
name|copyfrom_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|original_root_url
argument_list|,
name|original_repos_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* NOTE: if original_repos_relpath == NULL, then the                  second call to scan_addition() will not have occurred.                  Thus, this use of OP_ROOT_ABSPATH still contains the                  original value where we fetched a value for                  SCANNED_REPOS_RELPATH.  */
specifier|const
name|char
modifier|*
name|relpath_to_entry
init|=
name|svn_dirent_is_child
argument_list|(
name|op_root_abspath
argument_list|,
name|entry_abspath
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry_repos_relpath
init|=
name|svn_relpath_join
argument_list|(
name|scanned_original_relpath
argument_list|,
name|relpath_to_entry
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|entry
operator|->
name|copyfrom_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|original_root_url
argument_list|,
name|entry_repos_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_not_present
condition|)
block|{
comment|/* ### buh. 'deleted' nodes are actually supposed to be          ### schedule "normal" since we aren't going to actually *do*          ### anything to this node at commit time.  */
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
name|entry
operator|->
name|deleted
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_server_excluded
condition|)
block|{
name|entry
operator|->
name|absent
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_excluded
condition|)
block|{
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
name|entry
operator|->
name|depth
operator|=
name|svn_depth_exclude
expr_stmt|;
block|}
else|else
block|{
comment|/* ### we should have handled all possible status values.  */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
comment|/* ### higher levels want repos information about deleted nodes, even      ### tho they are not "part of" a repository any more.  */
if|if
condition|(
name|entry
operator|->
name|schedule
operator|==
name|svn_wc_schedule_delete
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_info_for_deleted
argument_list|(
name|entry
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|checksum
argument_list|,
operator|&
name|lock
argument_list|,
name|db
argument_list|,
name|entry_abspath
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|parent_entry
argument_list|,
name|have_base
argument_list|,
name|have_more_work
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### default to the infinite depth if we don't know it. */
if|if
condition|(
name|entry
operator|->
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|entry
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|entry
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|entry
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_symlink
condition|)
name|entry
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
comment|/* ### no symlink kind */
else|else
name|entry
operator|->
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
comment|/* We should always have a REPOS_RELPATH, except for:      - deleted nodes      - certain obstructed nodes      - not-present nodes      - absent nodes      - excluded nodes       ### the last three should probably have an "implied" REPOS_RELPATH   */
name|SVN_ERR_ASSERT
argument_list|(
name|repos_relpath
operator|!=
name|NULL
operator|||
name|entry
operator|->
name|schedule
operator|==
name|svn_wc_schedule_delete
operator|||
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_relpath
condition|)
name|entry
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|entry
operator|->
name|repos
argument_list|,
name|repos_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
comment|/* We got a SHA-1, get the corresponding MD-5. */
if|if
condition|(
name|checksum
operator|->
name|kind
operator|!=
name|svn_checksum_md5
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_md5
argument_list|(
operator|&
name|checksum
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|checksum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|checksum
operator|->
name|kind
operator|==
name|svn_checksum_md5
argument_list|)
expr_stmt|;
name|entry
operator|->
name|checksum
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conflicted
condition|)
block|{
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|svn_boolean_t
name|text_conflicted
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict_internal
argument_list|(
operator|&
name|conflict
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|entry_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_conflicted
condition|)
block|{
specifier|const
name|char
modifier|*
name|my_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|their_old_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|their_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_text_conflict
argument_list|(
operator|&
name|my_abspath
argument_list|,
operator|&
name|their_old_abspath
argument_list|,
operator|&
name|their_abspath
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_abspath
condition|)
name|entry
operator|->
name|conflict_wrk
operator|=
name|svn_dirent_basename
argument_list|(
name|my_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|their_old_abspath
condition|)
name|entry
operator|->
name|conflict_old
operator|=
name|svn_dirent_basename
argument_list|(
name|their_old_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|their_abspath
condition|)
name|entry
operator|->
name|conflict_new
operator|=
name|svn_dirent_basename
argument_list|(
name|their_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prop_conflicted
condition|)
block|{
specifier|const
name|char
modifier|*
name|prej_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
operator|&
name|prej_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prej_abspath
condition|)
name|entry
operator|->
name|prejfile
operator|=
name|svn_dirent_basename
argument_list|(
name|prej_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lock
condition|)
block|{
name|entry
operator|->
name|lock_token
operator|=
name|lock
operator|->
name|token
expr_stmt|;
name|entry
operator|->
name|lock_owner
operator|=
name|lock
operator|->
name|owner
expr_stmt|;
name|entry
operator|->
name|lock_comment
operator|=
name|lock
operator|->
name|comment
expr_stmt|;
name|entry
operator|->
name|lock_creation_date
operator|=
name|lock
operator|->
name|date
expr_stmt|;
block|}
comment|/* Let's check for a file external.  ugh.  */
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_normal
operator|&&
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|check_file_external
argument_list|(
name|entry
argument_list|,
name|db
argument_list|,
name|entry_abspath
argument_list|,
name|dir_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|working_size
operator|=
name|translated_size
expr_stmt|;
operator|*
name|new_entry
operator|=
name|entry
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read entries for PATH/LOCAL_ABSPATH from DB. The entries    will be allocated in RESULT_POOL, with temporary allocations in    SCRATCH_POOL. The entries are returned in RESULT_ENTRIES.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_entries_new
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|result_entries
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|svn_wc_entry_t
modifier|*
name|parent_entry
decl_stmt|;
name|entries
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_one_entry
argument_list|(
operator|&
name|parent_entry
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|wcroot
argument_list|,
name|dir_relpath
argument_list|,
literal|""
comment|/* name */
argument_list|,
name|NULL
comment|/* parent_entry */
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|entries
argument_list|,
literal|""
argument_list|,
name|parent_entry
argument_list|)
expr_stmt|;
comment|/* Use result_pool so that the child names (used by reference, rather      than copied) appear in result_pool.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children
argument_list|(
operator|&
name|children
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|children
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|svn_wc_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_one_entry
argument_list|(
operator|&
name|entry
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|wcroot
argument_list|,
name|dir_relpath
argument_list|,
name|name
argument_list|,
name|parent_entry
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|entries
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|result_entries
operator|=
name|entries
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_entry_pair_txn
parameter_list|(
specifier|const
name|svn_wc_entry_t
modifier|*
modifier|*
name|parent_entry
parameter_list|,
specifier|const
name|svn_wc_entry_t
modifier|*
modifier|*
name|entry
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|read_one_entry
argument_list|(
name|parent_entry
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|wcroot
argument_list|,
name|dir_relpath
argument_list|,
literal|""
comment|/* name */
argument_list|,
name|NULL
comment|/* parent_entry */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we need the entry for "this dir", then return the parent_entry      in both outputs. Otherwise, read the child node.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
comment|/* If the retrieved node is a FILE, then we have a problem. We asked          for a directory. This implies there is an obstructing, unversioned          directory where a FILE should be. We navigated from the obstructing          subdir up to the parent dir, then returned the FILE found there.           Let's return WC_MISSING cuz the caller thought we had a dir, but          that (versioned subdir) isn't there.  */
if|if
condition|(
operator|(
operator|*
name|parent_entry
operator|)
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
operator|*
name|parent_entry
operator|=
name|NULL
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_MISSING
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a versioned working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|entry
operator|=
operator|*
name|parent_entry
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Default to not finding the child.  */
operator|*
name|entry
operator|=
name|NULL
expr_stmt|;
comment|/* Determine whether the parent KNOWS about this child. If it does          not, then we should not attempt to look for it.           For example: the parent doesn't "know" about the child, but the          versioned directory *does* exist on disk. We don't want to look          into that subdir.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children
argument_list|(
operator|&
name|children
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|children
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|child
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|read_one_entry
argument_list|(
name|entry
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|wcroot
argument_list|,
name|dir_relpath
argument_list|,
name|name
argument_list|,
operator|*
name|parent_entry
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* No problem. Clear the error and leave the default value                      of "missing".  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* Found it. No need to keep searching.  */
break|break;
block|}
block|}
comment|/* if the loop ends without finding a child, then we have the default          ENTRY value of NULL.  */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a pair of entries from wc_db in the directory DIR_ABSPATH. Return    the directory's entry in *PARENT_ENTRY and NAME's entry in *ENTRY. The    two returned pointers will be the same if NAME=="" ("this dir").     The parent entry must exist.     The requested entry MAY exist. If it does not, then NULL will be returned.     The resulting entries are allocated in RESULT_POOL, and all temporary    allocations are made in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_entry_pair
parameter_list|(
specifier|const
name|svn_wc_entry_t
modifier|*
modifier|*
name|parent_entry
parameter_list|,
specifier|const
name|svn_wc_entry_t
modifier|*
modifier|*
name|entry
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wcroot_parse_local_abspath
argument_list|(
operator|&
name|wcroot
argument_list|,
operator|&
name|dir_relpath
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY_USABLE_WCROOT
argument_list|(
name|wcroot
argument_list|)
expr_stmt|;
name|SVN_WC__DB_WITH_TXN
argument_list|(
name|read_entry_pair_txn
argument_list|(
name|parent_entry
argument_list|,
name|entry
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|wcroot
argument_list|,
name|dir_relpath
argument_list|,
name|name
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|wcroot
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_relpath
decl_stmt|;
name|int
name|wc_format
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_get_format
argument_list|(
operator|&
name|wc_format
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_format
operator|<
name|SVN_WC__WC_NG_VERSION
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__read_entries_old
argument_list|(
name|entries
argument_list|,
name|dir_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wcroot_parse_local_abspath
argument_list|(
operator|&
name|wcroot
argument_list|,
operator|&
name|dir_relpath
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY_USABLE_WCROOT
argument_list|(
name|wcroot
argument_list|)
expr_stmt|;
name|SVN_WC__DB_WITH_TXN
argument_list|(
name|read_entries_new
argument_list|(
name|entries
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|wcroot
argument_list|,
name|dir_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|wcroot
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For a given LOCAL_ABSPATH, using DB, set *ADM_ABSPATH to the directory in    which the entry information is located, and *ENTRY_NAME to the entry name    to access that entry.     KIND is as in svn_wc__get_entry().     Return the results in RESULT_POOL and use SCRATCH_POOL for temporary    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_entry_access_info
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|adm_abspath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|entry_name
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_adm_access_t
modifier|*
name|adm_access
decl_stmt|;
name|svn_boolean_t
name|read_from_subdir
init|=
name|FALSE
decl_stmt|;
comment|/* If the caller didn't know the node kind, then stat the path. Maybe      it is really there, and we can speed up the steps below.  */
if|if
condition|(
name|kind
operator|==
name|svn_node_unknown
condition|)
block|{
name|svn_node_kind_t
name|on_disk
decl_stmt|;
comment|/* Do we already have an access baton for LOCAL_ABSPATH?  */
name|adm_access
operator|=
name|svn_wc__adm_retrieve_internal2
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|adm_access
condition|)
block|{
comment|/* Sweet. The node is a directory.  */
name|on_disk
operator|=
name|svn_node_dir
expr_stmt|;
block|}
else|else
block|{
name|svn_boolean_t
name|special
decl_stmt|;
comment|/* What's on disk?  */
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|on_disk
argument_list|,
operator|&
name|special
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|on_disk
operator|!=
name|svn_node_dir
condition|)
block|{
comment|/* If this is *anything* besides a directory (FILE, NONE, or              UNKNOWN), then we cannot treat it as a versioned directory              containing entries to read. Leave READ_FROM_SUBDIR as FALSE,              so that the parent will be examined.               For NONE and UNKNOWN, it may be that metadata exists for the              node, even though on-disk is unhelpful.               If NEED_PARENT_STUB is TRUE, and the entry is not a DIRECTORY,              then we'll error.               If NEED_PARENT_STUB if FALSE, and we successfully read a stub,              then this on-disk node is obstructing the read.  */
block|}
else|else
block|{
comment|/* We found a directory for this UNKNOWN node. Determine whether              we need to read inside it.  */
name|read_from_subdir
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|read_from_subdir
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|read_from_subdir
condition|)
block|{
comment|/* KIND must be a DIR or UNKNOWN (and we found a subdir). We want          the "real" data, so treat LOCAL_ABSPATH as a versioned directory.  */
operator|*
name|adm_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
operator|*
name|entry_name
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
comment|/* FILE node needs to read the parent directory. Or a DIR node          needs to read from the parent to get at the stub entry. Or this          is an UNKNOWN node, and we need to examine the parent.  */
name|svn_dirent_split
argument_list|(
name|adm_abspath
argument_list|,
name|entry_name
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_entry
parameter_list|(
specifier|const
name|svn_wc_entry_t
modifier|*
modifier|*
name|entry
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|allow_unversioned
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_entry_access_info
argument_list|(
operator|&
name|dir_abspath
argument_list|,
operator|&
name|entry_name
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|const
name|svn_wc_entry_t
modifier|*
name|parent_entry
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* NOTE: if KIND is UNKNOWN and we decided to examine the *parent*          directory, then it is possible we moved out of the working copy.          If the on-disk node is a DIR, and we asked for a stub, then we          obviously can't provide that (parent has no info). If the on-disk          node is a FILE/NONE/UNKNOWN, then it is obstructing the real          LOCAL_ABSPATH (or it was never a versioned item). In all these          cases, the read_entries() will (properly) throw an error.           NOTE: if KIND is a DIR and we asked for the real data, but it is          obstructed on-disk by some other node kind (NONE, FILE, UNKNOWN),          then this will throw an error.  */
name|err
operator|=
name|read_entry_pair
argument_list|(
operator|&
name|parent_entry
argument_list|,
name|entry
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|entry_name
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_MISSING
operator|||
name|kind
operator|!=
name|svn_node_unknown
operator|||
operator|*
name|entry_name
operator|!=
literal|'\0'
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* The caller didn't know the node type, we saw a directory there,              we attempted to read IN that directory, and then wc_db reports              that it is NOT a working copy directory. It is possible that              one of two things has happened:               1) a directory is obstructing a file in the parent              2) the (versioned) directory's contents have been removed               Let's assume situation (1); if that is true, then we can just              return the newly-found data.               If we assumed (2), then a valid result still won't help us              since the caller asked for the actual contents, not the stub              (which is why we read *into* the directory). However, if we              assume (1) and get back a stub, then we have verified a              missing, versioned directory, and can return an error              describing that.               Redo the fetch, but "insist" we are trying to find a file.              This will read from the parent directory of the "file".  */
name|err
operator|=
name|svn_wc__get_entry
argument_list|(
name|entry
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|allow_unversioned
argument_list|,
name|svn_node_file
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_NODE_UNEXPECTED_KIND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We asked for a FILE, but the node found is a DIR. Thus, we              are looking at a stub. Originally, we tried to read into the              subdir because NEED_PARENT_STUB is FALSE. The stub we just              read is not going to work for the caller, so inform them of              the missing subdirectory.  */
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|entry
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|entry
operator|)
operator|->
name|kind
operator|==
name|svn_node_dir
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Admin area of '%s' is missing"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|*
name|entry
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|allow_unversioned
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* The caller had the wrong information.  */
if|if
condition|(
operator|(
name|kind
operator|==
name|svn_node_file
operator|&&
operator|(
operator|*
name|entry
operator|)
operator|->
name|kind
operator|!=
name|svn_node_file
operator|)
operator|||
operator|(
name|kind
operator|==
name|svn_node_dir
operator|&&
operator|(
operator|*
name|entry
operator|)
operator|->
name|kind
operator|!=
name|svn_node_dir
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not of the right kind"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* TODO ### Rewrite doc string to mention ENTRIES_ALL; not ADM_ACCESS.     Prune the deleted entries from the cached entries in ADM_ACCESS, and    return that collection in *ENTRIES_PRUNED.  SCRATCH_POOL is used for local,    short term, memory allocation, RESULT_POOL for permanent stuff.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prune_deleted
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries_pruned
parameter_list|,
name|apr_hash_t
modifier|*
name|entries_all
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
if|if
condition|(
operator|!
name|entries_all
condition|)
block|{
operator|*
name|entries_pruned
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* I think it will be common for there to be no deleted entries, so      it is worth checking for that case as we can optimise it. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|entries_all
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_boolean_t
name|hidden
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__entry_is_hidden
argument_list|(
operator|&
name|hidden
argument_list|,
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hidden
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|hi
condition|)
block|{
comment|/* There are no deleted entries, so we can use the full hash */
operator|*
name|entries_pruned
operator|=
name|entries_all
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Construct pruned hash without deleted entries */
operator|*
name|entries_pruned
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|entries_all
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_wc_entry_t
modifier|*
name|entry
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|hidden
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__entry_is_hidden
argument_list|(
operator|&
name|hidden
argument_list|,
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hidden
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|entries_pruned
argument_list|,
name|key
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__entries_read_internal
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|,
name|svn_boolean_t
name|show_hidden
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|new_entries
decl_stmt|;
name|new_entries
operator|=
name|svn_wc__adm_access_entries
argument_list|(
name|adm_access
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_entries
condition|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|svn_wc__adm_get_db
argument_list|(
name|adm_access
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_wc__adm_access_abspath
argument_list|(
name|adm_access
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
init|=
name|svn_wc__adm_access_pool_internal
argument_list|(
name|adm_access
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_entries
argument_list|(
operator|&
name|new_entries
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_wc__adm_access_set_entries
argument_list|(
name|adm_access
argument_list|,
name|new_entries
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_hidden
condition|)
operator|*
name|entries
operator|=
name|new_entries
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|prune_deleted
argument_list|(
name|entries
argument_list|,
name|new_entries
argument_list|,
name|svn_wc__adm_access_pool_internal
argument_list|(
name|adm_access
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_entries_read
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|,
name|svn_boolean_t
name|show_hidden
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__entries_read_internal
argument_list|(
name|entries
argument_list|,
name|adm_access
argument_list|,
name|show_hidden
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* No transaction required: called from write_entry which is itself    transaction-wrapped. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|insert_node
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
specifier|const
name|db_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|present
init|=
operator|(
name|node
operator|->
name|presence
operator|==
name|svn_wc__db_status_normal
operator|||
name|node
operator|->
name|presence
operator|==
name|svn_wc__db_status_incomplete
operator|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|node
operator|->
name|op_depth
operator|>
literal|0
operator|||
name|node
operator|->
name|repos_relpath
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_INSERT_NODE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isdsnnnnsn"
argument_list|,
name|node
operator|->
name|wc_id
argument_list|,
name|node
operator|->
name|local_relpath
argument_list|,
name|node
operator|->
name|op_depth
argument_list|,
name|node
operator|->
name|parent_relpath
argument_list|,
comment|/* Setting depth for files? */
operator|(
name|node
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
name|present
operator|)
condition|?
name|svn_depth_to_word
argument_list|(
name|node
operator|->
name|depth
argument_list|)
else|:
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|present
operator|&&
name|node
operator|->
name|repos_relpath
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_revnum
argument_list|(
name|stmt
argument_list|,
literal|11
argument_list|,
name|node
operator|->
name|changed_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_int64
argument_list|(
name|stmt
argument_list|,
literal|12
argument_list|,
name|node
operator|->
name|changed_date
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_text
argument_list|(
name|stmt
argument_list|,
literal|13
argument_list|,
name|node
operator|->
name|changed_author
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|repos_relpath
operator|&&
name|node
operator|->
name|presence
operator|!=
name|svn_wc__db_status_base_deleted
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_int64
argument_list|(
name|stmt
argument_list|,
literal|5
argument_list|,
name|node
operator|->
name|repos_id
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_text
argument_list|(
name|stmt
argument_list|,
literal|6
argument_list|,
name|node
operator|->
name|repos_relpath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_revnum
argument_list|(
name|stmt
argument_list|,
literal|7
argument_list|,
name|node
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_token
argument_list|(
name|stmt
argument_list|,
literal|8
argument_list|,
name|presence_map
argument_list|,
name|node
operator|->
name|presence
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|kind
operator|==
name|svn_node_none
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_text
argument_list|(
name|stmt
argument_list|,
literal|10
argument_list|,
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_token
argument_list|(
name|stmt
argument_list|,
literal|10
argument_list|,
name|kind_map
argument_list|,
name|node
operator|->
name|kind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|kind
operator|==
name|svn_node_file
operator|&&
name|present
condition|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|checksum
operator|&&
name|node
operator|->
name|op_depth
operator|==
literal|0
operator|&&
name|node
operator|->
name|presence
operator|!=
name|svn_wc__db_status_not_present
operator|&&
name|node
operator|->
name|presence
operator|!=
name|svn_wc__db_status_excluded
operator|&&
name|node
operator|->
name|presence
operator|!=
name|svn_wc__db_status_server_excluded
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The file '%s' has no checksum"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|node
operator|->
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_checksum
argument_list|(
name|stmt
argument_list|,
literal|14
argument_list|,
name|node
operator|->
name|checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|repos_relpath
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|recorded_size
operator|!=
name|SVN_INVALID_FILESIZE
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_int64
argument_list|(
name|stmt
argument_list|,
literal|16
argument_list|,
name|node
operator|->
name|recorded_size
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_int64
argument_list|(
name|stmt
argument_list|,
literal|17
argument_list|,
name|node
operator|->
name|recorded_time
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ### Never set, props done later */
if|if
condition|(
name|node
operator|->
name|properties
operator|&&
name|present
operator|&&
name|node
operator|->
name|repos_relpath
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_properties
argument_list|(
name|stmt
argument_list|,
literal|15
argument_list|,
name|node
operator|->
name|properties
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|file_external
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_int
argument_list|(
name|stmt
argument_list|,
literal|20
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|inherited_props
operator|&&
name|present
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_iprops
argument_list|(
name|stmt
argument_list|,
literal|23
argument_list|,
name|node
operator|->
name|inherited_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__insert
argument_list|(
name|NULL
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|insert_actual_node
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|db_actual_node_t
modifier|*
name|actual_node
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_data
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_INSERT_ACTUAL_NODE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_int64
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|actual_node
operator|->
name|wc_id
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_text
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|,
name|actual_node
operator|->
name|local_relpath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_text
argument_list|(
name|stmt
argument_list|,
literal|3
argument_list|,
name|actual_node
operator|->
name|parent_relpath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_node
operator|->
name|properties
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_properties
argument_list|(
name|stmt
argument_list|,
literal|4
argument_list|,
name|actual_node
operator|->
name|properties
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_node
operator|->
name|changelist
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_text
argument_list|(
name|stmt
argument_list|,
literal|5
argument_list|,
name|actual_node
operator|->
name|changelist
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__upgrade_conflict_skel_from_raw
argument_list|(
operator|&
name|conflict_data
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|actual_node
operator|->
name|local_relpath
argument_list|,
name|actual_node
operator|->
name|conflict_old
argument_list|,
name|actual_node
operator|->
name|conflict_working
argument_list|,
name|actual_node
operator|->
name|conflict_new
argument_list|,
name|actual_node
operator|->
name|prop_reject
argument_list|,
name|actual_node
operator|->
name|tree_conflict_data
argument_list|,
name|actual_node
operator|->
name|tree_conflict_data
condition|?
name|strlen
argument_list|(
name|actual_node
operator|->
name|tree_conflict_data
argument_list|)
else|:
literal|0
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_data
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|data
init|=
name|svn_skel__unparse
argument_list|(
name|conflict_data
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_blob
argument_list|(
name|stmt
argument_list|,
literal|6
argument_list|,
name|data
operator|->
name|data
argument_list|,
name|data
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Execute and reset the insert clause. */
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__insert
argument_list|(
name|NULL
argument_list|,
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_switched
parameter_list|(
name|db_node_t
modifier|*
name|parent
parameter_list|,
name|db_node_t
modifier|*
name|child
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|&&
name|child
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|repos_id
operator|!=
name|child
operator|->
name|repos_id
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|parent
operator|->
name|repos_relpath
operator|&&
name|child
operator|->
name|repos_relpath
condition|)
block|{
specifier|const
name|char
modifier|*
name|unswitched
init|=
name|svn_relpath_join
argument_list|(
name|parent
operator|->
name|repos_relpath
argument_list|,
name|svn_relpath_basename
argument_list|(
name|child
operator|->
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|unswitched
argument_list|,
name|child
operator|->
name|repos_relpath
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_struct
struct|struct
name|write_baton
block|{
name|db_node_t
modifier|*
name|base
decl_stmt|;
name|db_node_t
modifier|*
name|work
decl_stmt|;
name|db_node_t
modifier|*
name|below_work
decl_stmt|;
name|apr_hash_t
modifier|*
name|tree_conflicts
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|WRITE_ENTRY_ASSERT
parameter_list|(
name|expr
parameter_list|)
define|\
value|if (!(expr)) \     return svn_error_createf(SVN_ERR_ASSERTION_FAIL, NULL,  \                              _("Unable to upgrade '%s' at line %d"),    \                              svn_dirent_local_style( \                                svn_dirent_join(root_abspath, \                                                local_relpath,           \                                                scratch_pool),           \                                scratch_pool), __LINE__)
end_define

begin_comment
comment|/* Write the information for ENTRY to WC_DB.  The WC_ID, REPOS_ID and    REPOS_ROOT will all be used for writing ENTRY.    ### transitioning from straight sql to using the wc_db APIs.  For the    ### time being, we'll need both parameters. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_entry
parameter_list|(
name|struct
name|write_baton
modifier|*
modifier|*
name|entry_node
parameter_list|,
specifier|const
name|struct
name|write_baton
modifier|*
name|parent_node
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_int64_t
name|wc_id
parameter_list|,
name|apr_int64_t
name|repos_id
parameter_list|,
specifier|const
name|svn_wc_entry_t
modifier|*
name|entry
parameter_list|,
specifier|const
name|svn_wc__text_base_info_t
modifier|*
name|text_base_info
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|tmp_entry_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|root_abspath
parameter_list|,
specifier|const
name|svn_wc_entry_t
modifier|*
name|this_dir
parameter_list|,
name|svn_boolean_t
name|create_locks
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|db_node_t
modifier|*
name|base_node
init|=
name|NULL
decl_stmt|;
name|db_node_t
modifier|*
name|working_node
init|=
name|NULL
decl_stmt|,
modifier|*
name|below_working_node
init|=
name|NULL
decl_stmt|;
name|db_actual_node_t
modifier|*
name|actual_node
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_relpath
decl_stmt|;
name|apr_hash_t
modifier|*
name|tree_conflicts
decl_stmt|;
if|if
condition|(
operator|*
name|local_relpath
operator|==
literal|'\0'
condition|)
name|parent_relpath
operator|=
name|NULL
expr_stmt|;
else|else
name|parent_relpath
operator|=
name|svn_relpath_dirname
argument_list|(
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* This is how it should work, it doesn't work like this yet because      we need proper op_depth to layer the working nodes.       Using "svn add", "svn rm", "svn cp" only files can be replaced      pre-wcng; directories can only be normal, deleted or added.      Files cannot be replaced within a deleted directory, so replaced      files can only exist in a normal directory, or a directory that      is added+copied.  In a normal directory a replaced file needs a      base node and a working node, in an added+copied directory a      replaced file needs two working nodes at different op-depths.       With just the above operations the conversion for files and      directories is straightforward:             pre-wcng                             wcng      parent         child                 parent     child       normal         normal                base       base      add+copied     normal+copied         work       work      normal+copied  normal+copied         work       work      normal         delete                base       base+work      delete         delete                base+work  base+work      add+copied     delete                work       work      normal         add                   base       work      add            add                   work       work      add+copied     add                   work       work      normal         add+copied            base       work      add            add+copied            work       work      add+copied     add+copied            work       work      normal         replace               base       base+work      add+copied     replace               work       work+work      normal         replace+copied        base       base+work      add+copied     replace+copied        work       work+work       However "svn merge" make this more complicated.  The pre-wcng      "svn merge" is capable of replacing a directory, that is it can      mark the whole tree deleted, and then copy another tree on top.      The entries then represent the replacing tree overlayed on the      deleted tree.         original       replace          schedule in        tree           tree             combined tree         A              A                replace+copied        A/f                             delete+copied        A/g            A/g              replace+copied                       A/h              add+copied        A/B            A/B              replace+copied        A/B/f                           delete+copied        A/B/g          A/B/g            replace+copied                       A/B/h            add+copied        A/C                             delete+copied        A/C/f                           delete+copied                       A/D              add+copied                       A/D/f            add+copied       The original tree could be normal tree, or an add+copied tree.      Committing such a merge generally worked, but making further tree      modifications before commit sometimes failed.       The root of the replace is handled like the file replace:             pre-wcng                             wcng      parent         child                 parent     child       normal         replace+copied        base       base+work      add+copied     replace+copied        work       work+work       although obviously the node is a directory rather then a file.      There are then more conversion states where the parent is      replaced.             pre-wcng                                wcng      parent           child              parent            child       replace+copied   add                [base|work]+work  work      replace+copied   add+copied         [base|work]+work  work      replace+copied   delete+copied      [base|work]+work  [base|work]+work      delete+copied    delete+copied      [base|work]+work  [base|work]+work      replace+copied   replace+copied     [base|work]+work  [base|work]+work   */
name|WRITE_ENTRY_ASSERT
argument_list|(
name|parent_node
operator|||
name|entry
operator|->
name|schedule
operator|==
name|svn_wc_schedule_normal
argument_list|)
expr_stmt|;
name|WRITE_ENTRY_ASSERT
argument_list|(
operator|!
name|parent_node
operator|||
name|parent_node
operator|->
name|base
operator|||
name|parent_node
operator|->
name|below_work
operator|||
name|parent_node
operator|->
name|work
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|schedule
condition|)
block|{
case|case
name|svn_wc_schedule_normal
case|:
if|if
condition|(
name|entry
operator|->
name|copied
operator|||
operator|(
name|entry
operator|->
name|depth
operator|==
name|svn_depth_exclude
operator|&&
name|parent_node
operator|&&
operator|!
name|parent_node
operator|->
name|base
operator|&&
name|parent_node
operator|->
name|work
operator|)
condition|)
name|working_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|working_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|base_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|base_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc_schedule_add
case|:
name|working_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|working_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|deleted
condition|)
block|{
if|if
condition|(
name|parent_node
operator|->
name|base
condition|)
name|base_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|base_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|below_working_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|below_working_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|svn_wc_schedule_delete
case|:
name|working_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|working_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_node
operator|->
name|base
condition|)
name|base_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|base_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_node
operator|->
name|work
condition|)
name|below_working_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|below_working_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc_schedule_replace
case|:
name|working_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|working_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_node
operator|->
name|base
condition|)
name|base_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|base_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|below_working_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|below_working_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Something deleted in this revision means there should always be a      BASE node to indicate the not-present node.  */
if|if
condition|(
name|entry
operator|->
name|deleted
condition|)
block|{
name|WRITE_ENTRY_ASSERT
argument_list|(
name|base_node
operator|||
name|below_working_node
argument_list|)
expr_stmt|;
name|WRITE_ENTRY_ASSERT
argument_list|(
operator|!
name|entry
operator|->
name|incomplete
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_node
condition|)
name|base_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_not_present
expr_stmt|;
else|else
name|below_working_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_not_present
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|absent
condition|)
block|{
name|WRITE_ENTRY_ASSERT
argument_list|(
name|base_node
operator|&&
operator|!
name|working_node
operator|&&
operator|!
name|below_working_node
argument_list|)
expr_stmt|;
name|WRITE_ENTRY_ASSERT
argument_list|(
operator|!
name|entry
operator|->
name|incomplete
argument_list|)
expr_stmt|;
name|base_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_server_excluded
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|copied
condition|)
block|{
name|db_node_t
modifier|*
name|work
init|=
name|parent_node
operator|->
name|work
condition|?
name|parent_node
operator|->
name|work
else|:
name|parent_node
operator|->
name|below_work
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|copyfrom_url
condition|)
block|{
name|working_node
operator|->
name|repos_id
operator|=
name|repos_id
expr_stmt|;
name|working_node
operator|->
name|repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|this_dir
operator|->
name|repos
argument_list|,
name|entry
operator|->
name|copyfrom_url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|working_node
operator|->
name|revision
operator|=
name|entry
operator|->
name|copyfrom_rev
expr_stmt|;
name|working_node
operator|->
name|op_depth
operator|=
name|svn_wc__db_op_depth_for_upgrade
argument_list|(
name|local_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|&&
name|work
operator|->
name|repos_relpath
operator|&&
name|work
operator|->
name|repos_id
operator|==
name|repos_id
operator|&&
name|work
operator|->
name|revision
operator|==
name|entry
operator|->
name|copyfrom_rev
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|svn_relpath_skip_ancestor
argument_list|(
name|work
operator|->
name|repos_relpath
argument_list|,
name|working_node
operator|->
name|repos_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|svn_relpath_basename
argument_list|(
name|local_relpath
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
block|{
name|working_node
operator|->
name|op_depth
operator|=
name|work
operator|->
name|op_depth
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|work
operator|&&
name|work
operator|->
name|repos_relpath
condition|)
block|{
name|working_node
operator|->
name|repos_id
operator|=
name|repos_id
expr_stmt|;
name|working_node
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|work
operator|->
name|repos_relpath
argument_list|,
name|svn_relpath_basename
argument_list|(
name|local_relpath
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|working_node
operator|->
name|revision
operator|=
name|work
operator|->
name|revision
expr_stmt|;
name|working_node
operator|->
name|op_depth
operator|=
name|work
operator|->
name|op_depth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent_node
operator|->
name|below_work
operator|&&
name|parent_node
operator|->
name|below_work
operator|->
name|repos_relpath
condition|)
block|{
comment|/* Parent deleted, this not-present or similar */
name|working_node
operator|->
name|repos_id
operator|=
name|repos_id
expr_stmt|;
name|working_node
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|parent_node
operator|->
name|below_work
operator|->
name|repos_relpath
argument_list|,
name|svn_relpath_basename
argument_list|(
name|local_relpath
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|working_node
operator|->
name|revision
operator|=
name|parent_node
operator|->
name|below_work
operator|->
name|revision
expr_stmt|;
name|working_node
operator|->
name|op_depth
operator|=
name|parent_node
operator|->
name|below_work
operator|->
name|op_depth
expr_stmt|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_MISSING_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No copyfrom URL for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|work
operator|&&
name|work
operator|->
name|op_depth
operator|!=
name|working_node
operator|->
name|op_depth
operator|&&
name|work
operator|->
name|repos_relpath
operator|&&
name|work
operator|->
name|repos_id
operator|==
name|working_node
operator|->
name|repos_id
operator|&&
name|work
operator|->
name|presence
operator|==
name|svn_wc__db_status_normal
operator|&&
operator|!
name|below_working_node
condition|)
block|{
comment|/* Introduce a not-present node! */
name|below_working_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|below_working_node
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|below_working_node
operator|->
name|wc_id
operator|=
name|wc_id
expr_stmt|;
name|below_working_node
operator|->
name|op_depth
operator|=
name|work
operator|->
name|op_depth
expr_stmt|;
name|below_working_node
operator|->
name|local_relpath
operator|=
name|local_relpath
expr_stmt|;
name|below_working_node
operator|->
name|parent_relpath
operator|=
name|parent_relpath
expr_stmt|;
name|below_working_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_not_present
expr_stmt|;
name|below_working_node
operator|->
name|repos_id
operator|=
name|repos_id
expr_stmt|;
name|below_working_node
operator|->
name|repos_relpath
operator|=
name|working_node
operator|->
name|local_relpath
expr_stmt|;
name|SVN_ERR
argument_list|(
name|insert_node
argument_list|(
name|sdb
argument_list|,
name|below_working_node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|below_working_node
operator|=
name|NULL
expr_stmt|;
comment|/* Don't write a present intermediate! */
block|}
block|}
if|if
condition|(
name|entry
operator|->
name|conflict_old
condition|)
block|{
name|actual_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|actual_node
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_relpath
operator|&&
name|entry
operator|->
name|conflict_old
condition|)
name|actual_node
operator|->
name|conflict_old
operator|=
name|svn_relpath_join
argument_list|(
name|parent_relpath
argument_list|,
name|entry
operator|->
name|conflict_old
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|actual_node
operator|->
name|conflict_old
operator|=
name|entry
operator|->
name|conflict_old
expr_stmt|;
if|if
condition|(
name|parent_relpath
operator|&&
name|entry
operator|->
name|conflict_new
condition|)
name|actual_node
operator|->
name|conflict_new
operator|=
name|svn_relpath_join
argument_list|(
name|parent_relpath
argument_list|,
name|entry
operator|->
name|conflict_new
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|actual_node
operator|->
name|conflict_new
operator|=
name|entry
operator|->
name|conflict_new
expr_stmt|;
if|if
condition|(
name|parent_relpath
operator|&&
name|entry
operator|->
name|conflict_wrk
condition|)
name|actual_node
operator|->
name|conflict_working
operator|=
name|svn_relpath_join
argument_list|(
name|parent_relpath
argument_list|,
name|entry
operator|->
name|conflict_wrk
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|actual_node
operator|->
name|conflict_working
operator|=
name|entry
operator|->
name|conflict_wrk
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|prejfile
condition|)
block|{
name|actual_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|actual_node
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|actual_node
operator|->
name|prop_reject
operator|=
name|svn_relpath_join
argument_list|(
operator|(
name|entry
operator|->
name|kind
operator|==
name|svn_node_dir
condition|?
name|local_relpath
else|:
name|parent_relpath
operator|)
argument_list|,
name|entry
operator|->
name|prejfile
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|changelist
condition|)
block|{
name|actual_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|actual_node
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|actual_node
operator|->
name|changelist
operator|=
name|entry
operator|->
name|changelist
expr_stmt|;
block|}
comment|/* ### set the text_mod value? */
if|if
condition|(
name|entry_node
operator|&&
name|entry
operator|->
name|tree_conflict_data
condition|)
block|{
comment|/* Issues #3840/#3916: 1.6 stores multiple tree conflicts on the          parent node, 1.7 stores them directly on the conflited nodes.          So "((skel1) (skel2))" becomes "(skel1)" and "(skel2)" */
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
name|skel
operator|=
name|svn_skel__parse
argument_list|(
name|entry
operator|->
name|tree_conflict_data
argument_list|,
name|strlen
argument_list|(
name|entry
operator|->
name|tree_conflict_data
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|tree_conflicts
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|skel
operator|=
name|skel
operator|->
name|children
expr_stmt|;
while|while
condition|(
name|skel
condition|)
block|{
name|svn_wc_conflict_description2_t
modifier|*
name|conflict
decl_stmt|;
name|svn_skel_t
modifier|*
name|new_skel
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
comment|/* *CONFLICT is allocated so it is safe to use a non-const pointer */
name|SVN_ERR
argument_list|(
name|svn_wc__deserialize_conflict
argument_list|(
operator|(
specifier|const
name|svn_wc_conflict_description2_t
operator|*
operator|*
operator|)
operator|&
name|conflict
argument_list|,
name|skel
argument_list|,
name|svn_dirent_join
argument_list|(
name|root_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_ENTRY_ASSERT
argument_list|(
name|conflict
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_tree
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__serialize_conflict
argument_list|(
operator|&
name|new_skel
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store in hash to be retrieved when writing the child              row. */
name|key
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|root_abspath
argument_list|,
name|conflict
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|tree_conflicts
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|key
argument_list|)
argument_list|,
name|svn_skel__unparse
argument_list|(
name|new_skel
argument_list|,
name|result_pool
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|skel
operator|=
name|skel
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
name|tree_conflicts
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|parent_node
operator|&&
name|parent_node
operator|->
name|tree_conflicts
condition|)
block|{
specifier|const
name|char
modifier|*
name|tree_conflict_data
init|=
name|svn_hash_gets
argument_list|(
name|parent_node
operator|->
name|tree_conflicts
argument_list|,
name|local_relpath
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_conflict_data
condition|)
block|{
name|actual_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|actual_node
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|actual_node
operator|->
name|tree_conflict_data
operator|=
name|tree_conflict_data
expr_stmt|;
block|}
comment|/* Reset hash so that we don't write the row again when writing          actual-only nodes */
name|svn_hash_sets
argument_list|(
name|parent_node
operator|->
name|tree_conflicts
argument_list|,
name|local_relpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|file_external_path
operator|!=
name|NULL
condition|)
block|{
name|base_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|base_node
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Insert the base node. */
if|if
condition|(
name|base_node
condition|)
block|{
name|base_node
operator|->
name|wc_id
operator|=
name|wc_id
expr_stmt|;
name|base_node
operator|->
name|local_relpath
operator|=
name|local_relpath
expr_stmt|;
name|base_node
operator|->
name|op_depth
operator|=
literal|0
expr_stmt|;
name|base_node
operator|->
name|parent_relpath
operator|=
name|parent_relpath
expr_stmt|;
name|base_node
operator|->
name|revision
operator|=
name|entry
operator|->
name|revision
expr_stmt|;
name|base_node
operator|->
name|recorded_time
operator|=
name|entry
operator|->
name|text_time
expr_stmt|;
name|base_node
operator|->
name|recorded_size
operator|=
name|entry
operator|->
name|working_size
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|depth
operator|!=
name|svn_depth_exclude
condition|)
name|base_node
operator|->
name|depth
operator|=
name|entry
operator|->
name|depth
expr_stmt|;
else|else
block|{
name|base_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_excluded
expr_stmt|;
name|base_node
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|deleted
condition|)
block|{
name|WRITE_ENTRY_ASSERT
argument_list|(
name|base_node
operator|->
name|presence
operator|==
name|svn_wc__db_status_not_present
argument_list|)
expr_stmt|;
comment|/* ### should be svn_node_unknown, but let's store what we have. */
name|base_node
operator|->
name|kind
operator|=
name|entry
operator|->
name|kind
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|absent
condition|)
block|{
name|WRITE_ENTRY_ASSERT
argument_list|(
name|base_node
operator|->
name|presence
operator|==
name|svn_wc__db_status_server_excluded
argument_list|)
expr_stmt|;
comment|/* ### should be svn_node_unknown, but let's store what we have. */
name|base_node
operator|->
name|kind
operator|=
name|entry
operator|->
name|kind
expr_stmt|;
comment|/* Store the most likely revision in the node to avoid              base nodes without a valid revision. Of course              we remember that the data is still incomplete. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_node
operator|->
name|revision
argument_list|)
operator|&&
name|parent_node
operator|->
name|base
condition|)
name|base_node
operator|->
name|revision
operator|=
name|parent_node
operator|->
name|base
operator|->
name|revision
expr_stmt|;
block|}
else|else
block|{
name|base_node
operator|->
name|kind
operator|=
name|entry
operator|->
name|kind
expr_stmt|;
if|if
condition|(
name|base_node
operator|->
name|presence
operator|!=
name|svn_wc__db_status_excluded
condition|)
block|{
comment|/* All subdirs are initially incomplete, they stop being                  incomplete when the entries file in the subdir is                  upgraded and remain incomplete if that doesn't happen. */
if|if
condition|(
name|entry
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
condition|)
block|{
name|base_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_incomplete
expr_stmt|;
comment|/* Store the most likely revision in the node to avoid                      base nodes without a valid revision. Of course                      we remember that the data is still incomplete. */
if|if
condition|(
name|parent_node
operator|->
name|base
condition|)
name|base_node
operator|->
name|revision
operator|=
name|parent_node
operator|->
name|base
operator|->
name|revision
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|incomplete
condition|)
block|{
comment|/* ### nobody should have set the presence.  */
name|WRITE_ENTRY_ASSERT
argument_list|(
name|base_node
operator|->
name|presence
operator|==
name|svn_wc__db_status_normal
argument_list|)
expr_stmt|;
name|base_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_incomplete
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|entry
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|base_node
operator|->
name|checksum
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|text_base_info
operator|&&
name|text_base_info
operator|->
name|revert_base
operator|.
name|sha1_checksum
condition|)
name|base_node
operator|->
name|checksum
operator|=
name|text_base_info
operator|->
name|revert_base
operator|.
name|sha1_checksum
expr_stmt|;
elseif|else
if|if
condition|(
name|text_base_info
operator|&&
name|text_base_info
operator|->
name|normal_base
operator|.
name|sha1_checksum
condition|)
name|base_node
operator|->
name|checksum
operator|=
name|text_base_info
operator|->
name|normal_base
operator|.
name|sha1_checksum
expr_stmt|;
else|else
name|base_node
operator|->
name|checksum
operator|=
name|NULL
expr_stmt|;
comment|/* The base MD5 checksum is available in the entry, unless there            * is a copied WORKING node.  If possible, verify that the entry            * checksum matches the base file that we found. */
if|if
condition|(
operator|!
operator|(
name|working_node
operator|&&
name|entry
operator|->
name|copied
operator|)
condition|)
block|{
name|svn_checksum_t
modifier|*
name|entry_md5_checksum
decl_stmt|,
modifier|*
name|found_md5_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|entry_md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|entry
operator|->
name|checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_base_info
operator|&&
name|text_base_info
operator|->
name|revert_base
operator|.
name|md5_checksum
condition|)
name|found_md5_checksum
operator|=
name|text_base_info
operator|->
name|revert_base
operator|.
name|md5_checksum
expr_stmt|;
elseif|else
if|if
condition|(
name|text_base_info
operator|&&
name|text_base_info
operator|->
name|normal_base
operator|.
name|md5_checksum
condition|)
name|found_md5_checksum
operator|=
name|text_base_info
operator|->
name|normal_base
operator|.
name|md5_checksum
expr_stmt|;
else|else
name|found_md5_checksum
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|entry_md5_checksum
operator|&&
name|found_md5_checksum
operator|&&
operator|!
name|svn_checksum_match
argument_list|(
name|entry_md5_checksum
argument_list|,
name|found_md5_checksum
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad base MD5 checksum for '%s'; "
literal|"expected: '%s'; found '%s'; "
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|svn_dirent_join
argument_list|(
name|root_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_checksum_to_cstring_display
argument_list|(
name|entry_md5_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_checksum_to_cstring_display
argument_list|(
name|found_md5_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
else|else
block|{
comment|/* ### Not sure what conditions this should cover. */
comment|/* SVN_ERR_ASSERT(entry->deleted || ...); */
block|}
block|}
block|}
if|if
condition|(
name|this_dir
operator|->
name|repos
condition|)
block|{
name|base_node
operator|->
name|repos_id
operator|=
name|repos_id
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|url
operator|!=
name|NULL
condition|)
block|{
name|base_node
operator|->
name|repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|this_dir
operator|->
name|repos
argument_list|,
name|entry
operator|->
name|url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|this_dir
operator|->
name|repos
argument_list|,
name|this_dir
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|relpath
operator|==
name|NULL
operator|||
operator|*
name|relpath
operator|==
literal|'\0'
condition|)
name|base_node
operator|->
name|repos_relpath
operator|=
name|entry
operator|->
name|name
expr_stmt|;
else|else
name|base_node
operator|->
name|repos_relpath
operator|=
name|svn_dirent_join
argument_list|(
name|relpath
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* TODO: These values should always be present, if they are missing          during an upgrade, set a flag, and then ask the user to talk to the          server.           Note: cmt_rev is the distinguishing value. The others may be 0 or          NULL if the corresponding revprop has been deleted.  */
name|base_node
operator|->
name|changed_rev
operator|=
name|entry
operator|->
name|cmt_rev
expr_stmt|;
name|base_node
operator|->
name|changed_date
operator|=
name|entry
operator|->
name|cmt_date
expr_stmt|;
name|base_node
operator|->
name|changed_author
operator|=
name|entry
operator|->
name|cmt_author
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|file_external_path
condition|)
name|base_node
operator|->
name|file_external
operator|=
name|TRUE
expr_stmt|;
comment|/* Switched nodes get an empty iprops cache. */
if|if
condition|(
name|parent_node
operator|&&
name|is_switched
argument_list|(
name|parent_node
operator|->
name|base
argument_list|,
name|base_node
argument_list|,
name|scratch_pool
argument_list|)
condition|)
name|base_node
operator|->
name|inherited_props
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_inherited_item_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|insert_node
argument_list|(
name|sdb
argument_list|,
name|base_node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have to insert the lock after the base node, because the node          must exist to lookup various bits of repos related information for          the abs path. */
if|if
condition|(
name|entry
operator|->
name|lock_token
operator|&&
name|create_locks
condition|)
block|{
name|svn_wc__db_lock_t
name|lock
decl_stmt|;
name|lock
operator|.
name|token
operator|=
name|entry
operator|->
name|lock_token
expr_stmt|;
name|lock
operator|.
name|owner
operator|=
name|entry
operator|->
name|lock_owner
expr_stmt|;
name|lock
operator|.
name|comment
operator|=
name|entry
operator|->
name|lock_comment
expr_stmt|;
name|lock
operator|.
name|date
operator|=
name|entry
operator|->
name|lock_creation_date
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_lock_add
argument_list|(
name|db
argument_list|,
name|tmp_entry_abspath
argument_list|,
operator|&
name|lock
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|below_working_node
condition|)
block|{
name|db_node_t
modifier|*
name|work
init|=
name|parent_node
operator|->
name|below_work
condition|?
name|parent_node
operator|->
name|below_work
else|:
name|parent_node
operator|->
name|work
decl_stmt|;
name|below_working_node
operator|->
name|wc_id
operator|=
name|wc_id
expr_stmt|;
name|below_working_node
operator|->
name|local_relpath
operator|=
name|local_relpath
expr_stmt|;
name|below_working_node
operator|->
name|op_depth
operator|=
name|work
operator|->
name|op_depth
expr_stmt|;
name|below_working_node
operator|->
name|parent_relpath
operator|=
name|parent_relpath
expr_stmt|;
name|below_working_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_normal
expr_stmt|;
name|below_working_node
operator|->
name|kind
operator|=
name|entry
operator|->
name|kind
expr_stmt|;
name|below_working_node
operator|->
name|repos_id
operator|=
name|work
operator|->
name|repos_id
expr_stmt|;
name|below_working_node
operator|->
name|revision
operator|=
name|work
operator|->
name|revision
expr_stmt|;
comment|/* This is just guessing. If the node below would have been switched          or if it was updated to a different version, the guess would          fail. But we don't have better information pre wc-ng :( */
if|if
condition|(
name|work
operator|->
name|repos_relpath
condition|)
name|below_working_node
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|work
operator|->
name|repos_relpath
argument_list|,
name|svn_relpath_basename
argument_list|(
name|local_relpath
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|below_working_node
operator|->
name|repos_relpath
operator|=
name|NULL
expr_stmt|;
comment|/* The revert_base checksum isn't available in the entry structure,          so the caller provides it. */
comment|/* text_base_info is NULL for files scheduled to be added. */
name|below_working_node
operator|->
name|checksum
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|text_base_info
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|schedule
operator|==
name|svn_wc_schedule_delete
condition|)
name|below_working_node
operator|->
name|checksum
operator|=
name|text_base_info
operator|->
name|normal_base
operator|.
name|sha1_checksum
expr_stmt|;
else|else
name|below_working_node
operator|->
name|checksum
operator|=
name|text_base_info
operator|->
name|revert_base
operator|.
name|sha1_checksum
expr_stmt|;
block|}
name|below_working_node
operator|->
name|recorded_size
operator|=
literal|0
expr_stmt|;
name|below_working_node
operator|->
name|changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|below_working_node
operator|->
name|changed_date
operator|=
literal|0
expr_stmt|;
name|below_working_node
operator|->
name|changed_author
operator|=
name|NULL
expr_stmt|;
name|below_working_node
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|below_working_node
operator|->
name|recorded_time
operator|=
literal|0
expr_stmt|;
name|below_working_node
operator|->
name|properties
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|working_node
operator|&&
name|entry
operator|->
name|schedule
operator|==
name|svn_wc_schedule_delete
operator|&&
name|working_node
operator|->
name|repos_relpath
condition|)
block|{
comment|/* We are lucky, our guesses above are not necessary. The known              correct information is in working. But our op_depth design              expects more information here */
name|below_working_node
operator|->
name|repos_relpath
operator|=
name|working_node
operator|->
name|repos_relpath
expr_stmt|;
name|below_working_node
operator|->
name|repos_id
operator|=
name|working_node
operator|->
name|repos_id
expr_stmt|;
name|below_working_node
operator|->
name|revision
operator|=
name|working_node
operator|->
name|revision
expr_stmt|;
comment|/* Nice for 'svn status' */
name|below_working_node
operator|->
name|changed_rev
operator|=
name|entry
operator|->
name|cmt_rev
expr_stmt|;
name|below_working_node
operator|->
name|changed_date
operator|=
name|entry
operator|->
name|cmt_date
expr_stmt|;
name|below_working_node
operator|->
name|changed_author
operator|=
name|entry
operator|->
name|cmt_author
expr_stmt|;
comment|/* And now remove it from WORKING, because in wc-ng code              should read it from the lower layer */
name|working_node
operator|->
name|repos_relpath
operator|=
name|NULL
expr_stmt|;
name|working_node
operator|->
name|repos_id
operator|=
literal|0
expr_stmt|;
name|working_node
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|insert_node
argument_list|(
name|sdb
argument_list|,
name|below_working_node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Insert the working node. */
if|if
condition|(
name|working_node
condition|)
block|{
name|working_node
operator|->
name|wc_id
operator|=
name|wc_id
expr_stmt|;
name|working_node
operator|->
name|local_relpath
operator|=
name|local_relpath
expr_stmt|;
name|working_node
operator|->
name|parent_relpath
operator|=
name|parent_relpath
expr_stmt|;
name|working_node
operator|->
name|changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|working_node
operator|->
name|recorded_time
operator|=
name|entry
operator|->
name|text_time
expr_stmt|;
name|working_node
operator|->
name|recorded_size
operator|=
name|entry
operator|->
name|working_size
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|depth
operator|!=
name|svn_depth_exclude
condition|)
name|working_node
operator|->
name|depth
operator|=
name|entry
operator|->
name|depth
expr_stmt|;
else|else
block|{
name|working_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_excluded
expr_stmt|;
name|working_node
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|working_node
operator|->
name|checksum
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|working_node
operator|->
name|checksum
operator|=
name|NULL
expr_stmt|;
comment|/* text_base_info is NULL for files scheduled to be added. */
if|if
condition|(
name|text_base_info
condition|)
name|working_node
operator|->
name|checksum
operator|=
name|text_base_info
operator|->
name|normal_base
operator|.
name|sha1_checksum
expr_stmt|;
comment|/* If an MD5 checksum is present in the entry, we can verify that            * it matches the MD5 of the base file we found earlier. */
ifdef|#
directive|ifdef
name|SVN_DEBUG
if|if
condition|(
name|entry
operator|->
name|checksum
operator|&&
name|text_base_info
condition|)
block|{
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|entry
operator|->
name|checksum
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|md5_checksum
operator|&&
name|text_base_info
operator|->
name|normal_base
operator|.
name|md5_checksum
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_checksum_match
argument_list|(
name|md5_checksum
argument_list|,
name|text_base_info
operator|->
name|normal_base
operator|.
name|md5_checksum
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|working_node
operator|->
name|kind
operator|=
name|entry
operator|->
name|kind
expr_stmt|;
if|if
condition|(
name|working_node
operator|->
name|presence
operator|!=
name|svn_wc__db_status_excluded
condition|)
block|{
comment|/* All subdirs start of incomplete, and stop being incomplete              when the entries file in the subdir is upgraded. */
if|if
condition|(
name|entry
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
condition|)
block|{
name|working_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_incomplete
expr_stmt|;
name|working_node
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|schedule
operator|==
name|svn_wc_schedule_delete
condition|)
block|{
name|working_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_base_deleted
expr_stmt|;
name|working_node
operator|->
name|kind
operator|=
name|entry
operator|->
name|kind
expr_stmt|;
block|}
else|else
block|{
comment|/* presence == normal  */
name|working_node
operator|->
name|kind
operator|=
name|entry
operator|->
name|kind
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|incomplete
condition|)
block|{
comment|/* We shouldn't be overwriting another status.  */
name|WRITE_ENTRY_ASSERT
argument_list|(
name|working_node
operator|->
name|presence
operator|==
name|svn_wc__db_status_normal
argument_list|)
expr_stmt|;
name|working_node
operator|->
name|presence
operator|=
name|svn_wc__db_status_incomplete
expr_stmt|;
block|}
block|}
block|}
comment|/* These should generally be unset for added and deleted files,          and contain whatever information we have for copied files. Let's          just store whatever we have.           Note: cmt_rev is the distinguishing value. The others may be 0 or          NULL if the corresponding revprop has been deleted.  */
if|if
condition|(
name|working_node
operator|->
name|presence
operator|!=
name|svn_wc__db_status_base_deleted
condition|)
block|{
name|working_node
operator|->
name|changed_rev
operator|=
name|entry
operator|->
name|cmt_rev
expr_stmt|;
name|working_node
operator|->
name|changed_date
operator|=
name|entry
operator|->
name|cmt_date
expr_stmt|;
name|working_node
operator|->
name|changed_author
operator|=
name|entry
operator|->
name|cmt_author
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|schedule
operator|==
name|svn_wc_schedule_delete
operator|&&
name|parent_node
operator|->
name|work
operator|&&
name|parent_node
operator|->
name|work
operator|->
name|presence
operator|==
name|svn_wc__db_status_base_deleted
condition|)
block|{
name|working_node
operator|->
name|op_depth
operator|=
name|parent_node
operator|->
name|work
operator|->
name|op_depth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|working_node
operator|->
name|presence
operator|==
name|svn_wc__db_status_excluded
operator|&&
name|parent_node
operator|->
name|work
condition|)
block|{
name|working_node
operator|->
name|op_depth
operator|=
name|parent_node
operator|->
name|work
operator|->
name|op_depth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|entry
operator|->
name|copied
condition|)
block|{
name|working_node
operator|->
name|op_depth
operator|=
name|svn_wc__db_op_depth_for_upgrade
argument_list|(
name|local_relpath
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|insert_node
argument_list|(
name|sdb
argument_list|,
name|working_node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Insert the actual node. */
if|if
condition|(
name|actual_node
condition|)
block|{
name|actual_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|actual_node
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|actual_node
operator|->
name|wc_id
operator|=
name|wc_id
expr_stmt|;
name|actual_node
operator|->
name|local_relpath
operator|=
name|local_relpath
expr_stmt|;
name|actual_node
operator|->
name|parent_relpath
operator|=
name|parent_relpath
expr_stmt|;
name|SVN_ERR
argument_list|(
name|insert_actual_node
argument_list|(
name|sdb
argument_list|,
name|db
argument_list|,
name|tmp_entry_abspath
argument_list|,
name|actual_node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry_node
condition|)
block|{
operator|*
name|entry_node
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|entry_node
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|entry_node
operator|)
operator|->
name|base
operator|=
name|base_node
expr_stmt|;
operator|(
operator|*
name|entry_node
operator|)
operator|->
name|work
operator|=
name|working_node
expr_stmt|;
operator|(
operator|*
name|entry_node
operator|)
operator|->
name|below_work
operator|=
name|below_working_node
expr_stmt|;
operator|(
operator|*
name|entry_node
operator|)
operator|->
name|tree_conflicts
operator|=
name|tree_conflicts
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|file_external_path
condition|)
block|{
comment|/* TODO: Maybe add a file external registration inside EXTERNALS here,                to allow removing file externals that aren't referenced from                svn:externals.           The svn:externals values are processed anyway after everything is          upgraded */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_actual_only_entries
parameter_list|(
name|apr_hash_t
modifier|*
name|tree_conflicts
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|apr_int64_t
name|wc_id
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|tree_conflicts
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|db_actual_node_t
modifier|*
name|actual_node
init|=
name|NULL
decl_stmt|;
name|actual_node
operator|=
name|MAYBE_ALLOC
argument_list|(
name|actual_node
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|actual_node
operator|->
name|wc_id
operator|=
name|wc_id
expr_stmt|;
name|actual_node
operator|->
name|local_relpath
operator|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|actual_node
operator|->
name|parent_relpath
operator|=
name|parent_relpath
expr_stmt|;
name|actual_node
operator|->
name|tree_conflict_data
operator|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|insert_actual_node
argument_list|(
name|sdb
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|actual_node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__write_upgraded_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_int64_t
name|repos_id
parameter_list|,
name|apr_int64_t
name|wc_id
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|new_root_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|entries
parameter_list|,
name|apr_hash_t
modifier|*
name|text_bases_info
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_wc_entry_t
modifier|*
name|this_dir
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_root_abspath
decl_stmt|,
modifier|*
name|dir_relpath
decl_stmt|;
name|struct
name|write_baton
modifier|*
name|parent_node
init|=
name|parent_baton
decl_stmt|;
name|struct
name|write_baton
modifier|*
name|dir_node
decl_stmt|;
comment|/* Get a copy of the "this dir" entry for comparison purposes. */
name|this_dir
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
expr_stmt|;
comment|/* If there is no "this dir" entry, something is wrong. */
if|if
condition|(
operator|!
name|this_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No default entry in directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dir_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
name|old_root_abspath
operator|=
name|svn_dirent_get_longest_ancestor
argument_list|(
name|dir_abspath
argument_list|,
name|new_root_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|old_root_abspath
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dir_relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|old_root_abspath
argument_list|,
name|dir_abspath
argument_list|)
expr_stmt|;
comment|/* Write out "this dir" */
name|SVN_ERR
argument_list|(
name|write_entry
argument_list|(
operator|&
name|dir_node
argument_list|,
name|parent_node
argument_list|,
name|db
argument_list|,
name|sdb
argument_list|,
name|wc_id
argument_list|,
name|repos_id
argument_list|,
name|this_dir
argument_list|,
name|NULL
argument_list|,
name|dir_relpath
argument_list|,
name|svn_dirent_join
argument_list|(
name|new_root_abspath
argument_list|,
name|dir_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|old_root_abspath
argument_list|,
name|this_dir
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_wc_entry_t
modifier|*
name|this_entry
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|,
modifier|*
name|child_relpath
decl_stmt|;
name|svn_wc__text_base_info_t
modifier|*
name|text_base_info
init|=
name|svn_hash_gets
argument_list|(
name|text_bases_info
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Don't rewrite the "this dir" entry! */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Write the entry. Pass TRUE for create locks, because we still          use this function for upgrading old working copies. */
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dir_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|child_relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|old_root_abspath
argument_list|,
name|child_abspath
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_entry
argument_list|(
name|NULL
argument_list|,
name|dir_node
argument_list|,
name|db
argument_list|,
name|sdb
argument_list|,
name|wc_id
argument_list|,
name|repos_id
argument_list|,
name|this_entry
argument_list|,
name|text_base_info
argument_list|,
name|child_relpath
argument_list|,
name|svn_dirent_join
argument_list|(
name|new_root_abspath
argument_list|,
name|child_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|old_root_abspath
argument_list|,
name|this_dir
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir_node
operator|->
name|tree_conflicts
condition|)
name|SVN_ERR
argument_list|(
name|write_actual_only_entries
argument_list|(
name|dir_node
operator|->
name|tree_conflicts
argument_list|,
name|sdb
argument_list|,
name|db
argument_list|,
name|new_root_abspath
argument_list|,
name|wc_id
argument_list|,
name|dir_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dir_baton
operator|=
name|dir_node
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_wc_entry_t
modifier|*
name|svn_wc_entry_dup
parameter_list|(
specifier|const
name|svn_wc_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_entry_t
modifier|*
name|dupentry
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dupentry
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Perform a trivial copy ... */
operator|*
name|dupentry
operator|=
operator|*
name|entry
expr_stmt|;
comment|/* ...and then re-copy stuff that needs to be duped into our pool. */
if|if
condition|(
name|entry
operator|->
name|name
condition|)
name|dupentry
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|url
condition|)
name|dupentry
operator|->
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|repos
condition|)
name|dupentry
operator|->
name|repos
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|repos
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|uuid
condition|)
name|dupentry
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|copyfrom_url
condition|)
name|dupentry
operator|->
name|copyfrom_url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|copyfrom_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|conflict_old
condition|)
name|dupentry
operator|->
name|conflict_old
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|conflict_old
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|conflict_new
condition|)
name|dupentry
operator|->
name|conflict_new
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|conflict_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|conflict_wrk
condition|)
name|dupentry
operator|->
name|conflict_wrk
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|conflict_wrk
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|prejfile
condition|)
name|dupentry
operator|->
name|prejfile
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|prejfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|checksum
condition|)
name|dupentry
operator|->
name|checksum
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|cmt_author
condition|)
name|dupentry
operator|->
name|cmt_author
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|cmt_author
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|lock_token
condition|)
name|dupentry
operator|->
name|lock_token
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|lock_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|lock_owner
condition|)
name|dupentry
operator|->
name|lock_owner
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|lock_owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|lock_comment
condition|)
name|dupentry
operator|->
name|lock_comment
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|lock_comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|changelist
condition|)
name|dupentry
operator|->
name|changelist
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|changelist
argument_list|)
expr_stmt|;
comment|/* NOTE: we do not dup cachable_props or present_props since they      are deprecated. Use "" to indicate "nothing cachable or cached". */
name|dupentry
operator|->
name|cachable_props
operator|=
literal|""
expr_stmt|;
name|dupentry
operator|->
name|present_props
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|tree_conflict_data
condition|)
name|dupentry
operator|->
name|tree_conflict_data
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|tree_conflict_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|file_external_path
condition|)
name|dupentry
operator|->
name|file_external_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|file_external_path
argument_list|)
expr_stmt|;
return|return
name|dupentry
return|;
block|}
end_function

begin_comment
comment|/*** Generic Entry Walker */
end_comment

begin_comment
comment|/* A recursive entry-walker, helper for svn_wc_walk_entries3().  *  * For this directory (DIRPATH, ADM_ACCESS), call the "found_entry" callback  * in WALK_CALLBACKS, passing WALK_BATON to it. Then, for each versioned  * entry in this directory, call the "found entry" callback and then recurse  * (if it is a directory and if DEPTH allows).  *  * If SHOW_HIDDEN is true, include entries that are in a 'deleted' or  * 'absent' state (and not scheduled for re-addition), else skip them.  *  * Call CANCEL_FUNC with CANCEL_BATON to allow cancellation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|walker_helper
parameter_list|(
specifier|const
name|char
modifier|*
name|dirpath
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|,
specifier|const
name|svn_wc_entry_callbacks2_t
modifier|*
name|walk_callbacks
parameter_list|,
name|void
modifier|*
name|walk_baton
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|show_hidden
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_wc_entry_t
modifier|*
name|dot_entry
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
init|=
name|svn_wc__adm_get_db
argument_list|(
name|adm_access
argument_list|)
decl_stmt|;
name|err
operator|=
name|svn_wc__entries_read_internal
argument_list|(
operator|&
name|entries
argument_list|,
name|adm_access
argument_list|,
name|show_hidden
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|SVN_ERR
argument_list|(
name|walk_callbacks
operator|->
name|handle_error
argument_list|(
name|dirpath
argument_list|,
name|err
argument_list|,
name|walk_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As promised, always return the '.' entry first. */
name|dot_entry
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dot_entry
condition|)
return|return
name|walk_callbacks
operator|->
name|handle_error
argument_list|(
name|dirpath
argument_list|,
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory '%s' has no THIS_DIR entry"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dirpath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|,
name|walk_baton
argument_list|,
name|pool
argument_list|)
return|;
comment|/* Call the "found entry" callback for this directory as a "this dir"    * entry. Note that if this directory has been reached by recursion, this    * is the second visit as it will already have been visited once as a    * child entry of its parent. */
name|err
operator|=
name|walk_callbacks
operator|->
name|found_entry
argument_list|(
name|dirpath
argument_list|,
name|dot_entry
argument_list|,
name|walk_baton
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|SVN_ERR
argument_list|(
name|walk_callbacks
operator|->
name|handle_error
argument_list|(
name|dirpath
argument_list|,
name|err
argument_list|,
name|walk_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_empty
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Loop over each of the other entries. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_wc_entry_t
modifier|*
name|current_entry
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|entrypath
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry_abspath
decl_stmt|;
name|svn_boolean_t
name|hidden
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* See if someone wants to cancel this operation. */
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip the "this dir" entry. */
if|if
condition|(
name|strcmp
argument_list|(
name|current_entry
operator|->
name|name
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|entrypath
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|name
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__entry_is_hidden
argument_list|(
operator|&
name|hidden
argument_list|,
name|current_entry
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|entry_abspath
argument_list|,
name|entrypath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the "found entry" callback for this entry. (For a directory,        * this is the first visit: as a child.) */
if|if
condition|(
name|current_entry
operator|->
name|kind
operator|==
name|svn_node_file
operator|||
name|depth
operator|>=
name|svn_depth_immediates
condition|)
block|{
name|err
operator|=
name|walk_callbacks
operator|->
name|found_entry
argument_list|(
name|entrypath
argument_list|,
name|current_entry
argument_list|,
name|walk_baton
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|SVN_ERR
argument_list|(
name|walk_callbacks
operator|->
name|handle_error
argument_list|(
name|entrypath
argument_list|,
name|err
argument_list|,
name|walk_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Recurse into this entry if appropriate. */
if|if
condition|(
name|current_entry
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
operator|!
name|hidden
operator|&&
name|depth
operator|>=
name|svn_depth_immediates
condition|)
block|{
name|svn_wc_adm_access_t
modifier|*
name|entry_access
decl_stmt|;
name|svn_depth_t
name|depth_below_here
init|=
name|depth
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_immediates
condition|)
name|depth_below_here
operator|=
name|svn_depth_empty
expr_stmt|;
name|entry_access
operator|=
name|svn_wc__adm_retrieve_internal2
argument_list|(
name|db
argument_list|,
name|entry_abspath
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_access
condition|)
name|SVN_ERR
argument_list|(
name|walker_helper
argument_list|(
name|entrypath
argument_list|,
name|entry_access
argument_list|,
name|walk_callbacks
argument_list|,
name|walk_baton
argument_list|,
name|depth_below_here
argument_list|,
name|show_hidden
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__walker_default_error_handler
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|void
modifier|*
name|walk_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Note: don't trace this. We don't want to insert a false "stack frame"      onto an error generated elsewhere.  */
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The public API. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc_walk_entries3
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|,
specifier|const
name|svn_wc_entry_callbacks2_t
modifier|*
name|walk_callbacks
parameter_list|,
name|void
modifier|*
name|walk_baton
parameter_list|,
name|svn_depth_t
name|walk_depth
parameter_list|,
name|svn_boolean_t
name|show_hidden
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
init|=
name|svn_wc__adm_get_db
argument_list|(
name|adm_access
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* Remap into SVN_ERR_UNVERSIONED_RESOURCE.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|walk_callbacks
operator|->
name|handle_error
argument_list|(
name|path
argument_list|,
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNVERSIONED_RESOURCE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|,
name|walk_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
condition|)
block|{
specifier|const
name|svn_wc_entry_t
modifier|*
name|entry
decl_stmt|;
comment|/* ### we should stop passing out entry structures.          ###          ### we should not call handle_error for an error the *callback*          ###   gave us. let it deal with the problem before returning.  */
if|if
condition|(
operator|!
name|show_hidden
operator|&&
operator|(
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|)
condition|)
block|{
comment|/* The fool asked to walk a "hidden" node. Report the node as               unversioned.                ### this is incorrect behavior. see depth_test 36. the walk               ### API will be revamped to avoid entry structures. we should               ### be able to solve the problem with the new API. (since we               ### shouldn't return a hidden entry here)  */
return|return
name|walk_callbacks
operator|->
name|handle_error
argument_list|(
name|path
argument_list|,
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNVERSIONED_RESOURCE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|,
name|walk_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__get_entry
argument_list|(
operator|&
name|entry
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|svn_node_file
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|walk_callbacks
operator|->
name|found_entry
argument_list|(
name|path
argument_list|,
name|entry
argument_list|,
name|walk_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|walk_callbacks
operator|->
name|handle_error
argument_list|(
name|path
argument_list|,
name|err
argument_list|,
name|walk_baton
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
return|return
name|walker_helper
argument_list|(
name|path
argument_list|,
name|adm_access
argument_list|,
name|walk_callbacks
argument_list|,
name|walk_baton
argument_list|,
name|walk_depth
argument_list|,
name|show_hidden
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|walk_callbacks
operator|->
name|handle_error
argument_list|(
name|path
argument_list|,
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNKNOWN_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' has an unrecognized node kind"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|,
name|walk_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

end_unit

