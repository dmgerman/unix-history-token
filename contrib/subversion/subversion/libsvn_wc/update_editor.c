begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * update_editor.c :  main editor for checkouts and updates  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_editor.h"
end_include

begin_comment
comment|/* Checks whether a svn_wc__db_status_t indicates whether a node is    present in a working copy. Used by the editor implementation */
end_comment

begin_define
define|#
directive|define
name|IS_NODE_PRESENT
parameter_list|(
name|status
parameter_list|)
define|\
value|((status) != svn_wc__db_status_server_excluded&&\             (status) != svn_wc__db_status_excluded&&       \             (status) != svn_wc__db_status_not_present)
end_define

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|path_join_under_root
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result_path
parameter_list|,
specifier|const
name|char
modifier|*
name|base_path
parameter_list|,
specifier|const
name|char
modifier|*
name|add_path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*  * This code handles "checkout" and "update" and "switch".  * A checkout is similar to an update that is only adding new items.  *  * The intended behaviour of "update" and "switch", focusing on the checks  * to be made before applying a change, is:  *  *   For each incoming change:  *     if target is already in conflict or obstructed:  *       skip this change  *     else  *     if this action will cause a tree conflict:  *       record the tree conflict  *       skip this change  *     else:  *       make this change  *  * In more detail:  *  *   For each incoming change:  *  *   1.   if  # Incoming change is inside an item already in conflict:  *    a.    tree/text/prop change to node beneath tree-conflicted dir  *        then  # Skip all changes in this conflicted subtree [*1]:  *          do not update the Base nor the Working  *          notify "skipped because already in conflict" just once  *            for the whole conflicted subtree  *  *        if  # Incoming change affects an item already in conflict:  *    b.    tree/text/prop change to tree-conflicted dir/file, or  *    c.    tree change to a text/prop-conflicted file/dir, or  *    d.    text/prop change to a text/prop-conflicted file/dir [*2], or  *    e.    tree change to a dir tree containing any conflicts,  *        then  # Skip this change [*1]:  *          do not update the Base nor the Working  *          notify "skipped because already in conflict"  *  *   2.   if  # Incoming change affects an item that's "obstructed":  *    a.    on-disk node kind doesn't match recorded Working node kind  *            (including an absence/presence mis-match),  *        then  # Skip this change [*1]:  *          do not update the Base nor the Working  *          notify "skipped because obstructed"  *  *   3.   if  # Incoming change raises a tree conflict:  *    a.    tree/text/prop change to node beneath sched-delete dir, or  *    b.    tree/text/prop change to sched-delete dir/file, or  *    c.    text/prop change to tree-scheduled dir/file,  *        then  # Skip this change:  *          do not update the Base nor the Working [*3]  *          notify "tree conflict"  *  *   4.   Apply the change:  *          update the Base  *          update the Working, possibly raising text/prop conflicts  *          notify  *  * Notes:  *  *      "Tree change" here refers to an add or delete of the target node,  *      including the add or delete part of a copy or move or rename.  *  * [*1] We should skip changes to an entire node, as the base revision number  *      applies to the entire node. Not sure how this affects attempts to  *      handle text and prop changes separately.  *  * [*2] Details of which combinations of property and text changes conflict  *      are not specified here.  *  * [*3] For now, we skip the update, and require the user to:  *        - Modify the WC to be compatible with the incoming change;  *        - Mark the conflict as resolved;  *        - Repeat the update.  *      Ideally, it would be possible to resolve any conflict without  *      repeating the update. To achieve this, we would have to store the  *      necessary data at conflict detection time, and delay the update of  *      the Base until the time of resolving.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** batons ***/
end_comment

begin_struct
struct|struct
name|edit_baton
block|{
comment|/* For updates, the "destination" of the edit is ANCHOR_ABSPATH, the      directory containing TARGET_ABSPATH. If ANCHOR_ABSPATH itself is the      target, the values are identical.       TARGET_BASENAME is the name of TARGET_ABSPATH in ANCHOR_ABSPATH, or "" if      ANCHOR_ABSPATH is the target */
specifier|const
name|char
modifier|*
name|target_basename
decl_stmt|;
comment|/* Absolute variants of ANCHOR and TARGET */
specifier|const
name|char
modifier|*
name|anchor_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
comment|/* The DB handle for managing the working copy state.  */
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
comment|/* Array of file extension patterns to preserve as extensions in      generated conflict files. */
specifier|const
name|apr_array_header_t
modifier|*
name|ext_patterns
decl_stmt|;
comment|/* Hash mapping const char * absolute working copy paths to depth-first      ordered arrays of svn_prop_inherited_item_t * structures representing      the properties inherited by the base node at that working copy path.      May be NULL. */
name|apr_hash_t
modifier|*
name|wcroot_iprops
decl_stmt|;
comment|/* The revision we're targeting...or something like that.  This      starts off as a pointer to the revision to which we are updating,      or SVN_INVALID_REVNUM, but by the end of the edit, should be      pointing to the final revision. */
name|svn_revnum_t
modifier|*
name|target_revision
decl_stmt|;
comment|/* The requested depth of this edit. */
name|svn_depth_t
name|requested_depth
decl_stmt|;
comment|/* Is the requested depth merely an operational limitation, or is      also the new sticky ambient depth of the update target? */
name|svn_boolean_t
name|depth_is_sticky
decl_stmt|;
comment|/* Need to know if the user wants us to overwrite the 'now' times on      edited/added files with the last-commit-time. */
name|svn_boolean_t
name|use_commit_times
decl_stmt|;
comment|/* Was the root actually opened (was this a non-empty edit)? */
name|svn_boolean_t
name|root_opened
decl_stmt|;
comment|/* Was the update-target deleted?  This is a special situation. */
name|svn_boolean_t
name|target_deleted
decl_stmt|;
comment|/* Allow unversioned obstructions when adding a path. */
name|svn_boolean_t
name|allow_unver_obstructions
decl_stmt|;
comment|/* Handle local additions as modifications of new nodes */
name|svn_boolean_t
name|adds_as_modification
decl_stmt|;
comment|/* If set, we check out into an empty directory. This allows for a number      of conflict checks to be omitted. */
name|svn_boolean_t
name|clean_checkout
decl_stmt|;
comment|/* If this is a 'switch' operation, the new relpath of target_abspath,      else NULL. */
specifier|const
name|char
modifier|*
name|switch_relpath
decl_stmt|;
comment|/* The URL to the root of the repository. */
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
comment|/* The UUID of the repos, or NULL. */
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
comment|/* External diff3 to use for merges (can be null, in which case      internal merge code is used). */
specifier|const
name|char
modifier|*
name|diff3_cmd
decl_stmt|;
comment|/* Externals handler */
name|svn_wc_external_update_t
name|external_func
decl_stmt|;
name|void
modifier|*
name|external_baton
decl_stmt|;
comment|/* This editor sends back notifications as it edits. */
name|svn_wc_notify_func2_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
comment|/* This editor is normally wrapped in a cancellation editor anyway,      so it doesn't bother to check for cancellation itself.  However,      it needs a cancel_func and cancel_baton available to pass to      long-running functions. */
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
comment|/* This editor will invoke a interactive conflict-resolution      callback, if available. */
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
decl_stmt|;
name|void
modifier|*
name|conflict_baton
decl_stmt|;
comment|/* Subtrees that were skipped during the edit, and therefore shouldn't      have their revision/url info updated at the end.  If a path is a      directory, its descendants will also be skipped.  The keys are paths      relative to the working copy root and the values unspecified. */
name|apr_hash_t
modifier|*
name|skipped_trees
decl_stmt|;
comment|/* A mapping from const char * repos_relpaths to the apr_hash_t * instances      returned from fetch_dirents_func for that repos_relpath. These      are used to avoid issue #3569 in specific update scenarios where a      restricted depth is used. */
name|apr_hash_t
modifier|*
name|dir_dirents
decl_stmt|;
comment|/* Absolute path of the working copy root or NULL if not initialized yet */
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record in the edit baton EB that LOCAL_ABSPATH's base version is not being  * updated.  *  * Add to EB->skipped_trees a copy (allocated in EB->pool) of the string  * LOCAL_ABSPATH.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remember_skipped_tree
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|eb
operator|->
name|skipped_trees
argument_list|,
name|apr_pstrdup
argument_list|(
name|eb
operator|->
name|pool
argument_list|,
name|svn_dirent_skip_ancestor
argument_list|(
name|eb
operator|->
name|wcroot_abspath
argument_list|,
name|local_abspath
argument_list|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Per directory baton. Lives in its own subpool of the parent directory    or of the edit baton if there is no parent directory */
end_comment

begin_struct
struct|struct
name|dir_baton
block|{
comment|/* Basename of this directory. */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Absolute path of this directory */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* The repository relative path this directory will correspond to. */
specifier|const
name|char
modifier|*
name|new_relpath
decl_stmt|;
comment|/* The revision of the directory before updating */
name|svn_revnum_t
name|old_revision
decl_stmt|;
comment|/* The repos_relpath before updating/switching */
specifier|const
name|char
modifier|*
name|old_repos_relpath
decl_stmt|;
comment|/* The global edit baton. */
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
comment|/* Baton for this directory's parent, or NULL if this is the root      directory. */
name|struct
name|dir_baton
modifier|*
name|parent_baton
decl_stmt|;
comment|/* Set if updates to this directory are skipped */
name|svn_boolean_t
name|skip_this
decl_stmt|;
comment|/* Set if there was a previous notification for this directory */
name|svn_boolean_t
name|already_notified
decl_stmt|;
comment|/* Set if this directory is being added during this editor drive. */
name|svn_boolean_t
name|adding_dir
decl_stmt|;
comment|/* Set on a node and its descendants are not present in the working copy      but should still be updated (not skipped). These nodes should all be      marked as deleted. */
name|svn_boolean_t
name|shadowed
decl_stmt|;
comment|/* Set on a node when the existing node is obstructed, and the edit operation      continues as semi-shadowed update */
name|svn_boolean_t
name|edit_obstructed
decl_stmt|;
comment|/* The (new) changed_* information, cached to avoid retrieving it later */
name|svn_revnum_t
name|changed_rev
decl_stmt|;
name|apr_time_t
name|changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|changed_author
decl_stmt|;
comment|/* If not NULL, contains a mapping of const char* basenames of children that      have been deleted to their svn_skel_t* tree conflicts.      We store this hash to allow replacements to continue under a just      installed tree conflict.       The add after the delete will then update the tree conflicts information      and reinstall it. */
name|apr_hash_t
modifier|*
name|deletion_conflicts
decl_stmt|;
comment|/* A hash of file names (only the hash key matters) seen by add_file      and not yet added to the database by close_file. */
name|apr_hash_t
modifier|*
name|not_present_files
decl_stmt|;
comment|/* Set if an unversioned dir of the same name already existed in      this directory. */
name|svn_boolean_t
name|obstruction_found
decl_stmt|;
comment|/* Set if a dir of the same name already exists and is      scheduled for addition without history. */
name|svn_boolean_t
name|add_existed
decl_stmt|;
comment|/* An array of svn_prop_t structures, representing all the property      changes to be applied to this directory. */
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|;
comment|/* A boolean indicating whether this node or one of its children has      received any 'real' changes. Used to avoid tree conflicts for simple      entryprop changes, like lock management */
name|svn_boolean_t
name|edited
decl_stmt|;
comment|/* The tree conflict to install once the node is really edited */
name|svn_skel_t
modifier|*
name|edit_conflict
decl_stmt|;
comment|/* The bump information for this directory. */
name|struct
name|bump_dir_info
modifier|*
name|bump_info
decl_stmt|;
comment|/* The depth of the directory in the wc (or inferred if added).  Not      used for filtering; we have a separate wrapping editor for that. */
name|svn_depth_t
name|ambient_depth
decl_stmt|;
comment|/* Was the directory marked as incomplete before the update?      (In other words, are we resuming an interrupted update?)       If WAS_INCOMPLETE is set to TRUE we expect to receive all child nodes      and properties for/of the directory. If WAS_INCOMPLETE is FALSE then      we only receive the changes in/for children and properties.*/
name|svn_boolean_t
name|was_incomplete
decl_stmt|;
comment|/* The pool in which this baton itself is allocated. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* how many nodes are referring to baton? */
name|int
name|ref_count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|handler_baton
block|{
name|svn_txdelta_window_handler_t
name|apply_handler
decl_stmt|;
name|void
modifier|*
name|apply_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
decl_stmt|;
comment|/* Where we are assembling the new file. */
specifier|const
name|char
modifier|*
name|new_text_base_tmp_abspath
decl_stmt|;
comment|/* The expected source checksum of the text source or NULL if no base      checksum is available (MD5 if the server provides a checksum, SHA1 if      the server doesn't) */
name|svn_checksum_t
modifier|*
name|expected_source_checksum
decl_stmt|;
comment|/* Why two checksums?      The editor currently provides an md5 which we use to detect corruption      during transmission.  We use the sha1 inside libsvn_wc both for pristine      handling and corruption detection.  In the future, the editor will also      provide a sha1, so we may not have to calculate both, but for the time      being, that's the way it is. */
comment|/* The calculated checksum of the text source or NULL if the acual      checksum is not being calculated. The checksum kind is identical to the      kind of expected_source_checksum. */
name|svn_checksum_t
modifier|*
name|actual_source_checksum
decl_stmt|;
comment|/* The stream used to calculate the source checksums */
name|svn_stream_t
modifier|*
name|source_checksum_stream
decl_stmt|;
comment|/* A calculated MD5 digest of NEW_TEXT_BASE_TMP_ABSPATH.      This is initialized to all zeroes when the baton is created, then      populated with the MD5 digest of the resultant fulltext after the      last window is handled by the handler returned from      apply_textdelta(). */
name|unsigned
name|char
name|new_text_base_md5_digest
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
comment|/* A calculated SHA-1 of NEW_TEXT_BASE_TMP_ABSPATH, which we'll use for      eventually writing the pristine. */
name|svn_checksum_t
modifier|*
name|new_text_base_sha1_checksum
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get an empty file in the temporary area for WRI_ABSPATH.  The file will    not be set for automatic deletion, and the name will be returned in    TMP_FILENAME.     This implementation creates a new empty file with a unique name.     ### This is inefficient for callers that just want an empty file to read    ### from.  There could be (and there used to be) a permanent, shared    ### empty file for this purpose.     ### This is inefficient for callers that just want to reserve a unique    ### file name to create later.  A better way may not be readily available.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_empty_tmp_file
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|tmp_filename
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|temp_dir_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|temp_dir_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
name|tmp_filename
argument_list|,
name|temp_dir_abspath
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An APR pool cleanup handler.  This runs the working queue for an    editor baton. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|cleanup_edit_baton
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|apr_pool_parent_get
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
decl_stmt|;
name|err
operator|=
name|svn_wc__wq_run
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|wcroot_abspath
argument_list|,
name|NULL
comment|/* cancel_func */
argument_list|,
name|NULL
comment|/* cancel_baton */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|apr_status_t
name|apr_err
init|=
name|err
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|apr_err
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Make a new dir baton in a subpool of PB->pool. PB is the parent baton.    If PATH and PB are NULL, this is the root directory of the edit; in this    case, make the new dir baton in a subpool of EB->pool.    ADDING should be TRUE if we are adding this directory.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_dir_baton
parameter_list|(
name|struct
name|dir_baton
modifier|*
modifier|*
name|d_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|pb
parameter_list|,
name|svn_boolean_t
name|adding
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|dir_pool
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|pb
operator|!=
name|NULL
condition|)
name|dir_pool
operator|=
name|svn_pool_create
argument_list|(
name|pb
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
name|dir_pool
operator|=
name|svn_pool_create
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|path
operator|||
operator|(
operator|!
name|pb
operator|)
argument_list|)
expr_stmt|;
comment|/* Okay, no easy out, so allocate and initialize a dir baton. */
name|d
operator|=
name|apr_pcalloc
argument_list|(
name|dir_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Construct the PATH and baseNAME of this directory. */
if|if
condition|(
name|path
condition|)
block|{
name|d
operator|->
name|name
operator|=
name|svn_dirent_basename
argument_list|(
name|path
argument_list|,
name|dir_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|path_join_under_root
argument_list|(
operator|&
name|d
operator|->
name|local_abspath
argument_list|,
name|pb
operator|->
name|local_abspath
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|dir_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is the root baton. */
name|d
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|local_abspath
operator|=
name|eb
operator|->
name|anchor_abspath
expr_stmt|;
block|}
comment|/* Figure out the new_relpath for this directory. */
if|if
condition|(
name|eb
operator|->
name|switch_relpath
condition|)
block|{
comment|/* Handle switches... */
if|if
condition|(
name|pb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|eb
operator|->
name|target_basename
operator|==
literal|'\0'
condition|)
block|{
comment|/* No parent baton and target_basename=="" means that we are                  the target of the switch. Thus, our NEW_RELPATH will be                  the SWITCH_RELPATH.  */
name|d
operator|->
name|new_relpath
operator|=
name|eb
operator|->
name|switch_relpath
expr_stmt|;
block|}
else|else
block|{
comment|/* This node is NOT the target of the switch (one of our                  children is the target); therefore, it must already exist.                  Get its old REPOS_RELPATH, as it won't be changing.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
operator|&
name|d
operator|->
name|new_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|d
operator|->
name|local_abspath
argument_list|,
name|dir_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This directory is *not* the root (has a parent). If there is              no grandparent, then we may have anchored at the parent,              and self is the target. If we match the target, then set              NEW_RELPATH to the SWITCH_RELPATH.               Otherwise, we simply extend NEW_RELPATH from the parent.  */
if|if
condition|(
name|pb
operator|->
name|parent_baton
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|eb
operator|->
name|target_basename
argument_list|,
name|d
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|d
operator|->
name|new_relpath
operator|=
name|eb
operator|->
name|switch_relpath
expr_stmt|;
else|else
name|d
operator|->
name|new_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|new_relpath
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|dir_pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* must be an update */
block|{
comment|/* If we are adding the node, then simply extend the parent's          relpath for our own.  */
if|if
condition|(
name|adding
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|pb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|d
operator|->
name|new_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|new_relpath
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|dir_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
operator|&
name|d
operator|->
name|new_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|d
operator|->
name|local_abspath
argument_list|,
name|dir_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|d
operator|->
name|new_relpath
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
name|d
operator|->
name|parent_baton
operator|=
name|pb
expr_stmt|;
name|d
operator|->
name|pool
operator|=
name|dir_pool
expr_stmt|;
name|d
operator|->
name|propchanges
operator|=
name|apr_array_make
argument_list|(
name|dir_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|obstruction_found
operator|=
name|FALSE
expr_stmt|;
name|d
operator|->
name|add_existed
operator|=
name|FALSE
expr_stmt|;
name|d
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|old_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|d
operator|->
name|adding_dir
operator|=
name|adding
expr_stmt|;
name|d
operator|->
name|changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|d
operator|->
name|not_present_files
operator|=
name|apr_hash_make
argument_list|(
name|dir_pool
argument_list|)
expr_stmt|;
comment|/* Copy some flags from the parent baton */
if|if
condition|(
name|pb
condition|)
block|{
name|d
operator|->
name|skip_this
operator|=
name|pb
operator|->
name|skip_this
expr_stmt|;
name|d
operator|->
name|shadowed
operator|=
name|pb
operator|->
name|shadowed
operator|||
name|pb
operator|->
name|edit_obstructed
expr_stmt|;
comment|/* the parent's bump info has one more referer */
name|pb
operator|->
name|ref_count
operator|++
expr_stmt|;
block|}
comment|/* The caller of this function needs to fill these in. */
name|d
operator|->
name|ambient_depth
operator|=
name|svn_depth_unknown
expr_stmt|;
name|d
operator|->
name|was_incomplete
operator|=
name|FALSE
expr_stmt|;
operator|*
name|d_p
operator|=
name|d
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Forward declarations. */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|already_in_a_tree_conflict
parameter_list|(
name|svn_boolean_t
modifier|*
name|conflicted
parameter_list|,
name|svn_boolean_t
modifier|*
name|ignored
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|do_notification
parameter_list|(
specifier|const
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_wc_notify_action_t
name|action
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
if|if
condition|(
name|eb
operator|->
name|notify_func
operator|==
name|NULL
condition|)
return|return;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|action
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
call|(
modifier|*
name|eb
operator|->
name|notify_func
call|)
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decrement the directory's reference count. If it hits zero,    then this directory is "done". This means it is safe to clear its pool.     In addition, when the directory is "done", we recurse to possible cleanup    the parent directory. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_release_dir_info
parameter_list|(
name|struct
name|dir_baton
modifier|*
name|db
parameter_list|)
block|{
name|db
operator|->
name|ref_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|db
operator|->
name|ref_count
condition|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|db
operator|->
name|parent_baton
decl_stmt|;
name|svn_pool_destroy
argument_list|(
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
condition|)
name|SVN_ERR
argument_list|(
name|maybe_release_dir_info
argument_list|(
name|pb
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Per file baton. Lives in its own subpool below the pool of the parent    directory */
end_comment

begin_struct
struct|struct
name|file_baton
block|{
comment|/* Pool specific to this file_baton. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Name of this file (its entry in the directory). */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Absolute path to this file */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* The repository relative path this file will correspond to. */
specifier|const
name|char
modifier|*
name|new_relpath
decl_stmt|;
comment|/* The revision of the file before updating */
name|svn_revnum_t
name|old_revision
decl_stmt|;
comment|/* The repos_relpath before updating/switching */
specifier|const
name|char
modifier|*
name|old_repos_relpath
decl_stmt|;
comment|/* The global edit baton. */
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
comment|/* The parent directory of this file. */
name|struct
name|dir_baton
modifier|*
name|dir_baton
decl_stmt|;
comment|/* Set if updates to this directory are skipped */
name|svn_boolean_t
name|skip_this
decl_stmt|;
comment|/* Set if there was a previous notification  */
name|svn_boolean_t
name|already_notified
decl_stmt|;
comment|/* Set if this file is new. */
name|svn_boolean_t
name|adding_file
decl_stmt|;
comment|/* Set if an unversioned file of the same name already existed in      this directory. */
name|svn_boolean_t
name|obstruction_found
decl_stmt|;
comment|/* Set if a file of the same name already exists and is      scheduled for addition without history. */
name|svn_boolean_t
name|add_existed
decl_stmt|;
comment|/* Set if this file is being added in the BASE layer, but is not-present      in the working copy (replaced, deleted, etc.). */
name|svn_boolean_t
name|shadowed
decl_stmt|;
comment|/* Set on a node when the existing node is obstructed, and the edit operation      continues as semi-shadowed update */
name|svn_boolean_t
name|edit_obstructed
decl_stmt|;
comment|/* The (new) changed_* information, cached to avoid retrieving it later */
name|svn_revnum_t
name|changed_rev
decl_stmt|;
name|apr_time_t
name|changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|changed_author
decl_stmt|;
comment|/* If there are file content changes, these are the checksums of the      resulting new text base, which is in the pristine store, else NULL. */
specifier|const
name|svn_checksum_t
modifier|*
name|new_text_base_md5_checksum
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|new_text_base_sha1_checksum
decl_stmt|;
comment|/* The checksum of the file before the update */
specifier|const
name|svn_checksum_t
modifier|*
name|original_checksum
decl_stmt|;
comment|/* An array of svn_prop_t structures, representing all the property      changes to be applied to this file.  Once a file baton is      initialized, this is never NULL, but it may have zero elements.  */
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|;
comment|/* For existing files, whether there are local modifications. FALSE for added      files */
name|svn_boolean_t
name|local_prop_mods
decl_stmt|;
comment|/* Bump information for the directory this file lives in */
name|struct
name|bump_dir_info
modifier|*
name|bump_info
decl_stmt|;
comment|/* A boolean indicating whether this node or one of its children has      received any 'real' changes. Used to avoid tree conflicts for simple      entryprop changes, like lock management */
name|svn_boolean_t
name|edited
decl_stmt|;
comment|/* The tree conflict to install once the node is really edited */
name|svn_skel_t
modifier|*
name|edit_conflict
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make a new file baton in a subpool of PB->pool. PB is the parent baton.  * PATH is relative to the root of the edit. ADDING tells whether this file  * is being added. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_file_baton
parameter_list|(
name|struct
name|file_baton
modifier|*
modifier|*
name|f_p
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|pb
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|adding
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|file_pool
init|=
name|svn_pool_create
argument_list|(
name|pb
operator|->
name|pool
argument_list|)
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|f
init|=
name|apr_pcalloc
argument_list|(
name|file_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* Make the file's on-disk name. */
name|f
operator|->
name|name
operator|=
name|svn_dirent_basename
argument_list|(
name|path
argument_list|,
name|file_pool
argument_list|)
expr_stmt|;
name|f
operator|->
name|old_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|SVN_ERR
argument_list|(
name|path_join_under_root
argument_list|(
operator|&
name|f
operator|->
name|local_abspath
argument_list|,
name|pb
operator|->
name|local_abspath
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|file_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Figure out the new URL for this file. */
if|if
condition|(
name|eb
operator|->
name|switch_relpath
condition|)
block|{
comment|/* Handle switches... */
comment|/* This file has a parent directory. If there is          no grandparent, then we may have anchored at the parent,          and self is the target. If we match the target, then set          NEW_RELPATH to the SWITCH_RELPATH.           Otherwise, we simply extend NEW_RELPATH from the parent.  */
if|if
condition|(
name|pb
operator|->
name|parent_baton
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|eb
operator|->
name|target_basename
argument_list|,
name|f
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|f
operator|->
name|new_relpath
operator|=
name|eb
operator|->
name|switch_relpath
expr_stmt|;
else|else
name|f
operator|->
name|new_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|new_relpath
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|file_pool
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* must be an update */
block|{
if|if
condition|(
name|adding
condition|)
name|f
operator|->
name|new_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|new_relpath
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|file_pool
argument_list|)
expr_stmt|;
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
operator|&
name|f
operator|->
name|new_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|f
operator|->
name|local_abspath
argument_list|,
name|file_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|f
operator|->
name|new_relpath
argument_list|)
expr_stmt|;
block|}
block|}
name|f
operator|->
name|pool
operator|=
name|file_pool
expr_stmt|;
name|f
operator|->
name|edit_baton
operator|=
name|pb
operator|->
name|edit_baton
expr_stmt|;
name|f
operator|->
name|propchanges
operator|=
name|apr_array_make
argument_list|(
name|file_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|bump_info
operator|=
name|pb
operator|->
name|bump_info
expr_stmt|;
name|f
operator|->
name|adding_file
operator|=
name|adding
expr_stmt|;
name|f
operator|->
name|obstruction_found
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|add_existed
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|skip_this
operator|=
name|pb
operator|->
name|skip_this
expr_stmt|;
name|f
operator|->
name|shadowed
operator|=
name|pb
operator|->
name|shadowed
operator|||
name|pb
operator|->
name|edit_obstructed
expr_stmt|;
name|f
operator|->
name|dir_baton
operator|=
name|pb
expr_stmt|;
name|f
operator|->
name|changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* the directory has one more referer now */
name|pb
operator|->
name|ref_count
operator|++
expr_stmt|;
operator|*
name|f_p
operator|=
name|f
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Complete a conflict skel by describing the update.  *  * LOCAL_KIND is the node kind of the tree conflict victim in the  * working copy.  *  * All temporary allocations are be made in SCRATCH_POOL, while allocations  * needed for the returned conflict struct are made in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|complete_conflict
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict
parameter_list|,
specifier|const
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|old_repos_relpath
parameter_list|,
name|svn_revnum_t
name|old_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|new_repos_relpath
parameter_list|,
name|svn_node_kind_t
name|local_kind
parameter_list|,
name|svn_node_kind_t
name|target_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_conflict_version_t
modifier|*
name|original_version
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|target_version
decl_stmt|;
name|svn_boolean_t
name|is_complete
decl_stmt|;
if|if
condition|(
operator|!
name|conflict
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Not conflicted */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_is_complete
argument_list|(
operator|&
name|is_complete
argument_list|,
name|conflict
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_complete
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Already completed */
if|if
condition|(
name|old_repos_relpath
condition|)
name|original_version
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
name|old_repos_relpath
argument_list|,
name|old_revision
argument_list|,
name|local_kind
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|original_version
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|new_repos_relpath
condition|)
name|target_version
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
name|new_repos_relpath
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|target_kind
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|target_version
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|switch_relpath
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_switch
argument_list|(
name|conflict
argument_list|,
name|original_version
argument_list|,
name|target_version
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_update
argument_list|(
name|conflict
argument_list|,
name|original_version
argument_list|,
name|target_version
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Called when a directory is really edited, to avoid marking a    tree conflict on a node for a no-change edit */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_directory_edited
parameter_list|(
name|struct
name|dir_baton
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|db
operator|->
name|edited
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|db
operator|->
name|parent_baton
condition|)
name|SVN_ERR
argument_list|(
name|mark_directory_edited
argument_list|(
name|db
operator|->
name|parent_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|edited
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|edit_conflict
condition|)
block|{
comment|/* We have a (delayed) tree conflict to install */
name|SVN_ERR
argument_list|(
name|complete_conflict
argument_list|(
name|db
operator|->
name|edit_conflict
argument_list|,
name|db
operator|->
name|edit_baton
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|old_repos_relpath
argument_list|,
name|db
operator|->
name|old_revision
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_node_dir
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_conflict
argument_list|(
name|db
operator|->
name|edit_baton
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|edit_conflict
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|do_notification
argument_list|(
name|db
operator|->
name|edit_baton
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|db
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Called when a file is really edited, to avoid marking a    tree conflict on a node for a no-change edit */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_file_edited
parameter_list|(
name|struct
name|file_baton
modifier|*
name|fb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|fb
operator|->
name|edited
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|mark_directory_edited
argument_list|(
name|fb
operator|->
name|dir_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|edited
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|edit_conflict
condition|)
block|{
comment|/* We have a (delayed) tree conflict to install */
name|SVN_ERR
argument_list|(
name|complete_conflict
argument_list|(
name|fb
operator|->
name|edit_conflict
argument_list|,
name|fb
operator|->
name|edit_baton
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|old_repos_relpath
argument_list|,
name|fb
operator|->
name|old_revision
argument_list|,
name|fb
operator|->
name|new_relpath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_node_file
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_conflict
argument_list|(
name|fb
operator|->
name|edit_baton
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|edit_conflict
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|do_notification
argument_list|(
name|fb
operator|->
name|edit_baton
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|fb
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handle the next delta window of the file described by BATON.  If it is  * the end (WINDOW == NULL), then check the checksum, store the text in the  * pristine store and write its details into BATON->fb->new_text_base_*. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_handler
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|handler_baton
modifier|*
name|hb
init|=
name|baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|hb
operator|->
name|fb
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
init|=
name|fb
operator|->
name|edit_baton
operator|->
name|db
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Apply this window.  We may be done at that point.  */
name|err
operator|=
name|hb
operator|->
name|apply_handler
argument_list|(
name|window
argument_list|,
name|hb
operator|->
name|apply_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|!=
name|NULL
operator|&&
operator|!
name|err
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|hb
operator|->
name|expected_source_checksum
condition|)
block|{
comment|/* Close the stream to calculate HB->actual_source_md5_checksum. */
name|svn_error_t
modifier|*
name|err2
init|=
name|svn_stream_close
argument_list|(
name|hb
operator|->
name|source_checksum_stream
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err2
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|hb
operator|->
name|expected_source_checksum
operator|->
name|kind
operator|==
name|hb
operator|->
name|actual_source_checksum
operator|->
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|hb
operator|->
name|expected_source_checksum
argument_list|,
name|hb
operator|->
name|actual_source_checksum
argument_list|)
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT_TEXT_BASE
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch while updating '%s':\n"
literal|"   expected:  %s\n"
literal|"     actual:  %s\n"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fb
operator|->
name|local_abspath
argument_list|,
name|hb
operator|->
name|pool
argument_list|)
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|hb
operator|->
name|expected_source_checksum
argument_list|,
name|hb
operator|->
name|pool
argument_list|)
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|hb
operator|->
name|actual_source_checksum
argument_list|,
name|hb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* We failed to apply the delta; clean up the temporary file.  */
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|hb
operator|->
name|new_text_base_tmp_abspath
argument_list|,
name|TRUE
argument_list|,
name|hb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Tell the file baton about the new text base's checksums. */
name|fb
operator|->
name|new_text_base_md5_checksum
operator|=
name|svn_checksum__from_digest_md5
argument_list|(
name|hb
operator|->
name|new_text_base_md5_digest
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|fb
operator|->
name|new_text_base_sha1_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|hb
operator|->
name|new_text_base_sha1_checksum
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Store the new pristine text in the pristine store now.  Later, in a          single transaction we will update the BASE_NODE to include a          reference to this pristine text's checksum. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_install
argument_list|(
name|db
argument_list|,
name|hb
operator|->
name|new_text_base_tmp_abspath
argument_list|,
name|fb
operator|->
name|new_text_base_sha1_checksum
argument_list|,
name|fb
operator|->
name|new_text_base_md5_checksum
argument_list|,
name|hb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|hb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Find the last-change info within ENTRY_PROPS, and return then in the    CHANGED_* parameters. Each parameter will be initialized to its "none"    value, and will contain the relavent info if found.     CHANGED_AUTHOR will be allocated in RESULT_POOL. SCRATCH_POOL will be    used for some temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|accumulate_last_change
parameter_list|(
name|svn_revnum_t
modifier|*
name|changed_rev
parameter_list|,
name|apr_time_t
modifier|*
name|changed_date
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|changed_author
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|entry_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
operator|*
name|changed_date
operator|=
literal|0
expr_stmt|;
operator|*
name|changed_author
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry_props
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entry_props
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
comment|/* A prop value of NULL means the information was not          available.  We don't remove this field from the entries          file; we have convention just leave it empty.  So let's          just skip those entry props that have no values. */
if|if
condition|(
operator|!
name|prop
operator|->
name|value
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|)
condition|)
operator|*
name|changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|prop
operator|->
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|)
condition|)
block|{
name|apr_int64_t
name|rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|rev
argument_list|,
name|prop
operator|->
name|value
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|changed_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|rev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
name|changed_date
argument_list|,
name|prop
operator|->
name|value
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Starting with Subversion 1.7 we ignore the SVN_PROP_ENTRY_UUID          property here. */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Join ADD_PATH to BASE_PATH.  If ADD_PATH is absolute, or if any ".."  * component of it resolves to a path above BASE_PATH, then return  * SVN_ERR_WC_OBSTRUCTED_UPDATE.  *  * This is to prevent the situation where the repository contains,  * say, "..\nastyfile".  Although that's perfectly legal on some  * systems, when checked out onto Win32 it would cause "nastyfile" to  * be created in the parent of the current edit directory.  *  * (http://cve.mitre.org/cgi-bin/cvename.cgi?name=2007-3846)  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|path_join_under_root
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result_path
parameter_list|,
specifier|const
name|char
modifier|*
name|base_path
parameter_list|,
specifier|const
name|char
modifier|*
name|add_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|under_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_is_under_root
argument_list|(
operator|&
name|under_root
argument_list|,
name|result_path
argument_list|,
name|base_path
argument_list|,
name|add_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|under_root
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not in the working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|svn_dirent_join
argument_list|(
name|base_path
argument_list|,
name|add_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* This catches issue #3288 */
if|if
condition|(
name|strcmp
argument_list|(
name|add_path
argument_list|,
name|svn_dirent_basename
argument_list|(
operator|*
name|result_path
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not valid as filename in directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|add_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|base_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** The callbacks we'll plug into an svn_delta_editor_t structure. ***/
end_comment

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_target_revision
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
operator|*
operator|(
name|eb
operator|->
name|target_revision
operator|)
operator|=
name|target_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|check_tree_conflict
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|pconflict
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc__db_status_t
name|working_status
parameter_list|,
name|svn_boolean_t
name|exists_in_repos
parameter_list|,
name|svn_node_kind_t
name|expected_kind
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
comment|/* This is ignored in co */
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|db
decl_stmt|;
name|svn_boolean_t
name|already_conflicted
decl_stmt|,
name|conflict_ignored
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_wc__db_status_t
name|base_status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|have_work
decl_stmt|;
comment|/* Note that something interesting is actually happening in this      edit run. */
name|eb
operator|->
name|root_opened
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_dir_baton
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
argument_list|,
name|eb
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dir_baton
operator|=
name|db
expr_stmt|;
name|err
operator|=
name|already_in_a_tree_conflict
argument_list|(
operator|&
name|already_conflicted
argument_list|,
operator|&
name|conflict_ignored
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|already_conflicted
operator|=
name|conflict_ignored
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|already_conflicted
condition|)
block|{
comment|/* Record a skip of both the anchor and target in the skipped tree          as the anchor itself might not be updated */
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
comment|/* Notify that we skipped the target, while we actually skipped          the anchor */
name|do_notification
argument_list|(
name|eb
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_wc_notify_skip_conflicted
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|db
operator|->
name|old_revision
argument_list|,
operator|&
name|db
operator|->
name|old_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|db
operator|->
name|changed_rev
argument_list|,
operator|&
name|db
operator|->
name|changed_date
argument_list|,
operator|&
name|db
operator|->
name|changed_author
argument_list|,
operator|&
name|db
operator|->
name|ambient_depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|have_work
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_ignored
condition|)
block|{
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_work
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_src_root_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_moved_to
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|move_src_root_abspath
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_src_root_abspath
operator|||
operator|*
name|eb
operator|->
name|target_basename
operator|==
literal|'\0'
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info
argument_list|(
operator|&
name|base_status
argument_list|,
name|NULL
argument_list|,
operator|&
name|db
operator|->
name|old_revision
argument_list|,
operator|&
name|db
operator|->
name|old_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|db
operator|->
name|changed_rev
argument_list|,
operator|&
name|db
operator|->
name|changed_date
argument_list|,
operator|&
name|db
operator|->
name|changed_author
argument_list|,
operator|&
name|db
operator|->
name|ambient_depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_src_root_abspath
condition|)
block|{
comment|/* This is an update anchored inside a move. We need to              raise a move-edit tree-conflict on the move root to              update the move destination. */
name|svn_skel_t
modifier|*
name|tree_conflict
init|=
name|svn_wc__conflict_skel_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_tree_conflict
argument_list|(
name|tree_conflict
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|move_src_root_abspath
argument_list|,
name|svn_wc_conflict_reason_moved_away
argument_list|,
name|svn_wc_conflict_action_edit
argument_list|,
name|move_src_root_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|db
operator|->
name|local_abspath
argument_list|,
name|move_src_root_abspath
argument_list|)
condition|)
block|{
comment|/* We are raising the tree-conflict on some parent of                  the edit root, we won't be handling that path again                  so raise the conflict now. */
name|SVN_ERR
argument_list|(
name|complete_conflict
argument_list|(
name|tree_conflict
argument_list|,
name|eb
argument_list|,
name|move_src_root_abspath
argument_list|,
name|db
operator|->
name|old_repos_relpath
argument_list|,
name|db
operator|->
name|old_revision
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_node_dir
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_conflict
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|move_src_root_abspath
argument_list|,
name|tree_conflict
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|move_src_root_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
name|db
operator|->
name|edit_conflict
operator|=
name|tree_conflict
expr_stmt|;
block|}
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
comment|/* Needed for the close_directory() on the root, to                               make sure it doesn't use the ACTUAL tree */
block|}
else|else
name|base_status
operator|=
name|status
expr_stmt|;
if|if
condition|(
operator|*
name|eb
operator|->
name|target_basename
operator|==
literal|'\0'
condition|)
block|{
comment|/* For an update with a NULL target, this is equivalent to open_dir(): */
name|db
operator|->
name|was_incomplete
operator|=
operator|(
name|base_status
operator|==
name|svn_wc__db_status_incomplete
operator|)
expr_stmt|;
comment|/* ### TODO: Add some tree conflict and obstruction detection, etc. like                    open_directory() does.                    (or find a way to reuse that code here)           ### BH 2013: I don't think we need all of the detection here, as the                       user explicitly asked to update this node. So we don't                       have to tell that it is a local replacement/delete.        */
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_op_start_directory_update
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ===================================================================== */
end_comment

begin_comment
comment|/* Checking for local modifications. */
end_comment

begin_comment
comment|/* A baton for use with modcheck_found_entry(). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|modcheck_baton_t
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
comment|/* wc_db to access nodes */
name|svn_boolean_t
name|found_mod
decl_stmt|;
comment|/* whether a modification has been found */
name|svn_boolean_t
name|found_not_delete
decl_stmt|;
comment|/* Found a not-delete modification */
block|}
name|modcheck_baton_t
typedef|;
end_typedef

begin_comment
comment|/* An implementation of svn_wc_status_func4_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|modcheck_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|modcheck_baton_t
modifier|*
name|mb
init|=
name|baton
decl_stmt|;
switch|switch
condition|(
name|status
operator|->
name|node_status
condition|)
block|{
case|case
name|svn_wc_status_normal
case|:
case|case
name|svn_wc_status_incomplete
case|:
case|case
name|svn_wc_status_ignored
case|:
case|case
name|svn_wc_status_none
case|:
case|case
name|svn_wc_status_unversioned
case|:
case|case
name|svn_wc_status_external
case|:
break|break;
case|case
name|svn_wc_status_deleted
case|:
name|mb
operator|->
name|found_mod
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_wc_status_missing
case|:
case|case
name|svn_wc_status_obstructed
case|:
name|mb
operator|->
name|found_mod
operator|=
name|TRUE
expr_stmt|;
name|mb
operator|->
name|found_not_delete
operator|=
name|TRUE
expr_stmt|;
comment|/* Exit from the status walker: We know what we want to know */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CEASE_INVOCATION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
default|default:
case|case
name|svn_wc_status_added
case|:
case|case
name|svn_wc_status_replaced
case|:
case|case
name|svn_wc_status_modified
case|:
name|mb
operator|->
name|found_mod
operator|=
name|TRUE
expr_stmt|;
name|mb
operator|->
name|found_not_delete
operator|=
name|TRUE
expr_stmt|;
comment|/* Exit from the status walker: We know what we want to know */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CEASE_INVOCATION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *MODIFIED to true iff there are any local modifications within the  * tree rooted at LOCAL_ABSPATH, using DB. If *MODIFIED  * is set to true and all the local modifications were deletes then set  * *ALL_EDITS_ARE_DELETES to true, set it to false otherwise.  LOCAL_ABSPATH  * may be a file or a directory. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__node_has_local_mods
parameter_list|(
name|svn_boolean_t
modifier|*
name|modified
parameter_list|,
name|svn_boolean_t
modifier|*
name|all_edits_are_deletes
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|modcheck_baton_t
name|modcheck_baton
init|=
block|{
name|NULL
block|,
name|FALSE
block|,
name|FALSE
block|}
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|modcheck_baton
operator|.
name|db
operator|=
name|db
expr_stmt|;
comment|/* Walk the WC tree for status with depth infinity, looking for any local    * modifications. If it's a "sparse" directory, that's OK: there can be    * no local mods in the pieces that aren't present in the WC. */
name|err
operator|=
name|svn_wc__internal_walk_status
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|modcheck_callback
argument_list|,
operator|&
name|modcheck_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CEASE_INVOCATION
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|modified
operator|=
name|modcheck_baton
operator|.
name|found_mod
expr_stmt|;
operator|*
name|all_edits_are_deletes
operator|=
operator|(
name|modcheck_baton
operator|.
name|found_mod
operator|&&
operator|!
name|modcheck_baton
operator|.
name|found_not_delete
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Indicates an unset svn_wc_conflict_reason_t. */
end_comment

begin_define
define|#
directive|define
name|SVN_WC_CONFLICT_REASON_NONE
value|(svn_wc_conflict_reason_t)(-1)
end_define

begin_comment
comment|/* Check whether the incoming change ACTION on FULL_PATH would conflict with  * LOCAL_ABSPATH's scheduled change. If so, then raise a tree conflict with  * LOCAL_ABSPATH as the victim.  *  * The edit baton EB gives information including whether the operation is  * an update or a switch.  *  * WORKING_STATUS is the current node status of LOCAL_ABSPATH  * and EXISTS_IN_REPOS specifies whether a BASE_NODE representation for exists  * for this node. In that case the on disk type is compared to EXPECTED_KIND.  *  * If a tree conflict reason was found for the incoming action, the resulting  * tree conflict info is returned in *PCONFLICT. PCONFLICT must be non-NULL,  * while *PCONFLICT is always overwritten.  *  * The tree conflict is allocated in RESULT_POOL. Temporary allocations use  * SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_tree_conflict
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|pconflict
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc__db_status_t
name|working_status
parameter_list|,
name|svn_boolean_t
name|exists_in_repos
parameter_list|,
name|svn_node_kind_t
name|expected_kind
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_conflict_reason_t
name|reason
init|=
name|SVN_WC_CONFLICT_REASON_NONE
decl_stmt|;
name|svn_boolean_t
name|modified
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|all_mods_are_deletes
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|move_src_op_root_abspath
init|=
name|NULL
decl_stmt|;
operator|*
name|pconflict
operator|=
name|NULL
expr_stmt|;
comment|/* Find out if there are any local changes to this node that may    * be the "reason" of a tree-conflict with the incoming "action". */
switch|switch
condition|(
name|working_status
condition|)
block|{
case|case
name|svn_wc__db_status_added
case|:
case|case
name|svn_wc__db_status_moved_here
case|:
case|case
name|svn_wc__db_status_copied
case|:
if|if
condition|(
operator|!
name|exists_in_repos
condition|)
block|{
comment|/* The node is locally added, and it did not exist before.  This              * is an 'update', so the local add can only conflict with an              * incoming 'add'.  In fact, if we receive anything else than an              * svn_wc_conflict_action_add (which includes 'added',              * 'copied-here' and 'moved-here') during update on a node that              * did not exist before, then something is very wrong.              * Note that if there was no action on the node, this code              * would not have been called in the first place. */
name|SVN_ERR_ASSERT
argument_list|(
name|action
operator|==
name|svn_wc_conflict_action_add
argument_list|)
expr_stmt|;
comment|/* Scan the addition in case our caller didn't. */
if|if
condition|(
name|working_status
operator|==
name|svn_wc__db_status_added
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
operator|&
name|working_status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|working_status
operator|==
name|svn_wc__db_status_moved_here
condition|)
name|reason
operator|=
name|svn_wc_conflict_reason_moved_here
expr_stmt|;
else|else
name|reason
operator|=
name|svn_wc_conflict_reason_added
expr_stmt|;
block|}
else|else
block|{
comment|/* The node is locally replaced but could also be moved-away. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_moved_to
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|move_src_op_root_abspath
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_src_op_root_abspath
condition|)
name|reason
operator|=
name|svn_wc_conflict_reason_moved_away
expr_stmt|;
else|else
name|reason
operator|=
name|svn_wc_conflict_reason_replaced
expr_stmt|;
block|}
break|break;
case|case
name|svn_wc__db_status_deleted
case|:
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_moved_to
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|move_src_op_root_abspath
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_src_op_root_abspath
condition|)
name|reason
operator|=
name|svn_wc_conflict_reason_moved_away
expr_stmt|;
else|else
name|reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
block|}
break|break;
case|case
name|svn_wc__db_status_incomplete
case|:
comment|/* We used svn_wc__db_read_info(), so 'incomplete' means          * - there is no node in the WORKING tree          * - a BASE node is known to exist          * So the node exists and is essentially 'normal'. We still need to          * check prop and text mods, and those checks will retrieve the          * missing information (hopefully). */
case|case
name|svn_wc__db_status_normal
case|:
if|if
condition|(
name|action
operator|==
name|svn_wc_conflict_action_edit
condition|)
block|{
comment|/* An edit onto a local edit or onto *no* local changes is no              * tree-conflict. (It's possibly a text- or prop-conflict,              * but we don't handle those here.)              *              * Except when there is a local obstruction              */
if|if
condition|(
name|exists_in_repos
condition|)
block|{
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|!=
name|expected_kind
operator|&&
name|disk_kind
operator|!=
name|svn_node_none
condition|)
block|{
name|reason
operator|=
name|svn_wc_conflict_reason_obstructed
expr_stmt|;
break|break;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Replace is handled as delete and then specifically in            add_directory() and add_file(), so we only expect deletes here */
name|SVN_ERR_ASSERT
argument_list|(
name|action
operator|==
name|svn_wc_conflict_action_delete
argument_list|)
expr_stmt|;
comment|/* Check if the update wants to delete or replace a locally          * modified node. */
comment|/* Do a deep tree detection of local changes. The update editor will          * not visit the subdirectories of a directory that it wants to delete.          * Therefore, we need to start a separate crawl here. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_has_local_mods
argument_list|(
operator|&
name|modified
argument_list|,
operator|&
name|all_mods_are_deletes
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified
condition|)
block|{
if|if
condition|(
name|all_mods_are_deletes
condition|)
name|reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
else|else
name|reason
operator|=
name|svn_wc_conflict_reason_edited
expr_stmt|;
block|}
break|break;
case|case
name|svn_wc__db_status_server_excluded
case|:
comment|/* Not allowed to view the node. Not allowed to report tree          * conflicts. */
case|case
name|svn_wc__db_status_excluded
case|:
comment|/* Locally marked as excluded. No conflicts wanted. */
case|case
name|svn_wc__db_status_not_present
case|:
comment|/* A committed delete (but parent not updated). The delete is            committed, so no conflict possible during update. */
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_wc__db_status_base_deleted
case|:
comment|/* An internal status. Should never show up here. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reason
operator|==
name|SVN_WC_CONFLICT_REASON_NONE
condition|)
comment|/* No conflict with the current action. */
return|return
name|SVN_NO_ERROR
return|;
comment|/* Sanity checks. Note that if there was no action on the node, this function    * would not have been called in the first place.*/
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_edited
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_obstructed
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_replaced
condition|)
block|{
comment|/* When the node existed before (it was locally deleted, replaced or        * edited), then 'update' cannot add it "again". So it can only send        * _action_edit, _delete or _replace. */
if|if
condition|(
name|action
operator|!=
name|svn_wc_conflict_action_edit
operator|&&
name|action
operator|!=
name|svn_wc_conflict_action_delete
operator|&&
name|action
operator|!=
name|svn_wc_conflict_action_replace
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_FOUND_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected attempt to add a node at path '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_added
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_moved_here
condition|)
block|{
comment|/* When the node did not exist before (it was locally added),        * then 'update' cannot want to modify it in any way.        * It can only send _action_add. */
if|if
condition|(
name|action
operator|!=
name|svn_wc_conflict_action_add
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_FOUND_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected attempt to edit, delete, or replace "
literal|"a node at path '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* A conflict was detected. Create a conflict skel to record it. */
operator|*
name|pconflict
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_tree_conflict
argument_list|(
operator|*
name|pconflict
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|reason
argument_list|,
name|action
argument_list|,
name|move_src_op_root_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If LOCAL_ABSPATH is inside a conflicted tree and the conflict is  * not a moved-away-edit conflict, set *CONFLICTED to TRUE.  Otherwise  * set *CONFLICTED to FALSE.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|already_in_a_tree_conflict
parameter_list|(
name|svn_boolean_t
modifier|*
name|conflicted
parameter_list|,
name|svn_boolean_t
modifier|*
name|ignored
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ancestor_abspath
init|=
name|local_abspath
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|conflicted
operator|=
operator|*
name|ignored
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|svn_boolean_t
name|is_wc_root
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflicted_for_update_p
argument_list|(
name|conflicted
argument_list|,
name|ignored
argument_list|,
name|db
argument_list|,
name|ancestor_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|conflicted
operator|||
operator|*
name|ignored
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_wc_root
argument_list|,
name|db
argument_list|,
name|ancestor_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_wc_root
condition|)
break|break;
name|ancestor_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|ancestor_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Temporary helper until the new conflict handling is in place */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|node_already_conflicted
parameter_list|(
name|svn_boolean_t
modifier|*
name|conflicted
parameter_list|,
name|svn_boolean_t
modifier|*
name|conflict_ignored
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__conflicted_for_update_p
argument_list|(
name|conflicted
argument_list|,
name|conflict_ignored
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
init|=
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|,
name|base_kind
decl_stmt|;
name|svn_revnum_t
name|old_revision
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_boolean_t
name|have_work
decl_stmt|;
name|svn_skel_t
modifier|*
name|tree_conflict
init|=
name|NULL
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_wc__db_status_t
name|base_status
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
name|svn_boolean_t
name|deleting_target
decl_stmt|;
name|svn_boolean_t
name|deleting_switched
decl_stmt|;
name|svn_boolean_t
name|keep_as_working
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|queue_deletes
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|skip_this
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|pb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_directory_edited
argument_list|(
name|pb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|path_join_under_root
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|pb
operator|->
name|local_abspath
argument_list|,
name|base
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|deleting_target
operator|=
operator|(
name|strcmp
argument_list|(
name|local_abspath
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* Detect obstructing working copies */
block|{
name|svn_boolean_t
name|is_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_root
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_root
condition|)
block|{
comment|/* Just skip this node; a future update will handle it */
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_wc_notify_update_skip_obstruction
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|old_revision
argument_list|,
operator|&
name|repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|have_work
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_work
condition|)
block|{
name|base_status
operator|=
name|status
expr_stmt|;
name|base_kind
operator|=
name|kind
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info
argument_list|(
operator|&
name|base_status
argument_list|,
operator|&
name|base_kind
argument_list|,
operator|&
name|old_revision
argument_list|,
operator|&
name|repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|old_repos_relpath
operator|&&
name|repos_relpath
condition|)
block|{
specifier|const
name|char
modifier|*
name|expected_name
decl_stmt|;
name|expected_name
operator|=
name|svn_relpath_skip_ancestor
argument_list|(
name|pb
operator|->
name|old_repos_relpath
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
name|deleting_switched
operator|=
operator|(
operator|!
name|expected_name
operator|||
name|strcmp
argument_list|(
name|expected_name
argument_list|,
name|base
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
name|deleting_switched
operator|=
name|FALSE
expr_stmt|;
comment|/* Is this path a conflict victim? */
if|if
condition|(
name|pb
operator|->
name|shadowed
condition|)
name|conflicted
operator|=
name|FALSE
expr_stmt|;
comment|/* Conflict applies to WORKING */
elseif|else
if|if
condition|(
name|conflicted
condition|)
name|SVN_ERR
argument_list|(
name|node_already_conflicted
argument_list|(
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicted
condition|)
block|{
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_wc_notify_skip_conflicted
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Receive the remote removal of excluded/server-excluded/not present node.      Do not notify, but perform the change even when the node is shadowed */
if|if
condition|(
name|base_status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|base_status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|base_status
operator|==
name|svn_wc__db_status_server_excluded
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_remove
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* keep_as_working */
argument_list|,
name|FALSE
comment|/* queue_deletes */
argument_list|,
name|SVN_INVALID_REVNUM
comment|/* not_present_rev */
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleting_target
condition|)
name|eb
operator|->
name|target_deleted
operator|=
name|TRUE
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Is this path the victim of a newly-discovered tree conflict?  If so,    * remember it and notify the client. Then (if it was existing and    * modified), re-schedule the node to be added back again, as a (modified)    * copy of the previous base version.  */
comment|/* Check for conflicts only when we haven't already recorded    * a tree-conflict on a parent node. */
if|if
condition|(
operator|!
name|pb
operator|->
name|shadowed
operator|&&
operator|!
name|pb
operator|->
name|edit_obstructed
condition|)
block|{
name|SVN_ERR
argument_list|(
name|check_tree_conflict
argument_list|(
operator|&
name|tree_conflict
argument_list|,
name|eb
argument_list|,
name|local_abspath
argument_list|,
name|status
argument_list|,
name|TRUE
argument_list|,
operator|(
name|kind
operator|==
name|svn_node_dir
operator|)
condition|?
name|svn_node_dir
else|:
name|svn_node_file
argument_list|,
name|svn_wc_conflict_action_delete
argument_list|,
name|pb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|queue_deletes
operator|=
name|FALSE
expr_stmt|;
comment|/* There is no in-wc representation */
if|if
condition|(
name|tree_conflict
operator|!=
name|NULL
condition|)
block|{
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
comment|/* When we raise a tree conflict on a node, we don't want to mark the        * node as skipped, to allow a replacement to continue doing at least        * a bit of its work (possibly adding a not present node, for the        * next update) */
if|if
condition|(
operator|!
name|pb
operator|->
name|deletion_conflicts
condition|)
name|pb
operator|->
name|deletion_conflicts
operator|=
name|apr_hash_make
argument_list|(
name|pb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deletion_conflicts
argument_list|,
name|apr_pstrdup
argument_list|(
name|pb
operator|->
name|pool
argument_list|,
name|base
argument_list|)
argument_list|,
name|tree_conflict
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|tree_conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_edited
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_obstructed
condition|)
block|{
comment|/* The item exists locally and has some sort of local mod.            * It no longer exists in the repository at its target URL@REV.            *            * To prepare the "accept mine" resolution for the tree conflict,            * we must schedule the existing content for re-addition as a copy            * of what it was, but with its local modifications preserved. */
name|keep_as_working
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through to remove the BASE_NODEs properly, with potentially              keeping a not-present marker */
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_replaced
condition|)
block|{
comment|/* The item does not exist locally because it was already shadowed.            * We must complete the deletion, leaving the tree conflict info            * as the only difference from a normal deletion. */
comment|/* Fall through to the normal "delete" code path. */
block|}
else|else
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* other reasons are not expected here */
block|}
name|SVN_ERR
argument_list|(
name|complete_conflict
argument_list|(
name|tree_conflict
argument_list|,
name|eb
argument_list|,
name|local_abspath
argument_list|,
name|repos_relpath
argument_list|,
name|old_revision
argument_list|,
name|NULL
argument_list|,
operator|(
name|kind
operator|==
name|svn_node_dir
operator|)
condition|?
name|svn_node_dir
else|:
name|svn_node_file
argument_list|,
name|svn_node_none
argument_list|,
name|pb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Issue a wq operation to delete the BASE_NODE data and to delete actual      nodes based on that from disk, but leave any WORKING_NODEs on disk.       Local modifications are already turned into copies at this point.       If the thing being deleted is the *target* of this update, then      we need to recreate a 'deleted' entry, so that the parent can give      accurate reports about itself in the future. */
if|if
condition|(
operator|!
name|deleting_target
operator|&&
operator|!
name|deleting_switched
condition|)
block|{
comment|/* Delete, and do not leave a not-present node.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_remove
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|keep_as_working
argument_list|,
name|queue_deletes
argument_list|,
name|SVN_INVALID_REVNUM
comment|/* not_present_rev */
argument_list|,
name|tree_conflict
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Delete, leaving a not-present node.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_remove
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|keep_as_working
argument_list|,
name|queue_deletes
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|tree_conflict
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleting_target
condition|)
name|eb
operator|->
name|target_deleted
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* Don't remove the not-present marker at the final bump */
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|pb
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notify. */
if|if
condition|(
name|tree_conflict
condition|)
name|do_notification
argument_list|(
name|eb
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
block|{
name|svn_wc_notify_action_t
name|action
init|=
name|svn_wc_notify_update_delete
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|shadowed
operator|||
name|pb
operator|->
name|edit_obstructed
condition|)
name|action
operator|=
name|svn_wc_notify_update_shadowed_delete
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|node_kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
name|node_kind
operator|=
name|svn_node_file
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
name|action
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|db
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_boolean_t
name|conflict_ignored
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|versioned_locally_and_present
decl_stmt|;
name|svn_skel_t
modifier|*
name|tree_conflict
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
operator|(
name|copyfrom_path
operator|||
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_dir_baton
argument_list|(
operator|&
name|db
argument_list|,
name|path
argument_list|,
name|eb
argument_list|,
name|pb
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|db
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|skip_this
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|mark_directory_edited
argument_list|(
name|db
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|eb
operator|->
name|target_abspath
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The target of the edit is being added, give it the requested          depth of the edit (but convert svn_depth_unknown to          svn_depth_infinity). */
name|db
operator|->
name|ambient_depth
operator|=
operator|(
name|eb
operator|->
name|requested_depth
operator|==
name|svn_depth_unknown
operator|)
condition|?
name|svn_depth_infinity
else|:
name|eb
operator|->
name|requested_depth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eb
operator|->
name|requested_depth
operator|==
name|svn_depth_immediates
operator|||
operator|(
name|eb
operator|->
name|requested_depth
operator|==
name|svn_depth_unknown
operator|&&
name|pb
operator|->
name|ambient_depth
operator|==
name|svn_depth_immediates
operator|)
condition|)
block|{
name|db
operator|->
name|ambient_depth
operator|=
name|svn_depth_empty
expr_stmt|;
block|}
else|else
block|{
name|db
operator|->
name|ambient_depth
operator|=
name|svn_depth_infinity
expr_stmt|;
block|}
comment|/* It may not be named the same as the administrative directory. */
if|if
condition|(
name|svn_wc_is_adm_dir
argument_list|(
name|db
operator|->
name|name
argument_list|,
name|pool
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to add directory '%s': object of the same name as the "
literal|"administrative directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|db
operator|->
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|wc_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|wc_kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|status
operator|=
name|svn_wc__db_status_normal
expr_stmt|;
name|conflicted
operator|=
name|FALSE
expr_stmt|;
name|versioned_locally_and_present
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc_kind
operator|==
name|svn_node_dir
operator|&&
name|status
operator|==
name|svn_wc__db_status_normal
condition|)
block|{
comment|/* !! We found the root of a separate working copy obstructing the wc !!           If the directory would be part of our own working copy then          we wouldn't have been called as an add_directory().           The only thing we can do is add a not-present node, to allow          a future update to bring in the new files when the problem is          resolved.  Note that svn_wc__db_base_add_not_present_node()          explicitly adds the node into the parent's node database. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_add_not_present_node
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|svn_node_file
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_update_skip_obstruction
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_normal
operator|&&
operator|(
name|wc_kind
operator|==
name|svn_node_file
operator|||
name|wc_kind
operator|==
name|svn_node_symlink
operator|)
condition|)
block|{
comment|/* We found a file external occupating the place we need in BASE.           We can't add a not-present node in this case as that would overwrite          the file external. Luckily the file external itself stops us from          forgetting a child of this parent directory like an obstructing          working copy would.           The reason we get here is that the adm crawler doesn't report          file externals.       */
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_update_skip_obstruction
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|wc_kind
operator|==
name|svn_node_unknown
condition|)
name|versioned_locally_and_present
operator|=
name|FALSE
expr_stmt|;
comment|/* Tree conflict ACTUAL-only node */
else|else
name|versioned_locally_and_present
operator|=
name|IS_NODE_PRESENT
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* Is this path a conflict victim? */
if|if
condition|(
name|conflicted
condition|)
block|{
if|if
condition|(
name|pb
operator|->
name|deletion_conflicts
condition|)
name|tree_conflict
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|deletion_conflicts
argument_list|,
name|db
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_conflict
condition|)
block|{
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
comment|/* So this deletion wasn't just a deletion, it is actually a              replacement. Let's install a better tree conflict. */
comment|/* ### Should store the conflict in DB to allow reinstalling              ### with theoretically more data in close_directory() */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|tree_conflict
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|tree_conflict
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_tree_conflict
argument_list|(
name|tree_conflict
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|reason
argument_list|,
name|svn_wc_conflict_action_replace
argument_list|,
name|NULL
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And now stop checking for conflicts here and just perform              a shadowed update */
name|db
operator|->
name|edit_conflict
operator|=
name|tree_conflict
expr_stmt|;
comment|/* Cache for close_directory */
name|tree_conflict
operator|=
name|NULL
expr_stmt|;
comment|/* No direct notification */
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
comment|/* Just continue */
name|conflicted
operator|=
name|FALSE
expr_stmt|;
comment|/* No skip */
block|}
else|else
name|SVN_ERR
argument_list|(
name|node_already_conflicted
argument_list|(
operator|&
name|conflicted
argument_list|,
operator|&
name|conflict_ignored
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now the "usual" behaviour if already conflicted. Skip it. */
if|if
condition|(
name|conflicted
condition|)
block|{
comment|/* Record this conflict so that its descendants are skipped silently. */
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
comment|/* We skip this node, but once the update completes the parent node will          be updated to the new revision. So a future recursive update of the          parent will not bring in this new node as the revision of the parent          describes to the repository that all children are available.           To resolve this problem, we add a not-present node to allow bringing          the node in once this conflict is resolved.           Note that we can safely assume that no present base node exists,          because then we would not have received an add_directory.        */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_add_not_present_node
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|svn_node_dir
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### TODO: Also print victim_path in the skip msg. */
name|do_notification
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_skip_conflicted
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|conflict_ignored
condition|)
block|{
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
block|{
comment|/* Nothing to check; does not and will not exist in working copy */
block|}
elseif|else
if|if
condition|(
name|versioned_locally_and_present
condition|)
block|{
comment|/* What to do with a versioned or schedule-add dir:           A dir already added without history is OK.  Set add_existed          so that user notification is delayed until after any prop          conflicts have been found.           An existing versioned dir is an error.  In the future we may          relax this restriction and simply update such dirs.           A dir added with history is a tree conflict. */
name|svn_boolean_t
name|local_is_non_dir
decl_stmt|;
name|svn_wc__db_status_t
name|add_status
init|=
name|svn_wc__db_status_normal
decl_stmt|;
comment|/* Is the local add a copy? */
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_added
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
operator|&
name|add_status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is there *something* that is not a dir? */
name|local_is_non_dir
operator|=
operator|(
name|wc_kind
operator|!=
name|svn_node_dir
operator|&&
name|status
operator|!=
name|svn_wc__db_status_deleted
operator|)
expr_stmt|;
comment|/* Do tree conflict checking if        *  - if there is a local copy.        *  - if this is a switch operation        *  - the node kinds mismatch        *        * During switch, local adds at the same path as incoming adds get        * "lost" in that switching back to the original will no longer have the        * local add. So switch always alerts the user with a tree conflict. */
if|if
condition|(
operator|!
name|eb
operator|->
name|adds_as_modification
operator|||
name|local_is_non_dir
operator|||
name|add_status
operator|!=
name|svn_wc__db_status_added
condition|)
block|{
name|SVN_ERR
argument_list|(
name|check_tree_conflict
argument_list|(
operator|&
name|tree_conflict
argument_list|,
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|status
argument_list|,
name|FALSE
argument_list|,
name|svn_node_none
argument_list|,
name|svn_wc_conflict_action_add
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tree_conflict
operator|==
name|NULL
condition|)
name|db
operator|->
name|add_existed
operator|=
name|TRUE
expr_stmt|;
comment|/* Take over WORKING */
else|else
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
comment|/* Only update BASE */
block|}
elseif|else
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
condition|)
block|{
comment|/* There's an unversioned node at this path. */
name|db
operator|->
name|obstruction_found
operator|=
name|TRUE
expr_stmt|;
comment|/* Unversioned, obstructing dirs are handled by prop merge/conflict,        * if unversioned obstructions are allowed. */
if|if
condition|(
operator|!
operator|(
name|kind
operator|==
name|svn_node_dir
operator|&&
name|eb
operator|->
name|allow_unver_obstructions
operator|)
condition|)
block|{
comment|/* Bring in the node as deleted */
comment|/* ### Obstructed Conflict */
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
comment|/* Mark a conflict */
name|tree_conflict
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_tree_conflict
argument_list|(
name|tree_conflict
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_wc_conflict_reason_unversioned
argument_list|,
name|svn_wc_conflict_action_add
argument_list|,
name|NULL
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|edit_conflict
operator|=
name|tree_conflict
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tree_conflict
condition|)
name|SVN_ERR
argument_list|(
name|complete_conflict
argument_list|(
name|tree_conflict
argument_list|,
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|old_repos_relpath
argument_list|,
name|db
operator|->
name|old_revision
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
name|wc_kind
argument_list|,
name|svn_node_dir
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_add_incomplete_directory
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|db
operator|->
name|ambient_depth
argument_list|,
operator|(
name|db
operator|->
name|shadowed
operator|&&
name|db
operator|->
name|obstruction_found
operator|)
argument_list|,
operator|(
operator|!
name|db
operator|->
name|shadowed
operator|&&
name|status
operator|==
name|svn_wc__db_status_added
operator|)
argument_list|,
name|tree_conflict
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure there is a real directory at LOCAL_ABSPATH, unless we are just      updating the DB */
if|if
condition|(
operator|!
name|db
operator|->
name|shadowed
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__ensure_directory
argument_list|(
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_conflict
operator|!=
name|NULL
condition|)
block|{
name|db
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If this add was obstructed by dir scheduled for addition without      history let close_directory() handle the notification because there      might be properties to deal with.  If PATH was added inside a locally      deleted tree, then suppress notification, a tree conflict was already      issued. */
if|if
condition|(
name|eb
operator|->
name|notify_func
operator|&&
operator|!
name|db
operator|->
name|already_notified
operator|&&
operator|!
name|db
operator|->
name|add_existed
condition|)
block|{
name|svn_wc_notify_action_t
name|action
decl_stmt|;
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
name|action
operator|=
name|svn_wc_notify_update_shadowed_add
expr_stmt|;
elseif|else
if|if
condition|(
name|db
operator|->
name|obstruction_found
operator|||
name|db
operator|->
name|add_existed
condition|)
name|action
operator|=
name|svn_wc_notify_exists
expr_stmt|;
else|else
name|action
operator|=
name|svn_wc_notify_update_add
expr_stmt|;
name|db
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|action
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
decl_stmt|,
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|svn_boolean_t
name|have_work
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_boolean_t
name|conflict_ignored
init|=
name|FALSE
decl_stmt|;
name|svn_skel_t
modifier|*
name|tree_conflict
init|=
name|NULL
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|,
name|base_status
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_dir_baton
argument_list|(
operator|&
name|db
argument_list|,
name|path
argument_list|,
name|eb
argument_list|,
name|pb
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|db
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|skip_this
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Detect obstructing working copies */
block|{
name|svn_boolean_t
name|is_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_root
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_root
condition|)
block|{
comment|/* Just skip this node; a future update will handle it */
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_update_skip_obstruction
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* We should have a write lock on every directory touched.  */
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|wc_kind
argument_list|,
operator|&
name|db
operator|->
name|old_revision
argument_list|,
operator|&
name|db
operator|->
name|old_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|db
operator|->
name|changed_rev
argument_list|,
operator|&
name|db
operator|->
name|changed_date
argument_list|,
operator|&
name|db
operator|->
name|changed_author
argument_list|,
operator|&
name|db
operator|->
name|ambient_depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|have_work
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_work
condition|)
name|base_status
operator|=
name|status
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info
argument_list|(
operator|&
name|base_status
argument_list|,
name|NULL
argument_list|,
operator|&
name|db
operator|->
name|old_revision
argument_list|,
operator|&
name|db
operator|->
name|old_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|db
operator|->
name|changed_rev
argument_list|,
operator|&
name|db
operator|->
name|changed_date
argument_list|,
operator|&
name|db
operator|->
name|changed_author
argument_list|,
operator|&
name|db
operator|->
name|ambient_depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|was_incomplete
operator|=
operator|(
name|base_status
operator|==
name|svn_wc__db_status_incomplete
operator|)
expr_stmt|;
comment|/* Is this path a conflict victim? */
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
name|conflicted
operator|=
name|FALSE
expr_stmt|;
comment|/* Conflict applies to WORKING */
elseif|else
if|if
condition|(
name|conflicted
condition|)
name|SVN_ERR
argument_list|(
name|node_already_conflicted
argument_list|(
operator|&
name|conflicted
argument_list|,
operator|&
name|conflict_ignored
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicted
condition|)
block|{
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_wc_notify_skip_conflicted
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|conflict_ignored
condition|)
block|{
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Is this path a fresh tree conflict victim?  If so, skip the tree      with one notification. */
comment|/* Check for conflicts only when we haven't already recorded    * a tree-conflict on a parent node. */
if|if
condition|(
operator|!
name|db
operator|->
name|shadowed
condition|)
name|SVN_ERR
argument_list|(
name|check_tree_conflict
argument_list|(
operator|&
name|tree_conflict
argument_list|,
name|eb
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|status
argument_list|,
name|TRUE
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_conflict_action_edit
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember the roots of any locally deleted trees. */
if|if
condition|(
name|tree_conflict
operator|!=
name|NULL
condition|)
block|{
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
name|db
operator|->
name|edit_conflict
operator|=
name|tree_conflict
expr_stmt|;
comment|/* Other modifications wouldn't be a tree conflict */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|tree_conflict
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_replaced
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_obstructed
argument_list|)
expr_stmt|;
comment|/* Continue updating BASE */
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_obstructed
condition|)
name|db
operator|->
name|edit_obstructed
operator|=
name|TRUE
expr_stmt|;
else|else
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Mark directory as being at target_revision and URL, but incomplete. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_op_start_directory_update
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_prop_t
modifier|*
name|propchange
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
if|if
condition|(
name|db
operator|->
name|skip_this
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|propchange
operator|=
name|apr_array_push
argument_list|(
name|db
operator|->
name|propchanges
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|value
operator|=
name|value
condition|?
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|db
operator|->
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|db
operator|->
name|edited
operator|&&
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
operator|==
name|svn_prop_regular_kind
condition|)
name|SVN_ERR
argument_list|(
name|mark_directory_edited
argument_list|(
name|db
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If any of the svn_prop_t objects in PROPCHANGES represents a change    to the SVN_PROP_EXTERNALS property, return that change, else return    null.  If PROPCHANGES contains more than one such change, return    the first. */
end_comment

begin_function
specifier|static
specifier|const
name|svn_prop_t
modifier|*
name|externals_prop_changed
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|propchanges
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|propchanges
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|p
init|=
operator|&
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|propchanges
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
name|svn_wc_notify_state_t
name|prop_state
init|=
name|svn_wc_notify_state_unknown
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entry_prop_changes
decl_stmt|;
name|apr_array_header_t
modifier|*
name|dav_prop_changes
decl_stmt|;
name|apr_array_header_t
modifier|*
name|regular_prop_changes
decl_stmt|;
name|apr_hash_t
modifier|*
name|base_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|actual_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_base_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_actual_props
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|new_changed_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|apr_time_t
name|new_changed_date
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_changed_author
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|db
operator|->
name|pool
decl_stmt|;
name|svn_skel_t
modifier|*
name|all_work_items
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_skel
init|=
name|NULL
decl_stmt|;
comment|/* Skip if we're in a conflicted tree. */
if|if
condition|(
name|db
operator|->
name|skip_this
condition|)
block|{
comment|/* Allow the parent to complete its update. */
name|SVN_ERR
argument_list|(
name|maybe_release_dir_info
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|db
operator|->
name|edited
condition|)
name|conflict_skel
operator|=
name|db
operator|->
name|edit_conflict
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|db
operator|->
name|propchanges
argument_list|,
operator|&
name|entry_prop_changes
argument_list|,
operator|&
name|dav_prop_changes
argument_list|,
operator|&
name|regular_prop_changes
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the existing properties.  */
if|if
condition|(
operator|(
operator|!
name|db
operator|->
name|adding_dir
operator|||
name|db
operator|->
name|add_existed
operator|)
operator|&&
operator|!
name|db
operator|->
name|shadowed
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__get_actual_props
argument_list|(
operator|&
name|actual_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|actual_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|add_existed
condition|)
block|{
comment|/* This node already exists. Grab the current pristine properties. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|base_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|db
operator|->
name|adding_dir
condition|)
block|{
comment|/* Get the BASE properties for proper merging. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_props
argument_list|(
operator|&
name|base_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|base_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* An incomplete directory might have props which were supposed to be      deleted but weren't.  Because the server sent us all the props we're      supposed to have, any previous base props not in this list must be      deleted (issue #1672). */
if|if
condition|(
name|db
operator|->
name|was_incomplete
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_hash_t
modifier|*
name|props_to_delete
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* In a copy of the BASE props, remove every property that we see an          incoming change for. The remaining unmentioned properties are those          which need to be deleted.  */
name|props_to_delete
operator|=
name|apr_hash_copy
argument_list|(
name|pool
argument_list|,
name|base_props
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regular_prop_changes
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
name|prop
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|regular_prop_changes
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|props_to_delete
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Add these props to the incoming propchanges (in        * regular_prop_changes).  */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|props_to_delete
argument_list|)
init|;
name|hi
operator|!=
name|NULL
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_prop_t
modifier|*
name|prop
init|=
name|apr_array_push
argument_list|(
name|regular_prop_changes
argument_list|)
decl_stmt|;
comment|/* Record a deletion for PROPNAME.  */
name|prop
operator|->
name|name
operator|=
name|propname
expr_stmt|;
name|prop
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If this directory has property changes stored up, now is the time      to deal with them. */
if|if
condition|(
name|regular_prop_changes
operator|->
name|nelts
condition|)
block|{
comment|/* If recording traversal info, then see if the          SVN_PROP_EXTERNALS property on this directory changed,          and record before and after for the change. */
if|if
condition|(
name|eb
operator|->
name|external_func
condition|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|change
init|=
name|externals_prop_changed
argument_list|(
name|regular_prop_changes
argument_list|)
decl_stmt|;
if|if
condition|(
name|change
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|new_val_s
init|=
name|change
operator|->
name|value
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|old_val_s
decl_stmt|;
name|old_val_s
operator|=
name|svn_hash_gets
argument_list|(
name|base_props
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_val_s
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|old_val_s
operator|==
name|NULL
operator|)
condition|)
empty_stmt|;
comment|/* No value before, no value after... so do nothing. */
elseif|else
if|if
condition|(
name|new_val_s
operator|&&
name|old_val_s
operator|&&
operator|(
name|svn_string_compare
argument_list|(
name|old_val_s
argument_list|,
name|new_val_s
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* Value did not change... so do nothing. */
elseif|else
if|if
condition|(
name|old_val_s
operator|||
name|new_val_s
condition|)
comment|/* something changed, record the change */
block|{
name|SVN_ERR
argument_list|(
call|(
name|eb
operator|->
name|external_func
call|)
argument_list|(
name|eb
operator|->
name|external_baton
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|old_val_s
argument_list|,
name|new_val_s
argument_list|,
name|db
operator|->
name|ambient_depth
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
block|{
comment|/* We don't have a relevant actual row, but we need actual properties              to allow property merging without conflicts. */
if|if
condition|(
name|db
operator|->
name|adding_dir
condition|)
name|actual_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|actual_props
operator|=
name|base_props
expr_stmt|;
block|}
comment|/* Merge pending properties. */
name|new_base_props
operator|=
name|svn_prop__patch
argument_list|(
name|base_props
argument_list|,
name|regular_prop_changes
argument_list|,
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR_W
argument_list|(
name|svn_wc__merge_props
argument_list|(
operator|&
name|conflict_skel
argument_list|,
operator|&
name|prop_state
argument_list|,
operator|&
name|new_actual_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|NULL
comment|/* use baseprops */
argument_list|,
name|base_props
argument_list|,
name|actual_props
argument_list|,
name|regular_prop_changes
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Couldn't do property merge"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* After a (not-dry-run) merge, we ALWAYS have props to save.  */
name|SVN_ERR_ASSERT
argument_list|(
name|new_base_props
operator|!=
name|NULL
operator|&&
name|new_actual_props
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|accumulate_last_change
argument_list|(
operator|&
name|new_changed_rev
argument_list|,
operator|&
name|new_changed_date
argument_list|,
operator|&
name|new_changed_author
argument_list|,
name|entry_prop_changes
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if we should add some not-present markers before marking the      directory complete (Issue #3569) */
block|{
name|apr_hash_t
modifier|*
name|new_children
init|=
name|svn_hash_gets
argument_list|(
name|eb
operator|->
name|dir_dirents
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_children
operator|!=
name|NULL
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|new_children
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|child_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_relpath
decl_stmt|;
specifier|const
name|svn_dirent_t
modifier|*
name|dirent
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|child_kind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|child_name
operator|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|db
operator|->
name|local_abspath
argument_list|,
name|child_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|dirent
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|child_kind
operator|=
operator|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
condition|?
name|svn_node_dir
else|:
name|svn_node_file
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|ambient_depth
operator|<
name|svn_depth_immediates
operator|&&
name|child_kind
operator|==
name|svn_node_dir
condition|)
continue|continue;
comment|/* We don't need the subdirs */
comment|/* ### We just check if there is some node in BASE at this path */
name|err
operator|=
name|svn_wc__db_base_get_info
argument_list|(
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|child_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|svn_boolean_t
name|is_wcroot
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_wcroot
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|child_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_wcroot
condition|)
continue|continue;
comment|/* Everything ok... Nothing to do here */
comment|/* Fall through to allow recovering later */
block|}
elseif|else
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|child_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|db
operator|->
name|new_relpath
argument_list|,
name|child_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_add_not_present_node
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|child_abspath
argument_list|,
name|child_relpath
argument_list|,
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|child_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|db
operator|->
name|not_present_files
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* This should call some new function (which could also be used          for new_children above) to add all the names in single          transaction, but I can't even trigger it.  I've tried          ra_local, ra_svn, ra_neon, ra_serf and they all call          close_file before close_dir. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|db
operator|->
name|not_present_files
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|child
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|,
modifier|*
name|child_relpath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|db
operator|->
name|local_abspath
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|child_relpath
operator|=
name|svn_dirent_join
argument_list|(
name|db
operator|->
name|new_relpath
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_add_not_present_node
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|child_abspath
argument_list|,
name|child_relpath
argument_list|,
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|svn_node_file
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* If this directory is merely an anchor for a targeted child, then we      should not be updating the node at all.  */
if|if
condition|(
name|db
operator|->
name|parent_baton
operator|==
name|NULL
operator|&&
operator|*
name|eb
operator|->
name|target_basename
operator|!=
literal|'\0'
condition|)
block|{
comment|/* And we should not have received any changes!  */
name|SVN_ERR_ASSERT
argument_list|(
name|db
operator|->
name|propchanges
operator|->
name|nelts
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* ... which also implies NEW_CHANGED_* are not set,          and NEW_BASE_PROPS == NULL.  */
block|}
else|else
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|iprops
init|=
name|NULL
decl_stmt|;
comment|/* ### we know a base node already exists. it was created in          ### open_directory or add_directory.  let's just preserve the          ### existing DEPTH value, and possibly CHANGED_*.  */
comment|/* If we received any changed_* values, then use them.  */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|new_changed_rev
argument_list|)
condition|)
name|db
operator|->
name|changed_rev
operator|=
name|new_changed_rev
expr_stmt|;
if|if
condition|(
name|new_changed_date
operator|!=
literal|0
condition|)
name|db
operator|->
name|changed_date
operator|=
name|new_changed_date
expr_stmt|;
if|if
condition|(
name|new_changed_author
operator|!=
name|NULL
condition|)
name|db
operator|->
name|changed_author
operator|=
name|new_changed_author
expr_stmt|;
comment|/* If no depth is set yet, set to infinity. */
if|if
condition|(
name|db
operator|->
name|ambient_depth
operator|==
name|svn_depth_unknown
condition|)
name|db
operator|->
name|ambient_depth
operator|=
name|svn_depth_infinity
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|depth_is_sticky
operator|&&
name|db
operator|->
name|ambient_depth
operator|!=
name|eb
operator|->
name|requested_depth
condition|)
block|{
comment|/* After a depth upgrade the entry must reflect the new depth.              Upgrading to infinity changes the depth of *all* directories,              upgrading to something else only changes the target. */
if|if
condition|(
name|eb
operator|->
name|requested_depth
operator|==
name|svn_depth_infinity
operator|||
operator|(
name|strcmp
argument_list|(
name|db
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|)
operator|==
literal|0
operator|&&
name|eb
operator|->
name|requested_depth
operator|>
name|db
operator|->
name|ambient_depth
operator|)
condition|)
block|{
name|db
operator|->
name|ambient_depth
operator|=
name|eb
operator|->
name|requested_depth
expr_stmt|;
block|}
block|}
comment|/* Do we have new properties to install? Or shall we simply retain          the prior set of properties? If we're installing new properties,          then we also want to write them to an old-style props file.  */
name|props
operator|=
name|new_base_props
expr_stmt|;
if|if
condition|(
name|props
operator|==
name|NULL
condition|)
name|props
operator|=
name|base_props
expr_stmt|;
if|if
condition|(
name|conflict_skel
condition|)
block|{
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|complete_conflict
argument_list|(
name|conflict_skel
argument_list|,
name|db
operator|->
name|edit_baton
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|db
operator|->
name|old_repos_relpath
argument_list|,
name|db
operator|->
name|old_revision
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_node_dir
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_create_markers
argument_list|(
operator|&
name|work_item
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Any inherited props to be set set for this base node? */
if|if
condition|(
name|eb
operator|->
name|wcroot_iprops
condition|)
block|{
name|iprops
operator|=
name|svn_hash_gets
argument_list|(
name|eb
operator|->
name|wcroot_iprops
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
comment|/* close_edit may also update iprops for switched nodes, catching              those for which close_directory is never called (e.g. a switch              with no changes).  So as a minor optimization we remove any              iprops from the hash so as not to set them again in              close_edit. */
if|if
condition|(
name|iprops
condition|)
name|svn_hash_sets
argument_list|(
name|eb
operator|->
name|wcroot_iprops
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Update the BASE data for the directory and mark the directory          complete */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_add_directory
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|wcroot_abspath
argument_list|,
name|db
operator|->
name|new_relpath
argument_list|,
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|props
argument_list|,
name|db
operator|->
name|changed_rev
argument_list|,
name|db
operator|->
name|changed_date
argument_list|,
name|db
operator|->
name|changed_author
argument_list|,
name|NULL
comment|/* children */
argument_list|,
name|db
operator|->
name|ambient_depth
argument_list|,
operator|(
name|dav_prop_changes
operator|->
name|nelts
operator|>
literal|0
operator|)
condition|?
name|svn_prop_array_to_hash
argument_list|(
name|dav_prop_changes
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
argument_list|,
name|conflict_skel
argument_list|,
operator|(
operator|!
name|db
operator|->
name|shadowed
operator|)
operator|&&
name|new_base_props
operator|!=
name|NULL
argument_list|,
name|new_actual_props
argument_list|,
name|iprops
argument_list|,
name|all_work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Process all of the queued work items for this directory.  */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_skel
operator|&&
name|eb
operator|->
name|conflict_func
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_invoke_resolver
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|db
operator|->
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|NULL
comment|/* merge_options */
argument_list|,
name|eb
operator|->
name|conflict_func
argument_list|,
name|eb
operator|->
name|conflict_baton
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|conflict_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notify of any prop changes on this directory -- but do nothing if      it's an added or skipped directory, because notification has already      happened in that case - unless the add was obstructed by a dir      scheduled for addition without history, in which case we handle      notification here). */
if|if
condition|(
operator|!
name|db
operator|->
name|already_notified
operator|&&
name|eb
operator|->
name|notify_func
operator|&&
name|db
operator|->
name|edited
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_wc_notify_action_t
name|action
decl_stmt|;
if|if
condition|(
name|db
operator|->
name|shadowed
operator|||
name|db
operator|->
name|edit_obstructed
condition|)
name|action
operator|=
name|svn_wc_notify_update_shadowed_update
expr_stmt|;
elseif|else
if|if
condition|(
name|db
operator|->
name|obstruction_found
operator|||
name|db
operator|->
name|add_existed
condition|)
name|action
operator|=
name|svn_wc_notify_exists
expr_stmt|;
else|else
name|action
operator|=
name|svn_wc_notify_update_update
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|db
operator|->
name|local_abspath
argument_list|,
name|action
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|notify
operator|->
name|prop_state
operator|=
name|prop_state
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
operator|*
name|eb
operator|->
name|target_revision
expr_stmt|;
name|notify
operator|->
name|old_revision
operator|=
name|db
operator|->
name|old_revision
expr_stmt|;
name|eb
operator|->
name|notify_func
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* We're done with this directory, so remove one reference from the      bump information. */
name|SVN_ERR
argument_list|(
name|maybe_release_dir_info
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Common code for 'absent_file' and 'absent_directory'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_node
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
name|absent_kind
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_dirent_basename
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|skip_this
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|mark_directory_edited
argument_list|(
name|pb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|local_abspath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If an item by this name is scheduled for addition that's a      genuine tree-conflict.  */
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|status
operator|=
name|svn_wc__db_status_not_present
expr_stmt|;
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_normal
operator|&&
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* We found an obstructing working copy!           We can do two things now:             1) notify the user, record a skip, etc.             2) Just record the absent node in BASE in the parent                working copy.           As option 2 happens to be exactly what we do anyway, lets do that.       */
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
condition|)
block|{
comment|/* The BASE node is not actually there, so we can safely turn it into          an absent node */
block|}
else|else
block|{
comment|/* We have a local addition. If this would be a BASE node it would have          been deleted before we get here. (Which might have turned it into          a copy).           ### This should be recorded as a tree conflict and the update          ### can just continue, as we can just record the absent status          ### in BASE.        */
name|SVN_ERR_ASSERT
argument_list|(
name|status
operator|!=
name|svn_wc__db_status_normal
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to mark '%s' absent: item of the same name is already "
literal|"scheduled for addition"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|new_relpath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Insert an excluded node below the parent node to note that this child        is absent. (This puts it in the parent db if the child is obstructed) */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_add_excluded_node
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|repos_relpath
argument_list|,
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
operator|(
name|eb
operator|->
name|target_revision
operator|)
argument_list|,
name|absent_kind
argument_list|,
name|svn_wc__db_status_server_excluded
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|absent_node
argument_list|(
name|path
argument_list|,
name|svn_node_file
argument_list|,
name|parent_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|absent_node
argument_list|(
name|path
argument_list|,
name|svn_node_dir
argument_list|,
name|parent_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
decl_stmt|;
name|svn_node_kind_t
name|kind
init|=
name|svn_node_none
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
init|=
name|svn_node_unknown
decl_stmt|;
name|svn_wc__db_status_t
name|status
init|=
name|svn_wc__db_status_normal
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
name|svn_boolean_t
name|conflicted
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|conflict_ignored
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|versioned_locally_and_present
init|=
name|FALSE
decl_stmt|;
name|svn_skel_t
modifier|*
name|tree_conflict
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
operator|(
name|copyfrom_path
operator|||
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_file_baton
argument_list|(
operator|&
name|fb
argument_list|,
name|pb
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|skip_this
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|fb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The file_pool can stick around for a *long* time, so we want to      use a subpool for any temporary allocations. */
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* It may not be named the same as the administrative directory. */
if|if
condition|(
name|svn_wc_is_adm_dir
argument_list|(
name|fb
operator|->
name|name
argument_list|,
name|pool
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to add file '%s': object of the same name as the "
literal|"administrative directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|eb
operator|->
name|clean_checkout
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|fb
operator|->
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|wc_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|wc_kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|conflicted
operator|=
name|FALSE
expr_stmt|;
name|versioned_locally_and_present
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc_kind
operator|==
name|svn_node_dir
operator|&&
name|status
operator|==
name|svn_wc__db_status_normal
condition|)
block|{
comment|/* !! We found the root of a separate working copy obstructing the wc !!           If the directory would be part of our own working copy then          we wouldn't have been called as an add_file().           The only thing we can do is add a not-present node, to allow          a future update to bring in the new files when the problem is          resolved. */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|not_present_files
argument_list|,
name|apr_pstrdup
argument_list|(
name|pb
operator|->
name|pool
argument_list|,
name|fb
operator|->
name|name
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_update_skip_obstruction
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_normal
operator|&&
operator|(
name|wc_kind
operator|==
name|svn_node_file
operator|||
name|wc_kind
operator|==
name|svn_node_symlink
operator|)
condition|)
block|{
comment|/* We found a file external occupating the place we need in BASE.           We can't add a not-present node in this case as that would overwrite          the file external. Luckily the file external itself stops us from          forgetting a child of this parent directory like an obstructing          working copy would.           The reason we get here is that the adm crawler doesn't report          file externals.       */
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_update_skip_obstruction
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|wc_kind
operator|==
name|svn_node_unknown
condition|)
name|versioned_locally_and_present
operator|=
name|FALSE
expr_stmt|;
comment|/* Tree conflict ACTUAL-only node */
else|else
name|versioned_locally_and_present
operator|=
name|IS_NODE_PRESENT
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* Is this path a conflict victim? */
if|if
condition|(
name|fb
operator|->
name|shadowed
condition|)
name|conflicted
operator|=
name|FALSE
expr_stmt|;
comment|/* Conflict applies to WORKING */
elseif|else
if|if
condition|(
name|conflicted
condition|)
block|{
if|if
condition|(
name|pb
operator|->
name|deletion_conflicts
condition|)
name|tree_conflict
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|deletion_conflicts
argument_list|,
name|fb
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_conflict
condition|)
block|{
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
comment|/* So this deletion wasn't just a deletion, it is actually a              replacement. Let's install a better tree conflict. */
comment|/* ### Should store the conflict in DB to allow reinstalling              ### with theoretically more data in close_directory() */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|tree_conflict
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|tree_conflict
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_tree_conflict
argument_list|(
name|tree_conflict
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|reason
argument_list|,
name|svn_wc_conflict_action_replace
argument_list|,
name|NULL
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And now stop checking for conflicts here and just perform              a shadowed update */
name|fb
operator|->
name|edit_conflict
operator|=
name|tree_conflict
expr_stmt|;
comment|/* Cache for close_file */
name|tree_conflict
operator|=
name|NULL
expr_stmt|;
comment|/* No direct notification */
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
comment|/* Just continue */
name|conflicted
operator|=
name|FALSE
expr_stmt|;
comment|/* No skip */
block|}
else|else
name|SVN_ERR
argument_list|(
name|node_already_conflicted
argument_list|(
operator|&
name|conflicted
argument_list|,
operator|&
name|conflict_ignored
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now the usual conflict handling: skip. */
if|if
condition|(
name|conflicted
condition|)
block|{
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
comment|/* We skip this node, but once the update completes the parent node will          be updated to the new revision. So a future recursive update of the          parent will not bring in this new node as the revision of the parent          describes to the repository that all children are available.           To resolve this problem, we add a not-present node to allow bringing          the node in once this conflict is resolved.           Note that we can safely assume that no present base node exists,          because then we would not have received an add_file.        */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|not_present_files
argument_list|,
name|apr_pstrdup
argument_list|(
name|pb
operator|->
name|pool
argument_list|,
name|fb
operator|->
name|name
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_wc_notify_skip_conflicted
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|conflict_ignored
condition|)
block|{
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|fb
operator|->
name|shadowed
condition|)
block|{
comment|/* Nothing to check; does not and will not exist in working copy */
block|}
elseif|else
if|if
condition|(
name|versioned_locally_and_present
condition|)
block|{
comment|/* What to do with a versioned or schedule-add file:           If the UUID doesn't match the parent's, or the URL isn't a child of          the parent dir's URL, it's an error.           Set add_existed so that user notification is delayed until after any          text or prop conflicts have been found.           Whether the incoming add is a symlink or a file will only be known in          close_file(), when the props are known. So with a locally added file          or symlink, let close_file() check for a tree conflict.           We will never see missing files here, because these would be          re-added during the crawler phase. */
name|svn_boolean_t
name|local_is_file
decl_stmt|;
comment|/* Is the local node a copy or move */
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_added
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is there something that is a file? */
name|local_is_file
operator|=
operator|(
name|wc_kind
operator|==
name|svn_node_file
operator|||
name|wc_kind
operator|==
name|svn_node_symlink
operator|)
expr_stmt|;
comment|/* Do tree conflict checking if        *  - if there is a local copy.        *  - if this is a switch operation        *  - the node kinds mismatch        *        * During switch, local adds at the same path as incoming adds get        * "lost" in that switching back to the original will no longer have the        * local add. So switch always alerts the user with a tree conflict. */
if|if
condition|(
operator|!
name|eb
operator|->
name|adds_as_modification
operator|||
operator|!
name|local_is_file
operator|||
name|status
operator|!=
name|svn_wc__db_status_added
condition|)
block|{
name|SVN_ERR
argument_list|(
name|check_tree_conflict
argument_list|(
operator|&
name|tree_conflict
argument_list|,
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|status
argument_list|,
name|FALSE
argument_list|,
name|svn_node_none
argument_list|,
name|svn_wc_conflict_action_add
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tree_conflict
operator|==
name|NULL
condition|)
name|fb
operator|->
name|add_existed
operator|=
name|TRUE
expr_stmt|;
comment|/* Take over WORKING */
else|else
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
comment|/* Only update BASE */
block|}
elseif|else
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
condition|)
block|{
comment|/* There's an unversioned node at this path. */
name|fb
operator|->
name|obstruction_found
operator|=
name|TRUE
expr_stmt|;
comment|/* Unversioned, obstructing files are handled by text merge/conflict,        * if unversioned obstructions are allowed. */
if|if
condition|(
operator|!
operator|(
name|kind
operator|==
name|svn_node_file
operator|&&
name|eb
operator|->
name|allow_unver_obstructions
operator|)
condition|)
block|{
comment|/* Bring in the node as deleted */
comment|/* ### Obstructed Conflict */
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
comment|/* Mark a conflict */
name|tree_conflict
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_tree_conflict
argument_list|(
name|tree_conflict
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_wc_conflict_reason_unversioned
argument_list|,
name|svn_wc_conflict_action_add
argument_list|,
name|NULL
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* When this is not the update target add a not-present BASE node now,      to allow marking the parent directory complete in its close_edit() call.      This resolves issues when that occurs before the close_file(). */
if|if
condition|(
name|pb
operator|->
name|parent_baton
operator|||
operator|*
name|eb
operator|->
name|target_basename
operator|==
literal|'\0'
operator|||
operator|(
name|strcmp
argument_list|(
name|fb
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|not_present_files
argument_list|,
name|apr_pstrdup
argument_list|(
name|pb
operator|->
name|pool
argument_list|,
name|fb
operator|->
name|name
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tree_conflict
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|complete_conflict
argument_list|(
name|tree_conflict
argument_list|,
name|fb
operator|->
name|edit_baton
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|old_repos_relpath
argument_list|,
name|fb
operator|->
name|old_revision
argument_list|,
name|fb
operator|->
name|new_relpath
argument_list|,
name|wc_kind
argument_list|,
name|svn_node_file
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_conflict
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|tree_conflict
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_boolean_t
name|conflict_ignored
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|have_work
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
name|svn_skel_t
modifier|*
name|tree_conflict
init|=
name|NULL
decl_stmt|;
comment|/* the file_pool can stick around for a *long* time, so we want to use      a subpool for any temporary allocations. */
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_file_baton
argument_list|(
operator|&
name|fb
argument_list|,
name|pb
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|skip_this
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Detect obstructing working copies */
block|{
name|svn_boolean_t
name|is_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_root
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_root
condition|)
block|{
comment|/* Just skip this node; a future update will handle it */
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_update_skip_obstruction
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Sanity check. */
comment|/* If replacing, make sure the .svn entry already exists. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|wc_kind
argument_list|,
operator|&
name|fb
operator|->
name|old_revision
argument_list|,
operator|&
name|fb
operator|->
name|old_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|fb
operator|->
name|changed_rev
argument_list|,
operator|&
name|fb
operator|->
name|changed_date
argument_list|,
operator|&
name|fb
operator|->
name|changed_author
argument_list|,
name|NULL
argument_list|,
operator|&
name|fb
operator|->
name|original_checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|fb
operator|->
name|local_prop_mods
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|have_work
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_work
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|fb
operator|->
name|old_revision
argument_list|,
operator|&
name|fb
operator|->
name|old_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|fb
operator|->
name|changed_rev
argument_list|,
operator|&
name|fb
operator|->
name|changed_date
argument_list|,
operator|&
name|fb
operator|->
name|changed_author
argument_list|,
name|NULL
argument_list|,
operator|&
name|fb
operator|->
name|original_checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is this path a conflict victim? */
if|if
condition|(
name|fb
operator|->
name|shadowed
condition|)
name|conflicted
operator|=
name|FALSE
expr_stmt|;
comment|/* Conflict applies to WORKING */
elseif|else
if|if
condition|(
name|conflicted
condition|)
name|SVN_ERR
argument_list|(
name|node_already_conflicted
argument_list|(
operator|&
name|conflicted
argument_list|,
operator|&
name|conflict_ignored
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicted
condition|)
block|{
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_wc_notify_skip_conflicted
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|conflict_ignored
condition|)
block|{
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Check for conflicts only when we haven't already recorded    * a tree-conflict on a parent node. */
if|if
condition|(
operator|!
name|fb
operator|->
name|shadowed
condition|)
name|SVN_ERR
argument_list|(
name|check_tree_conflict
argument_list|(
operator|&
name|tree_conflict
argument_list|,
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|status
argument_list|,
name|TRUE
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_conflict_action_edit
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is this path the victim of a newly-discovered tree conflict? */
if|if
condition|(
name|tree_conflict
operator|!=
name|NULL
condition|)
block|{
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
name|fb
operator|->
name|edit_conflict
operator|=
name|tree_conflict
expr_stmt|;
comment|/* Other modifications wouldn't be a tree conflict */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|tree_conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_replaced
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_obstructed
argument_list|)
expr_stmt|;
comment|/* Continue updating BASE */
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_obstructed
condition|)
name|fb
operator|->
name|edit_obstructed
operator|=
name|TRUE
expr_stmt|;
else|else
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_lazyopen_func_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lazy_open_source
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_read
argument_list|(
name|stream
argument_list|,
name|NULL
argument_list|,
name|fb
operator|->
name|edit_baton
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|original_checksum
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|lazy_target_baton
block|{
name|struct
name|file_baton
modifier|*
name|fb
decl_stmt|;
name|struct
name|handler_baton
modifier|*
name|hb
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_stream_lazyopen_func_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lazy_open_target
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|lazy_target_baton
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__open_writable_base
argument_list|(
name|stream
argument_list|,
operator|&
name|tb
operator|->
name|hb
operator|->
name|new_text_base_tmp_abspath
argument_list|,
name|NULL
argument_list|,
operator|&
name|tb
operator|->
name|hb
operator|->
name|new_text_base_sha1_checksum
argument_list|,
name|tb
operator|->
name|fb
operator|->
name|edit_baton
operator|->
name|db
argument_list|,
name|tb
operator|->
name|eb
operator|->
name|wcroot_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|expected_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|handler_pool
init|=
name|svn_pool_create
argument_list|(
name|fb
operator|->
name|pool
argument_list|)
decl_stmt|;
name|struct
name|handler_baton
modifier|*
name|hb
init|=
name|apr_pcalloc
argument_list|(
name|handler_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hb
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|recorded_base_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|expected_base_checksum
decl_stmt|;
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
name|struct
name|lazy_target_baton
modifier|*
name|tb
decl_stmt|;
name|svn_stream_t
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|fb
operator|->
name|skip_this
condition|)
block|{
operator|*
name|handler
operator|=
name|svn_delta_noop_window_handler
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|fb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse checksum or sets expected_base_checksum to NULL */
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|expected_base_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|expected_checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Before applying incoming svndiff data to text base, make sure      text base hasn't been corrupted, and that its checksum      matches the expected base checksum. */
comment|/* The incoming delta is targeted against EXPECTED_BASE_CHECKSUM. Find and      check our RECORDED_BASE_CHECKSUM.  (In WC-1, we could not do this test      for replaced nodes because we didn't store the checksum of the "revert      base".  In WC-NG, we do and we can.) */
name|recorded_base_checksum
operator|=
name|fb
operator|->
name|original_checksum
expr_stmt|;
comment|/* If we have a checksum that we want to compare to a MD5 checksum,      ensure that it is a MD5 checksum */
if|if
condition|(
name|recorded_base_checksum
operator|&&
name|expected_base_checksum
operator|&&
name|recorded_base_checksum
operator|->
name|kind
operator|!=
name|svn_checksum_md5
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_md5
argument_list|(
operator|&
name|recorded_base_checksum
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|wcroot_abspath
argument_list|,
name|recorded_base_checksum
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|expected_base_checksum
argument_list|,
name|recorded_base_checksum
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT_TEXT_BASE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for '%s':\n"
literal|"   expected:  %s\n"
literal|"   recorded:  %s\n"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_checksum_to_cstring_display
argument_list|(
name|expected_base_checksum
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_checksum_to_cstring_display
argument_list|(
name|recorded_base_checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* Open the text base for reading, unless this is an added file. */
comment|/*      kff todo: what we really need to do here is:       1. See if there's a file or dir by this name already here.      2. See if it's under revision control.      3. If both are true, open text-base.      4. If only 1 is true, bail, because we can't go destroying user's         files (or as an alternative to bailing, move it to some tmp         name and somehow tell the user, but communicating with the         user without erroring is a whole callback system we haven't         finished inventing yet.)   */
if|if
condition|(
operator|!
name|fb
operator|->
name|adding_file
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|fb
operator|->
name|original_checksum
operator|||
name|fb
operator|->
name|original_checksum
operator|->
name|kind
operator|==
name|svn_checksum_sha1
argument_list|)
expr_stmt|;
name|source
operator|=
name|svn_stream_lazyopen_create
argument_list|(
name|lazy_open_source
argument_list|,
name|fb
argument_list|,
name|FALSE
argument_list|,
name|handler_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
name|svn_stream_empty
argument_list|(
name|handler_pool
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't have a recorded checksum, use the ra provided checksum */
if|if
condition|(
operator|!
name|recorded_base_checksum
condition|)
name|recorded_base_checksum
operator|=
name|expected_base_checksum
expr_stmt|;
comment|/* Checksum the text base while applying deltas */
if|if
condition|(
name|recorded_base_checksum
condition|)
block|{
name|hb
operator|->
name|expected_source_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|recorded_base_checksum
argument_list|,
name|handler_pool
argument_list|)
expr_stmt|;
comment|/* Wrap stream and store reference to allow calculating the          checksum. */
name|source
operator|=
name|svn_stream_checksummed2
argument_list|(
name|source
argument_list|,
operator|&
name|hb
operator|->
name|actual_source_checksum
argument_list|,
name|NULL
argument_list|,
name|recorded_base_checksum
operator|->
name|kind
argument_list|,
name|TRUE
argument_list|,
name|handler_pool
argument_list|)
expr_stmt|;
name|hb
operator|->
name|source_checksum_stream
operator|=
name|source
expr_stmt|;
block|}
name|tb
operator|=
name|apr_palloc
argument_list|(
name|handler_pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lazy_target_baton
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|->
name|hb
operator|=
name|hb
expr_stmt|;
name|tb
operator|->
name|fb
operator|=
name|fb
expr_stmt|;
name|tb
operator|->
name|eb
operator|=
name|eb
expr_stmt|;
name|target
operator|=
name|svn_stream_lazyopen_create
argument_list|(
name|lazy_open_target
argument_list|,
name|tb
argument_list|,
name|TRUE
argument_list|,
name|handler_pool
argument_list|)
expr_stmt|;
comment|/* Prepare to apply the delta.  */
name|svn_txdelta_apply
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|hb
operator|->
name|new_text_base_md5_digest
argument_list|,
name|hb
operator|->
name|new_text_base_tmp_abspath
comment|/* error_info */
argument_list|,
name|handler_pool
argument_list|,
operator|&
name|hb
operator|->
name|apply_handler
argument_list|,
operator|&
name|hb
operator|->
name|apply_baton
argument_list|)
expr_stmt|;
name|hb
operator|->
name|pool
operator|=
name|handler_pool
expr_stmt|;
name|hb
operator|->
name|fb
operator|=
name|fb
expr_stmt|;
comment|/* We're all set.  */
operator|*
name|handler_baton
operator|=
name|hb
expr_stmt|;
operator|*
name|handler
operator|=
name|window_handler
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|svn_prop_t
modifier|*
name|propchange
decl_stmt|;
if|if
condition|(
name|fb
operator|->
name|skip_this
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Push a new propchange to the file baton's array of propchanges */
name|propchange
operator|=
name|apr_array_push
argument_list|(
name|fb
operator|->
name|propchanges
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|fb
operator|->
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|propchange
operator|->
name|value
operator|=
name|value
condition|?
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fb
operator|->
name|edited
operator|&&
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
operator|==
name|svn_prop_regular_kind
condition|)
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|fb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fb
operator|->
name|shadowed
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
name|svn_boolean_t
name|modified
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|becomes_symlink
decl_stmt|;
name|svn_boolean_t
name|was_symlink
decl_stmt|;
comment|/* Let's see if we have a change as in some scenarios servers report          non-changes of properties. */
name|becomes_symlink
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|adding_file
condition|)
name|was_symlink
operator|=
name|becomes_symlink
expr_stmt|;
comment|/* No change */
else|else
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* We read the server-props, not the ACTUAL props here as we just              want to see if this is really an incoming prop change. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_props
argument_list|(
operator|&
name|props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|was_symlink
operator|=
operator|(
operator|(
name|props
operator|&&
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
operator|!=
name|NULL
operator|)
condition|?
name|svn_tristate_true
else|:
name|svn_tristate_false
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|was_symlink
operator|!=
name|becomes_symlink
condition|)
block|{
comment|/* If the local node was not modified, we continue as usual, if              modified we want a tree conflict just like how we would handle              it when receiving a delete + add (aka "replace") */
if|if
condition|(
name|fb
operator|->
name|local_prop_mods
condition|)
name|modified
operator|=
name|TRUE
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__internal_file_modified_p
argument_list|(
operator|&
name|modified
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modified
condition|)
block|{
if|if
condition|(
operator|!
name|fb
operator|->
name|edit_conflict
condition|)
name|fb
operator|->
name|edit_conflict
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_tree_conflict
argument_list|(
name|fb
operator|->
name|edit_conflict
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_wc_conflict_reason_edited
argument_list|,
name|svn_wc_conflict_action_replace
argument_list|,
name|NULL
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|complete_conflict
argument_list|(
name|fb
operator|->
name|edit_conflict
argument_list|,
name|fb
operator|->
name|edit_baton
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|old_repos_relpath
argument_list|,
name|fb
operator|->
name|old_revision
argument_list|,
name|fb
operator|->
name|new_relpath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_node_file
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a copy of the existing (pre update) BASE node in WORKING,              mark a tree conflict and handle the rest of the update as              shadowed */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_make_copy
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|edit_conflict
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|do_notification
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Ok, we introduced a replacement, so we can now handle the rest              as a normal shadowed update */
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|add_existed
operator|=
name|FALSE
expr_stmt|;
name|fb
operator|->
name|already_notified
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform the actual merge of file changes between an original file,    identified by ORIGINAL_CHECKSUM (an empty file if NULL) to a new file    identified by NEW_CHECKSUM.     Merge the result into LOCAL_ABSPATH, which is part of the working copy    identified by WRI_ABSPATH. Use OLD_REVISION and TARGET_REVISION for naming    the intermediate files.     The rest of the arguments are passed to svn_wc__internal_merge().  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__perform_file_merge
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_skel_t
modifier|*
modifier|*
name|conflict_skel
parameter_list|,
name|svn_boolean_t
modifier|*
name|found_conflict
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|new_checksum
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|original_checksum
parameter_list|,
name|apr_hash_t
modifier|*
name|old_actual_props
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ext_patterns
parameter_list|,
name|svn_revnum_t
name|old_revision
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|propchanges
parameter_list|,
specifier|const
name|char
modifier|*
name|diff3_cmd
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Actual file exists and has local mods:      Now we need to let loose svn_wc__internal_merge() to merge      the textual changes into the working file. */
specifier|const
name|char
modifier|*
name|oldrev_str
decl_stmt|,
modifier|*
name|newrev_str
decl_stmt|,
modifier|*
name|mine_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_left
decl_stmt|;
name|svn_boolean_t
name|delete_left
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_ext
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_text_base_tmp_abspath
decl_stmt|;
name|enum
name|svn_wc_merge_outcome_t
name|merge_outcome
init|=
name|svn_wc_merge_unchanged
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_path
argument_list|(
operator|&
name|new_text_base_tmp_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|new_checksum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have any file extensions we're supposed to      preserve in generated conflict file names, then find      this path's extension.  But then, if it isn't one of      the ones we want to keep in conflict filenames,      pretend it doesn't have an extension at all. */
if|if
condition|(
name|ext_patterns
operator|&&
name|ext_patterns
operator|->
name|nelts
condition|)
block|{
name|svn_path_splitext
argument_list|(
name|NULL
argument_list|,
operator|&
name|path_ext
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|path_ext
operator|&&
name|svn_cstring_match_glob_list
argument_list|(
name|path_ext
argument_list|,
name|ext_patterns
argument_list|)
operator|)
condition|)
name|path_ext
operator|=
literal|""
expr_stmt|;
block|}
comment|/* old_revision can be invalid when the conflict is against a      local addition */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|old_revision
argument_list|)
condition|)
name|old_revision
operator|=
literal|0
expr_stmt|;
name|oldrev_str
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|".r%ld%s%s"
argument_list|,
name|old_revision
argument_list|,
operator|*
name|path_ext
condition|?
literal|"."
else|:
literal|""
argument_list|,
operator|*
name|path_ext
condition|?
name|path_ext
else|:
literal|""
argument_list|)
expr_stmt|;
name|newrev_str
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|".r%ld%s%s"
argument_list|,
name|target_revision
argument_list|,
operator|*
name|path_ext
condition|?
literal|"."
else|:
literal|""
argument_list|,
operator|*
name|path_ext
condition|?
name|path_ext
else|:
literal|""
argument_list|)
expr_stmt|;
name|mine_str
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|".mine%s%s"
argument_list|,
operator|*
name|path_ext
condition|?
literal|"."
else|:
literal|""
argument_list|,
operator|*
name|path_ext
condition|?
name|path_ext
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|original_checksum
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_empty_tmp_file
argument_list|(
operator|&
name|merge_left
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|delete_left
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_path
argument_list|(
operator|&
name|merge_left
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|original_checksum
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Merge the changes from the old textbase to the new      textbase into the file we're updating.      Remember that this function wants full paths! */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_merge
argument_list|(
operator|&
name|work_item
argument_list|,
name|conflict_skel
argument_list|,
operator|&
name|merge_outcome
argument_list|,
name|db
argument_list|,
name|merge_left
argument_list|,
name|new_text_base_tmp_abspath
argument_list|,
name|local_abspath
argument_list|,
name|wri_abspath
argument_list|,
name|oldrev_str
argument_list|,
name|newrev_str
argument_list|,
name|mine_str
argument_list|,
name|old_actual_props
argument_list|,
name|FALSE
comment|/* dry_run */
argument_list|,
name|diff3_cmd
argument_list|,
name|NULL
argument_list|,
name|propchanges
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|found_conflict
operator|=
operator|(
name|merge_outcome
operator|==
name|svn_wc_merge_conflict
operator|)
expr_stmt|;
comment|/* If we created a temporary left merge file, get rid of it. */
if|if
condition|(
name|delete_left
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|merge_left
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is the small planet.  It has the complex responsibility of  * "integrating" a new revision of a file into a working copy.  *  * Given a file_baton FB for a file either already under version control, or  * prepared (see below) to join version control, fully install a  * new revision of the file.  *  * ### transitional: installation of the working file will be handled  * ### by the *INSTALL_PRISTINE flag.  *  * By "install", we mean: create a new text-base and prop-base, merge  * any textual and property changes into the working file, and finally  * update all metadata so that the working copy believes it has a new  * working revision of the file.  All of this work includes being  * sensitive to eol translation, keyword substitution, and performing  * all actions accumulated the parent directory's work queue.  *  * Set *CONTENT_STATE to the state of the contents after the  * installation.  *  * Return values are allocated in RESULT_POOL and temporary allocations  * are performed in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_file
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_skel_t
modifier|*
modifier|*
name|conflict_skel
parameter_list|,
name|svn_boolean_t
modifier|*
name|install_pristine
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|install_from
parameter_list|,
name|svn_wc_notify_state_t
modifier|*
name|content_state
parameter_list|,
name|struct
name|file_baton
modifier|*
name|fb
parameter_list|,
name|apr_hash_t
modifier|*
name|actual_props
parameter_list|,
name|apr_time_t
name|last_changed_date
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|fb
operator|->
name|dir_baton
decl_stmt|;
name|svn_boolean_t
name|is_locally_modified
decl_stmt|;
name|svn_boolean_t
name|found_text_conflict
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|fb
operator|->
name|shadowed
operator|&&
operator|!
name|fb
operator|->
name|obstruction_found
operator|&&
operator|!
name|fb
operator|->
name|edit_obstructed
argument_list|)
expr_stmt|;
comment|/*      When this function is called on file F, we assume the following      things are true:           - The new pristine text of F is present in the pristine store            iff FB->NEW_TEXT_BASE_SHA1_CHECKSUM is not NULL.           - The WC metadata still reflects the old version of F.            (We can still access the old pristine base text of F.)       The goal is to update the local working copy of F to reflect      the changes received from the repository, preserving any local      modifications.   */
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
operator|*
name|install_pristine
operator|=
name|FALSE
expr_stmt|;
operator|*
name|install_from
operator|=
name|NULL
expr_stmt|;
comment|/* Start by splitting the file path, getting an access baton for the parent,      and an entry for the file if any. */
comment|/* Has the user made local mods to the working file?      Note that this compares to the current pristine file, which is      different from fb->old_text_base_path if we have a replaced-with-history      file.  However, in the case we had an obstruction, we check against the      new text base.    */
if|if
condition|(
name|fb
operator|->
name|adding_file
operator|&&
operator|!
name|fb
operator|->
name|add_existed
condition|)
block|{
name|is_locally_modified
operator|=
name|FALSE
expr_stmt|;
comment|/* There is no file: Don't check */
block|}
else|else
block|{
comment|/* The working file is not an obstruction.          So: is the file modified, relative to its ORIGINAL pristine?           This function sets is_locally_modified to FALSE for          files that do not exist and for directories. */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_file_modified_p
argument_list|(
operator|&
name|is_locally_modified
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|FALSE
comment|/* exact_comparison */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For 'textual' merging, we use the following system:       When a file is modified and we have a new BASE:       - For text files           * svn_wc_merge uses diff3           * possibly makes backups and marks files as conflicted.        - For binary files           * svn_wc_merge makes backups and marks files as conflicted.       If a file is not modified and we have a new BASE:        * Install from pristine.       If we have property changes related to magic properties or if the      svn:keywords property is set:        * Retranslate from the working file.    */
if|if
condition|(
operator|!
name|is_locally_modified
operator|&&
name|fb
operator|->
name|new_text_base_sha1_checksum
condition|)
block|{
comment|/* If there are no local mods, who cares whether it's a text              or binary file!  Just write a log command to overwrite              any working file with the new text-base.  If newline              conversion or keyword substitution is activated, this              will happen as well during the copy.              For replaced files, though, we want to merge in the changes              even if the file is not modified compared to the (non-revert)              text-base. */
operator|*
name|install_pristine
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fb
operator|->
name|new_text_base_sha1_checksum
condition|)
block|{
comment|/* Actual file exists and has local mods:          Now we need to let loose svn_wc__merge_internal() to merge          the textual changes into the working file. */
name|SVN_ERR
argument_list|(
name|svn_wc__perform_file_merge
argument_list|(
name|work_items
argument_list|,
name|conflict_skel
argument_list|,
operator|&
name|found_text_conflict
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|pb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|new_text_base_sha1_checksum
argument_list|,
name|fb
operator|->
name|add_existed
condition|?
name|NULL
else|:
name|fb
operator|->
name|original_checksum
argument_list|,
name|actual_props
argument_list|,
name|eb
operator|->
name|ext_patterns
argument_list|,
name|fb
operator|->
name|old_revision
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|fb
operator|->
name|propchanges
argument_list|,
name|eb
operator|->
name|diff3_cmd
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* end: working file exists and has mods */
else|else
block|{
comment|/* There is no new text base, but let's see if the working file needs          to be updated for any other reason. */
name|apr_hash_t
modifier|*
name|keywords
decl_stmt|;
comment|/* Determine if any of the propchanges are the "magic" ones that          might require changing the working file. */
name|svn_boolean_t
name|magic_props_changed
decl_stmt|;
name|magic_props_changed
operator|=
name|svn_wc__has_magic_property
argument_list|(
name|fb
operator|->
name|propchanges
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_translate_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|keywords
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|actual_props
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic_props_changed
operator|||
name|keywords
condition|)
block|{
comment|/* Special edge-case: it's possible that this file installation              only involves propchanges, but that some of those props still              require a retranslation of the working file.               OR that the file doesn't involve propchanges which by themselves              require retranslation, but receiving a change bumps the revision              number which requires re-expansion of keywords... */
if|if
condition|(
name|is_locally_modified
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmptext
decl_stmt|;
comment|/* Copy and DEtranslate the working file to a temp text-base.                  Note that detranslation is done according to the old props. */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_translated_file
argument_list|(
operator|&
name|tmptext
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|SVN_WC_TRANSLATE_TO_NF
operator||
name|SVN_WC_TRANSLATE_NO_OUTPUT_CLEANUP
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We always want to reinstall the working file if the magic                  properties have changed, or there are any keywords present.                  Note that TMPTEXT might actually refer to the working file                  itself (the above function skips a detranslate when not                  required). This is acceptable, as we will (re)translate                  according to the new properties into a temporary file (from                  the working file), and then rename the temp into place. Magic!                */
operator|*
name|install_pristine
operator|=
name|TRUE
expr_stmt|;
operator|*
name|install_from
operator|=
name|tmptext
expr_stmt|;
block|}
else|else
block|{
comment|/* Use our existing 'copy' from the pristine store instead                  of making a new copy. This way we can use the standard code                  to update the recorded size and modification time.                  (Issue #3842) */
operator|*
name|install_pristine
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* Set the returned content state. */
if|if
condition|(
name|found_text_conflict
condition|)
operator|*
name|content_state
operator|=
name|svn_wc_notify_state_conflicted
expr_stmt|;
elseif|else
if|if
condition|(
name|fb
operator|->
name|new_text_base_sha1_checksum
condition|)
block|{
if|if
condition|(
name|is_locally_modified
condition|)
operator|*
name|content_state
operator|=
name|svn_wc_notify_state_merged
expr_stmt|;
else|else
operator|*
name|content_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
block|}
else|else
operator|*
name|content_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_comment
comment|/* Mostly a wrapper around merge_file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|expected_md5_digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|pdb
init|=
name|fb
operator|->
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
name|svn_wc_notify_state_t
name|content_state
decl_stmt|,
name|prop_state
decl_stmt|;
name|svn_wc_notify_lock_state_t
name|lock_state
decl_stmt|;
name|svn_checksum_t
modifier|*
name|expected_md5_checksum
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_base_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_actual_props
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entry_prop_changes
decl_stmt|;
name|apr_array_header_t
modifier|*
name|dav_prop_changes
decl_stmt|;
name|apr_array_header_t
modifier|*
name|regular_prop_changes
decl_stmt|;
name|apr_hash_t
modifier|*
name|current_base_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|current_actual_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|local_actual_props
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|all_work_items
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_skel
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|fb
operator|->
name|pool
decl_stmt|;
comment|/* Destroyed at function exit */
name|svn_boolean_t
name|keep_recorded_info
init|=
name|FALSE
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|new_checksum
decl_stmt|;
name|apr_array_header_t
modifier|*
name|iprops
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|fb
operator|->
name|skip_this
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|maybe_release_dir_info
argument_list|(
name|pdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|fb
operator|->
name|edited
condition|)
name|conflict_skel
operator|=
name|fb
operator|->
name|edit_conflict
expr_stmt|;
if|if
condition|(
name|expected_md5_digest
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|expected_md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|expected_md5_digest
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|new_text_base_md5_checksum
operator|&&
name|expected_md5_checksum
operator|&&
operator|!
name|svn_checksum_match
argument_list|(
name|expected_md5_checksum
argument_list|,
name|fb
operator|->
name|new_text_base_md5_checksum
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_checksum_mismatch_err
argument_list|(
name|expected_md5_checksum
argument_list|,
name|fb
operator|->
name|new_text_base_md5_checksum
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Gather the changes for each kind of property.  */
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|fb
operator|->
name|propchanges
argument_list|,
operator|&
name|entry_prop_changes
argument_list|,
operator|&
name|dav_prop_changes
argument_list|,
operator|&
name|regular_prop_changes
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract the changed_* and lock state information.  */
block|{
name|svn_revnum_t
name|new_changed_rev
decl_stmt|;
name|apr_time_t
name|new_changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_changed_author
decl_stmt|;
name|SVN_ERR
argument_list|(
name|accumulate_last_change
argument_list|(
operator|&
name|new_changed_rev
argument_list|,
operator|&
name|new_changed_date
argument_list|,
operator|&
name|new_changed_author
argument_list|,
name|entry_prop_changes
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|new_changed_rev
argument_list|)
condition|)
name|fb
operator|->
name|changed_rev
operator|=
name|new_changed_rev
expr_stmt|;
if|if
condition|(
name|new_changed_date
operator|!=
literal|0
condition|)
name|fb
operator|->
name|changed_date
operator|=
name|new_changed_date
expr_stmt|;
if|if
condition|(
name|new_changed_author
operator|!=
name|NULL
condition|)
name|fb
operator|->
name|changed_author
operator|=
name|new_changed_author
expr_stmt|;
block|}
comment|/* Determine whether the file has become unlocked.  */
block|{
name|int
name|i
decl_stmt|;
name|lock_state
operator|=
name|svn_wc_notify_lock_state_unchanged
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry_prop_changes
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entry_prop_changes
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
comment|/* If we see a change to the LOCK_TOKEN entry prop, then the only            possible change is its REMOVAL. Thus, the lock has been removed,            and we should likewise remove our cached copy of it.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_ENTRY_LOCK_TOKEN
argument_list|)
condition|)
block|{
comment|/* If we lose the lock, but not because we are switching to                another url, remove the state lock from the wc */
if|if
condition|(
operator|!
name|eb
operator|->
name|switch_relpath
operator|||
name|strcmp
argument_list|(
name|fb
operator|->
name|new_relpath
argument_list|,
name|fb
operator|->
name|old_repos_relpath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|prop
operator|->
name|value
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_lock_remove
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|lock_state
operator|=
name|svn_wc_notify_lock_state_unlocked
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/* Install all kinds of properties.  It is important to do this before      any file content merging, since that process might expand keywords, in      which case we want the new entryprops to be in place. */
comment|/* Write log commands to merge REGULAR_PROPS into the existing      properties of FB->LOCAL_ABSPATH.  Update *PROP_STATE to reflect      the result of the regular prop merge.       BASE_PROPS and WORKING_PROPS are hashes of the base and      working props of the file; if NULL they are read from the wc.  */
comment|/* ### some of this feels like voodoo... */
if|if
condition|(
operator|(
operator|!
name|fb
operator|->
name|adding_file
operator|||
name|fb
operator|->
name|add_existed
operator|)
operator|&&
operator|!
name|fb
operator|->
name|shadowed
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__get_actual_props
argument_list|(
operator|&
name|local_actual_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_actual_props
operator|==
name|NULL
condition|)
name|local_actual_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|add_existed
condition|)
block|{
comment|/* This node already exists. Grab the current pristine properties. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|current_base_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|current_actual_props
operator|=
name|local_actual_props
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fb
operator|->
name|adding_file
condition|)
block|{
comment|/* Get the BASE properties for proper merging. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_props
argument_list|(
operator|&
name|current_base_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|current_actual_props
operator|=
name|local_actual_props
expr_stmt|;
block|}
comment|/* Note: even if the node existed before, it may not have      pristine props (e.g a local-add)  */
if|if
condition|(
name|current_base_props
operator|==
name|NULL
condition|)
name|current_base_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* And new nodes need an empty set of ACTUAL props.  */
if|if
condition|(
name|current_actual_props
operator|==
name|NULL
condition|)
name|current_actual_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|prop_state
operator|=
name|svn_wc_notify_state_unknown
expr_stmt|;
if|if
condition|(
operator|!
name|fb
operator|->
name|shadowed
condition|)
block|{
name|svn_boolean_t
name|install_pristine
decl_stmt|;
specifier|const
name|char
modifier|*
name|install_from
init|=
name|NULL
decl_stmt|;
comment|/* Merge the 'regular' props into the existing working proplist. */
comment|/* This will merge the old and new props into a new prop db, and          write<cp> commands to the logfile to install the merged          props.  */
name|new_base_props
operator|=
name|svn_prop__patch
argument_list|(
name|current_base_props
argument_list|,
name|regular_prop_changes
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__merge_props
argument_list|(
operator|&
name|conflict_skel
argument_list|,
operator|&
name|prop_state
argument_list|,
operator|&
name|new_actual_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|NULL
comment|/* server_baseprops (update, not merge)  */
argument_list|,
name|current_base_props
argument_list|,
name|current_actual_props
argument_list|,
name|regular_prop_changes
argument_list|,
comment|/* propchanges */
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We will ALWAYS have properties to save (after a not-dry-run merge). */
name|SVN_ERR_ASSERT
argument_list|(
name|new_base_props
operator|!=
name|NULL
operator|&&
name|new_actual_props
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Merge the text. This will queue some additional work.  */
if|if
condition|(
operator|!
name|fb
operator|->
name|obstruction_found
operator|&&
operator|!
name|fb
operator|->
name|edit_obstructed
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|merge_file
argument_list|(
operator|&
name|work_item
argument_list|,
operator|&
name|conflict_skel
argument_list|,
operator|&
name|install_pristine
argument_list|,
operator|&
name|install_from
argument_list|,
operator|&
name|content_state
argument_list|,
name|fb
argument_list|,
name|current_actual_props
argument_list|,
name|fb
operator|->
name|changed_date
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_ACCESS_DENIED
condition|)
block|{
if|if
condition|(
name|eb
operator|->
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|fb
operator|->
name|local_abspath
argument_list|,
name|svn_wc_notify_update_skip_access_denied
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|notify
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|eb
operator|->
name|notify_func
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remember_skipped_tree
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|skip_this
operator|=
name|TRUE
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|maybe_release_dir_info
argument_list|(
name|pdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|install_pristine
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|new_text_base_sha1_checksum
condition|)
name|content_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
else|else
name|content_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
block|}
if|if
condition|(
name|install_pristine
condition|)
block|{
name|svn_boolean_t
name|record_fileinfo
decl_stmt|;
comment|/* If we are installing from the pristine contents, then go ahead and              record the fileinfo. That will be the "proper" values. Installing              from some random file means the fileinfo does NOT correspond to              the pristine (in which case, the fileinfo will be cleared for              safety's sake).  */
name|record_fileinfo
operator|=
operator|(
name|install_from
operator|==
name|NULL
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|install_from
argument_list|,
name|eb
operator|->
name|use_commit_times
argument_list|,
name|record_fileinfo
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock_state
operator|==
name|svn_wc_notify_lock_state_unlocked
operator|&&
operator|!
name|fb
operator|->
name|obstruction_found
condition|)
block|{
comment|/* If a lock was removed and we didn't update the text contents, we              might need to set the file read-only.               Note: this will also update the executable flag, but ... meh.  */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_sync_file_flags
argument_list|(
operator|&
name|work_item
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|install_pristine
operator|&&
operator|(
name|content_state
operator|==
name|svn_wc_notify_state_unchanged
operator|)
condition|)
block|{
comment|/* It is safe to keep the current recorded timestamp and size */
name|keep_recorded_info
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Clean up any temporary files.  */
comment|/* Remove the INSTALL_FROM file, as long as it doesn't refer to the          working file.  */
if|if
condition|(
name|install_from
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|install_from
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|install_from
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Adding or updating a BASE node under a locally added node. */
name|apr_hash_t
modifier|*
name|fake_actual_props
decl_stmt|;
if|if
condition|(
name|fb
operator|->
name|adding_file
condition|)
name|fake_actual_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|fake_actual_props
operator|=
name|current_base_props
expr_stmt|;
comment|/* Store the incoming props (sent as propchanges) in new_base_props          and create a set of new actual props to use for notifications */
name|new_base_props
operator|=
name|svn_prop__patch
argument_list|(
name|current_base_props
argument_list|,
name|regular_prop_changes
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__merge_props
argument_list|(
operator|&
name|conflict_skel
argument_list|,
operator|&
name|prop_state
argument_list|,
operator|&
name|new_actual_props
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|NULL
comment|/* server_baseprops (not merging) */
argument_list|,
name|current_base_props
comment|/* pristine_props */
argument_list|,
name|fake_actual_props
comment|/* actual_props */
argument_list|,
name|regular_prop_changes
argument_list|,
comment|/* propchanges */
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|new_text_base_sha1_checksum
condition|)
name|content_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
else|else
name|content_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
block|}
comment|/* Insert/replace the BASE node with all of the new metadata.  */
comment|/* Set the 'checksum' column of the file's BASE_NODE row to    * NEW_TEXT_BASE_SHA1_CHECKSUM.  The pristine text identified by that    * checksum is already in the pristine store. */
name|new_checksum
operator|=
name|fb
operator|->
name|new_text_base_sha1_checksum
expr_stmt|;
comment|/* If we don't have a NEW checksum, then the base must not have changed.      Just carry over the old checksum.  */
if|if
condition|(
name|new_checksum
operator|==
name|NULL
condition|)
name|new_checksum
operator|=
name|fb
operator|->
name|original_checksum
expr_stmt|;
if|if
condition|(
name|conflict_skel
condition|)
block|{
name|SVN_ERR
argument_list|(
name|complete_conflict
argument_list|(
name|conflict_skel
argument_list|,
name|fb
operator|->
name|edit_baton
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|fb
operator|->
name|old_repos_relpath
argument_list|,
name|fb
operator|->
name|old_revision
argument_list|,
name|fb
operator|->
name|new_relpath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_node_file
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_create_markers
argument_list|(
operator|&
name|work_item
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Any inherited props to be set set for this base node? */
if|if
condition|(
name|eb
operator|->
name|wcroot_iprops
condition|)
block|{
name|iprops
operator|=
name|svn_hash_gets
argument_list|(
name|eb
operator|->
name|wcroot_iprops
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
comment|/* close_edit may also update iprops for switched nodes, catching          those for which close_directory is never called (e.g. a switch          with no changes).  So as a minor optimization we remove any          iprops from the hash so as not to set them again in          close_edit. */
if|if
condition|(
name|iprops
condition|)
name|svn_hash_sets
argument_list|(
name|eb
operator|->
name|wcroot_iprops
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_add_file
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|eb
operator|->
name|wcroot_abspath
argument_list|,
name|fb
operator|->
name|new_relpath
argument_list|,
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
name|eb
operator|->
name|target_revision
argument_list|,
name|new_base_props
argument_list|,
name|fb
operator|->
name|changed_rev
argument_list|,
name|fb
operator|->
name|changed_date
argument_list|,
name|fb
operator|->
name|changed_author
argument_list|,
name|new_checksum
argument_list|,
operator|(
name|dav_prop_changes
operator|->
name|nelts
operator|>
literal|0
operator|)
condition|?
name|svn_prop_array_to_hash
argument_list|(
name|dav_prop_changes
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|NULL
argument_list|,
operator|(
name|fb
operator|->
name|add_existed
operator|&&
name|fb
operator|->
name|adding_file
operator|)
argument_list|,
operator|(
operator|!
name|fb
operator|->
name|shadowed
operator|)
operator|&&
name|new_base_props
argument_list|,
name|new_actual_props
argument_list|,
name|iprops
argument_list|,
name|keep_recorded_info
argument_list|,
operator|(
name|fb
operator|->
name|shadowed
operator|&&
name|fb
operator|->
name|obstruction_found
operator|)
argument_list|,
name|conflict_skel
argument_list|,
name|all_work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_skel
operator|&&
name|eb
operator|->
name|conflict_func
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_invoke_resolver
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|fb
operator|->
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|NULL
comment|/* merge_options */
argument_list|,
name|eb
operator|->
name|conflict_func
argument_list|,
name|eb
operator|->
name|conflict_baton
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Deal with the WORKING tree, based on updates to the BASE tree.  */
name|svn_hash_sets
argument_list|(
name|fb
operator|->
name|dir_baton
operator|->
name|not_present_files
argument_list|,
name|fb
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Send a notification to the callback function.  (Skip notifications      about files which were already notified for another reason.) */
if|if
condition|(
name|eb
operator|->
name|notify_func
operator|&&
operator|!
name|fb
operator|->
name|already_notified
operator|&&
operator|(
name|fb
operator|->
name|edited
operator|||
name|lock_state
operator|==
name|svn_wc_notify_lock_state_unlocked
operator|)
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_wc_notify_action_t
name|action
init|=
name|svn_wc_notify_update_update
decl_stmt|;
if|if
condition|(
name|fb
operator|->
name|edited
condition|)
block|{
if|if
condition|(
name|fb
operator|->
name|shadowed
operator|||
name|fb
operator|->
name|edit_obstructed
condition|)
name|action
operator|=
name|fb
operator|->
name|adding_file
condition|?
name|svn_wc_notify_update_shadowed_add
else|:
name|svn_wc_notify_update_shadowed_update
expr_stmt|;
elseif|else
if|if
condition|(
name|fb
operator|->
name|obstruction_found
operator|||
name|fb
operator|->
name|add_existed
condition|)
block|{
if|if
condition|(
name|content_state
operator|!=
name|svn_wc_notify_state_conflicted
condition|)
name|action
operator|=
name|svn_wc_notify_exists
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fb
operator|->
name|adding_file
condition|)
block|{
name|action
operator|=
name|svn_wc_notify_update_add
expr_stmt|;
block|}
block|}
else|else
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|lock_state
operator|==
name|svn_wc_notify_lock_state_unlocked
argument_list|)
expr_stmt|;
name|action
operator|=
name|svn_wc_notify_update_broken_lock
expr_stmt|;
block|}
comment|/* If the file was moved-away, notify for the moved-away node.        * The original location only had its BASE info changed and        * we don't usually notify about such changes. */
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|fb
operator|->
name|local_abspath
argument_list|,
name|action
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|content_state
expr_stmt|;
name|notify
operator|->
name|prop_state
operator|=
name|prop_state
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|lock_state
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
operator|*
name|eb
operator|->
name|target_revision
expr_stmt|;
name|notify
operator|->
name|old_revision
operator|=
name|fb
operator|->
name|old_revision
expr_stmt|;
comment|/* Fetch the mimetype from the actual properties */
name|notify
operator|->
name|mime_type
operator|=
name|svn_prop_get_value
argument_list|(
name|new_actual_props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
expr_stmt|;
name|eb
operator|->
name|notify_func
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Destroy scratch_pool */
comment|/* We have one less referrer to the directory */
name|SVN_ERR
argument_list|(
name|maybe_release_dir_info
argument_list|(
name|pdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|eb
operator|->
name|pool
decl_stmt|;
comment|/* The editor didn't even open the root; we have to take care of      some cleanup stuffs. */
if|if
condition|(
operator|!
name|eb
operator|->
name|root_opened
operator|&&
operator|*
name|eb
operator|->
name|target_basename
operator|==
literal|'\0'
condition|)
block|{
comment|/* We need to "un-incomplete" the root directory. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_op_end_directory_update
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* By definition, anybody "driving" this editor for update or switch      purposes at a *minimum* must have called set_target_revision() at      the outset, and close_edit() at the end -- even if it turned out      that no changes ever had to be made, and open_root() was never      called.  That's fine.  But regardless, when the edit is over,      this editor needs to make sure that *all* paths have had their      revisions bumped to the new target revision. */
comment|/* Make sure our update target now has the new working revision.      Also, if this was an 'svn switch', then rewrite the target's      url.  All of this tweaking might happen recursively!  Note      that if eb->target is NULL, that's okay (albeit "sneaky",      some might say).  */
comment|/* Extra check: if the update did nothing but make its target      'deleted', then do *not* run cleanup on the target, as it      will only remove the deleted entry!  */
if|if
condition|(
operator|!
name|eb
operator|->
name|target_deleted
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_bump_revisions_post_update
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|eb
operator|->
name|requested_depth
argument_list|,
name|eb
operator|->
name|switch_relpath
argument_list|,
name|eb
operator|->
name|repos_root
argument_list|,
name|eb
operator|->
name|repos_uuid
argument_list|,
operator|*
operator|(
name|eb
operator|->
name|target_revision
operator|)
argument_list|,
name|eb
operator|->
name|skipped_trees
argument_list|,
name|eb
operator|->
name|wcroot_iprops
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eb
operator|->
name|target_basename
operator|!=
literal|'\0'
condition|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Note: we are fetching information about the *target*, not anchor.              There is no guarantee that the target has a BASE node.              For example:                 The node was not present in BASE, but locally-added, and the                update did not create a new BASE node "under" the local-add.               If there is no BASE node for the target, then we certainly don't              have to worry about removing it. */
name|err
operator|=
name|svn_wc__db_base_get_info
argument_list|(
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_excluded
condition|)
block|{
comment|/* There is a small chance that the explicit target of an update/                  switch is gone in the repository, in that specific case the                  node hasn't been re-added to the BASE tree by this update.                   If so, we should get rid of this excluded node now. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_remove
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|FALSE
comment|/* keep_as_working */
argument_list|,
name|FALSE
comment|/* queue_deletes */
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The edit is over: run the wq with proper cancel support,      but first kill the handler that would run it on the pool      cleanup at the end of this function. */
name|apr_pool_cleanup_kill
argument_list|(
name|eb
operator|->
name|pool
argument_list|,
name|eb
argument_list|,
name|cleanup_edit_baton
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|wcroot_abspath
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The edit is over, free its pool.      ### No, this is wrong.  Who says this editor/baton won't be used      again?  But the change is not merely to remove this call.  We      should also make eb->pool not be a subpool (see make_editor),      and change callers of svn_client_{checkout,update,switch} to do      better pool management. ### */
name|svn_pool_destroy
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Returning editors. ***/
end_comment

begin_comment
comment|/* Helper for the three public editor-supplying functions. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_editor
parameter_list|(
name|svn_revnum_t
modifier|*
name|target_revision
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target_basename
parameter_list|,
name|apr_hash_t
modifier|*
name|wcroot_iprops
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|depth_is_sticky
parameter_list|,
name|svn_boolean_t
name|allow_unver_obstructions
parameter_list|,
name|svn_boolean_t
name|adds_as_modification
parameter_list|,
name|svn_boolean_t
name|server_performs_filtering
parameter_list|,
name|svn_boolean_t
name|clean_checkout
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_dirents_func_t
name|fetch_dirents_func
parameter_list|,
name|void
modifier|*
name|fetch_dirents_baton
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|svn_wc_external_update_t
name|external_func
parameter_list|,
name|void
modifier|*
name|external_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|diff3_cmd
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|preserved_exts
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
decl_stmt|;
name|void
modifier|*
name|inner_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|edit_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_delta_editor_t
modifier|*
name|tree_editor
init|=
name|svn_delta_default_editor
argument_list|(
name|edit_pool
argument_list|)
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|inner_editor
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|,
modifier|*
name|repos_uuid
decl_stmt|;
name|struct
name|svn_wc__shim_fetch_baton_t
modifier|*
name|sfb
decl_stmt|;
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|edit_pool
argument_list|)
decl_stmt|;
comment|/* An unknown depth can't be sticky. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth_is_sticky
operator|=
name|FALSE
expr_stmt|;
comment|/* Get the anchor's repository root and uuid. The anchor must already exist      in BASE. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
name|NULL
argument_list|,
operator|&
name|repos_root
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|db
argument_list|,
name|anchor_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* With WC-NG we need a valid repository root */
name|SVN_ERR_ASSERT
argument_list|(
name|repos_root
operator|!=
name|NULL
operator|&&
name|repos_uuid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Disallow a switch operation to change the repository root of the target,      if that is known. */
if|if
condition|(
name|switch_url
operator|&&
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|repos_root
argument_list|,
name|switch_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_INVALID_SWITCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s'\nis not the same repository as\n'%s'"
argument_list|)
argument_list|,
name|switch_url
argument_list|,
name|repos_root
argument_list|)
return|;
comment|/* Construct an edit baton. */
name|eb
operator|=
name|apr_pcalloc
argument_list|(
name|edit_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|pool
operator|=
name|edit_pool
expr_stmt|;
name|eb
operator|->
name|use_commit_times
operator|=
name|use_commit_times
expr_stmt|;
name|eb
operator|->
name|target_revision
operator|=
name|target_revision
expr_stmt|;
name|eb
operator|->
name|repos_root
operator|=
name|repos_root
expr_stmt|;
name|eb
operator|->
name|repos_uuid
operator|=
name|repos_uuid
expr_stmt|;
name|eb
operator|->
name|db
operator|=
name|db
expr_stmt|;
name|eb
operator|->
name|target_basename
operator|=
name|target_basename
expr_stmt|;
name|eb
operator|->
name|anchor_abspath
operator|=
name|anchor_abspath
expr_stmt|;
name|eb
operator|->
name|wcroot_iprops
operator|=
name|wcroot_iprops
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|eb
operator|->
name|wcroot_abspath
argument_list|,
name|db
argument_list|,
name|anchor_abspath
argument_list|,
name|edit_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|switch_url
condition|)
name|eb
operator|->
name|switch_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root
argument_list|,
name|switch_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|eb
operator|->
name|switch_relpath
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|svn_path_is_empty
argument_list|(
name|target_basename
argument_list|)
condition|)
name|eb
operator|->
name|target_abspath
operator|=
name|eb
operator|->
name|anchor_abspath
expr_stmt|;
else|else
name|eb
operator|->
name|target_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|target_basename
argument_list|,
name|edit_pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|requested_depth
operator|=
name|depth
expr_stmt|;
name|eb
operator|->
name|depth_is_sticky
operator|=
name|depth_is_sticky
expr_stmt|;
name|eb
operator|->
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|eb
operator|->
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|eb
operator|->
name|external_func
operator|=
name|external_func
expr_stmt|;
name|eb
operator|->
name|external_baton
operator|=
name|external_baton
expr_stmt|;
name|eb
operator|->
name|diff3_cmd
operator|=
name|diff3_cmd
expr_stmt|;
name|eb
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|eb
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|eb
operator|->
name|conflict_func
operator|=
name|conflict_func
expr_stmt|;
name|eb
operator|->
name|conflict_baton
operator|=
name|conflict_baton
expr_stmt|;
name|eb
operator|->
name|allow_unver_obstructions
operator|=
name|allow_unver_obstructions
expr_stmt|;
name|eb
operator|->
name|adds_as_modification
operator|=
name|adds_as_modification
expr_stmt|;
name|eb
operator|->
name|clean_checkout
operator|=
name|clean_checkout
expr_stmt|;
name|eb
operator|->
name|skipped_trees
operator|=
name|apr_hash_make
argument_list|(
name|edit_pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|dir_dirents
operator|=
name|apr_hash_make
argument_list|(
name|edit_pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|ext_patterns
operator|=
name|preserved_exts
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|edit_pool
argument_list|,
name|eb
argument_list|,
name|cleanup_edit_baton
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* Construct an editor. */
name|tree_editor
operator|->
name|set_target_revision
operator|=
name|set_target_revision
expr_stmt|;
name|tree_editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|tree_editor
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|tree_editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|tree_editor
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
name|tree_editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|tree_editor
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|tree_editor
operator|->
name|absent_directory
operator|=
name|absent_directory
expr_stmt|;
name|tree_editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|tree_editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|tree_editor
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|tree_editor
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|tree_editor
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|tree_editor
operator|->
name|absent_file
operator|=
name|absent_file
expr_stmt|;
name|tree_editor
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
comment|/* Fiddle with the type system. */
name|inner_editor
operator|=
name|tree_editor
expr_stmt|;
name|inner_baton
operator|=
name|eb
expr_stmt|;
if|if
condition|(
operator|!
name|depth_is_sticky
operator|&&
name|depth
operator|!=
name|svn_depth_unknown
operator|&&
name|svn_depth_empty
operator|<=
name|depth
operator|&&
name|depth
operator|<
name|svn_depth_infinity
operator|&&
name|fetch_dirents_func
condition|)
block|{
comment|/* We are asked to perform an update at a depth less than the ambient          depth. In this case the update won't describe additions that would          have been reported if we updated at the ambient depth. */
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_node_kind_t
name|dir_kind
decl_stmt|;
name|svn_wc__db_status_t
name|dir_status
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_repos_relpath
decl_stmt|;
name|svn_depth_t
name|dir_depth
decl_stmt|;
comment|/* we have to do this on the target of the update, not the anchor */
name|err
operator|=
name|svn_wc__db_base_get_info
argument_list|(
operator|&
name|dir_status
argument_list|,
operator|&
name|dir_kind
argument_list|,
name|NULL
argument_list|,
operator|&
name|dir_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dir_depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|dir_kind
operator|==
name|svn_node_dir
operator|&&
name|dir_status
operator|==
name|svn_wc__db_status_normal
condition|)
block|{
if|if
condition|(
name|dir_depth
operator|>
name|depth
condition|)
block|{
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
comment|/* If we switch, we should look at the new relpath */
if|if
condition|(
name|eb
operator|->
name|switch_relpath
condition|)
name|dir_repos_relpath
operator|=
name|eb
operator|->
name|switch_relpath
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fetch_dirents_func
argument_list|(
name|fetch_dirents_baton
argument_list|,
operator|&
name|dirents
argument_list|,
name|repos_root
argument_list|,
name|dir_repos_relpath
argument_list|,
name|edit_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirents
operator|!=
name|NULL
operator|&&
name|apr_hash_count
argument_list|(
name|dirents
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|eb
operator|->
name|dir_dirents
argument_list|,
name|apr_pstrdup
argument_list|(
name|edit_pool
argument_list|,
name|dir_repos_relpath
argument_list|)
argument_list|,
name|dirents
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|==
name|svn_depth_immediates
condition|)
block|{
comment|/* Worst case scenario of issue #3569 fix: We have to do the                  same for all existing subdirs, but then we check for                  svn_depth_empty. */
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_children
argument_list|(
operator|&
name|children
argument_list|,
name|db
argument_list|,
name|eb
operator|->
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_name
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|child_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|target_abspath
argument_list|,
name|child_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info
argument_list|(
operator|&
name|dir_status
argument_list|,
operator|&
name|dir_kind
argument_list|,
name|NULL
argument_list|,
operator|&
name|dir_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dir_depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|child_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_kind
operator|==
name|svn_node_dir
operator|&&
name|dir_status
operator|==
name|svn_wc__db_status_normal
operator|&&
name|dir_depth
operator|>
name|svn_depth_empty
condition|)
block|{
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
comment|/* If we switch, we should look at the new relpath */
if|if
condition|(
name|eb
operator|->
name|switch_relpath
condition|)
name|dir_repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|eb
operator|->
name|switch_relpath
argument_list|,
name|child_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fetch_dirents_func
argument_list|(
name|fetch_dirents_baton
argument_list|,
operator|&
name|dirents
argument_list|,
name|repos_root
argument_list|,
name|dir_repos_relpath
argument_list|,
name|edit_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirents
operator|!=
name|NULL
operator|&&
name|apr_hash_count
argument_list|(
name|dirents
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|eb
operator|->
name|dir_dirents
argument_list|,
name|apr_pstrdup
argument_list|(
name|edit_pool
argument_list|,
name|dir_repos_relpath
argument_list|)
argument_list|,
name|dirents
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* We need to limit the scope of our operation to the ambient depths      present in the working copy already, but only if the requested      depth is not sticky. If a depth was explicitly requested,      libsvn_delta/depth_filter_editor.c will ensure that we never see      editor calls that extend beyond the scope of the requested depth.      But even what we do so might extend beyond the scope of our      ambient depth.  So we use another filtering editor to avoid      modifying the ambient working copy depth when not asked to do so.      (This can also be skipped if the server understands depth.) */
if|if
condition|(
operator|!
name|server_performs_filtering
operator|&&
operator|!
name|depth_is_sticky
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__ambient_depth_filter_editor
argument_list|(
operator|&
name|inner_editor
argument_list|,
operator|&
name|inner_baton
argument_list|,
name|db
argument_list|,
name|anchor_abspath
argument_list|,
name|target_basename
argument_list|,
name|inner_editor
argument_list|,
name|inner_baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta_get_cancellation_editor
argument_list|(
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|inner_editor
argument_list|,
name|inner_baton
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|sfb
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sfb
argument_list|)
argument_list|)
expr_stmt|;
name|sfb
operator|->
name|db
operator|=
name|db
expr_stmt|;
name|sfb
operator|->
name|base_abspath
operator|=
name|eb
operator|->
name|anchor_abspath
expr_stmt|;
name|sfb
operator|->
name|fetch_base
operator|=
name|TRUE
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_kind_func
operator|=
name|svn_wc__fetch_kind_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_props_func
operator|=
name|svn_wc__fetch_props_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_base_func
operator|=
name|svn_wc__fetch_base_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_baton
operator|=
name|sfb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor__insert_shims
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|*
name|editor
argument_list|,
operator|*
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|shim_callbacks
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_update_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
modifier|*
name|target_revision
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target_basename
parameter_list|,
name|apr_hash_t
modifier|*
name|wcroot_iprops
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|depth_is_sticky
parameter_list|,
name|svn_boolean_t
name|allow_unver_obstructions
parameter_list|,
name|svn_boolean_t
name|adds_as_modification
parameter_list|,
name|svn_boolean_t
name|server_performs_filtering
parameter_list|,
name|svn_boolean_t
name|clean_checkout
parameter_list|,
specifier|const
name|char
modifier|*
name|diff3_cmd
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|preserved_exts
parameter_list|,
name|svn_wc_dirents_func_t
name|fetch_dirents_func
parameter_list|,
name|void
modifier|*
name|fetch_dirents_baton
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|svn_wc_external_update_t
name|external_func
parameter_list|,
name|void
modifier|*
name|external_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|make_editor
argument_list|(
name|target_revision
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|anchor_abspath
argument_list|,
name|target_basename
argument_list|,
name|wcroot_iprops
argument_list|,
name|use_commit_times
argument_list|,
name|NULL
argument_list|,
name|depth
argument_list|,
name|depth_is_sticky
argument_list|,
name|allow_unver_obstructions
argument_list|,
name|adds_as_modification
argument_list|,
name|server_performs_filtering
argument_list|,
name|clean_checkout
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|fetch_dirents_func
argument_list|,
name|fetch_dirents_baton
argument_list|,
name|conflict_func
argument_list|,
name|conflict_baton
argument_list|,
name|external_func
argument_list|,
name|external_baton
argument_list|,
name|diff3_cmd
argument_list|,
name|preserved_exts
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_switch_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
modifier|*
name|target_revision
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target_basename
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
name|apr_hash_t
modifier|*
name|wcroot_iprops
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|depth_is_sticky
parameter_list|,
name|svn_boolean_t
name|allow_unver_obstructions
parameter_list|,
name|svn_boolean_t
name|server_performs_filtering
parameter_list|,
specifier|const
name|char
modifier|*
name|diff3_cmd
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|preserved_exts
parameter_list|,
name|svn_wc_dirents_func_t
name|fetch_dirents_func
parameter_list|,
name|void
modifier|*
name|fetch_dirents_baton
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|svn_wc_external_update_t
name|external_func
parameter_list|,
name|void
modifier|*
name|external_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|switch_url
operator|&&
name|svn_uri_is_canonical
argument_list|(
name|switch_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|make_editor
argument_list|(
name|target_revision
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|anchor_abspath
argument_list|,
name|target_basename
argument_list|,
name|wcroot_iprops
argument_list|,
name|use_commit_times
argument_list|,
name|switch_url
argument_list|,
name|depth
argument_list|,
name|depth_is_sticky
argument_list|,
name|allow_unver_obstructions
argument_list|,
name|FALSE
comment|/* adds_as_modification */
argument_list|,
name|server_performs_filtering
argument_list|,
name|FALSE
comment|/* clean_checkout */
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|fetch_dirents_func
argument_list|,
name|fetch_dirents_baton
argument_list|,
name|conflict_func
argument_list|,
name|conflict_baton
argument_list|,
name|external_func
argument_list|,
name|external_baton
argument_list|,
name|diff3_cmd
argument_list|,
name|preserved_exts
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ### Note that this function is completely different from the rest of the        update editor in what it updates. The update editor changes only BASE        and ACTUAL and this function just changes WORKING and ACTUAL.         In the entries world this function shared a lot of code with the        update editor but in the wonderful new WC-NG world it will probably        do more and more by itself and would be more logically grouped with        the add/copy functionality in adm_ops.c and copy.c. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc_add_repos_file4
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_stream_t
modifier|*
name|new_base_contents
parameter_list|,
name|svn_stream_t
modifier|*
name|new_contents
parameter_list|,
name|apr_hash_t
modifier|*
name|new_base_props
parameter_list|,
name|apr_hash_t
modifier|*
name|new_props
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_url
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_text_base_abspath
decl_stmt|;
name|svn_checksum_t
modifier|*
name|new_text_base_md5_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|new_text_base_sha1_checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_abspath
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|all_work_items
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_repos_relpath
decl_stmt|;
name|svn_revnum_t
name|changed_rev
decl_stmt|;
name|apr_time_t
name|changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|changed_author
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|scratch_pool
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|new_base_contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|new_base_props
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We should have a write lock on this file's parent directory.  */
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
elseif|else
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|svn_wc__db_status_not_present
case|:
case|case
name|svn_wc__db_status_deleted
case|:
break|break;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node '%s' exists."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|svn_wc__db_status_normal
case|:
case|case
name|svn_wc__db_status_added
case|:
break|break;
case|case
name|svn_wc__db_status_deleted
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_SCHEDULE_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't add '%s' to a parent directory"
literal|" scheduled for deletion"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Can't find parent directory's node while"
literal|" trying to add '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't schedule an addition of '%s'"
literal|" below a not-directory node"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* Fabricate the anticipated new URL of the target and check the      copyfrom URL to be in the same repository. */
if|if
condition|(
name|copyfrom_url
operator|!=
name|NULL
condition|)
block|{
comment|/* Find the repository_root via the parent directory, which          is always versioned before this function is called */
if|if
condition|(
operator|!
name|repos_root_url
condition|)
block|{
comment|/* The parent is an addition, scan upwards to find the right info */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|repos_root_url
argument_list|)
expr_stmt|;
name|original_repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|copyfrom_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|original_repos_relpath
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Copyfrom-url '%s' has different repository"
literal|" root than '%s'"
argument_list|)
argument_list|,
name|copyfrom_url
argument_list|,
name|repos_root_url
argument_list|)
return|;
block|}
else|else
block|{
name|original_repos_relpath
operator|=
name|NULL
expr_stmt|;
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Just to be sure.  */
block|}
comment|/* Set CHANGED_* to reflect the entry props in NEW_BASE_PROPS, and      filter NEW_BASE_PROPS so it contains only regular props. */
block|{
name|apr_array_header_t
modifier|*
name|regular_props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entry_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|svn_prop_hash_to_array
argument_list|(
name|new_base_props
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|entry_props
argument_list|,
name|NULL
argument_list|,
operator|&
name|regular_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put regular props back into a hash table. */
name|new_base_props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|regular_props
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Get the change_* info from the entry props.  */
name|SVN_ERR
argument_list|(
name|accumulate_last_change
argument_list|(
operator|&
name|changed_rev
argument_list|,
operator|&
name|changed_date
argument_list|,
operator|&
name|changed_author
argument_list|,
name|entry_props
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy NEW_BASE_CONTENTS into a temporary file so our log can refer to      it, and set TMP_TEXT_BASE_ABSPATH to its path.  Compute its      NEW_TEXT_BASE_MD5_CHECKSUM and NEW_TEXT_BASE_SHA1_CHECKSUM as we copy. */
block|{
name|svn_stream_t
modifier|*
name|tmp_base_contents
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__open_writable_base
argument_list|(
operator|&
name|tmp_base_contents
argument_list|,
operator|&
name|tmp_text_base_abspath
argument_list|,
operator|&
name|new_text_base_md5_checksum
argument_list|,
operator|&
name|new_text_base_sha1_checksum
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|new_base_contents
argument_list|,
name|tmp_base_contents
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the caller gave us a new working file, copy it to a safe (temporary)      location and set SOURCE_ABSPATH to that path. We'll then translate/copy      that into place after the node's state has been created.  */
if|if
condition|(
name|new_contents
condition|)
block|{
specifier|const
name|char
modifier|*
name|temp_dir_abspath
decl_stmt|;
name|svn_stream_t
modifier|*
name|tmp_contents
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|temp_dir_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|tmp_contents
argument_list|,
operator|&
name|source_abspath
argument_list|,
name|temp_dir_abspath
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|new_contents
argument_list|,
name|tmp_contents
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Install new text base for copied files. Added files do NOT have a      text base.  */
if|if
condition|(
name|copyfrom_url
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_install
argument_list|(
name|db
argument_list|,
name|tmp_text_base_abspath
argument_list|,
name|new_text_base_sha1_checksum
argument_list|,
name|new_text_base_md5_checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ### There's something wrong around here.  Sometimes (merge from a          foreign repository, at least) we are called with copyfrom_url =          NULL and an empty new_base_contents (and an empty set of          new_base_props).  Why an empty "new base"?           That happens in merge_tests.py 54,87,88,89,143.           In that case, having been given this supposed "new base" file, we          copy it and calculate its checksum but do not install it.  Why?          That must be wrong.           To crudely work around one issue with this, that we shouldn't          record a checksum in the database if we haven't installed the          corresponding pristine text, for now we'll just set the checksum          to NULL.           The proper solution is probably more like: the caller should pass          NULL for the missing information, and this function should learn to          handle that. */
name|new_text_base_sha1_checksum
operator|=
name|NULL
expr_stmt|;
name|new_text_base_md5_checksum
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* For added files without NEW_CONTENTS, then generate the working file      from the provided "pristine" contents.  */
if|if
condition|(
name|new_contents
operator|==
name|NULL
operator|&&
name|copyfrom_url
operator|==
name|NULL
condition|)
name|source_abspath
operator|=
name|tmp_text_base_abspath
expr_stmt|;
block|{
name|svn_boolean_t
name|record_fileinfo
decl_stmt|;
comment|/* If new contents were provided, then we do NOT want to record the        file information. We assume the new contents do not match the        "proper" values for RECORDED_SIZE and RECORDED_TIME.  */
name|record_fileinfo
operator|=
operator|(
name|new_contents
operator|==
name|NULL
operator|)
expr_stmt|;
comment|/* Install the working copy file (with appropriate translation) from        the appropriate source. SOURCE_ABSPATH will be NULL, indicating an        installation from the pristine (available for copied/moved files),        or it will specify a temporary file where we placed a "pristine"        (for an added file) or a detranslated local-mods file.  */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|source_abspath
argument_list|,
name|FALSE
comment|/* use_commit_times */
argument_list|,
name|record_fileinfo
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we installed from somewhere besides the official pristine, then        it is a temporary file, which needs to be removed.  */
if|if
condition|(
name|source_abspath
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|source_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|all_work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|all_work_items
argument_list|,
name|work_item
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ### ideally, we would have a single DB operation, and queue the work      ### items on that. for now, we'll queue them with the second call.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_copy_file
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|new_base_props
argument_list|,
name|changed_rev
argument_list|,
name|changed_date
argument_list|,
name|changed_author
argument_list|,
name|original_repos_relpath
argument_list|,
name|original_repos_relpath
condition|?
name|repos_root_url
else|:
name|NULL
argument_list|,
name|original_repos_relpath
condition|?
name|repos_uuid
else|:
name|NULL
argument_list|,
name|copyfrom_rev
argument_list|,
name|new_text_base_sha1_checksum
argument_list|,
name|TRUE
argument_list|,
name|new_props
argument_list|,
name|FALSE
comment|/* is_move */
argument_list|,
name|NULL
comment|/* conflict */
argument_list|,
name|all_work_items
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__complete_directory_add
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|new_original_props
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_url
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_uuid
decl_stmt|;
name|svn_boolean_t
name|had_props
decl_stmt|;
name|svn_boolean_t
name|props_mod
decl_stmt|;
name|svn_revnum_t
name|original_revision
decl_stmt|;
name|svn_revnum_t
name|changed_rev
decl_stmt|;
name|apr_time_t
name|changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|changed_author
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|original_repos_relpath
argument_list|,
operator|&
name|original_root_url
argument_list|,
operator|&
name|original_uuid
argument_list|,
operator|&
name|original_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|had_props
argument_list|,
operator|&
name|props_mod
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|svn_wc__db_status_added
operator|||
name|kind
operator|!=
name|svn_node_dir
operator|||
name|had_props
operator|||
name|props_mod
operator|||
operator|!
name|original_repos_relpath
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not an unmodified copied directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|original_revision
operator|!=
name|copyfrom_rev
operator|||
name|strcmp
argument_list|(
name|copyfrom_url
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|original_root_url
argument_list|,
name|original_repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Copyfrom '%s' doesn't match original location of '%s'"
argument_list|)
argument_list|,
name|copyfrom_url
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|{
name|apr_array_header_t
modifier|*
name|regular_props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entry_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|svn_prop_hash_to_array
argument_list|(
name|new_original_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|&
name|entry_props
argument_list|,
name|NULL
argument_list|,
operator|&
name|regular_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put regular props back into a hash table. */
name|new_original_props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|regular_props
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Get the change_* info from the entry props.  */
name|SVN_ERR
argument_list|(
name|accumulate_last_change
argument_list|(
operator|&
name|changed_rev
argument_list|,
operator|&
name|changed_date
argument_list|,
operator|&
name|changed_author
argument_list|,
name|entry_props
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_op_copy_dir
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|new_original_props
argument_list|,
name|changed_rev
argument_list|,
name|changed_date
argument_list|,
name|changed_author
argument_list|,
name|original_repos_relpath
argument_list|,
name|original_root_url
argument_list|,
name|original_uuid
argument_list|,
name|original_revision
argument_list|,
name|NULL
comment|/* children */
argument_list|,
name|FALSE
comment|/* is_move */
argument_list|,
name|svn_depth_infinity
argument_list|,
name|NULL
comment|/* conflict */
argument_list|,
name|NULL
comment|/* work_items */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

