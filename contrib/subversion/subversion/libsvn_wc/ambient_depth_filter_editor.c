begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ambient_depth_filter_editor.c -- provide a svn_delta_editor_t which wraps  *                                  another editor and provides  *                                  *ambient* depth-based filtering  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_comment
comment|/*      Notes on the general depth-filtering strategy.      ==============================================       When a depth-aware (>= 1.5) client pulls an update from a      non-depth-aware server, the server may send back too much data,      because it doesn't hear what the client tells it about the      "requested depth" of the update (the "foo" in "--depth=foo"), nor      about the "ambient depth" of each working copy directory.       For example, suppose a 1.5 client does this against a 1.4 server:         $ svn co --depth=empty -rSOME_OLD_REV http://url/repos/blah/ wc        $ cd wc        $ svn up       In the initial checkout, the requested depth is 'empty', so the      depth-filtering editor (see libsvn_delta/depth_filter_editor.c)      that wraps the main update editor transparently filters out all      the unwanted calls.       In the 'svn up', the requested depth is unspecified, meaning that      the ambient depth(s) of the working copy should be preserved.      Since there's only one directory, and its depth is 'empty',      clearly we should filter out or render no-ops all editor calls      after open_root(), except maybe for change_dir_prop() on the      top-level directory.  (Note that the server will have stuff to      send down, because we checked out at an old revision in the first      place, to set up this scenario.)       The depth-filtering editor won't help us here.  It only filters      based on the requested depth, it never looks in the working copy      to get ambient depths.  So the update editor itself will have to      filter out the unwanted calls -- or better yet, it will have to      be wrapped in a filtering editor that does the job.       This is that filtering editor.       Most of the work is done at the moment of baton construction.      When a file or dir is opened, we create its baton with the      appropriate ambient depth, either taking the depth directly from      the corresponding working copy object (if available), or from its      parent baton.  In the latter case, we don't just copy the parent      baton's depth, but rather use it to choose the correct depth for      this child.  The usual depth demotion rules apply, with the      additional stipulation that as soon as we find a subtree is not      present at all, due to being omitted for depth reasons, we set the      ambiently_excluded flag in its baton, which signals that      all descendant batons should be ignored.      (In fact, we may just re-use the parent baton, since none of the      other fields will be used anyway.)       See issues #2842 and #2897 for more. */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Batons, and the Toys That Create Them ***/
end_comment

begin_struct
struct|struct
name|edit_baton
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|wrapped_editor
decl_stmt|;
name|void
modifier|*
name|wrapped_edit_baton
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
specifier|const
name|char
modifier|*
name|anchor_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|file_baton
block|{
name|svn_boolean_t
name|ambiently_excluded
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
name|void
modifier|*
name|wrapped_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dir_baton
block|{
name|svn_boolean_t
name|ambiently_excluded
decl_stmt|;
name|svn_depth_t
name|ambient_depth
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|abspath
decl_stmt|;
name|void
modifier|*
name|wrapped_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Fetch the STATUS, KIND and DEPTH of the base node at LOCAL_ABSPATH.  * If there is no such base node, report 'normal', 'unknown' and 'unknown'  * respectively.  *  * STATUS and/or DEPTH may be NULL if not wanted; KIND must not be NULL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ambient_read_info
parameter_list|(
name|svn_wc__db_status_t
modifier|*
name|status
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|svn_depth_t
modifier|*
name|depth
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|kind
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_base_get_info
argument_list|(
name|status
argument_list|,
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|svn_wc__db_status_normal
expr_stmt|;
if|if
condition|(
name|depth
condition|)
operator|*
name|depth
operator|=
name|svn_depth_unknown
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_dir_baton
parameter_list|(
name|struct
name|dir_baton
modifier|*
modifier|*
name|d_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|pb
parameter_list|,
name|svn_boolean_t
name|added
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|d
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|path
operator|||
operator|(
operator|!
name|pb
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|&&
name|pb
operator|->
name|ambiently_excluded
condition|)
block|{
comment|/* Just re-use the parent baton, since the only field that          matters is ambiently_excluded. */
operator|*
name|d_p
operator|=
name|pb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Okay, no easy out, so allocate and initialize a dir baton. */
name|d
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|d
operator|->
name|abspath
operator|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|abspath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|eb
operator|->
name|anchor_abspath
argument_list|)
expr_stmt|;
comment|/* The svn_depth_unknown means that: 1) pb is the anchor; 2) there      is an non-null target, for which we are preparing the baton.      This enables explicitly pull in the target. */
if|if
condition|(
name|pb
operator|&&
name|pb
operator|->
name|ambient_depth
operator|!=
name|svn_depth_unknown
condition|)
block|{
name|svn_boolean_t
name|exclude
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|exists
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ambient_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|d
operator|->
name|abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|svn_wc__db_status_not_present
expr_stmt|;
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
block|}
name|exists
operator|=
operator|(
name|kind
operator|!=
name|svn_node_unknown
operator|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ambient_depth
operator|==
name|svn_depth_empty
operator|||
name|pb
operator|->
name|ambient_depth
operator|==
name|svn_depth_files
condition|)
block|{
comment|/* This is not a depth upgrade, and the parent directory is              depth==empty or depth==files.  So if the parent doesn't              already have an entry for the new dir, then the parent              doesn't want the new dir at all, thus we should initialize              it with ambiently_excluded=TRUE. */
name|exclude
operator|=
operator|!
name|exists
expr_stmt|;
block|}
else|else
block|{
comment|/* If the parent expect all children by default, only exclude              it whenever it is explicitly marked as exclude. */
name|exclude
operator|=
name|exists
operator|&&
operator|(
name|status
operator|==
name|svn_wc__db_status_excluded
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|exclude
condition|)
block|{
name|d
operator|->
name|ambiently_excluded
operator|=
name|TRUE
expr_stmt|;
operator|*
name|d_p
operator|=
name|d
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|d
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
comment|/* We'll initialize this differently in add_directory and      open_directory. */
name|d
operator|->
name|ambient_depth
operator|=
name|svn_depth_unknown
expr_stmt|;
operator|*
name|d_p
operator|=
name|d
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_file_baton
parameter_list|(
name|struct
name|file_baton
modifier|*
modifier|*
name|f_p
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|pb
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|added
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|f
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|abspath
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ambiently_excluded
condition|)
block|{
name|f
operator|->
name|ambiently_excluded
operator|=
name|TRUE
expr_stmt|;
operator|*
name|f_p
operator|=
name|f
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|abspath
operator|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ambient_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|svn_wc__db_status_not_present
expr_stmt|;
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
block|}
if|if
condition|(
name|pb
operator|->
name|ambient_depth
operator|==
name|svn_depth_empty
condition|)
block|{
comment|/* This is not a depth upgrade, and the parent directory is          depth==empty.  So if the parent doesn't          already have an entry for the file, then the parent          doesn't want to hear about the file at all. */
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|kind
operator|==
name|svn_node_unknown
condition|)
block|{
name|f
operator|->
name|ambiently_excluded
operator|=
name|TRUE
expr_stmt|;
operator|*
name|f_p
operator|=
name|f
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* If pb->ambient_depth == svn_depth_unknown we are pulling      in new nodes */
if|if
condition|(
name|pb
operator|->
name|ambient_depth
operator|!=
name|svn_depth_unknown
operator|&&
name|status
operator|==
name|svn_wc__db_status_excluded
condition|)
block|{
name|f
operator|->
name|ambiently_excluded
operator|=
name|TRUE
expr_stmt|;
operator|*
name|f_p
operator|=
name|f
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|f
operator|->
name|edit_baton
operator|=
name|pb
operator|->
name|edit_baton
expr_stmt|;
operator|*
name|f_p
operator|=
name|f
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Editor Functions ***/
end_comment

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_target_revision
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
comment|/* Nothing depth-y to filter here. */
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|set_target_revision
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|target_revision
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|b
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_dir_baton
argument_list|(
operator|&
name|b
argument_list|,
name|NULL
argument_list|,
name|eb
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_baton
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
operator|*
name|eb
operator|->
name|target
condition|)
block|{
comment|/* For an update with a NULL target, this is equivalent to open_dir(): */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_depth_t
name|depth
decl_stmt|;
comment|/* Read the depth from the entry. */
name|SVN_ERR
argument_list|(
name|ambient_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|depth
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_unknown
operator|&&
name|status
operator|!=
name|svn_wc__db_status_not_present
operator|&&
name|status
operator|!=
name|svn_wc__db_status_excluded
operator|&&
name|status
operator|!=
name|svn_wc__db_status_server_excluded
condition|)
block|{
name|b
operator|->
name|ambient_depth
operator|=
name|depth
expr_stmt|;
block|}
block|}
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_root
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|pb
operator|->
name|ambient_depth
operator|<
name|svn_depth_immediates
condition|)
block|{
comment|/* If the entry we want to delete doesn't exist, that's OK.          It's probably an old server that doesn't understand          depths. */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|abspath
decl_stmt|;
name|abspath
operator|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ambient_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_unknown
operator|||
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|delete_entry
argument_list|(
name|path
argument_list|,
name|base_revision
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_dir_baton
argument_list|(
operator|&
name|b
argument_list|,
name|path
argument_list|,
name|eb
argument_list|,
name|pb
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* It's not excluded, so what should we treat the ambient depth as      being? */
if|if
condition|(
name|strcmp
argument_list|(
name|eb
operator|->
name|target
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The target of the edit is being added, so make it          infinity. */
name|b
operator|->
name|ambient_depth
operator|=
name|svn_depth_infinity
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pb
operator|->
name|ambient_depth
operator|==
name|svn_depth_immediates
condition|)
block|{
name|b
operator|->
name|ambient_depth
operator|=
name|svn_depth_empty
expr_stmt|;
block|}
else|else
block|{
comment|/* There may be a requested depth< svn_depth_infinity, but          that's okay, libsvn_delta/depth_filter_editor.c will filter          further calls out for us anyway, and the update_editor will          do the right thing when it creates the directory. */
name|b
operator|->
name|ambient_depth
operator|=
name|svn_depth_infinity
expr_stmt|;
block|}
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|add_directory
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|b
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_depth_t
name|depth
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_dir_baton
argument_list|(
operator|&
name|b
argument_list|,
name|path
argument_list|,
name|eb
argument_list|,
name|pb
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_directory
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that for the update editor, the open_directory above will      flush the logs of pb's directory, which might be important for      this svn_wc_entry call. */
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|anchor_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ambient_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|depth
argument_list|,
name|eb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_unknown
operator|&&
name|status
operator|!=
name|svn_wc__db_status_not_present
operator|&&
name|status
operator|!=
name|svn_wc__db_status_excluded
operator|&&
name|status
operator|!=
name|svn_wc__db_status_server_excluded
condition|)
block|{
name|b
operator|->
name|ambient_depth
operator|=
name|depth
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_file_baton
argument_list|(
operator|&
name|b
argument_list|,
name|pb
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|add_file
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|b
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_file_baton
argument_list|(
operator|&
name|b
argument_list|,
name|pb
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_file
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
comment|/* For filtered files, we just consume the textdelta. */
if|if
condition|(
name|fb
operator|->
name|ambiently_excluded
condition|)
block|{
operator|*
name|handler
operator|=
name|svn_delta_noop_window_handler
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|apply_textdelta
argument_list|(
name|fb
operator|->
name|wrapped_baton
argument_list|,
name|base_checksum
argument_list|,
name|pool
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
if|if
condition|(
name|fb
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_file
argument_list|(
name|fb
operator|->
name|wrapped_baton
argument_list|,
name|text_checksum
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|absent_file
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
if|if
condition|(
name|db
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_directory
argument_list|(
name|db
operator|->
name|wrapped_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
comment|/* Don't report absent items in filtered directories. */
if|if
condition|(
name|pb
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|absent_directory
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
if|if
condition|(
name|fb
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|change_file_prop
argument_list|(
name|fb
operator|->
name|wrapped_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
if|if
condition|(
name|db
operator|->
name|ambiently_excluded
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|change_dir_prop
argument_list|(
name|db
operator|->
name|wrapped_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An svn_delta_editor_t function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_edit
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__ambient_depth_filter_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|wrapped_editor
parameter_list|,
name|void
modifier|*
name|wrapped_edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_delta_editor_t
modifier|*
name|depth_filter_editor
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|anchor_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|depth_filter_editor
operator|=
name|svn_delta_default_editor
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|depth_filter_editor
operator|->
name|set_target_revision
operator|=
name|set_target_revision
expr_stmt|;
name|depth_filter_editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|depth_filter_editor
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|depth_filter_editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|depth_filter_editor
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
name|depth_filter_editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|depth_filter_editor
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|depth_filter_editor
operator|->
name|absent_directory
operator|=
name|absent_directory
expr_stmt|;
name|depth_filter_editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|depth_filter_editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|depth_filter_editor
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|depth_filter_editor
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|depth_filter_editor
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|depth_filter_editor
operator|->
name|absent_file
operator|=
name|absent_file
expr_stmt|;
name|depth_filter_editor
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
name|eb
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|wrapped_editor
operator|=
name|wrapped_editor
expr_stmt|;
name|eb
operator|->
name|wrapped_edit_baton
operator|=
name|wrapped_edit_baton
expr_stmt|;
name|eb
operator|->
name|db
operator|=
name|db
expr_stmt|;
name|eb
operator|->
name|anchor_abspath
operator|=
name|anchor_abspath
expr_stmt|;
name|eb
operator|->
name|target
operator|=
name|target
expr_stmt|;
operator|*
name|editor
operator|=
name|depth_filter_editor
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|eb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

