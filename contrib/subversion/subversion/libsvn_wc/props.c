begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * props.c :  routines dealing with properties in the working copy  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"props.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Forward declaration.  */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|prop_conflict_from_skel
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|conflict_desc
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Given a *SINGLE* property conflict in PROP_SKEL, generate a description    for it, and write it to STREAM, along with a trailing EOL sequence.     See prop_conflict_from_skel() for details on PROP_SKEL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|append_prop_conflict
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|prop_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* TODO:  someday, perhaps prefix each conflict_description with a      timestamp or something? */
specifier|const
name|svn_string_t
modifier|*
name|conflict_desc
decl_stmt|;
name|SVN_ERR
argument_list|(
name|prop_conflict_from_skel
argument_list|(
operator|&
name|conflict_desc
argument_list|,
name|prop_skel
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
name|conflict_desc
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Merging propchanges into the working copy ***/
end_comment

begin_comment
comment|/* Parse FROM_PROP_VAL and TO_PROP_VAL into mergeinfo hashes, and    calculate the deltas between them. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|diff_mergeinfo_props
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|deleted
parameter_list|,
name|svn_mergeinfo_t
modifier|*
name|added
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|from_prop_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|to_prop_val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_string_compare
argument_list|(
name|from_prop_val
argument_list|,
name|to_prop_val
argument_list|)
condition|)
block|{
comment|/* Don't bothering parsing identical mergeinfo. */
operator|*
name|deleted
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
operator|*
name|added
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_mergeinfo_t
name|from
decl_stmt|,
name|to
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|from
argument_list|,
name|from_prop_val
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|to
argument_list|,
name|to_prop_val
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_diff2
argument_list|(
name|deleted
argument_list|,
name|added
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the mergeinfo from PROP_VAL1 and PROP_VAL2, combine it, then    reconstitute it into *OUTPUT.  Call when the WC's mergeinfo has    been modified to combine it with incoming mergeinfo from the    repos. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|combine_mergeinfo_props
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|output
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|prop_val1
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|prop_val2
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|mergeinfo1
decl_stmt|,
name|mergeinfo2
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo1
argument_list|,
name|prop_val1
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo2
argument_list|,
name|prop_val2
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|mergeinfo1
argument_list|,
name|mergeinfo2
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|mergeinfo_string
argument_list|,
name|mergeinfo1
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|mergeinfo_string
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform a 3-way merge operation on mergeinfo.  FROM_PROP_VAL is    the "base" property value, WORKING_PROP_VAL is the current value,    and TO_PROP_VAL is the new value. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|combine_forked_mergeinfo_props
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|output
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|from_prop_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|working_prop_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|to_prop_val
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|from_mergeinfo
decl_stmt|,
name|l_deleted
decl_stmt|,
name|l_added
decl_stmt|,
name|r_deleted
decl_stmt|,
name|r_added
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
decl_stmt|;
comment|/* ### OPTIMIZE: Use from_mergeinfo when diff'ing. */
name|SVN_ERR
argument_list|(
name|diff_mergeinfo_props
argument_list|(
operator|&
name|l_deleted
argument_list|,
operator|&
name|l_added
argument_list|,
name|from_prop_val
argument_list|,
name|working_prop_val
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|diff_mergeinfo_props
argument_list|(
operator|&
name|r_deleted
argument_list|,
operator|&
name|r_added
argument_list|,
name|from_prop_val
argument_list|,
name|to_prop_val
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|l_deleted
argument_list|,
name|r_deleted
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|l_added
argument_list|,
name|r_added
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Apply the combined deltas to the base. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|from_mergeinfo
argument_list|,
name|from_prop_val
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|from_mergeinfo
argument_list|,
name|l_added
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_remove2
argument_list|(
operator|&
name|from_mergeinfo
argument_list|,
name|l_deleted
argument_list|,
name|from_mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|mergeinfo_string
argument_list|,
name|from_mergeinfo
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|mergeinfo_string
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_merge_props3
parameter_list|(
name|svn_wc_notify_state_t
modifier|*
name|state
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
name|apr_hash_t
modifier|*
name|baseprops
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|propchanges
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_hash_t
modifier|*
name|pristine_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|actual_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_actual_props
decl_stmt|;
name|svn_boolean_t
name|had_props
decl_stmt|,
name|props_mod
decl_stmt|;
name|svn_boolean_t
name|have_base
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_skel
init|=
name|NULL
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
comment|/* IMPORTANT: svn_wc_merge_prop_diffs relies on the fact that baseprops      may be NULL. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
operator|&
name|had_props
argument_list|,
operator|&
name|props_mod
argument_list|,
operator|&
name|have_base
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Checks whether the node exists and returns the hidden flag */
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' was not found."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|svn_wc__db_status_normal
operator|&&
name|status
operator|!=
name|svn_wc__db_status_added
operator|&&
name|status
operator|!=
name|svn_wc__db_status_incomplete
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' does not have properties in this state."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|conflicted
condition|)
block|{
name|svn_boolean_t
name|text_conflicted
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__internal_conflicted_p
argument_list|(
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't install two text/prop conflicts on a single node, so            avoid even checking that we have to merge it */
if|if
condition|(
name|text_conflicted
operator|||
name|prop_conflicted
operator|||
name|tree_conflicted
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't merge into conflicted node '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* else: Conflict was resolved by removing markers */
block|}
comment|/* The PROPCHANGES may not have non-"normal" properties in it. If entry      or wc props were allowed, then the following code would install them      into the BASE and/or WORKING properties(!).  */
for|for
control|(
name|i
operator|=
name|propchanges
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|change
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|propchanges
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|svn_wc_is_normal_prop
argument_list|(
name|change
operator|->
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROP_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The property '%s' may not be merged "
literal|"into '%s'."
argument_list|)
argument_list|,
name|change
operator|->
name|name
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|had_props
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|pristine_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pristine_props
operator|==
name|NULL
condition|)
name|pristine_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|props_mod
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__get_actual_props
argument_list|(
operator|&
name|actual_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|actual_props
operator|=
name|pristine_props
expr_stmt|;
comment|/* Note that while this routine does the "real" work, it's only      prepping tempfiles and writing log commands.  */
name|SVN_ERR
argument_list|(
name|svn_wc__merge_props
argument_list|(
operator|&
name|conflict_skel
argument_list|,
name|state
argument_list|,
operator|&
name|new_actual_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|baseprops
comment|/* server_baseprops */
argument_list|,
name|pristine_props
argument_list|,
name|actual_props
argument_list|,
name|propchanges
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
block|{
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|dir_abspath
operator|=
name|local_abspath
expr_stmt|;
else|else
name|dir_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Verify that we're holding this directory's write lock.  */
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conflict_skel
condition|)
block|{
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_merge
argument_list|(
name|conflict_skel
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_create_markers
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* After a (not-dry-run) merge, we ALWAYS have props to save.  */
name|SVN_ERR_ASSERT
argument_list|(
name|new_actual_props
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_set_props
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|new_actual_props
argument_list|,
name|svn_wc__has_magic_property
argument_list|(
name|propchanges
argument_list|)
argument_list|,
name|conflict_skel
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_items
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is a conflict, try to resolve it. */
if|if
condition|(
name|conflict_skel
operator|&&
name|conflict_func
condition|)
block|{
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_invoke_resolver
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|NULL
comment|/* merge_options */
argument_list|,
name|conflict_func
argument_list|,
name|conflict_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset *STATE if all prop conflicts were resolved. */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_conflicted_p
argument_list|(
name|NULL
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_conflicted
condition|)
operator|*
name|state
operator|=
name|svn_wc_notify_state_merged
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Generate a message to describe the property conflict among these four    values.     Note that this function (currently) interprets the property values as    strings, but they could actually be binary values. We'll keep the    types as svn_string_t in case we fix this in the future.  */
end_comment

begin_function
specifier|static
name|svn_stringbuf_t
modifier|*
name|generate_conflict_message
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|mine
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|incoming
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|incoming_base
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
if|if
condition|(
name|incoming_base
operator|==
name|NULL
condition|)
block|{
comment|/* Attempting to add the value INCOMING.  */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|incoming
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mine
condition|)
block|{
comment|/* To have a conflict, these must be different.  */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
operator|!
name|svn_string_compare
argument_list|(
name|mine
argument_list|,
name|incoming
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that we don't care whether MINE is locally-added or              edited, or just something different that is a copy of the              pristine ORIGINAL.  */
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to add new property '%s'\n"
literal|"but the property already exists.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
block|}
comment|/* To have a conflict, we must have an ORIGINAL which has been          locally-deleted.  */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|original
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to add new property '%s'\n"
literal|"but the property has been locally "
literal|"deleted.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
block|}
if|if
condition|(
name|incoming
operator|==
name|NULL
condition|)
block|{
comment|/* Attempting to delete the value INCOMING_BASE.  */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|incoming_base
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Are we trying to delete a local addition? */
if|if
condition|(
name|original
operator|==
name|NULL
operator|&&
name|mine
operator|!=
name|NULL
condition|)
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to delete property '%s'\n"
literal|"but the property has been locally "
literal|"added.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
comment|/* A conflict can only occur if we originally had the property;          otherwise, we would have merged the property-delete into the          non-existent property.  */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|original
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_string_compare
argument_list|(
name|original
argument_list|,
name|incoming_base
argument_list|)
condition|)
block|{
if|if
condition|(
name|mine
condition|)
comment|/* We were trying to delete the correct property, but an edit                caused the conflict.  */
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to delete property '%s'\n"
literal|"but the property has been locally "
literal|"modified.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|mine
operator|==
name|NULL
condition|)
block|{
comment|/* We were trying to delete the property, but we have locally              deleted the same property, but with a different value. */
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to delete property '%s'\n"
literal|"but the property has been locally "
literal|"deleted and had a different "
literal|"value.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
block|}
comment|/* We were trying to delete INCOMING_BASE but our ORIGINAL is          something else entirely.  */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
operator|!
name|svn_string_compare
argument_list|(
name|original
argument_list|,
name|incoming_base
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to delete property '%s'\n"
literal|"but the local property value is "
literal|"different.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
block|}
comment|/* Attempting to change the property from INCOMING_BASE to INCOMING.  */
comment|/* If we have a (current) property value, then it should be different      from the INCOMING_BASE; otherwise, the incoming change would have      been applied to it.  */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
operator|!
name|mine
operator|||
operator|!
name|svn_string_compare
argument_list|(
name|mine
argument_list|,
name|incoming_base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|original
operator|&&
name|mine
operator|&&
name|svn_string_compare
argument_list|(
name|original
argument_list|,
name|mine
argument_list|)
condition|)
block|{
comment|/* We have an unchanged property, so the original values must          have been different.  */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
operator|!
name|svn_string_compare
argument_list|(
name|original
argument_list|,
name|incoming_base
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to change property '%s'\n"
literal|"but the local property value conflicts "
literal|"with the incoming change.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
block|}
if|if
condition|(
name|original
operator|&&
name|mine
condition|)
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to change property '%s'\n"
literal|"but the property has already been locally "
literal|"changed to a different value.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
if|if
condition|(
name|original
condition|)
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to change property '%s'\nbut "
literal|"the property has been locally deleted.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
if|if
condition|(
name|mine
condition|)
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to change property '%s'\nbut the "
literal|"property has been locally added with a "
literal|"different value.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|_
argument_list|(
literal|"Trying to change property '%s'\nbut "
literal|"the property does not exist locally.\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* SKEL will be one of:     ()    (VALUE)     Return NULL for the former (the particular property value was not    present), and VALUE for the second.  */
end_comment

begin_function
specifier|static
specifier|const
name|svn_string_t
modifier|*
name|maybe_prop_value
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
if|if
condition|(
name|skel
operator|->
name|children
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|svn_string_ncreate
argument_list|(
name|skel
operator|->
name|children
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|len
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a property conflict description from the provided SKEL.    The result includes a descriptive message (see generate_conflict_message)    and maybe a diff of property values containing conflict markers.    The result will be allocated in RESULT_POOL.     Note: SKEL is a single property conflict of the form:     ("prop" ([ORIGINAL]) ([MINE]) ([INCOMING]) ([INCOMING_BASE]))     See notes/wc-ng/conflict-storage for more information.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prop_conflict_from_skel
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|conflict_desc
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|original
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|mine
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|incoming
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|incoming_base
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|diff_opts
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|svn_boolean_t
name|original_is_binary
decl_stmt|;
name|svn_boolean_t
name|mine_is_binary
decl_stmt|;
name|svn_boolean_t
name|incoming_is_binary
decl_stmt|;
comment|/* Navigate to the property name.  */
name|skel
operator|=
name|skel
operator|->
name|children
operator|->
name|next
expr_stmt|;
comment|/* We need to copy these into SCRATCH_POOL in order to nul-terminate      the values.  */
name|propname
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|skel
operator|->
name|data
argument_list|,
name|skel
operator|->
name|len
argument_list|)
expr_stmt|;
name|original
operator|=
name|maybe_prop_value
argument_list|(
name|skel
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|mine
operator|=
name|maybe_prop_value
argument_list|(
name|skel
operator|->
name|next
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|incoming
operator|=
name|maybe_prop_value
argument_list|(
name|skel
operator|->
name|next
operator|->
name|next
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|incoming_base
operator|=
name|maybe_prop_value
argument_list|(
name|skel
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|buf
operator|=
name|generate_conflict_message
argument_list|(
name|propname
argument_list|,
name|original
argument_list|,
name|mine
argument_list|,
name|incoming
argument_list|,
name|incoming_base
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mine
operator|==
name|NULL
condition|)
name|mine
operator|=
name|svn_string_create_empty
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|incoming
operator|==
name|NULL
condition|)
name|incoming
operator|=
name|svn_string_create_empty
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Pick a suitable base for the conflict diff.    * The incoming value is always a change,    * but the local value might not have changed. */
if|if
condition|(
name|original
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|incoming_base
condition|)
name|original
operator|=
name|incoming_base
expr_stmt|;
else|else
name|original
operator|=
name|svn_string_create_empty
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incoming_base
operator|&&
name|svn_string_compare
argument_list|(
name|original
argument_list|,
name|mine
argument_list|)
condition|)
name|original
operator|=
name|incoming_base
expr_stmt|;
comment|/* If any of the property values involved in the diff is binary data,    * do not generate a diff. */
name|original_is_binary
operator|=
name|svn_io_is_binary_data
argument_list|(
name|original
operator|->
name|data
argument_list|,
name|original
operator|->
name|len
argument_list|)
expr_stmt|;
name|mine_is_binary
operator|=
name|svn_io_is_binary_data
argument_list|(
name|mine
operator|->
name|data
argument_list|,
name|mine
operator|->
name|len
argument_list|)
expr_stmt|;
name|incoming_is_binary
operator|=
name|svn_io_is_binary_data
argument_list|(
name|incoming
operator|->
name|data
argument_list|,
name|incoming
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|original_is_binary
operator|||
name|mine_is_binary
operator|||
name|incoming_is_binary
operator|)
condition|)
block|{
name|diff_opts
operator|=
name|svn_diff_file_options_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|diff_opts
operator|->
name|ignore_space
operator|=
name|svn_diff_file_ignore_space_none
expr_stmt|;
name|diff_opts
operator|->
name|ignore_eol_style
operator|=
name|FALSE
expr_stmt|;
name|diff_opts
operator|->
name|show_c_function
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_mem_string_diff3
argument_list|(
operator|&
name|diff
argument_list|,
name|original
argument_list|,
name|mine
argument_list|,
name|incoming
argument_list|,
name|diff_opts
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_diff_contains_conflicts
argument_list|(
name|diff
argument_list|)
condition|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_diff_conflict_display_style_t
name|style
decl_stmt|;
specifier|const
name|char
modifier|*
name|mine_marker
init|=
name|_
argument_list|(
literal|"<<<<<<< (local property value)"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|incoming_marker
init|=
name|_
argument_list|(
literal|">>>>>>> (incoming property value)"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|separator
init|=
literal|"======="
decl_stmt|;
name|svn_string_t
modifier|*
name|original_ascii
init|=
name|svn_string_create
argument_list|(
name|svn_utf_cstring_from_utf8_fuzzy
argument_list|(
name|original
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|mine_ascii
init|=
name|svn_string_create
argument_list|(
name|svn_utf_cstring_from_utf8_fuzzy
argument_list|(
name|mine
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|incoming_ascii
init|=
name|svn_string_create
argument_list|(
name|svn_utf_cstring_from_utf8_fuzzy
argument_list|(
name|incoming
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|style
operator|=
name|svn_diff_conflict_display_modified_latest
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|buf
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_skip
argument_list|(
name|stream
argument_list|,
name|buf
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_mem_string_output_merge2
argument_list|(
name|stream
argument_list|,
name|diff
argument_list|,
name|original_ascii
argument_list|,
name|mine_ascii
argument_list|,
name|incoming_ascii
argument_list|,
name|NULL
argument_list|,
name|mine_marker
argument_list|,
name|incoming_marker
argument_list|,
name|separator
argument_list|,
name|style
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|conflict_desc
operator|=
name|svn_string_create_from_buf
argument_list|(
name|buf
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* If we could not print a conflict diff just print full values . */
if|if
condition|(
name|mine
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Local property value:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mine_is_binary
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Cannot display: property value is "
literal|"binary data\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_appendbytes
argument_list|(
name|buf
argument_list|,
name|mine
operator|->
name|data
argument_list|,
name|mine
operator|->
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|incoming
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Incoming property value:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incoming_is_binary
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Cannot display: property value is "
literal|"binary data\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_appendbytes
argument_list|(
name|buf
argument_list|,
name|incoming
operator|->
name|data
argument_list|,
name|incoming
operator|->
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|conflict_desc
operator|=
name|svn_string_create_from_buf
argument_list|(
name|buf
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a property conflict file at PREJFILE based on the property    conflicts in CONFLICT_SKEL.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__create_prejfile
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|tmp_prejfile_abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tempdir_abspath
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_abspath
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|scan
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|tempdir_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
operator|&
name|temp_abspath
argument_list|,
name|tempdir_abspath
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|conflict_skel
operator|->
name|children
operator|->
name|next
init|;
name|scan
operator|!=
name|NULL
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|append_prop_conflict
argument_list|(
name|stream
argument_list|,
name|scan
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|tmp_prejfile_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|temp_abspath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the value of *STATE to NEW_VALUE if STATE is not NULL  * and NEW_VALUE is a higer order value than *STATE's current value  * using this ordering (lower order first):  *  * - unknown, unchanged, inapplicable  * - changed  * - merged  * - missing  * - obstructed  * - conflicted  *  */
end_comment

begin_function
specifier|static
name|void
name|set_prop_merge_state
parameter_list|(
name|svn_wc_notify_state_t
modifier|*
name|state
parameter_list|,
name|svn_wc_notify_state_t
name|new_value
parameter_list|)
block|{
specifier|static
name|char
name|ordering
index|[]
init|=
block|{
name|svn_wc_notify_state_unknown
block|,
name|svn_wc_notify_state_unchanged
block|,
name|svn_wc_notify_state_inapplicable
block|,
name|svn_wc_notify_state_changed
block|,
name|svn_wc_notify_state_merged
block|,
name|svn_wc_notify_state_obstructed
block|,
name|svn_wc_notify_state_conflicted
block|}
decl_stmt|;
name|int
name|state_pos
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
return|return;
comment|/* Find *STATE in our ordering */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ordering
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|state
operator|==
name|ordering
index|[
name|i
index|]
condition|)
block|{
name|state_pos
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Find NEW_VALUE in our ordering    * We don't need to look further than where we found *STATE though:    * If we find our value, it's order is too low.    * If we don't find it, we'll want to set it, no matter its order.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|state_pos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|new_value
operator|==
name|ordering
index|[
name|i
index|]
condition|)
return|return;
block|}
operator|*
name|state
operator|=
name|new_value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apply the addition of a property with name PROPNAME and value NEW_VAL to  * the existing property with value WORKING_VAL, that originally had value  * PRISTINE_VAL.  *  * Sets *RESULT_VAL to the resulting value.  * Sets *CONFLICT_REMAINS to TRUE if the change caused a conflict.  * Sets *DID_MERGE to true if the result is caused by a merge  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_single_prop_add
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result_val
parameter_list|,
name|svn_boolean_t
modifier|*
name|conflict_remains
parameter_list|,
name|svn_boolean_t
modifier|*
name|did_merge
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|pristine_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|new_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|working_val
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|working_val
condition|)
block|{
comment|/* the property already exists in actual_props... */
if|if
condition|(
name|svn_string_compare
argument_list|(
name|working_val
argument_list|,
name|new_val
argument_list|)
condition|)
comment|/* The value we want is already there, so it's a merge. */
operator|*
name|did_merge
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|svn_boolean_t
name|merged_prop
init|=
name|FALSE
decl_stmt|;
comment|/* The WC difference doesn't match the new value.            We only merge mergeinfo;  other props conflict */
if|if
condition|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|merged_val
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|combine_mergeinfo_props
argument_list|(
operator|&
name|merged_val
argument_list|,
name|working_val
argument_list|,
name|new_val
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Issue #3896 'mergeinfo syntax errors should be treated                  gracefully': If bogus mergeinfo is present we can't                  merge intelligently, so raise a conflict instead. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
block|{
name|merged_prop
operator|=
name|TRUE
expr_stmt|;
operator|*
name|result_val
operator|=
name|merged_val
expr_stmt|;
operator|*
name|did_merge
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|merged_prop
condition|)
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pristine_val
condition|)
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
else|else
comment|/* property doesn't yet exist in actual_props...  */
comment|/* so just set it */
operator|*
name|result_val
operator|=
name|new_val
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Apply the deletion of a property to the existing  * property with value WORKING_VAL, that originally had value PRISTINE_VAL.  *  * Sets *RESULT_VAL to the resulting value.  * Sets *CONFLICT_REMAINS to TRUE if the change caused a conflict.  * Sets *DID_MERGE to true if the result is caused by a merge  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_single_prop_delete
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result_val
parameter_list|,
name|svn_boolean_t
modifier|*
name|conflict_remains
parameter_list|,
name|svn_boolean_t
modifier|*
name|did_merge
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|base_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|old_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|working_val
parameter_list|)
block|{
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|base_val
condition|)
block|{
if|if
condition|(
name|working_val
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|working_val
argument_list|,
name|old_val
argument_list|)
condition|)
block|{
comment|/* We are trying to delete a locally-added prop. */
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|result_val
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|old_val
condition|)
comment|/* This is a merge, merging a delete into non-existent                property or a local addition of same prop value. */
operator|*
name|did_merge
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|svn_string_compare
argument_list|(
name|base_val
argument_list|,
name|old_val
argument_list|)
condition|)
block|{
if|if
condition|(
name|working_val
condition|)
block|{
if|if
condition|(
name|svn_string_compare
argument_list|(
name|working_val
argument_list|,
name|old_val
argument_list|)
condition|)
comment|/* they have the same values, so it's an update */
operator|*
name|result_val
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
comment|/* The property is locally deleted from the same value, so it's             a merge */
operator|*
name|did_merge
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Merge a change to the mergeinfo property. Similar to    apply_single_prop_change(), except that the property name is always    SVN_PROP_MERGEINFO. */
end_comment

begin_comment
comment|/* ### This function is extracted straight from the previous all-in-one    version of apply_single_prop_change() by removing the code paths that    were not followed for this property, but with no attempt to rationalize    the remainder. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_single_mergeinfo_prop_change
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result_val
parameter_list|,
name|svn_boolean_t
modifier|*
name|conflict_remains
parameter_list|,
name|svn_boolean_t
modifier|*
name|did_merge
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|base_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|old_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|new_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|working_val
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|(
name|working_val
operator|&&
operator|!
name|base_val
operator|)
operator|||
operator|(
operator|!
name|working_val
operator|&&
name|base_val
operator|)
operator|||
operator|(
name|working_val
operator|&&
name|base_val
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|working_val
argument_list|,
name|base_val
argument_list|)
operator|)
condition|)
block|{
comment|/* Locally changed property */
if|if
condition|(
name|working_val
condition|)
block|{
if|if
condition|(
name|svn_string_compare
argument_list|(
name|working_val
argument_list|,
name|new_val
argument_list|)
condition|)
comment|/* The new value equals the changed value: a no-op merge */
operator|*
name|did_merge
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* We have base, WC, and new values.  Discover                  deltas between base<-> WC, and base<->                  incoming.  Combine those deltas, and apply                  them to base to get the new value. */
name|SVN_ERR
argument_list|(
name|combine_forked_mergeinfo_props
argument_list|(
operator|&
name|new_val
argument_list|,
name|old_val
argument_list|,
name|working_val
argument_list|,
name|new_val
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_val
operator|=
name|new_val
expr_stmt|;
operator|*
name|did_merge
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is a base_val but no working_val */
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|working_val
condition|)
comment|/* means !working_val&& !base_val due                              to conditions above: no prop at all */
block|{
comment|/* Discover any mergeinfo additions in the          incoming value relative to the base, and          "combine" those with the empty WC value. */
name|svn_mergeinfo_t
name|deleted_mergeinfo
decl_stmt|,
name|added_mergeinfo
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
decl_stmt|;
name|SVN_ERR
argument_list|(
name|diff_mergeinfo_props
argument_list|(
operator|&
name|deleted_mergeinfo
argument_list|,
operator|&
name|added_mergeinfo
argument_list|,
name|old_val
argument_list|,
name|new_val
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|mergeinfo_string
argument_list|,
name|added_mergeinfo
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_val
operator|=
name|mergeinfo_string
expr_stmt|;
block|}
else|else
comment|/* means working&& base&& svn_string_compare(working, base) */
block|{
if|if
condition|(
name|svn_string_compare
argument_list|(
name|old_val
argument_list|,
name|base_val
argument_list|)
condition|)
operator|*
name|result_val
operator|=
name|new_val
expr_stmt|;
else|else
block|{
comment|/* We have base, WC, and new values.  Discover              deltas between base<-> WC, and base<->              incoming.  Combine those deltas, and apply              them to base to get the new value. */
name|SVN_ERR
argument_list|(
name|combine_forked_mergeinfo_props
argument_list|(
operator|&
name|new_val
argument_list|,
name|old_val
argument_list|,
name|working_val
argument_list|,
name|new_val
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result_val
operator|=
name|new_val
expr_stmt|;
operator|*
name|did_merge
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Merge a change to a property, using the rule that if the working value    is equal to the new value then there is nothing we need to do. Else, if    the working value is the same as the old value then apply the change as a    simple update (replacement), otherwise invoke maybe_generate_propconflict().    The definition of the arguments and behaviour is the same as    apply_single_prop_change(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_single_generic_prop_change
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result_val
parameter_list|,
name|svn_boolean_t
modifier|*
name|conflict_remains
parameter_list|,
name|svn_boolean_t
modifier|*
name|did_merge
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|old_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|new_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|working_val
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|old_val
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If working_val is the same as new_val already then there is    * nothing to do */
if|if
condition|(
name|working_val
operator|&&
name|new_val
operator|&&
name|svn_string_compare
argument_list|(
name|working_val
argument_list|,
name|new_val
argument_list|)
condition|)
block|{
comment|/* All values identical is a trivial, non-notifiable merge */
if|if
condition|(
operator|!
name|old_val
operator|||
operator|!
name|svn_string_compare
argument_list|(
name|old_val
argument_list|,
name|new_val
argument_list|)
condition|)
operator|*
name|did_merge
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If working_val is the same as old_val... */
elseif|else
if|if
condition|(
name|working_val
operator|&&
name|old_val
operator|&&
name|svn_string_compare
argument_list|(
name|working_val
argument_list|,
name|old_val
argument_list|)
condition|)
block|{
comment|/* A trivial update: change it to new_val. */
operator|*
name|result_val
operator|=
name|new_val
expr_stmt|;
block|}
else|else
block|{
comment|/* Merge the change. */
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Change the property with name PROPNAME, setting *RESULT_VAL,  * *CONFLICT_REMAINS and *DID_MERGE according to the merge outcome.  *  * BASE_VAL contains the working copy base property value. (May be null.)  *  * OLD_VAL contains the value of the property the server  * thinks it's overwriting. (Not null.)  *  * NEW_VAL contains the value to be set. (Not null.)  *  * WORKING_VAL contains the working copy actual value. (May be null.)  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_single_prop_change
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result_val
parameter_list|,
name|svn_boolean_t
modifier|*
name|conflict_remains
parameter_list|,
name|svn_boolean_t
modifier|*
name|did_merge
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|base_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|old_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|new_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|working_val
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|merged_prop
init|=
name|FALSE
decl_stmt|;
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
comment|/* Note: The purpose is to apply the change (old_val -> new_val) onto      (working_val). There is no need for base_val to be involved in the      process except as a bit of context to help the user understand and      resolve any conflict. */
comment|/* Decide how to merge, based on whether we know anything special about      the property. */
if|if
condition|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We know how to merge any mergeinfo property change...           ...But Issue #3896 'mergeinfo syntax errors should be treated          gracefully' might thwart us.  If bogus mergeinfo is present we          can't merge intelligently, so let the standard method deal with          it instead. */
name|svn_error_t
modifier|*
name|err
init|=
name|apply_single_mergeinfo_prop_change
argument_list|(
name|result_val
argument_list|,
name|conflict_remains
argument_list|,
name|did_merge
argument_list|,
name|base_val
argument_list|,
name|old_val
argument_list|,
name|new_val
argument_list|,
name|working_val
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
block|{
name|merged_prop
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|merged_prop
condition|)
block|{
comment|/* The standard method: perform a simple update automatically, but          pass any other kind of merge to maybe_generate_propconflict(). */
name|SVN_ERR
argument_list|(
name|apply_single_generic_prop_change
argument_list|(
name|result_val
argument_list|,
name|conflict_remains
argument_list|,
name|did_merge
argument_list|,
name|old_val
argument_list|,
name|new_val
argument_list|,
name|working_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__merge_props
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc_notify_state_t
modifier|*
name|state
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|new_actual_props
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|server_baseprops
parameter_list|,
name|apr_hash_t
modifier|*
name|pristine_props
parameter_list|,
name|apr_hash_t
modifier|*
name|actual_props
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|propchanges
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflict_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_props
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|pristine_props
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|actual_props
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|new_actual_props
operator|=
name|apr_hash_copy
argument_list|(
name|result_pool
argument_list|,
name|actual_props
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|server_baseprops
condition|)
name|server_baseprops
operator|=
name|pristine_props
expr_stmt|;
name|their_props
operator|=
name|apr_hash_copy
argument_list|(
name|scratch_pool
argument_list|,
name|server_baseprops
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
comment|/* Start out assuming no changes or conflicts.  Don't bother to          examine propchanges->nelts yet; even if we knew there were          propchanges, we wouldn't yet know if they are "normal" props,          as opposed wc or entry props.  */
operator|*
name|state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
block|}
comment|/* Looping over the array of incoming propchanges we want to apply: */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|propchanges
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|incoming_change
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|propchanges
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
init|=
name|incoming_change
operator|->
name|name
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|base_val
comment|/* Pristine in WC */
init|=
name|svn_hash_gets
argument_list|(
name|pristine_props
argument_list|,
name|propname
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|from_val
comment|/* Merge left */
init|=
name|svn_hash_gets
argument_list|(
name|server_baseprops
argument_list|,
name|propname
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|to_val
comment|/* Merge right */
init|=
name|incoming_change
operator|->
name|value
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|working_val
comment|/* Mine */
init|=
name|svn_hash_gets
argument_list|(
name|actual_props
argument_list|,
name|propname
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|result_val
decl_stmt|;
name|svn_boolean_t
name|conflict_remains
decl_stmt|;
name|svn_boolean_t
name|did_merge
init|=
name|FALSE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|to_val
operator|=
name|to_val
condition|?
name|svn_string_dup
argument_list|(
name|to_val
argument_list|,
name|result_pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|their_props
argument_list|,
name|propname
argument_list|,
name|to_val
argument_list|)
expr_stmt|;
comment|/* We already know that state is at least `changed', so mark          that, but remember that we may later upgrade to `merged' or          even `conflicted'. */
name|set_prop_merge_state
argument_list|(
name|state
argument_list|,
name|svn_wc_notify_state_changed
argument_list|)
expr_stmt|;
name|result_val
operator|=
name|working_val
expr_stmt|;
if|if
condition|(
operator|!
name|from_val
condition|)
comment|/* adding a new property */
name|SVN_ERR
argument_list|(
name|apply_single_prop_add
argument_list|(
operator|&
name|result_val
argument_list|,
operator|&
name|conflict_remains
argument_list|,
operator|&
name|did_merge
argument_list|,
name|propname
argument_list|,
name|base_val
argument_list|,
name|to_val
argument_list|,
name|working_val
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|to_val
condition|)
comment|/* delete an existing property */
name|SVN_ERR
argument_list|(
name|apply_single_prop_delete
argument_list|(
operator|&
name|result_val
argument_list|,
operator|&
name|conflict_remains
argument_list|,
operator|&
name|did_merge
argument_list|,
name|base_val
argument_list|,
name|from_val
argument_list|,
name|working_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* changing an existing property */
name|SVN_ERR
argument_list|(
name|apply_single_prop_change
argument_list|(
operator|&
name|result_val
argument_list|,
operator|&
name|conflict_remains
argument_list|,
operator|&
name|did_merge
argument_list|,
name|propname
argument_list|,
name|base_val
argument_list|,
name|from_val
argument_list|,
name|to_val
argument_list|,
name|working_val
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_val
operator|!=
name|working_val
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|new_actual_props
argument_list|,
name|propname
argument_list|,
name|result_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_merge
condition|)
name|set_prop_merge_state
argument_list|(
name|state
argument_list|,
name|svn_wc_notify_state_merged
argument_list|)
expr_stmt|;
comment|/* merging logic complete, now we need to possibly log conflict          data to tmpfiles.  */
if|if
condition|(
name|conflict_remains
condition|)
block|{
name|set_prop_merge_state
argument_list|(
name|state
argument_list|,
name|svn_wc_notify_state_conflicted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflict_props
condition|)
name|conflict_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|conflict_props
argument_list|,
name|propname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* foreach propchange ... */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Finished applying all incoming propchanges to our hashes! */
if|if
condition|(
name|conflict_props
operator|!=
name|NULL
condition|)
block|{
comment|/* Ok, we got some conflict. Lets store all the property knowledge we          have for resolving later */
if|if
condition|(
operator|!
operator|*
name|conflict_skel
condition|)
operator|*
name|conflict_skel
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_prop_conflict
argument_list|(
operator|*
name|conflict_skel
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
comment|/* reject_path */
argument_list|,
name|actual_props
argument_list|,
name|server_baseprops
argument_list|,
name|their_props
argument_list|,
name|conflict_props
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set a single 'wcprop' NAME to VALUE for versioned object LOCAL_ABSPATH.    If VALUE is null, remove property NAME.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|wcprop_set
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|prophash
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: this is not well-transacted. But... meh. This is merely a cache,      and if two processes are trying to modify this one entry at the same      time, then fine: we can let one be a winner, and one a loser. Of course,      if there are *other* state changes afoot, then the lack of a txn could      be a real issue, but we cannot solve that here.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_dav_cache
argument_list|(
operator|&
name|prophash
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prophash
operator|==
name|NULL
condition|)
name|prophash
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|prophash
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_base_set_dav_cache
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|prophash
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_actual_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|props
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### perform some state checking. for example, locally-deleted nodes      ### should not have any ACTUAL props.  */
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_read_props
argument_list|(
name|props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_prop_list2
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__get_actual_props
argument_list|(
name|props
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|propname_filter_baton_t
block|{
name|svn_wc__proplist_receiver_t
name|receiver_func
decl_stmt|;
name|void
modifier|*
name|receiver_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|propname_filter_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|propname_filter_baton_t
modifier|*
name|pfb
init|=
name|baton
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|propval
init|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|pfb
operator|->
name|propname
argument_list|)
decl_stmt|;
if|if
condition|(
name|propval
condition|)
block|{
name|props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|pfb
operator|->
name|propname
argument_list|,
name|propval
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|pfb
operator|->
name|receiver_func
argument_list|(
name|pfb
operator|->
name|receiver_baton
argument_list|,
name|local_abspath
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__prop_list_recursive
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|pristine
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
name|svn_wc__proplist_receiver_t
name|receiver_func
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__proplist_receiver_t
name|receiver
init|=
name|receiver_func
decl_stmt|;
name|void
modifier|*
name|baton
init|=
name|receiver_baton
decl_stmt|;
name|struct
name|propname_filter_baton_t
name|pfb
decl_stmt|;
name|pfb
operator|.
name|receiver_func
operator|=
name|receiver_func
expr_stmt|;
name|pfb
operator|.
name|receiver_baton
operator|=
name|receiver_baton
expr_stmt|;
name|pfb
operator|.
name|propname
operator|=
name|propname
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|receiver_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|propname
condition|)
block|{
name|baton
operator|=
operator|&
name|pfb
expr_stmt|;
name|receiver
operator|=
name|propname_filter_receiver
expr_stmt|;
block|}
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
name|svn_depth_empty
case|:
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_hash_t
modifier|*
name|changelist_hash
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|changelists
operator|&&
name|changelists
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|svn_hash_from_cstring_keys
argument_list|(
operator|&
name|changelist_hash
argument_list|,
name|changelists
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_wc__internal_changelist_match
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|changelist_hash
argument_list|,
name|scratch_pool
argument_list|)
condition|)
break|break;
if|if
condition|(
name|pristine
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|props
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|props
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|&&
name|apr_hash_count
argument_list|(
name|props
argument_list|)
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|receiver
argument_list|(
name|baton
argument_list|,
name|local_abspath
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|svn_depth_files
case|:
case|case
name|svn_depth_immediates
case|:
case|case
name|svn_depth_infinity
case|:
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props_streamily
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|pristine
argument_list|,
name|changelists
argument_list|,
name|receiver
argument_list|,
name|baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__prop_retrieve_recursive
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|values
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_prop_retrieve_recursive
argument_list|(
name|values
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|propname
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_get_pristine_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|props
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Certain node stats do not have properties defined on them. Check the      state, and return NULL for these situations.  */
name|err
operator|=
name|svn_wc__db_read_pristine_props
argument_list|(
name|props
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Documented behavior is to set *PROPS to NULL */
operator|*
name|props
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_prop_get2
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|value
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|enum
name|svn_prop_kind
name|kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_prop_entry_kind
condition|)
block|{
comment|/* we don't do entry properties here */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROP_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Property '%s' is an entry property"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
name|err
operator|=
name|svn_wc__internal_propget
argument_list|(
name|value
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|name
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Documented behavior is to set *VALUE to NULL */
operator|*
name|value
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_propget
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|value
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|prophash
init|=
name|NULL
decl_stmt|;
name|enum
name|svn_prop_kind
name|kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|kind
operator|!=
name|svn_prop_entry_kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_prop_wc_kind
condition|)
block|{
name|SVN_ERR_W
argument_list|(
name|svn_wc__db_base_get_dav_cache
argument_list|(
operator|&
name|prophash
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Failed to load properties"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* regular prop */
name|SVN_ERR_W
argument_list|(
name|svn_wc__get_actual_props
argument_list|(
operator|&
name|prophash
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Failed to load properties"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prophash
condition|)
operator|*
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|prophash
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|*
name|value
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The special Subversion properties are not valid for all node kinds.    Return an error if NAME is an invalid Subversion property for PATH which    is of kind NODE_KIND.  NAME must be in the "svn:" name space.     Note that we only disallow the property if we're sure it's one that    already has a meaning for a different node kind.  We don't disallow    setting an *unknown* svn: prop here, at this level; a higher level    should disallow that if desired.   */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|validate_prop_against_node_kind
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_display
init|=
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|?
name|path
else|:
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|node_kind
condition|)
block|{
case|case
name|svn_node_dir
case|:
if|if
condition|(
operator|!
name|svn_prop_is_known_svn_dir_prop
argument_list|(
name|name
argument_list|)
operator|&&
name|svn_prop_is_known_svn_file_prop
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot set '%s' on a directory ('%s')"
argument_list|)
argument_list|,
name|name
argument_list|,
name|path_display
argument_list|)
return|;
break|break;
case|case
name|svn_node_file
case|:
if|if
condition|(
operator|!
name|svn_prop_is_known_svn_file_prop
argument_list|(
name|name
argument_list|)
operator|&&
name|svn_prop_is_known_svn_dir_prop
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot set '%s' on a file ('%s')"
argument_list|)
argument_list|,
name|name
argument_list|,
name|path_display
argument_list|)
return|;
break|break;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file or directory"
argument_list|)
argument_list|,
name|path_display
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|getter_baton
block|{
specifier|const
name|svn_string_t
modifier|*
name|mime_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Provide the MIME_TYPE and/or push the content to STREAM for the file  * referenced by (getter_baton *) BATON.  *  * Implements svn_wc_canonicalize_svn_prop_get_file_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_for_validation
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|mime_type
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|getter_baton
modifier|*
name|gb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|mime_type
condition|)
operator|*
name|mime_type
operator|=
name|gb
operator|->
name|mime_type
expr_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|svn_stream_t
modifier|*
name|read_stream
decl_stmt|;
comment|/* Copy the text of GB->LOCAL_ABSPATH into STREAM. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|read_stream
argument_list|,
name|gb
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|read_stream
argument_list|,
name|svn_stream_disown
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Validate that a file has a 'non-binary' MIME type and contains  * self-consistent line endings.  If not, then return an error.  *  * Call GETTER (which must not be NULL) with GETTER_BATON to get the  * file's MIME type and/or content.  If the MIME type is non-null and  * is categorized as 'binary' then return an error and do not request  * the file content.  *  * Use PATH (a local path or a URL) only for error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|validate_eol_prop_against_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_wc_canonicalize_svn_prop_get_file_t
name|getter
parameter_list|,
name|void
modifier|*
name|getter_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|translating_stream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|mime_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_display
init|=
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|?
name|path
else|:
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* First just ask the "getter" for the MIME type. */
name|SVN_ERR
argument_list|(
name|getter
argument_list|(
operator|&
name|mime_type
argument_list|,
name|NULL
argument_list|,
name|getter_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this file has been determined to be binary. */
if|if
condition|(
name|mime_type
operator|&&
name|svn_mime_type_is_binary
argument_list|(
name|mime_type
operator|->
name|data
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't set '%s': "
literal|"file '%s' has binary mime type property"
argument_list|)
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|,
name|path_display
argument_list|)
return|;
comment|/* Now ask the getter for the contents of the file; this will do a      newline translation.  All we really care about here is whether or      not the function fails on inconsistent line endings.  The      function is "translating" to an empty stream.  This is      sneeeeeeeeeeeaky. */
name|translating_stream
operator|=
name|svn_subst_stream_translated
argument_list|(
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|getter
argument_list|(
name|NULL
argument_list|,
name|translating_stream
argument_list|,
name|getter_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_stream_close
argument_list|(
name|translating_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_IO_INCONSISTENT_EOL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"File '%s' has inconsistent newlines"
argument_list|)
argument_list|,
name|path_display
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_propset
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|svn_boolean_t
name|skip_checks
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|prophash
decl_stmt|;
name|svn_wc_notify_action_t
name|notify_action
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|clear_recorded_info
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_W
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|prophash
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Failed to load current properties"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setting an inappropriate property is not allowed (unless      overridden by 'skip_checks', in some circumstances).  Deleting an      inappropriate property is allowed, however, since older clients      allowed (and other clients possibly still allow) setting it in      the first place. */
if|if
condition|(
name|value
operator|&&
name|svn_prop_is_svn_prop
argument_list|(
name|name
argument_list|)
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|new_value
decl_stmt|;
name|struct
name|getter_baton
name|gb
decl_stmt|;
name|gb
operator|.
name|mime_type
operator|=
name|svn_hash_gets
argument_list|(
name|prophash
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
expr_stmt|;
name|gb
operator|.
name|local_abspath
operator|=
name|local_abspath
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_canonicalize_svn_prop
argument_list|(
operator|&
name|new_value
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|local_abspath
argument_list|,
name|kind
argument_list|,
name|skip_checks
argument_list|,
name|get_file_for_validation
argument_list|,
operator|&
name|gb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|new_value
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_NEEDS_LOCK
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_sync_file_flags
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we're changing this file's list of expanded keywords, then    * we'll need to invalidate its text timestamp, since keyword    * expansion affects the comparison of working file to text base.    *    * Here we retrieve the old list of expanded keywords; after the    * property is set, we'll grab the new list and see if it differs    * from the old one.    */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_string_t
modifier|*
name|old_value
init|=
name|svn_hash_gets
argument_list|(
name|prophash
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_keywords
decl_stmt|,
modifier|*
name|new_keywords
decl_stmt|;
if|if
condition|(
name|old_value
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__expand_keywords
argument_list|(
operator|&
name|old_keywords
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|old_value
operator|->
name|data
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old_keywords
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__expand_keywords
argument_list|(
operator|&
name|new_keywords
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_keywords
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_subst_keywords_differ2
argument_list|(
name|old_keywords
argument_list|,
name|new_keywords
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
condition|)
block|{
comment|/* If the keywords have changed, then the translation of the file              may be different. We should invalidate the RECORDED_SIZE              and RECORDED_TIME on this node.               Note that we don't immediately re-translate the file. But a              "has it changed?" check in the future will do a translation              from the pristine, and it will want to compare the (new)              resulting RECORDED_SIZE against the working copy file.               Also, when this file is (de)translated with the new keywords,              then it could be different, relative to the pristine. We want              to ensure the RECORDED_TIME is different, to indicate that              a full detranslate/compare is performed.  */
name|clear_recorded_info
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_string_t
modifier|*
name|old_value
init|=
name|svn_hash_gets
argument_list|(
name|prophash
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|value
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|old_value
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
name|value
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|value
argument_list|,
name|old_value
argument_list|)
operator|)
condition|)
block|{
name|clear_recorded_info
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Find out what type of property change we are doing: add, modify, or      delete. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|prophash
argument_list|,
name|name
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
comment|/* Deleting a non-existent property. */
name|notify_action
operator|=
name|svn_wc_notify_property_deleted_nonexistent
expr_stmt|;
else|else
comment|/* Adding a property. */
name|notify_action
operator|=
name|svn_wc_notify_property_added
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
comment|/* Deleting the property. */
name|notify_action
operator|=
name|svn_wc_notify_property_deleted
expr_stmt|;
else|else
comment|/* Modifying property. */
name|notify_action
operator|=
name|svn_wc_notify_property_modified
expr_stmt|;
block|}
comment|/* Now we have all the properties in our hash.  Simply merge the new      property into it. */
name|svn_hash_sets
argument_list|(
name|prophash
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Drop it right into the db..  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_set_props
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|prophash
argument_list|,
name|clear_recorded_info
argument_list|,
name|NULL
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run our workqueue item for sync'ing flags with props. */
if|if
condition|(
name|work_item
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|notify_action
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|prop_name
operator|=
name|name
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
call|(
modifier|*
name|notify_func
call|)
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A baton for propset_walk_cb. */
end_comment

begin_struct
struct|struct
name|propset_walk_baton
block|{
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
comment|/* The name of the property to set. */
specifier|const
name|svn_string_t
modifier|*
name|propval
decl_stmt|;
comment|/* The value to set. */
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
comment|/* Database for the tree being walked. */
name|svn_boolean_t
name|force
decl_stmt|;
comment|/* True iff force was passed. */
name|svn_wc_notify_func2_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An node-walk callback for svn_wc_prop_set4().  *  * For LOCAL_ABSPATH, set the property named wb->PROPNAME to the value  * wb->PROPVAL, where "wb" is the WALK_BATON of type "struct  * propset_walk_baton *".  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|propset_walk_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|void
modifier|*
name|walk_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|propset_walk_baton
modifier|*
name|wb
init|=
name|walk_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|do_propset
argument_list|(
name|wb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|kind
argument_list|,
name|wb
operator|->
name|propname
argument_list|,
name|wb
operator|->
name|propval
argument_list|,
name|wb
operator|->
name|force
argument_list|,
name|wb
operator|->
name|notify_func
argument_list|,
name|wb
operator|->
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ILLEGAL_TARGET
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_prop_set4
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|skip_checks
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelist_filter
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|enum
name|svn_prop_kind
name|prop_kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
comment|/* we don't do entry properties here */
if|if
condition|(
name|prop_kind
operator|==
name|svn_prop_entry_kind
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROP_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Property '%s' is an entry property"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Check to see if we're setting the dav cache. */
if|if
condition|(
name|prop_kind
operator|==
name|svn_prop_wc_kind
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|depth
operator|==
name|svn_depth_empty
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|wcprop_set
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|svn_wc__db_status_normal
operator|&&
name|status
operator|!=
name|svn_wc__db_status_added
operator|&&
name|status
operator|!=
name|svn_wc__db_status_incomplete
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_INVALID_SCHEDULE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't set properties on '%s':"
literal|" invalid status for updating properties."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* We have to do this little DIR_ABSPATH dance for backwards compat.      But from 1.7 onwards, all locks are of infinite depth, and from 1.6      backward we never call this API with depth> empty, so we only need      to do the write check once per call, here (and not for every node in      the node walker).       ### Note that we could check for a write lock on local_abspath first      ### if we would want to. And then justy check for kind if that fails.      ### ... but we need kind for the "svn:" property checks anyway */
block|{
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|dir_abspath
operator|=
name|local_abspath
expr_stmt|;
else|else
name|dir_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Verify that we're holding this directory's write lock.  */
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|==
name|svn_depth_empty
operator|||
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
name|apr_hash_t
modifier|*
name|changelist_hash
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|changelist_filter
operator|&&
name|changelist_filter
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|svn_hash_from_cstring_keys
argument_list|(
operator|&
name|changelist_hash
argument_list|,
name|changelist_filter
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_wc__internal_changelist_match
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|changelist_hash
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|do_propset
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|kind
operator|==
name|svn_node_dir
condition|?
name|svn_node_dir
else|:
name|svn_node_file
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|skip_checks
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|propset_walk_baton
name|wb
decl_stmt|;
name|wb
operator|.
name|propname
operator|=
name|name
expr_stmt|;
name|wb
operator|.
name|propval
operator|=
name|value
expr_stmt|;
name|wb
operator|.
name|db
operator|=
name|wc_ctx
operator|->
name|db
expr_stmt|;
name|wb
operator|.
name|force
operator|=
name|skip_checks
expr_stmt|;
name|wb
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|wb
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__internal_walk_children
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|changelist_filter
argument_list|,
name|propset_walk_cb
argument_list|,
operator|&
name|wb
argument_list|,
name|depth
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Check that NAME names a regular prop. Return an error if it names an  * entry prop or a WC prop. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_prop_is_regular_kind
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|enum
name|svn_prop_kind
name|prop_kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* we don't do entry properties here */
if|if
condition|(
name|prop_kind
operator|==
name|svn_prop_entry_kind
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROP_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Property '%s' is an entry property"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Check to see if we're setting the dav cache. */
if|if
condition|(
name|prop_kind
operator|==
name|svn_prop_wc_kind
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROP_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Property '%s' is a WC property, not "
literal|"a regular property"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__canonicalize_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|prepared_props
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_boolean_t
name|skip_some_checks
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|mime_type
decl_stmt|;
name|struct
name|getter_baton
name|gb
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* While we allocate new parts of *PREPARED_PROPS in RESULT_POOL, we      don't promise to deep-copy the unchanged keys and values. */
operator|*
name|prepared_props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Before we can canonicalize svn:eol-style we need to know svn:mime-type,    * so process that first. */
name|mime_type
operator|=
name|svn_hash_gets
argument_list|(
operator|(
name|apr_hash_t
operator|*
operator|)
name|props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mime_type
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_canonicalize_svn_prop
argument_list|(
operator|&
name|mime_type
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|,
name|mime_type
argument_list|,
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
name|skip_some_checks
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|prepared_props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|,
name|mime_type
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the context for canonicalizing the other properties. */
name|gb
operator|.
name|mime_type
operator|=
name|mime_type
expr_stmt|;
name|gb
operator|.
name|local_abspath
operator|=
name|local_abspath
expr_stmt|;
comment|/* Check and canonicalize the other properties. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
operator|(
name|apr_hash_t
operator|*
operator|)
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|ensure_prop_is_regular_kind
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_canonicalize_svn_prop
argument_list|(
operator|&
name|value
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
name|skip_some_checks
argument_list|,
name|get_file_for_validation
argument_list|,
operator|&
name|gb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|prepared_props
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_canonicalize_svn_prop
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|propval_p
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|propval
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_boolean_t
name|skip_some_checks
parameter_list|,
name|svn_wc_canonicalize_svn_prop_get_file_t
name|getter
parameter_list|,
name|void
modifier|*
name|getter_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|new_value
init|=
name|NULL
decl_stmt|;
comment|/* Keep this static, it may get stored (for read-only purposes) in a      hash that outlives this function. */
specifier|static
specifier|const
name|svn_string_t
name|boolean_value
init|=
block|{
name|SVN_PROP_BOOLEAN_TRUE
block|,
sizeof|sizeof
argument_list|(
name|SVN_PROP_BOOLEAN_TRUE
argument_list|)
operator|-
literal|1
block|}
decl_stmt|;
name|SVN_ERR
argument_list|(
name|validate_prop_against_node_kind
argument_list|(
name|propname
argument_list|,
name|path
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This code may place the new prop val in either NEW_VALUE or PROPVAL. */
if|if
condition|(
operator|!
name|skip_some_checks
operator|&&
operator|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|svn_subst_eol_style_t
name|eol_style
decl_stmt|;
specifier|const
name|char
modifier|*
name|ignored_eol
decl_stmt|;
name|new_value
operator|=
name|svn_stringbuf_create_from_string
argument_list|(
name|propval
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|new_value
argument_list|)
expr_stmt|;
name|svn_subst_eol_style_from_value
argument_list|(
operator|&
name|eol_style
argument_list|,
operator|&
name|ignored_eol
argument_list|,
name|new_value
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_style
operator|==
name|svn_subst_eol_style_unknown
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_UNKNOWN_EOL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unrecognized line ending style '%s' for '%s'"
argument_list|)
argument_list|,
name|new_value
operator|->
name|data
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|validate_eol_prop_against_file
argument_list|(
name|path
argument_list|,
name|getter
argument_list|,
name|getter_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|skip_some_checks
operator|&&
operator|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|new_value
operator|=
name|svn_stringbuf_create_from_string
argument_list|(
name|propval
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|new_value
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mime_type_validate
argument_list|(
name|new_value
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_IGNORE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_INHERITABLE_IGNORES
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_INHERITABLE_AUTO_PROPS
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Make sure that the last line ends in a newline */
if|if
condition|(
name|propval
operator|->
name|len
operator|==
literal|0
operator|||
name|propval
operator|->
name|data
index|[
name|propval
operator|->
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|new_value
operator|=
name|svn_stringbuf_create_from_string
argument_list|(
name|propval
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|new_value
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure this is a valid externals property.  Do not          allow 'skip_some_checks' to override, as there is no circumstance in          which this is proper (because there is no circumstance in          which Subversion can handle it). */
if|if
condition|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We don't allow "." nor ".." as target directories in              an svn:externals line.  As it happens, our parse code              checks for this, so all we have to is invoke it --              we're not interested in the parsed result, only in              whether or not the parsing errored. */
name|apr_array_header_t
modifier|*
name|externals
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|duplicate_targets
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_parse_externals_description3
argument_list|(
operator|&
name|externals
argument_list|,
name|path
argument_list|,
name|propval
operator|->
name|data
argument_list|,
name|FALSE
argument_list|,
comment|/*scratch_*/
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__externals_find_target_dups
argument_list|(
operator|&
name|duplicate_targets
argument_list|,
name|externals
argument_list|,
comment|/*scratch_*/
name|pool
argument_list|,
comment|/*scratch_*/
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicate_targets
operator|&&
name|duplicate_targets
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|more_str
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|duplicate_targets
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
name|more_str
operator|=
name|apr_psprintf
argument_list|(
comment|/*scratch_*/
name|pool
argument_list|,
name|_
argument_list|(
literal|" (%d more duplicate targets found)"
argument_list|)
argument_list|,
name|duplicate_targets
operator|->
name|nelts
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_DUPLICATE_EXTERNALS_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid %s property on '%s': "
literal|"target '%s' appears more than once%s"
argument_list|)
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|duplicate_targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|more_str
argument_list|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new_value
operator|=
name|svn_stringbuf_create_from_string
argument_list|(
name|propval
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|new_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svn_prop_is_boolean
argument_list|(
name|propname
argument_list|)
condition|)
block|{
comment|/* SVN_PROP_EXECUTABLE, SVN_PROP_NEEDS_LOCK, SVN_PROP_SPECIAL */
name|propval
operator|=
operator|&
name|boolean_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_hash_t
modifier|*
name|mergeinfo
decl_stmt|;
name|svn_string_t
modifier|*
name|new_value_str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|propval
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Non-inheritable mergeinfo is only valid on directories. */
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
operator|&&
name|svn_mergeinfo__is_noninheritable
argument_list|(
name|mergeinfo
argument_list|,
name|pool
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot set non-inheritable mergeinfo on a non-directory ('%s')"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|new_value_str
argument_list|,
name|mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|propval
operator|=
name|new_value_str
expr_stmt|;
block|}
if|if
condition|(
name|new_value
condition|)
operator|*
name|propval_p
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|new_value
argument_list|)
expr_stmt|;
else|else
operator|*
name|propval_p
operator|=
name|propval
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_wc_is_normal_prop
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|enum
name|svn_prop_kind
name|kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
operator|(
name|kind
operator|==
name|svn_prop_regular_kind
operator|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_wc_is_wc_prop
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|enum
name|svn_prop_kind
name|kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
operator|(
name|kind
operator|==
name|svn_prop_wc_kind
operator|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_wc_is_entry_prop
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|enum
name|svn_prop_kind
name|kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
operator|(
name|kind
operator|==
name|svn_prop_entry_kind
operator|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__props_modified
parameter_list|(
name|svn_boolean_t
modifier|*
name|modified_p
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|modified_p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_props_modified_p2
parameter_list|(
name|svn_boolean_t
modifier|*
name|modified_p
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__props_modified
argument_list|(
name|modified_p
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_propdiff
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|propchanges
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|original_props
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|baseprops
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### if pristines are not defined, then should this raise an error,      ### or use an empty set?  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|baseprops
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|original_props
operator|!=
name|NULL
condition|)
operator|*
name|original_props
operator|=
name|baseprops
expr_stmt|;
if|if
condition|(
name|propchanges
operator|!=
name|NULL
condition|)
block|{
name|apr_hash_t
modifier|*
name|actual_props
decl_stmt|;
comment|/* Some nodes do not have pristine props, so let's just use an empty          set here. Thus, any ACTUAL props are additions.  */
if|if
condition|(
name|baseprops
operator|==
name|NULL
condition|)
name|baseprops
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|actual_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### be wary. certain nodes don't have ACTUAL props either. we          ### may want to raise an error. or maybe that is a deletion of          ### any potential pristine props?  */
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
name|propchanges
argument_list|,
name|actual_props
argument_list|,
name|baseprops
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_get_prop_diffs2
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|propchanges
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|original_props
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__internal_propdiff
argument_list|(
name|propchanges
argument_list|,
name|original_props
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_wc__has_magic_property
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|properties
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|properties
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|property
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|properties
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|property
operator|->
name|name
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|property
operator|->
name|name
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|property
operator|->
name|name
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|property
operator|->
name|name
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|property
operator|->
name|name
argument_list|,
name|SVN_PROP_NEEDS_LOCK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_iprops
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|inherited_props
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_read_inherited_props
argument_list|(
name|inherited_props
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|propname
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_cached_iprop_children
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|iprop_paths
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_children_with_cached_iprops
argument_list|(
name|iprop_paths
argument_list|,
name|depth
argument_list|,
name|local_abspath
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

