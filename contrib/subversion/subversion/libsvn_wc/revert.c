begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * revert.c: Handling of the in-wc side of the revert operation  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_comment
comment|/* Thoughts on Reversion.      What does is mean to revert a given PATH in a tree?  We'll     consider things by their modifications.      Adds      - For files, svn_wc_remove_from_revision_control(), baby.      - Added directories may contain nothing but added children, and       reverting the addition of a directory necessarily means reverting       the addition of all the directory's children.  Again,       svn_wc_remove_from_revision_control() should do the trick.      Deletes      - Restore properties to their unmodified state.      - For files, restore the pristine contents, and reset the schedule       to 'normal'.      - For directories, reset the schedule to 'normal'.  All children       of a directory marked for deletion must also be marked for       deletion, but it's okay for those children to remain deleted even       if their parent directory is restored.  That's what the       recursive flag is for.      Replaces      - Restore properties to their unmodified state.      - For files, restore the pristine contents, and reset the schedule       to 'normal'.      - For directories, reset the schedule to normal.  A replaced       directory can have deleted children (left over from the initial       deletion), replaced children (children of the initial deletion       now re-added), and added children (new entries under the       replaced directory).  Since this is technically an addition, it       necessitates recursion.      Modifications      - Restore properties and, for files, contents to their unmodified       state.  */
end_comment

begin_comment
comment|/* Remove conflict file CONFLICT_ABSPATH, which may not exist, and set  * *NOTIFY_REQUIRED to TRUE if the file was present and removed. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_conflict_file
parameter_list|(
name|svn_boolean_t
modifier|*
name|notify_required
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|conflict_abspath
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_remove_file2
argument_list|(
name|conflict_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
operator|*
name|notify_required
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Sort copied children obtained from the revert list based on  * their paths in descending order (longest paths first). */
end_comment

begin_function
specifier|static
name|int
name|compare_revert_list_copied_children
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_wc__db_revert_list_copied_child_info_t
modifier|*
specifier|const
modifier|*
name|ca
init|=
name|a
decl_stmt|;
specifier|const
name|svn_wc__db_revert_list_copied_child_info_t
modifier|*
specifier|const
modifier|*
name|cb
init|=
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|svn_path_compare_paths
argument_list|(
name|ca
index|[
literal|0
index|]
operator|->
name|abspath
argument_list|,
name|cb
index|[
literal|0
index|]
operator|->
name|abspath
argument_list|)
expr_stmt|;
comment|/* Reverse the result of svn_path_compare_paths() to achieve    * descending order. */
return|return
operator|-
name|i
return|;
block|}
end_function

begin_comment
comment|/* Remove all reverted copied children from the directory at LOCAL_ABSPATH.  * If REMOVE_SELF is TRUE, try to remove LOCAL_ABSPATH itself (REMOVE_SELF  * should be set if LOCAL_ABSPATH is itself a reverted copy).  *  * If REMOVED_SELF is not NULL, indicate in *REMOVED_SELF whether  * LOCAL_ABSPATH itself was removed.  *  * All reverted copied file children are removed from disk. Reverted copied  * directories left empty as a result are also removed from disk.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|revert_restore_handle_copied_dirs
parameter_list|(
name|svn_boolean_t
modifier|*
name|removed_self
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|remove_self
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|copied_children
decl_stmt|;
name|svn_wc__db_revert_list_copied_child_info_t
modifier|*
name|child_info
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_node_kind_t
name|on_disk
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|removed_self
condition|)
operator|*
name|removed_self
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_revert_list_read_copied_children
argument_list|(
operator|&
name|copied_children
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Remove all copied file children. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copied_children
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|child_info
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|copied_children
argument_list|,
name|i
argument_list|,
name|svn_wc__db_revert_list_copied_child_info_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_info
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Make sure what we delete from disk is really a file. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|child_info
operator|->
name|abspath
argument_list|,
operator|&
name|on_disk
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on_disk
operator|!=
name|svn_node_file
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|child_info
operator|->
name|abspath
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Delete every empty child directory.    * We cannot delete children recursively since we want to keep any files    * that still exist on disk (e.g. unversioned files within the copied tree).    * So sort the children list such that longest paths come first and try to    * remove each child directory in order. */
name|qsort
argument_list|(
name|copied_children
operator|->
name|elts
argument_list|,
name|copied_children
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc__db_revert_list_copied_child_info_t
operator|*
argument_list|)
argument_list|,
name|compare_revert_list_copied_children
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copied_children
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|child_info
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|copied_children
argument_list|,
name|i
argument_list|,
name|svn_wc__db_revert_list_copied_child_info_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_info
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_dir_remove_nonrecursive
argument_list|(
name|child_info
operator|->
name|abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|APR_STATUS_IS_ENOTEMPTY
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|remove_self
condition|)
block|{
comment|/* Delete LOCAL_ABSPATH itself if no children are left. */
name|err
operator|=
name|svn_io_dir_remove_nonrecursive
argument_list|(
name|local_abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOTEMPTY
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|removed_self
condition|)
operator|*
name|removed_self
operator|=
name|TRUE
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make the working tree under LOCAL_ABSPATH to depth DEPTH match the    versioned tree.  This function is called after svn_wc__db_op_revert    has done the database revert and created the revert list.  Notifies    for all paths equal to or below LOCAL_ABSPATH that are reverted.     REVERT_ROOT is true for explicit revert targets and FALSE for targets    reached via recursion.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|revert_restore
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_boolean_t
name|revert_root
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_node_kind_t
name|on_disk
decl_stmt|;
name|svn_boolean_t
name|notify_required
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|conflict_files
decl_stmt|;
name|svn_filesize_t
name|recorded_size
decl_stmt|;
name|apr_time_t
name|recorded_time
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
name|svn_boolean_t
name|special
decl_stmt|;
endif|#
directive|endif
name|svn_boolean_t
name|copied_here
decl_stmt|;
name|svn_node_kind_t
name|reverted_kind
decl_stmt|;
name|svn_boolean_t
name|is_wcroot
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_wcroot
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_wcroot
operator|&&
operator|!
name|revert_root
condition|)
block|{
comment|/* Issue #4162: Obstructing working copy. We can't access the working          copy data from the parent working copy for this node by just using          local_abspath */
if|if
condition|(
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_update_skip_obstruction
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
comment|/* We don't revert obstructing working copies */
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_revert_list_read
argument_list|(
operator|&
name|notify_required
argument_list|,
operator|&
name|conflict_files
argument_list|,
operator|&
name|copied_here
argument_list|,
operator|&
name|reverted_kind
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|recorded_size
argument_list|,
operator|&
name|recorded_time
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copied_here
condition|)
block|{
if|if
condition|(
name|notify_func
operator|&&
name|notify_required
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_revert
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_revert_list_notify
argument_list|(
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* ### Initialise to values which prevent the code below from            * ### trying to restore anything to disk.            * ### 'status' should be status_unknown but that doesn't exist. */
name|status
operator|=
name|svn_wc__db_status_normal
expr_stmt|;
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|recorded_size
operator|=
name|SVN_INVALID_FILESIZE
expr_stmt|;
name|recorded_time
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|err
operator|=
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|local_abspath
argument_list|,
name|APR_FINFO_TYPE
operator||
name|APR_FINFO_LINK
operator||
name|APR_FINFO_SIZE
operator||
name|APR_FINFO_MTIME
operator||
name|SVN__APR_FINFO_EXECUTABLE
operator||
name|SVN__APR_FINFO_READONLY
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|on_disk
operator|=
name|svn_node_none
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
name|special
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|err
condition|)
block|{
if|if
condition|(
name|finfo
operator|.
name|filetype
operator|==
name|APR_REG
operator|||
name|finfo
operator|.
name|filetype
operator|==
name|APR_LNK
condition|)
name|on_disk
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
name|finfo
operator|.
name|filetype
operator|==
name|APR_DIR
condition|)
name|on_disk
operator|=
name|svn_node_dir
expr_stmt|;
else|else
name|on_disk
operator|=
name|svn_node_unknown
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
name|special
operator|=
operator|(
name|finfo
operator|.
name|filetype
operator|==
name|APR_LNK
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
name|copied_here
condition|)
block|{
comment|/* The revert target itself is the op-root of a copy. */
if|if
condition|(
name|reverted_kind
operator|==
name|svn_node_file
operator|&&
name|on_disk
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|on_disk
operator|=
name|svn_node_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reverted_kind
operator|==
name|svn_node_dir
operator|&&
name|on_disk
operator|==
name|svn_node_dir
condition|)
block|{
name|svn_boolean_t
name|removed
decl_stmt|;
name|SVN_ERR
argument_list|(
name|revert_restore_handle_copied_dirs
argument_list|(
operator|&
name|removed
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
condition|)
name|on_disk
operator|=
name|svn_node_none
expr_stmt|;
block|}
block|}
comment|/* If we expect a versioned item to be present then check that any      item on disk matches the versioned item, if it doesn't match then      fix it or delete it.  */
if|if
condition|(
name|on_disk
operator|!=
name|svn_node_none
operator|&&
name|status
operator|!=
name|svn_wc__db_status_server_excluded
operator|&&
name|status
operator|!=
name|svn_wc__db_status_deleted
operator|&&
name|status
operator|!=
name|svn_wc__db_status_excluded
operator|&&
name|status
operator|!=
name|svn_wc__db_status_not_present
condition|)
block|{
if|if
condition|(
name|on_disk
operator|==
name|svn_node_dir
operator|&&
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|on_disk
operator|=
name|svn_node_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|on_disk
operator|==
name|svn_node_file
operator|&&
name|kind
operator|!=
name|svn_node_file
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
comment|/* Preserve symlinks pointing at directories. Changes on the            * directory node have been reverted. The symlink should remain. */
if|if
condition|(
operator|!
operator|(
name|special
operator|&&
name|kind
operator|==
name|svn_node_dir
operator|)
condition|)
endif|#
directive|endif
block|{
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|on_disk
operator|=
name|svn_node_none
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|on_disk
operator|==
name|svn_node_file
condition|)
block|{
name|svn_boolean_t
name|modified
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
name|svn_string_t
modifier|*
name|special_prop
decl_stmt|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
name|special_prop
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|special_prop
operator|!=
name|NULL
operator|)
operator|!=
name|special
condition|)
block|{
comment|/* File/symlink mismatch. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|on_disk
operator|=
name|svn_node_none
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Issue #1663 asserts that we should compare a file in its                  working copy format here, but before r1101473 we would only                  do that if the file was already unequal to its recorded                  information.                   r1101473 removes the option of asking for a working format                  compare but *also* check the recorded information first, as                  that combination doesn't guarantee a stable behavior.                  (See the revert_test.py: revert_reexpand_keyword)                   But to have the same issue #1663 behavior for revert as we                  had in<=1.6 we only have to check the recorded information                  ourselves. And we already have everything we need, because                  we called stat ourselves. */
if|if
condition|(
name|recorded_size
operator|!=
name|SVN_INVALID_FILESIZE
operator|&&
name|recorded_time
operator|!=
literal|0
operator|&&
name|recorded_size
operator|==
name|finfo
operator|.
name|size
operator|&&
name|recorded_time
operator|==
name|finfo
operator|.
name|mtime
condition|)
block|{
name|modified
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__internal_file_modified_p
argument_list|(
operator|&
name|modified
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|on_disk
operator|=
name|svn_node_none
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_normal
condition|)
block|{
name|svn_boolean_t
name|read_only
decl_stmt|;
name|svn_string_t
modifier|*
name|needs_lock_prop
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io__is_finfo_read_only
argument_list|(
operator|&
name|read_only
argument_list|,
operator|&
name|finfo
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|needs_lock_prop
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_NEEDS_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_lock_prop
operator|&&
operator|!
name|read_only
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify_required
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|needs_lock_prop
operator|&&
name|read_only
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_write
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify_required
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
if|if
condition|(
operator|!
name|special
condition|)
endif|#
directive|endif
block|{
name|svn_boolean_t
name|executable
decl_stmt|;
name|svn_string_t
modifier|*
name|executable_prop
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io__is_finfo_executable
argument_list|(
operator|&
name|executable
argument_list|,
operator|&
name|finfo
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|executable_prop
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|executable_prop
operator|&&
operator|!
name|executable
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_set_file_executable
argument_list|(
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify_required
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|executable_prop
operator|&&
name|executable
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_set_file_executable
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify_required
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
block|}
block|}
comment|/* If we expect a versioned item to be present and there is nothing      on disk then recreate it. */
if|if
condition|(
name|on_disk
operator|==
name|svn_node_none
operator|&&
name|status
operator|!=
name|svn_wc__db_status_server_excluded
operator|&&
name|status
operator|!=
name|svn_wc__db_status_deleted
operator|&&
name|status
operator|!=
name|svn_wc__db_status_excluded
operator|&&
name|status
operator|!=
name|svn_wc__db_status_not_present
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|local_abspath
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
comment|/* ### Get the checksum from read_info above and pass in here? */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|use_commit_times
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_add
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|notify_required
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|conflict_files
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|conflict_files
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|SVN_ERR
argument_list|(
name|remove_conflict_file
argument_list|(
operator|&
name|notify_required
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|conflict_files
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|notify_func
operator|&&
name|notify_required
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_revert
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_infinity
operator|&&
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|revert_restore_handle_copied_dirs
argument_list|(
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children_of_working_node
argument_list|(
operator|&
name|children
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|revert_restore
argument_list|(
name|db
argument_list|,
name|child_abspath
argument_list|,
name|depth
argument_list|,
name|use_commit_times
argument_list|,
name|FALSE
comment|/* revert root */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_revert_list_notify
argument_list|(
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__revert_internal
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|depth
operator|==
name|svn_depth_empty
operator|||
name|depth
operator|==
name|svn_depth_infinity
argument_list|)
expr_stmt|;
comment|/* We should have a write lock on the parent of local_abspath, except      when local_abspath is the working copy root. */
block|{
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
name|svn_boolean_t
name|is_wcroot
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_wcroot
argument_list|(
operator|&
name|is_wcroot
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_wcroot
condition|)
name|dir_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|dir_abspath
operator|=
name|local_abspath
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_wc__db_op_revert
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|revert_restore
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|use_commit_times
argument_list|,
name|TRUE
comment|/* revert root */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_wc__db_revert_list_done
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Revert files in LOCAL_ABSPATH to depth DEPTH that match    CHANGELIST_HASH and notify for all reverts. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|revert_changelist
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|apr_hash_t
modifier|*
name|changelist_hash
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Revert this node (depth=empty) if it matches one of the changelists.  */
if|if
condition|(
name|svn_wc__internal_changelist_match
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|changelist_hash
argument_list|,
name|scratch_pool
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__revert_internal
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|svn_depth_empty
argument_list|,
name|use_commit_times
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_empty
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* We can handle both depth=files and depth=immediates by setting      depth=empty here.  We don't need to distinguish files and      directories when making the recursive call because directories      can never match a changelist, so making the recursive call for      directories when asked for depth=files is a no-op. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|||
name|depth
operator|==
name|svn_depth_immediates
condition|)
name|depth
operator|=
name|svn_depth_empty
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children_of_working_node
argument_list|(
operator|&
name|children
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|revert_changelist
argument_list|(
name|db
argument_list|,
name|child_abspath
argument_list|,
name|depth
argument_list|,
name|use_commit_times
argument_list|,
name|changelist_hash
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Does a partially recursive revert of LOCAL_ABSPATH to depth DEPTH    (which must be either svn_depth_files or svn_depth_immediates) by    doing a non-recursive revert on each permissible path.  Notifies    all reverted paths.     ### This won't revert a copied dir with one level of children since    ### the non-recursive revert on the dir will fail.  Not sure how a    ### partially recursive revert should handle actual-only nodes. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|revert_partial
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|depth
operator|==
name|svn_depth_files
operator|||
name|depth
operator|==
name|svn_depth_immediates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Revert the root node itself (depth=empty), then move on to the      children.  */
name|SVN_ERR
argument_list|(
name|svn_wc__revert_internal
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|svn_depth_empty
argument_list|,
name|use_commit_times
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children_of_working_node
argument_list|(
operator|&
name|children
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|child_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|child_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* For svn_depth_files: don't revert non-files.  */
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_kind
argument_list|(
operator|&
name|kind
argument_list|,
name|db
argument_list|,
name|child_abspath
argument_list|,
name|FALSE
comment|/* allow_missing */
argument_list|,
name|TRUE
comment|/* show_deleted */
argument_list|,
name|FALSE
comment|/* show_hidden */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
continue|continue;
block|}
comment|/* Revert just this node (depth=empty).  */
name|SVN_ERR
argument_list|(
name|svn_wc__revert_internal
argument_list|(
name|db
argument_list|,
name|child_abspath
argument_list|,
name|svn_depth_empty
argument_list|,
name|use_commit_times
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_revert4
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelist_filter
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|changelist_filter
operator|&&
name|changelist_filter
operator|->
name|nelts
condition|)
block|{
name|apr_hash_t
modifier|*
name|changelist_hash
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_from_cstring_keys
argument_list|(
operator|&
name|changelist_hash
argument_list|,
name|changelist_filter
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|revert_changelist
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|use_commit_times
argument_list|,
name|changelist_hash
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|depth
operator|==
name|svn_depth_empty
operator|||
name|depth
operator|==
name|svn_depth_infinity
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__revert_internal
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|use_commit_times
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* The user may expect svn_depth_files/svn_depth_immediates to work      on copied dirs with one level of children.  It doesn't, the user      will get an error and will need to invoke an infinite revert.  If      we identified those cases where svn_depth_infinity would not      revert too much we could invoke the recursive call above. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|||
name|depth
operator|==
name|svn_depth_immediates
condition|)
return|return
name|svn_error_trace
argument_list|(
name|revert_partial
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|use_commit_times
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* Bogus depth. Tell the caller.  */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_INVALID_OPERATION_DEPTH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

end_unit

