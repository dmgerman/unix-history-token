begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * questions.c:  routines for asking questions about working copies  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|<apr_time.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_include
include|#
directive|include
file|"wc_db.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** svn_wc_text_modified_p ***/
end_comment

begin_comment
comment|/* svn_wc_text_modified_p answers the question:     "Are the contents of F different than the contents of    .svn/text-base/F.svn-base or .svn/tmp/text-base/F.svn-base?"     In the first case, we're looking to see if a user has made local    modifications to a file since the last update or commit.  In the    second, the file may not be versioned yet (it doesn't exist in    entries).  Support for the latter case came about to facilitate    forced checkouts, updates, and switches, where an unversioned file    may obstruct a file about to be added.     Note: Assuming that F lives in a directory D at revision V, please    notice that we are *NOT* answering the question, "are the contents    of F different than revision V of F?"  While F may be at a different    revision number than its parent directory, but we're only looking    for local edits on F, not for consistent directory revisions.     TODO:  the logic of the routines on this page might change in the    future, as they bear some relation to the user interface.  For    example, if a file is removed -- without telling subversion about    it -- how should subversion react?  Should it copy the file back    out of text-base?  Should it ask whether one meant to officially    mark it for removal? */
end_comment

begin_comment
comment|/* Set *MODIFIED_P to TRUE if (after translation) VERSIONED_FILE_ABSPATH  * (of VERSIONED_FILE_SIZE bytes) differs from PRISTINE_STREAM (of  * PRISTINE_SIZE bytes), else to FALSE if not.  *  * If EXACT_COMPARISON is FALSE, translate VERSIONED_FILE_ABSPATH's EOL  * style and keywords to repository-normal form according to its properties,  * and compare the result with PRISTINE_STREAM.  If EXACT_COMPARISON is  * TRUE, translate PRISTINE_STREAM's EOL style and keywords to working-copy  * form according to VERSIONED_FILE_ABSPATH's properties, and compare the  * result with VERSIONED_FILE_ABSPATH.  *  * HAS_PROPS should be TRUE if the file had properties when it was not  * modified, otherwise FALSE.  *  * PROPS_MOD should be TRUE if the file's properties have been changed,  * otherwise FALSE.  *  * PRISTINE_STREAM will be closed before a successful return.  *  * DB is a wc_db; use SCRATCH_POOL for temporary allocation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|compare_and_verify
parameter_list|(
name|svn_boolean_t
modifier|*
name|modified_p
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|versioned_file_abspath
parameter_list|,
name|svn_filesize_t
name|versioned_file_size
parameter_list|,
name|svn_stream_t
modifier|*
name|pristine_stream
parameter_list|,
name|svn_filesize_t
name|pristine_size
parameter_list|,
name|svn_boolean_t
name|has_props
parameter_list|,
name|svn_boolean_t
name|props_mod
parameter_list|,
name|svn_boolean_t
name|exact_comparison
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|same
decl_stmt|;
name|svn_subst_eol_style_t
name|eol_style
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|apr_hash_t
modifier|*
name|keywords
decl_stmt|;
name|svn_boolean_t
name|special
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|need_translation
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|versioned_file_abspath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|props_mod
condition|)
name|has_props
operator|=
name|TRUE
expr_stmt|;
comment|/* Maybe it didn't have properties; but it has now */
if|if
condition|(
name|has_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__get_translate_info
argument_list|(
operator|&
name|eol_style
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|keywords
argument_list|,
operator|&
name|special
argument_list|,
name|db
argument_list|,
name|versioned_file_abspath
argument_list|,
name|NULL
argument_list|,
operator|!
name|exact_comparison
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|need_translation
operator|=
name|svn_subst_translation_required
argument_list|(
name|eol_style
argument_list|,
name|eol_str
argument_list|,
name|keywords
argument_list|,
name|special
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|need_translation
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|need_translation
operator|&&
operator|(
name|versioned_file_size
operator|!=
name|pristine_size
operator|)
condition|)
block|{
operator|*
name|modified_p
operator|=
name|TRUE
expr_stmt|;
comment|/* ### Why did we open the pristine? */
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_close
argument_list|(
name|pristine_stream
argument_list|)
argument_list|)
return|;
block|}
comment|/* ### Other checks possible? */
if|if
condition|(
name|need_translation
condition|)
block|{
comment|/* Reading files is necessary. */
name|svn_stream_t
modifier|*
name|v_stream
decl_stmt|;
comment|/* versioned_file */
if|if
condition|(
name|special
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_subst_read_specialfile
argument_list|(
operator|&
name|v_stream
argument_list|,
name|versioned_file_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|v_stream
argument_list|,
name|versioned_file_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exact_comparison
operator|&&
name|need_translation
condition|)
block|{
if|if
condition|(
name|eol_style
operator|==
name|svn_subst_eol_style_native
condition|)
name|eol_str
operator|=
name|SVN_SUBST_NATIVE_EOL_STR
expr_stmt|;
elseif|else
if|if
condition|(
name|eol_style
operator|!=
name|svn_subst_eol_style_fixed
operator|&&
name|eol_style
operator|!=
name|svn_subst_eol_style_none
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_UNKNOWN_EOL
argument_list|,
name|svn_stream_close
argument_list|(
name|v_stream
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Wrap file stream to detranslate into normal form,                * "repairing" the EOL style if it is inconsistent. */
name|v_stream
operator|=
name|svn_subst_stream_translated
argument_list|(
name|v_stream
argument_list|,
name|eol_str
argument_list|,
name|TRUE
comment|/* repair */
argument_list|,
name|keywords
argument_list|,
name|FALSE
comment|/* expand */
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_translation
condition|)
block|{
comment|/* Wrap base stream to translate into working copy form, and                * arrange to throw an error if its EOL style is inconsistent. */
name|pristine_stream
operator|=
name|svn_subst_stream_translated
argument_list|(
name|pristine_stream
argument_list|,
name|eol_str
argument_list|,
name|FALSE
argument_list|,
name|keywords
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_contents_same2
argument_list|(
operator|&
name|same
argument_list|,
name|pristine_stream
argument_list|,
name|v_stream
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Translation would be a no-op, so compare the original file. */
name|svn_stream_t
modifier|*
name|v_stream
decl_stmt|;
comment|/* versioned_file */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|v_stream
argument_list|,
name|versioned_file_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_contents_same2
argument_list|(
operator|&
name|same
argument_list|,
name|pristine_stream
argument_list|,
name|v_stream
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|modified_p
operator|=
operator|(
operator|!
name|same
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_file_modified_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|modified_p
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|exact_comparison
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|pristine_stream
decl_stmt|;
name|svn_filesize_t
name|pristine_size
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_filesize_t
name|recorded_size
decl_stmt|;
name|apr_time_t
name|recorded_mod_time
decl_stmt|;
name|svn_boolean_t
name|has_props
decl_stmt|;
name|svn_boolean_t
name|props_mod
decl_stmt|;
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
decl_stmt|;
comment|/* Read the relevant info */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|recorded_size
argument_list|,
operator|&
name|recorded_mod_time
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|has_props
argument_list|,
operator|&
name|props_mod
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we don't have a pristine or the node has a status that allows a      pristine, just say that the node is modified */
if|if
condition|(
operator|!
name|checksum
operator|||
operator|(
name|kind
operator|!=
name|svn_node_file
operator|)
operator|||
operator|(
operator|(
name|status
operator|!=
name|svn_wc__db_status_normal
operator|)
operator|&&
operator|(
name|status
operator|!=
name|svn_wc__db_status_added
operator|)
operator|)
condition|)
block|{
operator|*
name|modified_p
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|dirent
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
block|{
comment|/* There is no file on disk, so the text is missing, not modified. */
operator|*
name|modified_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|exact_comparison
condition|)
block|{
comment|/* We're allowed to use a heuristic to determine whether files may          have changed.  The heuristic has these steps:           1. Compare the working file's size             with the size cached in the entries file          2. If they differ, do a full file compare          3. Compare the working file's timestamp             with the timestamp cached in the entries file          4. If they differ, do a full file compare          5. Otherwise, return indicating an unchanged file.           There are 2 problematic situations which may occur:           1. The cached working size is missing          --> In this case, we forget we ever tried to compare              and skip to the timestamp comparison.  This is              because old working copies do not contain cached sizes           2. The cached timestamp is missing          --> In this case, we forget we ever tried to compare              and skip to full file comparison.  This is because              the timestamp will be removed when the library              updates a locally changed file.  (ie, this only happens              when the file was locally modified.)        */
comment|/* Compare the sizes, if applicable */
if|if
condition|(
name|recorded_size
operator|!=
name|SVN_INVALID_FILESIZE
operator|&&
name|dirent
operator|->
name|filesize
operator|!=
name|recorded_size
condition|)
goto|goto
name|compare_them
goto|;
comment|/* Compare the timestamps           Note: recorded_mod_time == 0 means not available,                which also means the timestamps won't be equal,                so there's no need to explicitly check the 'absent' value. */
if|if
condition|(
name|recorded_mod_time
operator|!=
name|dirent
operator|->
name|mtime
condition|)
goto|goto
name|compare_them
goto|;
operator|*
name|modified_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|compare_them
label|:
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_read
argument_list|(
operator|&
name|pristine_stream
argument_list|,
operator|&
name|pristine_size
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|checksum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check all bytes, and verify checksum if requested. */
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|compare_and_verify
argument_list|(
name|modified_p
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|dirent
operator|->
name|filesize
argument_list|,
name|pristine_stream
argument_list|,
name|pristine_size
argument_list|,
name|has_props
argument_list|,
name|props_mod
argument_list|,
name|exact_comparison
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* At this point we already opened the pristine file, so we know that        the access denied applies to the working copy path */
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EACCES
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_PATH_ACCESS_DENIED
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|modified_p
condition|)
block|{
name|svn_boolean_t
name|own_lock
decl_stmt|;
comment|/* The timestamp is missing or "broken" so "repair" it if we can. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock
argument_list|(
operator|&
name|own_lock
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|own_lock
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_global_record_fileinfo
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|dirent
operator|->
name|filesize
argument_list|,
name|dirent
operator|->
name|mtime
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_text_modified_p2
parameter_list|(
name|svn_boolean_t
modifier|*
name|modified_p
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|unused
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_wc__internal_file_modified_p
argument_list|(
name|modified_p
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|svn_error_t
modifier|*
name|internal_conflicted_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|text_conflicted_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|prop_conflicted_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|tree_conflicted_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|ignore_move_edit_p
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflicts
decl_stmt|;
name|svn_boolean_t
name|resolved_text
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|resolved_props
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflicts
condition|)
block|{
if|if
condition|(
name|text_conflicted_p
condition|)
operator|*
name|text_conflicted_p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|prop_conflicted_p
condition|)
operator|*
name|prop_conflicted_p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|tree_conflicted_p
condition|)
operator|*
name|tree_conflicted_p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ignore_move_edit_p
condition|)
operator|*
name|ignore_move_edit_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|text_conflicted_p
argument_list|,
name|prop_conflicted_p
argument_list|,
name|tree_conflicted_p
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_conflicted_p
operator|&&
operator|*
name|text_conflicted_p
condition|)
block|{
specifier|const
name|char
modifier|*
name|mine_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|their_old_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|their_abspath
decl_stmt|;
name|svn_boolean_t
name|done
init|=
name|FALSE
decl_stmt|;
comment|/* Look for any text conflict, exercising only as much effort as          necessary to obtain a definitive answer.  This only applies to          files, but we don't have to explicitly check that entry is a          file, since these attributes would never be set on a directory          anyway.  A conflict file entry notation only counts if the          conflict file still exists on disk.  */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_text_conflict
argument_list|(
operator|&
name|mine_abspath
argument_list|,
operator|&
name|their_old_abspath
argument_list|,
operator|&
name|their_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mine_abspath
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|mine_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|text_conflicted_p
operator|=
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|text_conflicted_p
condition|)
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
operator|&&
name|their_abspath
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|their_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|text_conflicted_p
operator|=
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|text_conflicted_p
condition|)
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
operator|&&
name|their_old_abspath
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|their_old_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|text_conflicted_p
operator|=
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|text_conflicted_p
condition|)
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
operator|&&
operator|(
name|mine_abspath
operator|||
name|their_abspath
operator|||
name|their_old_abspath
operator|)
condition|)
name|resolved_text
operator|=
name|TRUE
expr_stmt|;
comment|/* Remove in-db conflict marker */
block|}
if|if
condition|(
name|prop_conflicted_p
operator|&&
operator|*
name|prop_conflicted_p
condition|)
block|{
specifier|const
name|char
modifier|*
name|prej_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
operator|&
name|prej_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prej_abspath
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|prej_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|prop_conflicted_p
operator|=
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|prop_conflicted_p
condition|)
name|resolved_props
operator|=
name|TRUE
expr_stmt|;
comment|/* Remove in-db conflict marker */
block|}
block|}
if|if
condition|(
name|ignore_move_edit_p
condition|)
block|{
operator|*
name|ignore_move_edit_p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|tree_conflicted_p
operator|&&
operator|*
name|tree_conflicted_p
condition|)
block|{
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
name|svn_wc_conflict_action_t
name|action
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
operator|&
name|action
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|&&
name|action
operator|==
name|svn_wc_conflict_action_edit
condition|)
block|{
operator|*
name|tree_conflicted_p
operator|=
name|FALSE
expr_stmt|;
operator|*
name|ignore_move_edit_p
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|resolved_text
operator|||
name|resolved_props
condition|)
block|{
name|svn_boolean_t
name|own_lock
decl_stmt|;
comment|/* The marker files are missing, so "repair" wc.db if we can */
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock
argument_list|(
operator|&
name|own_lock
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|own_lock
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|resolved_text
argument_list|,
name|resolved_props
argument_list|,
name|FALSE
comment|/* resolved_tree */
argument_list|,
name|NULL
comment|/* work_items */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_conflicted_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|text_conflicted_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|prop_conflicted_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|tree_conflicted_p
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|internal_conflicted_p
argument_list|(
name|text_conflicted_p
argument_list|,
name|prop_conflicted_p
argument_list|,
name|tree_conflicted_p
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflicted_for_update_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|conflicted_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|conflict_ignored_p
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|tree_only
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|text_conflicted
decl_stmt|,
name|prop_conflicted
decl_stmt|,
name|tree_conflicted
decl_stmt|;
name|svn_boolean_t
name|conflict_ignored
decl_stmt|;
if|if
condition|(
operator|!
name|conflict_ignored_p
condition|)
name|conflict_ignored_p
operator|=
operator|&
name|conflict_ignored
expr_stmt|;
name|SVN_ERR
argument_list|(
name|internal_conflicted_p
argument_list|(
name|tree_only
condition|?
name|NULL
else|:
operator|&
name|text_conflicted
argument_list|,
name|tree_only
condition|?
name|NULL
else|:
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|conflict_ignored_p
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_only
condition|)
operator|*
name|conflicted_p
operator|=
name|tree_conflicted
expr_stmt|;
else|else
operator|*
name|conflicted_p
operator|=
name|text_conflicted
operator|||
name|prop_conflicted
operator|||
name|tree_conflicted
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_conflicted_p3
parameter_list|(
name|svn_boolean_t
modifier|*
name|text_conflicted_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|prop_conflicted_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|tree_conflicted_p
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__internal_conflicted_p
argument_list|(
name|text_conflicted_p
argument_list|,
name|prop_conflicted_p
argument_list|,
name|tree_conflicted_p
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__min_max_revisions
parameter_list|(
name|svn_revnum_t
modifier|*
name|min_revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|max_revision
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|committed
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_min_max_revisions
argument_list|(
name|min_revision
argument_list|,
name|max_revision
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|committed
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__has_switched_subtrees
parameter_list|(
name|svn_boolean_t
modifier|*
name|is_switched
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|trail_url
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_has_switched_subtrees
argument_list|(
name|is_switched
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|trail_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__has_local_mods
parameter_list|(
name|svn_boolean_t
modifier|*
name|is_modified
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_has_local_mods
argument_list|(
name|is_modified
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

