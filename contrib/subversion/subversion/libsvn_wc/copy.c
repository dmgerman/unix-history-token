begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * copy.c:  wc 'copy' functionality.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"props.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Make a copy of the filesystem node (or tree if RECURSIVE) at    SRC_ABSPATH under a temporary name in the directory    TMPDIR_ABSPATH and return the absolute path of the copy in    *DST_ABSPATH.  Return the node kind of SRC_ABSPATH in *KIND.  If    SRC_ABSPATH doesn't exist then set *DST_ABSPATH to NULL to indicate    that no copy was made. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_to_tmpdir
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|src_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|tmpdir_abspath
parameter_list|,
name|svn_boolean_t
name|file_copy
parameter_list|,
name|svn_boolean_t
name|unversioned
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_special
decl_stmt|;
name|svn_io_file_del_t
name|delete_when
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_tmp_abspath
decl_stmt|;
name|svn_node_kind_t
name|dsk_kind
decl_stmt|;
if|if
condition|(
operator|!
name|kind
condition|)
name|kind
operator|=
operator|&
name|dsk_kind
expr_stmt|;
operator|*
name|work_item
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|src_abspath
argument_list|,
name|kind
argument_list|,
operator|&
name|is_special
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|kind
operator|==
name|svn_node_none
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|kind
operator|==
name|svn_node_unknown
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Source '%s' is unexpected kind"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|kind
operator|==
name|svn_node_dir
operator|||
name|is_special
condition|)
name|delete_when
operator|=
name|svn_io_file_del_on_close
expr_stmt|;
else|else
comment|/* the default case: (*kind == svn_node_file) */
name|delete_when
operator|=
name|svn_io_file_del_none
expr_stmt|;
comment|/* ### Do we need a pool cleanup to remove the copy?  We can't use      ### svn_io_file_del_on_pool_cleanup above because a) it won't      ### handle the directory case and b) we need to be able to remove      ### the cleanup before queueing the move work item. */
if|if
condition|(
name|file_copy
operator|&&
operator|!
name|unversioned
condition|)
block|{
name|svn_boolean_t
name|modified
decl_stmt|;
comment|/* It's faster to look for mods on the source now, as          the timestamp might match, than to examine the          destination later as the destination timestamp will          never match. */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_file_modified_p
argument_list|(
operator|&
name|modified
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|modified
condition|)
block|{
comment|/* Why create a temp copy if we can just reinstall from pristine? */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
name|work_item
argument_list|,
name|db
argument_list|,
name|dst_abspath
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Set DST_TMP_ABSPATH to a temporary unique path.  If *KIND is file, leave      a file there and then overwrite it; otherwise leave no node on disk at      that path.  In the latter case, something else might use that path      before we get around to using it a moment later, but never mind. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|dst_tmp_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|delete_when
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
name|file_copy
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_copy_dir_recursively
argument_list|(
name|src_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|svn_dirent_basename
argument_list|(
name|dst_tmp_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
comment|/* copy_perms */
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|dst_tmp_abspath
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_special
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|src_abspath
argument_list|,
name|dst_tmp_abspath
argument_list|,
name|TRUE
comment|/* copy_perms */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_copy_link
argument_list|(
name|src_abspath
argument_list|,
name|dst_tmp_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_copy
condition|)
block|{
comment|/* Remove 'read-only' from the destination file; it's a local add now. */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_write
argument_list|(
name|dst_tmp_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_move
argument_list|(
name|work_item
argument_list|,
name|db
argument_list|,
name|dst_abspath
argument_list|,
name|dst_tmp_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy the versioned file SRC_ABSPATH in DB to the path DST_ABSPATH in DB.    If METADATA_ONLY is true, copy only the versioned metadata,    otherwise copy both the versioned metadata and the filesystem node (even    if it is the wrong kind, and recursively if it is a dir).     If IS_MOVE is true, record move information in working copy meta    data in addition to copying the file.     If the versioned file has a text conflict, and the .mine file exists in    the filesystem, copy the .mine file to DST_ABSPATH.  Otherwise, copy the    versioned file itself.     This also works for versioned symlinks that are stored in the db as    svn_node_file with svn:special set. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_versioned_file
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|src_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_op_root_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|tmpdir_abspath
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_boolean_t
name|conflicted
parameter_list|,
name|svn_boolean_t
name|is_move
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
comment|/* In case we are copying from one WC to another (e.g. an external dir),      ensure the destination WC has a copy of the pristine text. */
comment|/* Prepare a temp copy of the filesystem node.  It is usually a file, but      copy recursively if it's a dir. */
if|if
condition|(
operator|!
name|metadata_only
condition|)
block|{
specifier|const
name|char
modifier|*
name|my_src_abspath
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|handle_as_unversioned
init|=
name|FALSE
decl_stmt|;
comment|/* By default, take the copy source as given. */
name|my_src_abspath
operator|=
name|src_abspath
expr_stmt|;
if|if
condition|(
name|conflicted
condition|)
block|{
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_working
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Is there a text conflict at the source path? */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__conflict_read_text_conflict
argument_list|(
operator|&
name|conflict_working
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_MISSING
condition|)
block|{
comment|/* not text conflicted */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|conflict_working
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_working
condition|)
block|{
name|svn_node_kind_t
name|working_kind
decl_stmt|;
comment|/* Does the ".mine" file exist? */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|conflict_working
argument_list|,
operator|&
name|working_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|working_kind
operator|==
name|svn_node_file
condition|)
block|{
comment|/* Don't perform unmodified/pristine optimization */
name|handle_as_unversioned
operator|=
name|TRUE
expr_stmt|;
name|my_src_abspath
operator|=
name|conflict_working
expr_stmt|;
block|}
block|}
block|}
name|SVN_ERR
argument_list|(
name|copy_to_tmpdir
argument_list|(
operator|&
name|work_items
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|my_src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|TRUE
comment|/* file_copy */
argument_list|,
name|handle_as_unversioned
comment|/* unversioned */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the (single) node's metadata, and move the new filesystem node      into place. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_copy
argument_list|(
name|db
argument_list|,
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|dst_op_root_abspath
argument_list|,
name|is_move
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|dst_abspath
argument_list|,
name|svn_wc_notify_add
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
comment|/* When we notify that we performed a copy, make sure we already did */
if|if
condition|(
name|work_items
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|dst_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|notify_func
call|)
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy the versioned dir SRC_ABSPATH in DB to the path DST_ABSPATH in DB,    recursively.  If METADATA_ONLY is true, copy only the versioned metadata,    otherwise copy both the versioned metadata and the filesystem nodes (even    if they are the wrong kind, and including unversioned children).    If IS_MOVE is true, record move information in working copy meta    data in addition to copying the directory.     WITHIN_ONE_WC is TRUE if the copy/move is within a single working copy (root)  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_versioned_dir
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|src_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_op_root_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|tmpdir_abspath
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_boolean_t
name|is_move
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|versioned_children
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted_children
decl_stmt|;
name|apr_hash_t
modifier|*
name|disk_children
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Prepare a temp copy of the single filesystem node (usually a dir). */
if|if
condition|(
operator|!
name|metadata_only
condition|)
block|{
name|SVN_ERR
argument_list|(
name|copy_to_tmpdir
argument_list|(
operator|&
name|work_items
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|FALSE
comment|/* file_copy */
argument_list|,
name|FALSE
comment|/* unversioned */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the (single) node's metadata, and move the new filesystem node      into place. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_copy
argument_list|(
name|db
argument_list|,
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|dst_op_root_abspath
argument_list|,
name|is_move
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|dst_abspath
argument_list|,
name|svn_wc_notify_add
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
comment|/* When we notify that we performed a copy, make sure we already did */
if|if
condition|(
name|work_items
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|notify_func
call|)
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|metadata_only
operator|&&
name|disk_kind
operator|==
name|svn_node_dir
condition|)
comment|/* All filesystem children, versioned and unversioned.  We're only        interested in their names, so we can pass TRUE as the only_check_type        param. */
name|SVN_ERR
argument_list|(
name|svn_io_get_dirents3
argument_list|(
operator|&
name|disk_children
argument_list|,
name|src_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|disk_children
operator|=
name|NULL
expr_stmt|;
comment|/* Copy all the versioned children */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children_info
argument_list|(
operator|&
name|versioned_children
argument_list|,
operator|&
name|conflicted_children
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|versioned_children
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|child_name
decl_stmt|,
modifier|*
name|child_src_abspath
decl_stmt|,
modifier|*
name|child_dst_abspath
decl_stmt|;
name|struct
name|svn_wc__db_info_t
modifier|*
name|info
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|child_name
operator|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|info
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|child_src_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|src_abspath
argument_list|,
name|child_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|child_dst_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dst_abspath
argument_list|,
name|child_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|op_root
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_copy_shadowed_layer
argument_list|(
name|db
argument_list|,
name|child_src_abspath
argument_list|,
name|child_dst_abspath
argument_list|,
name|is_move
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_normal
operator|||
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_added
condition|)
block|{
comment|/* We have more work to do than just changing the DB */
if|if
condition|(
name|info
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
comment|/* We should skip this node if this child is a file external                  (issues #3589, #4000) */
if|if
condition|(
operator|!
name|info
operator|->
name|file_external
condition|)
name|SVN_ERR
argument_list|(
name|copy_versioned_file
argument_list|(
name|db
argument_list|,
name|child_src_abspath
argument_list|,
name|child_dst_abspath
argument_list|,
name|dst_op_root_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|metadata_only
argument_list|,
name|info
operator|->
name|conflicted
argument_list|,
name|is_move
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|copy_versioned_dir
argument_list|(
name|db
argument_list|,
name|child_src_abspath
argument_list|,
name|child_dst_abspath
argument_list|,
name|dst_op_root_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|metadata_only
argument_list|,
name|is_move
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"cannot handle node kind for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|child_src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_deleted
operator|||
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_excluded
condition|)
block|{
comment|/* This will be copied as some kind of deletion. Don't touch              any actual files */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_copy
argument_list|(
name|db
argument_list|,
name|child_src_abspath
argument_list|,
name|child_dst_abspath
argument_list|,
name|dst_op_root_abspath
argument_list|,
name|is_move
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't recurse on children while all we do is creating not-present              children */
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_incomplete
condition|)
block|{
comment|/* Should go ahead and copy incomplete to incomplete? Try to              copy as much as possible, or give up early? */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot handle status of '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|child_src_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_server_excluded
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot copy '%s' excluded by server"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|child_src_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|disk_children
operator|&&
operator|(
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_normal
operator|||
name|info
operator|->
name|status
operator|==
name|svn_wc__db_status_added
operator|)
condition|)
block|{
comment|/* Remove versioned child as it has been handled */
name|svn_hash_sets
argument_list|(
name|disk_children
argument_list|,
name|child_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy the remaining filesystem children, which are unversioned, skipping      any conflict-marker files. */
if|if
condition|(
name|disk_children
operator|&&
name|apr_hash_count
argument_list|(
name|disk_children
argument_list|)
condition|)
block|{
name|apr_hash_t
modifier|*
name|marker_files
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_conflict_marker_files
argument_list|(
operator|&
name|marker_files
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|disk_children
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|unver_src_abspath
decl_stmt|,
modifier|*
name|unver_dst_abspath
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
if|if
condition|(
name|svn_wc_is_adm_dir
argument_list|(
name|name
argument_list|,
name|iterpool
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|unver_src_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|src_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|unver_dst_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dst_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|marker_files
operator|&&
name|svn_hash_gets
argument_list|(
name|marker_files
argument_list|,
name|unver_src_abspath
argument_list|)
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|copy_to_tmpdir
argument_list|(
operator|&
name|work_item
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|unver_src_abspath
argument_list|,
name|unver_dst_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|TRUE
comment|/* recursive */
argument_list|,
name|TRUE
comment|/* unversioned */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_item
condition|)
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_add
argument_list|(
name|db
argument_list|,
name|dst_abspath
argument_list|,
name|work_items
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The guts of svn_wc_copy3() and svn_wc_move().  * The additional parameter IS_MOVE indicates whether this is a copy or  * a move operation.  *  * If MOVE_DEGRADED_TO_COPY is not NULL and a move had to be degraded  * to a copy, then set *MOVE_DEGRADED_TO_COPY. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_or_move
parameter_list|(
name|svn_boolean_t
modifier|*
name|move_degraded_to_copy
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|src_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_abspath
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_boolean_t
name|is_move
parameter_list|,
name|svn_boolean_t
name|allow_mixed_revisions
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
name|svn_node_kind_t
name|src_db_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|dstdir_abspath
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpdir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_wcroot_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_wcroot_abspath
decl_stmt|;
name|svn_boolean_t
name|within_one_wc
decl_stmt|;
name|svn_wc__db_status_t
name|src_status
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|src_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|dst_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|dstdir_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Ensure DSTDIR_ABSPATH belongs to the same repository as SRC_ABSPATH;      throw an error if not. */
block|{
name|svn_wc__db_status_t
name|dstdir_status
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_repos_root_url
decl_stmt|,
modifier|*
name|dst_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_repos_uuid
decl_stmt|,
modifier|*
name|dst_repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_repos_relpath
decl_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|src_status
argument_list|,
operator|&
name|src_db_kind
argument_list|,
name|NULL
argument_list|,
operator|&
name|src_repos_relpath
argument_list|,
operator|&
name|src_repos_root_url
argument_list|,
operator|&
name|src_repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
comment|/* Replicate old error code and text */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Do this now, as we know the right data is cached */
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|src_wcroot_abspath
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_status
condition|)
block|{
case|case
name|svn_wc__db_status_deleted
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Deleted node '%s' can't be copied."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
case|case
name|svn_wc__db_status_excluded
case|:
case|case
name|svn_wc__db_status_server_excluded
case|:
case|case
name|svn_wc__db_status_not_present
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' was not found."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|is_move
operator|&&
operator|!
name|strcmp
argument_list|(
name|src_abspath
argument_list|,
name|src_wcroot_abspath
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is the root of a working copy and "
literal|"cannot be moved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|is_move
operator|&&
name|src_repos_relpath
operator|&&
operator|!
name|src_repos_relpath
index|[
literal|0
index|]
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' represents the repository root "
literal|"and cannot be moved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|dstdir_status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst_repos_root_url
argument_list|,
operator|&
name|dst_repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|dstdir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
comment|/* An unversioned destination directory exists on disk. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dstdir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Do this now, as we know the right data is cached */
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|dst_wcroot_abspath
argument_list|,
name|db
argument_list|,
name|dstdir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|src_repos_root_url
condition|)
block|{
if|if
condition|(
name|src_status
operator|==
name|svn_wc__db_status_added
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|src_repos_root_url
argument_list|,
operator|&
name|src_repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* If not added, the node must have a base or we can't copy */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
name|NULL
argument_list|,
operator|&
name|src_repos_root_url
argument_list|,
operator|&
name|src_repos_uuid
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dst_repos_root_url
condition|)
block|{
if|if
condition|(
name|dstdir_status
operator|==
name|svn_wc__db_status_added
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst_repos_root_url
argument_list|,
operator|&
name|dst_repos_uuid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|dstdir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* If not added, the node must have a base or we can't copy */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_base_repos
argument_list|(
name|NULL
argument_list|,
operator|&
name|dst_repos_root_url
argument_list|,
operator|&
name|dst_repos_uuid
argument_list|,
name|db
argument_list|,
name|dstdir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|src_repos_root_url
argument_list|,
name|dst_repos_root_url
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|src_repos_uuid
argument_list|,
name|dst_repos_uuid
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_INVALID_SCHEDULE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot copy to '%s', as it is not from repository '%s'; "
literal|"it is from '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|src_repos_root_url
argument_list|,
name|dst_repos_root_url
argument_list|)
return|;
if|if
condition|(
name|dstdir_status
operator|==
name|svn_wc__db_status_deleted
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_INVALID_SCHEDULE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot copy to '%s' as it is scheduled for deletion"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* ### should report dstdir_abspath instead of dst_abspath? */
block|}
comment|/* TODO(#2843): Rework the error report. */
comment|/* Check if the copy target is missing or hidden and thus not exist on the      disk, before actually doing the file copy. */
block|{
name|svn_wc__db_status_t
name|dst_status
decl_stmt|;
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|dst_status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
switch|switch
condition|(
name|dst_status
condition|)
block|{
case|case
name|svn_wc__db_status_excluded
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is already under version control "
literal|"but is excluded."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
case|case
name|svn_wc__db_status_server_excluded
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is already under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
case|case
name|svn_wc__db_status_deleted
case|:
case|case
name|svn_wc__db_status_not_present
case|:
break|break;
comment|/* OK to add */
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"There is already a versioned item '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Check that the target path is not obstructed, if required. */
if|if
condition|(
operator|!
name|metadata_only
condition|)
block|{
name|svn_node_kind_t
name|dst_kind
decl_stmt|;
comment|/* (We need only to check the root of the copy, not every path inside          copy_versioned_file/_dir.) */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_abspath
argument_list|,
operator|&
name|dst_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_kind
operator|!=
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' already exists and is in the way"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|tmpdir_abspath
argument_list|,
name|db
argument_list|,
name|dstdir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|within_one_wc
operator|=
operator|(
name|strcmp
argument_list|(
name|src_wcroot_abspath
argument_list|,
name|dst_wcroot_abspath
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|is_move
operator|&&
operator|!
name|within_one_wc
condition|)
block|{
if|if
condition|(
name|move_degraded_to_copy
condition|)
operator|*
name|move_degraded_to_copy
operator|=
name|TRUE
expr_stmt|;
name|is_move
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|within_one_wc
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_transfer
argument_list|(
name|db
argument_list|,
name|src_abspath
argument_list|,
name|dst_wcroot_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_db_kind
operator|==
name|svn_node_file
operator|||
name|src_db_kind
operator|==
name|svn_node_symlink
condition|)
block|{
name|err
operator|=
name|copy_versioned_file
argument_list|(
name|db
argument_list|,
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|metadata_only
argument_list|,
name|conflicted
argument_list|,
name|is_move
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_move
operator|&&
name|src_status
operator|==
name|svn_wc__db_status_normal
condition|)
block|{
name|svn_revnum_t
name|min_rev
decl_stmt|;
name|svn_revnum_t
name|max_rev
decl_stmt|;
comment|/* Verify that the move source is a single-revision subtree. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_min_max_revisions
argument_list|(
operator|&
name|min_rev
argument_list|,
operator|&
name|max_rev
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|min_rev
argument_list|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|max_rev
argument_list|)
operator|&&
name|min_rev
operator|!=
name|max_rev
condition|)
block|{
if|if
condition|(
operator|!
name|allow_mixed_revisions
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_MIXED_REVISIONS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot move mixed-revision "
literal|"subtree '%s' [%ld:%ld]; "
literal|"try updating it first"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|min_rev
argument_list|,
name|max_rev
argument_list|)
return|;
name|is_move
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|move_degraded_to_copy
condition|)
operator|*
name|move_degraded_to_copy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|err
operator|=
name|copy_versioned_dir
argument_list|(
name|db
argument_list|,
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|tmpdir_abspath
argument_list|,
name|metadata_only
argument_list|,
name|is_move
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|&&
name|svn_error_find_cause
argument_list|(
name|err
argument_list|,
name|SVN_ERR_CANCELLED
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
name|is_move
condition|)
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_wc__db_op_handle_move_back
argument_list|(
name|NULL
argument_list|,
name|db
argument_list|,
name|dst_abspath
argument_list|,
name|src_abspath
argument_list|,
name|NULL
comment|/* work_items */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run the work queue with the remaining work */
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|dst_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Public Interface */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc_copy3
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|src_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_abspath
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Verify that we have the required write lock. */
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|copy_or_move
argument_list|(
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|metadata_only
argument_list|,
name|FALSE
comment|/* is_move */
argument_list|,
name|TRUE
comment|/* allow_mixed_revisions */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove the conflict markers of NODE_ABSPATH, that were left over after    copying NODE_ABSPATH from SRC_ABSPATH.     Only use this function when you know what you're doing. This function    explicitly ignores some case insensitivity issues!     */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_node_conflict_markers
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|src_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|node_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do we have conflict markers that should be removed? */
if|if
condition|(
name|conflict
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|markers
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_dir
init|=
name|svn_dirent_dirname
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_dir
init|=
name|svn_dirent_dirname
argument_list|(
name|node_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_markers
argument_list|(
operator|&
name|markers
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No iterpool: Maximum number of possible conflict markers is 4 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|markers
operator|&&
operator|(
name|i
operator|<
name|markers
operator|->
name|nelts
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|marker_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_abpath
decl_stmt|;
name|marker_abspath
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|markers
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|child_relpath
operator|=
name|svn_dirent_is_child
argument_list|(
name|src_dir
argument_list|,
name|marker_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_relpath
condition|)
block|{
name|child_abpath
operator|=
name|svn_dirent_join
argument_list|(
name|dst_dir
argument_list|,
name|child_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|child_abpath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove all the conflict markers below SRC_DIR_ABSPATH, that were left over    after copying WC_DIR_ABSPATH from SRC_DIR_ABSPATH.     This function doesn't remove the conflict markers on WC_DIR_ABSPATH    itself!     Only use this function when you know what you're doing. This function    explicitly ignores some case insensitivity issues!    */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_all_conflict_markers
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|src_dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|wc_dir_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|nodes
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicts
decl_stmt|;
comment|/* Unused */
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Reuse a status helper to obtain all subdirs and conflicts in a single      db transaction. */
comment|/* ### This uses a rifle to kill a fly. But at least it doesn't use heavy           artillery. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children_info
argument_list|(
operator|&
name|nodes
argument_list|,
operator|&
name|conflicts
argument_list|,
name|db
argument_list|,
name|src_dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|nodes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|struct
name|svn_wc__db_info_t
modifier|*
name|info
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|conflicted
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remove_node_conflict_markers
argument_list|(
name|db
argument_list|,
name|svn_dirent_join
argument_list|(
name|src_dir_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|svn_dirent_join
argument_list|(
name|wc_dir_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remove_all_conflict_markers
argument_list|(
name|db
argument_list|,
name|svn_dirent_join
argument_list|(
name|src_dir_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|svn_dirent_join
argument_list|(
name|wc_dir_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__move2
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|src_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_abspath
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_boolean_t
name|allow_mixed_revisions
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
name|svn_boolean_t
name|move_degraded_to_copy
init|=
name|FALSE
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
comment|/* Verify that we have the required write locks. */
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_or_move
argument_list|(
operator|&
name|move_degraded_to_copy
argument_list|,
name|wc_ctx
argument_list|,
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|TRUE
comment|/* metadata_only */
argument_list|,
name|TRUE
comment|/* is_move */
argument_list|,
name|allow_mixed_revisions
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* An interrupt at this point will leave the new copy marked as      moved-here but the source has not yet been deleted or marked as      moved-to. */
comment|/* Should we be using a workqueue for this move?  It's not clear.      What should happen if the copy above is interrupted?  The user      may want to abort the move and a workqueue might interfere with      that.       BH: On Windows it is not unlikely to encounter an access denied on      this line. Installing the move in the workqueue via the copy_or_move      might make it hard to recover from that situation, while the DB      is still in a valid state. So be careful when switching this over      to the workqueue. */
if|if
condition|(
operator|!
name|metadata_only
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|remove_all_conflict_markers
argument_list|(
name|db
argument_list|,
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicted
condition|)
name|SVN_ERR
argument_list|(
name|remove_node_conflict_markers
argument_list|(
name|db
argument_list|,
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_delete
argument_list|(
name|db
argument_list|,
name|src_abspath
argument_list|,
name|move_degraded_to_copy
condition|?
name|NULL
else|:
name|dst_abspath
argument_list|,
name|TRUE
comment|/* delete_dir_externals */
argument_list|,
name|NULL
comment|/* conflict */
argument_list|,
name|NULL
comment|/* work_items */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

