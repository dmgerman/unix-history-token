begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * old-and-busted.c:  routines for reading pre-1.7 working copies.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"entries.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Within the (old) entries file, boolean values have a specific string    value (thus, TRUE), or they are missing (for FALSE). Below are the    values for each of the booleans stored.  */
end_comment

begin_define
define|#
directive|define
name|ENTRIES_BOOL_COPIED
value|"copied"
end_define

begin_define
define|#
directive|define
name|ENTRIES_BOOL_DELETED
value|"deleted"
end_define

begin_define
define|#
directive|define
name|ENTRIES_BOOL_ABSENT
value|"absent"
end_define

begin_define
define|#
directive|define
name|ENTRIES_BOOL_INCOMPLETE
value|"incomplete"
end_define

begin_define
define|#
directive|define
name|ENTRIES_BOOL_KEEP_LOCAL
value|"keep-local"
end_define

begin_comment
comment|/* Tag names used in our old XML entries file.  */
end_comment

begin_define
define|#
directive|define
name|ENTRIES_TAG_ENTRY
value|"entry"
end_define

begin_comment
comment|/* Attribute names used in our old XML entries file.  */
end_comment

begin_define
define|#
directive|define
name|ENTRIES_ATTR_NAME
value|"name"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_REPOS
value|"repos"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_UUID
value|"uuid"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_INCOMPLETE
value|"incomplete"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_LOCK_TOKEN
value|"lock-token"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_LOCK_OWNER
value|"lock-owner"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_LOCK_COMMENT
value|"lock-comment"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_LOCK_CREATION_DATE
value|"lock-creation-date"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_DELETED
value|"deleted"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_ABSENT
value|"absent"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_CMT_REV
value|"committed-rev"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_CMT_DATE
value|"committed-date"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_CMT_AUTHOR
value|"last-author"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_REVISION
value|"revision"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_URL
value|"url"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_KIND
value|"kind"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_SCHEDULE
value|"schedule"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_COPIED
value|"copied"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_COPYFROM_URL
value|"copyfrom-url"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_COPYFROM_REV
value|"copyfrom-rev"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_CHECKSUM
value|"checksum"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_WORKING_SIZE
value|"working-size"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_TEXT_TIME
value|"text-time"
end_define

begin_define
define|#
directive|define
name|ENTRIES_ATTR_CONFLICT_OLD
value|"conflict-old"
end_define

begin_comment
comment|/* saved old file */
end_comment

begin_define
define|#
directive|define
name|ENTRIES_ATTR_CONFLICT_NEW
value|"conflict-new"
end_define

begin_comment
comment|/* saved new file */
end_comment

begin_define
define|#
directive|define
name|ENTRIES_ATTR_CONFLICT_WRK
value|"conflict-wrk"
end_define

begin_comment
comment|/* saved wrk file */
end_comment

begin_define
define|#
directive|define
name|ENTRIES_ATTR_PREJFILE
value|"prop-reject-file"
end_define

begin_comment
comment|/* Attribute values used in our old XML entries file.  */
end_comment

begin_define
define|#
directive|define
name|ENTRIES_VALUE_FILE
value|"file"
end_define

begin_define
define|#
directive|define
name|ENTRIES_VALUE_DIR
value|"dir"
end_define

begin_define
define|#
directive|define
name|ENTRIES_VALUE_ADD
value|"add"
end_define

begin_define
define|#
directive|define
name|ENTRIES_VALUE_DELETE
value|"delete"
end_define

begin_define
define|#
directive|define
name|ENTRIES_VALUE_REPLACE
value|"replace"
end_define

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_wc_entry_t
modifier|*
name|alloc_entry
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_entry_t
modifier|*
name|entry
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
decl_stmt|;
name|entry
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|cmt_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|entry
operator|->
name|working_size
operator|=
name|SVN_WC_ENTRY_WORKING_SIZE_UNKNOWN
expr_stmt|;
name|entry
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|entry
operator|->
name|file_external_path
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|file_external_peg_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|entry
operator|->
name|file_external_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Read an escaped byte on the form 'xHH' from [*BUF, END), placing    the byte in *RESULT.  Advance *BUF to point after the escape    sequence. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_escaped
parameter_list|(
name|char
modifier|*
name|result
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|apr_uint64_t
name|val
decl_stmt|;
name|char
name|digits
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|end
operator|-
operator|*
name|buf
operator|<
literal|3
operator|||
operator|*
operator|*
name|buf
operator|!=
literal|'x'
operator|||
operator|!
name|svn_ctype_isxdigit
argument_list|(
operator|(
operator|*
name|buf
operator|)
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|svn_ctype_isxdigit
argument_list|(
operator|(
operator|*
name|buf
operator|)
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid escape sequence"
argument_list|)
argument_list|)
return|;
operator|(
operator|*
name|buf
operator|)
operator|++
expr_stmt|;
name|digits
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|(
operator|*
name|buf
operator|)
operator|++
operator|)
expr_stmt|;
name|digits
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|(
operator|*
name|buf
operator|)
operator|++
operator|)
expr_stmt|;
name|digits
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|apr_strtoi64
argument_list|(
name|digits
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid escaped character"
argument_list|)
argument_list|)
return|;
operator|*
name|result
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a field, possibly with escaped bytes, from [*BUF, END),    stopping at the terminator.  Place the read string in *RESULT, or set    *RESULT to NULL if it is the empty string.  Allocate the returned string    in POOL.  Advance *BUF to point after the terminator. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_str
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
name|end
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of entry"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|*
operator|*
name|buf
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
operator|++
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|start
operator|=
operator|*
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|buf
operator|!=
name|end
operator|&&
operator|*
operator|*
name|buf
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|buf
operator|==
literal|'\\'
condition|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|start
argument_list|,
operator|*
name|buf
operator|-
name|start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_appendbytes
argument_list|(
name|s
argument_list|,
name|start
argument_list|,
operator|*
name|buf
operator|-
name|start
argument_list|)
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_escaped
argument_list|(
operator|&
name|c
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|start
operator|=
operator|*
name|buf
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|buf
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|buf
operator|==
name|end
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of entry"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|s
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|s
argument_list|,
name|start
argument_list|,
operator|*
name|buf
operator|-
name|start
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|s
operator|->
name|data
expr_stmt|;
block|}
else|else
operator|*
name|result
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|start
argument_list|,
operator|*
name|buf
operator|-
name|start
argument_list|)
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
operator|++
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is wrapper around read_str() (which see for details); it    simply asks svn_path_is_canonical() of the string it reads,    returning an error if the test fails.    ### It seems this is only called for entrynames now    */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
name|result
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|&&
operator|*
operator|*
name|result
operator|&&
operator|!
name|svn_relpath_is_canonical
argument_list|(
operator|*
name|result
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry contains non-canonical path '%s'"
argument_list|)
argument_list|,
operator|*
name|result
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is read_path() for urls. This function does not do the is_canonical    test for entries from working copies older than version 10, as since that    version the canonicalization of urls has been changed. See issue #2475.    If the test is done and fails, read_url returs an error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|int
name|wc_format
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
name|result
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Always canonicalize the url, as we have stricter canonicalization rules      in 1.7+ then before */
if|if
condition|(
operator|*
name|result
operator|&&
operator|*
operator|*
name|result
condition|)
operator|*
name|result
operator|=
name|svn_uri_canonicalize
argument_list|(
operator|*
name|result
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a field from [*BUF, END), terminated by a newline character.    The field may not contain escape sequences.  The field is not    copied and the buffer is modified in place, by replacing the    terminator with a NUL byte.  Make *BUF point after the original    terminator. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_val
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
operator|*
name|buf
decl_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
name|end
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of entry"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|*
operator|*
name|buf
operator|==
literal|'\n'
condition|)
block|{
operator|(
operator|*
name|buf
operator|)
operator|++
expr_stmt|;
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
while|while
condition|(
operator|*
name|buf
operator|!=
name|end
operator|&&
operator|*
operator|*
name|buf
operator|!=
literal|'\n'
condition|)
operator|(
operator|*
name|buf
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
name|end
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of entry"
argument_list|)
argument_list|)
return|;
operator|*
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|result
operator|=
name|start
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
operator|++
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a boolean field from [*BUF, END), placing the result in    *RESULT.  If there is no boolean value (just a terminator), it    defaults to false.  Else, the value must match FIELD_NAME, in which    case *RESULT will be set to true.  Advance *BUF to point after the    terminator. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_bool
parameter_list|(
name|svn_boolean_t
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|field_name
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
name|field_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid value for field '%s'"
argument_list|)
argument_list|,
name|field_name
argument_list|)
return|;
operator|*
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
operator|*
name|result
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a revision number from [*BUF, END) stopping at the    terminator.  Set *RESULT to the revision number, or    SVN_INVALID_REVNUM if there is none.  Use POOL for temporary    allocations.  Make *BUF point after the terminator.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|result
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
operator|*
name|result
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a timestamp from [*BUF, END) stopping at the terminator.    Set *RESULT to the resulting timestamp, or 0 if there is none.  Use    POOL for temporary allocations.  Make *BUF point after the    terminator. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_time
parameter_list|(
name|apr_time_t
modifier|*
name|result
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
name|result
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|result
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/**  * Parse the string at *STR as an revision and save the result in  * *OPT_REV.  After returning successfully, *STR points at next  * character in *STR where further parsing can be done.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|string_to_opt_revision
parameter_list|(
name|svn_opt_revision_t
modifier|*
name|opt_rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
operator|*
name|str
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|opt_rev
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|':'
condition|)
operator|++
name|s
expr_stmt|;
comment|/* Should not find a \0. */
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Found an unexpected \\0 in the file external '%s'"
argument_list|)
argument_list|,
operator|*
name|str
argument_list|)
return|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
operator|*
name|str
argument_list|,
literal|"HEAD:"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|opt_rev
operator|->
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
block|}
else|else
block|{
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|endptr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_revnum_parse
argument_list|(
operator|&
name|rev
argument_list|,
operator|*
name|str
argument_list|,
operator|&
name|endptr
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|endptr
operator|==
name|s
argument_list|)
expr_stmt|;
name|opt_rev
operator|->
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|opt_rev
operator|->
name|value
operator|.
name|number
operator|=
name|rev
expr_stmt|;
block|}
operator|*
name|str
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/**  * Given a revision, return a string for the revision, either "HEAD"  * or a string representation of the revision value.  All other  * revision kinds return an error.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|opt_revision_to_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
switch|switch
condition|(
name|rev
operator|->
name|kind
condition|)
block|{
case|case
name|svn_opt_revision_head
case|:
operator|*
name|str
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
literal|"HEAD"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_opt_revision_number
case|:
operator|*
name|str
operator|=
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|rev
operator|->
name|value
operator|.
name|number
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Illegal file external revision kind %d for path '%s'"
argument_list|)
argument_list|,
name|rev
operator|->
name|kind
argument_list|,
name|path
argument_list|)
return|;
break|break;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__unserialize_file_external
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path_result
parameter_list|,
name|svn_opt_revision_t
modifier|*
name|peg_rev_result
parameter_list|,
name|svn_opt_revision_t
modifier|*
name|rev_result
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|str
condition|)
block|{
name|svn_opt_revision_t
name|peg_rev
decl_stmt|;
name|svn_opt_revision_t
name|op_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|string_to_opt_revision
argument_list|(
operator|&
name|peg_rev
argument_list|,
operator|&
name|s
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|string_to_opt_revision
argument_list|(
operator|&
name|op_rev
argument_list|,
operator|&
name|s
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|path_result
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|peg_rev_result
operator|=
name|peg_rev
expr_stmt|;
operator|*
name|rev_result
operator|=
name|op_rev
expr_stmt|;
block|}
else|else
block|{
operator|*
name|path_result
operator|=
name|NULL
expr_stmt|;
name|peg_rev_result
operator|->
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|rev_result
operator|->
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__serialize_file_external
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_rev
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|path
condition|)
block|{
specifier|const
name|char
modifier|*
name|s1
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
decl_stmt|;
name|SVN_ERR
argument_list|(
name|opt_revision_to_string
argument_list|(
operator|&
name|s1
argument_list|,
name|path
argument_list|,
name|peg_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|opt_revision_to_string
argument_list|(
operator|&
name|s2
argument_list|,
name|path
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|s1
argument_list|,
literal|":"
argument_list|,
name|s2
argument_list|,
literal|":"
argument_list|,
name|path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|=
name|NULL
expr_stmt|;
operator|*
name|str
operator|=
name|s
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate an entry from POOL and read it from [*BUF, END).  The    buffer may be modified in place while parsing.  Return the new    entry in *NEW_ENTRY.  Advance *BUF to point at the end of the entry    record.    The entries file format should be provided in ENTRIES_FORMAT. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_entry
parameter_list|(
name|svn_wc_entry_t
modifier|*
modifier|*
name|new_entry
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|int
name|entries_format
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_entry_t
modifier|*
name|entry
init|=
name|alloc_entry
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
define|#
directive|define
name|MAYBE_DONE
value|if (**buf == '\f') goto done
comment|/* Find the name and set up the entry under that name. */
name|SVN_ERR
argument_list|(
name|read_path
argument_list|(
operator|&
name|name
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|name
operator|=
name|name
condition|?
name|name
else|:
name|SVN_WC_ENTRY_THIS_DIR
expr_stmt|;
comment|/* Set up kind. */
block|{
specifier|const
name|char
modifier|*
name|kindstr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|kindstr
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kindstr
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|kindstr
argument_list|,
name|ENTRIES_VALUE_FILE
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|kindstr
argument_list|,
name|ENTRIES_VALUE_DIR
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNKNOWN_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry '%s' has invalid node kind"
argument_list|)
argument_list|,
operator|(
name|name
condition|?
name|name
else|:
name|SVN_WC_ENTRY_THIS_DIR
operator|)
argument_list|)
return|;
block|}
else|else
name|entry
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
block|}
name|MAYBE_DONE
expr_stmt|;
comment|/* Attempt to set revision (resolve_to_defaults may do it later, too) */
name|SVN_ERR
argument_list|(
name|read_revnum
argument_list|(
operator|&
name|entry
operator|->
name|revision
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Attempt to set up url path (again, see resolve_to_defaults). */
name|SVN_ERR
argument_list|(
name|read_url
argument_list|(
operator|&
name|entry
operator|->
name|url
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|entries_format
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Set up repository root.  Make sure it is a prefix of url. */
name|SVN_ERR
argument_list|(
name|read_url
argument_list|(
operator|&
name|entry
operator|->
name|repos
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|entries_format
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|repos
operator|&&
name|entry
operator|->
name|url
operator|&&
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|entry
operator|->
name|repos
argument_list|,
name|entry
operator|->
name|url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry for '%s' has invalid repository "
literal|"root"
argument_list|)
argument_list|,
name|name
condition|?
name|name
else|:
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
return|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Look for a schedule attribute on this entry. */
block|{
specifier|const
name|char
modifier|*
name|schedulestr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|schedulestr
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
if|if
condition|(
name|schedulestr
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|schedulestr
argument_list|,
name|ENTRIES_VALUE_ADD
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_add
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|schedulestr
argument_list|,
name|ENTRIES_VALUE_DELETE
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_delete
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|schedulestr
argument_list|,
name|ENTRIES_VALUE_REPLACE
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_replace
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_ATTRIBUTE_INVALID
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry '%s' has invalid 'schedule' value"
argument_list|)
argument_list|,
name|name
condition|?
name|name
else|:
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
return|;
block|}
block|}
name|MAYBE_DONE
expr_stmt|;
comment|/* Attempt to set up text timestamp. */
name|SVN_ERR
argument_list|(
name|read_time
argument_list|(
operator|&
name|entry
operator|->
name|text_time
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Checksum. */
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
operator|&
name|entry
operator|->
name|checksum
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Setup last-committed values. */
name|SVN_ERR
argument_list|(
name|read_time
argument_list|(
operator|&
name|entry
operator|->
name|cmt_date
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_revnum
argument_list|(
operator|&
name|entry
operator|->
name|cmt_rev
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
operator|&
name|entry
operator|->
name|cmt_author
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* has-props, has-prop-mods, cachable-props, present-props are all      deprecated. Read any values that may be in the 'entries' file, but      discard them, and just put default values into the entry. */
block|{
specifier|const
name|char
modifier|*
name|unused_value
decl_stmt|;
comment|/* has-props flag. */
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|unused_value
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|has_props
operator|=
name|FALSE
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* has-prop-mods flag. */
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|unused_value
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|has_prop_mods
operator|=
name|FALSE
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Use the empty string for cachable_props, indicating that we no        longer attempt to cache any properties. An empty string for        present_props means that no cachable props are present. */
comment|/* cachable-props string. */
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|unused_value
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cachable_props
operator|=
literal|""
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* present-props string. */
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|unused_value
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|present_props
operator|=
literal|""
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
block|}
comment|/* Is this entry in a state of mental torment (conflict)? */
block|{
name|SVN_ERR
argument_list|(
name|read_path
argument_list|(
operator|&
name|entry
operator|->
name|prejfile
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_path
argument_list|(
operator|&
name|entry
operator|->
name|conflict_old
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_path
argument_list|(
operator|&
name|entry
operator|->
name|conflict_new
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_path
argument_list|(
operator|&
name|entry
operator|->
name|conflict_wrk
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
block|}
comment|/* Is this entry copied? */
name|SVN_ERR
argument_list|(
name|read_bool
argument_list|(
operator|&
name|entry
operator|->
name|copied
argument_list|,
name|ENTRIES_BOOL_COPIED
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_url
argument_list|(
operator|&
name|entry
operator|->
name|copyfrom_url
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|entries_format
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_revnum
argument_list|(
operator|&
name|entry
operator|->
name|copyfrom_rev
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Is this entry deleted? */
name|SVN_ERR
argument_list|(
name|read_bool
argument_list|(
operator|&
name|entry
operator|->
name|deleted
argument_list|,
name|ENTRIES_BOOL_DELETED
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Is this entry absent? */
name|SVN_ERR
argument_list|(
name|read_bool
argument_list|(
operator|&
name|entry
operator|->
name|absent
argument_list|,
name|ENTRIES_BOOL_ABSENT
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Is this entry incomplete? */
name|SVN_ERR
argument_list|(
name|read_bool
argument_list|(
operator|&
name|entry
operator|->
name|incomplete
argument_list|,
name|ENTRIES_BOOL_INCOMPLETE
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* UUID. */
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
operator|&
name|entry
operator|->
name|uuid
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Lock token. */
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
operator|&
name|entry
operator|->
name|lock_token
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Lock owner. */
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
operator|&
name|entry
operator|->
name|lock_owner
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Lock comment. */
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
operator|&
name|entry
operator|->
name|lock_comment
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Lock creation date. */
name|SVN_ERR
argument_list|(
name|read_time
argument_list|(
operator|&
name|entry
operator|->
name|lock_creation_date
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Changelist. */
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
operator|&
name|entry
operator|->
name|changelist
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Keep entry in working copy after deletion? */
name|SVN_ERR
argument_list|(
name|read_bool
argument_list|(
operator|&
name|entry
operator|->
name|keep_local
argument_list|,
name|ENTRIES_BOOL_KEEP_LOCAL
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* Translated size */
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
comment|/* read_val() returns NULL on an empty (e.g. default) entry line,        and entry has already been initialized accordingly already */
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|entry
operator|->
name|working_size
operator|=
operator|(
name|apr_off_t
operator|)
name|apr_strtoi64
argument_list|(
name|val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|MAYBE_DONE
expr_stmt|;
comment|/* Depth. */
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|result
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|svn_boolean_t
name|invalid
decl_stmt|;
name|svn_boolean_t
name|is_this_dir
decl_stmt|;
name|entry
operator|->
name|depth
operator|=
name|svn_depth_from_word
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Verify the depth value:            THIS_DIR should not have an excluded value and SUB_DIR should only            have excluded value. Remember that infinity value is not stored and            should not show up here. Otherwise, something bad may have            happened. However, infinity value itself will always be okay. */
name|is_this_dir
operator|=
operator|!
name|name
expr_stmt|;
comment|/* '!=': XOR */
name|invalid
operator|=
name|is_this_dir
operator|!=
operator|(
name|entry
operator|->
name|depth
operator|!=
name|svn_depth_exclude
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|depth
operator|!=
name|svn_depth_infinity
operator|&&
name|invalid
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_ATTRIBUTE_INVALID
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry '%s' has invalid 'depth' value"
argument_list|)
argument_list|,
name|name
condition|?
name|name
else|:
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
return|;
block|}
else|else
name|entry
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
block|}
name|MAYBE_DONE
expr_stmt|;
comment|/* Tree conflict data. */
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
operator|&
name|entry
operator|->
name|tree_conflict_data
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_DONE
expr_stmt|;
comment|/* File external URL and revision. */
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_str
argument_list|(
operator|&
name|str
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__unserialize_file_external
argument_list|(
operator|&
name|entry
operator|->
name|file_external_path
argument_list|,
operator|&
name|entry
operator|->
name|file_external_peg_rev
argument_list|,
operator|&
name|entry
operator|->
name|file_external_rev
argument_list|,
name|str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MAYBE_DONE
expr_stmt|;
name|done
label|:
operator|*
name|new_entry
operator|=
name|entry
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If attribute ATTR_NAME appears in hash ATTS, set *ENTRY_FLAG to its    boolean value, else set *ENTRY_FLAG false.  ENTRY_NAME is the name    of the WC-entry. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_bool_attr
parameter_list|(
name|svn_boolean_t
modifier|*
name|entry_flag
parameter_list|,
name|apr_hash_t
modifier|*
name|atts
parameter_list|,
specifier|const
name|char
modifier|*
name|attr_name
parameter_list|,
specifier|const
name|char
modifier|*
name|entry_name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|attr_name
argument_list|)
decl_stmt|;
operator|*
name|entry_flag
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|entry_flag
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"false"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|entry_flag
operator|=
name|FALSE
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_ATTRIBUTE_INVALID
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry '%s' has invalid '%s' value"
argument_list|)
argument_list|,
operator|(
name|entry_name
condition|?
name|entry_name
else|:
name|SVN_WC_ENTRY_THIS_DIR
operator|)
argument_list|,
name|attr_name
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|extract_string
parameter_list|(
name|apr_hash_t
modifier|*
name|atts
parameter_list|,
specifier|const
name|char
modifier|*
name|att_name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|att_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like extract_string(), but normalizes empty strings to NULL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|extract_string_normalize
parameter_list|(
name|apr_hash_t
modifier|*
name|atts
parameter_list|,
specifier|const
name|char
modifier|*
name|att_name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|att_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* NOTE: this is used for upgrading old XML-based entries file. Be wary of          removing items.     ### many attributes are no longer used within the old-style log files.    ### These attrs need to be recognized for old entries, however. For these    ### cases, the code will parse the attribute, but not set *MODIFY_FLAGS    ### for that particular field. MODIFY_FLAGS is *only* used by the    ### log-based entry modification system, and will go way once we    ### completely move away from loggy.     Set *NEW_ENTRY to a new entry, taking attributes from ATTS, whose    keys and values are both char *.  Allocate the entry and copy    attributes into POOL as needed. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|atts_to_entry
parameter_list|(
name|svn_wc_entry_t
modifier|*
modifier|*
name|new_entry
parameter_list|,
name|apr_hash_t
modifier|*
name|atts
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_entry_t
modifier|*
name|entry
init|=
name|alloc_entry
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Find the name and set up the entry under that name. */
name|name
operator|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_NAME
argument_list|)
expr_stmt|;
name|entry
operator|->
name|name
operator|=
name|name
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|)
else|:
name|SVN_WC_ENTRY_THIS_DIR
expr_stmt|;
comment|/* Attempt to set revision (resolve_to_defaults may do it later, too)       ### not used by loggy; no need to set MODIFY_FLAGS  */
block|{
specifier|const
name|char
modifier|*
name|revision_str
init|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_REVISION
argument_list|)
decl_stmt|;
if|if
condition|(
name|revision_str
condition|)
name|entry
operator|->
name|revision
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|revision_str
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* Attempt to set up url path (again, see resolve_to_defaults).       ### not used by loggy; no need to set MODIFY_FLAGS  */
name|entry
operator|->
name|url
operator|=
name|extract_string
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_URL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Set up repository root.  Make sure it is a prefix of url.       ### not used by loggy; no need to set MODIFY_FLAGS  */
name|entry
operator|->
name|repos
operator|=
name|extract_string
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_REPOS
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|url
operator|&&
name|entry
operator|->
name|repos
operator|&&
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|entry
operator|->
name|repos
argument_list|,
name|entry
operator|->
name|url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry for '%s' has invalid repository "
literal|"root"
argument_list|)
argument_list|,
name|name
condition|?
name|name
else|:
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
return|;
comment|/* Set up kind. */
comment|/* ### not used by loggy; no need to set MODIFY_FLAGS  */
block|{
specifier|const
name|char
modifier|*
name|kindstr
init|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_KIND
argument_list|)
decl_stmt|;
name|entry
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
if|if
condition|(
name|kindstr
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|kindstr
argument_list|,
name|ENTRIES_VALUE_FILE
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|kindstr
argument_list|,
name|ENTRIES_VALUE_DIR
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNKNOWN_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry '%s' has invalid node kind"
argument_list|)
argument_list|,
operator|(
name|name
condition|?
name|name
else|:
name|SVN_WC_ENTRY_THIS_DIR
operator|)
argument_list|)
return|;
block|}
block|}
comment|/* Look for a schedule attribute on this entry. */
comment|/* ### not used by loggy; no need to set MODIFY_FLAGS  */
block|{
specifier|const
name|char
modifier|*
name|schedulestr
init|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_SCHEDULE
argument_list|)
decl_stmt|;
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
if|if
condition|(
name|schedulestr
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|schedulestr
argument_list|,
name|ENTRIES_VALUE_ADD
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_add
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|schedulestr
argument_list|,
name|ENTRIES_VALUE_DELETE
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_delete
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|schedulestr
argument_list|,
name|ENTRIES_VALUE_REPLACE
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_replace
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|schedulestr
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_ATTRIBUTE_INVALID
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry '%s' has invalid 'schedule' value"
argument_list|)
argument_list|,
operator|(
name|name
condition|?
name|name
else|:
name|SVN_WC_ENTRY_THIS_DIR
operator|)
argument_list|)
return|;
block|}
block|}
comment|/* Is this entry in a state of mental torment (conflict)? */
name|entry
operator|->
name|prejfile
operator|=
name|extract_string_normalize
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_PREJFILE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|entry
operator|->
name|conflict_old
operator|=
name|extract_string_normalize
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_CONFLICT_OLD
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|entry
operator|->
name|conflict_new
operator|=
name|extract_string_normalize
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_CONFLICT_NEW
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|entry
operator|->
name|conflict_wrk
operator|=
name|extract_string_normalize
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_CONFLICT_WRK
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Is this entry copied? */
comment|/* ### not used by loggy; no need to set MODIFY_FLAGS  */
name|SVN_ERR
argument_list|(
name|do_bool_attr
argument_list|(
operator|&
name|entry
operator|->
name|copied
argument_list|,
name|atts
argument_list|,
name|ENTRIES_ATTR_COPIED
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### not used by loggy; no need to set MODIFY_FLAGS  */
name|entry
operator|->
name|copyfrom_url
operator|=
name|extract_string
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_COPYFROM_URL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* ### not used by loggy; no need to set MODIFY_FLAGS  */
block|{
specifier|const
name|char
modifier|*
name|revstr
decl_stmt|;
name|revstr
operator|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_COPYFROM_REV
argument_list|)
expr_stmt|;
if|if
condition|(
name|revstr
condition|)
name|entry
operator|->
name|copyfrom_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|revstr
argument_list|)
expr_stmt|;
block|}
comment|/* Is this entry deleted?       ### not used by loggy; no need to set MODIFY_FLAGS  */
name|SVN_ERR
argument_list|(
name|do_bool_attr
argument_list|(
operator|&
name|entry
operator|->
name|deleted
argument_list|,
name|atts
argument_list|,
name|ENTRIES_ATTR_DELETED
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is this entry absent?       ### not used by loggy; no need to set MODIFY_FLAGS  */
name|SVN_ERR
argument_list|(
name|do_bool_attr
argument_list|(
operator|&
name|entry
operator|->
name|absent
argument_list|,
name|atts
argument_list|,
name|ENTRIES_ATTR_ABSENT
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is this entry incomplete?       ### not used by loggy; no need to set MODIFY_FLAGS  */
name|SVN_ERR
argument_list|(
name|do_bool_attr
argument_list|(
operator|&
name|entry
operator|->
name|incomplete
argument_list|,
name|atts
argument_list|,
name|ENTRIES_ATTR_INCOMPLETE
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Attempt to set up timestamps. */
comment|/* ### not used by loggy; no need to set MODIFY_FLAGS  */
block|{
specifier|const
name|char
modifier|*
name|text_timestr
decl_stmt|;
name|text_timestr
operator|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_TEXT_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_timestr
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|entry
operator|->
name|text_time
argument_list|,
name|text_timestr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: we do not persist prop_time, so there is no need to attempt        to parse a new prop_time value from the log. Certainly, on any        recent working copy, there will not be a log record to alter        the prop_time value. */
block|}
comment|/* Checksum. */
comment|/* ### not used by loggy; no need to set MODIFY_FLAGS  */
name|entry
operator|->
name|checksum
operator|=
name|extract_string
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_CHECKSUM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* UUID.       ### not used by loggy; no need to set MODIFY_FLAGS  */
name|entry
operator|->
name|uuid
operator|=
name|extract_string
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_UUID
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Setup last-committed values. */
block|{
specifier|const
name|char
modifier|*
name|cmt_datestr
decl_stmt|,
modifier|*
name|cmt_revstr
decl_stmt|;
name|cmt_datestr
operator|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_CMT_DATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_datestr
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|entry
operator|->
name|cmt_date
argument_list|,
name|cmt_datestr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|->
name|cmt_date
operator|=
literal|0
expr_stmt|;
name|cmt_revstr
operator|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_CMT_REV
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_revstr
condition|)
block|{
name|entry
operator|->
name|cmt_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|cmt_revstr
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|->
name|cmt_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|cmt_author
operator|=
name|extract_string
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_CMT_AUTHOR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* ### not used by loggy; no need to set MODIFY_FLAGS  */
name|entry
operator|->
name|lock_token
operator|=
name|extract_string
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_LOCK_TOKEN
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|entry
operator|->
name|lock_owner
operator|=
name|extract_string
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_LOCK_OWNER
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|entry
operator|->
name|lock_comment
operator|=
name|extract_string
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_LOCK_COMMENT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|cdate_str
init|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_LOCK_CREATION_DATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cdate_str
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|entry
operator|->
name|lock_creation_date
argument_list|,
name|cdate_str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ----- end of lock handling.  */
comment|/* Note: if there are attributes for the (deprecated) has_props,      has_prop_mods, cachable_props, or present_props, then we're just      going to ignore them. */
comment|/* Translated size */
comment|/* ### not used by loggy; no need to set MODIFY_FLAGS  */
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|svn_hash_gets
argument_list|(
name|atts
argument_list|,
name|ENTRIES_ATTR_WORKING_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
condition|)
block|{
comment|/* Cast to off_t; it's safe: we put in an off_t to start with... */
name|entry
operator|->
name|working_size
operator|=
operator|(
name|apr_off_t
operator|)
name|apr_strtoi64
argument_list|(
name|val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|new_entry
operator|=
name|entry
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Used when reading an entries file in XML format. */
end_comment

begin_struct
struct|struct
name|entries_accumulator
block|{
comment|/* Keys are entry names, vals are (struct svn_wc_entry_t *)'s. */
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
comment|/* The parser that's parsing it, for signal_expat_bailout(). */
name|svn_xml_parser_t
modifier|*
name|parser
decl_stmt|;
comment|/* Don't leave home without one. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Cleared before handling each entry. */
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Called whenever we find an<open> tag of some kind. */
end_comment

begin_function
specifier|static
name|void
name|handle_start_tag
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|tagname
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|struct
name|entries_accumulator
modifier|*
name|accum
init|=
name|userData
decl_stmt|;
name|apr_hash_t
modifier|*
name|attributes
decl_stmt|;
name|svn_wc_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* We only care about the `entry' tag; all other tags, such as `xml'      and `wc-entries', are ignored. */
if|if
condition|(
name|strcmp
argument_list|(
name|tagname
argument_list|,
name|ENTRIES_TAG_ENTRY
argument_list|)
condition|)
return|return;
name|svn_pool_clear
argument_list|(
name|accum
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Make an entry from the attributes. */
name|attributes
operator|=
name|svn_xml_make_att_hash
argument_list|(
name|atts
argument_list|,
name|accum
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|atts_to_entry
argument_list|(
operator|&
name|entry
argument_list|,
name|attributes
argument_list|,
name|accum
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_xml_signal_bailout
argument_list|(
name|err
argument_list|,
name|accum
operator|->
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the name and set up the entry under that name.  This      should *NOT* be NULL, since svn_wc__atts_to_entry() should      have made it into SVN_WC_ENTRY_THIS_DIR. */
name|svn_hash_sets
argument_list|(
name|accum
operator|->
name|entries
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse BUF of size SIZE as an entries file in XML format, storing the parsed    entries in ENTRIES.  Use SCRATCH_POOL for temporary allocations and    RESULT_POOL for the returned entries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_entries_xml
parameter_list|(
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|entries
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_xml_parser_t
modifier|*
name|svn_parser
decl_stmt|;
name|struct
name|entries_accumulator
name|accum
decl_stmt|;
comment|/* Set up userData for the XML parser. */
name|accum
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
name|accum
operator|.
name|pool
operator|=
name|result_pool
expr_stmt|;
name|accum
operator|.
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Create the XML parser */
name|svn_parser
operator|=
name|svn_xml_make_parser
argument_list|(
operator|&
name|accum
argument_list|,
name|handle_start_tag
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Store parser in its own userdata, so callbacks can call      svn_xml_signal_bailout() */
name|accum
operator|.
name|parser
operator|=
name|svn_parser
expr_stmt|;
comment|/* Parse. */
name|SVN_ERR_W
argument_list|(
name|svn_xml_parse
argument_list|(
name|svn_parser
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"XML parser failed in '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|accum
operator|.
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Clean up the XML parser */
name|svn_xml_free_parser
argument_list|(
name|svn_parser
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Use entry SRC to fill in blank portions of entry DST.  SRC itself    may not have any blanks, of course.    Typically, SRC is a parent directory's own entry, and DST is some    child in that directory. */
end_comment

begin_function
specifier|static
name|void
name|take_from_entry
parameter_list|(
specifier|const
name|svn_wc_entry_t
modifier|*
name|src
parameter_list|,
name|svn_wc_entry_t
modifier|*
name|dst
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Inherits parent's revision if doesn't have a revision of one's      own, unless this is a subdirectory. */
if|if
condition|(
operator|(
name|dst
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
operator|)
operator|&&
operator|(
name|dst
operator|->
name|kind
operator|!=
name|svn_node_dir
operator|)
condition|)
name|dst
operator|->
name|revision
operator|=
name|src
operator|->
name|revision
expr_stmt|;
comment|/* Inherits parent's url if doesn't have a url of one's own. */
if|if
condition|(
operator|!
name|dst
operator|->
name|url
condition|)
name|dst
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|src
operator|->
name|url
argument_list|,
name|dst
operator|->
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst
operator|->
name|repos
condition|)
name|dst
operator|->
name|repos
operator|=
name|src
operator|->
name|repos
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|dst
operator|->
name|uuid
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|dst
operator|->
name|schedule
operator|==
name|svn_wc_schedule_add
operator|)
operator|||
operator|(
name|dst
operator|->
name|schedule
operator|==
name|svn_wc_schedule_replace
operator|)
operator|)
operator|)
condition|)
block|{
name|dst
operator|->
name|uuid
operator|=
name|src
operator|->
name|uuid
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resolve any missing information in ENTRIES by deducing from the    directory's own entry (which must already be present in ENTRIES). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_to_defaults
parameter_list|(
name|apr_hash_t
modifier|*
name|entries
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_wc_entry_t
modifier|*
name|default_entry
init|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|SVN_WC_ENTRY_THIS_DIR
argument_list|)
decl_stmt|;
comment|/* First check the dir's own entry for consistency. */
if|if
condition|(
operator|!
name|default_entry
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing default entry"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|default_entry
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ENTRY_MISSING_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Default entry has no revision number"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|default_entry
operator|->
name|url
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ENTRY_MISSING_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Default entry is missing URL"
argument_list|)
argument_list|)
return|;
comment|/* Then use it to fill in missing information in other entries. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_wc_entry_t
modifier|*
name|this_entry
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_entry
operator|==
name|default_entry
condition|)
comment|/* THIS_DIR already has all the information it can possibly            have.  */
continue|continue;
if|if
condition|(
name|this_entry
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
comment|/* Entries that are directories have everything but their            name, kind, and state stored in the THIS_DIR entry of the            directory itself.  However, we are disallowing the perusing            of any entries outside of the current entries file.  If a            caller wants more info about a directory, it should look in            the entries file in the directory.  */
continue|continue;
if|if
condition|(
name|this_entry
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
comment|/* For file nodes that do not explicitly have their ancestry            stated, this can be derived from the default entry of the            directory in which those files reside.  */
name|take_from_entry
argument_list|(
name|default_entry
argument_list|,
name|this_entry
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read and parse an old-style 'entries' file in the administrative area    of PATH, filling in ENTRIES with the contents. The results will be    allocated in RESULT_POOL, and temporary allocations will be made in    SCRATCH_POOL.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__read_entries_old
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|char
modifier|*
name|curp
decl_stmt|;
specifier|const
name|char
modifier|*
name|endp
decl_stmt|;
name|svn_wc_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_string_t
modifier|*
name|buf
decl_stmt|;
operator|*
name|entries
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Open the entries file. */
name|SVN_ERR
argument_list|(
name|svn_wc__open_adm_stream
argument_list|(
operator|&
name|stream
argument_list|,
name|dir_abspath
argument_list|,
name|SVN_WC__ADM_ENTRIES
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_string_from_stream
argument_list|(
operator|&
name|buf
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We own the returned data; it is modifiable, so cast away... */
name|curp
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|->
name|data
expr_stmt|;
name|endp
operator|=
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|len
expr_stmt|;
comment|/* If the first byte of the file is not a digit, then it is probably in XML      format. */
if|if
condition|(
name|curp
operator|!=
name|endp
operator|&&
operator|!
name|svn_ctype_isdigit
argument_list|(
operator|*
name|curp
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|parse_entries_xml
argument_list|(
name|dir_abspath
argument_list|,
operator|*
name|entries
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|entryno
decl_stmt|,
name|entries_format
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
comment|/* Read the format line from the entries file. In case we're in the          middle of upgrading a working copy, this line will contain the          original format pre-upgrade. */
name|SVN_ERR
argument_list|(
name|read_val
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|curp
argument_list|,
name|endp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|entries_format
operator|=
operator|(
name|int
operator|)
name|apr_strtoi64
argument_list|(
name|val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid version line in entries file "
literal|"of '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|entryno
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|curp
operator|!=
name|endp
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|read_entry
argument_list|(
operator|&
name|entry
argument_list|,
operator|&
name|curp
argument_list|,
name|endp
argument_list|,
name|entries_format
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
comment|/* We allow extra fields at the end of the line, for                  extensibility. */
name|curp
operator|=
name|memchr
argument_list|(
name|curp
argument_list|,
literal|'\f'
argument_list|,
name|endp
operator|-
name|curp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curp
condition|)
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing entry terminator"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
operator|(
name|curp
operator|==
name|endp
operator|||
operator|*
operator|(
operator|++
name|curp
operator|)
operator|!=
literal|'\n'
operator|)
condition|)
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid entry terminator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Error at entry %d in entries file for "
literal|"'%s':"
argument_list|)
argument_list|,
name|entryno
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
operator|++
name|curp
expr_stmt|;
operator|++
name|entryno
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|entries
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fill in any implied fields. */
return|return
name|svn_error_trace
argument_list|(
name|resolve_to_defaults
argument_list|(
operator|*
name|entries
argument_list|,
name|result_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For non-directory PATHs full entry information is obtained by reading  * the entries for the parent directory of PATH and then extracting PATH's  * entry.  If PATH is a directory then only abrieviated information is  * available in the parent directory, more complete information is  * available by reading the entries for PATH itself.  *  * Note: There is one bit of information about directories that is only  * available in the parent directory, that is the "deleted" state.  If PATH  * is a versioned directory then the "deleted" state information will not  * be returned in ENTRY.  This means some bits of the code (e.g. revert)  * need to obtain it by directly extracting the directory entry from the  * parent directory's entries.  I wonder if this function should handle  * that?  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc_entry
parameter_list|(
specifier|const
name|svn_wc_entry_t
modifier|*
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|,
name|svn_boolean_t
name|show_hidden
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|svn_wc__adm_get_db
argument_list|(
name|adm_access
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_wc_adm_access_t
modifier|*
name|dir_access
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry_name
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Does the provided path refer to a directory with an associated      access baton?  */
name|dir_access
operator|=
name|svn_wc__adm_retrieve_internal2
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_access
operator|==
name|NULL
condition|)
block|{
comment|/* Damn. Okay. Assume the path is to a child, and let's look for          a baton associated with its parent.  */
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|dir_abspath
argument_list|,
operator|&
name|entry_name
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dir_access
operator|=
name|svn_wc__adm_retrieve_internal2
argument_list|(
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Woo! Got one. Look for "this dir" in the entries hash.  */
name|entry_name
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|dir_access
operator|==
name|NULL
condition|)
block|{
comment|/* Early exit.  */
operator|*
name|entry
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Load an entries hash, and cache it into DIR_ACCESS. Go ahead and      fetch all entries here (optimization) since we know how to filter      out a "hidden" node.  */
name|SVN_ERR
argument_list|(
name|svn_wc__entries_read_internal
argument_list|(
operator|&
name|entries
argument_list|,
name|dir_access
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|entry
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|entry_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|show_hidden
operator|&&
operator|*
name|entry
operator|!=
name|NULL
condition|)
block|{
name|svn_boolean_t
name|hidden
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__entry_is_hidden
argument_list|(
operator|&
name|hidden
argument_list|,
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hidden
condition|)
operator|*
name|entry
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

