begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * lock.c:  routines for locking working copy subdirectories.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_define
define|#
directive|define
name|SVN_DEPRECATED
end_define

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_time.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"props.h"
end_include

begin_include
include|#
directive|include
file|"wc_db.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_escape
end_escape

begin_struct
struct|struct
name|svn_wc_adm_access_t
block|{
comment|/* PATH to directory which contains the administrative area */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* And the absolute form of the path.  */
specifier|const
name|char
modifier|*
name|abspath
decl_stmt|;
comment|/* Indicates that the baton has been closed. */
name|svn_boolean_t
name|closed
decl_stmt|;
comment|/* Handle to the administrative database. */
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
comment|/* Was the DB provided to us? If so, then we'll never close it.  */
name|svn_boolean_t
name|db_provided
decl_stmt|;
comment|/* ENTRIES_HIDDEN is all cached entries including those in      state deleted or state absent. It may be NULL. */
name|apr_hash_t
modifier|*
name|entries_all
decl_stmt|;
comment|/* POOL is used to allocate cached items, they need to persist for the      lifetime of this access baton */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is a placeholder used in the set hash to represent missing    directories.  Only its address is important, it contains no useful    data. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_wc_adm_access_t
name|missing
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_MISSING
parameter_list|(
name|lock
parameter_list|)
value|((lock) ==&missing)
end_define

begin_comment
comment|/* ### hack for now. future functionality coming in a future revision.  */
end_comment

begin_define
define|#
directive|define
name|svn_wc__db_is_closed
parameter_list|(
name|db
parameter_list|)
value|FALSE
end_define

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_check_wc
parameter_list|(
name|int
modifier|*
name|wc_format
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|check_path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc__db_temp_get_format
argument_list|(
name|wc_format
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_MISSING
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_UNSUPPORTED_FORMAT
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_UPGRADE_REQUIRED
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* ### the stuff below seems to be redundant. get_format() probably          ### does all this.          ###          ### investigate all callers. DEFINITELY keep in mind the          ### svn_wc_check_wc() entrypoint.       */
comment|/* If the format file does not exist or path not directory, then for          our purposes this is not a working copy, so return 0. */
operator|*
name|wc_format
operator|=
literal|0
expr_stmt|;
comment|/* Check path itself exists. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|APR_ENOENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' does not exist"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|*
name|wc_format
operator|>=
name|SVN_WC__WC_NG_VERSION
condition|)
block|{
name|svn_wc__db_status_t
name|db_status
decl_stmt|;
name|svn_node_kind_t
name|db_kind
decl_stmt|;
if|if
condition|(
name|check_path
condition|)
block|{
comment|/* If a node is not a directory, it is not a working copy              directory.  This allows creating new working copies as              a path below an existing working copy. */
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|wc_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_kind
operator|!=
name|svn_node_dir
condition|)
block|{
operator|*
name|wc_format
operator|=
literal|0
expr_stmt|;
comment|/* Not a directory, so not a wc-directory */
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|err
operator|=
name|svn_wc__db_read_info
argument_list|(
operator|&
name|db_status
argument_list|,
operator|&
name|db_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|wc_format
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_kind
operator|!=
name|svn_node_dir
condition|)
block|{
comment|/* The WC thinks there must be a file, so this is not              a wc-directory */
operator|*
name|wc_format
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
switch|switch
condition|(
name|db_status
condition|)
block|{
case|case
name|svn_wc__db_status_not_present
case|:
case|case
name|svn_wc__db_status_server_excluded
case|:
case|case
name|svn_wc__db_status_excluded
case|:
comment|/* If there is a directory here, it is not related to the parent                working copy: Obstruction */
operator|*
name|wc_format
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
default|default:
break|break;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_check_wc2
parameter_list|(
name|int
modifier|*
name|wc_format
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* ### Should we pass TRUE for check_path to find obstructions and          missing directories? */
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__internal_check_wc
argument_list|(
name|wc_format
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_to_shared
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* ### sometimes we replace&missing with a now-valid lock.  */
block|{
name|svn_wc_adm_access_t
modifier|*
name|prior
init|=
name|svn_wc__db_temp_get_access
argument_list|(
name|lock
operator|->
name|db
argument_list|,
name|lock
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_MISSING
argument_list|(
name|prior
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_close_access
argument_list|(
name|lock
operator|->
name|db
argument_list|,
name|lock
operator|->
name|abspath
argument_list|,
name|prior
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_wc__db_temp_set_access
argument_list|(
name|lock
operator|->
name|db
argument_list|,
name|lock
operator|->
name|abspath
argument_list|,
name|lock
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_wc_adm_access_t
modifier|*
name|get_from_shared
parameter_list|(
specifier|const
name|char
modifier|*
name|abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* We closed the DB when it became empty. ABSPATH is not present.  */
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|svn_wc__db_temp_get_access
argument_list|(
name|db
argument_list|,
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_single
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|,
name|svn_boolean_t
name|preserve_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|locked
decl_stmt|;
if|if
condition|(
name|adm_access
operator|->
name|closed
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Physically unlock if required */
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock
argument_list|(
operator|&
name|locked
argument_list|,
name|adm_access
operator|->
name|db
argument_list|,
name|adm_access
operator|->
name|abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
block|{
if|if
condition|(
operator|!
name|preserve_lock
condition|)
block|{
comment|/* Remove the physical lock in the admin directory for              PATH. It is acceptable for the administrative area to              have disappeared, such as when the directory is removed              from the working copy.  It is an error for the lock to              have disappeared if the administrative area still exists. */
name|svn_error_t
modifier|*
name|err
init|=
name|svn_wc__db_wclock_release
argument_list|(
name|adm_access
operator|->
name|db
argument_list|,
name|adm_access
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|svn_wc__adm_area_exists
argument_list|(
name|adm_access
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|err
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Reset to prevent further use of the lock. */
name|adm_access
operator|->
name|closed
operator|=
name|TRUE
expr_stmt|;
comment|/* Detach from set */
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_close_access
argument_list|(
name|adm_access
operator|->
name|db
argument_list|,
name|adm_access
operator|->
name|abspath
argument_list|,
name|adm_access
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Possibly close the underlying wc_db. */
if|if
condition|(
operator|!
name|adm_access
operator|->
name|db_provided
condition|)
block|{
name|apr_hash_t
modifier|*
name|opened
init|=
name|svn_wc__db_temp_get_all_access
argument_list|(
name|adm_access
operator|->
name|db
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|opened
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_close
argument_list|(
name|adm_access
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|adm_access
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Cleanup for a locked access baton.     This handles closing access batons when their pool gets destroyed.    The physical locks associated with such batons remain in the working    copy if they are protecting work items in the workqueue.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|pool_cleanup_locked
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|svn_wc_adm_access_t
modifier|*
name|lock
init|=
name|p
decl_stmt|;
name|apr_uint64_t
name|id
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|lock
operator|->
name|closed
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* If the DB is closed, then we have a bunch of extra work to do.  */
if|if
condition|(
name|svn_wc__db_is_closed
argument_list|(
name|lock
operator|->
name|db
argument_list|)
condition|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
name|lock
operator|->
name|closed
operator|=
name|TRUE
expr_stmt|;
comment|/* If there is no ADM area, then we definitely have no work items          or physical locks to worry about. Bail out.  */
if|if
condition|(
operator|!
name|svn_wc__adm_area_exists
argument_list|(
name|lock
operator|->
name|abspath
argument_list|,
name|lock
operator|->
name|pool
argument_list|)
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* Creating a subpool is safe within a pool cleanup, as long as          we're absolutely sure to destroy it before we exit this function.           We avoid using LOCK->POOL to keep the following functions from          hanging cleanups or subpools from it. (the cleanups *might* get          run, but the subpools will NOT be destroyed)  */
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|lock
operator|->
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__db_open
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
comment|/* ### config. need! */
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|err
operator|=
name|svn_wc__db_wq_fetch_next
argument_list|(
operator|&
name|id
argument_list|,
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|lock
operator|->
name|abspath
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|work_item
operator|==
name|NULL
condition|)
block|{
comment|/* There is no remaining work, so we're good to remove any                  potential "physical" lock.  */
name|err
operator|=
name|svn_wc__db_wclock_release
argument_list|(
name|db
argument_list|,
name|lock
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Closes the DB, too.  */
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* ### should we create an API that just looks, but doesn't return?  */
name|err
operator|=
name|svn_wc__db_wq_fetch_next
argument_list|(
operator|&
name|id
argument_list|,
operator|&
name|work_item
argument_list|,
name|lock
operator|->
name|db
argument_list|,
name|lock
operator|->
name|abspath
argument_list|,
literal|0
argument_list|,
name|lock
operator|->
name|pool
argument_list|,
name|lock
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Close just this access baton. The pool cleanup will close the rest.  */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|close_single
argument_list|(
name|lock
argument_list|,
name|work_item
operator|!=
name|NULL
comment|/* preserve_lock */
argument_list|,
name|lock
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|apr_status_t
name|apr_err
init|=
name|err
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|apr_err
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Cleanup for a readonly access baton.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|pool_cleanup_readonly
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|svn_wc_adm_access_t
modifier|*
name|lock
init|=
name|data
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|lock
operator|->
name|closed
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* If the DB is closed, then we have nothing to do. There are no      "physical" locks to remove, and we don't care whether this baton      is registered with the DB.  */
if|if
condition|(
name|svn_wc__db_is_closed
argument_list|(
name|lock
operator|->
name|db
argument_list|)
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* Close this baton. No lock to preserve. Since this is part of the      pool cleanup, we don't need to close children -- the cleanup process      will close all children.  */
name|err
operator|=
name|close_single
argument_list|(
name|lock
argument_list|,
name|FALSE
comment|/* preserve_lock */
argument_list|,
name|lock
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|apr_status_t
name|result
init|=
name|err
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* An APR pool cleanup handler.  This is a child handler, it removes the    main pool handler. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|pool_cleanup_child
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|svn_wc_adm_access_t
modifier|*
name|lock
init|=
name|p
decl_stmt|;
name|apr_pool_cleanup_kill
argument_list|(
name|lock
operator|->
name|pool
argument_list|,
name|lock
argument_list|,
name|pool_cleanup_locked
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_kill
argument_list|(
name|lock
operator|->
name|pool
argument_list|,
name|lock
argument_list|,
name|pool_cleanup_readonly
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Allocate from POOL, initialise and return an access baton. TYPE and PATH    are used to initialise the baton.  If STEAL_LOCK, steal the lock if path    is already locked */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|adm_access_alloc
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|adm_access
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_boolean_t
name|db_provided
parameter_list|,
name|svn_boolean_t
name|write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_wc_adm_access_t
modifier|*
name|lock
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lock
argument_list|)
argument_list|)
decl_stmt|;
name|lock
operator|->
name|closed
operator|=
name|FALSE
expr_stmt|;
name|lock
operator|->
name|entries_all
operator|=
name|NULL
expr_stmt|;
name|lock
operator|->
name|db
operator|=
name|db
expr_stmt|;
name|lock
operator|->
name|db_provided
operator|=
name|db_provided
expr_stmt|;
name|lock
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|lock
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|lock
operator|->
name|abspath
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|adm_access
operator|=
name|lock
expr_stmt|;
if|if
condition|(
name|write_lock
condition|)
block|{
name|svn_boolean_t
name|owns_lock
decl_stmt|;
comment|/* If the db already owns a lock, we can't add an extra lock record */
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock
argument_list|(
operator|&
name|owns_lock
argument_list|,
name|db
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If DB owns the lock, but when there is no access baton open for this          directory, old access baton based code is trying to access data that          was previously locked by new code. Just hand them the lock, or          important code paths like svn_wc_add3() will start failing */
if|if
condition|(
operator|!
name|owns_lock
operator|||
name|svn_wc__adm_retrieve_internal2
argument_list|(
name|db
argument_list|,
name|lock
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_obtain
argument_list|(
name|db
argument_list|,
name|lock
operator|->
name|abspath
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|add_to_shared
argument_list|(
name|lock
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_wc__db_wclock_release
argument_list|(
name|db
argument_list|,
name|lock
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* ### does this utf8 thing really/still apply??  */
comment|/* It's important that the cleanup handler is registered *after* at least      one UTF8 conversion has been done, since such a conversion may create      the apr_xlate_t object in the pool, and that object must be around      when the cleanup handler runs.  If the apr_xlate_t cleanup handler      were to run *before* the access baton cleanup handler, then the access      baton's handler won't work. */
comment|/* Register an appropriate cleanup handler, based on the whether this      access baton is locked or not.  */
name|apr_pool_cleanup_register
argument_list|(
name|lock
operator|->
name|pool
argument_list|,
name|lock
argument_list|,
name|write_lock
condition|?
name|pool_cleanup_locked
else|:
name|pool_cleanup_readonly
argument_list|,
name|pool_cleanup_child
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|probe
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|int
name|wc_format
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__internal_check_wc
argument_list|(
operator|&
name|wc_format
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* a "version" of 0 means a non-wc directory */
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
operator|||
name|wc_format
operator|==
literal|0
condition|)
block|{
comment|/* Passing a path ending in "." or ".." to svn_dirent_dirname() is          probably always a bad idea; certainly it is in this case.          Unfortunately, svn_dirent_dirname()'s current signature can't          return an error, so we have to insert the protection in this          caller, ideally the API needs a change.  See issue #1617. */
specifier|const
name|char
modifier|*
name|base_name
init|=
name|svn_dirent_basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|base_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|base_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_BAD_PATH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' ends in '%s', "
literal|"which is unsupported for this operation"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|base_name
argument_list|)
return|;
block|}
operator|*
name|dir
operator|=
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|dir
operator|=
name|path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_single
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|adm_access
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|write_lock
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_boolean_t
name|db_provided
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|int
name|wc_format
init|=
literal|0
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_wc_adm_access_t
modifier|*
name|lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__internal_check_wc
argument_list|(
operator|&
name|wc_format
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_format
operator|==
literal|0
operator|||
operator|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* The format version must match exactly. Note that wc_db will perform      an auto-upgrade if allowed. If it does *not*, then it has decided a      manual upgrade is required and it should have raised an error.  */
name|SVN_ERR_ASSERT
argument_list|(
name|wc_format
operator|==
name|SVN_WC__VERSION
argument_list|)
expr_stmt|;
comment|/* Need to create a new lock */
name|SVN_ERR
argument_list|(
name|adm_access_alloc
argument_list|(
operator|&
name|lock
argument_list|,
name|path
argument_list|,
name|db
argument_list|,
name|db_provided
argument_list|,
name|write_lock
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### recurse was here */
operator|*
name|adm_access
operator|=
name|lock
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Retrieves the KIND of LOCAL_ABSPATH and whether its administrative data is    available in the working copy.     *AVAILABLE is set to TRUE when the node and its metadata are available,    otherwise to FALSE (due to obstruction, missing, absence, exclusion,    or a "not-present" child).     KIND can be NULL.     ### note: this function should go away when we move to a single    ### adminstrative area.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|adm_available
parameter_list|(
name|svn_boolean_t
modifier|*
name|available
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
if|if
condition|(
name|kind
condition|)
operator|*
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|available
operator|=
operator|!
operator|(
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_not_present
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is essentially the guts of svn_wc_adm_open3.  *  * If the working copy is already locked, return SVN_ERR_WC_LOCKED; if  * it is not a versioned directory, return SVN_ERR_WC_NOT_WORKING_COPY.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_open
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|adm_access
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_boolean_t
name|db_provided
parameter_list|,
name|apr_array_header_t
modifier|*
name|rollback
parameter_list|,
name|svn_boolean_t
name|write_lock
parameter_list|,
name|int
name|levels_to_lock
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_adm_access_t
modifier|*
name|lock
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_single
argument_list|(
operator|&
name|lock
argument_list|,
name|path
argument_list|,
name|write_lock
argument_list|,
name|db
argument_list|,
name|db_provided
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add self to the rollback list in case of error.  */
name|APR_ARRAY_PUSH
argument_list|(
name|rollback
argument_list|,
name|svn_wc_adm_access_t
operator|*
argument_list|)
operator|=
name|lock
expr_stmt|;
if|if
condition|(
name|levels_to_lock
operator|!=
literal|0
condition|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_wc__adm_access_abspath
argument_list|(
name|lock
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Reduce levels_to_lock since we are about to recurse */
if|if
condition|(
name|levels_to_lock
operator|>
literal|0
condition|)
name|levels_to_lock
operator|--
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_children
argument_list|(
operator|&
name|children
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open the tree */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|node_abspath
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|available
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* See if someone wants to cancel this operation. */
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|node_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|adm_available
argument_list|(
operator|&
name|available
argument_list|,
operator|&
name|kind
argument_list|,
name|db
argument_list|,
name|node_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
continue|continue;
if|if
condition|(
name|available
condition|)
block|{
specifier|const
name|char
modifier|*
name|node_path
init|=
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|svn_wc_adm_access_t
modifier|*
name|node_access
decl_stmt|;
name|SVN_ERR
argument_list|(
name|do_open
argument_list|(
operator|&
name|node_access
argument_list|,
name|node_path
argument_list|,
name|db
argument_list|,
name|db_provided
argument_list|,
name|rollback
argument_list|,
name|write_lock
argument_list|,
name|levels_to_lock
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|lock
operator|->
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* node_access has been registered in DB, so we don't need                  to do anything with it.  */
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|adm_access
operator|=
name|lock
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_all
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|adm_access
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_boolean_t
name|db_provided
parameter_list|,
name|svn_boolean_t
name|write_lock
parameter_list|,
name|int
name|levels_to_lock
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|rollback
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|rollback
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|10
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc_adm_access_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|do_open
argument_list|(
name|adm_access
argument_list|,
name|path
argument_list|,
name|db
argument_list|,
name|db_provided
argument_list|,
name|rollback
argument_list|,
name|write_lock
argument_list|,
name|levels_to_lock
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rollback
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
name|svn_wc_adm_access_t
modifier|*
name|lock
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rollback
argument_list|,
name|i
argument_list|,
name|svn_wc_adm_access_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|IS_MISSING
argument_list|(
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|close_single
argument_list|(
name|lock
argument_list|,
name|FALSE
comment|/* preserve_lock */
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_adm_open3
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|adm_access
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|associated
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|write_lock
parameter_list|,
name|int
name|levels_to_lock
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
name|svn_boolean_t
name|db_provided
decl_stmt|;
comment|/* Make sure that ASSOCIATED has a set of access batons, so that we can      glom a reference to self into it. */
if|if
condition|(
name|associated
condition|)
block|{
specifier|const
name|char
modifier|*
name|abspath
decl_stmt|;
name|svn_wc_adm_access_t
modifier|*
name|lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|=
name|get_from_shared
argument_list|(
name|abspath
argument_list|,
name|associated
operator|->
name|db
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|&&
operator|!
name|IS_MISSING
argument_list|(
name|lock
argument_list|)
condition|)
comment|/* Already locked.  The reason we don't return the existing baton            here is that the user is supposed to know whether a directory is            locked: if it's not locked call svn_wc_adm_open, if it is locked            call svn_wc_adm_retrieve.  */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_LOCKED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Working copy '%s' locked"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|db
operator|=
name|associated
operator|->
name|db
expr_stmt|;
name|db_provided
operator|=
name|associated
operator|->
name|db_provided
expr_stmt|;
block|}
else|else
block|{
comment|/* Any baton creation is going to need a shared structure for holding          data across the entire set. The caller isn't providing one, so we          do it here.  */
comment|/* ### we could optimize around levels_to_lock==0, but much of this          ### is going to be simplified soon anyways.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_open
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
comment|/* ### config. need! */
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db_provided
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|open_all
argument_list|(
name|adm_access
argument_list|,
name|path
argument_list|,
name|db
argument_list|,
name|db_provided
argument_list|,
name|write_lock
argument_list|,
name|levels_to_lock
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_adm_probe_open3
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|adm_access
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|associated
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|write_lock
parameter_list|,
name|int
name|levels_to_lock
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
name|associated
operator|==
name|NULL
condition|)
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
comment|/* Ugh. Too bad about having to open a DB.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_open
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
comment|/* ### config */
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|probe
argument_list|(
name|db
argument_list|,
operator|&
name|dir
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_wc__db_close
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|probe
argument_list|(
name|associated
operator|->
name|db
argument_list|,
operator|&
name|dir
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we moved up a directory, then the path is not a directory, or it      is not under version control. In either case, the notion of      levels_to_lock does not apply to the provided path.  Disable it so      that we don't end up trying to lock more than we need.  */
if|if
condition|(
name|dir
operator|!=
name|path
condition|)
name|levels_to_lock
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|svn_wc_adm_open3
argument_list|(
name|adm_access
argument_list|,
name|associated
argument_list|,
name|dir
argument_list|,
name|write_lock
argument_list|,
name|levels_to_lock
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
comment|/* If we got an error on the parent dir, that means we failed to          get an access baton for the child in the first place.  And if          the reason we couldn't get the child access baton is that the          child is not a versioned directory, then return an error          about the child, not the parent. */
name|svn_node_kind_t
name|child_kind
decl_stmt|;
if|if
condition|(
operator|(
name|err2
operator|=
name|svn_io_check_path
argument_list|(
name|path
argument_list|,
operator|&
name|child_kind
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|svn_error_compose
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
operator|(
name|dir
operator|!=
name|path
operator|)
operator|&&
operator|(
name|child_kind
operator|==
name|svn_node_dir
operator|)
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_NOT_WORKING_COPY
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|err
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_wc_adm_access_t
modifier|*
name|svn_wc__adm_retrieve_internal2
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_adm_access_t
modifier|*
name|adm_access
init|=
name|get_from_shared
argument_list|(
name|abspath
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* If the entry is marked as "missing", then return nothing.  */
if|if
condition|(
name|IS_MISSING
argument_list|(
name|adm_access
argument_list|)
condition|)
name|adm_access
operator|=
name|NULL
expr_stmt|;
return|return
name|adm_access
return|;
block|}
end_function

begin_comment
comment|/* SVN_DEPRECATED */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc_adm_retrieve
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|adm_access
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|associated
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_node_kind_t
name|kind
init|=
name|svn_node_unknown
decl_stmt|;
name|svn_node_kind_t
name|wckind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|associated
operator|->
name|path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|adm_access
operator|=
name|associated
expr_stmt|;
else|else
operator|*
name|adm_access
operator|=
name|svn_wc__adm_retrieve_internal2
argument_list|(
name|associated
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We found what we're looking for, so bail. */
if|if
condition|(
operator|*
name|adm_access
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Most of the code expects access batons to exist, so returning an error      generally makes the calling code simpler as it doesn't need to check      for NULL batons. */
comment|/* We are going to send a SVN_ERR_WC_NOT_LOCKED, but let's provide      a bit more information to our caller */
name|err
operator|=
name|svn_io_check_path
argument_list|(
name|path
argument_list|,
operator|&
name|wckind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we can't check the path, we can't make a good error message.  */
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_LOCKED
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Unable to check path existence for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|associated
condition|)
block|{
name|err
operator|=
name|svn_wc__db_read_kind
argument_list|(
operator|&
name|kind
argument_list|,
name|svn_wc__adm_get_db
argument_list|(
name|associated
argument_list|)
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
comment|/* allow_missing */
argument_list|,
name|TRUE
comment|/* show_deleted */
argument_list|,
name|FALSE
comment|/* show_hidden */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
operator|&&
name|wckind
operator|==
name|svn_node_file
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected '%s' to be a directory but found a file"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_NOT_LOCKED
argument_list|,
name|err
argument_list|,
name|err
operator|->
name|message
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
operator|&&
name|kind
operator|!=
name|svn_node_unknown
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't retrieve an access baton for non-directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_NOT_LOCKED
argument_list|,
name|err
argument_list|,
name|err
operator|->
name|message
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_unknown
operator|||
name|wckind
operator|==
name|svn_node_none
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory '%s' is missing"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_NOT_LOCKED
argument_list|,
name|err
argument_list|,
name|err
operator|->
name|message
argument_list|)
return|;
block|}
comment|/* If all else fails, return our useless generic error.  */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_LOCKED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Working copy '%s' is not locked"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* SVN_DEPRECATED */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc_adm_probe_retrieve
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|adm_access
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|associated
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|associated
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_kind
argument_list|(
operator|&
name|kind
argument_list|,
name|associated
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
comment|/* allow_missing */
argument_list|,
name|TRUE
comment|/* show_deleted */
argument_list|,
name|FALSE
comment|/* show_hidden*/
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|dir
operator|=
name|path
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|!=
name|svn_node_unknown
condition|)
name|dir
operator|=
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
comment|/* Not a versioned item, probe it */
name|SVN_ERR
argument_list|(
name|probe
argument_list|(
name|associated
operator|->
name|db
argument_list|,
operator|&
name|dir
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc_adm_retrieve
argument_list|(
name|adm_access
argument_list|,
name|associated
argument_list|,
name|dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_NOT_LOCKED
condition|)
block|{
comment|/* We'll receive a NOT LOCKED error for various reasons,          including the reason we'll actually want to test for:          The path is a versioned directory, but missing, in which case          we want its parent's adm_access (which holds minimal data          on the child) */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|probe
argument_list|(
name|associated
operator|->
name|db
argument_list|,
operator|&
name|dir
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_adm_retrieve
argument_list|(
name|adm_access
argument_list|,
name|associated
argument_list|,
name|dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* SVN_DEPRECATED */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc_adm_probe_try3
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|adm_access
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
name|associated
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|write_lock
parameter_list|,
name|int
name|levels_to_lock
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc_adm_probe_retrieve
argument_list|(
name|adm_access
argument_list|,
name|associated
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* SVN_ERR_WC_NOT_LOCKED would mean there was no access baton for      path in associated, in which case we want to open an access      baton and add it to associated. */
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_NOT_LOCKED
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc_adm_probe_open3
argument_list|(
name|adm_access
argument_list|,
name|associated
argument_list|,
name|path
argument_list|,
name|write_lock
argument_list|,
name|levels_to_lock
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|svn_wc_adm_access_pool
argument_list|(
name|associated
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the path is not a versioned directory, we just return a          null access baton with no error.  Note that of the errors we          do report, the most important (and probably most likely) is          SVN_ERR_WC_LOCKED.  That error would mean that someone else          has this area locked, and we definitely want to bail in that          case. */
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_NOT_WORKING_COPY
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|adm_access
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|child_is_disjoint
parameter_list|(
name|svn_boolean_t
modifier|*
name|disjoint
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_switched
decl_stmt|;
comment|/* Check if the parent directory knows about this node */
name|SVN_ERR
argument_list|(
name|svn_wc__db_is_switched
argument_list|(
name|disjoint
argument_list|,
operator|&
name|is_switched
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|disjoint
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|is_switched
condition|)
operator|*
name|disjoint
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_anchor
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|anchor_access
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|target_access
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|target
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_boolean_t
name|db_provided
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|write_lock
parameter_list|,
name|int
name|levels_to_lock
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base_name
init|=
name|svn_dirent_basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* Any baton creation is going to need a shared structure for holding      data across the entire set. The caller isn't providing one, so we      do it here.  */
comment|/* ### we could maybe skip the shared struct for levels_to_lock==0, but      ### given that we need DB for format detection, may as well keep this.      ### in any case, much of this is going to be simplified soon anyways.  */
if|if
condition|(
operator|!
name|db_provided
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_open
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
argument_list|,
comment|/* ### config. need! */
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_empty
argument_list|(
name|path
argument_list|)
operator|||
name|svn_dirent_is_root
argument_list|(
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|base_name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|open_all
argument_list|(
name|anchor_access
argument_list|,
name|path
argument_list|,
name|db
argument_list|,
name|db_provided
argument_list|,
name|write_lock
argument_list|,
name|levels_to_lock
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|target_access
operator|=
operator|*
name|anchor_access
expr_stmt|;
operator|*
name|target
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_wc_adm_access_t
modifier|*
name|p_access
init|=
name|NULL
decl_stmt|;
name|svn_wc_adm_access_t
modifier|*
name|t_access
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent
init|=
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_error_t
modifier|*
name|p_access_err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to open parent of PATH to setup P_ACCESS */
name|err
operator|=
name|open_single
argument_list|(
operator|&
name|p_access
argument_list|,
name|parent
argument_list|,
name|write_lock
argument_list|,
name|db
argument_list|,
name|db_provided
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
specifier|const
name|char
modifier|*
name|abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_wc_adm_access_t
modifier|*
name|existing_adm
init|=
name|svn_wc__db_temp_get_access
argument_list|(
name|db
argument_list|,
name|abspath
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_MISSING
argument_list|(
name|existing_adm
argument_list|)
condition|)
name|svn_wc__db_temp_clear_access
argument_list|(
name|db
argument_list|,
name|abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR_ASSERT
argument_list|(
name|existing_adm
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_NOT_WORKING_COPY
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|p_access
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|write_lock
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_LOCKED
operator|||
name|APR_STATUS_IS_EACCES
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
comment|/* If P_ACCESS isn't to be returned then a read-only baton                  will do for now, but keep the error in case we need it. */
name|svn_error_t
modifier|*
name|err2
init|=
name|open_single
argument_list|(
operator|&
name|p_access
argument_list|,
name|parent
argument_list|,
name|FALSE
argument_list|,
name|db
argument_list|,
name|db_provided
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err2
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err2
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|p_access_err
operator|=
name|err
expr_stmt|;
block|}
else|else
return|return
name|err
return|;
block|}
comment|/* Try to open PATH to setup T_ACCESS */
name|err
operator|=
name|open_all
argument_list|(
operator|&
name|t_access
argument_list|,
name|path
argument_list|,
name|db
argument_list|,
name|db_provided
argument_list|,
name|write_lock
argument_list|,
name|levels_to_lock
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|p_access
operator|==
name|NULL
condition|)
block|{
comment|/* Couldn't open the parent or the target. Bail out.  */
name|svn_error_clear
argument_list|(
name|p_access_err
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_NOT_WORKING_COPY
condition|)
block|{
if|if
condition|(
name|p_access
condition|)
name|svn_error_clear
argument_list|(
name|svn_wc_adm_close2
argument_list|(
name|p_access
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|p_access_err
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* This directory is not under version control. Ignore it.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|t_access
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* At this stage might have P_ACCESS, T_ACCESS or both */
comment|/* Check for switched or disjoint P_ACCESS and T_ACCESS */
if|if
condition|(
name|p_access
operator|&&
name|t_access
condition|)
block|{
name|svn_boolean_t
name|disjoint
decl_stmt|;
name|err
operator|=
name|child_is_disjoint
argument_list|(
operator|&
name|disjoint
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|p_access_err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_wc_adm_close2
argument_list|(
name|p_access
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_wc_adm_close2
argument_list|(
name|t_access
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|disjoint
condition|)
block|{
comment|/* Switched or disjoint, so drop P_ACCESS. Don't close any                  descendents, or we might blast the child.  */
name|err
operator|=
name|close_single
argument_list|(
name|p_access
argument_list|,
name|FALSE
comment|/* preserve_lock */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|p_access_err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_wc_adm_close2
argument_list|(
name|t_access
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|p_access
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* We have a parent baton *and* we have an error related to opening          the baton. That means we have a readonly baton, but that isn't          going to work for us. (p_access would have been set to NULL if          a writable parent baton is not required)  */
if|if
condition|(
name|p_access
operator|&&
name|p_access_err
condition|)
block|{
if|if
condition|(
name|t_access
condition|)
name|svn_error_clear
argument_list|(
name|svn_wc_adm_close2
argument_list|(
name|t_access
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_wc_adm_close2
argument_list|(
name|p_access
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|p_access_err
argument_list|)
return|;
block|}
name|svn_error_clear
argument_list|(
name|p_access_err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t_access
condition|)
block|{
name|svn_boolean_t
name|available
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|err
operator|=
name|adm_available
argument_list|(
operator|&
name|available
argument_list|,
operator|&
name|kind
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_wc_adm_close2
argument_list|(
name|p_access
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
operator|*
name|anchor_access
operator|=
name|p_access
condition|?
name|p_access
else|:
name|t_access
expr_stmt|;
operator|*
name|target_access
operator|=
name|t_access
condition|?
name|t_access
else|:
name|p_access
expr_stmt|;
if|if
condition|(
operator|!
name|p_access
condition|)
operator|*
name|target
operator|=
literal|""
expr_stmt|;
else|else
operator|*
name|target
operator|=
name|base_name
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_adm_open_anchor
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|anchor_access
parameter_list|,
name|svn_wc_adm_access_t
modifier|*
modifier|*
name|target_access
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|write_lock
parameter_list|,
name|int
name|levels_to_lock
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|open_anchor
argument_list|(
name|anchor_access
argument_list|,
name|target_access
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|path
argument_list|,
name|write_lock
argument_list|,
name|levels_to_lock
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Does the work of closing the access baton ADM_ACCESS.  Any physical    locks are removed from the working copy if PRESERVE_LOCK is FALSE, or    are left if PRESERVE_LOCK is TRUE.  Any associated access batons that    are direct descendants will also be closed.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_close
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|,
name|svn_boolean_t
name|preserve_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_adm_access_t
modifier|*
name|look
decl_stmt|;
if|if
condition|(
name|adm_access
operator|->
name|closed
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If we are part of the shared set, then close descendant batons.  */
name|look
operator|=
name|get_from_shared
argument_list|(
name|adm_access
operator|->
name|abspath
argument_list|,
name|adm_access
operator|->
name|db
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|look
operator|!=
name|NULL
condition|)
block|{
name|apr_hash_t
modifier|*
name|opened
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Gather all the opened access batons from the DB.  */
name|opened
operator|=
name|svn_wc__db_temp_get_all_access
argument_list|(
name|adm_access
operator|->
name|db
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Close any that are descendents of this baton.  */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|opened
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_wc_adm_access_t
modifier|*
name|child
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|child
operator|->
name|path
decl_stmt|;
if|if
condition|(
name|IS_MISSING
argument_list|(
name|child
argument_list|)
condition|)
block|{
comment|/* We don't close the missing entry, but get rid of it from                  the set. */
name|svn_wc__db_temp_clear_access
argument_list|(
name|adm_access
operator|->
name|db
argument_list|,
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|svn_dirent_is_ancestor
argument_list|(
name|adm_access
operator|->
name|path
argument_list|,
name|path
argument_list|)
operator|||
name|strcmp
argument_list|(
name|adm_access
operator|->
name|path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|close_single
argument_list|(
name|child
argument_list|,
name|preserve_lock
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|close_single
argument_list|(
name|adm_access
argument_list|,
name|preserve_lock
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* SVN_DEPRECATED */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc_adm_close2
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|do_close
argument_list|(
name|adm_access
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* SVN_DEPRECATED */
end_comment

begin_function
name|svn_boolean_t
name|svn_wc_adm_locked
parameter_list|(
specifier|const
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|)
block|{
name|svn_boolean_t
name|locked
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|adm_access
operator|->
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_wc__db_wclock_owns_lock
argument_list|(
operator|&
name|locked
argument_list|,
name|adm_access
operator|->
name|db
argument_list|,
name|adm_access
operator|->
name|abspath
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* ### is this right? */
return|return
name|FALSE
return|;
block|}
return|return
name|locked
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__write_check
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|locked
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock
argument_list|(
operator|&
name|locked
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_LOCKED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No write-lock in '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_locked2
parameter_list|(
name|svn_boolean_t
modifier|*
name|locked_here
parameter_list|,
name|svn_boolean_t
modifier|*
name|locked
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_here
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock
argument_list|(
name|locked_here
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclocked
argument_list|(
name|locked
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* SVN_DEPRECATED */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|svn_wc_adm_access_path
parameter_list|(
specifier|const
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|)
block|{
return|return
name|adm_access
operator|->
name|path
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_wc__adm_access_abspath
parameter_list|(
specifier|const
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|)
block|{
return|return
name|adm_access
operator|->
name|abspath
return|;
block|}
end_function

begin_comment
comment|/* SVN_DEPRECATED */
end_comment

begin_function
name|apr_pool_t
modifier|*
name|svn_wc_adm_access_pool
parameter_list|(
specifier|const
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|)
block|{
return|return
name|adm_access
operator|->
name|pool
return|;
block|}
end_function

begin_function
name|apr_pool_t
modifier|*
name|svn_wc__adm_access_pool_internal
parameter_list|(
specifier|const
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|)
block|{
return|return
name|adm_access
operator|->
name|pool
return|;
block|}
end_function

begin_function
name|void
name|svn_wc__adm_access_set_entries
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|,
name|apr_hash_t
modifier|*
name|entries
parameter_list|)
block|{
name|adm_access
operator|->
name|entries_all
operator|=
name|entries
expr_stmt|;
block|}
end_function

begin_function
name|apr_hash_t
modifier|*
name|svn_wc__adm_access_entries
parameter_list|(
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|)
block|{
comment|/* Compile with -DSVN_DISABLE_ENTRY_CACHE to disable the in-memory      entry caching. As of 2010-03-18 (r924708) merge_tests 34 and 134      fail during "make check".  */
ifdef|#
directive|ifdef
name|SVN_DISABLE_ENTRY_CACHE
return|return
name|NULL
return|;
else|#
directive|else
return|return
name|adm_access
operator|->
name|entries_all
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_wc__db_t
modifier|*
name|svn_wc__adm_get_db
parameter_list|(
specifier|const
name|svn_wc_adm_access_t
modifier|*
name|adm_access
parameter_list|)
block|{
return|return
name|adm_access
operator|->
name|db
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__acquire_write_lock
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|lock_root_abspath
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|lock_anchor
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_t
modifier|*
name|db
init|=
name|wc_ctx
operator|->
name|db
decl_stmt|;
name|svn_boolean_t
name|is_wcroot
decl_stmt|;
name|svn_boolean_t
name|is_switched
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc__db_is_switched
argument_list|(
operator|&
name|is_wcroot
argument_list|,
operator|&
name|is_switched
argument_list|,
operator|&
name|kind
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|is_wcroot
operator|=
name|FALSE
expr_stmt|;
name|is_switched
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lock_root_abspath
operator|&&
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't obtain lock on non-directory '%s'."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|lock_anchor
operator|&&
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
name|is_wcroot
condition|)
name|lock_anchor
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|lock_anchor
condition|)
block|{
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|lock_root_abspath
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
operator|!
name|is_switched
condition|)
name|local_abspath
operator|=
name|parent_abspath
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
operator|&&
name|kind
operator|!=
name|svn_node_unknown
condition|)
block|{
comment|/* In the single-DB world we know parent exists */
name|local_abspath
operator|=
name|parent_abspath
expr_stmt|;
block|}
else|else
block|{
comment|/* Can't lock parents that don't exist */
name|svn_node_kind_t
name|parent_kind
decl_stmt|;
name|err
operator|=
name|svn_wc__db_read_kind
argument_list|(
operator|&
name|parent_kind
argument_list|,
name|db
argument_list|,
name|parent_abspath
argument_list|,
name|TRUE
comment|/* allow_missing */
argument_list|,
name|TRUE
comment|/* show_deleted */
argument_list|,
name|FALSE
comment|/* show_hidden */
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|SVN_WC__ERR_IS_NOT_CURRENT_WC
argument_list|(
name|err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|parent_kind
operator|=
name|svn_node_unknown
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|local_abspath
operator|=
name|parent_abspath
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
name|local_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock_root_abspath
condition|)
operator|*
name|lock_root_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_obtain
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
operator|-
literal|1
comment|/* levels_to_lock (infinite) */
argument_list|,
name|FALSE
comment|/* steal_lock */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__release_write_lock
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_uint64_t
name|id
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_fetch_next
argument_list|(
operator|&
name|id
argument_list|,
operator|&
name|work_item
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_item
condition|)
block|{
comment|/* Do not release locks (here or below) if there is work to do.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_release
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__call_with_write_lock
parameter_list|(
name|svn_wc__with_write_lock_func_t
name|func
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|lock_anchor
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err1
decl_stmt|,
modifier|*
name|err2
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_root_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__acquire_write_lock
argument_list|(
operator|&
name|lock_root_abspath
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|lock_anchor
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err1
operator|=
name|svn_error_trace
argument_list|(
name|func
argument_list|(
name|baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err2
operator|=
name|svn_wc__release_write_lock
argument_list|(
name|wc_ctx
argument_list|,
name|lock_root_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err1
argument_list|,
name|err2
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__acquire_write_lock_for_resolve
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|lock_root_abspath
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|locked
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|obtained_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|requested_abspath
init|=
name|local_abspath
decl_stmt|;
while|while
condition|(
operator|!
name|locked
condition|)
block|{
specifier|const
name|char
modifier|*
name|required_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|child
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__acquire_write_lock
argument_list|(
operator|&
name|obtained_abspath
argument_list|,
name|wc_ctx
argument_list|,
name|requested_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|locked
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__required_lock_for_resolve
argument_list|(
operator|&
name|required_abspath
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It's possible for the required lock path to be an ancestor          of, a descendent of, or equal to, the obtained lock path. If          it's an ancestor we have to try again, otherwise the obtained          lock will do. */
name|child
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|required_abspath
argument_list|,
name|obtained_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|&&
name|child
index|[
literal|0
index|]
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__release_write_lock
argument_list|(
name|wc_ctx
argument_list|,
name|obtained_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|locked
operator|=
name|FALSE
expr_stmt|;
name|requested_abspath
operator|=
name|required_abspath
expr_stmt|;
block|}
else|else
block|{
comment|/* required should be a descendent of, or equal to, obtained */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|strcmp
argument_list|(
name|required_abspath
argument_list|,
name|obtained_abspath
argument_list|)
operator|||
name|svn_dirent_skip_ancestor
argument_list|(
name|obtained_abspath
argument_list|,
name|required_abspath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|lock_root_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|obtained_abspath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

