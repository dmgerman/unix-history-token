begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * workqueue.c :  manipulating work queue items  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"wc_db.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_comment
comment|/* Workqueue operation names.  */
end_comment

begin_define
define|#
directive|define
name|OP_FILE_COMMIT
value|"file-commit"
end_define

begin_define
define|#
directive|define
name|OP_FILE_INSTALL
value|"file-install"
end_define

begin_define
define|#
directive|define
name|OP_FILE_REMOVE
value|"file-remove"
end_define

begin_define
define|#
directive|define
name|OP_FILE_MOVE
value|"file-move"
end_define

begin_define
define|#
directive|define
name|OP_FILE_COPY_TRANSLATED
value|"file-translate"
end_define

begin_define
define|#
directive|define
name|OP_SYNC_FILE_FLAGS
value|"sync-file-flags"
end_define

begin_define
define|#
directive|define
name|OP_PREJ_INSTALL
value|"prej-install"
end_define

begin_define
define|#
directive|define
name|OP_DIRECTORY_REMOVE
value|"dir-remove"
end_define

begin_define
define|#
directive|define
name|OP_DIRECTORY_INSTALL
value|"dir-install"
end_define

begin_define
define|#
directive|define
name|OP_POSTUPGRADE
value|"postupgrade"
end_define

begin_comment
comment|/* Legacy items */
end_comment

begin_define
define|#
directive|define
name|OP_BASE_REMOVE
value|"base-remove"
end_define

begin_define
define|#
directive|define
name|OP_RECORD_FILEINFO
value|"record-fileinfo"
end_define

begin_define
define|#
directive|define
name|OP_TMP_SET_TEXT_CONFLICT_MARKERS
value|"tmp-set-text-conflict-markers"
end_define

begin_define
define|#
directive|define
name|OP_TMP_SET_PROPERTY_CONFLICT_MARKER
value|"tmp-set-property-conflict-marker"
end_define

begin_comment
comment|/* For work queue debugging. Generates output about its operation.  */
end_comment

begin_comment
comment|/* #define SVN_DEBUG_WORK_QUEUE */
end_comment

begin_typedef
typedef|typedef
name|struct
name|work_item_baton_t
name|work_item_baton_t
typedef|;
end_typedef

begin_struct
struct|struct
name|work_item_dispatch
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward definition */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|get_and_record_fileinfo
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_REMOVE_BASE  */
end_comment

begin_comment
comment|/* Removes a BASE_NODE and all it's data, leaving any adds and copies as is.    Do this as a depth first traversal to make sure than any parent still exists    on error conditions.  */
end_comment

begin_comment
comment|/* Process the OP_REMOVE_BASE work item WORK_ITEM.  * See svn_wc__wq_build_remove_base() which generates this work item.  * Implements (struct work_item_dispatch).func. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_base_remove
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_revnum_t
name|not_present_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__parse_int
argument_list|(
operator|&
name|val
argument_list|,
name|arg1
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|->
name|next
operator|->
name|next
condition|)
block|{
name|not_present_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|val
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__parse_int
argument_list|(
operator|&
name|val
argument_list|,
name|arg1
operator|->
name|next
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_boolean_t
name|keep_not_present
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_WC__VERSION
operator|<=
literal|28
argument_list|)
expr_stmt|;
comment|/* Case unused in later versions*/
name|keep_not_present
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|keep_not_present
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|not_present_rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_remove
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* keep_as_working */
argument_list|,
name|TRUE
comment|/* queue_deletes */
argument_list|,
name|FALSE
comment|/* remove_locks */
argument_list|,
name|not_present_rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_FILE_COMMIT  */
end_comment

begin_comment
comment|/* FILE_ABSPATH is the new text base of the newly-committed versioned file,  * in repository-normal form (aka "detranslated" form).  Adjust the working  * file accordingly.  *  * If eol and/or keyword translation would cause the working file to  * change, then overwrite the working file with a translated copy of  * the new text base (but only if the translated copy differs from the  * current working file -- if they are the same, do nothing, to avoid  * clobbering timestamps unnecessarily).  *  * Set the working file's executability according to its svn:executable  * property.  *  * Set the working file's read-only attribute according to its properties  * and lock status (see svn_wc__maybe_set_read_only()).  *  * If the working file was re-translated or had its executability or  * read-only state changed,  * then set OVERWROTE_WORKING to TRUE.  If the working file isn't  * touched at all, then set to FALSE.  *  * Use SCRATCH_POOL for any temporary allocation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|install_committed_file
parameter_list|(
name|svn_boolean_t
modifier|*
name|overwrote_working
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|file_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|same
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_wfile
decl_stmt|;
name|svn_boolean_t
name|special
decl_stmt|;
comment|/* start off assuming that the working file isn't touched. */
operator|*
name|overwrote_working
operator|=
name|FALSE
expr_stmt|;
comment|/* In the commit, newlines and keywords may have been    * canonicalized and/or contracted... Or they may not have    * been.  It's kind of hard to know.  Here's how we find out:    *    *    1. Make a translated tmp copy of the committed text base,    *       translated according to the versioned file's properties.    *       Or, if no committed text base exists (the commit must have    *       been a propchange only), make a translated tmp copy of the    *       working file.    *    2. Compare the translated tmpfile to the working file.    *    3. If different, copy the tmpfile over working file.    *    * This means we only rewrite the working file if we absolutely    * have to, which is good because it avoids changing the file's    * timestamp unless necessary, so editors aren't tempted to    * reread the file if they don't really need to.    */
comment|/* Copy and translate the new base-to-be file (if found, else the working    * file) from repository-normal form to working form, writing a new    * temporary file if any translation was actually done.  Set TMP_WFILE to    * the translated file's path, which may be the source file's path if no    * translation was done.  Set SAME to indicate whether the new working    * text is the same as the old working text (or TRUE if it's a special    * file). */
block|{
specifier|const
name|char
modifier|*
name|tmp
init|=
name|file_abspath
decl_stmt|;
comment|/* Copy and translate, if necessary. The output file will be deleted at      * scratch_pool cleanup.      * ### That's not quite safe: we might rename the file and then maybe      * its path will get re-used for another temp file before pool clean-up.      * Instead, we should take responsibility for deleting it. */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_translated_file
argument_list|(
operator|&
name|tmp_wfile
argument_list|,
name|tmp
argument_list|,
name|db
argument_list|,
name|file_abspath
argument_list|,
name|SVN_WC_TRANSLATE_FROM_NF
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the translation is a no-op, the text base and the working copy      * file contain the same content, because we use the same props here      * as were used to detranslate from working file to text base.      *      * In that case: don't replace the working file, but make sure      * it has the right executable and read_write attributes set.      */
name|SVN_ERR
argument_list|(
name|svn_wc__get_translate_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|special
argument_list|,
name|db
argument_list|,
name|file_abspath
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Translated file returns the exact pointer if not translated. */
if|if
condition|(
operator|!
name|special
operator|&&
name|tmp
operator|!=
name|tmp_wfile
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_files_contents_same_p
argument_list|(
operator|&
name|same
argument_list|,
name|tmp_wfile
argument_list|,
name|file_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|same
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|same
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|tmp_wfile
argument_list|,
name|file_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|overwrote_working
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* ### should be using OP_SYNC_FILE_FLAGS, or an internal version of      ### that here. do we need to set *OVERWROTE_WORKING? */
comment|/* ### Re: OVERWROTE_WORKING, the following function is rather liberal      ### with setting that flag, so we should probably decide if we really      ### care about it when syncing flags. */
name|SVN_ERR
argument_list|(
name|svn_wc__sync_flags_with_props
argument_list|(
name|overwrote_working
argument_list|,
name|db
argument_list|,
name|file_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|process_commit_file_install
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|overwrote_working
decl_stmt|;
comment|/* Install the new file, which may involve expanding keywords.      A copy of this file should have been dropped into our `tmp/text-base'      directory during the commit process.  Part of this process      involves recording the textual timestamp for this entry.  We'd like      to just use the timestamp of the working file, but it is possible      that at some point during the commit, the real working file might      have changed again.    */
name|SVN_ERR
argument_list|(
name|install_committed_file
argument_list|(
operator|&
name|overwrote_working
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We will compute and modify the size and timestamp */
if|if
condition|(
name|overwrote_working
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|local_abspath
argument_list|,
name|APR_FINFO_MIN
operator||
name|APR_FINFO_LINK
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_global_record_fileinfo
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|finfo
operator|.
name|size
argument_list|,
name|finfo
operator|.
name|mtime
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_boolean_t
name|modified
decl_stmt|;
comment|/* The working copy file hasn't been overwritten.  We just          removed the recorded size and modification time from the nodes          record by calling svn_wc__db_global_commit().           Now we have some file in our working copy that might be what          we just committed, but we are not certain at this point.           We still have a write lock here, so we check if the file is          what we expect it to be and if it is the right file we update          the recorded information. (If it isn't we keep the null data).           Instead of reimplementing all this here, we just call a function          that already does implement this when it notices that we have the          right kind of lock (and we ignore the result)        */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_file_modified_p
argument_list|(
operator|&
name|modified
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_file_commit
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't both parsing the other two values in the skel. */
return|return
name|svn_error_trace
argument_list|(
name|process_commit_file_install
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_file_commit
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|props_mod
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_FILE_COMMIT
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_POSTUPGRADE  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_postupgrade
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|entries_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|adm_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_path
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc__wipe_postupgrade
argument_list|(
name|wri_abspath
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ENTRY_NOT_FOUND
condition|)
comment|/* No entry, this can happen when the wq item is rerun. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|adm_path
operator|=
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|entries_path
operator|=
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|SVN_WC__ADM_ENTRIES
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|format_path
operator|=
name|svn_wc__adm_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|SVN_WC__ADM_FORMAT
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Write the 'format' and 'entries' files.       ### The order may matter for some sufficiently old clients.. but      ### this code only runs during upgrade after the files had been      ### removed earlier during the upgrade. */
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|temp_path
argument_list|,
name|adm_path
argument_list|,
name|SVN_WC__NON_ENTRIES_STRING
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_WC__NON_ENTRIES_STRING
argument_list|)
operator|-
literal|1
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|temp_path
argument_list|,
name|format_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|temp_path
argument_list|,
name|adm_path
argument_list|,
name|SVN_WC__NON_ENTRIES_STRING
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_WC__NON_ENTRIES_STRING
argument_list|)
operator|-
literal|1
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|temp_path
argument_list|,
name|entries_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_postupgrade
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_POSTUPGRADE
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_FILE_INSTALL */
end_comment

begin_comment
comment|/* Process the OP_FILE_INSTALL work item WORK_ITEM.  * See svn_wc__wq_build_file_install() which generates this work item.  * Implements (struct work_item_dispatch).func. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_file_install
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|arg4
init|=
name|arg1
operator|->
name|next
operator|->
name|next
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_boolean_t
name|use_commit_times
decl_stmt|;
name|svn_boolean_t
name|record_fileinfo
decl_stmt|;
name|svn_boolean_t
name|special
decl_stmt|;
name|svn_stream_t
modifier|*
name|src_stream
decl_stmt|;
name|svn_subst_eol_style_t
name|style
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
name|apr_hash_t
modifier|*
name|keywords
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_dir_abspath
decl_stmt|;
name|svn_stream_t
modifier|*
name|dst_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_abspath
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_abspath
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_time_t
name|changed_date
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__parse_int
argument_list|(
operator|&
name|val
argument_list|,
name|arg1
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|use_commit_times
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__parse_int
argument_list|(
operator|&
name|val
argument_list|,
name|arg1
operator|->
name|next
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|record_fileinfo
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_node_install_info
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
operator|&
name|checksum
argument_list|,
operator|&
name|props
argument_list|,
operator|&
name|changed_date
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg4
operator|!=
name|NULL
condition|)
block|{
comment|/* Use the provided path for the source.  */
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg4
operator|->
name|data
argument_list|,
name|arg4
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|source_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|checksum
condition|)
block|{
comment|/* This error replaces a previous assertion. Reporting an error from here          leaves the workingqueue operation in place, so the working copy is          still broken!           But when we report this error the user at least knows what node has          this specific problem, so maybe we can find out why users see this          error */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT_TEXT_BASE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't install '%s' from pristine store, "
literal|"because no checksum is recorded for this "
literal|"file"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_future_path
argument_list|(
operator|&
name|source_abspath
argument_list|,
name|wcroot_abspath
argument_list|,
name|checksum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|src_stream
argument_list|,
name|source_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch all the translation bits.  */
name|SVN_ERR
argument_list|(
name|svn_wc__get_translate_info
argument_list|(
operator|&
name|style
argument_list|,
operator|&
name|eol
argument_list|,
operator|&
name|keywords
argument_list|,
operator|&
name|special
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|props
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|special
condition|)
block|{
comment|/* When this stream is closed, the resulting special file will          atomically be created/moved into place at LOCAL_ABSPATH.  */
name|SVN_ERR
argument_list|(
name|svn_subst_create_specialfile
argument_list|(
operator|&
name|dst_stream
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the "repository normal" form of the special file into the          special stream.  */
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|src_stream
argument_list|,
name|dst_stream
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No need to set exec or read-only flags on special files.  */
comment|/* ### Shouldn't this record a timestamp and size, etc.? */
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|svn_subst_translation_required
argument_list|(
name|style
argument_list|,
name|eol
argument_list|,
name|keywords
argument_list|,
name|FALSE
comment|/* special */
argument_list|,
name|TRUE
comment|/* force_eol_check */
argument_list|)
condition|)
block|{
comment|/* Wrap it in a translating (expanding) stream.  */
name|src_stream
operator|=
name|svn_subst_stream_translated
argument_list|(
name|src_stream
argument_list|,
name|eol
argument_list|,
name|TRUE
comment|/* repair */
argument_list|,
name|keywords
argument_list|,
name|TRUE
comment|/* expand */
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Where is the Right Place to put a temp file in this working copy?  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|temp_dir_abspath
argument_list|,
name|db
argument_list|,
name|wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Translate to a temporary file. We don't want the user seeing a partial      file, nor let them muck with it while we translate. We may also need to      get its TRANSLATED_SIZE before the user can monkey it.  */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|dst_stream
argument_list|,
operator|&
name|dst_abspath
argument_list|,
name|temp_dir_abspath
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy from the source to the dest, translating as we go. This will also      close both streams.  */
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|src_stream
argument_list|,
name|dst_stream
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All done. Move the file into place.  */
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_io_file_rename
argument_list|(
name|dst_abspath
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* With a single db we might want to install files in a missing directory.        Simply trying this scenario on error won't do any harm and at least        one user reported this problem on IRC. */
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|err2
operator|=
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
comment|/* Creating directory didn't work: Return all errors */
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
argument_list|)
return|;
else|else
comment|/* We could create a directory: retry install */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|dst_abspath
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* Tweak the on-disk file according to its properties.  */
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|props
operator|&&
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_executable
argument_list|(
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note that this explicitly checks the pristine properties, to make sure      that when the lock is locally set (=modification) it is not read only */
if|if
condition|(
name|props
operator|&&
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_NEEDS_LOCK
argument_list|)
condition|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_wc__db_lock_t
modifier|*
name|lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|lock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|&&
name|status
operator|!=
name|svn_wc__db_status_added
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_commit_times
condition|)
block|{
if|if
condition|(
name|changed_date
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_affected_time
argument_list|(
name|changed_date
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### this should happen before we rename the file into place.  */
if|if
condition|(
name|record_fileinfo
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_and_record_fileinfo
argument_list|(
name|wqb
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* ignore_enoent */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_file_install
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|source_abspath
parameter_list|,
name|svn_boolean_t
name|use_commit_times
parameter_list|,
name|svn_boolean_t
name|record_fileinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|wri_abspath
decl_stmt|;
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Use the directory of the file to install as wri_abspath to avoid      filestats on just obtaining the wc-root */
name|wri_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If a SOURCE_ABSPATH was provided, then put it into the skel. If this      value is not provided, then the file's pristine contents will be used. */
if|if
condition|(
name|source_abspath
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|source_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_int
argument_list|(
name|record_fileinfo
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_int
argument_list|(
name|use_commit_times
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_FILE_INSTALL
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_FILE_REMOVE  */
end_comment

begin_comment
comment|/* Process the OP_FILE_REMOVE work item WORK_ITEM.  * See svn_wc__wq_build_file_remove() which generates this work item.  * Implements (struct work_item_dispatch).func. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_file_remove
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the path, no worrying if it isn't there.  */
return|return
name|svn_error_trace
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_file_remove
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_FILE_REMOVE
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_DIRECTORY_REMOVE  */
end_comment

begin_comment
comment|/* Process the OP_FILE_REMOVE work item WORK_ITEM.  * See svn_wc__wq_build_file_remove() which generates this work item.  * Implements (struct work_item_dispatch).func. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_dir_remove
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_boolean_t
name|recursive
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|recursive
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|arg1
operator|->
name|next
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__parse_int
argument_list|(
operator|&
name|val
argument_list|,
name|arg1
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|recursive
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* Remove the path, no worrying if it isn't there.  */
if|if
condition|(
name|recursive
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
else|else
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_io_dir_remove_nonrecursive
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|APR_STATUS_IS_ENOTEMPTY
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_dir_remove
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|recursive
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
condition|)
name|svn_skel__prepend_int
argument_list|(
name|TRUE
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_DIRECTORY_REMOVE
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_FILE_MOVE  */
end_comment

begin_comment
comment|/* Process the OP_FILE_MOVE work item WORK_ITEM.  * See svn_wc__wq_build_file_move() which generates this work item.  * Implements (struct work_item_dispatch).func. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_file_move
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_abspath
decl_stmt|,
modifier|*
name|dst_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|src_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|next
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|dst_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use svn_io_file_move() instead of svn_io_file_rename() to allow cross      device copies. We should not fail in the workqueue. */
name|err
operator|=
name|svn_io_file_move
argument_list|(
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If the source is not found, we assume the wq op is already handled */
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_file_move
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|src_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|wri_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|src_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|dst_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* File must exist */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' not found"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|src_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_FILE_MOVE
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_FILE_COPY_TRANSLATED */
end_comment

begin_comment
comment|/* Process the OP_FILE_COPY_TRANSLATED work item WORK_ITEM.  * See run_file_copy_translated() which generates this work item.  * Implements (struct work_item_dispatch).func. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_file_copy_translated
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|,
modifier|*
name|src_abspath
decl_stmt|,
modifier|*
name|dst_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
name|svn_subst_eol_style_t
name|style
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
name|apr_hash_t
modifier|*
name|keywords
decl_stmt|;
name|svn_boolean_t
name|special
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|next
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|src_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|dst_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_translate_info
argument_list|(
operator|&
name|style
argument_list|,
operator|&
name|eol
argument_list|,
operator|&
name|keywords
argument_list|,
operator|&
name|special
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_copy_and_translate4
argument_list|(
name|src_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|eol
argument_list|,
name|TRUE
comment|/* repair */
argument_list|,
name|keywords
argument_list|,
name|TRUE
comment|/* expand */
argument_list|,
name|special
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_file_copy_translated
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|src_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|src_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|dst_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* File must exist */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' not found"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|dst_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|src_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_FILE_COPY_TRANSLATED
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_DIRECTORY_INSTALL  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_dir_install
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__ensure_directory
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_dir_install
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_DIRECTORY_INSTALL
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_SYNC_FILE_FLAGS  */
end_comment

begin_comment
comment|/* Process the OP_SYNC_FILE_FLAGS work item WORK_ITEM.  * See svn_wc__wq_build_sync_file_flags() which generates this work item.  * Implements (struct work_item_dispatch).func. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_sync_file_flags
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__sync_flags_with_props
argument_list|(
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_sync_file_flags
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_SYNC_FILE_FLAGS
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_PREJ_INSTALL  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_prej_install
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflicts
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|prop_conflict_skel
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_prejfile_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|prejfile_abspath
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
operator|&
name|prejfile_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|->
name|next
operator|!=
name|NULL
condition|)
name|prop_conflict_skel
operator|=
name|arg1
operator|->
name|next
expr_stmt|;
else|else
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* ### wc_db can't provide it ... yet.  */
comment|/* Construct a property reject file in the temporary area.  */
name|SVN_ERR
argument_list|(
name|svn_wc__create_prejfile
argument_list|(
operator|&
name|tmp_prejfile_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|prop_conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... and atomically move it into place.  */
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|tmp_prejfile_abspath
argument_list|,
name|prejfile_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_build_prej_install
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
operator|*
name|work_item
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* ### gotta have this, today  */
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_skel
operator|!=
name|NULL
condition|)
name|svn_skel__prepend
argument_list|(
name|conflict_skel
argument_list|,
operator|*
name|work_item
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|local_relpath
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|OP_PREJ_INSTALL
argument_list|,
operator|*
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_RECORD_FILEINFO  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_record_fileinfo
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg1
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|apr_time_t
name|set_time
init|=
literal|0
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg1
operator|->
name|data
argument_list|,
name|arg1
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|->
name|next
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__parse_int
argument_list|(
operator|&
name|val
argument_list|,
name|arg1
operator|->
name|next
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|set_time
operator|=
operator|(
name|apr_time_t
operator|)
name|val
expr_stmt|;
block|}
if|if
condition|(
name|set_time
operator|!=
literal|0
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|is_special
decl_stmt|;
comment|/* Do not set the timestamp on special files. */
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|is_special
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't set affected time when local_abspath does not exist or is          a special file */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|&&
operator|!
name|is_special
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_affected_time
argument_list|(
name|set_time
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that we can't use the value we get here for recording as the          filesystem might have a different timestamp granularity */
block|}
return|return
name|svn_error_trace
argument_list|(
name|get_and_record_fileinfo
argument_list|(
name|wqb
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
comment|/* ignore_enoent */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_TMP_SET_TEXT_CONFLICT_MARKERS  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_set_text_conflict_markers
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_abspath
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_abspath
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|wrk_abspath
init|=
name|NULL
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg
operator|->
name|data
argument_list|,
name|arg
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|arg
operator|->
name|next
expr_stmt|;
name|local_relpath
operator|=
name|arg
operator|->
name|len
condition|?
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg
operator|->
name|data
argument_list|,
name|arg
operator|->
name|len
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|local_relpath
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|old_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|arg
operator|->
name|next
expr_stmt|;
name|local_relpath
operator|=
name|arg
operator|->
name|len
condition|?
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg
operator|->
name|data
argument_list|,
name|arg
operator|->
name|len
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|local_relpath
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|new_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|arg
operator|->
name|next
expr_stmt|;
name|local_relpath
operator|=
name|arg
operator|->
name|len
condition|?
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg
operator|->
name|data
argument_list|,
name|arg
operator|->
name|len
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|local_relpath
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|wrk_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Upgrade scenario: We have a workqueue item that describes how to install a      non skel conflict. Fetch all the information we can to create a new style      conflict. */
comment|/* ### Before format 30 this is/was a common code path as we didn't install      ### the conflict directly in the db. It just calls the wc_db code      ### to set the right fields. */
block|{
comment|/* Check if we should combine with a property conflict... */
name|svn_skel_t
modifier|*
name|conflicts
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflicts
condition|)
block|{
comment|/* No conflict exists, create a basic skel */
name|conflicts
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_update
argument_list|(
name|conflicts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the text conflict to the existing onflict */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_text_conflict
argument_list|(
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|wrk_abspath
argument_list|,
name|old_abspath
argument_list|,
name|new_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_conflict
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* OP_TMP_SET_PROPERTY_CONFLICT_MARKER  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_set_property_conflict_marker
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|arg
init|=
name|work_item
operator|->
name|children
operator|->
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|prej_abspath
init|=
name|NULL
decl_stmt|;
name|local_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg
operator|->
name|data
argument_list|,
name|arg
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|arg
operator|->
name|next
expr_stmt|;
name|local_relpath
operator|=
name|arg
operator|->
name|len
condition|?
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|arg
operator|->
name|data
argument_list|,
name|arg
operator|->
name|len
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|local_relpath
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|prej_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* Check if we should combine with a text conflict... */
name|svn_skel_t
modifier|*
name|conflicts
decl_stmt|;
name|apr_hash_t
modifier|*
name|prop_names
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflicts
condition|)
block|{
comment|/* No conflict exists, create a basic skel */
name|conflicts
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_update
argument_list|(
name|conflicts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prop_names
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_prop_conflict
argument_list|(
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|prej_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|prop_names
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_conflict
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|work_item_dispatch
name|dispatch_table
index|[]
init|=
block|{
block|{
name|OP_FILE_COMMIT
block|,
name|run_file_commit
block|}
block|,
block|{
name|OP_FILE_INSTALL
block|,
name|run_file_install
block|}
block|,
block|{
name|OP_FILE_REMOVE
block|,
name|run_file_remove
block|}
block|,
block|{
name|OP_FILE_MOVE
block|,
name|run_file_move
block|}
block|,
block|{
name|OP_FILE_COPY_TRANSLATED
block|,
name|run_file_copy_translated
block|}
block|,
block|{
name|OP_SYNC_FILE_FLAGS
block|,
name|run_sync_file_flags
block|}
block|,
block|{
name|OP_PREJ_INSTALL
block|,
name|run_prej_install
block|}
block|,
block|{
name|OP_DIRECTORY_REMOVE
block|,
name|run_dir_remove
block|}
block|,
block|{
name|OP_DIRECTORY_INSTALL
block|,
name|run_dir_install
block|}
block|,
comment|/* Upgrade steps */
block|{
name|OP_POSTUPGRADE
block|,
name|run_postupgrade
block|}
block|,
comment|/* Legacy workqueue items. No longer created */
block|{
name|OP_BASE_REMOVE
block|,
name|run_base_remove
block|}
block|,
block|{
name|OP_RECORD_FILEINFO
block|,
name|run_record_fileinfo
block|}
block|,
block|{
name|OP_TMP_SET_TEXT_CONFLICT_MARKERS
block|,
name|run_set_text_conflict_markers
block|}
block|,
block|{
name|OP_TMP_SET_PROPERTY_CONFLICT_MARKER
block|,
name|run_set_property_conflict_marker
block|}
block|,
comment|/* Sentinel.  */
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|work_item_baton_t
block|{
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
comment|/* Pool to allocate result in */
name|svn_boolean_t
name|used
decl_stmt|;
comment|/* needs reset */
name|apr_hash_t
modifier|*
name|record_map
decl_stmt|;
comment|/* const char * -> svn_io_dirent2_t map */
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dispatch_work_item
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|struct
name|work_item_dispatch
modifier|*
name|scan
decl_stmt|;
comment|/* Scan the dispatch table for a function to handle this work item.  */
for|for
control|(
name|scan
operator|=
operator|&
name|dispatch_table
index|[
literal|0
index|]
init|;
name|scan
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|scan
control|)
block|{
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|work_item
operator|->
name|children
argument_list|,
name|scan
operator|->
name|name
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SVN_DEBUG_WORK_QUEUE
name|SVN_DBG
argument_list|(
operator|(
literal|"dispatch: operation='%s'\n"
operator|,
name|scan
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|scan
operator|->
name|func
call|)
argument_list|(
name|wqb
argument_list|,
name|db
argument_list|,
name|work_item
argument_list|,
name|wri_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_RUN_WORK_QUEUE_TWICE
ifdef|#
directive|ifdef
name|SVN_DEBUG_WORK_QUEUE
name|SVN_DBG
argument_list|(
operator|(
literal|"dispatch: operation='%s'\n"
operator|,
name|scan
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Being able to run every workqueue item twice is one              requirement for workqueues to be restartable. */
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|scan
operator|->
name|func
call|)
argument_list|(
name|db
argument_list|,
name|work_item
argument_list|,
name|wri_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
name|scan
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* We should know about ALL possible work items here. If we do not,          then something is wrong. Most likely, some kind of format/code          skew. There is nothing more we can do. Erasing or ignoring this          work item could leave the WC in an even more broken state.           Contrary to issue #1581, we cannot simply remove work items and          continue, so bail out with an error.  */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_BAD_ADM_LOG
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unrecognized work item in the queue"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__wq_run
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_uint64_t
name|last_id
init|=
literal|0
decl_stmt|;
name|work_item_baton_t
name|wib
init|=
block|{
literal|0
block|}
decl_stmt|;
name|wib
operator|.
name|result_pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_DEBUG_WORK_QUEUE
name|SVN_DBG
argument_list|(
operator|(
literal|"wq_run: wri='%s'\n"
operator|,
name|wri_abspath
operator|)
argument_list|)
expr_stmt|;
block|{
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|count_env_var
init|=
name|getenv
argument_list|(
literal|"SVN_DEBUG_WORK_QUEUE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|count_env_var
operator|&&
operator|++
name|count
operator|==
name|atoi
argument_list|(
name|count_env_var
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CANCELLED
argument_list|,
name|NULL
argument_list|,
literal|"fake cancel"
argument_list|)
return|;
block|}
endif|#
directive|endif
while|while
condition|(
name|TRUE
condition|)
block|{
name|apr_uint64_t
name|id
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wib
operator|.
name|used
condition|)
block|{
comment|/* Make sure to do this *early* in the loop iteration. There may              be a LAST_ID that needs to be marked as completed, *before* we              start worrying about anything else.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_fetch_next
argument_list|(
operator|&
name|id
argument_list|,
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|last_id
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure to do this *early* in the loop iteration. There may              be a LAST_ID that needs to be marked as completed, *before* we              start worrying about anything else.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_record_and_fetch_next
argument_list|(
operator|&
name|id
argument_list|,
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|last_id
argument_list|,
name|wib
operator|.
name|record_map
argument_list|,
name|iterpool
argument_list|,
name|wib
operator|.
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|wib
operator|.
name|result_pool
argument_list|)
expr_stmt|;
name|wib
operator|.
name|record_map
operator|=
name|NULL
expr_stmt|;
name|wib
operator|.
name|used
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Stop work queue processing, if requested. A future 'svn cleanup'          should be able to continue the processing. Note that we may          have WORK_ITEM, but we'll just skip its processing for now.  */
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a WORK_ITEM, then process the sucker. Otherwise,          we're done.  */
if|if
condition|(
name|work_item
operator|==
name|NULL
condition|)
break|break;
name|err
operator|=
name|dispatch_work_item
argument_list|(
operator|&
name|wib
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|work_item
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
specifier|const
name|char
modifier|*
name|skel
init|=
name|svn_skel__unparse
argument_list|(
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_BAD_ADM_LOG
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Failed to run the WC DB work queue "
literal|"associated with '%s', work item %d %s"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|id
argument_list|,
name|skel
argument_list|)
return|;
block|}
comment|/* The work item finished without error. Mark it completed          in the next loop.  */
name|last_id
operator|=
name|id
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_skel_t
modifier|*
name|svn_wc__wq_merge
parameter_list|(
name|svn_skel_t
modifier|*
name|work_item1
parameter_list|,
name|svn_skel_t
modifier|*
name|work_item2
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* If either argument is NULL, then just return the other.  */
if|if
condition|(
name|work_item1
operator|==
name|NULL
condition|)
return|return
name|work_item2
return|;
if|if
condition|(
name|work_item2
operator|==
name|NULL
condition|)
return|return
name|work_item1
return|;
comment|/* We have two items. Figure out how to join them.  */
if|if
condition|(
name|SVN_WC__SINGLE_WORK_ITEM
argument_list|(
name|work_item1
argument_list|)
condition|)
block|{
if|if
condition|(
name|SVN_WC__SINGLE_WORK_ITEM
argument_list|(
name|work_item2
argument_list|)
condition|)
block|{
comment|/* Both are singular work items. Construct a list, then put              both work items into it (in the proper order).  */
name|svn_skel_t
modifier|*
name|result
init|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_skel__prepend
argument_list|(
name|work_item2
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|work_item1
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* WORK_ITEM2 is a list of work items. We can simply shove WORK_ITEM1          in the front to keep the ordering.  */
name|svn_skel__prepend
argument_list|(
name|work_item1
argument_list|,
name|work_item2
argument_list|)
expr_stmt|;
return|return
name|work_item2
return|;
block|}
comment|/* WORK_ITEM1 is a list of work items.  */
if|if
condition|(
name|SVN_WC__SINGLE_WORK_ITEM
argument_list|(
name|work_item2
argument_list|)
condition|)
block|{
comment|/* Put WORK_ITEM2 onto the end of the WORK_ITEM1 list.  */
name|svn_skel__append
argument_list|(
name|work_item1
argument_list|,
name|work_item2
argument_list|)
expr_stmt|;
return|return
name|work_item1
return|;
block|}
comment|/* We have two lists of work items. We need to chain all of the work      items into one big list. We will leave behind the WORK_ITEM2 skel,      as we only want its children.  */
name|svn_skel__append
argument_list|(
name|work_item1
argument_list|,
name|work_item2
operator|->
name|children
argument_list|)
expr_stmt|;
return|return
name|work_item1
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_and_record_fileinfo
parameter_list|(
name|work_item_baton_t
modifier|*
name|wqb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|dirent
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|ignore_enoent
argument_list|,
name|wqb
operator|->
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|wqb
operator|->
name|used
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|wqb
operator|->
name|record_map
condition|)
name|wqb
operator|->
name|record_map
operator|=
name|apr_hash_make
argument_list|(
name|wqb
operator|->
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|wqb
operator|->
name|record_map
argument_list|,
name|apr_pstrdup
argument_list|(
name|wqb
operator|->
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|dirent
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

