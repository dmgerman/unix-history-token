begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * @copyright  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  * @endcopyright  */
end_comment

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_escape
end_escape

begin_function
name|svn_wc_info_t
modifier|*
name|svn_wc_info_dup
parameter_list|(
specifier|const
name|svn_wc_info_t
modifier|*
name|info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_info_t
modifier|*
name|new_info
init|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_info
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|changelist
condition|)
name|new_info
operator|->
name|changelist
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|info
operator|->
name|changelist
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|info
operator|->
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|conflicts
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|new_conflicts
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|info
operator|->
name|conflicts
operator|->
name|nelts
argument_list|,
name|info
operator|->
name|conflicts
operator|->
name|elt_size
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|conflicts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|new_conflicts
argument_list|,
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
operator|=
name|svn_wc__conflict_description2_dup
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|info
operator|->
name|conflicts
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|new_info
operator|->
name|conflicts
operator|=
name|new_conflicts
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|copyfrom_url
condition|)
name|new_info
operator|->
name|copyfrom_url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|info
operator|->
name|copyfrom_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|wcroot_abspath
condition|)
name|new_info
operator|->
name|wcroot_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|info
operator|->
name|wcroot_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|moved_from_abspath
condition|)
name|new_info
operator|->
name|moved_from_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|info
operator|->
name|moved_from_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|moved_to_abspath
condition|)
name|new_info
operator|->
name|moved_to_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|info
operator|->
name|moved_to_abspath
argument_list|)
expr_stmt|;
return|return
name|new_info
return|;
block|}
end_function

begin_comment
comment|/* Set *INFO to a new struct, allocated in RESULT_POOL, built from the WC    metadata of LOCAL_ABSPATH.  Pointer fields are copied by reference, not    dup'd. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|build_info_for_node
parameter_list|(
name|svn_wc__info2_t
modifier|*
modifier|*
name|info
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__info2_t
modifier|*
name|tmpinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|db_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_uuid
decl_stmt|;
name|svn_revnum_t
name|original_revision
decl_stmt|;
name|svn_wc__db_lock_t
modifier|*
name|lock
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_boolean_t
name|op_root
decl_stmt|;
name|svn_boolean_t
name|have_base
decl_stmt|;
name|svn_boolean_t
name|have_more_work
decl_stmt|;
name|svn_wc_info_t
modifier|*
name|wc_info
decl_stmt|;
name|tmpinfo
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmpinfo
argument_list|)
argument_list|)
expr_stmt|;
name|tmpinfo
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|wc_info
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wc_info
argument_list|)
argument_list|)
expr_stmt|;
name|tmpinfo
operator|->
name|wc_info
operator|=
name|wc_info
expr_stmt|;
name|wc_info
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|db_kind
argument_list|,
operator|&
name|tmpinfo
operator|->
name|rev
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_root_URL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_UUID
argument_list|,
operator|&
name|tmpinfo
operator|->
name|last_changed_rev
argument_list|,
operator|&
name|tmpinfo
operator|->
name|last_changed_date
argument_list|,
operator|&
name|tmpinfo
operator|->
name|last_changed_author
argument_list|,
operator|&
name|wc_info
operator|->
name|depth
argument_list|,
operator|&
name|wc_info
operator|->
name|checksum
argument_list|,
name|NULL
argument_list|,
operator|&
name|original_repos_relpath
argument_list|,
operator|&
name|original_repos_root_url
argument_list|,
operator|&
name|original_uuid
argument_list|,
operator|&
name|original_revision
argument_list|,
operator|&
name|lock
argument_list|,
operator|&
name|wc_info
operator|->
name|recorded_size
argument_list|,
operator|&
name|wc_info
operator|->
name|recorded_time
argument_list|,
operator|&
name|wc_info
operator|->
name|changelist
argument_list|,
operator|&
name|conflicted
argument_list|,
operator|&
name|op_root
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|have_base
argument_list|,
operator|&
name|have_more_work
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|original_repos_root_url
operator|!=
name|NULL
condition|)
block|{
name|tmpinfo
operator|->
name|repos_root_URL
operator|=
name|original_repos_root_url
expr_stmt|;
name|tmpinfo
operator|->
name|repos_UUID
operator|=
name|original_uuid
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_added
condition|)
block|{
comment|/* ### We should also just be fetching the true BASE revision          ### here, which means copied items would also not have a          ### revision to display.  But WC-1 wants to show the revision of          ### copy targets as the copyfrom-rev.  *sigh* */
if|if
condition|(
name|original_repos_relpath
condition|)
block|{
comment|/* Root or child of copy */
name|tmpinfo
operator|->
name|rev
operator|=
name|original_revision
expr_stmt|;
name|repos_relpath
operator|=
name|original_repos_relpath
expr_stmt|;
if|if
condition|(
name|op_root
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|wc_info
operator|->
name|copyfrom_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|tmpinfo
operator|->
name|repos_root_URL
argument_list|,
name|original_repos_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|wc_info
operator|->
name|copyfrom_rev
operator|=
name|original_revision
expr_stmt|;
name|err
operator|=
name|svn_wc__db_scan_moved
argument_list|(
operator|&
name|wc_info
operator|->
name|moved_from_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|wc_info
operator|->
name|moved_from_abspath
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|op_root
condition|)
block|{
comment|/* Local addition */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_root_URL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_UUID
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_base
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Child of copy. ### Not WC-NG like */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_get_origin
argument_list|(
name|NULL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|rev
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_root_URL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_UUID
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### We should be able to avoid both these calls with the information          from read_info() in most cases */
if|if
condition|(
operator|!
name|op_root
condition|)
name|wc_info
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|have_more_work
operator|&&
operator|!
name|have_base
condition|)
name|wc_info
operator|->
name|schedule
operator|=
name|svn_wc_schedule_add
expr_stmt|;
else|else
block|{
name|svn_wc__db_status_t
name|below_working
decl_stmt|;
name|svn_boolean_t
name|have_work
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_info_below_working
argument_list|(
operator|&
name|have_base
argument_list|,
operator|&
name|have_work
argument_list|,
operator|&
name|below_working
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the node is not present or deleted (read: not present              in working), then the node is not a replacement */
if|if
condition|(
name|below_working
operator|!=
name|svn_wc__db_status_not_present
operator|&&
name|below_working
operator|!=
name|svn_wc__db_status_deleted
condition|)
block|{
name|wc_info
operator|->
name|schedule
operator|=
name|svn_wc_schedule_replace
expr_stmt|;
block|}
else|else
name|wc_info
operator|->
name|schedule
operator|=
name|svn_wc_schedule_add
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_url
argument_list|(
operator|&
name|tmpinfo
operator|->
name|URL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_deleted
condition|)
block|{
specifier|const
name|char
modifier|*
name|work_del_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|last_changed_rev
argument_list|,
operator|&
name|tmpinfo
operator|->
name|last_changed_date
argument_list|,
operator|&
name|tmpinfo
operator|->
name|last_changed_author
argument_list|,
operator|&
name|wc_info
operator|->
name|depth
argument_list|,
operator|&
name|wc_info
operator|->
name|checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And now fetch the url and revision of what will be deleted */
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_deletion
argument_list|(
name|NULL
argument_list|,
operator|&
name|wc_info
operator|->
name|moved_to_abspath
argument_list|,
operator|&
name|work_del_abspath
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_del_abspath
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a deletion within a copied subtree. Get the copied-from            * revision. */
specifier|const
name|char
modifier|*
name|added_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|work_del_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_addition
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_root_URL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_UUID
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|rev
argument_list|,
name|db
argument_list|,
name|added_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|tmpinfo
operator|->
name|URL
operator|=
name|svn_path_url_add_component2
argument_list|(
name|tmpinfo
operator|->
name|repos_root_URL
argument_list|,
name|svn_relpath_join
argument_list|(
name|repos_relpath
argument_list|,
name|svn_dirent_skip_ancestor
argument_list|(
name|added_abspath
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_base_get_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|rev
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_root_URL
argument_list|,
operator|&
name|tmpinfo
operator|->
name|repos_UUID
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|tmpinfo
operator|->
name|URL
operator|=
name|svn_path_url_add_component2
argument_list|(
name|tmpinfo
operator|->
name|repos_root_URL
argument_list|,
name|repos_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|wc_info
operator|->
name|schedule
operator|=
name|svn_wc_schedule_delete
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
condition|)
block|{
operator|*
name|info
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* Just a BASE node. We have all the info we need */
name|tmpinfo
operator|->
name|URL
operator|=
name|svn_path_url_add_component2
argument_list|(
name|tmpinfo
operator|->
name|repos_root_URL
argument_list|,
name|repos_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|wc_info
operator|->
name|schedule
operator|=
name|svn_wc_schedule_normal
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_excluded
condition|)
name|tmpinfo
operator|->
name|wc_info
operator|->
name|depth
operator|=
name|svn_depth_exclude
expr_stmt|;
comment|/* A default */
name|tmpinfo
operator|->
name|size
operator|=
name|SVN_INVALID_FILESIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|tmpinfo
operator|->
name|wc_info
operator|->
name|wcroot_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicted
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__read_conflicts
argument_list|(
operator|&
name|wc_info
operator|->
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
comment|/* ### create tempfiles */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|wc_info
operator|->
name|conflicts
operator|=
name|NULL
expr_stmt|;
comment|/* lock stuff */
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
block|{
name|tmpinfo
operator|->
name|lock
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|tmpinfo
operator|->
name|lock
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmpinfo
operator|->
name|lock
operator|->
name|token
operator|=
name|lock
operator|->
name|token
expr_stmt|;
name|tmpinfo
operator|->
name|lock
operator|->
name|owner
operator|=
name|lock
operator|->
name|owner
expr_stmt|;
name|tmpinfo
operator|->
name|lock
operator|->
name|comment
operator|=
name|lock
operator|->
name|comment
expr_stmt|;
name|tmpinfo
operator|->
name|lock
operator|->
name|creation_date
operator|=
name|lock
operator|->
name|date
expr_stmt|;
block|}
operator|*
name|info
operator|=
name|tmpinfo
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *INFO to a new struct with minimal content, to be    used in reporting info for unversioned tree conflict victims. */
end_comment

begin_comment
comment|/* ### Some fields we could fill out based on the parent dir's entry        or by looking at an obstructing item. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|build_info_for_unversioned
parameter_list|(
name|svn_wc__info2_t
modifier|*
modifier|*
name|info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc__info2_t
modifier|*
name|tmpinfo
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmpinfo
argument_list|)
argument_list|)
decl_stmt|;
name|svn_wc_info_t
modifier|*
name|wc_info
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wc_info
argument_list|)
argument_list|)
decl_stmt|;
name|tmpinfo
operator|->
name|URL
operator|=
name|NULL
expr_stmt|;
name|tmpinfo
operator|->
name|repos_UUID
operator|=
name|NULL
expr_stmt|;
name|tmpinfo
operator|->
name|repos_root_URL
operator|=
name|NULL
expr_stmt|;
name|tmpinfo
operator|->
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|tmpinfo
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|tmpinfo
operator|->
name|size
operator|=
name|SVN_INVALID_FILESIZE
expr_stmt|;
name|tmpinfo
operator|->
name|last_changed_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|tmpinfo
operator|->
name|last_changed_date
operator|=
literal|0
expr_stmt|;
name|tmpinfo
operator|->
name|last_changed_author
operator|=
name|NULL
expr_stmt|;
name|tmpinfo
operator|->
name|lock
operator|=
name|NULL
expr_stmt|;
name|tmpinfo
operator|->
name|wc_info
operator|=
name|wc_info
expr_stmt|;
name|wc_info
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|wc_info
operator|->
name|depth
operator|=
name|svn_depth_unknown
expr_stmt|;
name|wc_info
operator|->
name|recorded_size
operator|=
name|SVN_INVALID_FILESIZE
expr_stmt|;
operator|*
name|info
operator|=
name|tmpinfo
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Callback and baton for crawl_entries() walk over entries files. */
end_comment

begin_struct
struct|struct
name|found_entry_baton
block|{
name|svn_wc__info_receiver2_t
name|receiver
decl_stmt|;
name|void
modifier|*
name|receiver_baton
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
name|svn_boolean_t
name|actual_only
decl_stmt|;
name|svn_boolean_t
name|first
decl_stmt|;
comment|/* The set of tree conflicts that have been found but not (yet) visited by    * the tree walker.  Map of abspath -> svn_wc_conflict_description2_t. */
name|apr_hash_t
modifier|*
name|tree_conflicts
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Call WALK_BATON->receiver with WALK_BATON->receiver_baton, passing to it  * info about the path LOCAL_ABSPATH.  * An svn_wc__node_found_func_t callback function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|info_found_node_callback
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|void
modifier|*
name|walk_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|found_entry_baton
modifier|*
name|fe_baton
init|=
name|walk_baton
decl_stmt|;
name|svn_wc__info2_t
modifier|*
name|info
decl_stmt|;
name|SVN_ERR
argument_list|(
name|build_info_for_node
argument_list|(
operator|&
name|info
argument_list|,
name|fe_baton
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fe_baton
operator|->
name|first
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* not present or server excluded descendant */
comment|/* If the info root is not found, that is an error */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' was not found."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|fe_baton
operator|->
name|first
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|info
operator|->
name|wc_info
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fe_baton
operator|->
name|receiver
argument_list|(
name|fe_baton
operator|->
name|receiver_baton
argument_list|,
name|local_abspath
argument_list|,
name|info
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this node is a versioned directory, make a note of any tree conflicts    * on all immediate children.  Some of these may be visited later in this    * walk, at which point they will be removed from the list, while any that    * are not visited will remain in the list. */
if|if
condition|(
name|fe_baton
operator|->
name|actual_only
operator|&&
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|victims
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict_victims
argument_list|(
operator|&
name|victims
argument_list|,
name|fe_baton
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|victims
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|this_basename
init|=
name|APR_ARRAY_IDX
argument_list|(
name|victims
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|fe_baton
operator|->
name|tree_conflicts
argument_list|,
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|this_basename
argument_list|,
name|fe_baton
operator|->
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Delete this path which we are currently visiting from the list of tree    * conflicts.  This relies on the walker visiting a directory before visiting    * its children. */
name|svn_hash_sets
argument_list|(
name|fe_baton
operator|->
name|tree_conflicts
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff the subtree at ROOT_ABSPATH, restricted to depth DEPTH,  * would include the path CHILD_ABSPATH of kind CHILD_KIND. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|depth_includes
parameter_list|(
specifier|const
name|char
modifier|*
name|root_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|child_abspath
parameter_list|,
name|svn_node_kind_t
name|child_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|parent_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|child_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
return|return
operator|(
name|depth
operator|==
name|svn_depth_infinity
operator|||
operator|(
operator|(
name|depth
operator|==
name|svn_depth_immediates
operator|||
operator|(
name|depth
operator|==
name|svn_depth_files
operator|&&
name|child_kind
operator|==
name|svn_node_file
operator|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|root_abspath
argument_list|,
name|parent_abspath
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|root_abspath
argument_list|,
name|child_abspath
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__get_info
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|fetch_excluded
parameter_list|,
name|svn_boolean_t
name|fetch_actual_only
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelist_filter
parameter_list|,
name|svn_wc__info_receiver2_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|found_entry_baton
name|fe_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
init|=
name|NULL
decl_stmt|;
name|fe_baton
operator|.
name|receiver
operator|=
name|receiver
expr_stmt|;
name|fe_baton
operator|.
name|receiver_baton
operator|=
name|receiver_baton
expr_stmt|;
name|fe_baton
operator|.
name|db
operator|=
name|wc_ctx
operator|->
name|db
expr_stmt|;
name|fe_baton
operator|.
name|actual_only
operator|=
name|fetch_actual_only
expr_stmt|;
name|fe_baton
operator|.
name|first
operator|=
name|TRUE
expr_stmt|;
name|fe_baton
operator|.
name|tree_conflicts
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|fe_baton
operator|.
name|pool
operator|=
name|scratch_pool
expr_stmt|;
name|err
operator|=
name|svn_wc__internal_walk_children
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|fetch_excluded
argument_list|,
name|changelist_filter
argument_list|,
name|info_found_node_callback
argument_list|,
operator|&
name|fe_baton
argument_list|,
name|depth
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If the target root node is not present, svn_wc__internal_walk_children()      returns a PATH_NOT_FOUND error and doesn't call the callback.  If there      is a tree conflict on this node, that is not an error. */
if|if
condition|(
name|fe_baton
operator|.
name|first
comment|/* not visited by walk_children */
operator|&&
name|fetch_actual_only
operator|&&
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|err2
operator|=
name|svn_wc__internal_conflicted_p
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err2
operator|&&
name|err2
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err2
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|err2
operator|||
operator|!
name|tree_conflicted
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|fe_baton
operator|.
name|tree_conflicts
argument_list|,
name|local_abspath
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* If there are any tree conflicts that we have found but have not reported,    * send a minimal info struct for each one now. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|fe_baton
operator|.
name|tree_conflicts
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|this_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|tree_conflict
decl_stmt|;
name|svn_wc__info2_t
modifier|*
name|info
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build_info_for_unversioned
argument_list|(
operator|&
name|info
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|repos_root_url
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__internal_get_repos_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|this_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|repos_root_URL
operator|=
name|repos_root_url
expr_stmt|;
name|info
operator|->
name|repos_UUID
operator|=
name|repos_uuid
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__read_conflicts
argument_list|(
operator|&
name|info
operator|->
name|wc_info
operator|->
name|conflicts
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|this_abspath
argument_list|,
name|TRUE
comment|/* ### create tempfiles */
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|wc_info
operator|->
name|conflicts
operator|||
operator|!
name|info
operator|->
name|wc_info
operator|->
name|conflicts
operator|->
name|nelts
condition|)
continue|continue;
name|tree_conflict
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|conflicts
argument_list|,
literal|0
argument_list|,
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|depth_includes
argument_list|(
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|tree_conflict
operator|->
name|local_abspath
argument_list|,
name|tree_conflict
operator|->
name|node_kind
argument_list|,
name|iterpool
argument_list|)
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|receiver
argument_list|(
name|receiver_baton
argument_list|,
name|this_abspath
argument_list|,
name|info
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

