begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * log-cmd.c -- Display log messages  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_define
define|#
directive|define
name|APR_WANT_STDIO
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_compat.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Baton for log_entry_receiver() and log_entry_receiver_xml(). */
end_comment

begin_struct
struct|struct
name|log_receiver_baton
block|{
comment|/* Client context. */
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
comment|/* Level of merge revision nesting */
name|apr_size_t
name|merge_depth
decl_stmt|;
comment|/* collect counters? */
name|svn_boolean_t
name|quiet
decl_stmt|;
comment|/* total revision counters */
name|apr_int64_t
name|revisions
decl_stmt|;
name|apr_int64_t
name|changes
decl_stmt|;
name|apr_int64_t
name|message_lines
decl_stmt|;
comment|/* part that came from merges */
name|apr_int64_t
name|merges
decl_stmt|;
name|apr_int64_t
name|merged_revs
decl_stmt|;
name|apr_int64_t
name|merged_changes
decl_stmt|;
name|apr_int64_t
name|merged_message_lines
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implement `svn_log_entry_receiver_t', printing the logs in  * a human-readable and machine-parseable format.  *  * BATON is of type `struct log_receiver_baton'.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_entry_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|log_receiver_baton
modifier|*
name|lb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|author
decl_stmt|;
specifier|const
name|char
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
if|if
condition|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|log_entry
operator|->
name|revision
argument_list|)
condition|)
block|{
name|lb
operator|->
name|merge_depth
operator|--
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* if we don't want counters, we are done */
if|if
condition|(
name|lb
operator|->
name|quiet
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* extract the message and do all the other counting */
name|svn_compat_log_revprops_out
argument_list|(
operator|&
name|author
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|message
argument_list|,
name|log_entry
operator|->
name|revprops
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revision
operator|==
literal|0
operator|&&
name|message
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|lb
operator|->
name|revisions
operator|++
expr_stmt|;
if|if
condition|(
name|lb
operator|->
name|merge_depth
condition|)
name|lb
operator|->
name|merged_revs
operator|++
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
name|int
name|count
init|=
name|svn_cstring_count_newlines
argument_list|(
name|message
argument_list|)
operator|+
literal|1
decl_stmt|;
name|lb
operator|->
name|message_lines
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|lb
operator|->
name|merge_depth
condition|)
name|lb
operator|->
name|merged_message_lines
operator|+=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|log_entry
operator|->
name|changed_paths2
condition|)
block|{
name|unsigned
name|count
init|=
name|apr_hash_count
argument_list|(
name|log_entry
operator|->
name|changed_paths2
argument_list|)
decl_stmt|;
name|lb
operator|->
name|changes
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|lb
operator|->
name|merge_depth
condition|)
name|lb
operator|->
name|merged_changes
operator|+=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|log_entry
operator|->
name|has_children
condition|)
block|{
name|lb
operator|->
name|merge_depth
operator|++
expr_stmt|;
name|lb
operator|->
name|merges
operator|++
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements the `svn_opt_subcommand_t' interface. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cl__null_log
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cl__opt_state_t
modifier|*
name|opt_state
init|=
operator|(
operator|(
name|svn_cl__cmd_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|opt_state
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
init|=
operator|(
operator|(
name|svn_cl__cmd_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|ctx
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|struct
name|log_receiver_baton
name|lb
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|revprops
decl_stmt|;
name|svn_opt_revision_t
name|target_peg_revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_path_or_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__args_to_target_array_print_reserved
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|opt_state
operator|->
name|targets
argument_list|,
name|ctx
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add "." if user passed 0 arguments */
name|svn_opt_push_implicit_dot_target
argument_list|(
name|targets
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Determine if they really want a two-revision range. */
if|if
condition|(
name|opt_state
operator|->
name|used_change_arg
condition|)
block|{
if|if
condition|(
name|opt_state
operator|->
name|used_revision_arg
operator|&&
name|opt_state
operator|->
name|revision_ranges
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"-c and -r are mutually exclusive"
argument_list|)
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opt_state
operator|->
name|revision_ranges
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_opt_revision_range_t
modifier|*
name|range
decl_stmt|;
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|opt_state
operator|->
name|revision_ranges
argument_list|,
name|i
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|start
operator|.
name|value
operator|.
name|number
operator|<
name|range
operator|->
name|end
operator|.
name|value
operator|.
name|number
condition|)
name|range
operator|->
name|start
operator|.
name|value
operator|.
name|number
operator|++
expr_stmt|;
else|else
name|range
operator|->
name|end
operator|.
name|value
operator|.
name|number
operator|++
expr_stmt|;
block|}
block|}
comment|/* Parse the first target into path-or-url and peg revision. */
name|target
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_parse_path
argument_list|(
operator|&
name|target_peg_revision
argument_list|,
operator|&
name|target_path_or_url
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_peg_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|target_peg_revision
operator|.
name|kind
operator|=
operator|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|?
name|svn_opt_revision_head
else|:
name|svn_opt_revision_working
operator|)
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|target_path_or_url
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
operator|||
name|target
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Only relative paths can be specified"
literal|" after a URL for 'svnbench log', "
literal|"but '%s' is not a relative path"
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
block|}
block|}
name|lb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|lb
operator|.
name|quiet
operator|=
name|opt_state
operator|->
name|quiet
expr_stmt|;
name|revprops
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_PROP_REVISION_AUTHOR
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_PROP_REVISION_DATE
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_PROP_REVISION_LOG
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_log5
argument_list|(
name|targets
argument_list|,
operator|&
name|target_peg_revision
argument_list|,
name|opt_state
operator|->
name|revision_ranges
argument_list|,
name|opt_state
operator|->
name|limit
argument_list|,
name|opt_state
operator|->
name|verbose
argument_list|,
name|opt_state
operator|->
name|stop_on_copy
argument_list|,
name|opt_state
operator|->
name|use_merge_history
argument_list|,
name|revprops
argument_list|,
name|log_entry_receiver
argument_list|,
operator|&
name|lb
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
block|{
if|if
condition|(
name|opt_state
operator|->
name|use_merge_history
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"%15s revisions, %15s merged in %s merges\n"
literal|"%15s msg lines, %15s in merged revisions\n"
literal|"%15s changes,   %15s in merged revisions\n"
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|revisions
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|merged_revs
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|merges
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|message_lines
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|merged_message_lines
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|changes
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|merged_changes
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"%15s revisions\n"
literal|"%15s msg lines\n"
literal|"%15s changes\n"
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|revisions
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|message_lines
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn__ui64toa_sep
argument_list|(
name|lb
operator|.
name|changes
argument_list|,
literal|','
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

