begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * lcs.c :  routines for creating an lcs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_comment
comment|/*  * Calculate the Longest Common Subsequence (LCS) between two datasources.  * This function is what makes the diff code tick.  *  * The LCS algorithm implemented here is based on the approach described  * by Sun Wu, Udi Manber and Gene Meyers in "An O(NP) Sequence Comparison  * Algorithm", but has been modified for better performance.  *  * Let M and N be the lengths (number of tokens) of the two sources  * ('files'). The goal is to reach the end of both sources (files) with the  * minimum number of insertions + deletions. Since there is a known length  * difference N-M between the files, that is equivalent to just the minimum  * number of deletions, or equivalently the minimum number of insertions.  * For symmetry, we use the lesser number - deletions if M<N, insertions if  * M>N.  *  * Let 'k' be the difference in remaining length between the files, i.e.  * if we're at the beginning of both files, k=N-M, whereas k=0 for the  * 'end state', at the end of both files. An insertion will increase k by  * one, while a deletion decreases k by one. If k<0, then insertions are  * 'free' - we need those to reach the end state k=0 anyway - but deletions  * are costly: Adding a deletion means that we will have to add an additional  * insertion later to reach the end state, so it doesn't matter if we count  * deletions or insertions. Similarly, deletions are free for k>0.  *  * Let a 'state' be a given position in each file {pos1, pos2}. An array  * 'fp' keeps track of the best possible state (largest values of  * {pos1, pos2}) that can be achieved for a given cost 'p' (# moves away  * from k=0), as well as a linked list of what matches were used to reach  * that state. For each new value of p, we find for each value of k the  * best achievable state for that k - either by doing a costly operation  * (deletion if k<0) from a state achieved at a lower p, or doing a free  * operation (insertion if k<0) from a state achieved at the same p -  * and in both cases advancing past any matching regions found. This is  * handled by running loops over k in order of descending absolute value.  *  * A recent improvement of the algorithm is to ignore tokens that are unique  * to one file or the other, as those are known from the start to be  * impossible to match.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|svn_diff__snake_t
name|svn_diff__snake_t
typedef|;
end_typedef

begin_struct
struct|struct
name|svn_diff__snake_t
block|{
name|apr_off_t
name|y
decl_stmt|;
name|svn_diff__lcs_t
modifier|*
name|lcs
decl_stmt|;
name|svn_diff__position_t
modifier|*
name|position
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|APR_INLINE
name|void
name|svn_diff__snake
parameter_list|(
name|svn_diff__snake_t
modifier|*
name|fp_k
parameter_list|,
name|svn_diff__token_index_t
modifier|*
name|token_counts
index|[
literal|2
index|]
parameter_list|,
name|svn_diff__lcs_t
modifier|*
modifier|*
name|freelist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff__position_t
modifier|*
name|start_position
index|[
literal|2
index|]
decl_stmt|;
name|svn_diff__position_t
modifier|*
name|position
index|[
literal|2
index|]
decl_stmt|;
name|svn_diff__lcs_t
modifier|*
name|lcs
decl_stmt|;
name|svn_diff__lcs_t
modifier|*
name|previous_lcs
decl_stmt|;
comment|/* The previous entry at fp[k] is going to be replaced.  See if we    * can mark that lcs node for reuse, because the sequence up to this    * point was a dead end.    */
name|lcs
operator|=
name|fp_k
index|[
literal|0
index|]
operator|.
name|lcs
expr_stmt|;
while|while
condition|(
name|lcs
condition|)
block|{
name|lcs
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|lcs
operator|->
name|refcount
condition|)
break|break;
name|previous_lcs
operator|=
name|lcs
operator|->
name|next
expr_stmt|;
name|lcs
operator|->
name|next
operator|=
operator|*
name|freelist
expr_stmt|;
operator|*
name|freelist
operator|=
name|lcs
expr_stmt|;
name|lcs
operator|=
name|previous_lcs
expr_stmt|;
block|}
if|if
condition|(
name|fp_k
index|[
operator|-
literal|1
index|]
operator|.
name|y
operator|>=
name|fp_k
index|[
literal|1
index|]
operator|.
name|y
condition|)
block|{
name|start_position
index|[
literal|0
index|]
operator|=
name|fp_k
index|[
operator|-
literal|1
index|]
operator|.
name|position
index|[
literal|0
index|]
expr_stmt|;
name|start_position
index|[
literal|1
index|]
operator|=
name|fp_k
index|[
operator|-
literal|1
index|]
operator|.
name|position
index|[
literal|1
index|]
operator|->
name|next
expr_stmt|;
name|previous_lcs
operator|=
name|fp_k
index|[
operator|-
literal|1
index|]
operator|.
name|lcs
expr_stmt|;
block|}
else|else
block|{
name|start_position
index|[
literal|0
index|]
operator|=
name|fp_k
index|[
literal|1
index|]
operator|.
name|position
index|[
literal|0
index|]
operator|->
name|next
expr_stmt|;
name|start_position
index|[
literal|1
index|]
operator|=
name|fp_k
index|[
literal|1
index|]
operator|.
name|position
index|[
literal|1
index|]
expr_stmt|;
name|previous_lcs
operator|=
name|fp_k
index|[
literal|1
index|]
operator|.
name|lcs
expr_stmt|;
block|}
if|if
condition|(
name|previous_lcs
condition|)
block|{
name|previous_lcs
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
comment|/* ### Optimization, skip all positions that don't have matchpoints    * ### anyway. Beware of the sentinel, don't skip it!    */
name|position
index|[
literal|0
index|]
operator|=
name|start_position
index|[
literal|0
index|]
expr_stmt|;
name|position
index|[
literal|1
index|]
operator|=
name|start_position
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|position
index|[
literal|0
index|]
operator|->
name|token_index
operator|==
name|position
index|[
literal|1
index|]
operator|->
name|token_index
condition|)
block|{
name|position
index|[
literal|0
index|]
operator|=
name|position
index|[
literal|0
index|]
operator|->
name|next
expr_stmt|;
name|position
index|[
literal|1
index|]
operator|=
name|position
index|[
literal|1
index|]
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|position
index|[
literal|1
index|]
operator|!=
name|start_position
index|[
literal|1
index|]
condition|)
block|{
name|lcs
operator|=
operator|*
name|freelist
expr_stmt|;
if|if
condition|(
name|lcs
condition|)
block|{
operator|*
name|freelist
operator|=
name|lcs
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|lcs
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lcs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lcs
operator|->
name|position
index|[
literal|0
index|]
operator|=
name|start_position
index|[
literal|0
index|]
expr_stmt|;
name|lcs
operator|->
name|position
index|[
literal|1
index|]
operator|=
name|start_position
index|[
literal|1
index|]
expr_stmt|;
name|lcs
operator|->
name|length
operator|=
name|position
index|[
literal|1
index|]
operator|->
name|offset
operator|-
name|start_position
index|[
literal|1
index|]
operator|->
name|offset
expr_stmt|;
name|lcs
operator|->
name|next
operator|=
name|previous_lcs
expr_stmt|;
name|lcs
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|previous_lcs
operator|=
name|lcs
expr_stmt|;
name|start_position
index|[
literal|0
index|]
operator|=
name|position
index|[
literal|0
index|]
expr_stmt|;
name|start_position
index|[
literal|1
index|]
operator|=
name|position
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* Skip any and all tokens that only occur in one of the files */
if|if
condition|(
name|position
index|[
literal|0
index|]
operator|->
name|token_index
operator|>=
literal|0
operator|&&
name|token_counts
index|[
literal|1
index|]
index|[
name|position
index|[
literal|0
index|]
operator|->
name|token_index
index|]
operator|==
literal|0
condition|)
name|start_position
index|[
literal|0
index|]
operator|=
name|position
index|[
literal|0
index|]
operator|=
name|position
index|[
literal|0
index|]
operator|->
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|position
index|[
literal|1
index|]
operator|->
name|token_index
operator|>=
literal|0
operator|&&
name|token_counts
index|[
literal|0
index|]
index|[
name|position
index|[
literal|1
index|]
operator|->
name|token_index
index|]
operator|==
literal|0
condition|)
name|start_position
index|[
literal|1
index|]
operator|=
name|position
index|[
literal|1
index|]
operator|=
name|position
index|[
literal|1
index|]
operator|->
name|next
expr_stmt|;
else|else
break|break;
block|}
name|fp_k
index|[
literal|0
index|]
operator|.
name|lcs
operator|=
name|previous_lcs
expr_stmt|;
name|fp_k
index|[
literal|0
index|]
operator|.
name|position
index|[
literal|0
index|]
operator|=
name|position
index|[
literal|0
index|]
expr_stmt|;
name|fp_k
index|[
literal|0
index|]
operator|.
name|position
index|[
literal|1
index|]
operator|=
name|position
index|[
literal|1
index|]
expr_stmt|;
name|fp_k
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|position
index|[
literal|1
index|]
operator|->
name|offset
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_diff__lcs_t
modifier|*
name|svn_diff__lcs_reverse
parameter_list|(
name|svn_diff__lcs_t
modifier|*
name|lcs
parameter_list|)
block|{
name|svn_diff__lcs_t
modifier|*
name|next
decl_stmt|;
name|svn_diff__lcs_t
modifier|*
name|prev
decl_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|lcs
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|=
name|lcs
operator|->
name|next
expr_stmt|;
name|lcs
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|lcs
expr_stmt|;
name|lcs
operator|=
name|prev
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Prepends a new lcs chunk for the amount of LINES at the given positions  * POS0_OFFSET and POS1_OFFSET to the given LCS chain, and returns it.  * This function assumes LINES> 0. */
end_comment

begin_function
specifier|static
name|svn_diff__lcs_t
modifier|*
name|prepend_lcs
parameter_list|(
name|svn_diff__lcs_t
modifier|*
name|lcs
parameter_list|,
name|apr_off_t
name|lines
parameter_list|,
name|apr_off_t
name|pos0_offset
parameter_list|,
name|apr_off_t
name|pos1_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff__lcs_t
modifier|*
name|new_lcs
decl_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|lines
operator|>
literal|0
argument_list|)
expr_stmt|;
name|new_lcs
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_lcs
argument_list|)
argument_list|)
expr_stmt|;
name|new_lcs
operator|->
name|position
index|[
literal|0
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_lcs
operator|->
name|position
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|new_lcs
operator|->
name|position
index|[
literal|0
index|]
operator|->
name|offset
operator|=
name|pos0_offset
expr_stmt|;
name|new_lcs
operator|->
name|position
index|[
literal|1
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_lcs
operator|->
name|position
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|new_lcs
operator|->
name|position
index|[
literal|1
index|]
operator|->
name|offset
operator|=
name|pos1_offset
expr_stmt|;
name|new_lcs
operator|->
name|length
operator|=
name|lines
expr_stmt|;
name|new_lcs
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|new_lcs
operator|->
name|next
operator|=
name|lcs
expr_stmt|;
return|return
name|new_lcs
return|;
block|}
end_function

begin_function
name|svn_diff__lcs_t
modifier|*
name|svn_diff__lcs
parameter_list|(
name|svn_diff__position_t
modifier|*
name|position_list1
parameter_list|,
comment|/* pointer to tail (ring) */
name|svn_diff__position_t
modifier|*
name|position_list2
parameter_list|,
comment|/* pointer to tail (ring) */
name|svn_diff__token_index_t
modifier|*
name|token_counts_list1
parameter_list|,
comment|/* array of counts */
name|svn_diff__token_index_t
modifier|*
name|token_counts_list2
parameter_list|,
comment|/* array of counts */
name|svn_diff__token_index_t
name|num_tokens
parameter_list|,
name|apr_off_t
name|prefix_lines
parameter_list|,
name|apr_off_t
name|suffix_lines
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_off_t
name|length
index|[
literal|2
index|]
decl_stmt|;
name|svn_diff__token_index_t
modifier|*
name|token_counts
index|[
literal|2
index|]
decl_stmt|;
name|svn_diff__token_index_t
name|unique_count
index|[
literal|2
index|]
decl_stmt|;
name|svn_diff__token_index_t
name|token_index
decl_stmt|;
name|svn_diff__snake_t
modifier|*
name|fp
decl_stmt|;
name|apr_off_t
name|d
decl_stmt|;
name|apr_off_t
name|k
decl_stmt|;
name|apr_off_t
name|p
init|=
literal|0
decl_stmt|;
name|svn_diff__lcs_t
modifier|*
name|lcs
decl_stmt|,
modifier|*
name|lcs_freelist
init|=
name|NULL
decl_stmt|;
name|svn_diff__position_t
name|sentinel_position
index|[
literal|2
index|]
decl_stmt|;
comment|/* Since EOF is always a sync point we tack on an EOF link    * with sentinel positions    */
name|lcs
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lcs
argument_list|)
argument_list|)
expr_stmt|;
name|lcs
operator|->
name|position
index|[
literal|0
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lcs
operator|->
name|position
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|lcs
operator|->
name|position
index|[
literal|0
index|]
operator|->
name|offset
operator|=
name|position_list1
condition|?
name|position_list1
operator|->
name|offset
operator|+
name|suffix_lines
operator|+
literal|1
else|:
name|prefix_lines
operator|+
name|suffix_lines
operator|+
literal|1
expr_stmt|;
name|lcs
operator|->
name|position
index|[
literal|1
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lcs
operator|->
name|position
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|lcs
operator|->
name|position
index|[
literal|1
index|]
operator|->
name|offset
operator|=
name|position_list2
condition|?
name|position_list2
operator|->
name|offset
operator|+
name|suffix_lines
operator|+
literal|1
else|:
name|prefix_lines
operator|+
name|suffix_lines
operator|+
literal|1
expr_stmt|;
name|lcs
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|lcs
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|lcs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|position_list1
operator|==
name|NULL
operator|||
name|position_list2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|suffix_lines
condition|)
name|lcs
operator|=
name|prepend_lcs
argument_list|(
name|lcs
argument_list|,
name|suffix_lines
argument_list|,
name|lcs
operator|->
name|position
index|[
literal|0
index|]
operator|->
name|offset
operator|-
name|suffix_lines
argument_list|,
name|lcs
operator|->
name|position
index|[
literal|1
index|]
operator|->
name|offset
operator|-
name|suffix_lines
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_lines
condition|)
name|lcs
operator|=
name|prepend_lcs
argument_list|(
name|lcs
argument_list|,
name|prefix_lines
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|lcs
return|;
block|}
name|unique_count
index|[
literal|1
index|]
operator|=
name|unique_count
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|token_index
operator|=
literal|0
init|;
name|token_index
operator|<
name|num_tokens
condition|;
name|token_index
operator|++
control|)
block|{
if|if
condition|(
name|token_counts_list1
index|[
name|token_index
index|]
operator|==
literal|0
condition|)
name|unique_count
index|[
literal|1
index|]
operator|+=
name|token_counts_list2
index|[
name|token_index
index|]
expr_stmt|;
if|if
condition|(
name|token_counts_list2
index|[
name|token_index
index|]
operator|==
literal|0
condition|)
name|unique_count
index|[
literal|0
index|]
operator|+=
name|token_counts_list1
index|[
name|token_index
index|]
expr_stmt|;
block|}
comment|/* Calculate lengths M and N of the sequences to be compared. Do not    * count tokens unique to one file, as those are ignored in __snake.    */
name|length
index|[
literal|0
index|]
operator|=
name|position_list1
operator|->
name|offset
operator|-
name|position_list1
operator|->
name|next
operator|->
name|offset
operator|+
literal|1
operator|-
name|unique_count
index|[
literal|0
index|]
expr_stmt|;
name|length
index|[
literal|1
index|]
operator|=
name|position_list2
operator|->
name|offset
operator|-
name|position_list2
operator|->
name|next
operator|->
name|offset
operator|+
literal|1
operator|-
name|unique_count
index|[
literal|1
index|]
expr_stmt|;
comment|/* strikerXXX: here we allocate the furthest point array, which is    * strikerXXX: sized M + N + 3 (!)    */
name|fp
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
operator|*
call|(
name|apr_size_t
call|)
argument_list|(
name|length
index|[
literal|0
index|]
operator|+
name|length
index|[
literal|1
index|]
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The origo of fp corresponds to the end state, where we are    * at the end of both files. The valid states thus span from    * -N (at end of first file and at the beginning of the second    * file) to +M (the opposite :). Finally, svn_diff__snake needs    * 1 extra slot on each side to work.    */
name|fp
operator|+=
name|length
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|sentinel_position
index|[
literal|0
index|]
operator|.
name|next
operator|=
name|position_list1
operator|->
name|next
expr_stmt|;
name|position_list1
operator|->
name|next
operator|=
operator|&
name|sentinel_position
index|[
literal|0
index|]
expr_stmt|;
name|sentinel_position
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|position_list1
operator|->
name|offset
operator|+
literal|1
expr_stmt|;
name|token_counts
index|[
literal|0
index|]
operator|=
name|token_counts_list1
expr_stmt|;
name|sentinel_position
index|[
literal|1
index|]
operator|.
name|next
operator|=
name|position_list2
operator|->
name|next
expr_stmt|;
name|position_list2
operator|->
name|next
operator|=
operator|&
name|sentinel_position
index|[
literal|1
index|]
expr_stmt|;
name|sentinel_position
index|[
literal|1
index|]
operator|.
name|offset
operator|=
name|position_list2
operator|->
name|offset
operator|+
literal|1
expr_stmt|;
name|token_counts
index|[
literal|1
index|]
operator|=
name|token_counts_list2
expr_stmt|;
comment|/* Negative indices will not be used elsewhere    */
name|sentinel_position
index|[
literal|0
index|]
operator|.
name|token_index
operator|=
operator|-
literal|1
expr_stmt|;
name|sentinel_position
index|[
literal|1
index|]
operator|.
name|token_index
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* position d = M - N corresponds to the initial state, where    * we are at the beginning of both files.    */
name|d
operator|=
name|length
index|[
literal|0
index|]
operator|-
name|length
index|[
literal|1
index|]
expr_stmt|;
comment|/* k = d - 1 will be the first to be used to get previous    * position information from, make sure it holds sane    * data    */
name|fp
index|[
name|d
operator|-
literal|1
index|]
operator|.
name|position
index|[
literal|0
index|]
operator|=
name|sentinel_position
index|[
literal|0
index|]
operator|.
name|next
expr_stmt|;
name|fp
index|[
name|d
operator|-
literal|1
index|]
operator|.
name|position
index|[
literal|1
index|]
operator|=
operator|&
name|sentinel_position
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* For k< 0, insertions are free */
for|for
control|(
name|k
operator|=
operator|(
name|d
operator|<
literal|0
condition|?
name|d
else|:
literal|0
operator|)
operator|-
name|p
init|;
name|k
operator|<
literal|0
condition|;
name|k
operator|++
control|)
block|{
name|svn_diff__snake
argument_list|(
name|fp
operator|+
name|k
argument_list|,
name|token_counts
argument_list|,
operator|&
name|lcs_freelist
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* for k> 0, deletions are free */
for|for
control|(
name|k
operator|=
operator|(
name|d
operator|>
literal|0
condition|?
name|d
else|:
literal|0
operator|)
operator|+
name|p
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
name|svn_diff__snake
argument_list|(
name|fp
operator|+
name|k
argument_list|,
name|token_counts
argument_list|,
operator|&
name|lcs_freelist
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|fp
index|[
literal|0
index|]
operator|.
name|position
index|[
literal|1
index|]
operator|!=
operator|&
name|sentinel_position
index|[
literal|1
index|]
condition|)
do|;
if|if
condition|(
name|suffix_lines
condition|)
name|lcs
operator|->
name|next
operator|=
name|prepend_lcs
argument_list|(
name|fp
index|[
literal|0
index|]
operator|.
name|lcs
argument_list|,
name|suffix_lines
argument_list|,
name|lcs
operator|->
name|position
index|[
literal|0
index|]
operator|->
name|offset
operator|-
name|suffix_lines
argument_list|,
name|lcs
operator|->
name|position
index|[
literal|1
index|]
operator|->
name|offset
operator|-
name|suffix_lines
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|lcs
operator|->
name|next
operator|=
name|fp
index|[
literal|0
index|]
operator|.
name|lcs
expr_stmt|;
name|lcs
operator|=
name|svn_diff__lcs_reverse
argument_list|(
name|lcs
argument_list|)
expr_stmt|;
name|position_list1
operator|->
name|next
operator|=
name|sentinel_position
index|[
literal|0
index|]
operator|.
name|next
expr_stmt|;
name|position_list2
operator|->
name|next
operator|=
name|sentinel_position
index|[
literal|1
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|prefix_lines
condition|)
return|return
name|prepend_lcs
argument_list|(
name|lcs
argument_list|,
name|prefix_lines
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|lcs
return|;
block|}
end_function

end_unit

