begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * token.c :  routines for doing diffs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_comment
comment|/*  * Prime number to use as the size of the hash table.  This number was  * not selected by testing of any kind and may need tweaking.  */
end_comment

begin_define
define|#
directive|define
name|SVN_DIFF__HASH_SIZE
value|127
end_define

begin_struct
struct|struct
name|svn_diff__node_t
block|{
name|svn_diff__node_t
modifier|*
name|parent
decl_stmt|;
name|svn_diff__node_t
modifier|*
name|left
decl_stmt|;
name|svn_diff__node_t
modifier|*
name|right
decl_stmt|;
name|apr_uint32_t
name|hash
decl_stmt|;
name|svn_diff__token_index_t
name|index
decl_stmt|;
name|void
modifier|*
name|token
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|svn_diff__tree_t
block|{
name|svn_diff__node_t
modifier|*
name|root
index|[
name|SVN_DIFF__HASH_SIZE
index|]
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_diff__token_index_t
name|node_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Returns number of tokens in a tree  */
end_comment

begin_function
name|svn_diff__token_index_t
name|svn_diff__get_node_count
parameter_list|(
name|svn_diff__tree_t
modifier|*
name|tree
parameter_list|)
block|{
return|return
name|tree
operator|->
name|node_count
return|;
block|}
end_function

begin_comment
comment|/*  * Support functions to build a tree of token positions  */
end_comment

begin_function
name|void
name|svn_diff__tree_create
parameter_list|(
name|svn_diff__tree_t
modifier|*
modifier|*
name|tree
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|tree
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|tree
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|tree
operator|)
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
operator|(
operator|*
name|tree
operator|)
operator|->
name|node_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tree_insert_token
parameter_list|(
name|svn_diff__node_t
modifier|*
modifier|*
name|node
parameter_list|,
name|svn_diff__tree_t
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
name|diff_baton
parameter_list|,
specifier|const
name|svn_diff_fns2_t
modifier|*
name|vtable
parameter_list|,
name|apr_uint32_t
name|hash
parameter_list|,
name|void
modifier|*
name|token
parameter_list|)
block|{
name|svn_diff__node_t
modifier|*
name|new_node
decl_stmt|;
name|svn_diff__node_t
modifier|*
modifier|*
name|node_ref
decl_stmt|;
name|svn_diff__node_t
modifier|*
name|parent
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|parent
operator|=
name|NULL
expr_stmt|;
name|node_ref
operator|=
operator|&
name|tree
operator|->
name|root
index|[
name|hash
operator|%
name|SVN_DIFF__HASH_SIZE
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|node_ref
operator|!=
name|NULL
condition|)
block|{
name|parent
operator|=
operator|*
name|node_ref
expr_stmt|;
name|rv
operator|=
name|hash
operator|-
name|parent
operator|->
name|hash
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
name|SVN_ERR
argument_list|(
name|vtable
operator|->
name|token_compare
argument_list|(
name|diff_baton
argument_list|,
name|parent
operator|->
name|token
argument_list|,
name|token
argument_list|,
operator|&
name|rv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
comment|/* Discard the previous token.  This helps in cases where            * only recently read tokens are still in memory.            */
if|if
condition|(
name|vtable
operator|->
name|token_discard
operator|!=
name|NULL
condition|)
name|vtable
operator|->
name|token_discard
argument_list|(
name|diff_baton
argument_list|,
name|parent
operator|->
name|token
argument_list|)
expr_stmt|;
name|parent
operator|->
name|token
operator|=
name|token
expr_stmt|;
operator|*
name|node
operator|=
name|parent
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|>
literal|0
condition|)
block|{
name|node_ref
operator|=
operator|&
name|parent
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|node_ref
operator|=
operator|&
name|parent
operator|->
name|right
expr_stmt|;
block|}
block|}
comment|/* Create a new node */
name|new_node
operator|=
name|apr_palloc
argument_list|(
name|tree
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_node
argument_list|)
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|new_node
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
name|new_node
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|new_node
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|new_node
operator|->
name|token
operator|=
name|token
expr_stmt|;
name|new_node
operator|->
name|index
operator|=
name|tree
operator|->
name|node_count
operator|++
expr_stmt|;
operator|*
name|node
operator|=
operator|*
name|node_ref
operator|=
name|new_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Get all tokens from a datasource.  Return the  * last item in the (circular) list.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_diff__get_tokens
parameter_list|(
name|svn_diff__position_t
modifier|*
modifier|*
name|position_list
parameter_list|,
name|svn_diff__tree_t
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
name|diff_baton
parameter_list|,
specifier|const
name|svn_diff_fns2_t
modifier|*
name|vtable
parameter_list|,
name|svn_diff_datasource_e
name|datasource
parameter_list|,
name|apr_off_t
name|prefix_lines
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff__position_t
modifier|*
name|start_position
decl_stmt|;
name|svn_diff__position_t
modifier|*
name|position
init|=
name|NULL
decl_stmt|;
name|svn_diff__position_t
modifier|*
modifier|*
name|position_ref
decl_stmt|;
name|svn_diff__node_t
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|token
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|apr_uint32_t
name|hash
decl_stmt|;
operator|*
name|position_list
operator|=
name|NULL
expr_stmt|;
name|position_ref
operator|=
operator|&
name|start_position
expr_stmt|;
name|offset
operator|=
name|prefix_lines
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
comment|/* The callback fn doesn't need to touch it per se */
while|while
condition|(
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|vtable
operator|->
name|datasource_get_next_token
argument_list|(
operator|&
name|hash
argument_list|,
operator|&
name|token
argument_list|,
name|diff_baton
argument_list|,
name|datasource
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|NULL
condition|)
break|break;
name|offset
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|tree_insert_token
argument_list|(
operator|&
name|node
argument_list|,
name|tree
argument_list|,
name|diff_baton
argument_list|,
name|vtable
argument_list|,
name|hash
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new position */
name|position
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|position
operator|->
name|token_index
operator|=
name|node
operator|->
name|index
expr_stmt|;
name|position
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
operator|*
name|position_ref
operator|=
name|position
expr_stmt|;
name|position_ref
operator|=
operator|&
name|position
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|position_ref
operator|=
name|start_position
expr_stmt|;
name|SVN_ERR
argument_list|(
name|vtable
operator|->
name|datasource_close
argument_list|(
name|diff_baton
argument_list|,
name|datasource
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|position_list
operator|=
name|position
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

