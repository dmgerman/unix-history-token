begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util.c :  routines for doing diffs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_diff_private.h"
end_include

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_function
name|svn_boolean_t
name|svn_diff_contains_conflicts
parameter_list|(
name|svn_diff_t
modifier|*
name|diff
parameter_list|)
block|{
while|while
condition|(
name|diff
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|diff
operator|->
name|type
operator|==
name|svn_diff__type_conflict
condition|)
block|{
return|return
name|TRUE
return|;
block|}
name|diff
operator|=
name|diff
operator|->
name|next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_diff_contains_diffs
parameter_list|(
name|svn_diff_t
modifier|*
name|diff
parameter_list|)
block|{
while|while
condition|(
name|diff
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|diff
operator|->
name|type
operator|!=
name|svn_diff__type_common
condition|)
block|{
return|return
name|TRUE
return|;
block|}
name|diff
operator|=
name|diff
operator|->
name|next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_output
parameter_list|(
name|svn_diff_t
modifier|*
name|diff
parameter_list|,
name|void
modifier|*
name|output_baton
parameter_list|,
specifier|const
name|svn_diff_output_fns_t
modifier|*
name|vtable
parameter_list|)
block|{
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|output_fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|apr_off_t
parameter_list|,
name|apr_off_t
parameter_list|,
name|apr_off_t
parameter_list|,
name|apr_off_t
parameter_list|,
name|apr_off_t
parameter_list|,
name|apr_off_t
parameter_list|)
function_decl|;
while|while
condition|(
name|diff
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|diff
operator|->
name|type
condition|)
block|{
case|case
name|svn_diff__type_common
case|:
name|output_fn
operator|=
name|vtable
operator|->
name|output_common
expr_stmt|;
break|break;
case|case
name|svn_diff__type_diff_common
case|:
name|output_fn
operator|=
name|vtable
operator|->
name|output_diff_common
expr_stmt|;
break|break;
case|case
name|svn_diff__type_diff_modified
case|:
name|output_fn
operator|=
name|vtable
operator|->
name|output_diff_modified
expr_stmt|;
break|break;
case|case
name|svn_diff__type_diff_latest
case|:
name|output_fn
operator|=
name|vtable
operator|->
name|output_diff_latest
expr_stmt|;
break|break;
case|case
name|svn_diff__type_conflict
case|:
name|output_fn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vtable
operator|->
name|output_conflict
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|vtable
operator|->
name|output_conflict
argument_list|(
name|output_baton
argument_list|,
name|diff
operator|->
name|original_start
argument_list|,
name|diff
operator|->
name|original_length
argument_list|,
name|diff
operator|->
name|modified_start
argument_list|,
name|diff
operator|->
name|modified_length
argument_list|,
name|diff
operator|->
name|latest_start
argument_list|,
name|diff
operator|->
name|latest_length
argument_list|,
name|diff
operator|->
name|resolved_diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|output_fn
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|output_fn
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_fn
argument_list|(
name|output_baton
argument_list|,
name|diff
operator|->
name|original_start
argument_list|,
name|diff
operator|->
name|original_length
argument_list|,
name|diff
operator|->
name|modified_start
argument_list|,
name|diff
operator|->
name|modified_length
argument_list|,
name|diff
operator|->
name|latest_start
argument_list|,
name|diff
operator|->
name|latest_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|diff
operator|=
name|diff
operator|->
name|next
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_diff__normalize_buffer
parameter_list|(
name|char
modifier|*
modifier|*
name|tgt
parameter_list|,
name|apr_off_t
modifier|*
name|lengthp
parameter_list|,
name|svn_diff__normalize_state_t
modifier|*
name|statep
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|svn_diff_file_options_t
modifier|*
name|opts
parameter_list|)
block|{
comment|/* Variables for looping through BUF */
specifier|const
name|char
modifier|*
name|curp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
comment|/* Variable to record normalizing state */
name|svn_diff__normalize_state_t
name|state
init|=
operator|*
name|statep
decl_stmt|;
comment|/* Variables to track what needs copying into the target buffer */
specifier|const
name|char
modifier|*
name|start
init|=
name|buf
decl_stmt|;
name|apr_size_t
name|include_len
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|last_skipped
init|=
name|FALSE
decl_stmt|;
comment|/* makes sure we set 'start' */
comment|/* Variable to record the state of the target buffer */
name|char
modifier|*
name|tgt_newend
init|=
operator|*
name|tgt
decl_stmt|;
comment|/* If this is a noop, then just get out of here. */
if|if
condition|(
operator|!
name|opts
operator|->
name|ignore_space
operator|&&
operator|!
name|opts
operator|->
name|ignore_eol_style
condition|)
block|{
operator|*
name|tgt
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
return|return;
block|}
comment|/* It only took me forever to get this routine right,      so here my thoughts go:      Below, we loop through the data, doing 2 things:       - Normalizing      - Copying other data       The routine tries its hardest *not* to copy data, but instead      returning a pointer into already normalized existing data.       To this end, a block 'other data' shouldn't be copied when found,      but only as soon as it can't be returned in-place.       On a character level, there are 3 possible operations:       - Skip the character (don't include in the normalized data)      - Include the character (do include in the normalizad data)      - Include as another character        This is essentially the same as skipping the current character        and inserting a given character in the output data.      The macros below (SKIP, INCLUDE and INCLUDE_AS) are defined to     handle the character based operations.  The macros themselves     collect character level data into blocks.      At all times designate the START, INCLUDED_LEN and CURP pointers     an included and and skipped block like this:        [ start, start + included_len ) [ start + included_len, curp )              INCLUDED                        EXCLUDED      When the routine flips from skipping to including, the last     included block has to be flushed to the output buffer.   */
comment|/* Going from including to skipping; only schedules the current      included section for flushing.      Also, simply chop off the character if it's the first in the buffer,      so we can possibly just return the remainder of the buffer */
define|#
directive|define
name|SKIP
define|\
value|do {                   \     if (start == curp)   \        ++start;          \     last_skipped = TRUE; \   } while (0)
define|#
directive|define
name|INCLUDE
define|\
value|do {                         \     if (last_skipped)          \       COPY_INCLUDED_SECTION;   \     ++include_len;             \     last_skipped = FALSE;      \   } while (0)
define|#
directive|define
name|COPY_INCLUDED_SECTION
define|\
value|do {                                            \     if (include_len> 0)                          \       {                                           \          memmove(tgt_newend, start, include_len); \          tgt_newend += include_len;               \          include_len = 0;                         \       }                                           \     start = curp;                                 \   } while (0)
comment|/* Include the current character as character X.      If the current character already *is* X, add it to the      currently included region, increasing chances for consecutive      fully normalized blocks. */
define|#
directive|define
name|INCLUDE_AS
parameter_list|(
name|x
parameter_list|)
define|\
value|do {                         \     if (*curp == (x))          \       INCLUDE;                 \     else                       \       {                        \         INSERT((x));           \         SKIP;                  \       }                        \   } while (0)
comment|/* Insert character X in the output buffer */
define|#
directive|define
name|INSERT
parameter_list|(
name|x
parameter_list|)
define|\
value|do {                         \     COPY_INCLUDED_SECTION;     \     *tgt_newend++ = (x);       \   } while (0)
for|for
control|(
name|curp
operator|=
name|buf
operator|,
name|endp
operator|=
name|buf
operator|+
operator|*
name|lengthp
init|;
name|curp
operator|!=
name|endp
condition|;
operator|++
name|curp
control|)
block|{
switch|switch
condition|(
operator|*
name|curp
condition|)
block|{
case|case
literal|'\r'
case|:
if|if
condition|(
name|opts
operator|->
name|ignore_eol_style
condition|)
name|INCLUDE_AS
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|INCLUDE
expr_stmt|;
name|state
operator|=
name|svn_diff__normalize_state_cr
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|state
operator|==
name|svn_diff__normalize_state_cr
operator|&&
name|opts
operator|->
name|ignore_eol_style
condition|)
name|SKIP
expr_stmt|;
else|else
name|INCLUDE
expr_stmt|;
name|state
operator|=
name|svn_diff__normalize_state_normal
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|svn_ctype_isspace
argument_list|(
operator|*
name|curp
argument_list|)
operator|&&
name|opts
operator|->
name|ignore_space
operator|!=
name|svn_diff_file_ignore_space_none
condition|)
block|{
comment|/* Whitespace but not '\r' or '\n' */
if|if
condition|(
name|state
operator|!=
name|svn_diff__normalize_state_whitespace
operator|&&
name|opts
operator|->
name|ignore_space
operator|==
name|svn_diff_file_ignore_space_change
condition|)
comment|/*### If we can postpone insertion of the space                   until the next non-whitespace character,                   we have a potential of reducing the number of copies:                   If this space is followed by more spaces,                   this will cause a block-copy.                   If the next non-space block is considered normalized                   *and* preceded by a space, we can take advantage of that. */
comment|/* Note, the above optimization applies to 90% of the source                    lines in our own code, since it (generally) doesn't use                    more than one space per blank section, except for the                    beginning of a line. */
name|INCLUDE_AS
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
name|SKIP
expr_stmt|;
name|state
operator|=
name|svn_diff__normalize_state_whitespace
expr_stmt|;
block|}
else|else
block|{
comment|/* Non-whitespace character, or whitespace character in                  svn_diff_file_ignore_space_none mode. */
name|INCLUDE
expr_stmt|;
name|state
operator|=
name|svn_diff__normalize_state_normal
expr_stmt|;
block|}
block|}
block|}
comment|/* If we're not in whitespace, flush the last chunk of data.    * Note that this will work correctly when this is the last chunk of the    * file:    * * If there is an eol, it will either have been output when we entered    *   the state_cr, or it will be output now.    * * If there is no eol and we're not in whitespace, then we just output    *   everything below.    * * If there's no eol and we are in whitespace, we want to ignore    *   whitespace unconditionally. */
if|if
condition|(
operator|*
name|tgt
operator|==
name|tgt_newend
condition|)
block|{
comment|/* we haven't copied any data in to *tgt and our chunk consists          only of one block of (already normalized) data.          Just return the block. */
operator|*
name|tgt
operator|=
operator|(
name|char
operator|*
operator|)
name|start
expr_stmt|;
operator|*
name|lengthp
operator|=
name|include_len
expr_stmt|;
block|}
else|else
block|{
name|COPY_INCLUDED_SECTION
expr_stmt|;
operator|*
name|lengthp
operator|=
name|tgt_newend
operator|-
operator|*
name|tgt
expr_stmt|;
block|}
operator|*
name|statep
operator|=
name|state
expr_stmt|;
undef|#
directive|undef
name|SKIP
undef|#
directive|undef
name|INCLUDE
undef|#
directive|undef
name|INCLUDE_AS
undef|#
directive|undef
name|INSERT
undef|#
directive|undef
name|COPY_INCLUDED_SECTION
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff__unified_append_no_newline_msg
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|stringbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|header_encoding
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|out_str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
argument|&out_str
argument_list|,
argument|APR_EOL_STR             SVN_DIFF__NO_NEWLINE_AT_END_OF_FILE APR_EOL_STR
argument_list|,
argument|header_encoding
argument_list|,
argument|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|stringbuf
argument_list|,
name|out_str
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff__unified_write_hunk_header
parameter_list|(
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|,
specifier|const
name|char
modifier|*
name|header_encoding
parameter_list|,
specifier|const
name|char
modifier|*
name|hunk_delimiter
parameter_list|,
name|apr_off_t
name|old_start
parameter_list|,
name|apr_off_t
name|old_length
parameter_list|,
name|apr_off_t
name|new_start
parameter_list|,
name|apr_off_t
name|new_length
parameter_list|,
specifier|const
name|char
modifier|*
name|hunk_extra_context
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|output_stream
argument_list|,
name|header_encoding
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s -%"
name|APR_OFF_T_FMT
argument_list|,
name|hunk_delimiter
argument_list|,
name|old_start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the hunk length is 1, suppress the number of lines in the hunk    * (it is 1 implicitly) */
if|if
condition|(
name|old_length
operator|!=
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|output_stream
argument_list|,
name|header_encoding
argument_list|,
name|scratch_pool
argument_list|,
literal|",%"
name|APR_OFF_T_FMT
argument_list|,
name|old_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|output_stream
argument_list|,
name|header_encoding
argument_list|,
name|scratch_pool
argument_list|,
literal|" +%"
name|APR_OFF_T_FMT
argument_list|,
name|new_start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_length
operator|!=
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|output_stream
argument_list|,
name|header_encoding
argument_list|,
name|scratch_pool
argument_list|,
literal|",%"
name|APR_OFF_T_FMT
argument_list|,
name|new_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hunk_extra_context
operator|==
name|NULL
condition|)
name|hunk_extra_context
operator|=
literal|""
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|output_stream
argument_list|,
name|header_encoding
argument_list|,
name|scratch_pool
argument_list|,
literal|" %s%s%s"
name|APR_EOL_STR
argument_list|,
name|hunk_delimiter
argument_list|,
name|hunk_extra_context
index|[
literal|0
index|]
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|hunk_extra_context
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff__unidiff_write_header
parameter_list|(
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|,
specifier|const
name|char
modifier|*
name|header_encoding
parameter_list|,
specifier|const
name|char
modifier|*
name|old_header
parameter_list|,
specifier|const
name|char
modifier|*
name|new_header
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|output_stream
argument_list|,
name|header_encoding
argument_list|,
name|scratch_pool
argument_list|,
literal|"--- %s"
name|APR_EOL_STR
literal|"+++ %s"
name|APR_EOL_STR
argument_list|,
name|old_header
argument_list|,
name|new_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A helper function for display_prop_diffs.  Output the differences between    the mergeinfo stored in ORIG_MERGEINFO_VAL and NEW_MERGEINFO_VAL in a    human-readable form to OUTSTREAM, using ENCODING.  Use POOL for temporary    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|display_mergeinfo_diff
parameter_list|(
specifier|const
name|char
modifier|*
name|old_mergeinfo_val
parameter_list|,
specifier|const
name|char
modifier|*
name|new_mergeinfo_val
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|svn_stream_t
modifier|*
name|outstream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|old_mergeinfo_hash
decl_stmt|,
modifier|*
name|new_mergeinfo_hash
decl_stmt|,
modifier|*
name|added
decl_stmt|,
modifier|*
name|deleted
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
if|if
condition|(
name|old_mergeinfo_val
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|old_mergeinfo_hash
argument_list|,
name|old_mergeinfo_val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old_mergeinfo_hash
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|new_mergeinfo_val
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|new_mergeinfo_hash
argument_list|,
name|new_mergeinfo_val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_mergeinfo_hash
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_diff2
argument_list|(
operator|&
name|deleted
argument_list|,
operator|&
name|added
argument_list|,
name|old_mergeinfo_hash
argument_list|,
name|new_mergeinfo_hash
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|deleted
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|from_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|merge_revarray
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|merge_revstr
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_to_string
argument_list|(
operator|&
name|merge_revstr
argument_list|,
name|merge_revarray
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|outstream
argument_list|,
name|encoding
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"   Reverse-merged %s:r%s%s"
argument_list|)
argument_list|,
name|from_path
argument_list|,
name|merge_revstr
operator|->
name|data
argument_list|,
name|APR_EOL_STR
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|added
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|from_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|merge_revarray
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|merge_revstr
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_to_string
argument_list|(
operator|&
name|merge_revstr
argument_list|,
name|merge_revarray
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|outstream
argument_list|,
name|encoding
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"   Merged %s:r%s%s"
argument_list|)
argument_list|,
name|from_path
argument_list|,
name|merge_revstr
operator|->
name|data
argument_list|,
name|APR_EOL_STR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff__display_prop_diffs
parameter_list|(
name|svn_stream_t
modifier|*
name|outstream
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|propchanges
parameter_list|,
name|apr_hash_t
modifier|*
name|original_props
parameter_list|,
name|svn_boolean_t
name|pretty_print_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|propchanges
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|action
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|original_value
decl_stmt|;
specifier|const
name|svn_prop_t
modifier|*
name|propchange
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|propchanges
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|original_props
condition|)
name|original_value
operator|=
name|svn_hash_gets
argument_list|(
name|original_props
argument_list|,
name|propchange
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|original_value
operator|=
name|NULL
expr_stmt|;
comment|/* If the property doesn't exist on either side, or if it exists          with the same value, skip it.  This can happen if the client is          hitting an old mod_dav_svn server that doesn't understand the          "send-all" REPORT style. */
if|if
condition|(
operator|(
operator|!
operator|(
name|original_value
operator|||
name|propchange
operator|->
name|value
operator|)
operator|)
operator|||
operator|(
name|original_value
operator|&&
name|propchange
operator|->
name|value
operator|&&
name|svn_string_compare
argument_list|(
name|original_value
argument_list|,
name|propchange
operator|->
name|value
argument_list|)
operator|)
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|original_value
condition|)
name|action
operator|=
literal|"Added"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|propchange
operator|->
name|value
condition|)
name|action
operator|=
literal|"Deleted"
expr_stmt|;
else|else
name|action
operator|=
literal|"Modified"
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|outstream
argument_list|,
name|encoding
argument_list|,
name|iterpool
argument_list|,
literal|"%s: %s%s"
argument_list|,
name|action
argument_list|,
name|propchange
operator|->
name|name
argument_list|,
name|APR_EOL_STR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty_print_mergeinfo
operator|&&
name|strcmp
argument_list|(
name|propchange
operator|->
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|orig
init|=
name|original_value
condition|?
name|original_value
operator|->
name|data
else|:
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
init|=
name|propchange
operator|->
name|value
condition|?
name|propchange
operator|->
name|value
operator|->
name|data
else|:
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|display_mergeinfo_diff
argument_list|(
name|orig
argument_list|,
name|val
argument_list|,
name|encoding
argument_list|,
name|outstream
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
comment|/* Issue #3896: If we can't pretty-print mergeinfo differences              because invalid mergeinfo is present, then don't let the diff              fail, just print the diff as any other property. */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|{
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_diff_file_options_t
name|options
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|orig
init|=
name|original_value
condition|?
name|original_value
else|:
name|svn_string_create_empty
argument_list|(
name|iterpool
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|val
init|=
name|propchange
operator|->
name|value
condition|?
name|propchange
operator|->
name|value
else|:
name|svn_string_create_empty
argument_list|(
name|iterpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_mem_string_diff
argument_list|(
operator|&
name|diff
argument_list|,
name|orig
argument_list|,
name|val
argument_list|,
operator|&
name|options
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* UNIX patch will try to apply a diff even if the diff header          * is missing. It tries to be helpful by asking the user for a          * target filename when it can't determine the target filename          * from the diff header. But there usually are no files which          * UNIX patch could apply the property diff to, so we use "##"          * instead of "@@" as the default hunk delimiter for property diffs.          * We also supress the diff header. */
name|SVN_ERR
argument_list|(
name|svn_diff_mem_string_output_unified2
argument_list|(
name|outstream
argument_list|,
name|diff
argument_list|,
name|FALSE
comment|/* no header */
argument_list|,
literal|"##"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|encoding
argument_list|,
name|orig
argument_list|,
name|val
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the library version number. */
end_comment

begin_function
specifier|const
name|svn_version_t
modifier|*
name|svn_diff_version
parameter_list|(
name|void
parameter_list|)
block|{
name|SVN_VERSION_BODY
expr_stmt|;
block|}
end_function

end_unit

