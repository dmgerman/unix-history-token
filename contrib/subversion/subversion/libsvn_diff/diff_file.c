begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * diff_file.c :  routines for doing diffs on files  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|<apr_time.h>
end_include

begin_include
include|#
directive|include
file|<apr_mmap.h>
end_include

begin_include
include|#
directive|include
file|<apr_getopt.h>
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_eol_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_adler32.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_diff_private.h"
end_include

begin_comment
comment|/* A token, i.e. a line read from a file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|svn_diff__file_token_t
block|{
comment|/* Next token in free list. */
name|struct
name|svn_diff__file_token_t
modifier|*
name|next
decl_stmt|;
name|svn_diff_datasource_e
name|datasource
decl_stmt|;
comment|/* Offset in the datasource. */
name|apr_off_t
name|offset
decl_stmt|;
comment|/* Offset of the normalized token (may skip leading whitespace) */
name|apr_off_t
name|norm_offset
decl_stmt|;
comment|/* Total length - before normalization. */
name|apr_off_t
name|raw_length
decl_stmt|;
comment|/* Total length - after normalization. */
name|apr_off_t
name|length
decl_stmt|;
block|}
name|svn_diff__file_token_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|svn_diff__file_baton_t
block|{
specifier|const
name|svn_diff_file_options_t
modifier|*
name|options
decl_stmt|;
struct|struct
name|file_info
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* path to this file, absolute or relative to CWD */
comment|/* All the following fields are active while this datasource is open */
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* handle of this file */
name|apr_off_t
name|size
decl_stmt|;
comment|/* total raw size in bytes of this file */
comment|/* The current chunk: CHUNK_SIZE bytes except for the last chunk. */
name|int
name|chunk
decl_stmt|;
comment|/* the current chunk number, zero-based */
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* a buffer containing the current chunk */
name|char
modifier|*
name|curp
decl_stmt|;
comment|/* current position in the current chunk */
name|char
modifier|*
name|endp
decl_stmt|;
comment|/* next memory address after the current chunk */
name|svn_diff__normalize_state_t
name|normalize_state
decl_stmt|;
comment|/* Where the identical suffix starts in this datasource */
name|int
name|suffix_start_chunk
decl_stmt|;
name|apr_off_t
name|suffix_offset_in_chunk
decl_stmt|;
block|}
name|files
index|[
literal|4
index|]
struct|;
comment|/* List of free tokens that may be reused. */
name|svn_diff__file_token_t
modifier|*
name|tokens
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|svn_diff__file_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|datasource_to_index
parameter_list|(
name|svn_diff_datasource_e
name|datasource
parameter_list|)
block|{
switch|switch
condition|(
name|datasource
condition|)
block|{
case|case
name|svn_diff_datasource_original
case|:
return|return
literal|0
return|;
case|case
name|svn_diff_datasource_modified
case|:
return|return
literal|1
return|;
case|case
name|svn_diff_datasource_latest
case|:
return|return
literal|2
return|;
case|case
name|svn_diff_datasource_ancestor
case|:
return|return
literal|3
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Files are read in chunks of 128k.  There is no support for this number  * whatsoever.  If there is a number someone comes up with that has some  * argumentation, let's use that.  */
end_comment

begin_comment
comment|/* If you change this number, update test_norm_offset(),  * test_identical_suffix() and and test_token_compare()  in diff-diff3-test.c.  */
end_comment

begin_define
define|#
directive|define
name|CHUNK_SHIFT
value|17
end_define

begin_define
define|#
directive|define
name|CHUNK_SIZE
value|(1<< CHUNK_SHIFT)
end_define

begin_define
define|#
directive|define
name|chunk_to_offset
parameter_list|(
name|chunk
parameter_list|)
value|((chunk)<< CHUNK_SHIFT)
end_define

begin_define
define|#
directive|define
name|offset_to_chunk
parameter_list|(
name|offset
parameter_list|)
value|((offset)>> CHUNK_SHIFT)
end_define

begin_define
define|#
directive|define
name|offset_in_chunk
parameter_list|(
name|offset
parameter_list|)
value|((offset)& (CHUNK_SIZE - 1))
end_define

begin_comment
comment|/* Read a chunk from a FILE into BUFFER, starting from OFFSET, going for  * *LENGTH.  The actual bytes read are stored in *LENGTH on return.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|svn_error_t
modifier|*
name|read_chunk
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_off_t
name|length
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* XXX: The final offset may not be the one we asked for.    * XXX: Check.    */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
operator|(
name|apr_size_t
operator|)
name|length
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Map or read a file at PATH. *BUFFER will point to the file  * contents; if the file was mapped, *FILE and *MM will contain the  * mmap context; otherwise they will be NULL.  SIZE will contain the  * file size.  Allocate from POOL.  */
end_comment

begin_if
if|#
directive|if
name|APR_HAS_MMAP
end_if

begin_define
define|#
directive|define
name|MMAP_T_PARAM
parameter_list|(
name|NAME
parameter_list|)
value|apr_mmap_t **NAME,
end_define

begin_define
define|#
directive|define
name|MMAP_T_ARG
parameter_list|(
name|NAME
parameter_list|)
value|&(NAME),
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MMAP_T_PARAM
parameter_list|(
name|NAME
parameter_list|)
end_define

begin_define
define|#
directive|define
name|MMAP_T_ARG
parameter_list|(
name|NAME
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|svn_error_t
modifier|*
name|map_or_read_file
argument_list|(
name|apr_file_t
operator|*
operator|*
name|file
argument_list|,
name|MMAP_T_PARAM
argument_list|(
argument|mm
argument_list|)
name|char
operator|*
operator|*
name|buffer
argument_list|,
name|apr_size_t
operator|*
name|size_p
argument_list|,
specifier|const
name|char
operator|*
name|path
argument_list|,
name|apr_pool_t
operator|*
name|pool
argument_list|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
operator|*
name|buffer
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
name|file
argument_list|,
name|path
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_info_get
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
operator|*
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|size
operator|>
name|APR_SIZE_MAX
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|APR_ENOMEM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"File '%s' is too large to be read in "
literal|"to memory"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
name|size
operator|=
operator|(
name|apr_size_t
operator|)
name|finfo
operator|.
name|size
expr_stmt|;
if|#
directive|if
name|APR_HAS_MMAP
if|if
condition|(
name|size
operator|>
name|APR_MMAP_THRESHOLD
condition|)
block|{
name|rv
operator|=
name|apr_mmap_create
argument_list|(
name|mm
argument_list|,
operator|*
name|file
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|APR_MMAP_READ
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|APR_SUCCESS
condition|)
block|{
operator|*
name|buffer
operator|=
operator|(
operator|*
name|mm
operator|)
operator|->
name|mm
expr_stmt|;
block|}
else|else
block|{
comment|/* Clear *MM because output parameters are undefined on error. */
operator|*
name|mm
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* On failure we just fall through and try reading the file into        * memory instead.        */
block|}
endif|#
directive|endif
comment|/* APR_HAS_MMAP */
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
operator|*
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
operator|*
name|file
argument_list|,
operator|*
name|buffer
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since we have the entire contents of the file we can        * close it now.        */
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
operator|*
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|size_p
operator|=
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_decl_stmt

begin_comment
comment|/* For all files in the FILE array, increment the curp pointer.  If a file  * points before the beginning of file, let it point at the first byte again.  * If the end of the current chunk is reached, read the next chunk in the  * buffer and point curp to the start of the chunk.  If EOF is reached, set  * curp equal to endp to indicate EOF. */
end_comment

begin_define
define|#
directive|define
name|INCREMENT_POINTERS
parameter_list|(
name|all_files
parameter_list|,
name|files_len
parameter_list|,
name|pool
parameter_list|)
define|\
value|do {                                                                       \     apr_size_t svn_macro__i;                                                 \                                                                              \     for (svn_macro__i = 0; svn_macro__i< (files_len); svn_macro__i++)       \     {                                                                        \       if ((all_files)[svn_macro__i].curp< (all_files)[svn_macro__i].endp - 1)\         (all_files)[svn_macro__i].curp++;                                    \       else                                                                   \         SVN_ERR(increment_chunk(&(all_files)[svn_macro__i], (pool)));        \     }                                                                        \   } while (0)
end_define

begin_comment
comment|/* For all files in the FILE array, decrement the curp pointer.  If the  * start of a chunk is reached, read the previous chunk in the buffer and  * point curp to the last byte of the chunk.  If the beginning of a FILE is  * reached, set chunk to -1 to indicate BOF. */
end_comment

begin_define
define|#
directive|define
name|DECREMENT_POINTERS
parameter_list|(
name|all_files
parameter_list|,
name|files_len
parameter_list|,
name|pool
parameter_list|)
define|\
value|do {                                                                       \     apr_size_t svn_macro__i;                                                 \                                                                              \     for (svn_macro__i = 0; svn_macro__i< (files_len); svn_macro__i++)       \     {                                                                        \       if ((all_files)[svn_macro__i].curp> (all_files)[svn_macro__i].buffer) \         (all_files)[svn_macro__i].curp--;                                    \       else                                                                   \         SVN_ERR(decrement_chunk(&(all_files)[svn_macro__i], (pool)));        \     }                                                                        \   } while (0)
end_define

begin_function
specifier|static
name|svn_error_t
modifier|*
name|increment_chunk
parameter_list|(
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_off_t
name|length
decl_stmt|;
name|apr_off_t
name|last_chunk
init|=
name|offset_to_chunk
argument_list|(
name|file
operator|->
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|chunk
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* We are at BOF (Beginning Of File). Point to first chunk/byte again. */
name|file
operator|->
name|chunk
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|curp
operator|=
name|file
operator|->
name|buffer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|file
operator|->
name|chunk
operator|==
name|last_chunk
condition|)
block|{
comment|/* We are at the last chunk. Indicate EOF by setting curp == endp. */
name|file
operator|->
name|curp
operator|=
name|file
operator|->
name|endp
expr_stmt|;
block|}
else|else
block|{
comment|/* There are still chunks left. Read next chunk and reset pointers. */
name|file
operator|->
name|chunk
operator|++
expr_stmt|;
name|length
operator|=
name|file
operator|->
name|chunk
operator|==
name|last_chunk
condition|?
name|offset_in_chunk
argument_list|(
name|file
operator|->
name|size
argument_list|)
else|:
name|CHUNK_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_chunk
argument_list|(
name|file
operator|->
name|file
argument_list|,
name|file
operator|->
name|path
argument_list|,
name|file
operator|->
name|buffer
argument_list|,
name|length
argument_list|,
name|chunk_to_offset
argument_list|(
name|file
operator|->
name|chunk
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|endp
operator|=
name|file
operator|->
name|buffer
operator|+
name|length
expr_stmt|;
name|file
operator|->
name|curp
operator|=
name|file
operator|->
name|buffer
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|decrement_chunk
parameter_list|(
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|chunk
operator|==
literal|0
condition|)
block|{
comment|/* We are already at the first chunk. Indicate BOF (Beginning Of File)          by setting chunk = -1 and curp = endp - 1. Both conditions are          important. They help the increment step to catch the BOF situation          in an efficient way. */
name|file
operator|->
name|chunk
operator|--
expr_stmt|;
name|file
operator|->
name|curp
operator|=
name|file
operator|->
name|endp
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Read previous chunk and reset pointers. */
name|file
operator|->
name|chunk
operator|--
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_chunk
argument_list|(
name|file
operator|->
name|file
argument_list|,
name|file
operator|->
name|path
argument_list|,
name|file
operator|->
name|buffer
argument_list|,
name|CHUNK_SIZE
argument_list|,
name|chunk_to_offset
argument_list|(
name|file
operator|->
name|chunk
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|endp
operator|=
name|file
operator|->
name|buffer
operator|+
name|CHUNK_SIZE
expr_stmt|;
name|file
operator|->
name|curp
operator|=
name|file
operator|->
name|endp
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Check whether one of the FILEs has its pointers 'before' the beginning of  * the file (this can happen while scanning backwards). This is the case if  * one of them has chunk == -1. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_one_at_bof
parameter_list|(
name|struct
name|file_info
name|file
index|[]
parameter_list|,
name|apr_size_t
name|file_len
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|file
index|[
name|i
index|]
operator|.
name|chunk
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Check whether one of the FILEs has its pointers at EOF (this is the case if  * one of them has curp == endp (this can only happen at the last chunk)) */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_one_at_eof
parameter_list|(
name|struct
name|file_info
name|file
index|[]
parameter_list|,
name|apr_size_t
name|file_len
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|file
index|[
name|i
index|]
operator|.
name|curp
operator|==
name|file
index|[
name|i
index|]
operator|.
name|endp
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Quickly determine whether there is a eol char in CHUNK.  * (mainly copy-n-paste from eol.c#svn_eol__find_eol_start).  */
end_comment

begin_if
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
end_if

begin_function
specifier|static
name|svn_boolean_t
name|contains_eol
parameter_list|(
name|apr_uintptr_t
name|chunk
parameter_list|)
block|{
name|apr_uintptr_t
name|r_test
init|=
name|chunk
operator|^
name|SVN__R_MASK
decl_stmt|;
name|apr_uintptr_t
name|n_test
init|=
name|chunk
operator|^
name|SVN__N_MASK
decl_stmt|;
name|r_test
operator||=
operator|(
name|r_test
operator|&
name|SVN__LOWER_7BITS_SET
operator|)
operator|+
name|SVN__LOWER_7BITS_SET
expr_stmt|;
name|n_test
operator||=
operator|(
name|n_test
operator|&
name|SVN__LOWER_7BITS_SET
operator|)
operator|+
name|SVN__LOWER_7BITS_SET
expr_stmt|;
return|return
operator|(
name|r_test
operator|&
name|n_test
operator|&
name|SVN__BIT_7_SET
operator|)
operator|!=
name|SVN__BIT_7_SET
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Find the prefix which is identical between all elements of the FILE array.  * Return the number of prefix lines in PREFIX_LINES.  REACHED_ONE_EOF will be  * set to TRUE if one of the FILEs reached its end while scanning prefix,  * i.e. at least one file consisted entirely of prefix.  Otherwise,  * REACHED_ONE_EOF is set to FALSE.  *  * After this function is finished, the buffers, chunks, curp's and endp's  * of the FILEs are set to point at the first byte after the prefix. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_identical_prefix
parameter_list|(
name|svn_boolean_t
modifier|*
name|reached_one_eof
parameter_list|,
name|apr_off_t
modifier|*
name|prefix_lines
parameter_list|,
name|struct
name|file_info
name|file
index|[]
parameter_list|,
name|apr_size_t
name|file_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|had_cr
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|is_match
decl_stmt|;
name|apr_off_t
name|lines
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
operator|*
name|reached_one_eof
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|is_match
operator|=
name|TRUE
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
name|is_match
operator|=
name|is_match
operator|&&
operator|*
name|file
index|[
literal|0
index|]
operator|.
name|curp
operator|==
operator|*
name|file
index|[
name|i
index|]
operator|.
name|curp
expr_stmt|;
while|while
condition|(
name|is_match
condition|)
block|{
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
name|apr_ssize_t
name|max_delta
decl_stmt|,
name|delta
decl_stmt|;
endif|#
directive|endif
comment|/* SVN_UNALIGNED_ACCESS_IS_OK */
comment|/* ### TODO: see if we can take advantage of          diff options like ignore_eol_style or ignore_space. */
comment|/* check for eol, and count */
if|if
condition|(
operator|*
name|file
index|[
literal|0
index|]
operator|.
name|curp
operator|==
literal|'\r'
condition|)
block|{
name|lines
operator|++
expr_stmt|;
name|had_cr
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|file
index|[
literal|0
index|]
operator|.
name|curp
operator|==
literal|'\n'
operator|&&
operator|!
name|had_cr
condition|)
block|{
name|lines
operator|++
expr_stmt|;
block|}
else|else
block|{
name|had_cr
operator|=
name|FALSE
expr_stmt|;
block|}
name|INCREMENT_POINTERS
argument_list|(
name|file
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* Try to advance as far as possible with machine-word granularity.        * Determine how far we may advance with chunky ops without reaching        * endp for any of the files.        * Signedness is important here if curp gets close to endp.        */
name|max_delta
operator|=
name|file
index|[
literal|0
index|]
operator|.
name|endp
operator|-
name|file
index|[
literal|0
index|]
operator|.
name|curp
operator|-
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
block|{
name|delta
operator|=
name|file
index|[
name|i
index|]
operator|.
name|endp
operator|-
name|file
index|[
name|i
index|]
operator|.
name|curp
operator|-
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<
name|max_delta
condition|)
name|max_delta
operator|=
name|delta
expr_stmt|;
block|}
name|is_match
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|delta
operator|=
literal|0
init|;
name|delta
operator|<
name|max_delta
condition|;
name|delta
operator|+=
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
control|)
block|{
name|apr_uintptr_t
name|chunk
init|=
operator|*
operator|(
specifier|const
name|apr_uintptr_t
operator|*
operator|)
operator|(
name|file
index|[
literal|0
index|]
operator|.
name|curp
operator|+
name|delta
operator|)
decl_stmt|;
if|if
condition|(
name|contains_eol
argument_list|(
name|chunk
argument_list|)
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|chunk
operator|!=
operator|*
operator|(
specifier|const
name|apr_uintptr_t
operator|*
operator|)
operator|(
name|file
index|[
name|i
index|]
operator|.
name|curp
operator|+
name|delta
operator|)
condition|)
block|{
name|is_match
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|is_match
condition|)
break|break;
block|}
if|if
condition|(
name|delta
comment|/*> 0*/
condition|)
block|{
comment|/* We either found a mismatch or an EOL at or shortly behind curp+delta            * or we cannot proceed with chunky ops without exceeding endp.            * In any way, everything up to curp + delta is equal and not an EOL.            */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
name|file
index|[
name|i
index|]
operator|.
name|curp
operator|+=
name|delta
expr_stmt|;
comment|/* Skipped data without EOL markers, so last char was not a CR. */
name|had_cr
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|reached_one_eof
operator|=
name|is_one_at_eof
argument_list|(
name|file
argument_list|,
name|file_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reached_one_eof
condition|)
break|break;
else|else
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|is_match
operator|=
name|TRUE
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
name|is_match
operator|=
name|is_match
operator|&&
operator|*
name|file
index|[
literal|0
index|]
operator|.
name|curp
operator|==
operator|*
name|file
index|[
name|i
index|]
operator|.
name|curp
expr_stmt|;
block|}
if|if
condition|(
name|had_cr
condition|)
block|{
comment|/* Check if we ended in the middle of a \r\n for one file, but \r for          another. If so, back up one byte, so the next loop will back up          the entire line. Also decrement lines, since we counted one          too many for the \r. */
name|svn_boolean_t
name|ended_at_nonmatching_newline
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|file
index|[
name|i
index|]
operator|.
name|curp
operator|<
name|file
index|[
name|i
index|]
operator|.
name|endp
condition|)
name|ended_at_nonmatching_newline
operator|=
name|ended_at_nonmatching_newline
operator|||
operator|*
name|file
index|[
name|i
index|]
operator|.
name|curp
operator|==
literal|'\n'
expr_stmt|;
if|if
condition|(
name|ended_at_nonmatching_newline
condition|)
block|{
name|lines
operator|--
expr_stmt|;
name|DECREMENT_POINTERS
argument_list|(
name|file
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Back up one byte, so we point at the last identical byte */
name|DECREMENT_POINTERS
argument_list|(
name|file
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Back up to the last eol sequence (\n, \r\n or \r) */
while|while
condition|(
operator|!
name|is_one_at_bof
argument_list|(
name|file
argument_list|,
name|file_len
argument_list|)
operator|&&
operator|*
name|file
index|[
literal|0
index|]
operator|.
name|curp
operator|!=
literal|'\n'
operator|&&
operator|*
name|file
index|[
literal|0
index|]
operator|.
name|curp
operator|!=
literal|'\r'
condition|)
name|DECREMENT_POINTERS
argument_list|(
name|file
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Slide one byte forward, to point past the eol sequence */
name|INCREMENT_POINTERS
argument_list|(
name|file
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|prefix_lines
operator|=
name|lines
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The number of identical suffix lines to keep with the middle section. These  * lines are not eliminated as suffix, and can be picked up by the token  * parsing and lcs steps. This is mainly for backward compatibility with  * the previous diff (and blame) output (if there are multiple diff solutions,  * our lcs algorithm prefers taking common lines from the start, rather than  * from the end. By giving it back some suffix lines, we give it some wiggle  * room to find the exact same diff as before).  *  * The number 50 is more or less arbitrary, based on some real-world tests  * with big files (and then doubling the required number to be on the safe  * side). This has a negligible effect on the power of the optimization. */
end_comment

begin_comment
comment|/* If you change this number, update test_identical_suffix() in diff-diff3-test.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SUFFIX_LINES_TO_KEEP
end_ifndef

begin_define
define|#
directive|define
name|SUFFIX_LINES_TO_KEEP
value|50
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Find the suffix which is identical between all elements of the FILE array.  * Return the number of suffix lines in SUFFIX_LINES.  *  * Before this function is called the FILEs' pointers and chunks should be  * positioned right after the identical prefix (which is the case after  * find_identical_prefix), so we can determine where suffix scanning should  * ultimately stop. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_identical_suffix
parameter_list|(
name|apr_off_t
modifier|*
name|suffix_lines
parameter_list|,
name|struct
name|file_info
name|file
index|[]
parameter_list|,
name|apr_size_t
name|file_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_info
name|file_for_suffix
index|[
literal|4
index|]
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|apr_off_t
name|length
index|[
literal|4
index|]
decl_stmt|;
name|apr_off_t
name|suffix_min_chunk0
decl_stmt|;
name|apr_off_t
name|suffix_min_offset0
decl_stmt|;
name|apr_off_t
name|min_file_size
decl_stmt|;
name|int
name|suffix_lines_to_keep
init|=
name|SUFFIX_LINES_TO_KEEP
decl_stmt|;
name|svn_boolean_t
name|is_match
decl_stmt|;
name|apr_off_t
name|lines
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|had_cr
decl_stmt|;
name|svn_boolean_t
name|had_nl
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
comment|/* Initialize file_for_suffix[].      Read last chunk, position curp at last byte. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
block|{
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|path
operator|=
name|file
index|[
name|i
index|]
operator|.
name|path
expr_stmt|;
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|file
operator|=
name|file
index|[
name|i
index|]
operator|.
name|file
expr_stmt|;
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|size
operator|=
name|file
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|chunk
operator|=
operator|(
name|int
operator|)
name|offset_to_chunk
argument_list|(
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* last chunk */
name|length
index|[
name|i
index|]
operator|=
name|offset_in_chunk
argument_list|(
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
comment|/* last chunk is an empty chunk -> start at next-to-last chunk */
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|chunk
operator|=
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|chunk
operator|-
literal|1
expr_stmt|;
name|length
index|[
name|i
index|]
operator|=
name|CHUNK_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|chunk
operator|==
name|file
index|[
name|i
index|]
operator|.
name|chunk
condition|)
block|{
comment|/* Prefix ended in last chunk, so we can reuse the prefix buffer */
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|file
index|[
name|i
index|]
operator|.
name|buffer
expr_stmt|;
block|}
else|else
block|{
comment|/* There is at least more than 1 chunk,              so allocate full chunk size buffer */
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|CHUNK_SIZE
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_chunk
argument_list|(
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|file
argument_list|,
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|path
argument_list|,
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|buffer
argument_list|,
name|length
index|[
name|i
index|]
argument_list|,
name|chunk_to_offset
argument_list|(
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|chunk
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|endp
operator|=
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|buffer
operator|+
name|length
index|[
name|i
index|]
expr_stmt|;
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|curp
operator|=
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|endp
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Get the chunk and pointer offset (for file[0]) at which we should stop      scanning backward for the identical suffix, i.e. when we reach prefix. */
name|suffix_min_chunk0
operator|=
name|file
index|[
literal|0
index|]
operator|.
name|chunk
expr_stmt|;
name|suffix_min_offset0
operator|=
name|file
index|[
literal|0
index|]
operator|.
name|curp
operator|-
name|file
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
comment|/* Compensate if other files are smaller than file[0] */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|min_file_size
operator|=
name|file
index|[
literal|0
index|]
operator|.
name|size
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|file
index|[
name|i
index|]
operator|.
name|size
operator|<
name|min_file_size
condition|)
name|min_file_size
operator|=
name|file
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|.
name|size
operator|>
name|min_file_size
condition|)
block|{
name|suffix_min_chunk0
operator|+=
operator|(
name|file
index|[
literal|0
index|]
operator|.
name|size
operator|-
name|min_file_size
operator|)
operator|/
name|CHUNK_SIZE
expr_stmt|;
name|suffix_min_offset0
operator|+=
operator|(
name|file
index|[
literal|0
index|]
operator|.
name|size
operator|-
name|min_file_size
operator|)
operator|%
name|CHUNK_SIZE
expr_stmt|;
block|}
comment|/* Scan backwards until mismatch or until we reach the prefix. */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|is_match
operator|=
name|TRUE
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
name|is_match
operator|=
name|is_match
operator|&&
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|==
operator|*
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|curp
expr_stmt|;
if|if
condition|(
name|is_match
operator|&&
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|!=
literal|'\r'
operator|&&
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|!=
literal|'\n'
condition|)
comment|/* Count an extra line for the last line not ending in an eol. */
name|lines
operator|++
expr_stmt|;
name|had_nl
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|is_match
condition|)
block|{
name|svn_boolean_t
name|reached_prefix
decl_stmt|;
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* Initialize the minimum pointer positions. */
specifier|const
name|char
modifier|*
name|min_curp
index|[
literal|4
index|]
decl_stmt|;
name|svn_boolean_t
name|can_read_word
decl_stmt|;
endif|#
directive|endif
comment|/* SVN_UNALIGNED_ACCESS_IS_OK */
comment|/* ### TODO: see if we can take advantage of          diff options like ignore_eol_style or ignore_space. */
comment|/* check for eol, and count */
if|if
condition|(
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|==
literal|'\n'
condition|)
block|{
name|lines
operator|++
expr_stmt|;
name|had_nl
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|==
literal|'\r'
operator|&&
operator|!
name|had_nl
condition|)
block|{
name|lines
operator|++
expr_stmt|;
block|}
else|else
block|{
name|had_nl
operator|=
name|FALSE
expr_stmt|;
block|}
name|DECREMENT_POINTERS
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
name|min_curp
index|[
name|i
index|]
operator|=
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|buffer
expr_stmt|;
comment|/* If we are in the same chunk that contains the last part of the common          prefix, use the min_curp[0] pointer to make sure we don't get a          suffix that overlaps the already determined common prefix. */
if|if
condition|(
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|chunk
operator|==
name|suffix_min_chunk0
condition|)
name|min_curp
index|[
literal|0
index|]
operator|+=
name|suffix_min_offset0
expr_stmt|;
comment|/* Scan quickly by reading with machine-word granularity. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|can_read_word
operator|=
name|TRUE
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
name|can_read_word
operator|=
name|can_read_word
operator|&&
operator|(
operator|(
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|curp
operator|+
literal|1
operator|-
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
operator|)
operator|>
name|min_curp
index|[
name|i
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|can_read_word
condition|)
block|{
name|apr_uintptr_t
name|chunk
decl_stmt|;
comment|/* For each file curp is positioned at the current byte, but we              want to examine the current byte and the ones before the current              location as one machine word. */
name|chunk
operator|=
operator|*
operator|(
specifier|const
name|apr_uintptr_t
operator|*
operator|)
operator|(
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|+
literal|1
operator|-
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|contains_eol
argument_list|(
name|chunk
argument_list|)
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|is_match
operator|=
name|TRUE
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
name|is_match
operator|=
name|is_match
operator|&&
operator|(
name|chunk
operator|==
operator|*
operator|(
specifier|const
name|apr_uintptr_t
operator|*
operator|)
operator|(
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|curp
operator|+
literal|1
operator|-
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_match
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
block|{
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|curp
operator|-=
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
expr_stmt|;
name|can_read_word
operator|=
name|can_read_word
operator|&&
operator|(
operator|(
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|curp
operator|+
literal|1
operator|-
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
operator|)
operator|>
name|min_curp
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
comment|/* We skipped some bytes, so there are no closing EOLs */
name|had_nl
operator|=
name|FALSE
expr_stmt|;
name|had_cr
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* The> min_curp[i] check leaves at least one final byte for checking          in the non block optimized case below. */
endif|#
directive|endif
name|reached_prefix
operator|=
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|chunk
operator|==
name|suffix_min_chunk0
operator|&&
operator|(
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|-
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|buffer
operator|)
operator|==
name|suffix_min_offset0
expr_stmt|;
if|if
condition|(
name|reached_prefix
operator|||
name|is_one_at_bof
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|)
condition|)
break|break;
name|is_match
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
name|is_match
operator|=
name|is_match
operator|&&
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|==
operator|*
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|curp
expr_stmt|;
block|}
comment|/* Slide one byte forward, to point at the first byte of identical suffix */
name|INCREMENT_POINTERS
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Slide forward until we find an eol sequence to add the rest of the line      we're in. Then add SUFFIX_LINES_TO_KEEP more lines. Stop if at least      one file reaches its end. */
do|do
block|{
name|had_cr
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|is_one_at_eof
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|)
operator|&&
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|!=
literal|'\n'
operator|&&
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|!=
literal|'\r'
condition|)
name|INCREMENT_POINTERS
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Slide one or two more bytes, to point past the eol. */
if|if
condition|(
operator|!
name|is_one_at_eof
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|)
operator|&&
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|==
literal|'\r'
condition|)
block|{
name|lines
operator|--
expr_stmt|;
name|had_cr
operator|=
name|TRUE
expr_stmt|;
name|INCREMENT_POINTERS
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_one_at_eof
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|)
operator|&&
operator|*
name|file_for_suffix
index|[
literal|0
index|]
operator|.
name|curp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|had_cr
condition|)
name|lines
operator|--
expr_stmt|;
name|INCREMENT_POINTERS
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|is_one_at_eof
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|)
operator|&&
name|suffix_lines_to_keep
operator|--
condition|)
do|;
if|if
condition|(
name|is_one_at_eof
argument_list|(
name|file_for_suffix
argument_list|,
name|file_len
argument_list|)
condition|)
name|lines
operator|=
literal|0
expr_stmt|;
comment|/* Save the final suffix information in the original file_info */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_len
condition|;
name|i
operator|++
control|)
block|{
name|file
index|[
name|i
index|]
operator|.
name|suffix_start_chunk
operator|=
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|chunk
expr_stmt|;
name|file
index|[
name|i
index|]
operator|.
name|suffix_offset_in_chunk
operator|=
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|curp
operator|-
name|file_for_suffix
index|[
name|i
index|]
operator|.
name|buffer
expr_stmt|;
block|}
operator|*
name|suffix_lines
operator|=
name|lines
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Let FILE stand for the array of file_info struct elements of BATON->files  * that are indexed by the elements of the DATASOURCE array.  * BATON's type is (svn_diff__file_baton_t *).  *  * For each file in the FILE array, open the file at FILE.path; initialize  * FILE.file, FILE.size, FILE.buffer, FILE.curp and FILE.endp; allocate a  * buffer and read the first chunk.  Then find the prefix and suffix lines  * which are identical between all the files.  Return the number of identical  * prefix lines in PREFIX_LINES, and the number of identical suffix lines in  * SUFFIX_LINES.  *  * Finding the identical prefix and suffix allows us to exclude those from the  * rest of the diff algorithm, which increases performance by reducing the  * problem space.  *  * Implements svn_diff_fns2_t::datasources_open. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|datasources_open
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|prefix_lines
parameter_list|,
name|apr_off_t
modifier|*
name|suffix_lines
parameter_list|,
specifier|const
name|svn_diff_datasource_e
modifier|*
name|datasources
parameter_list|,
name|apr_size_t
name|datasources_len
parameter_list|)
block|{
name|svn_diff__file_baton_t
modifier|*
name|file_baton
init|=
name|baton
decl_stmt|;
name|struct
name|file_info
name|files
index|[
literal|4
index|]
decl_stmt|;
name|apr_finfo_t
name|finfo
index|[
literal|4
index|]
decl_stmt|;
name|apr_off_t
name|length
index|[
literal|4
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|SVN_DISABLE_PREFIX_SUFFIX_SCANNING
name|svn_boolean_t
name|reached_one_eof
decl_stmt|;
endif|#
directive|endif
name|apr_size_t
name|i
decl_stmt|;
comment|/* Make sure prefix_lines and suffix_lines are set correctly, even if we    * exit early because one of the files is empty. */
operator|*
name|prefix_lines
operator|=
literal|0
expr_stmt|;
operator|*
name|suffix_lines
operator|=
literal|0
expr_stmt|;
comment|/* Open datasources and read first chunk */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datasources_len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|file_info
modifier|*
name|file
init|=
operator|&
name|file_baton
operator|->
name|files
index|[
name|datasource_to_index
argument_list|(
name|datasources
index|[
name|i
index|]
argument_list|)
index|]
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
operator|->
name|file
argument_list|,
name|file
operator|->
name|path
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|file_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_info_get
argument_list|(
operator|&
name|finfo
index|[
name|i
index|]
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|file
operator|->
name|file
argument_list|,
name|file_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|size
operator|=
name|finfo
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|length
index|[
name|i
index|]
operator|=
name|finfo
index|[
name|i
index|]
operator|.
name|size
operator|>
name|CHUNK_SIZE
condition|?
name|CHUNK_SIZE
else|:
name|finfo
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|file
operator|->
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|file_baton
operator|->
name|pool
argument_list|,
operator|(
name|apr_size_t
operator|)
name|length
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_chunk
argument_list|(
name|file
operator|->
name|file
argument_list|,
name|file
operator|->
name|path
argument_list|,
name|file
operator|->
name|buffer
argument_list|,
name|length
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|file_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|endp
operator|=
name|file
operator|->
name|buffer
operator|+
name|length
index|[
name|i
index|]
expr_stmt|;
name|file
operator|->
name|curp
operator|=
name|file
operator|->
name|buffer
expr_stmt|;
comment|/* Set suffix_start_chunk to a guard value, so if suffix scanning is        * skipped because one of the files is empty, or because of        * reached_one_eof, we can still easily check for the suffix during        * token reading (datasource_get_next_token). */
name|file
operator|->
name|suffix_start_chunk
operator|=
operator|-
literal|1
expr_stmt|;
name|files
index|[
name|i
index|]
operator|=
operator|*
name|file
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datasources_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|length
index|[
name|i
index|]
operator|==
literal|0
condition|)
comment|/* There will not be any identical prefix/suffix, so we're done. */
return|return
name|SVN_NO_ERROR
return|;
ifndef|#
directive|ifndef
name|SVN_DISABLE_PREFIX_SUFFIX_SCANNING
name|SVN_ERR
argument_list|(
name|find_identical_prefix
argument_list|(
operator|&
name|reached_one_eof
argument_list|,
name|prefix_lines
argument_list|,
name|files
argument_list|,
name|datasources_len
argument_list|,
name|file_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reached_one_eof
condition|)
comment|/* No file consisted totally of identical prefix,      * so there may be some identical suffix.  */
name|SVN_ERR
argument_list|(
name|find_identical_suffix
argument_list|(
name|suffix_lines
argument_list|,
name|files
argument_list|,
name|datasources_len
argument_list|,
name|file_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Copy local results back to baton. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datasources_len
condition|;
name|i
operator|++
control|)
name|file_baton
operator|->
name|files
index|[
name|datasource_to_index
argument_list|(
name|datasources
index|[
name|i
index|]
argument_list|)
index|]
operator|=
name|files
index|[
name|i
index|]
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::datasource_close */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|datasource_close
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_diff_datasource_e
name|datasource
parameter_list|)
block|{
comment|/* Do nothing.  The compare_token function needs previous datasources    * to stay available until all datasources are processed.    */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::datasource_get_next_token */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|datasource_get_next_token
parameter_list|(
name|apr_uint32_t
modifier|*
name|hash
parameter_list|,
name|void
modifier|*
modifier|*
name|token
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_diff_datasource_e
name|datasource
parameter_list|)
block|{
name|svn_diff__file_baton_t
modifier|*
name|file_baton
init|=
name|baton
decl_stmt|;
name|svn_diff__file_token_t
modifier|*
name|file_token
decl_stmt|;
name|struct
name|file_info
modifier|*
name|file
init|=
operator|&
name|file_baton
operator|->
name|files
index|[
name|datasource_to_index
argument_list|(
name|datasource
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|curp
decl_stmt|;
name|char
modifier|*
name|eol
decl_stmt|;
name|apr_off_t
name|last_chunk
decl_stmt|;
name|apr_off_t
name|length
decl_stmt|;
name|apr_uint32_t
name|h
init|=
literal|0
decl_stmt|;
comment|/* Did the last chunk end in a CR character? */
name|svn_boolean_t
name|had_cr
init|=
name|FALSE
decl_stmt|;
operator|*
name|token
operator|=
name|NULL
expr_stmt|;
name|curp
operator|=
name|file
operator|->
name|curp
expr_stmt|;
name|endp
operator|=
name|file
operator|->
name|endp
expr_stmt|;
name|last_chunk
operator|=
name|offset_to_chunk
argument_list|(
name|file
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Are we already at the end of a chunk? */
if|if
condition|(
name|curp
operator|==
name|endp
condition|)
block|{
comment|/* Are we at EOF */
if|if
condition|(
name|last_chunk
operator|==
name|file
operator|->
name|chunk
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* EOF */
comment|/* Or right before an identical suffix in the next chunk? */
if|if
condition|(
name|file
operator|->
name|chunk
operator|+
literal|1
operator|==
name|file
operator|->
name|suffix_start_chunk
operator|&&
name|file
operator|->
name|suffix_offset_in_chunk
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Stop when we encounter the identical suffix. If suffix scanning was not    * performed, suffix_start_chunk will be -1, so this condition will never    * be true. */
if|if
condition|(
name|file
operator|->
name|chunk
operator|==
name|file
operator|->
name|suffix_start_chunk
operator|&&
operator|(
name|curp
operator|-
name|file
operator|->
name|buffer
operator|)
operator|==
name|file
operator|->
name|suffix_offset_in_chunk
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Allocate a new token, or fetch one from the "reusable tokens" list. */
name|file_token
operator|=
name|file_baton
operator|->
name|tokens
expr_stmt|;
if|if
condition|(
name|file_token
condition|)
block|{
name|file_baton
operator|->
name|tokens
operator|=
name|file_token
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|file_token
operator|=
name|apr_palloc
argument_list|(
name|file_baton
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file_token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|file_token
operator|->
name|datasource
operator|=
name|datasource
expr_stmt|;
name|file_token
operator|->
name|offset
operator|=
name|chunk_to_offset
argument_list|(
name|file
operator|->
name|chunk
argument_list|)
operator|+
operator|(
name|curp
operator|-
name|file
operator|->
name|buffer
operator|)
expr_stmt|;
name|file_token
operator|->
name|norm_offset
operator|=
name|file_token
operator|->
name|offset
expr_stmt|;
name|file_token
operator|->
name|raw_length
operator|=
literal|0
expr_stmt|;
name|file_token
operator|->
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|eol
operator|=
name|svn_eol__find_eol_start
argument_list|(
name|curp
argument_list|,
name|endp
operator|-
name|curp
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol
condition|)
block|{
name|had_cr
operator|=
operator|(
operator|*
name|eol
operator|==
literal|'\r'
operator|)
expr_stmt|;
name|eol
operator|++
expr_stmt|;
comment|/* If we have the whole eol sequence in the chunk... */
if|if
condition|(
operator|!
operator|(
name|had_cr
operator|&&
name|eol
operator|==
name|endp
operator|)
condition|)
block|{
comment|/* Also skip past the '\n' in an '\r\n' sequence. */
if|if
condition|(
name|had_cr
operator|&&
operator|*
name|eol
operator|==
literal|'\n'
condition|)
name|eol
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|file
operator|->
name|chunk
operator|==
name|last_chunk
condition|)
block|{
name|eol
operator|=
name|endp
expr_stmt|;
break|break;
block|}
name|length
operator|=
name|endp
operator|-
name|curp
expr_stmt|;
name|file_token
operator|->
name|raw_length
operator|+=
name|length
expr_stmt|;
block|{
name|char
modifier|*
name|c
init|=
name|curp
decl_stmt|;
name|svn_diff__normalize_buffer
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|file
operator|->
name|normalize_state
argument_list|,
name|curp
argument_list|,
name|file_baton
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_token
operator|->
name|length
operator|==
literal|0
condition|)
block|{
comment|/* When we are reading the first part of the token, move the                normalized offset past leading ignored characters, if any. */
name|file_token
operator|->
name|norm_offset
operator|+=
operator|(
name|c
operator|-
name|curp
operator|)
expr_stmt|;
block|}
name|file_token
operator|->
name|length
operator|+=
name|length
expr_stmt|;
name|h
operator|=
name|svn__adler32
argument_list|(
name|h
argument_list|,
name|c
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|curp
operator|=
name|endp
operator|=
name|file
operator|->
name|buffer
expr_stmt|;
name|file
operator|->
name|chunk
operator|++
expr_stmt|;
name|length
operator|=
name|file
operator|->
name|chunk
operator|==
name|last_chunk
condition|?
name|offset_in_chunk
argument_list|(
name|file
operator|->
name|size
argument_list|)
else|:
name|CHUNK_SIZE
expr_stmt|;
name|endp
operator|+=
name|length
expr_stmt|;
name|file
operator|->
name|endp
operator|=
name|endp
expr_stmt|;
comment|/* Issue #4283: Normally we should have checked for reaching the skipped          suffix here, but because we assume that a suffix always starts on a          line and token boundary we rely on catching the suffix earlier in this          function.           When changing things here, make sure the whitespace settings are          applied, or we mught not reach the exact suffix boundary as token          boundary. */
name|SVN_ERR
argument_list|(
name|read_chunk
argument_list|(
name|file
operator|->
name|file
argument_list|,
name|file
operator|->
name|path
argument_list|,
name|curp
argument_list|,
name|length
argument_list|,
name|chunk_to_offset
argument_list|(
name|file
operator|->
name|chunk
argument_list|)
argument_list|,
name|file_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the last chunk ended in a CR, we're done. */
if|if
condition|(
name|had_cr
condition|)
block|{
name|eol
operator|=
name|curp
expr_stmt|;
if|if
condition|(
operator|*
name|curp
operator|==
literal|'\n'
condition|)
operator|++
name|eol
expr_stmt|;
break|break;
block|}
block|}
name|length
operator|=
name|eol
operator|-
name|curp
expr_stmt|;
name|file_token
operator|->
name|raw_length
operator|+=
name|length
expr_stmt|;
name|file
operator|->
name|curp
operator|=
name|eol
expr_stmt|;
comment|/* If the file length is exactly a multiple of CHUNK_SIZE, we will end up    * with a spurious empty token.  Avoid returning it.    * Note that we use the unnormalized length; we don't want a line containing    * only spaces (and no trailing newline) to appear like a non-existent    * line. */
if|if
condition|(
name|file_token
operator|->
name|raw_length
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|c
init|=
name|curp
decl_stmt|;
name|svn_diff__normalize_buffer
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|file
operator|->
name|normalize_state
argument_list|,
name|curp
argument_list|,
name|file_baton
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_token
operator|->
name|length
operator|==
literal|0
condition|)
block|{
comment|/* When we are reading the first part of the token, move the              normalized offset past leading ignored characters, if any. */
name|file_token
operator|->
name|norm_offset
operator|+=
operator|(
name|c
operator|-
name|curp
operator|)
expr_stmt|;
block|}
name|file_token
operator|->
name|length
operator|+=
name|length
expr_stmt|;
operator|*
name|hash
operator|=
name|svn__adler32
argument_list|(
name|h
argument_list|,
name|c
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|*
name|token
operator|=
name|file_token
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_define
define|#
directive|define
name|COMPARE_CHUNK_SIZE
value|4096
end_define

begin_comment
comment|/* Implements svn_diff_fns2_t::token_compare */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|token_compare
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|void
modifier|*
name|token1
parameter_list|,
name|void
modifier|*
name|token2
parameter_list|,
name|int
modifier|*
name|compare
parameter_list|)
block|{
name|svn_diff__file_baton_t
modifier|*
name|file_baton
init|=
name|baton
decl_stmt|;
name|svn_diff__file_token_t
modifier|*
name|file_token
index|[
literal|2
index|]
decl_stmt|;
name|char
name|buffer
index|[
literal|2
index|]
index|[
name|COMPARE_CHUNK_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|bufp
index|[
literal|2
index|]
decl_stmt|;
name|apr_off_t
name|offset
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|file_info
modifier|*
name|file
index|[
literal|2
index|]
decl_stmt|;
name|apr_off_t
name|length
index|[
literal|2
index|]
decl_stmt|;
name|apr_off_t
name|total_length
decl_stmt|;
comment|/* How much is left to read of each token from the file. */
name|apr_off_t
name|raw_length
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_diff__normalize_state_t
name|state
index|[
literal|2
index|]
decl_stmt|;
name|file_token
index|[
literal|0
index|]
operator|=
name|token1
expr_stmt|;
name|file_token
index|[
literal|1
index|]
operator|=
name|token2
expr_stmt|;
if|if
condition|(
name|file_token
index|[
literal|0
index|]
operator|->
name|length
operator|<
name|file_token
index|[
literal|1
index|]
operator|->
name|length
condition|)
block|{
operator|*
name|compare
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|file_token
index|[
literal|0
index|]
operator|->
name|length
operator|>
name|file_token
index|[
literal|1
index|]
operator|->
name|length
condition|)
block|{
operator|*
name|compare
operator|=
literal|1
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|total_length
operator|=
name|file_token
index|[
literal|0
index|]
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|total_length
operator|==
literal|0
condition|)
block|{
operator|*
name|compare
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|int
name|idx
init|=
name|datasource_to_index
argument_list|(
name|file_token
index|[
name|i
index|]
operator|->
name|datasource
argument_list|)
decl_stmt|;
name|file
index|[
name|i
index|]
operator|=
operator|&
name|file_baton
operator|->
name|files
index|[
name|idx
index|]
expr_stmt|;
name|offset
index|[
name|i
index|]
operator|=
name|file_token
index|[
name|i
index|]
operator|->
name|norm_offset
expr_stmt|;
name|state
index|[
name|i
index|]
operator|=
name|svn_diff__normalize_state_normal
expr_stmt|;
if|if
condition|(
name|offset_to_chunk
argument_list|(
name|offset
index|[
name|i
index|]
argument_list|)
operator|==
name|file
index|[
name|i
index|]
operator|->
name|chunk
condition|)
block|{
comment|/* If the start of the token is in memory, the entire token is            * in memory.            */
name|bufp
index|[
name|i
index|]
operator|=
name|file
index|[
name|i
index|]
operator|->
name|buffer
expr_stmt|;
name|bufp
index|[
name|i
index|]
operator|+=
name|offset_in_chunk
argument_list|(
name|offset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|length
index|[
name|i
index|]
operator|=
name|total_length
expr_stmt|;
name|raw_length
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|apr_off_t
name|skipped
decl_stmt|;
name|length
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* When we skipped the first part of the token via the whitespace              normalization we must reduce the raw length of the token */
name|skipped
operator|=
operator|(
name|file_token
index|[
name|i
index|]
operator|->
name|norm_offset
operator|-
name|file_token
index|[
name|i
index|]
operator|->
name|offset
operator|)
expr_stmt|;
name|raw_length
index|[
name|i
index|]
operator|=
name|file_token
index|[
name|i
index|]
operator|->
name|raw_length
operator|-
name|skipped
expr_stmt|;
block|}
block|}
do|do
block|{
name|apr_off_t
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|length
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Error if raw_length is 0, that's an unexpected change                * of the file that can happen when ingoring whitespace                * and that can lead to an infinite loop. */
if|if
condition|(
name|raw_length
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_DIFF_DATASOURCE_MODIFIED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The file '%s' changed unexpectedly"
literal|" during diff"
argument_list|)
argument_list|,
name|file
index|[
name|i
index|]
operator|->
name|path
argument_list|)
return|;
comment|/* Read a chunk from disk into a buffer */
name|bufp
index|[
name|i
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
name|length
index|[
name|i
index|]
operator|=
name|raw_length
index|[
name|i
index|]
operator|>
name|COMPARE_CHUNK_SIZE
condition|?
name|COMPARE_CHUNK_SIZE
else|:
name|raw_length
index|[
name|i
index|]
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_chunk
argument_list|(
name|file
index|[
name|i
index|]
operator|->
name|file
argument_list|,
name|file
index|[
name|i
index|]
operator|->
name|path
argument_list|,
name|bufp
index|[
name|i
index|]
argument_list|,
name|length
index|[
name|i
index|]
argument_list|,
name|offset
index|[
name|i
index|]
argument_list|,
name|file_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
index|[
name|i
index|]
operator|+=
name|length
index|[
name|i
index|]
expr_stmt|;
name|raw_length
index|[
name|i
index|]
operator|-=
name|length
index|[
name|i
index|]
expr_stmt|;
comment|/* bufp[i] gets reset to buffer[i] before reading each chunk,                  so, overwriting it isn't a problem */
name|svn_diff__normalize_buffer
argument_list|(
operator|&
name|bufp
index|[
name|i
index|]
argument_list|,
operator|&
name|length
index|[
name|i
index|]
argument_list|,
operator|&
name|state
index|[
name|i
index|]
argument_list|,
name|bufp
index|[
name|i
index|]
argument_list|,
name|file_baton
operator|->
name|options
argument_list|)
expr_stmt|;
comment|/* assert(length[i] == file_token[i]->length); */
block|}
block|}
name|len
operator|=
name|length
index|[
literal|0
index|]
operator|>
name|length
index|[
literal|1
index|]
condition|?
name|length
index|[
literal|1
index|]
else|:
name|length
index|[
literal|0
index|]
expr_stmt|;
comment|/* Compare two chunks (that could be entire tokens if they both reside        * in memory).        */
operator|*
name|compare
operator|=
name|memcmp
argument_list|(
name|bufp
index|[
literal|0
index|]
argument_list|,
name|bufp
index|[
literal|1
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|compare
operator|!=
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|total_length
operator|-=
name|len
expr_stmt|;
name|length
index|[
literal|0
index|]
operator|-=
name|len
expr_stmt|;
name|length
index|[
literal|1
index|]
operator|-=
name|len
expr_stmt|;
name|bufp
index|[
literal|0
index|]
operator|+=
name|len
expr_stmt|;
name|bufp
index|[
literal|1
index|]
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|total_length
operator|>
literal|0
condition|)
do|;
operator|*
name|compare
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::token_discard */
end_comment

begin_function
specifier|static
name|void
name|token_discard
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|void
modifier|*
name|token
parameter_list|)
block|{
name|svn_diff__file_baton_t
modifier|*
name|file_baton
init|=
name|baton
decl_stmt|;
name|svn_diff__file_token_t
modifier|*
name|file_token
init|=
name|token
decl_stmt|;
comment|/* Prepend FILE_TOKEN to FILE_BATON->TOKENS, for reuse. */
name|file_token
operator|->
name|next
operator|=
name|file_baton
operator|->
name|tokens
expr_stmt|;
name|file_baton
operator|->
name|tokens
operator|=
name|file_token
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::token_discard_all */
end_comment

begin_function
specifier|static
name|void
name|token_discard_all
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|svn_diff__file_baton_t
modifier|*
name|file_baton
init|=
name|baton
decl_stmt|;
comment|/* Discard all memory in use by the tokens, and close all open files. */
name|svn_pool_clear
argument_list|(
name|file_baton
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_diff_fns2_t
name|svn_diff__file_vtable
init|=
block|{
name|datasources_open
block|,
name|datasource_close
block|,
name|datasource_get_next_token
block|,
name|token_compare
block|,
name|token_discard
block|,
name|token_discard_all
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Id for the --ignore-eol-style option, which doesn't have a short name. */
end_comment

begin_define
define|#
directive|define
name|SVN_DIFF__OPT_IGNORE_EOL_STYLE
value|256
end_define

begin_comment
comment|/* Options supported by svn_diff_file_options_parse(). */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|apr_getopt_option_t
name|diff_options
index|[]
init|=
block|{
block|{
literal|"ignore-space-change"
block|,
literal|'b'
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ignore-all-space"
block|,
literal|'w'
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ignore-eol-style"
block|,
name|SVN_DIFF__OPT_IGNORE_EOL_STYLE
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"show-c-function"
block|,
literal|'p'
block|,
literal|0
block|,
name|NULL
block|}
block|,
comment|/* ### For compatibility; we don't support the argument to -u, because    * ### we don't have optional argument support. */
block|{
literal|"unified"
block|,
literal|'u'
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_diff_file_options_t
modifier|*
name|svn_diff_file_options_create
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_diff_file_options_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A baton for use with opt_parsing_error_func(). */
end_comment

begin_struct
struct|struct
name|opt_parsing_error_baton_t
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Store an error message from apr_getopt_long().  Set BATON->err to a new  * error with a message generated from FMT and the remaining arguments.  * Implements apr_getopt_err_fn_t. */
end_comment

begin_function
specifier|static
name|void
name|opt_parsing_error_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|opt_parsing_error_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* Skip leading ": " (if present, which it always is in known cases). */
if|if
condition|(
name|strncmp
argument_list|(
name|message
argument_list|,
literal|": "
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|message
operator|+=
literal|2
expr_stmt|;
name|b
operator|->
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_INVALID_DIFF_OPTION
argument_list|,
name|NULL
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_file_options_parse
parameter_list|(
name|svn_diff_file_options_t
modifier|*
name|options
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|args
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
name|struct
name|opt_parsing_error_baton_t
name|opt_parsing_error_baton
decl_stmt|;
comment|/* Make room for each option (starting at index 1) plus trailing NULL. */
specifier|const
name|char
modifier|*
modifier|*
name|argv
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|args
operator|->
name|nelts
operator|+
literal|2
operator|)
argument_list|)
decl_stmt|;
name|opt_parsing_error_baton
operator|.
name|err
operator|=
name|NULL
expr_stmt|;
name|opt_parsing_error_baton
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
literal|""
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|argv
operator|+
literal|1
operator|)
argument_list|,
name|args
operator|->
name|elts
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|args
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|argv
index|[
name|args
operator|->
name|nelts
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|apr_getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|pool
argument_list|,
name|args
operator|->
name|nelts
operator|+
literal|1
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Capture any error message from apr_getopt_long().  This will typically    * say which option is wrong, which we would not otherwise know. */
name|os
operator|->
name|errfn
operator|=
name|opt_parsing_error_func
expr_stmt|;
name|os
operator|->
name|errarg
operator|=
operator|&
name|opt_parsing_error_baton
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
name|int
name|opt_id
decl_stmt|;
name|apr_status_t
name|err
init|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|diff_options
argument_list|,
operator|&
name|opt_id
argument_list|,
operator|&
name|opt_arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|err
argument_list|)
condition|)
break|break;
if|if
condition|(
name|err
condition|)
comment|/* Wrap apr_getopt_long()'s error message.  Its doc string implies          * it always will produce one, but never mind if it doesn't.  Avoid          * using the message associated with the return code ERR, because          * it refers to the "command line" which may be misleading here. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INVALID_DIFF_OPTION
argument_list|,
name|opt_parsing_error_baton
operator|.
name|err
argument_list|,
name|_
argument_list|(
literal|"Error in options to internal diff"
argument_list|)
argument_list|)
return|;
switch|switch
condition|(
name|opt_id
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* -w takes precedence over -b. */
if|if
condition|(
operator|!
name|options
operator|->
name|ignore_space
condition|)
name|options
operator|->
name|ignore_space
operator|=
name|svn_diff_file_ignore_space_change
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|options
operator|->
name|ignore_space
operator|=
name|svn_diff_file_ignore_space_all
expr_stmt|;
break|break;
case|case
name|SVN_DIFF__OPT_IGNORE_EOL_STYLE
case|:
name|options
operator|->
name|ignore_eol_style
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|options
operator|->
name|show_c_function
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Check for spurious arguments. */
if|if
condition|(
name|os
operator|->
name|ind
operator|<
name|os
operator|->
name|argc
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INVALID_DIFF_OPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid argument '%s' in diff options"
argument_list|)
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
index|]
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_file_diff_2
parameter_list|(
name|svn_diff_t
modifier|*
modifier|*
name|diff
parameter_list|,
specifier|const
name|char
modifier|*
name|original
parameter_list|,
specifier|const
name|char
modifier|*
name|modified
parameter_list|,
specifier|const
name|svn_diff_file_options_t
modifier|*
name|options
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff__file_baton_t
name|baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|baton
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|baton
operator|.
name|files
index|[
literal|0
index|]
operator|.
name|path
operator|=
name|original
expr_stmt|;
name|baton
operator|.
name|files
index|[
literal|1
index|]
operator|.
name|path
operator|=
name|modified
expr_stmt|;
name|baton
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_diff_2
argument_list|(
name|diff
argument_list|,
operator|&
name|baton
argument_list|,
operator|&
name|svn_diff__file_vtable
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|baton
operator|.
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_file_diff3_2
parameter_list|(
name|svn_diff_t
modifier|*
modifier|*
name|diff
parameter_list|,
specifier|const
name|char
modifier|*
name|original
parameter_list|,
specifier|const
name|char
modifier|*
name|modified
parameter_list|,
specifier|const
name|char
modifier|*
name|latest
parameter_list|,
specifier|const
name|svn_diff_file_options_t
modifier|*
name|options
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff__file_baton_t
name|baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|baton
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|baton
operator|.
name|files
index|[
literal|0
index|]
operator|.
name|path
operator|=
name|original
expr_stmt|;
name|baton
operator|.
name|files
index|[
literal|1
index|]
operator|.
name|path
operator|=
name|modified
expr_stmt|;
name|baton
operator|.
name|files
index|[
literal|2
index|]
operator|.
name|path
operator|=
name|latest
expr_stmt|;
name|baton
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_diff3_2
argument_list|(
name|diff
argument_list|,
operator|&
name|baton
argument_list|,
operator|&
name|svn_diff__file_vtable
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|baton
operator|.
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_file_diff4_2
parameter_list|(
name|svn_diff_t
modifier|*
modifier|*
name|diff
parameter_list|,
specifier|const
name|char
modifier|*
name|original
parameter_list|,
specifier|const
name|char
modifier|*
name|modified
parameter_list|,
specifier|const
name|char
modifier|*
name|latest
parameter_list|,
specifier|const
name|char
modifier|*
name|ancestor
parameter_list|,
specifier|const
name|svn_diff_file_options_t
modifier|*
name|options
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff__file_baton_t
name|baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|baton
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|baton
operator|.
name|files
index|[
literal|0
index|]
operator|.
name|path
operator|=
name|original
expr_stmt|;
name|baton
operator|.
name|files
index|[
literal|1
index|]
operator|.
name|path
operator|=
name|modified
expr_stmt|;
name|baton
operator|.
name|files
index|[
literal|2
index|]
operator|.
name|path
operator|=
name|latest
expr_stmt|;
name|baton
operator|.
name|files
index|[
literal|3
index|]
operator|.
name|path
operator|=
name|ancestor
expr_stmt|;
name|baton
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_diff4_2
argument_list|(
name|diff
argument_list|,
operator|&
name|baton
argument_list|,
operator|&
name|svn_diff__file_vtable
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|baton
operator|.
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Display unified context diffs **/
end_comment

begin_comment
comment|/* Maximum length of the extra context to show when show_c_function is set.  * GNU diff uses 40, let's be brave and use 50 instead. */
end_comment

begin_define
define|#
directive|define
name|SVN_DIFF__EXTRA_CONTEXT_LENGTH
value|50
end_define

begin_typedef
typedef|typedef
struct|struct
name|svn_diff__file_output_baton_t
block|{
name|svn_stream_t
modifier|*
name|output_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|header_encoding
decl_stmt|;
comment|/* Cached markers, in header_encoding. */
specifier|const
name|char
modifier|*
name|context_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|delete_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|insert_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
index|[
literal|2
index|]
decl_stmt|;
name|apr_file_t
modifier|*
name|file
index|[
literal|2
index|]
decl_stmt|;
name|apr_off_t
name|current_line
index|[
literal|2
index|]
decl_stmt|;
name|char
name|buffer
index|[
literal|2
index|]
index|[
literal|4096
index|]
decl_stmt|;
name|apr_size_t
name|length
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|curp
index|[
literal|2
index|]
decl_stmt|;
name|apr_off_t
name|hunk_start
index|[
literal|2
index|]
decl_stmt|;
name|apr_off_t
name|hunk_length
index|[
literal|2
index|]
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|hunk
decl_stmt|;
comment|/* Should we emit C functions in the unified diff header */
name|svn_boolean_t
name|show_c_function
decl_stmt|;
comment|/* Extra strings to skip over if we match. */
name|apr_array_header_t
modifier|*
name|extra_skip_match
decl_stmt|;
comment|/* "Context" to append to the @@ line when the show_c_function option    * is set. */
name|svn_stringbuf_t
modifier|*
name|extra_context
decl_stmt|;
comment|/* Extra context for the current hunk. */
name|char
name|hunk_extra_context
index|[
name|SVN_DIFF__EXTRA_CONTEXT_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|svn_diff__file_output_baton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
name|svn_diff__file_output_unified_type_e
block|{
name|svn_diff__file_output_unified_skip
block|,
name|svn_diff__file_output_unified_context
block|,
name|svn_diff__file_output_unified_delete
block|,
name|svn_diff__file_output_unified_insert
block|}
name|svn_diff__file_output_unified_type_e
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_unified_line
parameter_list|(
name|svn_diff__file_output_baton_t
modifier|*
name|baton
parameter_list|,
name|svn_diff__file_output_unified_type_e
name|type
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|char
modifier|*
name|curp
decl_stmt|;
name|char
modifier|*
name|eol
decl_stmt|;
name|apr_size_t
name|length
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|bytes_processed
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|had_cr
init|=
name|FALSE
decl_stmt|;
comment|/* Are we collecting extra context? */
name|svn_boolean_t
name|collect_extra
init|=
name|FALSE
decl_stmt|;
name|length
operator|=
name|baton
operator|->
name|length
index|[
name|idx
index|]
expr_stmt|;
name|curp
operator|=
name|baton
operator|->
name|curp
index|[
name|idx
index|]
expr_stmt|;
comment|/* Lazily update the current line even if we're at EOF.    * This way we fake output of context at EOF    */
name|baton
operator|->
name|current_line
index|[
name|idx
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
operator|&&
name|apr_file_eof
argument_list|(
name|baton
operator|->
name|file
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
do|do
block|{
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bytes_processed
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|svn_diff__file_output_unified_context
case|:
name|svn_stringbuf_appendcstr
argument_list|(
name|baton
operator|->
name|hunk
argument_list|,
name|baton
operator|->
name|context_str
argument_list|)
expr_stmt|;
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|svn_diff__file_output_unified_delete
case|:
name|svn_stringbuf_appendcstr
argument_list|(
name|baton
operator|->
name|hunk
argument_list|,
name|baton
operator|->
name|delete_str
argument_list|)
expr_stmt|;
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|svn_diff__file_output_unified_insert
case|:
name|svn_stringbuf_appendcstr
argument_list|(
name|baton
operator|->
name|hunk
argument_list|,
name|baton
operator|->
name|insert_str
argument_list|)
expr_stmt|;
name|baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|baton
operator|->
name|show_c_function
operator|&&
operator|(
name|type
operator|==
name|svn_diff__file_output_unified_skip
operator|||
name|type
operator|==
name|svn_diff__file_output_unified_context
operator|)
operator|&&
operator|(
name|svn_ctype_isalpha
argument_list|(
operator|*
name|curp
argument_list|)
operator|||
operator|*
name|curp
operator|==
literal|'$'
operator|||
operator|*
name|curp
operator|==
literal|'_'
operator|)
operator|&&
operator|!
name|svn_cstring_match_glob_list
argument_list|(
name|curp
argument_list|,
name|baton
operator|->
name|extra_skip_match
argument_list|)
condition|)
block|{
name|svn_stringbuf_setempty
argument_list|(
name|baton
operator|->
name|extra_context
argument_list|)
expr_stmt|;
name|collect_extra
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|eol
operator|=
name|svn_eol__find_eol_start
argument_list|(
name|curp
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol
operator|!=
name|NULL
condition|)
block|{
name|apr_size_t
name|len
decl_stmt|;
name|had_cr
operator|=
operator|(
operator|*
name|eol
operator|==
literal|'\r'
operator|)
expr_stmt|;
name|eol
operator|++
expr_stmt|;
name|len
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|eol
operator|-
name|curp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|had_cr
operator|||
name|len
operator|<
name|length
condition|)
block|{
if|if
condition|(
name|had_cr
operator|&&
operator|*
name|eol
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|eol
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|length
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|svn_diff__file_output_unified_skip
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|baton
operator|->
name|hunk
argument_list|,
name|curp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collect_extra
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|baton
operator|->
name|extra_context
argument_list|,
name|curp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|baton
operator|->
name|curp
index|[
name|idx
index|]
operator|=
name|eol
expr_stmt|;
name|baton
operator|->
name|length
index|[
name|idx
index|]
operator|=
name|length
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|type
operator|!=
name|svn_diff__file_output_unified_skip
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|baton
operator|->
name|hunk
argument_list|,
name|curp
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collect_extra
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|baton
operator|->
name|extra_context
argument_list|,
name|curp
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|bytes_processed
operator|=
name|TRUE
expr_stmt|;
block|}
name|curp
operator|=
name|baton
operator|->
name|buffer
index|[
name|idx
index|]
expr_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
name|baton
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_file_read
argument_list|(
name|baton
operator|->
name|file
index|[
name|idx
index|]
argument_list|,
name|curp
argument_list|,
operator|&
name|length
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* If the last chunk ended with a CR, we look for an LF at the start          of this chunk. */
if|if
condition|(
name|had_cr
condition|)
block|{
if|if
condition|(
operator|!
name|err
operator|&&
name|length
operator|>
literal|0
operator|&&
operator|*
name|curp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|svn_diff__file_output_unified_skip
condition|)
block|{
name|svn_stringbuf_appendbyte
argument_list|(
name|baton
operator|->
name|hunk
argument_list|,
operator|*
name|curp
argument_list|)
expr_stmt|;
block|}
comment|/* We don't append the LF to extra_context, since it would                * just be stripped anyway. */
operator|++
name|curp
expr_stmt|;
operator|--
name|length
expr_stmt|;
block|}
name|baton
operator|->
name|curp
index|[
name|idx
index|]
operator|=
name|curp
expr_stmt|;
name|baton
operator|->
name|length
index|[
name|idx
index|]
operator|=
name|length
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|err
condition|)
do|;
if|if
condition|(
name|err
operator|&&
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Special case if we reach the end of file AND the last line is in the          changed range AND the file doesn't end with a newline */
if|if
condition|(
name|bytes_processed
operator|&&
operator|(
name|type
operator|!=
name|svn_diff__file_output_unified_skip
operator|)
operator|&&
operator|!
name|had_cr
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_diff__unified_append_no_newline_msg
argument_list|(
name|baton
operator|->
name|hunk
argument_list|,
name|baton
operator|->
name|header_encoding
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|baton
operator|->
name|length
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
name|svn_error_t
modifier|*
name|output_unified_diff_range
parameter_list|(
name|svn_diff__file_output_baton_t
modifier|*
name|output_baton
parameter_list|,
name|int
name|source
parameter_list|,
name|svn_diff__file_output_unified_type_e
name|type
parameter_list|,
name|apr_off_t
name|until
parameter_list|)
block|{
while|while
condition|(
name|output_baton
operator|->
name|current_line
index|[
name|source
index|]
operator|<
name|until
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_unified_line
argument_list|(
name|output_baton
argument_list|,
name|type
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_unified_flush_hunk
parameter_list|(
name|svn_diff__file_output_baton_t
modifier|*
name|baton
parameter_list|)
block|{
name|apr_off_t
name|target_line
decl_stmt|;
name|apr_size_t
name|hunk_len
decl_stmt|;
name|apr_off_t
name|old_start
decl_stmt|;
name|apr_off_t
name|new_start
decl_stmt|;
if|if
condition|(
name|svn_stringbuf_isempty
argument_list|(
name|baton
operator|->
name|hunk
argument_list|)
condition|)
block|{
comment|/* Nothing to flush */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|target_line
operator|=
name|baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|+
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|+
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
comment|/* Add trailing context to the hunk */
name|SVN_ERR
argument_list|(
name|output_unified_diff_range
argument_list|(
name|baton
argument_list|,
literal|0
comment|/* original */
argument_list|,
name|svn_diff__file_output_unified_context
argument_list|,
name|target_line
argument_list|)
argument_list|)
expr_stmt|;
name|old_start
operator|=
name|baton
operator|->
name|hunk_start
index|[
literal|0
index|]
expr_stmt|;
name|new_start
operator|=
name|baton
operator|->
name|hunk_start
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the file is non-empty, convert the line indexes from      zero based to one based */
if|if
condition|(
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
condition|)
name|old_start
operator|++
expr_stmt|;
if|if
condition|(
name|baton
operator|->
name|hunk_length
index|[
literal|1
index|]
condition|)
name|new_start
operator|++
expr_stmt|;
comment|/* Write the hunk header */
name|SVN_ERR
argument_list|(
name|svn_diff__unified_write_hunk_header
argument_list|(
name|baton
operator|->
name|output_stream
argument_list|,
name|baton
operator|->
name|header_encoding
argument_list|,
literal|"@@"
argument_list|,
name|old_start
argument_list|,
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
argument_list|,
name|new_start
argument_list|,
name|baton
operator|->
name|hunk_length
index|[
literal|1
index|]
argument_list|,
name|baton
operator|->
name|hunk_extra_context
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the hunk content */
name|hunk_len
operator|=
name|baton
operator|->
name|hunk
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|baton
operator|->
name|output_stream
argument_list|,
name|baton
operator|->
name|hunk
operator|->
name|data
argument_list|,
operator|&
name|hunk_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare for the next hunk */
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|baton
operator|->
name|hunk_start
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|baton
operator|->
name|hunk
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_unified_diff_modified
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
name|svn_diff__file_output_baton_t
modifier|*
name|output_baton
init|=
name|baton
decl_stmt|;
name|apr_off_t
name|context_prefix_length
decl_stmt|;
name|apr_off_t
name|prev_context_end
decl_stmt|;
name|svn_boolean_t
name|init_hunk
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|original_start
operator|>
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
condition|)
name|context_prefix_length
operator|=
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
else|else
name|context_prefix_length
operator|=
name|original_start
expr_stmt|;
comment|/* Calculate where the previous hunk will end if we would write it now      (including the necessary context at the end) */
if|if
condition|(
name|output_baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|>
literal|0
operator|||
name|output_baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|>
literal|0
condition|)
block|{
name|prev_context_end
operator|=
name|output_baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|+
name|output_baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|+
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
block|}
else|else
block|{
name|prev_context_end
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|output_baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|original_length
operator|>
literal|0
operator|||
name|modified_length
operator|>
literal|0
operator|)
condition|)
name|init_hunk
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If the changed range is far enough from the previous range, flush the current      hunk. */
block|{
name|apr_off_t
name|new_hunk_start
init|=
operator|(
name|original_start
operator|-
name|context_prefix_length
operator|)
decl_stmt|;
if|if
condition|(
name|output_baton
operator|->
name|current_line
index|[
literal|0
index|]
operator|<
name|new_hunk_start
operator|&&
name|prev_context_end
operator|<=
name|new_hunk_start
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_unified_flush_hunk
argument_list|(
name|output_baton
argument_list|)
argument_list|)
expr_stmt|;
name|init_hunk
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|output_baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|>
literal|0
operator|||
name|output_baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|>
literal|0
condition|)
block|{
comment|/* We extend the current hunk */
comment|/* Original: Output the context preceding the changed range */
name|SVN_ERR
argument_list|(
name|output_unified_diff_range
argument_list|(
name|output_baton
argument_list|,
literal|0
comment|/* original */
argument_list|,
name|svn_diff__file_output_unified_context
argument_list|,
name|original_start
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Original: Skip lines until we are at the beginning of the context we want      to display */
name|SVN_ERR
argument_list|(
name|output_unified_diff_range
argument_list|(
name|output_baton
argument_list|,
literal|0
comment|/* original */
argument_list|,
name|svn_diff__file_output_unified_skip
argument_list|,
name|original_start
operator|-
name|context_prefix_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that the above skip stores data for the show_c_function support below */
if|if
condition|(
name|init_hunk
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|output_baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|output_baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|output_baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|=
name|original_start
operator|-
name|context_prefix_length
expr_stmt|;
name|output_baton
operator|->
name|hunk_start
index|[
literal|1
index|]
operator|=
name|modified_start
operator|-
name|context_prefix_length
expr_stmt|;
block|}
if|if
condition|(
name|init_hunk
operator|&&
name|output_baton
operator|->
name|show_c_function
condition|)
block|{
name|apr_size_t
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|invalid_character
decl_stmt|;
comment|/* Save the extra context for later use.        * Note that the last byte of the hunk_extra_context array is never        * touched after it is zero-initialized, so the array is always        * 0-terminated. */
name|strncpy
argument_list|(
name|output_baton
operator|->
name|hunk_extra_context
argument_list|,
name|output_baton
operator|->
name|extra_context
operator|->
name|data
argument_list|,
name|SVN_DIFF__EXTRA_CONTEXT_LENGTH
argument_list|)
expr_stmt|;
comment|/* Trim whitespace at the end, most notably to get rid of any        * newline characters. */
name|p
operator|=
name|strlen
argument_list|(
name|output_baton
operator|->
name|hunk_extra_context
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|>
literal|0
operator|&&
name|svn_ctype_isspace
argument_list|(
name|output_baton
operator|->
name|hunk_extra_context
index|[
name|p
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|output_baton
operator|->
name|hunk_extra_context
index|[
operator|--
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|invalid_character
operator|=
name|svn_utf__last_valid
argument_list|(
name|output_baton
operator|->
name|hunk_extra_context
argument_list|,
name|SVN_DIFF__EXTRA_CONTEXT_LENGTH
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|invalid_character
operator|-
name|output_baton
operator|->
name|hunk_extra_context
init|;
name|p
operator|<
name|SVN_DIFF__EXTRA_CONTEXT_LENGTH
condition|;
name|p
operator|++
control|)
block|{
name|output_baton
operator|->
name|hunk_extra_context
index|[
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* Modified: Skip lines until we are at the start of the changed range */
name|SVN_ERR
argument_list|(
name|output_unified_diff_range
argument_list|(
name|output_baton
argument_list|,
literal|1
comment|/* modified */
argument_list|,
name|svn_diff__file_output_unified_skip
argument_list|,
name|modified_start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Original: Output the context preceding the changed range */
name|SVN_ERR
argument_list|(
name|output_unified_diff_range
argument_list|(
name|output_baton
argument_list|,
literal|0
comment|/* original */
argument_list|,
name|svn_diff__file_output_unified_context
argument_list|,
name|original_start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Both: Output the changed range */
name|SVN_ERR
argument_list|(
name|output_unified_diff_range
argument_list|(
name|output_baton
argument_list|,
literal|0
comment|/* original */
argument_list|,
name|svn_diff__file_output_unified_delete
argument_list|,
name|original_start
operator|+
name|original_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_unified_diff_range
argument_list|(
name|output_baton
argument_list|,
literal|1
comment|/* modified */
argument_list|,
name|svn_diff__file_output_unified_insert
argument_list|,
name|modified_start
operator|+
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *HEADER to a new string consisting of PATH, a tab, and PATH's mtime. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_unified_default_hdr
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_finfo_t
name|file_info
decl_stmt|;
name|apr_time_exp_t
name|exploded_time
decl_stmt|;
name|char
name|time_buffer
index|[
literal|64
index|]
decl_stmt|;
name|apr_size_t
name|time_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|utf8_timestr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|file_info
argument_list|,
name|path
argument_list|,
name|APR_FINFO_MTIME
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_time_exp_lt
argument_list|(
operator|&
name|exploded_time
argument_list|,
name|file_info
operator|.
name|mtime
argument_list|)
expr_stmt|;
name|apr_strftime
argument_list|(
name|time_buffer
argument_list|,
operator|&
name|time_len
argument_list|,
sizeof|sizeof
argument_list|(
name|time_buffer
argument_list|)
operator|-
literal|1
argument_list|,
comment|/* Order of date components can be different in different languages */
name|_
argument_list|(
literal|"%a %b %e %H:%M:%S %Y"
argument_list|)
argument_list|,
operator|&
name|exploded_time
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_timestr
argument_list|,
name|time_buffer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|header
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s\t%s"
argument_list|,
name|path
argument_list|,
name|utf8_timestr
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_diff_output_fns_t
name|svn_diff__file_output_unified_vtable
init|=
block|{
name|NULL
block|,
comment|/* output_common */
name|output_unified_diff_modified
block|,
name|NULL
block|,
comment|/* output_diff_latest */
name|NULL
block|,
comment|/* output_diff_common */
name|NULL
comment|/* output_conflict */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_diff_file_output_unified3
parameter_list|(
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|,
specifier|const
name|char
modifier|*
name|original_path
parameter_list|,
specifier|const
name|char
modifier|*
name|modified_path
parameter_list|,
specifier|const
name|char
modifier|*
name|original_header
parameter_list|,
specifier|const
name|char
modifier|*
name|modified_header
parameter_list|,
specifier|const
name|char
modifier|*
name|header_encoding
parameter_list|,
specifier|const
name|char
modifier|*
name|relative_to_dir
parameter_list|,
name|svn_boolean_t
name|show_c_function
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_diff_contains_diffs
argument_list|(
name|diff
argument_list|)
condition|)
block|{
name|svn_diff__file_output_baton_t
name|baton
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|baton
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|.
name|output_stream
operator|=
name|output_stream
expr_stmt|;
name|baton
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|baton
operator|.
name|header_encoding
operator|=
name|header_encoding
expr_stmt|;
name|baton
operator|.
name|path
index|[
literal|0
index|]
operator|=
name|original_path
expr_stmt|;
name|baton
operator|.
name|path
index|[
literal|1
index|]
operator|=
name|modified_path
expr_stmt|;
name|baton
operator|.
name|hunk
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|.
name|show_c_function
operator|=
name|show_c_function
expr_stmt|;
name|baton
operator|.
name|extra_context
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_c_function
condition|)
block|{
name|baton
operator|.
name|extra_skip_match
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|baton
operator|.
name|extra_skip_match
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
literal|"public:*"
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|baton
operator|.
name|extra_skip_match
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
literal|"private:*"
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|baton
operator|.
name|extra_skip_match
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
literal|"protected:*"
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
name|baton
operator|.
name|context_str
argument_list|,
literal|" "
argument_list|,
name|header_encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
name|baton
operator|.
name|delete_str
argument_list|,
literal|"-"
argument_list|,
name|header_encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
name|baton
operator|.
name|insert_str
argument_list|,
literal|"+"
argument_list|,
name|header_encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relative_to_dir
condition|)
block|{
comment|/* Possibly adjust the "original" and "modified" paths shown in              the output (see issue #2723). */
specifier|const
name|char
modifier|*
name|child_path
decl_stmt|;
if|if
condition|(
operator|!
name|original_header
condition|)
block|{
name|child_path
operator|=
name|svn_dirent_is_child
argument_list|(
name|relative_to_dir
argument_list|,
name|original_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_path
condition|)
name|original_path
operator|=
name|child_path
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_RELATIVE_PATH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' must be inside "
literal|"the directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|original_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|relative_to_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|modified_header
condition|)
block|{
name|child_path
operator|=
name|svn_dirent_is_child
argument_list|(
name|relative_to_dir
argument_list|,
name|modified_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_path
condition|)
name|modified_path
operator|=
name|child_path
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_RELATIVE_PATH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' must be inside "
literal|"the directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|modified_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|relative_to_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|baton
operator|.
name|file
index|[
name|i
index|]
argument_list|,
name|baton
operator|.
name|path
index|[
name|i
index|]
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|original_header
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_unified_default_hdr
argument_list|(
operator|&
name|original_header
argument_list|,
name|original_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modified_header
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_unified_default_hdr
argument_list|(
operator|&
name|modified_header
argument_list|,
name|modified_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_diff__unidiff_write_header
argument_list|(
name|output_stream
argument_list|,
name|header_encoding
argument_list|,
name|original_header
argument_list|,
name|modified_header
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_output
argument_list|(
name|diff
argument_list|,
operator|&
name|baton
argument_list|,
operator|&
name|svn_diff__file_output_unified_vtable
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_unified_flush_hunk
argument_list|(
operator|&
name|baton
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|baton
operator|.
name|file
index|[
name|i
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Display diff3 **/
end_comment

begin_comment
comment|/* A stream to remember *leading* context.  Note that this stream does    *not* copy the data that it is remembering; it just saves    *pointers! */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|context_saver_t
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
index|[
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|len
index|[
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|next_slot
decl_stmt|;
name|apr_size_t
name|total_written
decl_stmt|;
block|}
name|context_saver_t
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|context_saver_stream_write
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|context_saver_t
modifier|*
name|cs
init|=
name|baton
decl_stmt|;
name|cs
operator|->
name|data
index|[
name|cs
operator|->
name|next_slot
index|]
operator|=
name|data
expr_stmt|;
name|cs
operator|->
name|len
index|[
name|cs
operator|->
name|next_slot
index|]
operator|=
operator|*
name|len
expr_stmt|;
name|cs
operator|->
name|next_slot
operator|=
operator|(
name|cs
operator|->
name|next_slot
operator|+
literal|1
operator|)
operator|%
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
name|cs
operator|->
name|total_written
operator|++
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|svn_diff3__file_output_baton_t
block|{
name|svn_stream_t
modifier|*
name|output_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
index|[
literal|3
index|]
decl_stmt|;
name|apr_off_t
name|current_line
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|endp
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|curp
index|[
literal|3
index|]
decl_stmt|;
comment|/* The following four members are in the encoding used for the output. */
specifier|const
name|char
modifier|*
name|conflict_modified
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_original
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_separator
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_latest
decl_stmt|;
specifier|const
name|char
modifier|*
name|marker_eol
decl_stmt|;
name|svn_diff_conflict_display_style_t
name|conflict_style
decl_stmt|;
comment|/* The rest of the fields are for      svn_diff_conflict_display_only_conflicts only.  Note that for      these batons, OUTPUT_STREAM is either CONTEXT_SAVER->STREAM or      (soon after a conflict) a "trailing context stream", never the      actual output stream.*/
comment|/* The actual output stream. */
name|svn_stream_t
modifier|*
name|real_output_stream
decl_stmt|;
name|context_saver_t
modifier|*
name|context_saver
decl_stmt|;
comment|/* Used to allocate context_saver and trailing context streams, and      for some printfs. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|svn_diff3__file_output_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|flush_context_saver
parameter_list|(
name|context_saver_t
modifier|*
name|cs
parameter_list|,
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|apr_size_t
name|slot
init|=
operator|(
name|i
operator|+
name|cs
operator|->
name|next_slot
operator|)
operator|%
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|data
index|[
name|slot
index|]
condition|)
block|{
name|apr_size_t
name|len
init|=
name|cs
operator|->
name|len
index|[
name|slot
index|]
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|output_stream
argument_list|,
name|cs
operator|->
name|data
index|[
name|slot
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_context_saver
parameter_list|(
name|svn_diff3__file_output_baton_t
modifier|*
name|fob
parameter_list|)
block|{
name|context_saver_t
modifier|*
name|cs
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|fob
operator|->
name|pool
argument_list|)
expr_stmt|;
name|cs
operator|=
name|apr_pcalloc
argument_list|(
name|fob
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|cs
operator|->
name|stream
operator|=
name|svn_stream_empty
argument_list|(
name|fob
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_baton
argument_list|(
name|cs
operator|->
name|stream
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|cs
operator|->
name|stream
argument_list|,
name|context_saver_stream_write
argument_list|)
expr_stmt|;
name|fob
operator|->
name|context_saver
operator|=
name|cs
expr_stmt|;
name|fob
operator|->
name|output_stream
operator|=
name|cs
operator|->
name|stream
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A stream which prints SVN_DIFF__UNIFIED_CONTEXT_SIZE lines to    BATON->REAL_OUTPUT_STREAM, and then changes BATON->OUTPUT_STREAM to    a context_saver; used for *trailing* context. */
end_comment

begin_struct
struct|struct
name|trailing_context_printer
block|{
name|apr_size_t
name|lines_to_print
decl_stmt|;
name|svn_diff3__file_output_baton_t
modifier|*
name|fob
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|trailing_context_printer_write
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|trailing_context_printer
modifier|*
name|tcp
init|=
name|baton
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|tcp
operator|->
name|lines_to_print
operator|>
literal|0
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|tcp
operator|->
name|fob
operator|->
name|real_output_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|lines_to_print
operator|--
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|lines_to_print
operator|==
literal|0
condition|)
name|make_context_saver
argument_list|(
name|tcp
operator|->
name|fob
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_trailing_context_printer
parameter_list|(
name|svn_diff3__file_output_baton_t
modifier|*
name|btn
parameter_list|)
block|{
name|struct
name|trailing_context_printer
modifier|*
name|tcp
decl_stmt|;
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
name|tcp
operator|=
name|apr_pcalloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|lines_to_print
operator|=
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
name|tcp
operator|->
name|fob
operator|=
name|btn
expr_stmt|;
name|s
operator|=
name|svn_stream_empty
argument_list|(
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_baton
argument_list|(
name|s
argument_list|,
name|tcp
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|s
argument_list|,
name|trailing_context_printer_write
argument_list|)
expr_stmt|;
name|btn
operator|->
name|output_stream
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
name|svn_diff3__file_output_type_e
block|{
name|svn_diff3__file_output_skip
block|,
name|svn_diff3__file_output_normal
block|}
name|svn_diff3__file_output_type_e
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_line
parameter_list|(
name|svn_diff3__file_output_baton_t
modifier|*
name|baton
parameter_list|,
name|svn_diff3__file_output_type_e
name|type
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|char
modifier|*
name|curp
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|eol
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|curp
operator|=
name|baton
operator|->
name|curp
index|[
name|idx
index|]
expr_stmt|;
name|endp
operator|=
name|baton
operator|->
name|endp
index|[
name|idx
index|]
expr_stmt|;
comment|/* Lazily update the current line even if we're at EOF.    */
name|baton
operator|->
name|current_line
index|[
name|idx
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|curp
operator|==
name|endp
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|eol
operator|=
name|svn_eol__find_eol_start
argument_list|(
name|curp
argument_list|,
name|endp
operator|-
name|curp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
condition|)
name|eol
operator|=
name|endp
expr_stmt|;
else|else
block|{
name|svn_boolean_t
name|had_cr
init|=
operator|(
operator|*
name|eol
operator|==
literal|'\r'
operator|)
decl_stmt|;
name|eol
operator|++
expr_stmt|;
if|if
condition|(
name|had_cr
operator|&&
name|eol
operator|!=
name|endp
operator|&&
operator|*
name|eol
operator|==
literal|'\n'
condition|)
name|eol
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|svn_diff3__file_output_skip
condition|)
block|{
name|len
operator|=
name|eol
operator|-
name|curp
expr_stmt|;
comment|/* Note that the trailing context printer assumes that          svn_stream_write is called exactly once per line. */
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|baton
operator|->
name|output_stream
argument_list|,
name|curp
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|baton
operator|->
name|curp
index|[
name|idx
index|]
operator|=
name|eol
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_marker_eol
parameter_list|(
name|svn_diff3__file_output_baton_t
modifier|*
name|btn
parameter_list|)
block|{
return|return
name|svn_stream_puts
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|marker_eol
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_hunk
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|idx
parameter_list|,
name|apr_off_t
name|target_line
parameter_list|,
name|apr_off_t
name|target_length
parameter_list|)
block|{
name|svn_diff3__file_output_baton_t
modifier|*
name|output_baton
init|=
name|baton
decl_stmt|;
comment|/* Skip lines until we are at the start of the changed range */
while|while
condition|(
name|output_baton
operator|->
name|current_line
index|[
name|idx
index|]
operator|<
name|target_line
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_line
argument_list|(
name|output_baton
argument_list|,
name|svn_diff3__file_output_skip
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|target_line
operator|+=
name|target_length
expr_stmt|;
while|while
condition|(
name|output_baton
operator|->
name|current_line
index|[
name|idx
index|]
operator|<
name|target_line
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_line
argument_list|(
name|output_baton
argument_list|,
name|svn_diff3__file_output_normal
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_common
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
return|return
name|output_hunk
argument_list|(
name|baton
argument_list|,
literal|1
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_diff_modified
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
return|return
name|output_hunk
argument_list|(
name|baton
argument_list|,
literal|1
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_diff_latest
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
return|return
name|output_hunk
argument_list|(
name|baton
argument_list|,
literal|2
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|output_conflict
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|svn_diff_output_fns_t
name|svn_diff3__file_output_vtable
init|=
block|{
name|output_common
block|,
name|output_diff_modified
block|,
name|output_diff_latest
block|,
name|output_diff_modified
block|,
comment|/* output_diff_common */
name|output_conflict
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_conflict_with_context
parameter_list|(
name|svn_diff3__file_output_baton_t
modifier|*
name|btn
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
comment|/* Are we currently saving starting context (as opposed to printing      trailing context)?  If so, flush it. */
if|if
condition|(
name|btn
operator|->
name|output_stream
operator|==
name|btn
operator|->
name|context_saver
operator|->
name|stream
condition|)
block|{
if|if
condition|(
name|btn
operator|->
name|context_saver
operator|->
name|total_written
operator|>
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|btn
operator|->
name|real_output_stream
argument_list|,
literal|"@@\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|flush_context_saver
argument_list|(
name|btn
operator|->
name|context_saver
argument_list|,
name|btn
operator|->
name|real_output_stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Print to the real output stream. */
name|btn
operator|->
name|output_stream
operator|=
name|btn
operator|->
name|real_output_stream
expr_stmt|;
comment|/* Output the conflict itself. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|pool
argument_list|,
operator|(
name|modified_length
operator|==
literal|1
condition|?
literal|"%s (%"
name|APR_OFF_T_FMT
literal|")"
else|:
literal|"%s (%"
name|APR_OFF_T_FMT
literal|",%"
name|APR_OFF_T_FMT
literal|")"
operator|)
argument_list|,
name|btn
operator|->
name|conflict_modified
argument_list|,
name|modified_start
operator|+
literal|1
argument_list|,
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|btn
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_hunk
argument_list|(
name|btn
argument_list|,
literal|1
comment|/*modified*/
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|pool
argument_list|,
operator|(
name|original_length
operator|==
literal|1
condition|?
literal|"%s (%"
name|APR_OFF_T_FMT
literal|")"
else|:
literal|"%s (%"
name|APR_OFF_T_FMT
literal|",%"
name|APR_OFF_T_FMT
literal|")"
operator|)
argument_list|,
name|btn
operator|->
name|conflict_original
argument_list|,
name|original_start
operator|+
literal|1
argument_list|,
name|original_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|btn
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_hunk
argument_list|(
name|btn
argument_list|,
literal|0
comment|/*original*/
argument_list|,
name|original_start
argument_list|,
name|original_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|pool
argument_list|,
literal|"%s%s"
argument_list|,
name|btn
operator|->
name|conflict_separator
argument_list|,
name|btn
operator|->
name|marker_eol
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_hunk
argument_list|(
name|btn
argument_list|,
literal|2
comment|/*latest*/
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|pool
argument_list|,
operator|(
name|latest_length
operator|==
literal|1
condition|?
literal|"%s (%"
name|APR_OFF_T_FMT
literal|")"
else|:
literal|"%s (%"
name|APR_OFF_T_FMT
literal|",%"
name|APR_OFF_T_FMT
literal|")"
operator|)
argument_list|,
name|btn
operator|->
name|conflict_latest
argument_list|,
name|latest_start
operator|+
literal|1
argument_list|,
name|latest_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|btn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go into print-trailing-context mode instead. */
name|make_trailing_context_printer
argument_list|(
name|btn
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_conflict
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|svn_diff3__file_output_baton_t
modifier|*
name|file_baton
init|=
name|baton
decl_stmt|;
name|svn_diff_conflict_display_style_t
name|style
init|=
name|file_baton
operator|->
name|conflict_style
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_only_conflicts
condition|)
return|return
name|output_conflict_with_context
argument_list|(
name|file_baton
argument_list|,
name|original_start
argument_list|,
name|original_length
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|)
return|;
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_resolved_modified_latest
condition|)
block|{
if|if
condition|(
name|diff
condition|)
return|return
name|svn_diff_output
argument_list|(
name|diff
argument_list|,
name|baton
argument_list|,
operator|&
name|svn_diff3__file_output_vtable
argument_list|)
return|;
else|else
name|style
operator|=
name|svn_diff_conflict_display_modified_latest
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_modified_latest
operator|||
name|style
operator|==
name|svn_diff_conflict_display_modified_original_latest
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|file_baton
operator|->
name|output_stream
argument_list|,
name|file_baton
operator|->
name|conflict_modified
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_hunk
argument_list|(
name|baton
argument_list|,
literal|1
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_modified_original_latest
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|file_baton
operator|->
name|output_stream
argument_list|,
name|file_baton
operator|->
name|conflict_original
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_hunk
argument_list|(
name|baton
argument_list|,
literal|0
argument_list|,
name|original_start
argument_list|,
name|original_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|file_baton
operator|->
name|output_stream
argument_list|,
name|file_baton
operator|->
name|conflict_separator
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_hunk
argument_list|(
name|baton
argument_list|,
literal|2
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|file_baton
operator|->
name|output_stream
argument_list|,
name|file_baton
operator|->
name|conflict_latest
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_modified
condition|)
name|SVN_ERR
argument_list|(
name|output_hunk
argument_list|(
name|baton
argument_list|,
literal|1
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_latest
condition|)
name|SVN_ERR
argument_list|(
name|output_hunk
argument_list|(
name|baton
argument_list|,
literal|2
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* unknown style */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_file_output_merge2
parameter_list|(
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|,
specifier|const
name|char
modifier|*
name|original_path
parameter_list|,
specifier|const
name|char
modifier|*
name|modified_path
parameter_list|,
specifier|const
name|char
modifier|*
name|latest_path
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_original
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_modified
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_latest
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_separator
parameter_list|,
name|svn_diff_conflict_display_style_t
name|style
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff3__file_output_baton_t
name|baton
decl_stmt|;
name|apr_file_t
modifier|*
name|file
index|[
literal|3
index|]
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|#
directive|if
name|APR_HAS_MMAP
name|apr_mmap_t
modifier|*
name|mm
index|[
literal|3
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_MMAP */
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
name|svn_boolean_t
name|conflicts_only
init|=
operator|(
name|style
operator|==
name|svn_diff_conflict_display_only_conflicts
operator|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|baton
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicts_only
condition|)
block|{
name|baton
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|make_context_saver
argument_list|(
operator|&
name|baton
argument_list|)
expr_stmt|;
name|baton
operator|.
name|real_output_stream
operator|=
name|output_stream
expr_stmt|;
block|}
else|else
name|baton
operator|.
name|output_stream
operator|=
name|output_stream
expr_stmt|;
name|baton
operator|.
name|path
index|[
literal|0
index|]
operator|=
name|original_path
expr_stmt|;
name|baton
operator|.
name|path
index|[
literal|1
index|]
operator|=
name|modified_path
expr_stmt|;
name|baton
operator|.
name|path
index|[
literal|2
index|]
operator|=
name|latest_path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|baton
operator|.
name|conflict_modified
argument_list|,
name|conflict_modified
condition|?
name|conflict_modified
else|:
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"<<<<<<< %s"
argument_list|,
name|modified_path
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|baton
operator|.
name|conflict_original
argument_list|,
name|conflict_original
condition|?
name|conflict_original
else|:
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"||||||| %s"
argument_list|,
name|original_path
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|baton
operator|.
name|conflict_separator
argument_list|,
name|conflict_separator
condition|?
name|conflict_separator
else|:
literal|"======="
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|baton
operator|.
name|conflict_latest
argument_list|,
name|conflict_latest
condition|?
name|conflict_latest
else|:
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|">>>>>>> %s"
argument_list|,
name|latest_path
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|.
name|conflict_style
operator|=
name|style
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|3
condition|;
name|idx
operator|++
control|)
block|{
name|apr_size_t
name|size
decl_stmt|;
name|SVN_ERR
argument_list|(
name|map_or_read_file
argument_list|(
operator|&
name|file
index|[
name|idx
index|]
argument_list|,
name|MMAP_T_ARG
argument_list|(
name|mm
index|[
name|idx
index|]
argument_list|)
operator|&
name|baton
operator|.
name|buffer
index|[
name|idx
index|]
argument_list|,
operator|&
name|size
argument_list|,
name|baton
operator|.
name|path
index|[
name|idx
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|.
name|curp
index|[
name|idx
index|]
operator|=
name|baton
operator|.
name|buffer
index|[
name|idx
index|]
expr_stmt|;
name|baton
operator|.
name|endp
index|[
name|idx
index|]
operator|=
name|baton
operator|.
name|buffer
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|baton
operator|.
name|endp
index|[
name|idx
index|]
condition|)
name|baton
operator|.
name|endp
index|[
name|idx
index|]
operator|+=
name|size
expr_stmt|;
block|}
comment|/* Check what eol marker we should use for conflict markers.      We use the eol marker of the modified file and fall back on the      platform's eol marker if that file doesn't contain any newlines. */
name|eol
operator|=
name|svn_eol__detect_eol
argument_list|(
name|baton
operator|.
name|buffer
index|[
literal|1
index|]
argument_list|,
name|baton
operator|.
name|endp
index|[
literal|1
index|]
operator|-
name|baton
operator|.
name|buffer
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
condition|)
name|eol
operator|=
name|APR_EOL_STR
expr_stmt|;
name|baton
operator|.
name|marker_eol
operator|=
name|eol
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_output
argument_list|(
name|diff
argument_list|,
operator|&
name|baton
argument_list|,
operator|&
name|svn_diff3__file_output_vtable
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|3
condition|;
name|idx
operator|++
control|)
block|{
if|#
directive|if
name|APR_HAS_MMAP
if|if
condition|(
name|mm
index|[
name|idx
index|]
condition|)
block|{
name|apr_status_t
name|rv
init|=
name|apr_mmap_delete
argument_list|(
name|mm
index|[
name|idx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|rv
argument_list|,
name|_
argument_list|(
literal|"Failed to delete mmap '%s'"
argument_list|)
argument_list|,
name|baton
operator|.
name|path
index|[
name|idx
index|]
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* APR_HAS_MMAP */
if|if
condition|(
name|file
index|[
name|idx
index|]
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
index|[
name|idx
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conflicts_only
condition|)
name|svn_pool_destroy
argument_list|(
name|baton
operator|.
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

