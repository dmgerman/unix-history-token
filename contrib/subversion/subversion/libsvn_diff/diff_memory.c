begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * diff_memory.c :  routines for doing diffs on in-memory data  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_define
define|#
directive|define
name|WANT_MEMFUNC
end_define

begin_define
define|#
directive|define
name|WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_adler32.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_diff_private.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|source_tokens_t
block|{
comment|/* A token simply is an svn_string_t pointing to      the data of the in-memory data source, containing      the raw token text, with length stored in the string */
name|apr_array_header_t
modifier|*
name|tokens
decl_stmt|;
comment|/* Next token to be consumed */
name|apr_size_t
name|next_token
decl_stmt|;
comment|/* The source, containing the in-memory data to be diffed */
specifier|const
name|svn_string_t
modifier|*
name|source
decl_stmt|;
comment|/* The last token ends with a newline character (sequence) */
name|svn_boolean_t
name|ends_without_eol
decl_stmt|;
block|}
name|source_tokens_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|diff_mem_baton_t
block|{
comment|/* The tokens for each of the sources */
name|source_tokens_t
name|sources
index|[
literal|4
index|]
decl_stmt|;
comment|/* Normalization buffer; we only ever compare 2 tokens at the same time */
name|char
modifier|*
name|normalization_buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* Options for normalized comparison of the data sources */
specifier|const
name|svn_diff_file_options_t
modifier|*
name|normalization_options
decl_stmt|;
block|}
name|diff_mem_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|datasource_to_index
parameter_list|(
name|svn_diff_datasource_e
name|datasource
parameter_list|)
block|{
switch|switch
condition|(
name|datasource
condition|)
block|{
case|case
name|svn_diff_datasource_original
case|:
return|return
literal|0
return|;
case|case
name|svn_diff_datasource_modified
case|:
return|return
literal|1
return|;
case|case
name|svn_diff_datasource_latest
case|:
return|return
literal|2
return|;
case|case
name|svn_diff_datasource_ancestor
case|:
return|return
literal|3
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::datasources_open */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|datasources_open
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|prefix_lines
parameter_list|,
name|apr_off_t
modifier|*
name|suffix_lines
parameter_list|,
specifier|const
name|svn_diff_datasource_e
modifier|*
name|datasources
parameter_list|,
name|apr_size_t
name|datasources_len
parameter_list|)
block|{
comment|/* Do nothing: everything is already there and initialized to 0 */
operator|*
name|prefix_lines
operator|=
literal|0
expr_stmt|;
operator|*
name|suffix_lines
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::datasource_close */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|datasource_close
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_diff_datasource_e
name|datasource
parameter_list|)
block|{
comment|/* Do nothing.  The compare_token function needs previous datasources    * to stay available until all datasources are processed.    */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::datasource_get_next_token */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|datasource_get_next_token
parameter_list|(
name|apr_uint32_t
modifier|*
name|hash
parameter_list|,
name|void
modifier|*
modifier|*
name|token
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_diff_datasource_e
name|datasource
parameter_list|)
block|{
name|diff_mem_baton_t
modifier|*
name|mem_baton
init|=
name|baton
decl_stmt|;
name|source_tokens_t
modifier|*
name|src
init|=
operator|&
operator|(
name|mem_baton
operator|->
name|sources
index|[
name|datasource_to_index
argument_list|(
name|datasource
argument_list|)
index|]
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|apr_size_t
operator|)
name|src
operator|->
name|tokens
operator|->
name|nelts
operator|>
name|src
operator|->
name|next_token
condition|)
block|{
comment|/* There are actually tokens to be returned */
name|char
modifier|*
name|buf
init|=
name|mem_baton
operator|->
name|normalization_buf
index|[
literal|0
index|]
decl_stmt|;
name|svn_string_t
modifier|*
name|tok
init|=
operator|(
operator|*
name|token
operator|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|src
operator|->
name|tokens
argument_list|,
name|src
operator|->
name|next_token
argument_list|,
name|svn_string_t
operator|*
argument_list|)
decl_stmt|;
name|apr_off_t
name|len
init|=
name|tok
operator|->
name|len
decl_stmt|;
name|svn_diff__normalize_state_t
name|state
init|=
name|svn_diff__normalize_state_normal
decl_stmt|;
name|svn_diff__normalize_buffer
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|state
argument_list|,
name|tok
operator|->
name|data
argument_list|,
name|mem_baton
operator|->
name|normalization_options
argument_list|)
expr_stmt|;
operator|*
name|hash
operator|=
name|svn__adler32
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|src
operator|->
name|next_token
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|token
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::token_compare */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|token_compare
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|void
modifier|*
name|token1
parameter_list|,
name|void
modifier|*
name|token2
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
block|{
comment|/* Implement the same behaviour as diff_file.c:token_compare(),      but be simpler, because we know we'll have all data in memory */
name|diff_mem_baton_t
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_string_t
modifier|*
name|t1
init|=
name|token1
decl_stmt|;
name|svn_string_t
modifier|*
name|t2
init|=
name|token2
decl_stmt|;
name|char
modifier|*
name|buf1
init|=
name|btn
operator|->
name|normalization_buf
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|btn
operator|->
name|normalization_buf
index|[
literal|1
index|]
decl_stmt|;
name|apr_off_t
name|len1
init|=
name|t1
operator|->
name|len
decl_stmt|;
name|apr_off_t
name|len2
init|=
name|t2
operator|->
name|len
decl_stmt|;
name|svn_diff__normalize_state_t
name|state
init|=
name|svn_diff__normalize_state_normal
decl_stmt|;
name|svn_diff__normalize_buffer
argument_list|(
operator|&
name|buf1
argument_list|,
operator|&
name|len1
argument_list|,
operator|&
name|state
argument_list|,
name|t1
operator|->
name|data
argument_list|,
name|btn
operator|->
name|normalization_options
argument_list|)
expr_stmt|;
name|state
operator|=
name|svn_diff__normalize_state_normal
expr_stmt|;
name|svn_diff__normalize_buffer
argument_list|(
operator|&
name|buf2
argument_list|,
operator|&
name|len2
argument_list|,
operator|&
name|state
argument_list|,
name|t2
operator|->
name|data
argument_list|,
name|btn
operator|->
name|normalization_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|len1
operator|!=
name|len2
condition|)
operator|*
name|result
operator|=
operator|(
name|len1
operator|<
name|len2
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
else|else
operator|*
name|result
operator|=
operator|(
name|len1
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|memcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
operator|(
name|size_t
operator|)
name|len1
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::token_discard */
end_comment

begin_function
specifier|static
name|void
name|token_discard
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|void
modifier|*
name|token
parameter_list|)
block|{
comment|/* No-op, we have no use for discarded tokens... */
block|}
end_function

begin_comment
comment|/* Implements svn_diff_fns2_t::token_discard_all */
end_comment

begin_function
specifier|static
name|void
name|token_discard_all
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
comment|/* Do nothing.      Note that in the file case, this function discards all      tokens allocated, but we're geared toward small in-memory diffs.      Meaning that there's no special pool to clear.   */
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_diff_fns2_t
name|svn_diff__mem_vtable
init|=
block|{
name|datasources_open
block|,
name|datasource_close
block|,
name|datasource_get_next_token
block|,
name|token_compare
block|,
name|token_discard
block|,
name|token_discard_all
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fill SRC with the diff tokens (e.g. lines).     TEXT is assumed to live long enough for the tokens to    stay valid during their lifetime: no data is copied,    instead, svn_string_t's are allocated pointing straight    into TEXT. */
end_comment

begin_function
specifier|static
name|void
name|fill_source_tokens
parameter_list|(
name|source_tokens_t
modifier|*
name|src
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|text
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|curp
decl_stmt|;
specifier|const
name|char
modifier|*
name|endp
decl_stmt|;
specifier|const
name|char
modifier|*
name|startp
decl_stmt|;
name|src
operator|->
name|tokens
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_string_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|->
name|next_token
operator|=
literal|0
expr_stmt|;
name|src
operator|->
name|source
operator|=
name|text
expr_stmt|;
for|for
control|(
name|startp
operator|=
name|curp
operator|=
name|text
operator|->
name|data
operator|,
name|endp
operator|=
name|curp
operator|+
name|text
operator|->
name|len
init|;
name|curp
operator|!=
name|endp
condition|;
name|curp
operator|++
control|)
block|{
if|if
condition|(
name|curp
operator|!=
name|endp
operator|&&
operator|*
name|curp
operator|==
literal|'\r'
operator|&&
operator|*
operator|(
name|curp
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
name|curp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|curp
operator|==
literal|'\r'
operator|||
operator|*
name|curp
operator|==
literal|'\n'
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|src
operator|->
name|tokens
argument_list|,
name|svn_string_t
operator|*
argument_list|)
operator|=
name|svn_string_ncreate
argument_list|(
name|startp
argument_list|,
name|curp
operator|-
name|startp
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|startp
operator|=
name|curp
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* If there's anything remaining (ie last line doesn't have a newline) */
if|if
condition|(
name|startp
operator|!=
name|endp
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|src
operator|->
name|tokens
argument_list|,
name|svn_string_t
operator|*
argument_list|)
operator|=
name|svn_string_ncreate
argument_list|(
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|src
operator|->
name|ends_without_eol
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|src
operator|->
name|ends_without_eol
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_normalization_bufs
parameter_list|(
name|diff_mem_baton_t
modifier|*
name|btn
parameter_list|,
name|int
name|sources
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|max_len
init|=
literal|0
decl_stmt|;
name|apr_off_t
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sources
condition|;
name|i
operator|++
control|)
block|{
name|apr_array_header_t
modifier|*
name|tokens
init|=
name|btn
operator|->
name|sources
index|[
name|i
index|]
operator|.
name|tokens
decl_stmt|;
if|if
condition|(
name|tokens
operator|->
name|nelts
operator|>
literal|0
condition|)
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|tokens
operator|->
name|nelts
condition|;
name|idx
operator|++
control|)
block|{
name|apr_size_t
name|token_len
init|=
name|APR_ARRAY_IDX
argument_list|(
name|tokens
argument_list|,
name|idx
argument_list|,
name|svn_string_t
operator|*
argument_list|)
operator|->
name|len
decl_stmt|;
name|max_len
operator|=
operator|(
name|max_len
operator|<
name|token_len
operator|)
condition|?
name|token_len
else|:
name|max_len
expr_stmt|;
block|}
block|}
name|btn
operator|->
name|normalization_buf
index|[
literal|0
index|]
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|max_len
argument_list|)
expr_stmt|;
name|btn
operator|->
name|normalization_buf
index|[
literal|1
index|]
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|max_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_mem_string_diff
parameter_list|(
name|svn_diff_t
modifier|*
modifier|*
name|diff
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|modified
parameter_list|,
specifier|const
name|svn_diff_file_options_t
modifier|*
name|options
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|diff_mem_baton_t
name|baton
decl_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|sources
index|[
literal|0
index|]
operator|)
argument_list|,
name|original
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|sources
index|[
literal|1
index|]
operator|)
argument_list|,
name|modified
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|alloc_normalization_bufs
argument_list|(
operator|&
name|baton
argument_list|,
literal|2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|.
name|normalization_options
operator|=
name|options
expr_stmt|;
return|return
name|svn_diff_diff_2
argument_list|(
name|diff
argument_list|,
operator|&
name|baton
argument_list|,
operator|&
name|svn_diff__mem_vtable
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_mem_string_diff3
parameter_list|(
name|svn_diff_t
modifier|*
modifier|*
name|diff
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|modified
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|latest
parameter_list|,
specifier|const
name|svn_diff_file_options_t
modifier|*
name|options
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|diff_mem_baton_t
name|baton
decl_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|sources
index|[
literal|0
index|]
operator|)
argument_list|,
name|original
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|sources
index|[
literal|1
index|]
operator|)
argument_list|,
name|modified
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|sources
index|[
literal|2
index|]
operator|)
argument_list|,
name|latest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|alloc_normalization_bufs
argument_list|(
operator|&
name|baton
argument_list|,
literal|3
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|.
name|normalization_options
operator|=
name|options
expr_stmt|;
return|return
name|svn_diff_diff3_2
argument_list|(
name|diff
argument_list|,
operator|&
name|baton
argument_list|,
operator|&
name|svn_diff__mem_vtable
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_mem_string_diff4
parameter_list|(
name|svn_diff_t
modifier|*
modifier|*
name|diff
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|modified
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|latest
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|ancestor
parameter_list|,
specifier|const
name|svn_diff_file_options_t
modifier|*
name|options
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|diff_mem_baton_t
name|baton
decl_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|sources
index|[
literal|0
index|]
operator|)
argument_list|,
name|original
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|sources
index|[
literal|1
index|]
operator|)
argument_list|,
name|modified
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|sources
index|[
literal|2
index|]
operator|)
argument_list|,
name|latest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|sources
index|[
literal|3
index|]
operator|)
argument_list|,
name|ancestor
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|alloc_normalization_bufs
argument_list|(
operator|&
name|baton
argument_list|,
literal|4
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|.
name|normalization_options
operator|=
name|options
expr_stmt|;
return|return
name|svn_diff_diff4_2
argument_list|(
name|diff
argument_list|,
operator|&
name|baton
argument_list|,
operator|&
name|svn_diff__mem_vtable
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
name|unified_output_e
block|{
name|unified_output_context
init|=
literal|0
block|,
name|unified_output_delete
block|,
name|unified_output_insert
block|,
name|unified_output_skip
block|}
name|unified_output_e
typedef|;
end_typedef

begin_comment
comment|/* Baton for generating unified diffs */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|unified_output_baton_t
block|{
name|svn_stream_t
modifier|*
name|output_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|header_encoding
decl_stmt|;
name|source_tokens_t
name|sources
index|[
literal|2
index|]
decl_stmt|;
comment|/* 0 == original; 1 == modified */
name|apr_off_t
name|current_token
index|[
literal|2
index|]
decl_stmt|;
comment|/* current token per source */
comment|/* Cached markers, in header_encoding,      indexed using unified_output_e */
specifier|const
name|char
modifier|*
name|prefix_str
index|[
literal|3
index|]
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|hunk
decl_stmt|;
comment|/* in-progress hunk data */
name|apr_off_t
name|hunk_length
index|[
literal|2
index|]
decl_stmt|;
comment|/* 0 == original; 1 == modified */
name|apr_off_t
name|hunk_start
index|[
literal|2
index|]
decl_stmt|;
comment|/* 0 == original; 1 == modified */
comment|/* The delimiters of the hunk header, '@@' for text hunks and '##' for    * property hunks. */
specifier|const
name|char
modifier|*
name|hunk_delimiter
decl_stmt|;
comment|/* The string to print after a line that does not end with a newline.    * It must start with a '\'.  Typically "\ No newline at end of file". */
specifier|const
name|char
modifier|*
name|no_newline_string
decl_stmt|;
comment|/* Pool for allocation of temporary memory in the callbacks      Should be cleared on entry of each iteration of a callback */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|output_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Append tokens (lines) FIRST up to PAST_LAST    from token-source index TOKENS with change-type TYPE    to the current hunk. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_unified_token_range
parameter_list|(
name|output_baton_t
modifier|*
name|btn
parameter_list|,
name|int
name|tokens
parameter_list|,
name|unified_output_e
name|type
parameter_list|,
name|apr_off_t
name|until
parameter_list|)
block|{
name|source_tokens_t
modifier|*
name|source
init|=
operator|&
name|btn
operator|->
name|sources
index|[
name|tokens
index|]
decl_stmt|;
if|if
condition|(
name|until
operator|>
name|source
operator|->
name|tokens
operator|->
name|nelts
condition|)
name|until
operator|=
name|source
operator|->
name|tokens
operator|->
name|nelts
expr_stmt|;
if|if
condition|(
name|until
operator|<=
name|btn
operator|->
name|current_token
index|[
name|tokens
index|]
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Do the loop with prefix and token */
while|while
condition|(
name|TRUE
condition|)
block|{
name|svn_string_t
modifier|*
name|token
init|=
name|APR_ARRAY_IDX
argument_list|(
name|source
operator|->
name|tokens
argument_list|,
name|btn
operator|->
name|current_token
index|[
name|tokens
index|]
argument_list|,
name|svn_string_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|unified_output_skip
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|btn
operator|->
name|hunk
argument_list|,
name|btn
operator|->
name|prefix_str
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|btn
operator|->
name|hunk
argument_list|,
name|token
operator|->
name|data
argument_list|,
name|token
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|unified_output_context
condition|)
block|{
name|btn
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|btn
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|unified_output_delete
condition|)
name|btn
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|unified_output_insert
condition|)
name|btn
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|++
expr_stmt|;
comment|/* ### TODO: Add skip processing for -p handling? */
name|btn
operator|->
name|current_token
index|[
name|tokens
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|btn
operator|->
name|current_token
index|[
name|tokens
index|]
operator|==
name|until
condition|)
break|break;
block|}
if|if
condition|(
name|btn
operator|->
name|current_token
index|[
name|tokens
index|]
operator|==
name|source
operator|->
name|tokens
operator|->
name|nelts
operator|&&
name|source
operator|->
name|ends_without_eol
condition|)
block|{
specifier|const
name|char
modifier|*
name|out_str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
name|out_str
argument_list|,
name|btn
operator|->
name|no_newline_string
argument_list|,
name|btn
operator|->
name|header_encoding
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|btn
operator|->
name|hunk
argument_list|,
name|out_str
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Flush the hunk currently built up in BATON    into the BATON's output_stream.    Use the specified HUNK_DELIMITER.    If HUNK_DELIMITER is NULL, fall back to the default delimiter. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_unified_flush_hunk
parameter_list|(
name|output_baton_t
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|hunk_delimiter
parameter_list|)
block|{
name|apr_off_t
name|target_token
decl_stmt|;
name|apr_size_t
name|hunk_len
decl_stmt|;
name|apr_off_t
name|old_start
decl_stmt|;
name|apr_off_t
name|new_start
decl_stmt|;
if|if
condition|(
name|svn_stringbuf_isempty
argument_list|(
name|baton
operator|->
name|hunk
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|svn_pool_clear
argument_list|(
name|baton
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Write the trailing context */
name|target_token
operator|=
name|baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|+
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|+
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_unified_token_range
argument_list|(
name|baton
argument_list|,
literal|0
comment|/*original*/
argument_list|,
name|unified_output_context
argument_list|,
name|target_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hunk_delimiter
operator|==
name|NULL
condition|)
name|hunk_delimiter
operator|=
literal|"@@"
expr_stmt|;
name|old_start
operator|=
name|baton
operator|->
name|hunk_start
index|[
literal|0
index|]
expr_stmt|;
name|new_start
operator|=
name|baton
operator|->
name|hunk_start
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the file is non-empty, convert the line indexes from      zero based to one based */
if|if
condition|(
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
condition|)
name|old_start
operator|++
expr_stmt|;
if|if
condition|(
name|baton
operator|->
name|hunk_length
index|[
literal|1
index|]
condition|)
name|new_start
operator|++
expr_stmt|;
comment|/* Write the hunk header */
name|SVN_ERR
argument_list|(
name|svn_diff__unified_write_hunk_header
argument_list|(
name|baton
operator|->
name|output_stream
argument_list|,
name|baton
operator|->
name|header_encoding
argument_list|,
name|hunk_delimiter
argument_list|,
name|old_start
argument_list|,
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
argument_list|,
name|new_start
argument_list|,
name|baton
operator|->
name|hunk_length
index|[
literal|1
index|]
argument_list|,
name|NULL
comment|/* hunk_extra_context */
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hunk_len
operator|=
name|baton
operator|->
name|hunk
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|baton
operator|->
name|output_stream
argument_list|,
name|baton
operator|->
name|hunk
operator|->
name|data
argument_list|,
operator|&
name|hunk_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare for the next hunk */
name|baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|baton
operator|->
name|hunk_start
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|baton
operator|->
name|hunk
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_diff_output_fns_t::output_diff_modified */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_unified_diff_modified
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
name|output_baton_t
modifier|*
name|output_baton
init|=
name|baton
decl_stmt|;
name|apr_off_t
name|context_prefix_length
decl_stmt|;
name|apr_off_t
name|prev_context_end
decl_stmt|;
name|svn_boolean_t
name|init_hunk
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|original_start
operator|>
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
condition|)
name|context_prefix_length
operator|=
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
else|else
name|context_prefix_length
operator|=
name|original_start
expr_stmt|;
comment|/* Calculate where the previous hunk will end if we would write it now      (including the necessary context at the end) */
if|if
condition|(
name|output_baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|>
literal|0
operator|||
name|output_baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|>
literal|0
condition|)
block|{
name|prev_context_end
operator|=
name|output_baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|+
name|output_baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|+
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
block|}
else|else
block|{
name|prev_context_end
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|output_baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|original_length
operator|>
literal|0
operator|||
name|modified_length
operator|>
literal|0
operator|)
condition|)
name|init_hunk
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If the changed range is far enough from the previous range, flush the current      hunk. */
block|{
name|apr_off_t
name|new_hunk_start
init|=
operator|(
name|original_start
operator|-
name|context_prefix_length
operator|)
decl_stmt|;
if|if
condition|(
name|output_baton
operator|->
name|current_token
index|[
literal|0
index|]
operator|<
name|new_hunk_start
operator|&&
name|prev_context_end
operator|<=
name|new_hunk_start
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_unified_flush_hunk
argument_list|(
name|output_baton
argument_list|,
name|output_baton
operator|->
name|hunk_delimiter
argument_list|)
argument_list|)
expr_stmt|;
name|init_hunk
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|output_baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|>
literal|0
operator|||
name|output_baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|>
literal|0
condition|)
block|{
comment|/* We extend the current hunk */
comment|/* Original: Output the context preceding the changed range */
name|SVN_ERR
argument_list|(
name|output_unified_token_range
argument_list|(
name|output_baton
argument_list|,
literal|0
comment|/* original */
argument_list|,
name|unified_output_context
argument_list|,
name|original_start
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Original: Skip lines until we are at the beginning of the context we want      to display */
name|SVN_ERR
argument_list|(
name|output_unified_token_range
argument_list|(
name|output_baton
argument_list|,
literal|0
comment|/* original */
argument_list|,
name|unified_output_skip
argument_list|,
name|original_start
operator|-
name|context_prefix_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_hunk
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|output_baton
operator|->
name|hunk_length
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|output_baton
operator|->
name|hunk_length
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|output_baton
operator|->
name|hunk_start
index|[
literal|0
index|]
operator|=
name|original_start
operator|-
name|context_prefix_length
expr_stmt|;
name|output_baton
operator|->
name|hunk_start
index|[
literal|1
index|]
operator|=
name|modified_start
operator|-
name|context_prefix_length
expr_stmt|;
block|}
comment|/* Modified: Skip lines until we are at the start of the changed range */
name|SVN_ERR
argument_list|(
name|output_unified_token_range
argument_list|(
name|output_baton
argument_list|,
literal|1
comment|/* modified */
argument_list|,
name|unified_output_skip
argument_list|,
name|modified_start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Original: Output the context preceding the changed range */
name|SVN_ERR
argument_list|(
name|output_unified_token_range
argument_list|(
name|output_baton
argument_list|,
literal|0
comment|/* original */
argument_list|,
name|unified_output_context
argument_list|,
name|original_start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Both: Output the changed range */
name|SVN_ERR
argument_list|(
name|output_unified_token_range
argument_list|(
name|output_baton
argument_list|,
literal|0
comment|/* original */
argument_list|,
name|unified_output_delete
argument_list|,
name|original_start
operator|+
name|original_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_unified_token_range
argument_list|(
name|output_baton
argument_list|,
literal|1
comment|/* modified */
argument_list|,
name|unified_output_insert
argument_list|,
name|modified_start
operator|+
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_diff_output_fns_t
name|mem_output_unified_vtable
init|=
block|{
name|NULL
block|,
comment|/* output_common */
name|output_unified_diff_modified
block|,
name|NULL
block|,
comment|/* output_diff_latest */
name|NULL
block|,
comment|/* output_diff_common */
name|NULL
comment|/* output_conflict */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_diff_mem_string_output_unified2
parameter_list|(
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|,
name|svn_boolean_t
name|with_diff_header
parameter_list|,
specifier|const
name|char
modifier|*
name|hunk_delimiter
parameter_list|,
specifier|const
name|char
modifier|*
name|original_header
parameter_list|,
specifier|const
name|char
modifier|*
name|modified_header
parameter_list|,
specifier|const
name|char
modifier|*
name|header_encoding
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|modified
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_diff_contains_diffs
argument_list|(
name|diff
argument_list|)
condition|)
block|{
name|output_baton_t
name|baton
decl_stmt|;
name|memset
argument_list|(
operator|&
name|baton
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|.
name|output_stream
operator|=
name|output_stream
expr_stmt|;
name|baton
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|.
name|header_encoding
operator|=
name|header_encoding
expr_stmt|;
name|baton
operator|.
name|hunk
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|.
name|hunk_delimiter
operator|=
name|hunk_delimiter
expr_stmt|;
name|baton
operator|.
name|no_newline_string
operator|=
operator|(
name|hunk_delimiter
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|hunk_delimiter
argument_list|,
literal|"##"
argument_list|)
operator|!=
literal|0
operator|)
condition|?
name|APR_EOL_STR
name|SVN_DIFF__NO_NEWLINE_AT_END_OF_FILE
name|APR_EOL_STR
else|:
name|APR_EOL_STR
name|SVN_DIFF__NO_NEWLINE_AT_END_OF_PROPERTY
name|APR_EOL_STR
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|prefix_str
index|[
name|unified_output_context
index|]
operator|)
argument_list|,
literal|" "
argument_list|,
name|header_encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|prefix_str
index|[
name|unified_output_delete
index|]
operator|)
argument_list|,
literal|"-"
argument_list|,
name|header_encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|prefix_str
index|[
name|unified_output_insert
index|]
operator|)
argument_list|,
literal|"+"
argument_list|,
name|header_encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
name|baton
operator|.
name|sources
index|[
literal|0
index|]
argument_list|,
name|original
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
name|baton
operator|.
name|sources
index|[
literal|1
index|]
argument_list|,
name|modified
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_diff_header
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_diff__unidiff_write_header
argument_list|(
name|output_stream
argument_list|,
name|header_encoding
argument_list|,
name|original_header
argument_list|,
name|modified_header
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_diff_output
argument_list|(
name|diff
argument_list|,
operator|&
name|baton
argument_list|,
operator|&
name|mem_output_unified_vtable
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_unified_flush_hunk
argument_list|(
operator|&
name|baton
argument_list|,
name|hunk_delimiter
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|baton
operator|.
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_mem_string_output_unified
parameter_list|(
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|,
specifier|const
name|char
modifier|*
name|original_header
parameter_list|,
specifier|const
name|char
modifier|*
name|modified_header
parameter_list|,
specifier|const
name|char
modifier|*
name|header_encoding
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|modified
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_diff_mem_string_output_unified2
argument_list|(
name|output_stream
argument_list|,
name|diff
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|original_header
argument_list|,
name|modified_header
argument_list|,
name|header_encoding
argument_list|,
name|original
argument_list|,
name|modified
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* diff3 merge output */
end_comment

begin_comment
comment|/* A stream to remember *leading* context.  Note that this stream does    *not* copy the data that it is remembering; it just saves    *pointers! */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|context_saver_t
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
index|[
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|len
index|[
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|next_slot
decl_stmt|;
name|apr_size_t
name|total_written
decl_stmt|;
block|}
name|context_saver_t
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|context_saver_stream_write
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|context_saver_t
modifier|*
name|cs
init|=
name|baton
decl_stmt|;
name|cs
operator|->
name|data
index|[
name|cs
operator|->
name|next_slot
index|]
operator|=
name|data
expr_stmt|;
name|cs
operator|->
name|len
index|[
name|cs
operator|->
name|next_slot
index|]
operator|=
operator|*
name|len
expr_stmt|;
name|cs
operator|->
name|next_slot
operator|=
operator|(
name|cs
operator|->
name|next_slot
operator|+
literal|1
operator|)
operator|%
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
name|cs
operator|->
name|total_written
operator|++
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|merge_output_baton_t
block|{
name|svn_stream_t
modifier|*
name|output_stream
decl_stmt|;
comment|/* Tokenized source text */
name|source_tokens_t
name|sources
index|[
literal|3
index|]
decl_stmt|;
name|apr_off_t
name|next_token
index|[
literal|3
index|]
decl_stmt|;
comment|/* Markers for marking conflicted sections */
specifier|const
name|char
modifier|*
name|markers
index|[
literal|4
index|]
decl_stmt|;
comment|/* 0 = original, 1 = modified,                              2 = separator, 3 = latest (end) */
specifier|const
name|char
modifier|*
name|marker_eol
decl_stmt|;
name|svn_diff_conflict_display_style_t
name|conflict_style
decl_stmt|;
comment|/* The rest of the fields are for      svn_diff_conflict_display_only_conflicts only.  Note that for      these batons, OUTPUT_STREAM is either CONTEXT_SAVER->STREAM or      (soon after a conflict) a "trailing context stream", never the      actual output stream.*/
comment|/* The actual output stream. */
name|svn_stream_t
modifier|*
name|real_output_stream
decl_stmt|;
name|context_saver_t
modifier|*
name|context_saver
decl_stmt|;
comment|/* Used to allocate context_saver and trailing context streams, and      for some printfs. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|merge_output_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|flush_context_saver
parameter_list|(
name|context_saver_t
modifier|*
name|cs
parameter_list|,
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|apr_size_t
name|slot
init|=
operator|(
name|i
operator|+
name|cs
operator|->
name|next_slot
operator|)
operator|%
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|data
index|[
name|slot
index|]
condition|)
block|{
name|apr_size_t
name|len
init|=
name|cs
operator|->
name|len
index|[
name|slot
index|]
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|output_stream
argument_list|,
name|cs
operator|->
name|data
index|[
name|slot
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_context_saver
parameter_list|(
name|merge_output_baton_t
modifier|*
name|mob
parameter_list|)
block|{
name|context_saver_t
modifier|*
name|cs
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|mob
operator|->
name|pool
argument_list|)
expr_stmt|;
name|cs
operator|=
name|apr_pcalloc
argument_list|(
name|mob
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|cs
operator|->
name|stream
operator|=
name|svn_stream_empty
argument_list|(
name|mob
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_baton
argument_list|(
name|cs
operator|->
name|stream
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|cs
operator|->
name|stream
argument_list|,
name|context_saver_stream_write
argument_list|)
expr_stmt|;
name|mob
operator|->
name|context_saver
operator|=
name|cs
expr_stmt|;
name|mob
operator|->
name|output_stream
operator|=
name|cs
operator|->
name|stream
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A stream which prints SVN_DIFF__UNIFIED_CONTEXT_SIZE lines to    BATON->REAL_OUTPUT_STREAM, and then changes BATON->OUTPUT_STREAM to    a context_saver; used for *trailing* context. */
end_comment

begin_struct
struct|struct
name|trailing_context_printer
block|{
name|apr_size_t
name|lines_to_print
decl_stmt|;
name|merge_output_baton_t
modifier|*
name|mob
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|trailing_context_printer_write
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|trailing_context_printer
modifier|*
name|tcp
init|=
name|baton
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|tcp
operator|->
name|lines_to_print
operator|>
literal|0
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|tcp
operator|->
name|mob
operator|->
name|real_output_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|lines_to_print
operator|--
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|lines_to_print
operator|==
literal|0
condition|)
name|make_context_saver
argument_list|(
name|tcp
operator|->
name|mob
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_trailing_context_printer
parameter_list|(
name|merge_output_baton_t
modifier|*
name|btn
parameter_list|)
block|{
name|struct
name|trailing_context_printer
modifier|*
name|tcp
decl_stmt|;
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
name|tcp
operator|=
name|apr_pcalloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|lines_to_print
operator|=
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
expr_stmt|;
name|tcp
operator|->
name|mob
operator|=
name|btn
expr_stmt|;
name|s
operator|=
name|svn_stream_empty
argument_list|(
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_baton
argument_list|(
name|s
argument_list|,
name|tcp
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|s
argument_list|,
name|trailing_context_printer_write
argument_list|)
expr_stmt|;
name|btn
operator|->
name|output_stream
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_merge_token_range
parameter_list|(
name|apr_size_t
modifier|*
name|lines_printed_p
parameter_list|,
name|merge_output_baton_t
modifier|*
name|btn
parameter_list|,
name|int
name|idx
parameter_list|,
name|apr_off_t
name|first
parameter_list|,
name|apr_off_t
name|length
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|tokens
init|=
name|btn
operator|->
name|sources
index|[
name|idx
index|]
operator|.
name|tokens
decl_stmt|;
name|apr_size_t
name|lines_printed
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|length
operator|>
literal|0
operator|&&
name|first
operator|<
name|tokens
operator|->
name|nelts
condition|;
name|length
operator|--
operator|,
name|first
operator|++
control|)
block|{
name|svn_string_t
modifier|*
name|token
init|=
name|APR_ARRAY_IDX
argument_list|(
name|tokens
argument_list|,
name|first
argument_list|,
name|svn_string_t
operator|*
argument_list|)
decl_stmt|;
name|apr_size_t
name|len
init|=
name|token
operator|->
name|len
decl_stmt|;
comment|/* Note that the trailing context printer assumes that          svn_stream_write is called exactly once per line. */
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|token
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|lines_printed
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lines_printed_p
condition|)
operator|*
name|lines_printed_p
operator|=
name|lines_printed
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_marker_eol
parameter_list|(
name|merge_output_baton_t
modifier|*
name|btn
parameter_list|)
block|{
return|return
name|svn_stream_puts
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|marker_eol
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_merge_marker
parameter_list|(
name|merge_output_baton_t
modifier|*
name|btn
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|markers
index|[
name|idx
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|output_marker_eol
argument_list|(
name|btn
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_common_modified
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
return|return
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|baton
argument_list|,
literal|1
comment|/*modified*/
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_latest
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
return|return
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|baton
argument_list|,
literal|2
comment|/*latest*/
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|output_conflict
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|svn_diff_output_fns_t
name|merge_output_vtable
init|=
block|{
name|output_common_modified
block|,
comment|/* common */
name|output_common_modified
block|,
comment|/* modified */
name|output_latest
block|,
name|output_common_modified
block|,
comment|/* output_diff_common */
name|output_conflict
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_conflict
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|merge_output_baton_t
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_diff_conflict_display_style_t
name|style
init|=
name|btn
operator|->
name|conflict_style
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_resolved_modified_latest
condition|)
block|{
if|if
condition|(
name|diff
condition|)
return|return
name|svn_diff_output
argument_list|(
name|diff
argument_list|,
name|baton
argument_list|,
operator|&
name|merge_output_vtable
argument_list|)
return|;
else|else
name|style
operator|=
name|svn_diff_conflict_display_modified_latest
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_modified_latest
operator|||
name|style
operator|==
name|svn_diff_conflict_display_modified_original_latest
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_merge_marker
argument_list|(
name|btn
argument_list|,
literal|1
comment|/*modified*/
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|btn
argument_list|,
literal|1
comment|/*modified*/
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_modified_original_latest
condition|)
block|{
name|SVN_ERR
argument_list|(
name|output_merge_marker
argument_list|(
name|btn
argument_list|,
literal|0
comment|/*original*/
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|btn
argument_list|,
literal|0
comment|/*original*/
argument_list|,
name|original_start
argument_list|,
name|original_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|output_merge_marker
argument_list|(
name|btn
argument_list|,
literal|2
comment|/*separator*/
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|btn
argument_list|,
literal|2
comment|/*latest*/
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_merge_marker
argument_list|(
name|btn
argument_list|,
literal|3
comment|/*latest (end)*/
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_modified
condition|)
name|SVN_ERR
argument_list|(
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|btn
argument_list|,
literal|1
comment|/*modified*/
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|style
operator|==
name|svn_diff_conflict_display_latest
condition|)
name|SVN_ERR
argument_list|(
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|btn
argument_list|,
literal|2
comment|/*latest*/
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* unknown style */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_conflict_with_context
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|merge_output_baton_t
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
comment|/* Are we currently saving starting context (as opposed to printing      trailing context)?  If so, flush it. */
if|if
condition|(
name|btn
operator|->
name|output_stream
operator|==
name|btn
operator|->
name|context_saver
operator|->
name|stream
condition|)
block|{
if|if
condition|(
name|btn
operator|->
name|context_saver
operator|->
name|total_written
operator|>
name|SVN_DIFF__UNIFIED_CONTEXT_SIZE
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|btn
operator|->
name|real_output_stream
argument_list|,
literal|"@@\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|flush_context_saver
argument_list|(
name|btn
operator|->
name|context_saver
argument_list|,
name|btn
operator|->
name|real_output_stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Print to the real output stream. */
name|btn
operator|->
name|output_stream
operator|=
name|btn
operator|->
name|real_output_stream
expr_stmt|;
comment|/* Output the conflict itself. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|pool
argument_list|,
operator|(
name|modified_length
operator|==
literal|1
condition|?
literal|"%s (%"
name|APR_OFF_T_FMT
literal|")"
else|:
literal|"%s (%"
name|APR_OFF_T_FMT
literal|",%"
name|APR_OFF_T_FMT
literal|")"
operator|)
argument_list|,
name|btn
operator|->
name|markers
index|[
literal|1
index|]
argument_list|,
name|modified_start
operator|+
literal|1
argument_list|,
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|btn
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|btn
argument_list|,
literal|1
comment|/*modified*/
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|pool
argument_list|,
operator|(
name|original_length
operator|==
literal|1
condition|?
literal|"%s (%"
name|APR_OFF_T_FMT
literal|")"
else|:
literal|"%s (%"
name|APR_OFF_T_FMT
literal|",%"
name|APR_OFF_T_FMT
literal|")"
operator|)
argument_list|,
name|btn
operator|->
name|markers
index|[
literal|0
index|]
argument_list|,
name|original_start
operator|+
literal|1
argument_list|,
name|original_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|btn
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|btn
argument_list|,
literal|0
comment|/*original*/
argument_list|,
name|original_start
argument_list|,
name|original_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_merge_marker
argument_list|(
name|btn
argument_list|,
literal|2
comment|/*separator*/
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_merge_token_range
argument_list|(
name|NULL
argument_list|,
name|btn
argument_list|,
literal|2
comment|/*latest*/
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|btn
operator|->
name|output_stream
argument_list|,
name|btn
operator|->
name|pool
argument_list|,
operator|(
name|latest_length
operator|==
literal|1
condition|?
literal|"%s (%"
name|APR_OFF_T_FMT
literal|")"
else|:
literal|"%s (%"
name|APR_OFF_T_FMT
literal|",%"
name|APR_OFF_T_FMT
literal|")"
operator|)
argument_list|,
name|btn
operator|->
name|markers
index|[
literal|3
index|]
argument_list|,
name|latest_start
operator|+
literal|1
argument_list|,
name|latest_length
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|output_marker_eol
argument_list|(
name|btn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go into print-trailing-context mode instead. */
name|make_trailing_context_printer
argument_list|(
name|btn
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_diff_output_fns_t
name|merge_only_conflicts_output_vtable
init|=
block|{
name|output_common_modified
block|,
name|output_common_modified
block|,
name|output_latest
block|,
name|output_common_modified
block|,
name|output_conflict_with_context
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TOKEN is the first token in the modified file.    Return its line-ending, if any. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|detect_eol
parameter_list|(
name|svn_string_t
modifier|*
name|token
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|curp
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|len
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|curp
operator|=
name|token
operator|->
name|data
operator|+
name|token
operator|->
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|curp
operator|==
literal|'\r'
condition|)
return|return
literal|"\r"
return|;
elseif|else
if|if
condition|(
operator|*
name|curp
operator|!=
literal|'\n'
condition|)
return|return
name|NULL
return|;
else|else
block|{
if|if
condition|(
name|token
operator|->
name|len
operator|==
literal|1
operator|||
operator|*
operator|(
operator|--
name|curp
operator|)
operator|!=
literal|'\r'
condition|)
return|return
literal|"\n"
return|;
else|else
return|return
literal|"\r\n"
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_mem_string_output_merge2
parameter_list|(
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|modified
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|latest
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_original
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_modified
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_latest
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_separator
parameter_list|,
name|svn_diff_conflict_display_style_t
name|style
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|merge_output_baton_t
name|btn
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
name|svn_boolean_t
name|conflicts_only
init|=
operator|(
name|style
operator|==
name|svn_diff_conflict_display_only_conflicts
operator|)
decl_stmt|;
specifier|const
name|svn_diff_output_fns_t
modifier|*
name|vtable
init|=
name|conflicts_only
condition|?
operator|&
name|merge_only_conflicts_output_vtable
else|:
operator|&
name|merge_output_vtable
decl_stmt|;
name|memset
argument_list|(
operator|&
name|btn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|btn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicts_only
condition|)
block|{
name|btn
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|make_context_saver
argument_list|(
operator|&
name|btn
argument_list|)
expr_stmt|;
name|btn
operator|.
name|real_output_stream
operator|=
name|output_stream
expr_stmt|;
block|}
else|else
name|btn
operator|.
name|output_stream
operator|=
name|output_stream
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|btn
operator|.
name|sources
index|[
literal|0
index|]
operator|)
argument_list|,
name|original
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|btn
operator|.
name|sources
index|[
literal|1
index|]
operator|)
argument_list|,
name|modified
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fill_source_tokens
argument_list|(
operator|&
operator|(
name|btn
operator|.
name|sources
index|[
literal|2
index|]
operator|)
argument_list|,
name|latest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|btn
operator|.
name|conflict_style
operator|=
name|style
expr_stmt|;
if|if
condition|(
name|btn
operator|.
name|sources
index|[
literal|1
index|]
operator|.
name|tokens
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|eol
operator|=
name|detect_eol
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|btn
operator|.
name|sources
index|[
literal|1
index|]
operator|.
name|tokens
argument_list|,
literal|0
argument_list|,
name|svn_string_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
condition|)
name|eol
operator|=
name|APR_EOL_STR
expr_stmt|;
comment|/* use the platform default */
block|}
else|else
name|eol
operator|=
name|APR_EOL_STR
expr_stmt|;
comment|/* use the platform default */
name|btn
operator|.
name|marker_eol
operator|=
name|eol
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|btn
operator|.
name|markers
index|[
literal|1
index|]
argument_list|,
name|conflict_modified
condition|?
name|conflict_modified
else|:
literal|"<<<<<<< (modified)"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|btn
operator|.
name|markers
index|[
literal|0
index|]
argument_list|,
name|conflict_original
condition|?
name|conflict_original
else|:
literal|"||||||| (original)"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|btn
operator|.
name|markers
index|[
literal|2
index|]
argument_list|,
name|conflict_separator
condition|?
name|conflict_separator
else|:
literal|"======="
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|btn
operator|.
name|markers
index|[
literal|3
index|]
argument_list|,
name|conflict_latest
condition|?
name|conflict_latest
else|:
literal|">>>>>>> (latest)"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_output
argument_list|(
name|diff
argument_list|,
operator|&
name|btn
argument_list|,
name|vtable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicts_only
condition|)
name|svn_pool_destroy
argument_list|(
name|btn
operator|.
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_diff_mem_string_output_merge
parameter_list|(
name|svn_stream_t
modifier|*
name|output_stream
parameter_list|,
name|svn_diff_t
modifier|*
name|diff
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|modified
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|latest
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_original
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_modified
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_latest
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_separator
parameter_list|,
name|svn_boolean_t
name|display_original_in_conflict
parameter_list|,
name|svn_boolean_t
name|display_resolved_conflicts
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff_conflict_display_style_t
name|style
init|=
name|svn_diff_conflict_display_modified_latest
decl_stmt|;
if|if
condition|(
name|display_resolved_conflicts
condition|)
name|style
operator|=
name|svn_diff_conflict_display_resolved_modified_latest
expr_stmt|;
if|if
condition|(
name|display_original_in_conflict
condition|)
name|style
operator|=
name|svn_diff_conflict_display_modified_original_latest
expr_stmt|;
return|return
name|svn_diff_mem_string_output_merge2
argument_list|(
name|output_stream
argument_list|,
name|diff
argument_list|,
name|original
argument_list|,
name|modified
argument_list|,
name|latest
argument_list|,
name|conflict_original
argument_list|,
name|conflict_modified
argument_list|,
name|conflict_latest
argument_list|,
name|conflict_separator
argument_list|,
name|style
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

end_unit

