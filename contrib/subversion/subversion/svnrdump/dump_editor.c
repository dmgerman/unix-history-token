begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  dump_editor.c: The svn_delta_editor_t editor used by svnrdump to  *  dump revisions.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_editor.h"
end_include

begin_include
include|#
directive|include
file|"svnrdump.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|ARE_VALID_COPY_ARGS
parameter_list|(
name|p
parameter_list|,
name|r
parameter_list|)
value|((p)&& SVN_IS_VALID_REVNUM(r))
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|LDR_DBG
parameter_list|(
name|x
parameter_list|)
value|SVN_DBG(x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LDR_DBG
parameter_list|(
name|x
parameter_list|)
value|while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A directory baton used by all directory-related callback functions  * in the dump editor.  */
end_comment

begin_struct
struct|struct
name|dir_baton
block|{
name|struct
name|dump_edit_baton
modifier|*
name|eb
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|parent_dir_baton
decl_stmt|;
comment|/* Pool for per-directory allocations */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* is this directory a new addition to this revision? */
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* has this directory been written to the output stream? */
name|svn_boolean_t
name|written_out
decl_stmt|;
comment|/* the path to this directory */
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
comment|/* a relpath */
comment|/* Copyfrom info for the node, if any. */
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
comment|/* a relpath */
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* Properties which were modified during change_dir_prop. */
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* Properties which were deleted during change_dir_prop. */
name|apr_hash_t
modifier|*
name|deleted_props
decl_stmt|;
comment|/* Hash of paths that need to be deleted, though some -might- be      replaced.  Maps const char * paths to this dir_baton. Note that      they're full paths, because that's what the editor driver gives      us, although they're all really within this directory. */
name|apr_hash_t
modifier|*
name|deleted_entries
decl_stmt|;
comment|/* Flags to trigger dumping props and record termination newlines. */
name|svn_boolean_t
name|dump_props
decl_stmt|;
name|svn_boolean_t
name|dump_newlines
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A file baton used by all file-related callback functions in the dump  * editor */
end_comment

begin_struct
struct|struct
name|file_baton
block|{
name|struct
name|dump_edit_baton
modifier|*
name|eb
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|parent_dir_baton
decl_stmt|;
comment|/* Pool for per-file allocations */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* the path to this file */
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
comment|/* a relpath */
comment|/* Properties which were modified during change_file_prop. */
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* Properties which were deleted during change_file_prop. */
name|apr_hash_t
modifier|*
name|deleted_props
decl_stmt|;
comment|/* The checksum of the file the delta is being applied to */
specifier|const
name|char
modifier|*
name|base_checksum
decl_stmt|;
comment|/* Copy state and source information (if any). */
name|svn_boolean_t
name|is_copy
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* The action associate with this node. */
name|enum
name|svn_node_action
name|action
decl_stmt|;
comment|/* Flags to trigger dumping props and text. */
name|svn_boolean_t
name|dump_text
decl_stmt|;
name|svn_boolean_t
name|dump_props
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A handler baton to be used in window_handler().  */
end_comment

begin_struct
struct|struct
name|handler_baton
block|{
name|svn_txdelta_window_handler_t
name|apply_handler
decl_stmt|;
name|void
modifier|*
name|apply_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The baton used by the dump editor. */
end_comment

begin_struct
struct|struct
name|dump_edit_baton
block|{
comment|/* The output stream we write the dumpfile to */
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* A backdoor ra session to fetch additional information during the edit. */
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
comment|/* The repository relpath of the anchor of the editor when driven      via the RA update mechanism; NULL otherwise. (When the editor is      driven via the RA "replay" mechanism instead, the editor is      always anchored at the repository, we don't need to prepend an      anchor path to the dumped node paths, and open_root() doesn't      need to manufacture directory additions.)  */
specifier|const
name|char
modifier|*
name|update_anchor_relpath
decl_stmt|;
comment|/* Pool for per-revision allocations */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Temporary file used for textdelta application along with its      absolute path; these two variables should be allocated in the      per-edit-session pool */
specifier|const
name|char
modifier|*
name|delta_abspath
decl_stmt|;
name|apr_file_t
modifier|*
name|delta_file
decl_stmt|;
comment|/* The revision we're currently dumping. */
name|svn_revnum_t
name|current_revision
decl_stmt|;
comment|/* The kind (file or directory) and baton of the item whose block of      dump stream data has not been fully completed; NULL if there's no      such item. */
name|svn_node_kind_t
name|pending_kind
decl_stmt|;
name|void
modifier|*
name|pending_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make a directory baton to represent the directory at PATH (relative  * to the EDIT_BATON).  *  * COPYFROM_PATH/COPYFROM_REV are the path/revision against which this  * directory should be compared for changes. If the copyfrom  * information is valid, the directory will be compared against its  * copy source.  *  * PB is the directory baton of this directory's parent, or NULL if  * this is the top-level directory of the edit.  ADDED indicates if  * this directory is newly added in this revision.  Perform all  * allocations in POOL.  */
end_comment

begin_function
specifier|static
name|struct
name|dir_baton
modifier|*
name|make_dir_baton
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|pb
parameter_list|,
name|svn_boolean_t
name|added
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dump_edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_db
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
comment|/* Construct the full path of this node. */
if|if
condition|(
name|pb
condition|)
name|repos_relpath
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|repos_relpath
operator|=
literal|""
expr_stmt|;
comment|/* Strip leading slash from copyfrom_path so that the path is      canonical and svn_relpath_join can be used */
if|if
condition|(
name|copyfrom_path
condition|)
name|copyfrom_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|copyfrom_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_db
operator|->
name|eb
operator|=
name|eb
expr_stmt|;
name|new_db
operator|->
name|parent_dir_baton
operator|=
name|pb
expr_stmt|;
name|new_db
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|new_db
operator|->
name|repos_relpath
operator|=
name|repos_relpath
expr_stmt|;
name|new_db
operator|->
name|copyfrom_path
operator|=
name|copyfrom_path
condition|?
name|svn_relpath_canonicalize
argument_list|(
name|copyfrom_path
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|new_db
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
name|new_db
operator|->
name|added
operator|=
name|added
expr_stmt|;
name|new_db
operator|->
name|written_out
operator|=
name|FALSE
expr_stmt|;
name|new_db
operator|->
name|props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|new_db
operator|->
name|deleted_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|new_db
operator|->
name|deleted_entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|new_db
return|;
block|}
end_function

begin_comment
comment|/* Make a file baton to represent the directory at PATH (relative to  * PB->eb).  PB is the directory baton of this directory's parent, or  * NULL if this is the top-level directory of the edit.  Perform all  * allocations in POOL.  */
end_comment

begin_function
specifier|static
name|struct
name|file_baton
modifier|*
name|make_file_baton
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|pb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|new_fb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_fb
argument_list|)
argument_list|)
decl_stmt|;
name|new_fb
operator|->
name|eb
operator|=
name|pb
operator|->
name|eb
expr_stmt|;
name|new_fb
operator|->
name|parent_dir_baton
operator|=
name|pb
expr_stmt|;
name|new_fb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|new_fb
operator|->
name|repos_relpath
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_fb
operator|->
name|props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|new_fb
operator|->
name|deleted_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|new_fb
operator|->
name|is_copy
operator|=
name|FALSE
expr_stmt|;
name|new_fb
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|new_fb
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|new_fb
operator|->
name|action
operator|=
name|svn_node_action_change
expr_stmt|;
return|return
name|new_fb
return|;
block|}
end_function

begin_comment
comment|/* Return in *HEADER and *CONTENT the headers and content for PROPS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_props_content
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|header
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|content
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_hash_t
modifier|*
name|deleted_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|content_stream
decl_stmt|;
name|apr_hash_t
modifier|*
name|normal_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
operator|*
name|content
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|header
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|content_stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
operator|*
name|content
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rdump__normalize_props
argument_list|(
operator|&
name|normal_props
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write_incremental
argument_list|(
name|normal_props
argument_list|,
name|deleted_props
argument_list|,
name|content_stream
argument_list|,
literal|"PROPS-END"
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|content_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prop-delta: true */
operator|*
name|header
operator|=
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_DELTA
literal|": true\n"
argument_list|)
expr_stmt|;
comment|/* Prop-content-length: 193 */
name|buf
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
literal|": %"
name|APR_SIZE_T_FMT
literal|"\n"
argument_list|,
operator|(
operator|*
name|content
operator|)
operator|->
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|header
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Extract and dump properties stored in PROPS and property deletions  * stored in DELETED_PROPS. If TRIGGER_VAR is not NULL, it is set to  * FALSE.  *  * If PROPSTRING is non-NULL, set *PROPSTRING to a string containing  * the content block of the property changes; otherwise, dump that to  * the stream, too.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_dump_props
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|propstring
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_hash_t
modifier|*
name|deleted_props
parameter_list|,
name|svn_boolean_t
modifier|*
name|trigger_var
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|header
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
if|if
condition|(
name|trigger_var
operator|&&
operator|!
operator|*
name|trigger_var
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|get_props_content
argument_list|(
operator|&
name|header
argument_list|,
operator|&
name|content
argument_list|,
name|props
argument_list|,
name|deleted_props
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|header
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|header
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|propstring
condition|)
block|{
operator|*
name|propstring
operator|=
name|content
expr_stmt|;
block|}
else|else
block|{
comment|/* Content-length: 14 */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
literal|": %"
name|APR_SIZE_T_FMT
literal|"\n\n"
argument_list|,
name|content
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|content
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|content
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No text is going to be dumped. Write a couple of newlines and          wait for the next node/ revision. */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
literal|"\n\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cleanup so that data is never dumped twice. */
name|apr_hash_clear
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|apr_hash_clear
argument_list|(
name|deleted_props
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger_var
condition|)
operator|*
name|trigger_var
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_dump_newlines
parameter_list|(
name|struct
name|dump_edit_baton
modifier|*
name|eb
parameter_list|,
name|svn_boolean_t
modifier|*
name|trigger_var
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|trigger_var
operator|&&
operator|*
name|trigger_var
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
literal|"\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|trigger_var
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Write out a node record for PATH of type KIND under EB->FS_ROOT.  * ACTION describes what is happening to the node (see enum  * svn_node_action). Write record to writable EB->STREAM, using  * EB->BUFFER to write in chunks.  *  * If the node was itself copied, IS_COPY is TRUE and the  * path/revision of the copy source are in COPYFROM_PATH/COPYFROM_REV.  * If IS_COPY is FALSE, yet COPYFROM_PATH/COPYFROM_REV are valid, this  * node is part of a copied subtree.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_node
parameter_list|(
name|struct
name|dump_edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|db
parameter_list|,
name|struct
name|file_baton
modifier|*
name|fb
parameter_list|,
name|enum
name|svn_node_action
name|action
parameter_list|,
name|svn_boolean_t
name|is_copy
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|node_relpath
init|=
name|repos_relpath
decl_stmt|;
name|assert
argument_list|(
name|svn_relpath_is_canonical
argument_list|(
name|repos_relpath
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|copyfrom_path
operator|||
name|svn_relpath_is_canonical
argument_list|(
name|copyfrom_path
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|db
operator|&&
name|fb
operator|)
argument_list|)
expr_stmt|;
comment|/* Add the edit root relpath prefix if necessary. */
if|if
condition|(
name|eb
operator|->
name|update_anchor_relpath
condition|)
name|node_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|eb
operator|->
name|update_anchor_relpath
argument_list|,
name|node_relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Node-path: ... */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
literal|": %s\n"
argument_list|,
name|node_relpath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Node-kind: "file" | "dir" */
if|if
condition|(
name|fb
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
literal|": file\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|db
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
literal|": dir\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the appropriate Node-action header */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|svn_node_action_change
case|:
comment|/* We are here after a change_file_prop or change_dir_prop. They          set up whatever dump_props they needed to- nothing to          do here but print node action information.           Node-action: change.  */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": change\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_action_replace
case|:
if|if
condition|(
name|is_copy
condition|)
block|{
comment|/* Delete the original, and then re-add the replacement as a              copy using recursive calls into this function. */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|repos_relpath
argument_list|,
name|db
argument_list|,
name|fb
argument_list|,
name|svn_node_action_delete
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|repos_relpath
argument_list|,
name|db
argument_list|,
name|fb
argument_list|,
name|svn_node_action_add
argument_list|,
name|is_copy
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Node-action: replace */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": replace\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wait for a change_*_prop to be called before dumping              anything */
if|if
condition|(
name|fb
condition|)
name|fb
operator|->
name|dump_props
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|db
condition|)
name|db
operator|->
name|dump_props
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|svn_node_action_delete
case|:
comment|/* Node-action: delete */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": delete\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can leave this routine quietly now. Nothing more to do-          print a couple of newlines because we're not dumping props or          text. */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
literal|"\n\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_action_add
case|:
comment|/* Node-action: add */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": add\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_copy
condition|)
block|{
comment|/* Node-copyfrom-rev / Node-copyfrom-path */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
literal|": %ld\n"
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH
literal|": %s\n"
argument_list|,
name|copyfrom_rev
argument_list|,
name|copyfrom_path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ugly hack: If a directory was copied from a previous              revision, nothing like close_file() will be called to write two              blank lines. If change_dir_prop() is called, props are dumped              (along with the necessary PROPS-END\n\n and we're good. So              set DUMP_NEWLINES here to print the newlines unless              change_dir_prop() is called next otherwise the `svnadmin load`              parser will fail.  */
if|if
condition|(
name|db
condition|)
name|db
operator|->
name|dump_newlines
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* fb->dump_props (for files) is handled in close_file()              which is called immediately.               However, directories are not closed until all the work              inside them has been done; db->dump_props (for directories)              is handled (via dump_pending()) in all the functions that              can possibly be called after add_directory():                 - add_directory()                - open_directory()                - delete_entry()                - close_directory()                - add_file()                - open_file()               change_dir_prop() is a special case. */
if|if
condition|(
name|fb
condition|)
name|fb
operator|->
name|dump_props
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|db
condition|)
name|db
operator|->
name|dump_props
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_mkdir
parameter_list|(
name|struct
name|dump_edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|prop_header
decl_stmt|,
modifier|*
name|prop_content
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Node-path: ... */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
literal|": %s\n"
argument_list|,
name|repos_relpath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Node-kind: dir */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
literal|": dir\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Node-action: add */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": add\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump the (empty) property block. */
name|SVN_ERR
argument_list|(
name|get_props_content
argument_list|(
operator|&
name|prop_header
argument_list|,
operator|&
name|prop_content
argument_list|,
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
argument_list|,
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|prop_header
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|prop_header
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|prop_content
operator|->
name|len
expr_stmt|;
name|buf
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
literal|": %"
name|APR_SIZE_T_FMT
literal|"\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|prop_content
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Newlines to tie it all off. */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
literal|"\n\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Dump pending items from the specified node, to allow starting the dump    of a child node */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_pending
parameter_list|(
name|struct
name|dump_edit_baton
modifier|*
name|eb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|eb
operator|->
name|pending_baton
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|eb
operator|->
name|pending_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|eb
operator|->
name|pending_baton
decl_stmt|;
comment|/* Some pending properties to dump? */
name|SVN_ERR
argument_list|(
name|do_dump_props
argument_list|(
name|NULL
argument_list|,
name|eb
operator|->
name|stream
argument_list|,
name|db
operator|->
name|props
argument_list|,
name|db
operator|->
name|deleted_props
argument_list|,
operator|&
operator|(
name|db
operator|->
name|dump_props
operator|)
argument_list|,
name|db
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some pending newlines to dump? */
name|SVN_ERR
argument_list|(
name|do_dump_newlines
argument_list|(
name|eb
argument_list|,
operator|&
operator|(
name|db
operator|->
name|dump_newlines
operator|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eb
operator|->
name|pending_kind
operator|==
name|svn_node_file
condition|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|eb
operator|->
name|pending_baton
decl_stmt|;
comment|/* Some pending properties to dump? */
name|SVN_ERR
argument_list|(
name|do_dump_props
argument_list|(
name|NULL
argument_list|,
name|eb
operator|->
name|stream
argument_list|,
name|fb
operator|->
name|props
argument_list|,
name|fb
operator|->
name|deleted_props
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|dump_props
operator|)
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Anything that was pending is pending no longer. */
name|eb
operator|->
name|pending_baton
operator|=
name|NULL
expr_stmt|;
name|eb
operator|->
name|pending_kind
operator|=
name|svn_node_none
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Editor Function Implementations ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|struct
name|dump_edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
init|=
name|NULL
decl_stmt|;
comment|/* Clear the per-revision pool after each revision */
name|svn_pool_clear
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"open_root %p\n"
operator|,
operator|*
name|root_baton
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|update_anchor_relpath
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_path
init|=
name|eb
operator|->
name|update_anchor_relpath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|dirs_to_add
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|svn_path_is_empty
argument_list|(
name|parent_path
argument_list|)
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|dirs_to_add
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|parent_path
expr_stmt|;
name|parent_path
operator|=
name|svn_relpath_dirname
argument_list|(
name|parent_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|dirs_to_add
operator|->
name|nelts
init|;
name|i
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|dir_to_add
init|=
name|APR_ARRAY_IDX
argument_list|(
name|dirs_to_add
argument_list|,
name|i
operator|-
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* For parents of the source directory, we just manufacture              the adds ourselves. */
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|dump_mkdir
argument_list|(
name|eb
argument_list|,
name|dir_to_add
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ... but for the source directory itself, we'll defer                  to letting the typical plumbing handle this task. */
name|new_db
operator|=
name|make_dir_baton
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|new_db
operator|->
name|repos_relpath
argument_list|,
name|new_db
argument_list|,
name|NULL
argument_list|,
name|svn_node_action_add
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember that we've started but not yet finished                  handling this directory. */
name|new_db
operator|->
name|written_out
operator|=
name|TRUE
expr_stmt|;
name|eb
operator|->
name|pending_baton
operator|=
name|new_db
expr_stmt|;
name|eb
operator|->
name|pending_kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|new_db
condition|)
block|{
name|new_db
operator|=
name|make_dir_baton
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|root_baton
operator|=
name|new_db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"delete_entry %s\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_pending
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't dump this deletion immediate.  Rather, we add this path      to the deleted_entries of the parent directory baton.  That way,      we can tell (later) an addition from a replacement.  All the real      deletions get handled in close_directory().  */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|apr_pstrdup
argument_list|(
name|pb
operator|->
name|eb
operator|->
name|pool
argument_list|,
name|path
argument_list|)
argument_list|,
name|pb
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
decl_stmt|;
name|svn_boolean_t
name|is_copy
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"add_directory %s\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_pending
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_db
operator|=
name|make_dir_baton
argument_list|(
name|path
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|pb
operator|->
name|eb
argument_list|,
name|pb
argument_list|,
name|TRUE
argument_list|,
name|pb
operator|->
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* This might be a replacement -- is the path already deleted? */
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Detect an add-with-history */
name|is_copy
operator|=
name|ARE_VALID_COPY_ARGS
argument_list|(
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|)
expr_stmt|;
comment|/* Dump the node */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|new_db
operator|->
name|repos_relpath
argument_list|,
name|new_db
argument_list|,
name|NULL
argument_list|,
name|val
condition|?
name|svn_node_action_replace
else|:
name|svn_node_action_add
argument_list|,
name|is_copy
argument_list|,
name|is_copy
condition|?
name|new_db
operator|->
name|copyfrom_path
else|:
name|NULL
argument_list|,
name|is_copy
condition|?
name|copyfrom_rev
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
comment|/* Delete the path, it's now been dumped */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Remember that we've started, but not yet finished handling this      directory. */
name|new_db
operator|->
name|written_out
operator|=
name|TRUE
expr_stmt|;
name|pb
operator|->
name|eb
operator|->
name|pending_baton
operator|=
name|new_db
expr_stmt|;
name|pb
operator|->
name|eb
operator|->
name|pending_kind
operator|=
name|svn_node_dir
expr_stmt|;
operator|*
name|child_baton
operator|=
name|new_db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"open_directory %s\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_pending
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the parent directory has explicit comparison path and rev,      record the same for this one. */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|pb
operator|->
name|copyfrom_path
argument_list|,
name|pb
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|copyfrom_path
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|copyfrom_path
argument_list|,
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|pb
operator|->
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|copyfrom_rev
operator|=
name|pb
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
name|new_db
operator|=
name|make_dir_baton
argument_list|(
name|path
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|pb
operator|->
name|eb
argument_list|,
name|pb
argument_list|,
name|FALSE
argument_list|,
name|pb
operator|->
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|new_db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|this_pending
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"close_directory %p\n"
operator|,
name|dir_baton
operator|)
argument_list|)
expr_stmt|;
comment|/* Remember if this directory is the one currently pending. */
name|this_pending
operator|=
operator|(
name|db
operator|->
name|eb
operator|->
name|pending_baton
operator|==
name|db
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_pending
argument_list|(
name|db
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this directory was pending, then dump_pending() should have      taken care of all the props and such.  Of course, the only way      that would be the case is if this directory was added/replaced.       Otherwise, if stuff for this directory has already been written      out (at some point in the past, prior to our handling other      nodes), we might need to generate a second "change" record just      to carry the information we've since learned about the      directory. */
if|if
condition|(
operator|(
operator|!
name|this_pending
operator|)
operator|&&
operator|(
name|db
operator|->
name|dump_props
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|db
operator|->
name|eb
argument_list|,
name|db
operator|->
name|repos_relpath
argument_list|,
name|db
argument_list|,
name|NULL
argument_list|,
name|svn_node_action_change
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|eb
operator|->
name|pending_baton
operator|=
name|db
expr_stmt|;
name|db
operator|->
name|eb
operator|->
name|pending_kind
operator|=
name|svn_node_dir
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_pending
argument_list|(
name|db
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the deleted directory entries */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|db
operator|->
name|deleted_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|db
operator|->
name|eb
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_node_action_delete
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### should be unnecessary */
name|apr_hash_clear
argument_list|(
name|db
operator|->
name|deleted_entries
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"add_file %s\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_pending
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the file baton. */
name|fb
operator|=
name|make_file_baton
argument_list|(
name|path
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* This might be a replacement -- is the path already deleted? */
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Detect add-with-history. */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|fb
operator|->
name|copyfrom_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|copyfrom_path
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|fb
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
name|fb
operator|->
name|is_copy
operator|=
name|TRUE
expr_stmt|;
block|}
name|fb
operator|->
name|action
operator|=
name|val
condition|?
name|svn_node_action_replace
else|:
name|svn_node_action_add
expr_stmt|;
comment|/* Delete the path, it's now been dumped. */
if|if
condition|(
name|val
condition|)
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|ancestor_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"open_file %s\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_pending
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the file baton. */
name|fb
operator|=
name|make_file_baton
argument_list|(
name|path
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If the parent directory has explicit copyfrom path and rev,      record the same for this one. */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|pb
operator|->
name|copyfrom_path
argument_list|,
name|pb
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|fb
operator|->
name|copyfrom_path
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|copyfrom_path
argument_list|,
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|pb
operator|->
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|fb
operator|->
name|copyfrom_rev
operator|=
name|pb
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|parent_baton
decl_stmt|;
name|svn_boolean_t
name|this_pending
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"change_dir_prop %p\n"
operator|,
name|parent_baton
operator|)
argument_list|)
expr_stmt|;
comment|/* This directory is not pending, but something else is, so handle      the "something else".  */
name|this_pending
operator|=
operator|(
name|db
operator|->
name|eb
operator|->
name|pending_baton
operator|==
name|db
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_pending
condition|)
name|SVN_ERR
argument_list|(
name|dump_pending
argument_list|(
name|db
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
operator|!=
name|svn_prop_regular_kind
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|value
condition|)
name|svn_hash_sets
argument_list|(
name|db
operator|->
name|props
argument_list|,
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|db
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_hash_sets
argument_list|(
name|db
operator|->
name|deleted_props
argument_list|,
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Make sure we eventually output the props, and disable printing      a couple of extra newlines */
name|db
operator|->
name|dump_newlines
operator|=
name|FALSE
expr_stmt|;
name|db
operator|->
name|dump_props
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"change_file_prop %p\n"
operator|,
name|file_baton
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
operator|!=
name|svn_prop_regular_kind
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|value
condition|)
name|svn_hash_sets
argument_list|(
name|fb
operator|->
name|props
argument_list|,
name|apr_pstrdup
argument_list|(
name|fb
operator|->
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_hash_sets
argument_list|(
name|fb
operator|->
name|deleted_props
argument_list|,
name|apr_pstrdup
argument_list|(
name|fb
operator|->
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Dump the property headers and wait; close_file might need      to write text headers too depending on whether      apply_textdelta is called */
name|fb
operator|->
name|dump_props
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_handler
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|handler_baton
modifier|*
name|hb
init|=
name|baton
decl_stmt|;
specifier|static
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|hb
operator|->
name|apply_handler
argument_list|(
name|window
argument_list|,
name|hb
operator|->
name|apply_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|!=
name|NULL
operator|&&
operator|!
name|err
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|err
condition|)
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|dump_edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|eb
decl_stmt|;
name|struct
name|handler_baton
modifier|*
name|hb
decl_stmt|;
name|svn_stream_t
modifier|*
name|delta_filestream
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"apply_textdelta %p\n"
operator|,
name|file_baton
operator|)
argument_list|)
expr_stmt|;
comment|/* This is custom handler_baton, allocated from a separate pool.  */
name|hb
operator|=
name|apr_pcalloc
argument_list|(
name|eb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use a temporary file to measure the Text-content-length */
name|delta_filestream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|eb
operator|->
name|delta_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Prepare to write the delta to the delta_filestream */
name|svn_txdelta_to_svndiff3
argument_list|(
operator|&
operator|(
name|hb
operator|->
name|apply_handler
operator|)
argument_list|,
operator|&
operator|(
name|hb
operator|->
name|apply_baton
operator|)
argument_list|,
name|delta_filestream
argument_list|,
literal|0
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Record that there's text to be dumped, and its base checksum. */
name|fb
operator|->
name|dump_text
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|base_checksum
operator|=
name|apr_pstrdup
argument_list|(
name|eb
operator|->
name|pool
argument_list|,
name|base_checksum
argument_list|)
expr_stmt|;
comment|/* The actual writing takes place when this function has      finished. Set handler and handler_baton now so for      window_handler() */
operator|*
name|handler
operator|=
name|window_handler
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|hb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|dump_edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|eb
decl_stmt|;
name|apr_finfo_t
modifier|*
name|info
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_finfo_t
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|propstring
decl_stmt|;
name|LDR_DBG
argument_list|(
operator|(
literal|"close_file %p\n"
operator|,
name|file_baton
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_pending
argument_list|(
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump the node. */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|repos_relpath
argument_list|,
name|NULL
argument_list|,
name|fb
argument_list|,
name|fb
operator|->
name|action
argument_list|,
name|fb
operator|->
name|is_copy
argument_list|,
name|fb
operator|->
name|copyfrom_path
argument_list|,
name|fb
operator|->
name|copyfrom_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some pending properties to dump?  We'll dump just the headers for      now, then dump the actual propchange content only after dumping      the text headers too (if present). */
name|SVN_ERR
argument_list|(
name|do_dump_props
argument_list|(
operator|&
name|propstring
argument_list|,
name|eb
operator|->
name|stream
argument_list|,
name|fb
operator|->
name|props
argument_list|,
name|fb
operator|->
name|deleted_props
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|dump_props
operator|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump the text headers */
if|if
condition|(
name|fb
operator|->
name|dump_text
condition|)
block|{
name|apr_status_t
name|err
decl_stmt|;
comment|/* Text-delta: true */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA
literal|": true\n"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|apr_file_info_get
argument_list|(
name|info
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|eb
operator|->
name|delta_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|SVN_ERR
argument_list|(
name|svn_error_wrap_apr
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|base_checksum
condition|)
comment|/* Text-delta-base-md5: */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_MD5
literal|": %s\n"
argument_list|,
name|fb
operator|->
name|base_checksum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Text-content-length: 39 */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH
literal|": %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|info
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Text-content-md5: 82705804337e04dcd0e586bfa2389a7f */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_MD5
literal|": %s\n"
argument_list|,
name|text_checksum
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Content-length: 1549 */
comment|/* If both text and props are absent, skip this header */
if|if
condition|(
name|fb
operator|->
name|dump_props
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
literal|": %ld\n\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|info
operator|->
name|size
operator|+
name|propstring
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fb
operator|->
name|dump_text
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
literal|": %ld\n\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|info
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump the props now */
if|if
condition|(
name|fb
operator|->
name|dump_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|propstring
operator|->
name|data
argument_list|,
operator|&
operator|(
name|propstring
operator|->
name|len
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cleanup */
name|fb
operator|->
name|dump_props
operator|=
name|FALSE
expr_stmt|;
name|apr_hash_clear
argument_list|(
name|fb
operator|->
name|props
argument_list|)
expr_stmt|;
name|apr_hash_clear
argument_list|(
name|fb
operator|->
name|deleted_props
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the text */
if|if
condition|(
name|fb
operator|->
name|dump_text
condition|)
block|{
comment|/* Seek to the beginning of the delta file, map it to a stream,          and copy the stream to eb->stream. Then close the stream and          truncate the file so we can reuse it for the next textdelta          application. Note that the file isn't created, opened or          closed here */
name|svn_stream_t
modifier|*
name|delta_filestream
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|eb
operator|->
name|delta_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|delta_filestream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|eb
operator|->
name|delta_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|delta_filestream
argument_list|,
name|eb
operator|->
name|stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cleanup */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|delta_filestream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|eb
operator|->
name|delta_file
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write a couple of blank lines for matching output with `svnadmin      dump` */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
literal|"\n\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|dump_edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|fstream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|path
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|current_revision
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|fstream
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_get_file
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|fstream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|dump_edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|path
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|current_revision
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
operator|&
name|node_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_array_header_t
modifier|*
name|tmp_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
literal|0
comment|/* Dirent fields */
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_props
operator|=
name|svn_prop_hash_to_array
argument_list|(
operator|*
name|props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|tmp_props
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|dump_edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|path
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|current_revision
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|eb
operator|->
name|ra_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rdump__get_dump_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|update_anchor_relpath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dump_edit_baton
modifier|*
name|eb
decl_stmt|;
name|svn_delta_editor_t
modifier|*
name|de
decl_stmt|;
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|eb
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dump_edit_baton
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|eb
operator|->
name|ra_session
operator|=
name|ra_session
expr_stmt|;
name|eb
operator|->
name|update_anchor_relpath
operator|=
name|update_anchor_relpath
expr_stmt|;
name|eb
operator|->
name|current_revision
operator|=
name|revision
expr_stmt|;
name|eb
operator|->
name|pending_kind
operator|=
name|svn_node_none
expr_stmt|;
comment|/* Create a special per-revision pool */
name|eb
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Open a unique temporary file for all textdelta applications in      this edit session. The file is automatically closed and cleaned      up when the edit session is done. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
operator|(
name|eb
operator|->
name|delta_file
operator|)
argument_list|,
operator|&
operator|(
name|eb
operator|->
name|delta_abspath
operator|)
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|de
operator|=
name|svn_delta_default_editor
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|de
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|de
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|de
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|de
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
name|de
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|de
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|de
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|de
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|de
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|de
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|de
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|de
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
comment|/* Set the edit_baton and editor. */
operator|*
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|editor
operator|=
name|de
expr_stmt|;
comment|/* Wrap this editor in a cancellation editor. */
name|SVN_ERR
argument_list|(
name|svn_delta_get_cancellation_editor
argument_list|(
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|de
argument_list|,
name|eb
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_baton
operator|=
name|eb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor__insert_shims
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|*
name|editor
argument_list|,
operator|*
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|shim_callbacks
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

