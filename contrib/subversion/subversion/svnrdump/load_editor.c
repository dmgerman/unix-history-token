begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  load_editor.c: The svn_delta_editor_t editor used by svnrdump to  *  load revisions.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"svnrdump.h"
end_include

begin_define
define|#
directive|define
name|SVNRDUMP_PROP_LOCK
value|SVN_PROP_PREFIX "rdump-lock"
end_define

begin_define
define|#
directive|define
name|ARE_VALID_COPY_ARGS
parameter_list|(
name|p
parameter_list|,
name|r
parameter_list|)
value|((p)&& SVN_IS_VALID_REVNUM(r))
end_define

begin_escape
end_escape

begin_comment
comment|/**  * General baton used by the parser functions.  */
end_comment

begin_struct
struct|struct
name|parse_baton
block|{
comment|/* Commit editor and baton used to transfer loaded revisions to      the target repository. */
specifier|const
name|svn_delta_editor_t
modifier|*
name|commit_editor
decl_stmt|;
name|void
modifier|*
name|commit_edit_baton
decl_stmt|;
comment|/* RA session(s) for committing to the target repository. */
name|svn_ra_session_t
modifier|*
name|session
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|aux_session
decl_stmt|;
comment|/* To bleep, or not to bleep?  (What kind of question is that?) */
name|svn_boolean_t
name|quiet
decl_stmt|;
comment|/* Root URL of the target repository. */
specifier|const
name|char
modifier|*
name|root_url
decl_stmt|;
comment|/* The "parent directory" of the target repository in which to load.      (This is essentially the difference between ROOT_URL and      SESSION's url, and roughly equivalent to the 'svnadmin load      --parent-dir' option.) */
specifier|const
name|char
modifier|*
name|parent_dir
decl_stmt|;
comment|/* A mapping of svn_revnum_t * dump stream revisions to their      corresponding svn_revnum_t * target repository revisions. */
comment|/* ### See http://subversion.tigris.org/issues/show_bug.cgi?id=3903      ### for discussion about improving the memory costs of this mapping. */
name|apr_hash_t
modifier|*
name|rev_map
decl_stmt|;
comment|/* The most recent (youngest) revision from the dump stream mapped in      REV_MAP, or SVN_INVALID_REVNUM if no revisions have been mapped. */
name|svn_revnum_t
name|last_rev_mapped
decl_stmt|;
comment|/* The oldest revision loaded from the dump stream, or      SVN_INVALID_REVNUM if none have been loaded. */
name|svn_revnum_t
name|oldest_dumpstream_rev
decl_stmt|;
comment|/* An hash containing specific revision properties to skip while      loading. */
name|apr_hash_t
modifier|*
name|skip_revprops
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Use to wrap the dir_context_t in commit.c so we can keep track of  * relpath and parent for open_directory and close_directory.  */
end_comment

begin_struct
struct|struct
name|directory_baton
block|{
name|void
modifier|*
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
comment|/* The copy-from source of this directory, no matter whether it is      copied explicitly (the root node of a copy) or implicitly (being an      existing child of a copied directory). For a node that is newly      added (without history), even inside a copied parent, these are      NULL and SVN_INVALID_REVNUM. */
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
name|struct
name|directory_baton
modifier|*
name|parent
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Baton used to represent a node; to be used by the parser  * functions. Contains a link to the revision baton.  */
end_comment

begin_struct
struct|struct
name|node_baton
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|enum
name|svn_node_action
name|action
decl_stmt|;
comment|/* Is this directory explicitly added? If not, then it already existed      or is a child of a copy. */
name|svn_boolean_t
name|is_added
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_url
decl_stmt|;
name|void
modifier|*
name|file_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_checksum
decl_stmt|;
comment|/* (const char *name) -> (svn_prop_t *) */
name|apr_hash_t
modifier|*
name|prop_changes
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Baton used to represet a revision; used by the parser  * functions. Contains a link to the parser baton.  */
end_comment

begin_struct
struct|struct
name|revision_baton
block|{
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_hash_t
modifier|*
name|revprop_table
decl_stmt|;
name|apr_int32_t
name|rev_offset
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|datestamp
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|author
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
decl_stmt|;
name|struct
name|directory_baton
modifier|*
name|db
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Record the mapping of FROM_REV to TO_REV in REV_MAP, ensuring that    anything added to the hash is allocated in the hash's pool. */
end_comment

begin_function
specifier|static
name|void
name|set_revision_mapping
parameter_list|(
name|apr_hash_t
modifier|*
name|rev_map
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|,
name|svn_revnum_t
name|to_rev
parameter_list|)
block|{
name|svn_revnum_t
modifier|*
name|mapped_revs
init|=
name|apr_palloc
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|rev_map
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
operator|*
literal|2
argument_list|)
decl_stmt|;
name|mapped_revs
index|[
literal|0
index|]
operator|=
name|from_rev
expr_stmt|;
name|mapped_revs
index|[
literal|1
index|]
operator|=
name|to_rev
expr_stmt|;
name|apr_hash_set
argument_list|(
name|rev_map
argument_list|,
name|mapped_revs
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|,
name|mapped_revs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the revision to which FROM_REV maps in REV_MAP, or    SVN_INVALID_REVNUM if no such mapping exists. */
end_comment

begin_function
specifier|static
name|svn_revnum_t
name|get_revision_mapping
parameter_list|(
name|apr_hash_t
modifier|*
name|rev_map
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|)
block|{
name|svn_revnum_t
modifier|*
name|to_rev
init|=
name|apr_hash_get
argument_list|(
name|rev_map
argument_list|,
operator|&
name|from_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|from_rev
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|to_rev
condition|?
operator|*
name|to_rev
else|:
name|SVN_INVALID_REVNUM
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit_callback
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
comment|/* ### Don't print directly; generate a notification. */
if|if
condition|(
operator|!
name|pb
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"* Loaded revision %ld.\n"
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the mapping of the dumpstream revision to the committed revision. */
name|set_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|rb
operator|->
name|rev
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|)
expr_stmt|;
comment|/* If the incoming dump stream has non-contiguous revisions (e.g. from      using svndumpfilter --drop-empty-revs without --renumber-revs) then      we must account for the missing gaps in PB->REV_MAP.  Otherwise we      might not be able to map all mergeinfo source revisions to the correct      revisions in the target repos. */
if|if
condition|(
operator|(
name|pb
operator|->
name|last_rev_mapped
operator|!=
name|SVN_INVALID_REVNUM
operator|)
operator|&&
operator|(
name|rb
operator|->
name|rev
operator|!=
name|pb
operator|->
name|last_rev_mapped
operator|+
literal|1
operator|)
condition|)
block|{
name|svn_revnum_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|pb
operator|->
name|last_rev_mapped
operator|+
literal|1
init|;
name|i
operator|<
name|rb
operator|->
name|rev
condition|;
name|i
operator|++
control|)
block|{
name|set_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|i
argument_list|,
name|pb
operator|->
name|last_rev_mapped
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update our "last revision mapped". */
name|pb
operator|->
name|last_rev_mapped
operator|=
name|rb
operator|->
name|rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements `svn_ra__lock_retry_func_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lock_retry_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|reposlocktoken
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Failed to get lock on destination "
literal|"repos, currently held by '%s'\n"
argument_list|)
argument_list|,
name|reposlocktoken
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|fstream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|rb
operator|->
name|rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|fstream
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_get_file
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|fstream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|rb
operator|->
name|rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
operator|&
name|node_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_array_header_t
modifier|*
name|tmp_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
literal|0
comment|/* Dirent fields */
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_props
operator|=
name|svn_prop_hash_to_array
argument_list|(
operator|*
name|props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|tmp_props
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|rb
operator|->
name|rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_delta_shim_callbacks_t
modifier|*
name|get_shim_callbacks
parameter_list|(
name|struct
name|revision_baton
modifier|*
name|rb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_baton
operator|=
name|rb
expr_stmt|;
return|return
name|callbacks
return|;
block|}
end_function

begin_comment
comment|/* Acquire a lock (of sorts) on the repository associated with the  * given RA SESSION. This lock is just a revprop change attempt in a  * time-delay loop. This function is duplicated by svnsync in  * svnsync/svnsync.c  *  * ### TODO: Make this function more generic and  * expose it through a header for use by other Subversion  * applications to avoid duplication.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|lock_string_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|be_atomic
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|session
argument_list|,
operator|&
name|be_atomic
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|be_atomic
condition|)
block|{
comment|/* Pre-1.7 servers can't lock without a race condition.  (Issue #3546) */
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Target server does not support atomic revision "
literal|"property edits; consider upgrading it to 1.7."
argument_list|)
argument_list|)
decl_stmt|;
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
literal|"svnrdump: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_ra__get_operational_lock
argument_list|(
name|lock_string_p
argument_list|,
name|NULL
argument_list|,
name|session
argument_list|,
name|SVNRDUMP_PROP_LOCK
argument_list|,
name|FALSE
argument_list|,
literal|10
comment|/* retries */
argument_list|,
name|lock_retry_func
argument_list|,
name|NULL
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|new_revision_record
parameter_list|(
name|void
modifier|*
modifier|*
name|revision_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_revnum_t
name|head_rev
decl_stmt|;
name|rb
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rb
argument_list|)
argument_list|)
expr_stmt|;
name|pb
operator|=
name|parse_baton
expr_stmt|;
name|rb
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|rb
operator|->
name|pb
operator|=
name|pb
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|headers
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|hname
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|hval
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
argument_list|)
operator|==
literal|0
condition|)
name|rb
operator|->
name|rev
operator|=
name|atoi
argument_list|(
name|hval
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_get_latest_revnum
argument_list|(
name|pb
operator|->
name|session
argument_list|,
operator|&
name|head_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: This is a lame fallback loading multiple segments of dump in      several separate operations. It is highly susceptible to race conditions.      Calculate the revision 'offset' for finding copyfrom sources.      It might be positive or negative. */
name|rb
operator|->
name|rev_offset
operator|=
call|(
name|apr_int32_t
call|)
argument_list|(
operator|(
name|rb
operator|->
name|rev
operator|)
operator|-
operator|(
name|head_rev
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Stash the oldest (non-zero) dumpstream revision seen. */
if|if
condition|(
operator|(
name|rb
operator|->
name|rev
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|pb
operator|->
name|oldest_dumpstream_rev
argument_list|)
operator|)
condition|)
name|pb
operator|->
name|oldest_dumpstream_rev
operator|=
name|rb
operator|->
name|rev
expr_stmt|;
comment|/* Set the commit_editor/ commit_edit_baton to NULL and wait for      them to be created in new_node_record */
name|rb
operator|->
name|pb
operator|->
name|commit_editor
operator|=
name|NULL
expr_stmt|;
name|rb
operator|->
name|pb
operator|->
name|commit_edit_baton
operator|=
name|NULL
expr_stmt|;
name|rb
operator|->
name|revprop_table
operator|=
name|apr_hash_make
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|revision_baton
operator|=
name|rb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|magic_header_record
parameter_list|(
name|int
name|version
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|uuid_record
parameter_list|(
specifier|const
name|char
modifier|*
name|uuid
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Push information about another directory onto the linked list RB->db.  *  * CHILD_BATON is the baton returned by the commit editor. RELPATH is the  * repository-relative path of this directory. IS_ADDED is true iff this  * directory is being added (with or without history). If added with  * history then COPYFROM_PATH/COPYFROM_REV are the copyfrom source, else  * are NULL/SVN_INVALID_REVNUM.  */
end_comment

begin_function
specifier|static
name|void
name|push_directory
parameter_list|(
name|struct
name|revision_baton
modifier|*
name|rb
parameter_list|,
name|void
modifier|*
name|child_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_boolean_t
name|is_added
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|)
block|{
name|struct
name|directory_baton
modifier|*
name|child_db
init|=
name|apr_pcalloc
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|child_db
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|is_added
operator|||
operator|(
name|copyfrom_path
operator|==
name|NULL
operator|&&
name|copyfrom_rev
operator|==
name|SVN_INVALID_REVNUM
operator|)
argument_list|)
expr_stmt|;
comment|/* If this node is an existing (not newly added) child of a copied node,      calculate where it was copied from. */
if|if
condition|(
operator|!
name|is_added
operator|&&
name|ARE_VALID_COPY_ARGS
argument_list|(
name|rb
operator|->
name|db
operator|->
name|copyfrom_path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_relpath_basename
argument_list|(
name|relpath
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|copyfrom_path
operator|=
name|svn_relpath_join
argument_list|(
name|rb
operator|->
name|db
operator|->
name|copyfrom_path
argument_list|,
name|name
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|copyfrom_rev
operator|=
name|rb
operator|->
name|db
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
name|child_db
operator|->
name|baton
operator|=
name|child_baton
expr_stmt|;
name|child_db
operator|->
name|relpath
operator|=
name|relpath
expr_stmt|;
name|child_db
operator|->
name|copyfrom_path
operator|=
name|copyfrom_path
expr_stmt|;
name|child_db
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
name|child_db
operator|->
name|parent
operator|=
name|rb
operator|->
name|db
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|child_db
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|new_node_record
parameter_list|(
name|void
modifier|*
modifier|*
name|node_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|revision_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|revision_baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|void
modifier|*
name|commit_edit_baton
init|=
name|rb
operator|->
name|pb
operator|->
name|commit_edit_baton
decl_stmt|;
name|struct
name|node_baton
modifier|*
name|nb
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|void
modifier|*
name|child_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|nb_dirname
decl_stmt|;
name|nb
operator|=
name|apr_pcalloc
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nb
argument_list|)
argument_list|)
expr_stmt|;
name|nb
operator|->
name|rb
operator|=
name|rb
expr_stmt|;
name|nb
operator|->
name|is_added
operator|=
name|FALSE
expr_stmt|;
name|nb
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|nb
operator|->
name|copyfrom_url
operator|=
name|NULL
expr_stmt|;
name|nb
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|nb
operator|->
name|prop_changes
operator|=
name|apr_hash_make
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* If the creation of commit_editor is pending, create it now and      open_root on it; also create a top-level directory baton. */
if|if
condition|(
operator|!
name|commit_editor
condition|)
block|{
comment|/* The revprop_table should have been filled in with important          information like svn:log in set_revision_property. We can now          use it all this information to create our commit_editor. But          first, clear revprops that we aren't allowed to set with the          commit_editor. We'll set them separately using the RA API          after closing the editor (see close_revision). */
name|svn_hash_sets
argument_list|(
name|rb
operator|->
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|rb
operator|->
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
name|get_shim_callbacks
argument_list|(
name|rb
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
operator|&
name|commit_editor
argument_list|,
operator|&
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|revision_baton
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|pb
operator|->
name|commit_editor
operator|=
name|commit_editor
expr_stmt|;
name|rb
operator|->
name|pb
operator|->
name|commit_edit_baton
operator|=
name|commit_edit_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_root
argument_list|(
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* child_baton corresponds to the root directory baton here */
name|push_directory
argument_list|(
name|rb
argument_list|,
name|child_baton
argument_list|,
literal|""
argument_list|,
name|TRUE
comment|/*is_added*/
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|headers
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|hname
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|hval
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
comment|/* Parse the different kinds of headers we can encounter and          stuff them into the node_baton for writing later */
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|hval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|kind
operator|=
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|?
name|svn_node_file
else|:
name|svn_node_dir
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_add
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"change"
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_change
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_delete
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hval
argument_list|,
literal|"replace"
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_replace
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_MD5
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|base_checksum
operator|=
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|hval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|copyfrom_rev
operator|=
name|atoi
argument_list|(
name|hval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hname
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH
argument_list|)
operator|==
literal|0
condition|)
name|nb
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|hval
argument_list|)
expr_stmt|;
block|}
comment|/* Before handling the new node, ensure depth-first editing order by      traversing the directory hierarchy from the old node's to the new      node's parent directory. */
name|nb_dirname
operator|=
name|svn_relpath_dirname
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_compare_paths
argument_list|(
name|nb_dirname
argument_list|,
name|rb
operator|->
name|db
operator|->
name|relpath
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ancestor_path
decl_stmt|;
name|apr_size_t
name|residual_close_count
decl_stmt|;
name|apr_array_header_t
modifier|*
name|residual_open_path
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_size_t
name|n
decl_stmt|;
name|ancestor_path
operator|=
name|svn_relpath_get_longest_ancestor
argument_list|(
name|nb_dirname
argument_list|,
name|rb
operator|->
name|db
operator|->
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|residual_close_count
operator|=
name|svn_path_component_count
argument_list|(
name|svn_relpath_skip_ancestor
argument_list|(
name|ancestor_path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|relpath
argument_list|)
argument_list|)
expr_stmt|;
name|residual_open_path
operator|=
name|svn_path_decompose
argument_list|(
name|svn_relpath_skip_ancestor
argument_list|(
name|ancestor_path
argument_list|,
name|nb_dirname
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* First close all as many directories as there are after          skip_ancestor, and then open fresh directories */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|residual_close_count
condition|;
name|n
operator|++
control|)
block|{
comment|/* Don't worry about destroying the actual rb->db object,              since the pool we're using has the lifetime of one              revision anyway */
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_directory
argument_list|(
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|rb
operator|->
name|db
operator|->
name|parent
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|residual_open_path
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|relpath_compose
init|=
name|svn_relpath_join
argument_list|(
name|rb
operator|->
name|db
operator|->
name|relpath
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|residual_open_path
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_directory
argument_list|(
name|relpath_compose
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|push_directory
argument_list|(
name|rb
argument_list|,
name|child_baton
argument_list|,
name|relpath_compose
argument_list|,
name|TRUE
comment|/*is_added*/
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fix up the copyfrom information in light of mapped revisions and      non-root load targets, and convert copyfrom path into a full      URL. */
if|if
condition|(
name|nb
operator|->
name|copyfrom_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|nb
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* Try to find the copyfrom revision in the revision map;          failing that, fall back to the revision offset approach. */
name|copyfrom_rev
operator|=
name|get_revision_mapping
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|rev_map
argument_list|,
name|nb
operator|->
name|copyfrom_rev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
condition|)
name|copyfrom_rev
operator|=
name|nb
operator|->
name|copyfrom_rev
operator|-
name|rb
operator|->
name|rev_offset
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Relative source revision %ld is not"
literal|" available in current repository"
argument_list|)
argument_list|,
name|copyfrom_rev
argument_list|)
return|;
name|nb
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|parent_dir
condition|)
name|nb
operator|->
name|copyfrom_path
operator|=
name|svn_relpath_join
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|parent_dir
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Convert to a URL, as the commit editor requires. */
name|nb
operator|->
name|copyfrom_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|root_url
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|nb
operator|->
name|action
condition|)
block|{
case|case
name|svn_node_action_delete
case|:
case|case
name|svn_node_action_replace
case|:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|delete_entry
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|->
name|action
operator|==
name|svn_node_action_delete
condition|)
break|break;
else|else
comment|/* FALL THROUGH */
empty_stmt|;
case|case
name|svn_node_action_add
case|:
name|nb
operator|->
name|is_added
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|nb
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_file
case|:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|add_file
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|nb
operator|->
name|copyfrom_url
argument_list|,
name|nb
operator|->
name|copyfrom_rev
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
operator|(
name|nb
operator|->
name|file_baton
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_dir
case|:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|add_directory
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|nb
operator|->
name|copyfrom_url
argument_list|,
name|nb
operator|->
name|copyfrom_rev
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|push_directory
argument_list|(
name|rb
argument_list|,
name|child_baton
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|TRUE
comment|/*is_added*/
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|nb
operator|->
name|copyfrom_rev
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|svn_node_action_change
case|:
switch|switch
condition|(
name|nb
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_file
case|:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_file
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
operator|(
name|nb
operator|->
name|file_baton
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_directory
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|push_directory
argument_list|(
name|rb
argument_list|,
name|child_baton
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|FALSE
comment|/*is_added*/
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
operator|*
name|node_baton
operator|=
name|nb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_revision_property
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rdump__normalize_prop
argument_list|(
name|name
argument_list|,
operator|&
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|rev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|skip_revprops
argument_list|,
name|name
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|rb
operator|->
name|revprop_table
argument_list|,
name|apr_pstrdup
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rb
operator|->
name|rev_offset
operator|==
operator|-
literal|1
operator|&&
operator|!
name|svn_hash_gets
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|skip_revprops
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* Special case: set revision 0 properties directly (which is          safe because the commit_editor hasn't been created yet), but          only when loading into an 'empty' filesystem. */
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remember any datestamp/ author that passes through (see comment      in close_revision). */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
condition|)
name|rb
operator|->
name|datestamp
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
condition|)
name|rb
operator|->
name|author
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_node_property
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
if|if
condition|(
name|value
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_string_t
modifier|*
name|new_value
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_repos__adjust_mergeinfo_property
argument_list|(
operator|&
name|new_value
argument_list|,
name|value
argument_list|,
name|pb
operator|->
name|parent_dir
argument_list|,
name|pb
operator|->
name|rev_map
argument_list|,
name|pb
operator|->
name|oldest_dumpstream_rev
argument_list|,
name|rb
operator|->
name|rev_offset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/*notify*/
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Invalid svn:mergeinfo value"
argument_list|)
argument_list|)
return|;
block|}
name|value
operator|=
name|new_value
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_rdump__normalize_prop
argument_list|(
name|name
argument_list|,
operator|&
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|=
name|apr_palloc
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|prop
operator|->
name|value
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|nb
operator|->
name|prop_changes
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_node_property
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|prop
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|nb
operator|->
name|prop_changes
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Delete all the properties of the node, if any.  *  * The commit editor doesn't have a method to delete a node's properties  * without knowing what they are, so we have to first find out what  * properties the node would have had. If it's copied (explicitly or  * implicitly), we look at the copy source. If it's only being changed,  * we look at the node's current path in the head revision.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_node_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig_path
decl_stmt|;
name|svn_revnum_t
name|orig_rev
decl_stmt|;
comment|/* Find the path and revision that has the node's original properties */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|nb
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|orig_path
operator|=
name|nb
operator|->
name|copyfrom_path
expr_stmt|;
name|orig_rev
operator|=
name|nb
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nb
operator|->
name|is_added
operator|&&
name|ARE_VALID_COPY_ARGS
argument_list|(
name|rb
operator|->
name|db
operator|->
name|copyfrom_path
argument_list|,
name|rb
operator|->
name|db
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
comment|/* If this is a dir, then it's described by rb->db;          if this is a file, then it's a child of the dir in rb->db. */
name|orig_path
operator|=
operator|(
name|nb
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
condition|?
name|rb
operator|->
name|db
operator|->
name|copyfrom_path
else|:
name|svn_relpath_join
argument_list|(
name|rb
operator|->
name|db
operator|->
name|copyfrom_path
argument_list|,
name|svn_relpath_basename
argument_list|(
name|nb
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|orig_rev
operator|=
name|rb
operator|->
name|db
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
else|else
block|{
comment|/* ### Should we query at a known, fixed, "head" revision number          instead of passing SVN_INVALID_REVNUM and getting a moving target? */
name|orig_path
operator|=
name|nb
operator|->
name|path
expr_stmt|;
name|orig_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nb
operator|->
name|action
operator|==
name|svn_node_action_add
operator|||
name|nb
operator|->
name|action
operator|==
name|svn_node_action_replace
operator|)
operator|&&
operator|!
name|ARE_VALID_COPY_ARGS
argument_list|(
name|orig_path
argument_list|,
name|orig_rev
argument_list|)
condition|)
comment|/* Add-without-history; no "old" properties to worry about. */
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|nb
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|orig_path
argument_list|,
name|orig_rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* nb->kind == svn_node_dir */
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|aux_session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|orig_path
argument_list|,
name|orig_rev
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_prop_kind_t
name|kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_prop_regular_kind
condition|)
name|SVN_ERR
argument_list|(
name|set_node_property
argument_list|(
name|nb
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_fulltext
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|node_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|svn_txdelta_window_handler_t
name|handler
decl_stmt|;
name|void
modifier|*
name|handler_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|apply_textdelta
argument_list|(
name|nb
operator|->
name|file_baton
argument_list|,
name|nb
operator|->
name|base_checksum
argument_list|,
name|pool
argument_list|,
operator|&
name|handler
argument_list|,
operator|&
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_txdelta_target_push
argument_list|(
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|,
name|void
modifier|*
name|node_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|apply_textdelta
argument_list|(
name|nb
operator|->
name|file_baton
argument_list|,
name|nb
operator|->
name|base_checksum
argument_list|,
name|pool
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_node
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
specifier|const
name|struct
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|nb
operator|->
name|rb
operator|->
name|pool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|nb
operator|->
name|prop_changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_prop_t
modifier|*
name|prop
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nb
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_file
case|:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|change_file_prop
argument_list|(
name|nb
operator|->
name|file_baton
argument_list|,
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_dir
case|:
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|change_dir_prop
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Pass a file node closure through to the editor *unless* we      deleted the file (which doesn't require us to open it). */
if|if
condition|(
operator|(
name|nb
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
operator|&&
operator|(
name|nb
operator|->
name|file_baton
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_file
argument_list|(
name|nb
operator|->
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|nb
operator|->
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The svn_node_dir case is handled in close_revision */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_revision
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|commit_editor
init|=
name|rb
operator|->
name|pb
operator|->
name|commit_editor
decl_stmt|;
name|void
modifier|*
name|commit_edit_baton
init|=
name|rb
operator|->
name|pb
operator|->
name|commit_edit_baton
decl_stmt|;
name|svn_revnum_t
name|committed_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* Fake revision 0 */
if|if
condition|(
name|rb
operator|->
name|rev
operator|==
literal|0
condition|)
block|{
comment|/* ### Don't print directly; generate a notification. */
if|if
condition|(
operator|!
name|rb
operator|->
name|pb
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|rb
operator|->
name|pool
argument_list|,
literal|"* Loaded revision 0.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commit_editor
condition|)
block|{
comment|/* Close all pending open directories, and then close the edit          session itself */
while|while
condition|(
name|rb
operator|->
name|db
operator|&&
name|rb
operator|->
name|db
operator|->
name|parent
condition|)
block|{
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_directory
argument_list|(
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|db
operator|=
name|rb
operator|->
name|db
operator|->
name|parent
expr_stmt|;
block|}
comment|/* root dir's baton */
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_directory
argument_list|(
name|rb
operator|->
name|db
operator|->
name|baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_edit
argument_list|(
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|child_baton
decl_stmt|;
comment|/* Legitimate revision with no node information */
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
operator|&
name|commit_editor
argument_list|,
operator|&
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|baton
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|open_root
argument_list|(
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|rev
operator|-
name|rb
operator|->
name|rev_offset
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_directory
argument_list|(
name|child_baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|commit_editor
operator|->
name|close_edit
argument_list|(
name|commit_edit_baton
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* svn_fs_commit_txn() rewrites the datestamp and author properties;      we'll rewrite them again by hand after closing the commit_editor.      The only time we don't do this is for revision 0 when loaded into      a non-empty repository.  */
if|if
condition|(
name|rb
operator|->
name|rev
operator|>
literal|0
condition|)
block|{
name|committed_rev
operator|=
name|get_revision_mapping
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|rev_map
argument_list|,
name|rb
operator|->
name|rev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rb
operator|->
name|rev_offset
operator|==
operator|-
literal|1
condition|)
block|{
name|committed_rev
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|committed_rev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|skip_revprops
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|SVN_PROP_REVISION_DATE
argument_list|,
name|rb
operator|->
name|datestamp
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
name|committed_rev
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|datestamp
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|skip_revprops
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|rb
operator|->
name|author
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|session
argument_list|,
name|committed_rev
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|author
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rdump__load_dumpstream
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|aux_session
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
name|apr_hash_t
modifier|*
name|skip_revprops
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos_parse_fns3_t
modifier|*
name|parser
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|parse_baton
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|lock_string
decl_stmt|;
name|svn_boolean_t
name|be_atomic
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|session_url
decl_stmt|,
modifier|*
name|root_url
decl_stmt|,
modifier|*
name|parent_dir
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|session
argument_list|,
operator|&
name|be_atomic
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_lock
argument_list|(
operator|&
name|lock_string
argument_list|,
name|session
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|session
argument_list|,
operator|&
name|root_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|session
argument_list|,
operator|&
name|session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_path_relative_to_root
argument_list|(
name|session
argument_list|,
operator|&
name|parent_dir
argument_list|,
name|session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|magic_header_record
operator|=
name|magic_header_record
expr_stmt|;
name|parser
operator|->
name|uuid_record
operator|=
name|uuid_record
expr_stmt|;
name|parser
operator|->
name|new_revision_record
operator|=
name|new_revision_record
expr_stmt|;
name|parser
operator|->
name|new_node_record
operator|=
name|new_node_record
expr_stmt|;
name|parser
operator|->
name|set_revision_property
operator|=
name|set_revision_property
expr_stmt|;
name|parser
operator|->
name|set_node_property
operator|=
name|set_node_property
expr_stmt|;
name|parser
operator|->
name|delete_node_property
operator|=
name|delete_node_property
expr_stmt|;
name|parser
operator|->
name|remove_node_props
operator|=
name|remove_node_props
expr_stmt|;
name|parser
operator|->
name|set_fulltext
operator|=
name|set_fulltext
expr_stmt|;
name|parser
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|parser
operator|->
name|close_node
operator|=
name|close_node
expr_stmt|;
name|parser
operator|->
name|close_revision
operator|=
name|close_revision
expr_stmt|;
name|parse_baton
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parse_baton
argument_list|)
argument_list|)
expr_stmt|;
name|parse_baton
operator|->
name|session
operator|=
name|session
expr_stmt|;
name|parse_baton
operator|->
name|aux_session
operator|=
name|aux_session
expr_stmt|;
name|parse_baton
operator|->
name|quiet
operator|=
name|quiet
expr_stmt|;
name|parse_baton
operator|->
name|root_url
operator|=
name|root_url
expr_stmt|;
name|parse_baton
operator|->
name|parent_dir
operator|=
name|parent_dir
expr_stmt|;
name|parse_baton
operator|->
name|rev_map
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|parse_baton
operator|->
name|last_rev_mapped
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|parse_baton
operator|->
name|oldest_dumpstream_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|parse_baton
operator|->
name|skip_revprops
operator|=
name|skip_revprops
expr_stmt|;
name|err
operator|=
name|svn_repos_parse_dumpstream3
argument_list|(
name|stream
argument_list|,
name|parser
argument_list|,
name|parse_baton
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If all goes well, or if we're cancelled cleanly, don't leave a      stray lock behind. */
if|if
condition|(
operator|(
operator|!
name|err
operator|)
operator|||
operator|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CANCELLED
operator|)
operator|)
condition|)
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_ra__release_operational_lock
argument_list|(
name|session
argument_list|,
name|SVNRDUMP_PROP_LOCK
argument_list|,
name|lock_string
argument_list|,
name|pool
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

