begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  svnrdump.c: Produce a dumpfile of a local or remote repository  *              without touching the filesystem, but for temporary files.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svnrdump.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Cancellation ***/
end_comment

begin_comment
comment|/* A flag to see if we've been cancelled by the client or not. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|cancelled
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A signal handler to support cancellation. */
end_comment

begin_function
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|apr_signal
argument_list|(
name|signum
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|cancelled
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Our cancellation callback. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_cancel
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
if|if
condition|(
name|cancelled
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CANCELLED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Caught signal"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|svn_opt_subcommand_t
name|dump_cmd
decl_stmt|,
name|load_cmd
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|svn_svnrdump__longopt_t
block|{
name|opt_config_dir
init|=
name|SVN_OPT_FIRST_LONGOPT_ID
block|,
name|opt_config_option
block|,
name|opt_auth_username
block|,
name|opt_auth_password
block|,
name|opt_auth_nocache
block|,
name|opt_non_interactive
block|,
name|opt_skip_revprop
block|,
name|opt_force_interactive
block|,
name|opt_incremental
block|,
name|opt_trust_server_cert
block|,
name|opt_trust_server_cert_failures
block|,
name|opt_version
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|SVN_SVNRDUMP__BASE_OPTIONS
value|opt_config_dir, \                                    opt_config_option, \                                    opt_auth_username, \                                    opt_auth_password, \                                    opt_auth_nocache, \                                    opt_trust_server_cert, \                                    opt_trust_server_cert_failures, \                                    opt_non_interactive, \                                    opt_force_interactive
end_define

begin_decl_stmt
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|svnrdump__cmd_table
index|[]
init|=
block|{
block|{
literal|"dump"
block|,
name|dump_cmd
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnrdump dump URL [-r LOWER[:UPPER]]\n\n"
literal|"Dump revisions LOWER to UPPER of repository at remote URL to stdout\n"
literal|"in a 'dumpfile' portable format.  If only LOWER is given, dump that\n"
literal|"one revision.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'q'
block|,
name|opt_incremental
block|,
name|SVN_SVNRDUMP__BASE_OPTIONS
block|}
block|}
block|,
block|{
literal|"load"
block|,
name|load_cmd
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnrdump load URL\n\n"
literal|"Load a 'dumpfile' given on stdin to a repository at remote URL.\n"
argument_list|)
block|,
block|{
literal|'q'
block|,
name|opt_skip_revprop
block|,
name|SVN_SVNRDUMP__BASE_OPTIONS
block|}
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
block|{
literal|"?"
block|,
literal|"h"
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnrdump help [SUBCOMMAND...]\n\n"
literal|"Describe the usage of this program or its subcommands.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|apr_getopt_option_t
name|svnrdump__options
index|[]
init|=
block|{
block|{
literal|"revision"
block|,
literal|'r'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify revision number ARG (or X:Y range)"
argument_list|)
block|}
block|,
block|{
literal|"quiet"
block|,
literal|'q'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"no progress (only errors) to stderr"
argument_list|)
block|}
block|,
block|{
literal|"incremental"
block|,
name|opt_incremental
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"dump incrementally"
argument_list|)
block|}
block|,
block|{
literal|"skip-revprop"
block|,
name|opt_skip_revprop
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"skip revision property ARG (e.g., \"svn:author\")"
argument_list|)
block|}
block|,
block|{
literal|"config-dir"
block|,
name|opt_config_dir
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"read user configuration files from directory ARG"
argument_list|)
block|}
block|,
block|{
literal|"username"
block|,
name|opt_auth_username
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify a username ARG"
argument_list|)
block|}
block|,
block|{
literal|"password"
block|,
name|opt_auth_password
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify a password ARG"
argument_list|)
block|}
block|,
block|{
literal|"non-interactive"
block|,
name|opt_non_interactive
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do no interactive prompting (default is to prompt\n"
literal|"                             "
literal|"only if standard input is a terminal device)"
argument_list|)
block|}
block|,
block|{
literal|"force-interactive"
block|,
name|opt_force_interactive
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do interactive prompting even if standard input\n"
literal|"                             "
literal|"is not a terminal device"
argument_list|)
block|}
block|,
block|{
literal|"no-auth-cache"
block|,
name|opt_auth_nocache
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do not cache authentication tokens"
argument_list|)
block|}
block|,
block|{
literal|"help"
block|,
literal|'h'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"display this help"
argument_list|)
block|}
block|,
block|{
literal|"version"
block|,
name|opt_version
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show program version information"
argument_list|)
block|}
block|,
block|{
literal|"config-option"
block|,
name|opt_config_option
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"set user configuration option in the format:\n"
literal|"                             "
literal|"    FILE:SECTION:OPTION=[VALUE]\n"
literal|"                             "
literal|"For example:\n"
literal|"                             "
literal|"    servers:global:http-library=serf"
argument_list|)
block|}
block|,
block|{
literal|"trust-server-cert"
block|,
name|opt_trust_server_cert
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"deprecated; same as\n"
literal|"                             "
literal|"--trust-server-cert-failures=unknown-ca"
argument_list|)
block|}
block|,
block|{
literal|"trust-server-cert-failures"
block|,
name|opt_trust_server_cert_failures
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"with --non-interactive, accept SSL server\n"
literal|"                             "
literal|"certificates with failures; ARG is comma-separated\n"
literal|"                             "
literal|"list of 'unknown-ca' (Unknown Authority),\n"
literal|"                             "
literal|"'cn-mismatch' (Hostname mismatch), 'expired'\n"
literal|"                             "
literal|"(Expired certificate), 'not-yet-valid' (Not yet\n"
literal|"                             "
literal|"valid certificate) and 'other' (all other not\n"
literal|"                             "
literal|"separately classified certificate errors)."
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Baton for the RA replay session. */
end_comment

begin_struct
struct|struct
name|replay_baton
block|{
comment|/* A backdoor ra session for fetching information. */
name|svn_ra_session_t
modifier|*
name|extra_ra_session
decl_stmt|;
comment|/* The output stream */
name|svn_stream_t
modifier|*
name|stdout_stream
decl_stmt|;
comment|/* Whether to be quiet. */
name|svn_boolean_t
name|quiet
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Option set */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|opt_baton_t
block|{
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|session
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|svn_boolean_t
name|help
decl_stmt|;
name|svn_boolean_t
name|version
decl_stmt|;
name|svn_opt_revision_t
name|start_revision
decl_stmt|;
name|svn_opt_revision_t
name|end_revision
decl_stmt|;
name|svn_boolean_t
name|quiet
decl_stmt|;
name|svn_boolean_t
name|incremental
decl_stmt|;
name|apr_hash_t
modifier|*
name|skip_revprops
decl_stmt|;
block|}
name|opt_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Print dumpstream-formatted information about REVISION.  * Implements the `svn_ra_replay_revstart_callback_t' interface.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_revstart
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|replay_baton
modifier|*
name|rb
init|=
name|replay_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|normal_props
decl_stmt|;
comment|/* Normalize and dump the revprops */
name|SVN_ERR
argument_list|(
name|svn_rdump__normalize_props
argument_list|(
operator|&
name|normal_props
argument_list|,
name|rev_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__dump_revision_record
argument_list|(
name|rb
operator|->
name|stdout_stream
argument_list|,
name|revision
argument_list|,
name|NULL
argument_list|,
name|normal_props
argument_list|,
name|TRUE
comment|/*props_section_always*/
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rdump__get_dump_editor
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|revision
argument_list|,
name|rb
operator|->
name|stdout_stream
argument_list|,
name|rb
operator|->
name|extra_ra_session
argument_list|,
name|NULL
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print progress information about the dump of REVISION.    Implements the `svn_ra_replay_revfinish_callback_t' interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_revend
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* No resources left to free. */
name|struct
name|replay_baton
modifier|*
name|rb
init|=
name|replay_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rb
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
literal|"* Dumped revision %lu.\n"
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_EV2_IMPL
end_ifdef

begin_comment
comment|/* Print dumpstream-formatted information about REVISION.  * Implements the `svn_ra_replay_revstart_callback_t' interface.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_revstart_v2
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
name|svn_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|replay_baton
modifier|*
name|rb
init|=
name|replay_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|normal_props
decl_stmt|;
comment|/* Normalize and dump the revprops */
name|SVN_ERR
argument_list|(
name|svn_rdump__normalize_props
argument_list|(
operator|&
name|normal_props
argument_list|,
name|rev_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__dump_revision_record
argument_list|(
name|rb
operator|->
name|stdout_stream
argument_list|,
name|revision
argument_list|,
name|normal_props
argument_list|,
name|TRUE
comment|/*props_section_always*/
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rdump__get_dump_editor_v2
argument_list|(
name|editor
argument_list|,
name|revision
argument_list|,
name|rb
operator|->
name|stdout_stream
argument_list|,
name|rb
operator|->
name|extra_ra_session
argument_list|,
name|NULL
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print progress information about the dump of REVISION.    Implements the `svn_ra_replay_revfinish_callback_t' interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_revend_v2
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
name|svn_editor_t
modifier|*
name|editor
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* No resources left to free. */
name|struct
name|replay_baton
modifier|*
name|rb
init|=
name|replay_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_complete
argument_list|(
name|editor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rb
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
literal|"* Dumped revision %lu.\n"
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize the RA layer, and set *CTX to a new client context baton  * allocated from POOL.  Use CONFIG_DIR and pass USERNAME, PASSWORD,  * CONFIG_DIR and NO_AUTH_CACHE to initialize the authorization baton.  * CONFIG_OPTIONS (if not NULL) is a list of configuration overrides.  * REPOS_URL is used to fiddle with server-specific configuration  * options.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_client_context
parameter_list|(
name|svn_client_ctx_t
modifier|*
modifier|*
name|ctx_p
parameter_list|,
name|svn_boolean_t
name|non_interactive
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|,
specifier|const
name|char
modifier|*
name|config_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_url
parameter_list|,
name|svn_boolean_t
name|no_auth_cache
parameter_list|,
name|svn_boolean_t
name|trust_unknown_ca
parameter_list|,
name|svn_boolean_t
name|trust_cn_mismatch
parameter_list|,
name|svn_boolean_t
name|trust_expired
parameter_list|,
name|svn_boolean_t
name|trust_not_yet_valid
parameter_list|,
name|svn_boolean_t
name|trust_other_failure
parameter_list|,
name|apr_array_header_t
modifier|*
name|config_options
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_client_ctx_t
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg_config
decl_stmt|,
modifier|*
name|cfg_servers
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_initialize
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_ensure
argument_list|(
name|config_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_create_context2
argument_list|(
operator|&
name|ctx
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_config
argument_list|(
operator|&
operator|(
name|ctx
operator|->
name|config
operator|)
argument_list|,
name|config_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_options
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline__apply_config_options
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|config_options
argument_list|,
literal|"svnrdump: "
argument_list|,
literal|"--config-option"
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_config
operator|=
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
expr_stmt|;
comment|/* ### FIXME: This is a hack to work around the fact that our dump      ### editor simply can't handle the way ra_serf violates the      ### editor v1 drive ordering requirements.      ###      ### We'll override both the global value and server-specific one      ### for the 'http-bulk-updates' and 'http-max-connections'      ### options in order to get ra_serf to try a bulk-update if the      ### server will allow it, or at least try to limit all its      ### auxiliary GETs/PROPFINDs to happening (well-ordered) on a      ### single server connection.      ###      ### See http://subversion.tigris.org/issues/show_bug.cgi?id=4116.   */
name|cfg_servers
operator|=
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_SERVERS
argument_list|)
expr_stmt|;
name|svn_config_set_bool
argument_list|(
name|cfg_servers
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_BULK_UPDATES
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|svn_config_set_int64
argument_list|(
name|cfg_servers
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_servers
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_uri_t
name|parsed_url
decl_stmt|;
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|pool
argument_list|,
name|repos_url
argument_list|,
operator|&
name|parsed_url
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
specifier|const
name|char
modifier|*
name|server_group
decl_stmt|;
name|server_group
operator|=
name|svn_config_find_group
argument_list|(
name|cfg_servers
argument_list|,
name|parsed_url
operator|.
name|hostname
argument_list|,
name|SVN_CONFIG_SECTION_GROUPS
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_group
condition|)
block|{
name|svn_config_set_bool
argument_list|(
name|cfg_servers
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_BULK_UPDATES
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|svn_config_set_int64
argument_list|(
name|cfg_servers
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Set up our cancellation support. */
name|ctx
operator|->
name|cancel_func
operator|=
name|check_cancel
expr_stmt|;
comment|/* Default authentication providers for non-interactive use */
name|SVN_ERR
argument_list|(
name|svn_cmdline_create_auth_baton2
argument_list|(
operator|&
operator|(
name|ctx
operator|->
name|auth_baton
operator|)
argument_list|,
name|non_interactive
argument_list|,
name|username
argument_list|,
name|password
argument_list|,
name|config_dir
argument_list|,
name|no_auth_cache
argument_list|,
name|trust_unknown_ca
argument_list|,
name|trust_cn_mismatch
argument_list|,
name|trust_expired
argument_list|,
name|trust_not_yet_valid
argument_list|,
name|trust_other_failure
argument_list|,
name|cfg_config
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ctx_p
operator|=
name|ctx
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print a revision record header for REVISION to STDOUT_STREAM.  Use  * SESSION to contact the repository for revision properties and  * such.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_revision_header
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_stream_t
modifier|*
name|stdout_stream
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|prophash
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_rev_proplist
argument_list|(
name|session
argument_list|,
name|revision
argument_list|,
operator|&
name|prophash
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__dump_revision_record
argument_list|(
name|stdout_stream
argument_list|,
name|revision
argument_list|,
name|NULL
argument_list|,
name|prophash
argument_list|,
name|TRUE
comment|/*props_section_always*/
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_initial_full_revision
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|extra_ra_session
parameter_list|,
name|svn_stream_t
modifier|*
name|stdout_stream
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|reporter
decl_stmt|;
name|void
modifier|*
name|report_baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|dump_editor
decl_stmt|;
name|void
modifier|*
name|dump_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|session_url
decl_stmt|,
modifier|*
name|source_relpath
decl_stmt|;
comment|/* Determine whether we're dumping the repository root URL or some      child thereof.  If we're dumping a subtree of the repository      rather than the root, we have to jump through some hoops to make      our update-driven dump generation work the way a replay-driven      one would.       See http://subversion.tigris.org/issues/show_bug.cgi?id=4101   */
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|session
argument_list|,
operator|&
name|session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_path_relative_to_root
argument_list|(
name|session
argument_list|,
operator|&
name|source_relpath
argument_list|,
name|session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start with a revision record header. */
name|SVN_ERR
argument_list|(
name|dump_revision_header
argument_list|(
name|session
argument_list|,
name|stdout_stream
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Then, we'll drive the dump editor with what would look like a      full checkout of the repository as it looked in START_REVISION.      We do this by manufacturing a basic 'report' to the update      reporter, telling it that we have nothing to start with.  The      delta between nothing and everything-at-REV is, effectively, a      full dump of REV. */
name|SVN_ERR
argument_list|(
name|svn_rdump__get_dump_editor
argument_list|(
operator|&
name|dump_editor
argument_list|,
operator|&
name|dump_baton
argument_list|,
name|revision
argument_list|,
name|stdout_stream
argument_list|,
name|extra_ra_session
argument_list|,
name|source_relpath
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_do_update3
argument_list|(
name|session
argument_list|,
operator|&
name|reporter
argument_list|,
operator|&
name|report_baton
argument_list|,
name|revision
argument_list|,
literal|""
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|dump_editor
argument_list|,
name|dump_baton
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|revision
argument_list|,
name|svn_depth_infinity
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|finish_report
argument_list|(
name|report_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All finished with START_REVISION! */
if|if
condition|(
operator|!
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
literal|"* Dumped revision %lu.\n"
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Replay revisions START_REVISION thru END_REVISION (inclusive) of  * the repository URL at which SESSION is rooted, using callbacks  * which generate Subversion repository dumpstreams describing the  * changes made in those revisions.  If QUIET is set, don't generate  * progress messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_revisions
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|extra_ra_session
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|replay_baton
modifier|*
name|replay_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
name|svn_stream_t
modifier|*
name|stdout_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|stdout_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|replay_baton
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|replay_baton
argument_list|)
argument_list|)
expr_stmt|;
name|replay_baton
operator|->
name|stdout_stream
operator|=
name|stdout_stream
expr_stmt|;
name|replay_baton
operator|->
name|extra_ra_session
operator|=
name|extra_ra_session
expr_stmt|;
name|replay_baton
operator|->
name|quiet
operator|=
name|quiet
expr_stmt|;
comment|/* Write the magic header and UUID */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stdout_stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_MAGIC_HEADER
literal|": %d\n\n"
argument_list|,
name|SVN_REPOS_DUMPFILE_FORMAT_VERSION
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_uuid2
argument_list|(
name|session
argument_list|,
operator|&
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stdout_stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_UUID
literal|": %s\n\n"
argument_list|,
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fake revision 0 if necessary */
if|if
condition|(
name|start_revision
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|dump_revision_header
argument_list|(
name|session
argument_list|,
name|stdout_stream
argument_list|,
name|start_revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Revision 0 has no tree changes, so we're done. */
if|if
condition|(
operator|!
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
literal|"* Dumped revision %lu.\n"
argument_list|,
name|start_revision
argument_list|)
argument_list|)
expr_stmt|;
name|start_revision
operator|++
expr_stmt|;
comment|/* If our first revision is 0, we can treat this as an          incremental dump. */
name|incremental
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If what remains to be dumped is not going to be dumped      incrementally, then dump the first revision in full. */
if|if
condition|(
operator|!
name|incremental
condition|)
block|{
name|SVN_ERR
argument_list|(
name|dump_initial_full_revision
argument_list|(
name|session
argument_list|,
name|extra_ra_session
argument_list|,
name|stdout_stream
argument_list|,
name|start_revision
argument_list|,
name|quiet
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|start_revision
operator|++
expr_stmt|;
block|}
comment|/* If there are still revisions left to be dumped, do so. */
if|if
condition|(
name|start_revision
operator|<=
name|end_revision
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_EV2_IMPL
name|SVN_ERR
argument_list|(
name|svn_ra_replay_range
argument_list|(
name|session
argument_list|,
name|start_revision
argument_list|,
name|end_revision
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|replay_revstart
argument_list|,
name|replay_revend
argument_list|,
name|replay_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SVN_ERR
argument_list|(
name|svn_ra__replay_range_ev2
argument_list|(
name|session
argument_list|,
name|start_revision
argument_list|,
name|end_revision
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|replay_revstart_v2
argument_list|,
name|replay_revend_v2
argument_list|,
name|replay_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stdout_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a dumpstream from stdin, and use it to feed a loader capable  * of transmitting that information to the repository located at URL  * (to which SESSION has been opened).  AUX_SESSION is a second RA  * session opened to the same URL for performing auxiliary out-of-band  * operations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|load_revisions
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|aux_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
name|apr_hash_t
modifier|*
name|skip_revprops
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|stdin_file
decl_stmt|;
name|svn_stream_t
modifier|*
name|stdin_stream
decl_stmt|;
name|apr_file_open_stdin
argument_list|(
operator|&
name|stdin_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|stdin_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|stdin_file
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rdump__load_dumpstream
argument_list|(
name|stdin_stream
argument_list|,
name|session
argument_list|,
name|aux_session
argument_list|,
name|quiet
argument_list|,
name|skip_revprops
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stdin_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a program name for this program, the basename of the path  * represented by PROGNAME if not NULL; use "svnrdump" otherwise.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ensure_appname
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|progname
condition|)
return|return
literal|"svnrdump"
return|;
return|return
name|svn_dirent_basename
argument_list|(
name|svn_dirent_internal_style
argument_list|(
name|progname
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print a simple usage string. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Type '%s help' for usage.\n"
argument_list|)
argument_list|,
name|ensure_appname
argument_list|(
name|progname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print information about the version of this program and dependent  * modules.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|version
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|version_footer
init|=
name|svn_stringbuf_create
argument_list|(
name|_
argument_list|(
literal|"The following repository access (RA) modules "
literal|"are available:\n\n"
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_print_modules
argument_list|(
name|version_footer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_opt_print_help4
argument_list|(
name|NULL
argument_list|,
name|ensure_appname
argument_list|(
name|progname
argument_list|,
name|pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|quiet
argument_list|,
name|FALSE
argument_list|,
name|version_footer
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle the "dump" subcommand.  Implements `svn_opt_subcommand_t'.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_cmd
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|opt_baton_t
modifier|*
name|opt_baton
init|=
name|baton
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|extra_ra_session
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|extra_ra_session
argument_list|,
name|opt_baton
operator|->
name|url
argument_list|,
name|NULL
argument_list|,
name|opt_baton
operator|->
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|extra_ra_session
argument_list|,
operator|&
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|extra_ra_session
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|replay_revisions
argument_list|(
name|opt_baton
operator|->
name|session
argument_list|,
name|extra_ra_session
argument_list|,
name|opt_baton
operator|->
name|start_revision
operator|.
name|value
operator|.
name|number
argument_list|,
name|opt_baton
operator|->
name|end_revision
operator|.
name|value
operator|.
name|number
argument_list|,
name|opt_baton
operator|->
name|quiet
argument_list|,
name|opt_baton
operator|->
name|incremental
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle the "load" subcommand.  Implements `svn_opt_subcommand_t'.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|load_cmd
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|opt_baton_t
modifier|*
name|opt_baton
init|=
name|baton
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|aux_session
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|aux_session
argument_list|,
name|opt_baton
operator|->
name|url
argument_list|,
name|NULL
argument_list|,
name|opt_baton
operator|->
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|load_revisions
argument_list|(
name|opt_baton
operator|->
name|session
argument_list|,
name|aux_session
argument_list|,
name|opt_baton
operator|->
name|url
argument_list|,
name|opt_baton
operator|->
name|quiet
argument_list|,
name|opt_baton
operator|->
name|skip_revprops
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle the "help" subcommand.  Implements `svn_opt_subcommand_t'.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|help_cmd
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|header
init|=
name|_
argument_list|(
literal|"general usage: svnrdump SUBCOMMAND URL [-r LOWER[:UPPER]]\n"
literal|"Subversion remote repository dump and load tool.\n"
literal|"Type 'svnrdump help<subcommand>' for help on a specific subcommand.\n"
literal|"Type 'svnrdump --version' to see the program version and RA modules.\n"
literal|"\n"
literal|"Available subcommands:\n"
argument_list|)
decl_stmt|;
return|return
name|svn_opt_print_help4
argument_list|(
name|os
argument_list|,
literal|"svnrdump"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|header
argument_list|,
name|svnrdump__cmd_table
argument_list|,
name|svnrdump__options
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Examine the OPT_BATON's 'start_revision' and 'end_revision'  * members, making sure that they make sense (in general, and as  * applied to a repository whose current youngest revision is  * LATEST_REVISION).  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|validate_and_resolve_revisions
parameter_list|(
name|opt_baton_t
modifier|*
name|opt_baton
parameter_list|,
name|svn_revnum_t
name|latest_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|provided_start_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* Ensure that the start revision is something we can handle.  We      want a number>= 0.  If unspecified, make it a number (r0) --      anything else is bogus.  */
if|if
condition|(
name|opt_baton
operator|->
name|start_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_number
condition|)
block|{
name|provided_start_rev
operator|=
name|opt_baton
operator|->
name|start_revision
operator|.
name|value
operator|.
name|number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_baton
operator|->
name|start_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_head
condition|)
block|{
name|opt_baton
operator|->
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|opt_baton
operator|->
name|start_revision
operator|.
name|value
operator|.
name|number
operator|=
name|latest_revision
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_baton
operator|->
name|start_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
block|{
name|opt_baton
operator|->
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|opt_baton
operator|->
name|start_revision
operator|.
name|value
operator|.
name|number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|opt_baton
operator|->
name|start_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_number
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported revision specifier used; use "
literal|"only integer values or 'HEAD'"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|opt_baton
operator|->
name|start_revision
operator|.
name|value
operator|.
name|number
operator|<
literal|0
operator|)
operator|||
operator|(
name|opt_baton
operator|->
name|start_revision
operator|.
name|value
operator|.
name|number
operator|>
name|latest_revision
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision '%ld' does not exist"
argument_list|)
argument_list|,
name|opt_baton
operator|->
name|start_revision
operator|.
name|value
operator|.
name|number
argument_list|)
return|;
block|}
comment|/* Ensure that the end revision is something we can handle.  We want      a number<= the youngest, and> the start revision.  If      unspecified, make it a number (start_revision + 1 if that was      specified, the youngest revision in the repository otherwise) --      anything else is bogus.  */
if|if
condition|(
name|opt_baton
operator|->
name|end_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
block|{
name|opt_baton
operator|->
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|provided_start_rev
argument_list|)
condition|)
name|opt_baton
operator|->
name|end_revision
operator|.
name|value
operator|.
name|number
operator|=
name|provided_start_rev
expr_stmt|;
else|else
name|opt_baton
operator|->
name|end_revision
operator|.
name|value
operator|.
name|number
operator|=
name|latest_revision
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_baton
operator|->
name|end_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_head
condition|)
block|{
name|opt_baton
operator|->
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|opt_baton
operator|->
name|end_revision
operator|.
name|value
operator|.
name|number
operator|=
name|latest_revision
expr_stmt|;
block|}
if|if
condition|(
name|opt_baton
operator|->
name|end_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_number
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported revision specifier used; use "
literal|"only integer values or 'HEAD'"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|opt_baton
operator|->
name|end_revision
operator|.
name|value
operator|.
name|number
operator|<
literal|0
operator|)
operator|||
operator|(
name|opt_baton
operator|->
name|end_revision
operator|.
name|value
operator|.
name|number
operator|>
name|latest_revision
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision '%ld' does not exist"
argument_list|)
argument_list|,
name|opt_baton
operator|->
name|end_revision
operator|.
name|value
operator|.
name|number
argument_list|)
return|;
block|}
comment|/* Finally, make sure that the end revision is younger than the      start revision.  We don't do "backwards" 'round here.  */
if|if
condition|(
name|opt_baton
operator|->
name|end_revision
operator|.
name|value
operator|.
name|number
operator|<
name|opt_baton
operator|->
name|start_revision
operator|.
name|value
operator|.
name|number
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"LOWER revision cannot be greater than "
literal|"UPPER revision; consider reversing your "
literal|"revision range"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * On success, leave *EXIT_CODE untouched and return SVN_NO_ERROR. On error,  * either return an error to be displayed, or set *EXIT_CODE to non-zero and  * return SVN_NO_ERROR.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sub_main
parameter_list|(
name|int
modifier|*
name|exit_code
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|subcommand
init|=
name|NULL
decl_stmt|;
name|opt_baton_t
modifier|*
name|opt_baton
decl_stmt|;
name|svn_revnum_t
name|latest_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_dir
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|no_auth_cache
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_unknown_ca
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_cn_mismatch
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_expired
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_not_yet_valid
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_other_failure
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|non_interactive
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|force_interactive
init|=
name|FALSE
decl_stmt|;
name|apr_array_header_t
modifier|*
name|config_options
init|=
name|NULL
decl_stmt|;
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
specifier|const
name|char
modifier|*
name|first_arg
decl_stmt|;
name|apr_array_header_t
modifier|*
name|received_opts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|opt_baton
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opt_baton
argument_list|)
argument_list|)
expr_stmt|;
name|opt_baton
operator|->
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_baton
operator|->
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_baton
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
name|opt_baton
operator|->
name|skip_revprops
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|interleave
operator|=
name|TRUE
expr_stmt|;
comment|/* Options and arguments can be interleaved */
comment|/* Set up our cancellation support. */
name|apr_signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBREAK
comment|/* SIGBREAK is a Win32 specific signal generated by ctrl-break. */
name|apr_signal
argument_list|(
name|SIGBREAK
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|apr_signal
argument_list|(
name|SIGHUP
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|apr_signal
argument_list|(
name|SIGTERM
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* Disable SIGPIPE generation for the platforms that have it. */
name|apr_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
comment|/* Disable SIGXFSZ generation for the platforms that have it, otherwise    * working with large files when compiled against an APR that doesn't have    * large file support will crash the program, which is uncool. */
name|apr_signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|received_opts
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|SVN_OPT_MAX_OPTIONS
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
name|apr_status_t
name|status
init|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|svnrdump__options
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|opt_arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
break|break;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|SVN_ERR
argument_list|(
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Stash the option code in an array before parsing it. */
name|APR_ARRAY_PUSH
argument_list|(
name|received_opts
argument_list|,
name|int
argument_list|)
operator|=
name|opt
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'r'
case|:
block|{
comment|/* Make sure we've not seen -r already. */
if|if
condition|(
name|opt_baton
operator|->
name|start_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Multiple revision arguments "
literal|"encountered; try '-r N:M' instead "
literal|"of '-r N -r M'"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Parse the -r argument. */
if|if
condition|(
name|svn_opt_parse_revision
argument_list|(
operator|&
operator|(
name|opt_baton
operator|->
name|start_revision
operator|)
argument_list|,
operator|&
operator|(
name|opt_baton
operator|->
name|end_revision
operator|)
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|utf8_opt_arg
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Syntax error in revision "
literal|"argument '%s'"
argument_list|)
argument_list|,
name|utf8_opt_arg
argument_list|)
return|;
block|}
block|}
break|break;
case|case
literal|'q'
case|:
name|opt_baton
operator|->
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_config_dir
case|:
name|config_dir
operator|=
name|opt_arg
expr_stmt|;
break|break;
case|case
name|opt_version
case|:
name|opt_baton
operator|->
name|version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|opt_baton
operator|->
name|help
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_auth_username
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|username
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|opt_auth_password
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|password
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|opt_auth_nocache
case|:
name|no_auth_cache
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_non_interactive
case|:
name|non_interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_force_interactive
case|:
name|force_interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_incremental
case|:
name|opt_baton
operator|->
name|incremental
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_skip_revprop
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|opt_baton
operator|->
name|skip_revprops
argument_list|,
name|opt_arg
argument_list|,
name|opt_arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|opt_trust_server_cert
case|:
comment|/* backward compat */
name|trust_unknown_ca
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_trust_server_cert_failures
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_trust_options
argument_list|(
operator|&
name|trust_unknown_ca
argument_list|,
operator|&
name|trust_cn_mismatch
argument_list|,
operator|&
name|trust_expired
argument_list|,
operator|&
name|trust_not_yet_valid
argument_list|,
operator|&
name|trust_other_failure
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|opt_config_option
case|:
if|if
condition|(
operator|!
name|config_options
condition|)
name|config_options
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_config_option
argument_list|(
name|config_options
argument_list|,
name|opt_arg
argument_list|,
literal|"svnrdump: "
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The --non-interactive and --force-interactive options are mutually    * exclusive. */
if|if
condition|(
name|non_interactive
operator|&&
name|force_interactive
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--non-interactive and --force-interactive "
literal|"are mutually exclusive"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|opt_baton
operator|->
name|help
condition|)
block|{
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|svnrdump__cmd_table
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
if|if
condition|(
name|opt_baton
operator|->
name|version
condition|)
block|{
comment|/* Use the "help" subcommand to handle the "--version" option. */
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|pseudo_cmd
init|=
block|{
literal|"--version"
block|,
name|help_cmd
block|,
block|{
literal|0
block|}
block|,
literal|""
block|,
block|{
name|opt_version
block|,
comment|/* must accept its own option */
literal|'q'
block|,
comment|/* --quiet */
block|}
block|}
decl_stmt|;
name|subcommand
operator|=
operator|&
name|pseudo_cmd
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
name|first_arg
operator|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
expr_stmt|;
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|svnrdump__cmd_table
argument_list|,
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|first_arg_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|first_arg_utf8
argument_list|,
name|first_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Unknown subcommand: '%s'\n"
argument_list|)
argument_list|,
name|first_arg_utf8
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
comment|/* Check that the subcommand wasn't passed any inappropriate options. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|received_opts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|int
name|opt_id
init|=
name|APR_ARRAY_IDX
argument_list|(
name|received_opts
argument_list|,
name|i
argument_list|,
name|int
argument_list|)
decl_stmt|;
comment|/* All commands implicitly accept --help, so just skip over this          when we see it. Note that we don't want to include this option          in their "accepted options" list because it would be awfully          redundant to display it in every commands' help text. */
if|if
condition|(
name|opt_id
operator|==
literal|'h'
operator|||
name|opt_id
operator|==
literal|'?'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|svn_opt_subcommand_takes_option3
argument_list|(
name|subcommand
argument_list|,
name|opt_id
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
specifier|const
name|apr_getopt_option_t
modifier|*
name|badopt
init|=
name|svn_opt_get_option_from_code2
argument_list|(
name|opt_id
argument_list|,
name|svnrdump__options
argument_list|,
name|subcommand
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_opt_format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|badopt
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Subcommand '%s' doesn't accept option '%s'\n"
literal|"Type 'svnrdump help %s' for usage.\n"
argument_list|)
argument_list|,
name|subcommand
operator|->
name|name
argument_list|,
name|optstr
argument_list|,
name|subcommand
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|subcommand
operator|->
name|name
argument_list|,
literal|"--version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|version
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|opt_baton
operator|->
name|quiet
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|subcommand
operator|->
name|name
argument_list|,
literal|"help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|os
argument_list|,
name|opt_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* --trust-* can only be used with --non-interactive */
if|if
condition|(
operator|!
name|non_interactive
condition|)
block|{
if|if
condition|(
name|trust_unknown_ca
operator|||
name|trust_cn_mismatch
operator|||
name|trust_expired
operator|||
name|trust_not_yet_valid
operator|||
name|trust_other_failure
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--trust-server-cert-failures requires "
literal|"--non-interactive"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Expect one more non-option argument:  the repository URL. */
if|if
condition|(
name|os
operator|->
name|ind
operator|!=
name|os
operator|->
name|argc
operator|-
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|repos_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|repos_url
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|repos_url
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
literal|"Target '%s' is not a URL"
argument_list|,
name|repos_url
argument_list|)
return|;
block|}
name|opt_baton
operator|->
name|url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|repos_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|subcommand
operator|->
name|name
argument_list|,
literal|"load"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*        * By default (no --*-interactive options given), the 'load' subcommand        * is interactive unless username and password were provided on the        * command line. This allows prompting for auth creds to work without        * requiring users to remember to use --force-interactive.        * See issue #3913, "svnrdump load is not working in interactive mode".        */
if|if
condition|(
operator|!
name|non_interactive
operator|&&
operator|!
name|force_interactive
condition|)
name|force_interactive
operator|=
operator|(
name|username
operator|==
name|NULL
operator|||
name|password
operator|==
name|NULL
operator|)
expr_stmt|;
block|}
name|non_interactive
operator|=
operator|!
name|svn_cmdline__be_interactive
argument_list|(
name|non_interactive
argument_list|,
name|force_interactive
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|init_client_context
argument_list|(
operator|&
operator|(
name|opt_baton
operator|->
name|ctx
operator|)
argument_list|,
name|non_interactive
argument_list|,
name|username
argument_list|,
name|password
argument_list|,
name|config_dir
argument_list|,
name|opt_baton
operator|->
name|url
argument_list|,
name|no_auth_cache
argument_list|,
name|trust_unknown_ca
argument_list|,
name|trust_cn_mismatch
argument_list|,
name|trust_expired
argument_list|,
name|trust_not_yet_valid
argument_list|,
name|trust_other_failure
argument_list|,
name|config_options
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_client_open_ra_session2
argument_list|(
operator|&
operator|(
name|opt_baton
operator|->
name|session
operator|)
argument_list|,
name|opt_baton
operator|->
name|url
argument_list|,
name|NULL
argument_list|,
name|opt_baton
operator|->
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Have sane opt_baton->start_revision and end_revision defaults if      unspecified.  */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_ra_get_latest_revnum
argument_list|(
name|opt_baton
operator|->
name|session
argument_list|,
operator|&
name|latest_revision
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Make sure any provided revisions make sense. */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|validate_and_resolve_revisions
argument_list|(
name|opt_baton
argument_list|,
name|latest_revision
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Dispatch the subcommand */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
call|(
modifier|*
name|subcommand
operator|->
name|cmd_func
call|)
argument_list|(
name|os
argument_list|,
name|opt_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_AUTHN_FAILED
operator|&&
name|non_interactive
condition|)
block|{
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Authentication failed and interactive"
literal|" prompting is disabled; see the"
literal|" --force-interactive option"
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|int
name|exit_code
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svnrdump"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool.  Use a separate mutexless allocator,    * given this application is single threaded.    */
name|pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|sub_main
argument_list|(
operator|&
name|exit_code
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Flush stdout and report if it fails. It would be flushed on exit anyway      but this makes sure that output is not silently lost if it fails. */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|,
literal|"svnrdump: "
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function

end_unit

