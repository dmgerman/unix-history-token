begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * get_file.c :  entry point for update RA functions for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_version.h>
end_include

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * This structure represents a single request to GET (fetch) a file with  * its associated Serf session/connection.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|stream_ctx_t
block|{
comment|/* The handler representing this particular fetch.  */
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* Have we read our response headers yet? */
name|svn_boolean_t
name|read_headers
decl_stmt|;
name|svn_boolean_t
name|using_compression
decl_stmt|;
comment|/* This flag is set when our response is aborted before we reach the    * end and we decide to requeue this request.    */
name|svn_boolean_t
name|aborted_read
decl_stmt|;
name|apr_off_t
name|aborted_read_size
decl_stmt|;
comment|/* This is the amount of data that we have read so far. */
name|apr_off_t
name|read_size
decl_stmt|;
comment|/* If we're writing this file to a stream, this will be non-NULL. */
name|svn_stream_t
modifier|*
name|result_stream
decl_stmt|;
block|}
name|stream_ctx_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/** Routines called when we are fetching a file */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|headers_fetch
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|stream_ctx_t
modifier|*
name|fetch_ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|fetch_ctx
operator|->
name|using_compression
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Accept-Encoding"
argument_list|,
literal|"gzip"
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cancel_fetch
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|int
name|status_code
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|stream_ctx_t
modifier|*
name|fetch_ctx
init|=
name|baton
decl_stmt|;
comment|/* Uh-oh.  Our connection died on us.    *    * The core ra_serf layer will requeue our request - we just need to note    * that we got cut off in the middle of our song.    */
if|if
condition|(
operator|!
name|response
condition|)
block|{
comment|/* If we already started the fetch and opened the file handle, we need        * to hold subsequent read() ops until we get back to where we were        * before the close and we can then resume the textdelta() calls.        */
if|if
condition|(
name|fetch_ctx
operator|->
name|read_headers
condition|)
block|{
if|if
condition|(
operator|!
name|fetch_ctx
operator|->
name|aborted_read
operator|&&
name|fetch_ctx
operator|->
name|read_size
condition|)
block|{
name|fetch_ctx
operator|->
name|aborted_read
operator|=
name|TRUE
expr_stmt|;
name|fetch_ctx
operator|->
name|aborted_read_size
operator|=
name|fetch_ctx
operator|->
name|read_size
expr_stmt|;
block|}
name|fetch_ctx
operator|->
name|read_size
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We have no idea what went wrong. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper svn_ra_serf__get_file(). Attempts to fetch file contents  * using SESSION->wc_callbacks->get_wc_contents() if sha1 property is  * present in PROPS.  *  * Sets *FOUND_P to TRUE if file contents was successfuly fetched.  *  * Performs all temporary allocations in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|try_get_wc_contents
parameter_list|(
name|svn_boolean_t
modifier|*
name|found_p
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|sha1_checksum_prop
parameter_list|,
name|svn_stream_t
modifier|*
name|dst_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_stream_t
modifier|*
name|wc_stream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* No contents found by default. */
operator|*
name|found_p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
operator|||
name|sha1_checksum_prop
operator|==
name|NULL
condition|)
block|{
comment|/* Nothing to do. */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|sha1_checksum_prop
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|session
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
argument_list|(
name|session
operator|->
name|wc_callback_baton
argument_list|,
operator|&
name|wc_stream
argument_list|,
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Ignore errors for now. */
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|wc_stream
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|wc_stream
argument_list|,
name|svn_stream_disown
argument_list|(
name|dst_stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|found_p
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* -----------------------------------------------------------------------    svn_ra_get_file() specific */
end_comment

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_stream
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|stream_ctx_t
modifier|*
name|fetch_ctx
init|=
name|handler_baton
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|fetch_ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|200
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|fetch_ctx
operator|->
name|handler
argument_list|)
argument_list|)
return|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
literal|8000
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|fetch_ctx
operator|->
name|read_size
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|fetch_ctx
operator|->
name|aborted_read
condition|)
block|{
name|apr_off_t
name|skip
decl_stmt|;
comment|/* We haven't caught up to where we were before. */
if|if
condition|(
name|fetch_ctx
operator|->
name|read_size
operator|<
name|fetch_ctx
operator|->
name|aborted_read_size
condition|)
block|{
comment|/* Eek.  What did the file shrink or something? */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
comment|/* Skip on to the next iteration of this loop. */
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
continue|continue;
block|}
comment|/* Woo-hoo.  We're back. */
name|fetch_ctx
operator|->
name|aborted_read
operator|=
name|FALSE
expr_stmt|;
comment|/* Increment data and len by the difference. */
name|skip
operator|=
name|len
operator|-
operator|(
name|fetch_ctx
operator|->
name|read_size
operator|-
name|fetch_ctx
operator|->
name|aborted_read_size
operator|)
expr_stmt|;
name|data
operator|+=
name|skip
expr_stmt|;
name|len
operator|-=
operator|(
name|apr_size_t
operator|)
name|skip
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|apr_size_t
name|written_len
decl_stmt|;
name|written_len
operator|=
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|fetch_ctx
operator|->
name|result_stream
argument_list|,
name|data
argument_list|,
operator|&
name|written_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
comment|/* not reached */
block|}
end_function

begin_comment
comment|/* Baton for get_file_prop_cb */
end_comment

begin_struct
struct|struct
name|file_prop_baton_t
block|{
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|char
modifier|*
name|sha1_checksum
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_ra_serf__prop_func_t for svn_ra_serf__get_file */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_prop_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|file_prop_baton_t
modifier|*
name|fb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|svn_name
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"resourcetype"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|value
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"collection"
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
name|fb
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_DAV
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sha1-checksum"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fb
operator|->
name|sha1_checksum
operator|=
name|apr_pstrdup
argument_list|(
name|fb
operator|->
name|result_pool
argument_list|,
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fb
operator|->
name|props
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|svn_name
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|fb
operator|->
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_name
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|fb
operator|->
name|props
argument_list|,
name|svn_name
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|fb
operator|->
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_file
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|fetch_url
decl_stmt|;
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|which_props
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|propfind_handler
decl_stmt|;
name|struct
name|file_prop_baton_t
name|fb
decl_stmt|;
comment|/* Fetch properties. */
name|fetch_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* The simple case is if we want HEAD - then a GET on the fetch_url is fine.    *    * Otherwise, we need to get the baseline version for this particular    * revision and then fetch that file.    */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
operator|||
name|fetched_rev
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|fetch_url
argument_list|,
name|fetched_rev
argument_list|,
name|session
argument_list|,
name|fetch_url
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* REVISION is always SVN_INVALID_REVNUM  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
condition|)
name|which_props
operator|=
name|all_props
expr_stmt|;
elseif|else
if|if
condition|(
name|stream
operator|&&
name|session
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
condition|)
name|which_props
operator|=
name|type_and_checksum_props
expr_stmt|;
else|else
name|which_props
operator|=
name|check_path_props
expr_stmt|;
name|fb
operator|.
name|result_pool
operator|=
name|pool
expr_stmt|;
name|fb
operator|.
name|props
operator|=
name|props
condition|?
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|fb
operator|.
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|fb
operator|.
name|sha1_checksum
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|propfind_handler
argument_list|,
name|session
argument_list|,
name|fetch_url
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|"0"
argument_list|,
name|which_props
argument_list|,
name|get_file_prop_cb
argument_list|,
operator|&
name|fb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|propfind_handler
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify that resource type is not collection. */
if|if
condition|(
name|fb
operator|.
name|kind
operator|!=
name|svn_node_file
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get text contents of a directory"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|props
condition|)
operator|*
name|props
operator|=
name|fb
operator|.
name|props
expr_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|svn_boolean_t
name|found
decl_stmt|;
name|SVN_ERR
argument_list|(
name|try_get_wc_contents
argument_list|(
operator|&
name|found
argument_list|,
name|session
argument_list|,
name|fb
operator|.
name|sha1_checksum
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No contents found in the WC, let's fetch from server. */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|stream_ctx_t
modifier|*
name|stream_ctx
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* Create the fetch context. */
name|stream_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|stream_ctx
operator|->
name|result_stream
operator|=
name|stream
expr_stmt|;
name|stream_ctx
operator|->
name|using_compression
operator|=
name|session
operator|->
name|using_compression
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|session
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"GET"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|fetch_url
expr_stmt|;
name|handler
operator|->
name|custom_accept_encoding
operator|=
name|TRUE
expr_stmt|;
name|handler
operator|->
name|no_dav_headers
operator|=
name|TRUE
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|headers_fetch
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|stream_ctx
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|handle_stream
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|stream_ctx
expr_stmt|;
name|handler
operator|->
name|response_error
operator|=
name|cancel_fetch
expr_stmt|;
name|handler
operator|->
name|response_error_baton
operator|=
name|stream_ctx
expr_stmt|;
name|stream_ctx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|200
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

