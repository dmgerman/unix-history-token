begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * multistatus.c : parse multistatus (error) responses.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|<serf_bucket_types.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_comment
comment|/* The current state of our XML parsing. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|iprops_state_e
block|{
name|INITIAL
init|=
name|XML_STATE_INITIAL
block|,
name|MS_MULTISTATUS
block|,
name|MS_RESPONSE
block|,
name|MS_RESPONSE_HREF
block|,
name|MS_PROPSTAT
block|,
name|MS_PROPSTAT_PROP
block|,
name|MS_PROPSTAT_PROP_NAME
block|,
name|MS_PROPSTAT_STATUS
block|,
name|MS_PROPSTAT_RESPONSEDESCRIPTION
block|,
name|MS_PROPSTAT_ERROR
block|,
name|MS_PROPSTAT_ERROR_HUMANREADABLE
block|,
name|MS_RESPONSE_STATUS
block|,
name|MS_RESPONSE_RESPONSEDESCRIPTION
block|,
name|MS_RESPONSE_ERROR
block|,
name|MS_RESPONSE_ERROR_HUMANREADABLE
block|,
name|MS_MULTISTATUS_RESPONSEDESCRIPTION
block|,
name|D_ERROR
block|,
name|S_ERROR
block|,
name|M_ERROR_HUMANREADABLE
block|}
name|iprops_state_e
typedef|;
end_typedef

begin_comment
comment|/*<D:multistatus xmlns:D="DAV:"><D:response><D:href>http://something</D:href><!-- Possibly multiple D:href elements --><D:status>HTTP/1.1 500 failed</D:status><D:error><S:human-readable code="12345">           Some Subversion error</S:human-readable></D:error><D:responsedescription>         Human readable description</D:responsedescription><D:location>http://redirected</D:location></D:response>     ...</D:multistatus>    Or for property operations:<D:multistatus xmlns:D="DAV:"><D:response><D:href>http://somewhere-else</D:href><D:propstat><D:propname><C:myprop /></D:propname><D:status>HTTP/1.1 499 failed</D:status><D:error><S:human-readable code="12345">             Some Subversion error</S:human-readable></D:error><D:responsedescription>           Human readable description</D:responsedescription></D:propstat><D:status>HTTP/1.1 499 failed</D:status><D:error><S:human-readable code="12345">           Some Subversion error</S:human-readable></D:error><D:responsedescription>         Human readable description</D:responsedescription><D:location>http://redirected</D:location><D:responsedescription>       Global description<D:responsedescription></D:multistatus>    Or on request failures<D:error><X:some-error xmlns="QQ" /><D:human-readable code="12345">           Some Subversion error</D:human-readable></D:error>  */
end_comment

begin_define
define|#
directive|define
name|D_
value|"DAV:"
end_define

begin_define
define|#
directive|define
name|S_
value|SVN_XML_NAMESPACE
end_define

begin_define
define|#
directive|define
name|M_
value|"http://apache.org/dav/xmlns"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_serf__xml_transition_t
name|multistatus_ttable
index|[]
init|=
block|{
block|{
name|INITIAL
block|,
name|D_
block|,
literal|"multistatus"
block|,
name|MS_MULTISTATUS
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|MS_MULTISTATUS
block|,
name|D_
block|,
literal|"responsedescription"
block|,
name|MS_MULTISTATUS_RESPONSEDESCRIPTION
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
comment|/*<response> */
block|{
name|MS_MULTISTATUS
block|,
name|D_
block|,
literal|"response"
block|,
name|MS_RESPONSE
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|MS_RESPONSE
block|,
name|D_
block|,
literal|"href"
block|,
name|MS_RESPONSE_HREF
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
comment|/*<propstat> */
block|{
name|MS_RESPONSE
block|,
name|D_
block|,
literal|"propstat"
block|,
name|MS_PROPSTAT
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|MS_PROPSTAT
block|,
name|D_
block|,
literal|"prop"
block|,
name|MS_PROPSTAT_PROP
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|MS_PROPSTAT_PROP
block|,
literal|""
block|,
literal|"*"
block|,
name|MS_PROPSTAT_PROP_NAME
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|MS_PROPSTAT
block|,
name|D_
block|,
literal|"status"
block|,
name|MS_PROPSTAT_STATUS
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|MS_PROPSTAT
block|,
name|D_
block|,
literal|"responsedescription"
block|,
name|MS_PROPSTAT_RESPONSEDESCRIPTION
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|MS_PROPSTAT
block|,
name|D_
block|,
literal|"error"
block|,
name|MS_PROPSTAT_ERROR
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|MS_PROPSTAT_ERROR
block|,
name|M_
block|,
literal|"human-readable"
block|,
name|MS_PROPSTAT_ERROR_HUMANREADABLE
block|,
name|TRUE
block|,
block|{
literal|"?errcode"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
comment|/*</propstat> */
block|{
name|MS_RESPONSE
block|,
name|D_
block|,
literal|"status"
block|,
name|MS_RESPONSE_STATUS
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|MS_RESPONSE
block|,
name|D_
block|,
literal|"responsedescription"
block|,
name|MS_RESPONSE_RESPONSEDESCRIPTION
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|MS_RESPONSE
block|,
name|D_
block|,
literal|"error"
block|,
name|MS_RESPONSE_ERROR
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|MS_RESPONSE_ERROR
block|,
name|M_
block|,
literal|"human-readable"
block|,
name|MS_RESPONSE_ERROR_HUMANREADABLE
block|,
name|TRUE
block|,
block|{
literal|"?errcode"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
comment|/*</response> */
block|{
name|MS_MULTISTATUS
block|,
name|D_
block|,
literal|"responsedescription"
block|,
name|MS_MULTISTATUS_RESPONSEDESCRIPTION
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|INITIAL
block|,
name|D_
block|,
literal|"error"
block|,
name|D_ERROR
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|D_ERROR
block|,
name|S_
block|,
literal|"error"
block|,
name|S_ERROR
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|D_ERROR
block|,
name|M_
block|,
literal|"human-readable"
block|,
name|M_ERROR_HUMANREADABLE
block|,
name|TRUE
block|,
block|{
literal|"?errcode"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a string like "HTTP/1.1 500 (status)" in BUF, parse out the numeric    status code into *STATUS_CODE_OUT.  Ignores leading whitespace. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_status_line
parameter_list|(
name|int
modifier|*
name|status_code_out
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|status_line
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|char
modifier|*
name|tok_status
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|temp_buf
init|=
name|svn_stringbuf_create
argument_list|(
name|status_line
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|temp_buf
argument_list|)
expr_stmt|;
name|token
operator|=
name|apr_strtok
argument_list|(
name|temp_buf
operator|->
name|data
argument_list|,
literal|" \t\r\n"
argument_list|,
operator|&
name|tok_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
condition|)
name|token
operator|=
name|apr_strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t\r\n"
argument_list|,
operator|&
name|tok_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed DAV:status '%s'"
argument_list|)
argument_list|,
name|status_line
argument_list|)
return|;
name|err
operator|=
name|svn_cstring_atoi
argument_list|(
name|status_code_out
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Malformed DAV:status '%s'"
argument_list|)
argument_list|,
name|status_line
argument_list|)
return|;
name|token
operator|=
name|apr_strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t\r\n"
argument_list|,
operator|&
name|tok_status
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|error_item_t
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
name|int
name|http_status
decl_stmt|;
specifier|const
name|char
modifier|*
name|http_reason
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|}
name|error_item_t
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|multistatus_opened
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|entered_state
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|tag
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/*struct svn_ra_serf__server_error_t *server_error = baton;*/
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
switch|switch
condition|(
name|entered_state
condition|)
block|{
case|case
name|MS_PROPSTAT_PROP_NAME
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|tag
operator|->
name|xmlns
argument_list|,
name|SVN_DAV_PROP_NS_SVN
argument_list|)
operator|==
literal|0
condition|)
name|propname
operator|=
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|tag
operator|->
name|name
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
else|else
name|propname
operator|=
name|tag
operator|->
name|name
expr_stmt|;
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|MS_PROPSTAT
argument_list|,
literal|"propname"
argument_list|,
name|propname
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_ERROR
case|:
comment|/* This toggles an has error boolean in libsvn_ra_neon in 1.7 */
break|break;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|multistatus_closed
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|leaving_state
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|cdata
parameter_list|,
name|apr_hash_t
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|svn_ra_serf__server_error_t
modifier|*
name|server_error
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|errcode
decl_stmt|;
specifier|const
name|char
modifier|*
name|status
decl_stmt|;
switch|switch
condition|(
name|leaving_state
condition|)
block|{
case|case
name|MS_RESPONSE_HREF
case|:
block|{
name|apr_status_t
name|result
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
name|result
operator|=
name|apr_uri_parse
argument_list|(
name|scratch_pool
argument_list|,
name|cdata
operator|->
name|data
argument_list|,
operator|&
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|)
return|;
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|MS_RESPONSE
argument_list|,
literal|"path"
argument_list|,
name|svn_urlpath__canonicalize
argument_list|(
name|uri
operator|.
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MS_RESPONSE_STATUS
case|:
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|MS_RESPONSE
argument_list|,
literal|"status"
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|MS_RESPONSE_ERROR_HUMANREADABLE
case|:
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|MS_RESPONSE
argument_list|,
literal|"human-readable"
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"errcode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
condition|)
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|MS_RESPONSE
argument_list|,
literal|"errcode"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MS_RESPONSE
case|:
if|if
condition|(
operator|(
name|status
operator|=
name|svn_hash__get_cstring
argument_list|(
name|attrs
argument_list|,
literal|"status"
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error_item_t
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|apr_pcalloc
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"path"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_status_line
argument_list|(
operator|&
name|item
operator|->
name|http_status
argument_list|,
operator|&
name|item
operator|->
name|http_reason
argument_list|,
name|status
argument_list|,
name|server_error
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do we have a mod_dav specific message? */
name|item
operator|->
name|message
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"human-readable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|message
condition|)
block|{
if|if
condition|(
operator|(
name|errcode
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"errcode"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|apr_err
operator|=
operator|(
name|apr_status_t
operator|)
name|val
expr_stmt|;
block|}
name|item
operator|->
name|message
operator|=
name|apr_pstrdup
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
name|item
operator|->
name|message
argument_list|)
expr_stmt|;
block|}
else|else
name|item
operator|->
name|message
operator|=
name|apr_pstrdup
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"description"
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|server_error
operator|->
name|items
argument_list|,
name|error_item_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
break|break;
case|case
name|MS_PROPSTAT_STATUS
case|:
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|MS_PROPSTAT
argument_list|,
literal|"status"
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|MS_PROPSTAT_ERROR_HUMANREADABLE
case|:
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|MS_PROPSTAT
argument_list|,
literal|"human-readable"
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"errcode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
condition|)
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|MS_PROPSTAT
argument_list|,
literal|"errcode"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MS_PROPSTAT_RESPONSEDESCRIPTION
case|:
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|MS_PROPSTAT
argument_list|,
literal|"description"
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|MS_PROPSTAT
case|:
if|if
condition|(
operator|(
name|status
operator|=
name|svn_hash__get_cstring
argument_list|(
name|attrs
argument_list|,
literal|"status"
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|apr_hash_t
modifier|*
name|response_attrs
decl_stmt|;
name|error_item_t
modifier|*
name|item
decl_stmt|;
name|response_attrs
operator|=
name|svn_ra_serf__xml_gather_since
argument_list|(
name|xes
argument_list|,
name|MS_RESPONSE
argument_list|)
expr_stmt|;
name|item
operator|=
name|apr_pcalloc
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
name|svn_hash_gets
argument_list|(
name|response_attrs
argument_list|,
literal|"path"
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|propname
operator|=
name|apr_pstrdup
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"propname"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_status_line
argument_list|(
operator|&
name|item
operator|->
name|http_status
argument_list|,
operator|&
name|item
operator|->
name|http_reason
argument_list|,
name|status
argument_list|,
name|server_error
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do we have a mod_dav specific message? */
name|item
operator|->
name|message
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"human-readable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|message
condition|)
block|{
if|if
condition|(
operator|(
name|errcode
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"errcode"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|apr_err
operator|=
operator|(
name|apr_status_t
operator|)
name|val
expr_stmt|;
block|}
name|item
operator|->
name|message
operator|=
name|apr_pstrdup
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
name|item
operator|->
name|message
argument_list|)
expr_stmt|;
block|}
else|else
name|item
operator|->
name|message
operator|=
name|apr_pstrdup
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"description"
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|server_error
operator|->
name|items
argument_list|,
name|error_item_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
break|break;
case|case
name|M_ERROR_HUMANREADABLE
case|:
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|D_ERROR
argument_list|,
literal|"human-readable"
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"errcode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
condition|)
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|D_ERROR
argument_list|,
literal|"errcode"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_ERROR
case|:
block|{
name|error_item_t
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|apr_pcalloc
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|http_status
operator|=
name|server_error
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
expr_stmt|;
comment|/* Do we have a mod_dav specific message? */
name|item
operator|->
name|message
operator|=
name|svn_hash__get_cstring
argument_list|(
name|attrs
argument_list|,
literal|"human-readable"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|message
condition|)
block|{
if|if
condition|(
operator|(
name|errcode
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"errcode"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|apr_err
operator|=
operator|(
name|apr_status_t
operator|)
name|val
expr_stmt|;
block|}
name|item
operator|->
name|message
operator|=
name|apr_pstrdup
argument_list|(
name|server_error
operator|->
name|pool
argument_list|,
name|item
operator|->
name|message
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|server_error
operator|->
name|items
argument_list|,
name|error_item_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__server_error_create
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|server_error
init|=
name|handler
operator|->
name|server_error
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|server_error
operator|->
name|items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|error_item_t
modifier|*
name|item
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|svn_error_t
modifier|*
name|new_err
decl_stmt|;
name|item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|server_error
operator|->
name|items
argument_list|,
name|i
argument_list|,
name|error_item_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|apr_err
operator|&&
name|item
operator|->
name|http_status
operator|==
literal|200
condition|)
block|{
continue|continue;
comment|/* Success code */
block|}
elseif|else
if|if
condition|(
operator|!
name|item
operator|->
name|apr_err
operator|&&
name|item
operator|->
name|http_status
operator|==
literal|424
operator|&&
name|item
operator|->
name|propname
condition|)
block|{
continue|continue;
comment|/* Failed because other PROPPATCH operations failed */
block|}
if|if
condition|(
name|item
operator|->
name|apr_err
condition|)
name|status
operator|=
name|item
operator|->
name|apr_err
expr_stmt|;
else|else
switch|switch
condition|(
name|item
operator|->
name|http_status
condition|)
block|{
case|case
literal|0
case|:
continue|continue;
comment|/* Not an error */
case|case
literal|301
case|:
case|case
literal|302
case|:
case|case
literal|303
case|:
case|case
literal|307
case|:
case|case
literal|308
case|:
name|status
operator|=
name|SVN_ERR_RA_DAV_RELOCATED
expr_stmt|;
break|break;
case|case
literal|403
case|:
name|status
operator|=
name|SVN_ERR_RA_DAV_FORBIDDEN
expr_stmt|;
break|break;
case|case
literal|404
case|:
name|status
operator|=
name|SVN_ERR_FS_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|409
case|:
name|status
operator|=
name|SVN_ERR_FS_CONFLICT
expr_stmt|;
break|break;
case|case
literal|412
case|:
name|status
operator|=
name|SVN_ERR_RA_DAV_PRECONDITION_FAILED
expr_stmt|;
break|break;
case|case
literal|423
case|:
name|status
operator|=
name|SVN_ERR_FS_NO_LOCK_TOKEN
expr_stmt|;
break|break;
case|case
literal|500
case|:
name|status
operator|=
name|SVN_ERR_RA_DAV_REQUEST_FAILED
expr_stmt|;
break|break;
case|case
literal|501
case|:
name|status
operator|=
name|SVN_ERR_UNSUPPORTED_FEATURE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|err
condition|)
name|status
operator|=
name|err
operator|->
name|apr_err
expr_stmt|;
comment|/* Just use previous */
else|else
name|status
operator|=
name|SVN_ERR_RA_DAV_REQUEST_FAILED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|item
operator|->
name|message
operator|&&
operator|*
name|item
operator|->
name|message
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|sb
init|=
name|svn_stringbuf_create
argument_list|(
name|item
operator|->
name|message
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|message
operator|=
name|sb
operator|->
name|data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|propname
condition|)
block|{
name|message
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Property operation on '%s' failed"
argument_list|)
argument_list|,
name|item
operator|->
name|propname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Yuck: Older servers sometimes assume that we get convertable                    apr error codes, while mod_dav_svn just produces a blank                    text error, because err->message is NULL. */
name|serf_status_line
name|sline
decl_stmt|;
name|svn_error_t
modifier|*
name|tmp_err
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sline
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sline
argument_list|)
argument_list|)
expr_stmt|;
name|sline
operator|.
name|code
operator|=
name|item
operator|->
name|http_status
expr_stmt|;
name|sline
operator|.
name|reason
operator|=
name|item
operator|->
name|http_reason
expr_stmt|;
name|tmp_err
operator|=
name|svn_ra_serf__error_on_status
argument_list|(
name|sline
argument_list|,
name|item
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|message
operator|=
operator|(
name|tmp_err
operator|&&
name|tmp_err
operator|->
name|message
operator|)
condition|?
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|tmp_err
operator|->
name|message
argument_list|)
else|:
name|_
argument_list|(
literal|"<blank error>"
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|tmp_err
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|status
operator|>
literal|0
argument_list|)
expr_stmt|;
name|new_err
operator|=
name|svn_error_create
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|propname
condition|)
name|new_err
operator|=
name|svn_error_createf
argument_list|(
name|new_err
operator|->
name|apr_err
argument_list|,
name|new_err
argument_list|,
name|_
argument_list|(
literal|"While handling the '%s' property on '%s':"
argument_list|)
argument_list|,
name|item
operator|->
name|propname
argument_list|,
name|item
operator|->
name|path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|item
operator|->
name|path
condition|)
name|new_err
operator|=
name|svn_error_createf
argument_list|(
name|new_err
operator|->
name|apr_err
argument_list|,
name|new_err
argument_list|,
name|_
argument_list|(
literal|"While handling the '%s' path:"
argument_list|)
argument_list|,
name|item
operator|->
name|path
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|new_err
argument_list|)
expr_stmt|;
block|}
comment|/* Theoretically a 207 status can have a 'global' description without a      global STATUS that summarizes the final result of property/href      operations.       We should wrap that around the existing errors if there is one.       But currently I don't see how mod_dav ever sets that value */
if|if
condition|(
operator|!
name|err
condition|)
block|{
comment|/* We should fail.... but why... Who installed us? */
name|err
operator|=
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__setup_error_parsing
parameter_list|(
name|svn_ra_serf__server_error_t
modifier|*
modifier|*
name|server_err
parameter_list|,
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|svn_boolean_t
name|expect_207_only
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|ms_baton
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|tmp_handler
decl_stmt|;
name|int
modifier|*
name|expected_status
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|expected_status
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|expected_status
index|[
literal|0
index|]
operator|=
name|handler
operator|->
name|sline
operator|.
name|code
expr_stmt|;
name|ms_baton
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ms_baton
argument_list|)
argument_list|)
expr_stmt|;
name|ms_baton
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|ms_baton
operator|->
name|items
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|error_item_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ms_baton
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|ms_baton
operator|->
name|xmlctx
operator|=
name|svn_ra_serf__xml_context_create
argument_list|(
name|multistatus_ttable
argument_list|,
name|multistatus_opened
argument_list|,
name|multistatus_closed
argument_list|,
name|NULL
argument_list|,
name|ms_baton
argument_list|,
name|ms_baton
operator|->
name|pool
argument_list|)
expr_stmt|;
name|tmp_handler
operator|=
name|svn_ra_serf__create_expat_handler
argument_list|(
name|handler
operator|->
name|session
argument_list|,
name|ms_baton
operator|->
name|xmlctx
argument_list|,
name|expected_status
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Ugly way to obtain expat_handler() */
name|tmp_handler
operator|->
name|sline
operator|=
name|handler
operator|->
name|sline
expr_stmt|;
name|ms_baton
operator|->
name|response_handler
operator|=
name|tmp_handler
operator|->
name|response_handler
expr_stmt|;
name|ms_baton
operator|->
name|response_baton
operator|=
name|tmp_handler
operator|->
name|response_baton
expr_stmt|;
operator|*
name|server_err
operator|=
name|ms_baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_multistatus_only
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|baton
decl_stmt|;
comment|/* This function is just like expect_empty_body() except for the      XML parsing callbacks. We are looking for very limited pieces of      the multistatus response.  */
comment|/* We should see this just once, in order to initialize SERVER_ERROR.      At that point, the core error processing will take over. If we choose      not to parse an error, then we'll never return here (because we      change the response handler).  */
name|SVN_ERR_ASSERT
argument_list|(
name|handler
operator|->
name|server_error
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|{
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Content-Type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|strncasecmp
argument_list|(
name|val
argument_list|,
literal|"text/xml"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"text/xml"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|server_err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__setup_error_parsing
argument_list|(
operator|&
name|server_err
argument_list|,
name|handler
argument_list|,
name|TRUE
argument_list|,
name|handler
operator|->
name|handler_pool
argument_list|,
name|handler
operator|->
name|handler_pool
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|->
name|server_error
operator|=
name|server_err
expr_stmt|;
block|}
else|else
block|{
comment|/* The body was not text/xml, so we don't know what to do with it.              Toss anything that arrives.  */
name|handler
operator|->
name|discard_body
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Returning SVN_NO_ERROR will return APR_SUCCESS to serf, which tells it      to call the response handler again. That will start up the XML parsing,      or it will be dropped on the floor (per the decision above).  */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_server_error
parameter_list|(
name|svn_ra_serf__server_error_t
modifier|*
name|server_error
parameter_list|,
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|apr_status_t
modifier|*
name|serf_status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|server_error
operator|->
name|response_handler
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|server_error
operator|->
name|response_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If we do not receive an error or it is a non-transient error, return      immediately.       APR_EOF will be returned when parsing is complete.       APR_EAGAIN& WAIT_CONN may be intermittently returned as we proceed through      parsing and the network has no more data right now.  If we receive that,      clear the error and return - allowing serf to wait for more data.      */
if|if
condition|(
operator|!
name|err
operator|||
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
operator|*
name|serf_status
operator|=
name|err
operator|->
name|apr_err
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Clear the EOF. We don't need it as subversion error.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|serf_status
operator|=
name|APR_EOF
expr_stmt|;
comment|/* On PROPPATCH we always get status 207, which may or may not imply an      error status, but let's keep it generic and just do the check for      any multistatus */
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|==
literal|207
comment|/* MULTISTATUS */
condition|)
block|{
name|svn_boolean_t
name|have_error
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|server_error
operator|->
name|items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|error_item_t
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|server_error
operator|->
name|items
argument_list|,
name|i
argument_list|,
name|error_item_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|apr_err
operator|&&
name|item
operator|->
name|http_status
operator|==
literal|200
condition|)
block|{
continue|continue;
comment|/* Success code */
block|}
name|have_error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|have_error
condition|)
name|handler
operator|->
name|server_error
operator|=
name|NULL
expr_stmt|;
comment|/* We didn't have a server error */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

