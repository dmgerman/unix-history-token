begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * xml.c :  standard XML parsing routines for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Fix for older expat 1.95.x's that do not define  * XML_STATUS_OK/XML_STATUS_ERROR  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XML_STATUS_OK
end_ifndef

begin_define
define|#
directive|define
name|XML_STATUS_OK
value|1
end_define

begin_define
define|#
directive|define
name|XML_STATUS_ERROR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XML_VERSION_AT_LEAST
end_ifndef

begin_define
define|#
directive|define
name|XML_VERSION_AT_LEAST
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|,
name|patch
parameter_list|)
define|\
value|(((major)< XML_MAJOR_VERSION)                                       \  || ((major) == XML_MAJOR_VERSION&& (minor)< XML_MINOR_VERSION)    \  || ((major) == XML_MAJOR_VERSION&& (minor) == XML_MINOR_VERSION&& \      (patch)<= XML_MICRO_VERSION))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XML_VERSION_AT_LEAST */
end_comment

begin_comment
comment|/* Read/write chunks of this size into the spillbuf.  */
end_comment

begin_define
define|#
directive|define
name|PARSE_CHUNK_SIZE
value|8000
end_define

begin_struct
struct|struct
name|svn_ra_serf__xml_context_t
block|{
comment|/* Current state information.  */
name|svn_ra_serf__xml_estate_t
modifier|*
name|current
decl_stmt|;
comment|/* If WAITING>= then we are waiting for an element to close before      resuming events. The number stored here is the amount of nested      elements open. The Xml parser will make sure the document is well      formed. */
name|int
name|waiting
decl_stmt|;
comment|/* The transition table.  */
specifier|const
name|svn_ra_serf__xml_transition_t
modifier|*
name|ttable
decl_stmt|;
comment|/* The callback information.  */
name|svn_ra_serf__xml_opened_t
name|opened_cb
decl_stmt|;
name|svn_ra_serf__xml_closed_t
name|closed_cb
decl_stmt|;
name|svn_ra_serf__xml_cdata_t
name|cdata_cb
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
comment|/* Linked list of free states.  */
name|svn_ra_serf__xml_estate_t
modifier|*
name|free_states
decl_stmt|;
ifdef|#
directive|ifdef
name|SVN_DEBUG
comment|/* Used to verify we are not re-entering a callback, specifically to      ensure SCRATCH_POOL is not cleared while an outer callback is      trying to use it.  */
name|svn_boolean_t
name|within_callback
decl_stmt|;
define|#
directive|define
name|START_CALLBACK
parameter_list|(
name|xmlctx
parameter_list|)
define|\
value|do {                                                    \     svn_ra_serf__xml_context_t *xmlctx__tmp = (xmlctx);   \     SVN_ERR_ASSERT(!xmlctx__tmp->within_callback);        \     xmlctx__tmp->within_callback = TRUE;                  \   } while (0)
define|#
directive|define
name|END_CALLBACK
parameter_list|(
name|xmlctx
parameter_list|)
value|((xmlctx)->within_callback = FALSE)
else|#
directive|else
define|#
directive|define
name|START_CALLBACK
parameter_list|(
name|xmlctx
parameter_list|)
comment|/* empty */
define|#
directive|define
name|END_CALLBACK
parameter_list|(
name|xmlctx
parameter_list|)
comment|/* empty */
endif|#
directive|endif
comment|/* SVN_DEBUG  */
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure which represents an XML namespace. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|svn_ra_serf__ns_t
block|{
comment|/* The assigned name. */
specifier|const
name|char
modifier|*
name|xmlns
decl_stmt|;
comment|/* The full URL for this namespace. */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
comment|/* The next namespace in our list. */
name|struct
name|svn_ra_serf__ns_t
modifier|*
name|next
decl_stmt|;
block|}
name|svn_ra_serf__ns_t
typedef|;
end_typedef

begin_struct
struct|struct
name|svn_ra_serf__xml_estate_t
block|{
comment|/* The current state value.  */
name|int
name|state
decl_stmt|;
comment|/* The xml tag that opened this state. Waiting for the tag to close.  */
name|svn_ra_serf__dav_props_t
name|tag
decl_stmt|;
comment|/* Should the CLOSED_CB function be called for custom processing when      this tag is closed?  */
name|svn_boolean_t
name|custom_close
decl_stmt|;
comment|/* A pool may be constructed for this state.  */
name|apr_pool_t
modifier|*
name|state_pool
decl_stmt|;
comment|/* The namespaces extent for this state/element. This will start with      the parent's NS_LIST, and we will push new namespaces into our      local list. The parent will be unaffected by our locally-scoped data. */
name|svn_ra_serf__ns_t
modifier|*
name|ns_list
decl_stmt|;
comment|/* Any collected attribute values. char * -> svn_string_t *. May be NULL      if no attributes have been collected.  */
name|apr_hash_t
modifier|*
name|attrs
decl_stmt|;
comment|/* Any collected cdata. May be NULL if no cdata is being collected.  */
name|svn_stringbuf_t
modifier|*
name|cdata
decl_stmt|;
comment|/* Previous/outer state.  */
name|svn_ra_serf__xml_estate_t
modifier|*
name|prev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|expat_ctx_t
block|{
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
name|XML_Parser
name|parser
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
specifier|const
name|int
modifier|*
name|expected_status
decl_stmt|;
name|svn_error_t
modifier|*
name|inner_error
decl_stmt|;
comment|/* Do not use this pool for allocation. It is merely recorded for running      the cleanup handler.  */
name|apr_pool_t
modifier|*
name|cleanup_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|define_namespaces
parameter_list|(
name|svn_ra_serf__ns_t
modifier|*
modifier|*
name|ns_list
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
function_decl|(
modifier|*
name|get_pool
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|tmp_attrs
init|=
name|attrs
decl_stmt|;
for|for
control|(
name|tmp_attrs
operator|=
name|attrs
init|;
operator|*
name|tmp_attrs
operator|!=
name|NULL
condition|;
name|tmp_attrs
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|tmp_attrs
argument_list|,
literal|"xmlns"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|svn_ra_serf__ns_t
modifier|*
name|cur_ns
decl_stmt|;
name|svn_boolean_t
name|found
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* The empty prefix, or a named-prefix.  */
if|if
condition|(
name|tmp_attrs
index|[
literal|0
index|]
index|[
literal|5
index|]
operator|==
literal|':'
condition|)
name|prefix
operator|=
operator|&
name|tmp_attrs
index|[
literal|0
index|]
index|[
literal|6
index|]
expr_stmt|;
else|else
name|prefix
operator|=
literal|""
expr_stmt|;
comment|/* Have we already defined this ns previously? */
for|for
control|(
name|cur_ns
operator|=
operator|*
name|ns_list
init|;
name|cur_ns
condition|;
name|cur_ns
operator|=
name|cur_ns
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cur_ns
operator|->
name|xmlns
argument_list|,
name|prefix
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_ra_serf__ns_t
modifier|*
name|new_ns
decl_stmt|;
if|if
condition|(
name|get_pool
condition|)
name|pool
operator|=
name|get_pool
argument_list|(
name|baton
argument_list|)
expr_stmt|;
else|else
name|pool
operator|=
name|baton
expr_stmt|;
name|new_ns
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_ns
argument_list|)
argument_list|)
expr_stmt|;
name|new_ns
operator|->
name|xmlns
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|new_ns
operator|->
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|tmp_attrs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Push into the front of NS_LIST. Parent states will point                  to later in the chain, so will be unaffected by                  shadowing/other namespaces pushed onto NS_LIST.  */
name|new_ns
operator|->
name|next
operator|=
operator|*
name|ns_list
expr_stmt|;
operator|*
name|ns_list
operator|=
name|new_ns
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Look up @a name in the @a ns_list list for previously declared namespace  * definitions.  *  * Return (in @a *returned_prop_name) a #svn_ra_serf__dav_props_t tuple  * representing the expanded name.  */
end_comment

begin_function
specifier|static
name|void
name|expand_ns
parameter_list|(
name|svn_ra_serf__dav_props_t
modifier|*
name|returned_prop_name
parameter_list|,
specifier|const
name|svn_ra_serf__ns_t
modifier|*
name|ns_list
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|colon
decl_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
specifier|const
name|svn_ra_serf__ns_t
modifier|*
name|ns
decl_stmt|;
for|for
control|(
name|ns
operator|=
name|ns_list
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|ns
operator|->
name|xmlns
argument_list|,
name|name
argument_list|,
name|colon
operator|-
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|returned_prop_name
operator|->
name|xmlns
operator|=
name|ns
operator|->
name|url
expr_stmt|;
name|returned_prop_name
operator|->
name|name
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|svn_ra_serf__ns_t
modifier|*
name|ns
decl_stmt|;
for|for
control|(
name|ns
operator|=
name|ns_list
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ns
operator|->
name|xmlns
index|[
literal|0
index|]
condition|)
block|{
name|returned_prop_name
operator|->
name|xmlns
operator|=
name|ns
operator|->
name|url
expr_stmt|;
name|returned_prop_name
operator|->
name|name
operator|=
name|name
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If the prefix is not found, then the name is NOT within a      namespace.  */
name|returned_prop_name
operator|->
name|xmlns
operator|=
literal|""
expr_stmt|;
name|returned_prop_name
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|XML_HEADER
value|"<?xml version=\"1.0\" encoding=\"utf-8\"?>"
end_define

begin_function
name|void
name|svn_ra_serf__add_xml_header_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
name|XML_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
name|XML_HEADER
argument_list|)
operator|-
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_ra_serf__add_open_tag_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|serf_bucket_t
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"<"
argument_list|,
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|tag
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|tag
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|key
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"=\""
argument_list|,
literal|2
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|val
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"\""
argument_list|,
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|">"
argument_list|,
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_ra_serf__add_empty_tag_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|serf_bucket_t
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"<"
argument_list|,
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|tag
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|tag
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|key
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"=\""
argument_list|,
literal|2
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|val
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"\""
argument_list|,
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"/>"
argument_list|,
literal|2
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_ra_serf__add_close_tag_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"</"
argument_list|,
literal|2
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|tag
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|">"
argument_list|,
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_ra_serf__add_cdata_len_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|data
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|serf_bucket_t
modifier|*
name|tmp_bkt
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find a character which needs to be quoted and append bytes up          to that point.  Strictly speaking, '>' only needs to be          quoted if it follows "]]", but it's easier to quote it all          the time.           So, why are we escaping '\r' here?  Well, according to the          XML spec, '\r\n' gets converted to '\n' during XML parsing.          Also, any '\r' not followed by '\n' is converted to '\n'.  By          golly, if we say we want to escape a '\r', we want to make          sure it remains a '\r'!  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|end
operator|&&
operator|*
name|q
operator|!=
literal|'&'
operator|&&
operator|*
name|q
operator|!=
literal|'<'
operator|&&
operator|*
name|q
operator|!=
literal|'>'
operator|&&
operator|*
name|q
operator|!=
literal|'\r'
condition|)
name|q
operator|++
expr_stmt|;
name|tmp_bkt
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp_bkt
argument_list|)
expr_stmt|;
comment|/* We may already be a winner.  */
if|if
condition|(
name|q
operator|==
name|end
condition|)
break|break;
comment|/* Append the entity reference for the character.  */
if|if
condition|(
operator|*
name|q
operator|==
literal|'&'
condition|)
block|{
name|tmp_bkt
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"&amp;"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"&amp;"
argument_list|)
operator|-
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp_bkt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'<'
condition|)
block|{
name|tmp_bkt
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"&lt;"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"&lt;"
argument_list|)
operator|-
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp_bkt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'>'
condition|)
block|{
name|tmp_bkt
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"&gt;"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"&gt;"
argument_list|)
operator|-
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp_bkt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'\r'
condition|)
block|{
name|tmp_bkt
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"&#13;"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"&#13;"
argument_list|)
operator|-
literal|1
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|agg_bucket
argument_list|,
name|tmp_bkt
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|svn_ra_serf__add_tag_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|)
block|{
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|agg_bucket
argument_list|,
name|bkt_alloc
argument_list|,
name|tag
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|svn_ra_serf__add_cdata_len_buckets
argument_list|(
name|agg_bucket
argument_list|,
name|bkt_alloc
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|agg_bucket
argument_list|,
name|bkt_alloc
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pool for XES to use for self-alloc (and other specifics).  */
end_comment

begin_function
specifier|static
name|apr_pool_t
modifier|*
name|xes_pool
parameter_list|(
specifier|const
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|)
block|{
comment|/* Move up through parent states looking for one with a pool. This      will always terminate since the initial state has a pool.  */
while|while
condition|(
name|xes
operator|->
name|state_pool
operator|==
name|NULL
condition|)
name|xes
operator|=
name|xes
operator|->
name|prev
expr_stmt|;
return|return
name|xes
operator|->
name|state_pool
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ensure_pool
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|)
block|{
if|if
condition|(
name|xes
operator|->
name|state_pool
operator|==
name|NULL
condition|)
name|xes
operator|->
name|state_pool
operator|=
name|svn_pool_create
argument_list|(
name|xes_pool
argument_list|(
name|xes
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This callback is used by define_namespaces() to wait until a pool is    required before constructing it.  */
end_comment

begin_function
specifier|static
name|apr_pool_t
modifier|*
name|lazy_create_pool
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
init|=
name|baton
decl_stmt|;
name|ensure_pool
argument_list|(
name|xes
argument_list|)
expr_stmt|;
return|return
name|xes
operator|->
name|state_pool
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__xml_context_done
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|)
block|{
if|if
condition|(
name|xmlctx
operator|->
name|current
operator|->
name|prev
condition|)
block|{
comment|/* Probably unreachable as this would be an xml parser error */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"XML stream truncated: closing '%s' missing"
argument_list|)
argument_list|,
name|xmlctx
operator|->
name|current
operator|->
name|tag
operator|.
name|name
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xmlctx
operator|->
name|free_states
condition|)
block|{
comment|/* If we have no items on the free_states list, we didn't push anything,          which tells us that we found an empty xml body */
specifier|const
name|svn_ra_serf__xml_transition_t
modifier|*
name|scan
decl_stmt|;
specifier|const
name|svn_ra_serf__xml_transition_t
modifier|*
name|document
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|xmlctx
operator|->
name|ttable
init|;
name|scan
operator|->
name|ns
operator|!=
name|NULL
condition|;
operator|++
name|scan
control|)
block|{
if|if
condition|(
name|scan
operator|->
name|from_state
operator|==
name|XML_STATE_INITIAL
condition|)
block|{
if|if
condition|(
name|document
operator|!=
name|NULL
condition|)
block|{
name|document
operator|=
name|NULL
expr_stmt|;
comment|/* Multiple document elements defined */
break|break;
block|}
name|document
operator|=
name|scan
expr_stmt|;
block|}
block|}
if|if
condition|(
name|document
condition|)
name|msg
operator|=
name|apr_psprintf
argument_list|(
name|xmlctx
operator|->
name|scratch_pool
argument_list|,
literal|"'%s' element not found"
argument_list|,
name|document
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"document element not found"
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"XML stream truncated: %s"
argument_list|)
argument_list|,
name|msg
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|xmlctx
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_ra_serf__xml_context_t
modifier|*
name|svn_ra_serf__xml_context_create
parameter_list|(
specifier|const
name|svn_ra_serf__xml_transition_t
modifier|*
name|ttable
parameter_list|,
name|svn_ra_serf__xml_opened_t
name|opened_cb
parameter_list|,
name|svn_ra_serf__xml_closed_t
name|closed_cb
parameter_list|,
name|svn_ra_serf__xml_cdata_t
name|cdata_cb
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
decl_stmt|;
name|xmlctx
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xmlctx
argument_list|)
argument_list|)
expr_stmt|;
name|xmlctx
operator|->
name|ttable
operator|=
name|ttable
expr_stmt|;
name|xmlctx
operator|->
name|opened_cb
operator|=
name|opened_cb
expr_stmt|;
name|xmlctx
operator|->
name|closed_cb
operator|=
name|closed_cb
expr_stmt|;
name|xmlctx
operator|->
name|cdata_cb
operator|=
name|cdata_cb
expr_stmt|;
name|xmlctx
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
name|xmlctx
operator|->
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|xes
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XES->STATE == 0  */
comment|/* Child states may use this pool to allocate themselves. If a child      needs to collect information, then it will construct a subpool and      will use that to allocate itself and its collected data.  */
name|xes
operator|->
name|state_pool
operator|=
name|result_pool
expr_stmt|;
name|xmlctx
operator|->
name|current
operator|=
name|xes
expr_stmt|;
return|return
name|xmlctx
return|;
block|}
end_function

begin_function
name|apr_hash_t
modifier|*
name|svn_ra_serf__xml_gather_since
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|int
name|stop_state
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|data
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|ensure_pool
argument_list|(
name|xes
argument_list|)
expr_stmt|;
name|pool
operator|=
name|xes
operator|->
name|state_pool
expr_stmt|;
name|data
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|xes
operator|!=
name|NULL
condition|;
name|xes
operator|=
name|xes
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|xes
operator|->
name|attrs
operator|!=
name|NULL
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|xes
operator|->
name|attrs
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
comment|/* Parent name/value lifetimes are at least as long as POOL.  */
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|data
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xes
operator|->
name|state
operator|==
name|stop_state
condition|)
break|break;
block|}
return|return
name|data
return|;
block|}
end_function

begin_function
name|void
name|svn_ra_serf__xml_note
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|int
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|svn_ra_serf__xml_estate_t
modifier|*
name|scan
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|xes
init|;
name|scan
operator|!=
name|NULL
operator|&&
name|scan
operator|->
name|state
operator|!=
name|state
condition|;
name|scan
operator|=
name|scan
operator|->
name|prev
control|)
comment|/* pass */
empty_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|scan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure the target state has a pool.  */
name|ensure_pool
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* ... and attribute storage.  */
if|if
condition|(
name|scan
operator|->
name|attrs
operator|==
name|NULL
condition|)
name|scan
operator|->
name|attrs
operator|=
name|apr_hash_make
argument_list|(
name|scan
operator|->
name|state_pool
argument_list|)
expr_stmt|;
comment|/* In all likelihood, NAME is a string constant. But we can't really      be sure. And it isn't like we're storing a billion of these into      the state pool.  */
name|svn_hash_sets
argument_list|(
name|scan
operator|->
name|attrs
argument_list|,
name|apr_pstrdup
argument_list|(
name|scan
operator|->
name|state_pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|scan
operator|->
name|state_pool
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|apr_pool_t
modifier|*
name|svn_ra_serf__xml_state_pool
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|)
block|{
comment|/* If they asked for a pool, then ensure that we have one to provide.  */
name|ensure_pool
argument_list|(
name|xes
argument_list|)
expr_stmt|;
return|return
name|xes
operator|->
name|state_pool
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|xml_cb_start
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|attrs
parameter_list|)
block|{
name|svn_ra_serf__xml_estate_t
modifier|*
name|current
init|=
name|xmlctx
operator|->
name|current
decl_stmt|;
name|svn_ra_serf__dav_props_t
name|elemname
decl_stmt|;
specifier|const
name|svn_ra_serf__xml_transition_t
modifier|*
name|scan
decl_stmt|;
name|apr_pool_t
modifier|*
name|new_pool
decl_stmt|;
name|svn_ra_serf__xml_estate_t
modifier|*
name|new_xes
decl_stmt|;
comment|/* If we're waiting for an element to close, then just ignore all      other element-opens.  */
if|if
condition|(
name|xmlctx
operator|->
name|waiting
operator|>
literal|0
condition|)
block|{
name|xmlctx
operator|->
name|waiting
operator|++
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Look for xmlns: attributes. Lazily create the state pool if any      were found.  */
name|define_namespaces
argument_list|(
operator|&
name|current
operator|->
name|ns_list
argument_list|,
name|attrs
argument_list|,
name|lazy_create_pool
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|expand_ns
argument_list|(
operator|&
name|elemname
argument_list|,
name|current
operator|->
name|ns_list
argument_list|,
name|raw_name
argument_list|)
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|xmlctx
operator|->
name|ttable
init|;
name|scan
operator|->
name|ns
operator|!=
name|NULL
condition|;
operator|++
name|scan
control|)
block|{
if|if
condition|(
name|scan
operator|->
name|from_state
operator|!=
name|current
operator|->
name|state
condition|)
continue|continue;
comment|/* Wildcard tag match.  */
if|if
condition|(
operator|*
name|scan
operator|->
name|name
operator|==
literal|'*'
condition|)
break|break;
comment|/* Found a specific transition.  */
if|if
condition|(
name|strcmp
argument_list|(
name|elemname
operator|.
name|name
argument_list|,
name|scan
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|elemname
operator|.
name|xmlns
argument_list|,
name|scan
operator|->
name|ns
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|scan
operator|->
name|ns
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|state
operator|==
name|XML_STATE_INITIAL
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_UNEXPECTED_ELEMENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"XML Parsing failed: Unexpected root element '%s'"
argument_list|)
argument_list|,
name|elemname
operator|.
name|name
argument_list|)
return|;
block|}
name|xmlctx
operator|->
name|waiting
operator|++
expr_stmt|;
comment|/* Start waiting for the close tag */
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We should not be told to collect cdata if the closed_cb will not      be called.  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|scan
operator|->
name|collect_cdata
operator|||
name|scan
operator|->
name|custom_close
argument_list|)
expr_stmt|;
comment|/* Found a transition. Make it happen.  */
comment|/* ### todo. push state  */
comment|/* ### how to use free states?  */
comment|/* This state should be allocated in the extent pool. If we will be      collecting information for this state, then construct a subpool.       ### potentially optimize away the subpool if none of the      ### attributes are present. subpools are cheap, tho...  */
name|new_pool
operator|=
name|xes_pool
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|collect_cdata
operator|||
name|scan
operator|->
name|collect_attrs
index|[
literal|0
index|]
condition|)
block|{
name|new_pool
operator|=
name|svn_pool_create
argument_list|(
name|new_pool
argument_list|)
expr_stmt|;
comment|/* Prep the new state.  */
name|new_xes
operator|=
name|apr_pcalloc
argument_list|(
name|new_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_xes
argument_list|)
argument_list|)
expr_stmt|;
name|new_xes
operator|->
name|state_pool
operator|=
name|new_pool
expr_stmt|;
comment|/* If we're supposed to collect cdata, then set up a buffer for          this. The existence of this buffer will instruct our cdata          callback to collect the cdata.  */
if|if
condition|(
name|scan
operator|->
name|collect_cdata
condition|)
name|new_xes
operator|->
name|cdata
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|new_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|collect_attrs
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|saveattr
init|=
operator|&
name|scan
operator|->
name|collect_attrs
index|[
literal|0
index|]
decl_stmt|;
name|new_xes
operator|->
name|attrs
operator|=
name|apr_hash_make
argument_list|(
name|new_pool
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|saveattr
operator|!=
name|NULL
condition|;
operator|++
name|saveattr
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|saveattr
operator|==
literal|'?'
condition|)
block|{
name|name
operator|=
operator|*
name|saveattr
operator|+
literal|1
expr_stmt|;
name|value
operator|=
name|svn_xml_get_attr_value
argument_list|(
name|name
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
operator|*
name|saveattr
expr_stmt|;
name|value
operator|=
name|svn_xml_get_attr_value
argument_list|(
name|name
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_ATTRIB_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing XML attribute '%s' on '%s' element"
argument_list|)
argument_list|,
name|name
argument_list|,
name|scan
operator|->
name|name
argument_list|)
return|;
block|}
if|if
condition|(
name|value
condition|)
name|svn_hash_sets
argument_list|(
name|new_xes
operator|->
name|attrs
argument_list|,
name|name
argument_list|,
name|apr_pstrdup
argument_list|(
name|new_pool
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Prep the new state.  */
name|new_xes
operator|=
name|apr_pcalloc
argument_list|(
name|new_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_xes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* STATE_POOL remains NULL.  */
block|}
comment|/* Some basic copies to set up the new estate.  */
name|new_xes
operator|->
name|state
operator|=
name|scan
operator|->
name|to_state
expr_stmt|;
name|new_xes
operator|->
name|tag
operator|.
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|new_pool
argument_list|,
name|elemname
operator|.
name|name
argument_list|)
expr_stmt|;
name|new_xes
operator|->
name|tag
operator|.
name|xmlns
operator|=
name|apr_pstrdup
argument_list|(
name|new_pool
argument_list|,
name|elemname
operator|.
name|xmlns
argument_list|)
expr_stmt|;
name|new_xes
operator|->
name|custom_close
operator|=
name|scan
operator|->
name|custom_close
expr_stmt|;
comment|/* Start with the parent's namespace set.  */
name|new_xes
operator|->
name|ns_list
operator|=
name|current
operator|->
name|ns_list
expr_stmt|;
comment|/* The new state is prepared. Make it current.  */
name|new_xes
operator|->
name|prev
operator|=
name|current
expr_stmt|;
name|xmlctx
operator|->
name|current
operator|=
name|new_xes
expr_stmt|;
if|if
condition|(
name|xmlctx
operator|->
name|opened_cb
condition|)
block|{
name|START_CALLBACK
argument_list|(
name|xmlctx
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|xmlctx
operator|->
name|opened_cb
argument_list|(
name|new_xes
argument_list|,
name|xmlctx
operator|->
name|baton
argument_list|,
name|new_xes
operator|->
name|state
argument_list|,
operator|&
name|new_xes
operator|->
name|tag
argument_list|,
name|xmlctx
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|END_CALLBACK
argument_list|(
name|xmlctx
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|xmlctx
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|xml_cb_end
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|)
block|{
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
init|=
name|xmlctx
operator|->
name|current
decl_stmt|;
if|if
condition|(
name|xmlctx
operator|->
name|waiting
operator|>
literal|0
condition|)
block|{
name|xmlctx
operator|->
name|waiting
operator|--
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|xes
operator|->
name|custom_close
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|cdata
decl_stmt|;
if|if
condition|(
name|xes
operator|->
name|cdata
condition|)
block|{
name|cdata
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|xes
operator|->
name|cdata
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_DEBUG
comment|/* We might toss the pool holding this structure, but it could also              be within a parent pool. In any case, for safety's sake, disable              the stringbuf against future Badness.  */
name|xes
operator|->
name|cdata
operator|->
name|pool
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|cdata
operator|=
name|NULL
expr_stmt|;
name|START_CALLBACK
argument_list|(
name|xmlctx
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|xmlctx
operator|->
name|closed_cb
argument_list|(
name|xes
argument_list|,
name|xmlctx
operator|->
name|baton
argument_list|,
name|xes
operator|->
name|state
argument_list|,
name|cdata
argument_list|,
name|xes
operator|->
name|attrs
argument_list|,
name|xmlctx
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|END_CALLBACK
argument_list|(
name|xmlctx
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|xmlctx
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Pop the state.  */
name|xmlctx
operator|->
name|current
operator|=
name|xes
operator|->
name|prev
expr_stmt|;
comment|/* ### not everything should go on the free state list. XES may go      ### away with the state pool.  */
name|xes
operator|->
name|prev
operator|=
name|xmlctx
operator|->
name|free_states
expr_stmt|;
name|xmlctx
operator|->
name|free_states
operator|=
name|xes
expr_stmt|;
comment|/* If there is a STATE_POOL, then toss it. This will get rid of as much      memory as possible. Potentially the XES (if we didn't create a pool      right away, then XES may be in a parent pool).  */
if|if
condition|(
name|xes
operator|->
name|state_pool
condition|)
name|svn_pool_destroy
argument_list|(
name|xes
operator|->
name|state_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|xml_cb_cdata
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
comment|/* If we are waiting for a closing tag, then we are uninterested in      the cdata. Just return.  */
if|if
condition|(
name|xmlctx
operator|->
name|waiting
operator|>
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the current state is collecting cdata, then copy the cdata.  */
if|if
condition|(
name|xmlctx
operator|->
name|current
operator|->
name|cdata
operator|!=
name|NULL
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|xmlctx
operator|->
name|current
operator|->
name|cdata
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* ... else if a CDATA_CB has been supplied, then invoke it for      all states.  */
elseif|else
if|if
condition|(
name|xmlctx
operator|->
name|cdata_cb
operator|!=
name|NULL
condition|)
block|{
name|START_CALLBACK
argument_list|(
name|xmlctx
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|xmlctx
operator|->
name|cdata_cb
argument_list|(
name|xmlctx
operator|->
name|current
argument_list|,
name|xmlctx
operator|->
name|baton
argument_list|,
name|xmlctx
operator|->
name|current
operator|->
name|state
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|xmlctx
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|END_CALLBACK
argument_list|(
name|xmlctx
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|xmlctx
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* svn_error_t * wrapper around XML_Parse */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|svn_error_t
modifier|*
name|parse_xml
parameter_list|(
name|struct
name|expat_ctx_t
modifier|*
name|ectx
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_boolean_t
name|is_final
parameter_list|)
block|{
name|int
name|xml_status
init|=
name|XML_Parse
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|data
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|is_final
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|xml_code
decl_stmt|;
if|if
condition|(
name|xml_status
operator|==
name|XML_STATUS_OK
condition|)
return|return
name|ectx
operator|->
name|inner_error
return|;
name|xml_code
operator|=
name|XML_GetErrorCode
argument_list|(
name|ectx
operator|->
name|parser
argument_list|)
expr_stmt|;
if|#
directive|if
name|XML_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|95
operator|,
literal|8
argument_list|)
comment|/* If we called XML_StopParser() expat will return an abort error. If we      have a better error stored we should ignore it as it will not help      the end-user to store it in the error chain. */
if|if
condition|(
name|xml_code
operator|==
name|XML_ERROR_ABORTED
operator|&&
name|ectx
operator|->
name|inner_error
condition|)
return|return
name|ectx
operator|->
name|inner_error
return|;
endif|#
directive|endif
name|msg
operator|=
name|XML_ErrorString
argument_list|(
name|xml_code
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|ectx
operator|->
name|inner_error
argument_list|,
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed XML: %s"
argument_list|)
argument_list|,
name|msg
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"The XML response contains invalid XML"
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Apr pool cleanup handler to release an XML_Parser in success and error    conditions */
end_comment

begin_function
specifier|static
name|apr_status_t
name|xml_parser_cleanup
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|XML_Parser
modifier|*
name|xmlp
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|*
name|xmlp
condition|)
block|{
operator|(
name|void
operator|)
name|XML_ParserFree
argument_list|(
operator|*
name|xmlp
argument_list|)
expr_stmt|;
operator|*
name|xmlp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Conforms to Expat's XML_StartElementHandler  */
end_comment

begin_function
specifier|static
name|void
name|expat_start
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attrs
parameter_list|)
block|{
name|struct
name|expat_ctx_t
modifier|*
name|ectx
init|=
name|userData
decl_stmt|;
if|if
condition|(
name|ectx
operator|->
name|inner_error
operator|!=
name|NULL
condition|)
return|return;
name|ectx
operator|->
name|inner_error
operator|=
name|svn_error_trace
argument_list|(
name|xml_cb_start
argument_list|(
name|ectx
operator|->
name|xmlctx
argument_list|,
name|raw_name
argument_list|,
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|XML_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|95
operator|,
literal|8
argument_list|)
if|if
condition|(
name|ectx
operator|->
name|inner_error
condition|)
operator|(
name|void
operator|)
name|XML_StopParser
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
literal|0
comment|/* resumable */
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Conforms to Expat's XML_EndElementHandler  */
end_comment

begin_function
specifier|static
name|void
name|expat_end
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|)
block|{
name|struct
name|expat_ctx_t
modifier|*
name|ectx
init|=
name|userData
decl_stmt|;
if|if
condition|(
name|ectx
operator|->
name|inner_error
operator|!=
name|NULL
condition|)
return|return;
name|ectx
operator|->
name|inner_error
operator|=
name|svn_error_trace
argument_list|(
name|xml_cb_end
argument_list|(
name|ectx
operator|->
name|xmlctx
argument_list|,
name|raw_name
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|XML_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|95
operator|,
literal|8
argument_list|)
if|if
condition|(
name|ectx
operator|->
name|inner_error
condition|)
operator|(
name|void
operator|)
name|XML_StopParser
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
literal|0
comment|/* resumable */
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Conforms to Expat's XML_CharacterDataHandler  */
end_comment

begin_function
specifier|static
name|void
name|expat_cdata
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|expat_ctx_t
modifier|*
name|ectx
init|=
name|userData
decl_stmt|;
if|if
condition|(
name|ectx
operator|->
name|inner_error
operator|!=
name|NULL
condition|)
return|return;
name|ectx
operator|->
name|inner_error
operator|=
name|svn_error_trace
argument_list|(
name|xml_cb_cdata
argument_list|(
name|ectx
operator|->
name|xmlctx
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|XML_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|95
operator|,
literal|8
argument_list|)
if|if
condition|(
name|ectx
operator|->
name|inner_error
condition|)
operator|(
name|void
operator|)
name|XML_StopParser
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
literal|0
comment|/* resumable */
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|XML_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|95
operator|,
literal|8
argument_list|)
end_if

begin_function
specifier|static
name|void
name|expat_entity_declaration
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|entityName
parameter_list|,
name|int
name|is_parameter_entity
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|value
parameter_list|,
name|int
name|value_length
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|base
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|systemId
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|publicId
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|notationName
parameter_list|)
block|{
name|struct
name|expat_ctx_t
modifier|*
name|ectx
init|=
name|userData
decl_stmt|;
comment|/* Stop the parser if an entity declaration is hit. */
name|XML_StopParser
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
literal|0
comment|/* resumable */
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* A noop default_handler. */
end_comment

begin_function
specifier|static
name|void
name|expat_default_handler
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|expat_response_handler
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|expat_ctx_t
modifier|*
name|ectx
init|=
name|baton
decl_stmt|;
name|svn_boolean_t
name|got_expected_status
decl_stmt|;
if|if
condition|(
name|ectx
operator|->
name|expected_status
condition|)
block|{
specifier|const
name|int
modifier|*
name|status
init|=
name|ectx
operator|->
name|expected_status
decl_stmt|;
name|got_expected_status
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|*
name|status
operator|&&
name|ectx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
operator|*
name|status
condition|)
name|status
operator|++
expr_stmt|;
name|got_expected_status
operator|=
operator|(
operator|*
name|status
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
else|else
name|got_expected_status
operator|=
operator|(
name|ectx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
operator|==
literal|200
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ectx
operator|->
name|handler
operator|->
name|server_error
operator|&&
operator|(
operator|(
name|ectx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
operator|<
literal|200
operator|)
operator|||
operator|(
name|ectx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
operator|>=
literal|300
operator|)
operator|||
operator|!
name|got_expected_status
operator|)
condition|)
block|{
comment|/* By deferring to expect_empty_body(), it will make a choice on          how to handle the body. Whatever the decision, the core handler          will take over, and we will not be called again.  */
comment|/* ### This handles xml bodies as svn-errors (returned via serf context          ### loop), but ignores non-xml errors.           Current code depends on this behavior and checks itself while other          continues, and then verifies if work has been performed.           ### TODO: Make error checking consistent */
comment|/* ### If !GOT_EXPECTED_STATUS, this should always produce an error */
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__expect_empty_body
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|ectx
operator|->
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ectx
operator|->
name|parser
condition|)
block|{
name|ectx
operator|->
name|parser
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|ectx
operator|->
name|cleanup_pool
argument_list|,
operator|&
name|ectx
operator|->
name|parser
argument_list|,
name|xml_parser_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|ectx
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|expat_start
argument_list|,
name|expat_end
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|expat_cdata
argument_list|)
expr_stmt|;
if|#
directive|if
name|XML_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|95
operator|,
literal|8
argument_list|)
name|XML_SetEntityDeclHandler
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|expat_entity_declaration
argument_list|)
expr_stmt|;
else|#
directive|else
name|XML_SetDefaultHandler
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|expat_default_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|at_eof
init|=
name|FALSE
decl_stmt|;
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
name|PARSE_CHUNK_SIZE
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
elseif|else
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
name|at_eof
operator|=
name|TRUE
expr_stmt|;
name|err
operator|=
name|parse_xml
argument_list|(
name|ectx
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|at_eof
comment|/* isFinal */
argument_list|)
expr_stmt|;
if|if
condition|(
name|at_eof
operator|||
name|err
condition|)
block|{
comment|/* Release xml parser state/tables. */
name|apr_pool_cleanup_run
argument_list|(
name|ectx
operator|->
name|cleanup_pool
argument_list|,
operator|&
name|ectx
operator|->
name|parser
argument_list|,
name|xml_parser_cleanup
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* The parsing went fine. What has the bucket told us?  */
if|if
condition|(
name|at_eof
condition|)
block|{
comment|/* Make sure we actually got xml and clean up after parsing */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__xml_context_done
argument_list|(
name|ectx
operator|->
name|xmlctx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&&
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|svn_ra_serf__handler_t
modifier|*
name|svn_ra_serf__create_expat_handler
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
specifier|const
name|int
modifier|*
name|expected_status
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|struct
name|expat_ctx_t
modifier|*
name|ectx
decl_stmt|;
name|ectx
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ectx
argument_list|)
argument_list|)
expr_stmt|;
name|ectx
operator|->
name|xmlctx
operator|=
name|xmlctx
expr_stmt|;
name|ectx
operator|->
name|parser
operator|=
name|NULL
expr_stmt|;
name|ectx
operator|->
name|expected_status
operator|=
name|expected_status
expr_stmt|;
name|ectx
operator|->
name|cleanup_pool
operator|=
name|result_pool
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|session
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|expat_response_handler
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|ectx
expr_stmt|;
name|ectx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
return|return
name|handler
return|;
block|}
end_function

end_unit

