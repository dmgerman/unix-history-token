begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * stat.c :  file and directory stat and read functions  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dav_protocol.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Implements svn_ra__vtable_t.check_path(). */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__check_path
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|url
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
comment|/* If we have a relative path, append it. */
if|if
condition|(
name|relpath
condition|)
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|url
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If we were given a specific revision, get a URL that refers to that      specific revision (rather than floating with HEAD).  */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|url
argument_list|,
name|NULL
comment|/* latest_revnum */
argument_list|,
name|session
argument_list|,
name|url
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* URL is stable, so we use SVN_INVALID_REVNUM since it is now irrelevant.      Or we started with SVN_INVALID_REVNUM and URL may be floating.  */
name|err
operator|=
name|svn_ra_serf__fetch_node_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
argument_list|,
name|url
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|check_path_props
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|kind
operator|=
name|svn_node_none
expr_stmt|;
block|}
else|else
block|{
name|apr_hash_t
modifier|*
name|dav_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|res_type
decl_stmt|;
comment|/* Any other error, raise to caller. */
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|dav_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
literal|"DAV:"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|res_type
operator|=
name|svn_prop_get_value
argument_list|(
name|dav_props
argument_list|,
literal|"resourcetype"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res_type
condition|)
block|{
comment|/* How did this happen? */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_PROPS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include the "
literal|"requested resourcetype value"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|res_type
argument_list|,
literal|"collection"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
operator|*
name|kind
operator|=
name|svn_node_file
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for fill_dirent_propfunc() */
end_comment

begin_struct
struct|struct
name|fill_dirent_baton_t
block|{
comment|/* Update the fields in this entry.  */
name|svn_dirent_t
modifier|*
name|entry
decl_stmt|;
name|svn_tristate_t
modifier|*
name|supports_deadprop_count
decl_stmt|;
comment|/* If allocations are necessary, then use this pool.  */
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_ra_serf__prop_func_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fill_dirent_propfunc
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|fill_dirent_baton_t
modifier|*
name|fdb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_DAV__VERSION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_int64_t
name|rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|rev
argument_list|,
name|val
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|fdb
operator|->
name|entry
operator|->
name|created_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|rev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"creator-displayname"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fdb
operator|->
name|entry
operator|->
name|last_author
operator|=
name|apr_pstrdup
argument_list|(
name|fdb
operator|->
name|result_pool
argument_list|,
name|val
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_DAV__CREATIONDATE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|fdb
operator|->
name|entry
operator|->
name|time
argument_list|,
name|val
operator|->
name|data
argument_list|,
name|fdb
operator|->
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"getcontentlength"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 'getcontentlength' property is empty for directories. */
if|if
condition|(
name|val
operator|->
name|len
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|fdb
operator|->
name|entry
operator|->
name|size
argument_list|,
name|val
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"resourcetype"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|val
operator|->
name|data
argument_list|,
literal|"collection"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fdb
operator|->
name|entry
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
else|else
block|{
name|fdb
operator|->
name|entry
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_CUSTOM
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fdb
operator|->
name|entry
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_SVN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fdb
operator|->
name|entry
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_DAV
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"deadprop-count"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|val
operator|->
name|data
condition|)
block|{
name|apr_int64_t
name|deadprop_count
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|deadprop_count
argument_list|,
name|val
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|fdb
operator|->
name|entry
operator|->
name|has_props
operator|=
name|deadprop_count
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|fdb
operator|->
name|supports_deadprop_count
condition|)
operator|*
name|fdb
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdb
operator|->
name|supports_deadprop_count
condition|)
operator|*
name|fdb
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_false
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|get_dirent_props
parameter_list|(
name|apr_uint32_t
name|dirent_fields
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__dav_props_t
modifier|*
name|prop
decl_stmt|;
name|apr_array_header_t
modifier|*
name|props
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|7
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_ra_serf__dav_props_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|session
operator|->
name|supports_deadprop_count
operator|!=
name|svn_tristate_false
operator|||
operator|!
operator|(
name|dirent_fields
operator|&
name|SVN_DIRENT_HAS_PROPS
operator|)
condition|)
block|{
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_KIND
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|xmlns
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"resourcetype"
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_SIZE
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|xmlns
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"getcontentlength"
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_HAS_PROPS
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|xmlns
operator|=
name|SVN_DAV_PROP_NS_DAV
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"deadprop-count"
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_CREATED_REV
condition|)
block|{
name|svn_ra_serf__dav_props_t
modifier|*
name|p
init|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
decl_stmt|;
name|p
operator|->
name|xmlns
operator|=
literal|"DAV:"
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|SVN_DAV__VERSION_NAME
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_TIME
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|xmlns
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|SVN_DAV__CREATIONDATE
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_LAST_AUTHOR
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|xmlns
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"creator-displayname"
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We found an old subversion server that can't handle          the deadprop-count property in the way we expect.           The neon behavior is to retrieve all properties in this case */
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|xmlns
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"allprop"
expr_stmt|;
block|}
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|xmlns
operator|=
name|NULL
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|svn_ra_serf__dav_props_t
operator|*
operator|)
name|props
operator|->
name|elts
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.stat(). */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__stat
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_dirent_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|struct
name|fill_dirent_baton_t
name|fdb
decl_stmt|;
name|svn_tristate_t
name|deadprop_count
init|=
name|svn_tristate_unknown
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|url
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
comment|/* If we have a relative path, append it. */
if|if
condition|(
name|relpath
condition|)
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|url
argument_list|,
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we were given a specific revision, get a URL that refers to that      specific revision (rather than floating with HEAD).  */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|url
argument_list|,
name|NULL
comment|/* latest_revnum */
argument_list|,
name|session
argument_list|,
name|url
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fdb
operator|.
name|entry
operator|=
name|svn_dirent_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|fdb
operator|.
name|supports_deadprop_count
operator|=
operator|&
name|deadprop_count
expr_stmt|;
name|fdb
operator|.
name|result_pool
operator|=
name|pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|handler
argument_list|,
name|session
argument_list|,
name|url
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|"0"
argument_list|,
name|get_dirent_props
argument_list|(
name|SVN_DIRENT_ALL
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fill_dirent_propfunc
argument_list|,
operator|&
name|fdb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|dirent
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|deadprop_count
operator|==
name|svn_tristate_false
operator|&&
name|session
operator|->
name|supports_deadprop_count
operator|==
name|svn_tristate_unknown
operator|&&
operator|!
name|fdb
operator|.
name|entry
operator|->
name|has_props
condition|)
block|{
comment|/* We have to requery as the server didn't give us the right          information */
name|session
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_false
expr_stmt|;
comment|/* Run the same handler again */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deadprop_count
operator|!=
name|svn_tristate_unknown
condition|)
name|session
operator|->
name|supports_deadprop_count
operator|=
name|deadprop_count
expr_stmt|;
operator|*
name|dirent
operator|=
name|fdb
operator|.
name|entry
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for get_dir_dirents_cb and get_dir_props_cb */
end_comment

begin_struct
struct|struct
name|get_dir_baton_t
block|{
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_t
modifier|*
name|ret_props
decl_stmt|;
name|svn_boolean_t
name|is_directory
decl_stmt|;
name|svn_tristate_t
name|supports_deadprop_count
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_ra_serf__prop_func_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dir_dirents_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|get_dir_baton_t
modifier|*
name|db
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|relpath
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|db
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|relpath
operator|&&
name|relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|fill_dirent_baton_t
name|fdb
decl_stmt|;
name|relpath
operator|=
name|svn_path_uri_decode
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|fdb
operator|.
name|entry
operator|=
name|svn_hash_gets
argument_list|(
name|db
operator|->
name|dirents
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdb
operator|.
name|entry
condition|)
block|{
name|fdb
operator|.
name|entry
operator|=
name|svn_dirent_create
argument_list|(
name|db
operator|->
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|db
operator|->
name|dirents
argument_list|,
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|result_pool
argument_list|,
name|relpath
argument_list|)
argument_list|,
name|fdb
operator|.
name|entry
argument_list|)
expr_stmt|;
block|}
name|fdb
operator|.
name|result_pool
operator|=
name|db
operator|->
name|result_pool
expr_stmt|;
name|fdb
operator|.
name|supports_deadprop_count
operator|=
operator|&
name|db
operator|->
name|supports_deadprop_count
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fill_dirent_propfunc
argument_list|(
operator|&
name|fdb
argument_list|,
name|path
argument_list|,
name|ns
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|relpath
operator|&&
operator|!
name|db
operator|->
name|is_directory
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"resourcetype"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
operator|->
name|data
argument_list|,
literal|"collection"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Tell a lie to exit early */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get properties of non-directory"
argument_list|)
argument_list|)
return|;
block|}
else|else
name|db
operator|->
name|is_directory
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__prop_func */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dir_props_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|get_dir_baton_t
modifier|*
name|db
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
name|propname
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|db
operator|->
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|propname
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|db
operator|->
name|ret_props
argument_list|,
name|propname
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|db
operator|->
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|db
operator|->
name|is_directory
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"resourcetype"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
operator|->
name|data
argument_list|,
literal|"collection"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Tell a lie to exit early */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get properties of non-directory"
argument_list|)
argument_list|)
return|;
block|}
else|else
name|db
operator|->
name|is_directory
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.get_dir(). */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_dir
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|dirents
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|ret_props
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_uint32_t
name|dirent_fields
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|dirent_handler
init|=
name|NULL
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|props_handler
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|get_dir_baton_t
name|gdb
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|gdb
operator|.
name|result_pool
operator|=
name|result_pool
expr_stmt|;
name|gdb
operator|.
name|is_directory
operator|=
name|FALSE
expr_stmt|;
name|gdb
operator|.
name|supports_deadprop_count
operator|=
name|svn_tristate_unknown
expr_stmt|;
name|path
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
comment|/* If we have a relative path, URI encode and append it. */
if|if
condition|(
name|rel_path
condition|)
block|{
name|path
operator|=
name|svn_path_url_add_component2
argument_list|(
name|path
argument_list|,
name|rel_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* If the user specified a peg revision other than HEAD, we have to fetch      the baseline collection url for that revision. If not, we can use the      public url. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
operator|||
name|fetched_rev
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|path
argument_list|,
name|fetched_rev
argument_list|,
name|session
argument_list|,
name|path
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* REVISION is always SVN_INVALID_REVNUM  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|gdb
operator|.
name|path
operator|=
name|path
expr_stmt|;
comment|/* If we're asked for children, fetch them now. */
if|if
condition|(
name|dirents
condition|)
block|{
comment|/* Always request node kind to check that path is really a        * directory. */
if|if
condition|(
operator|!
name|ret_props
condition|)
name|dirent_fields
operator||=
name|SVN_DIRENT_KIND
expr_stmt|;
name|gdb
operator|.
name|dirents
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|dirent_handler
argument_list|,
name|session
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|"1"
argument_list|,
name|get_dirent_props
argument_list|(
name|dirent_fields
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|get_dir_dirents_cb
argument_list|,
operator|&
name|gdb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|dirent_handler
argument_list|)
expr_stmt|;
block|}
else|else
name|gdb
operator|.
name|dirents
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret_props
condition|)
block|{
name|gdb
operator|.
name|ret_props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|props_handler
argument_list|,
name|session
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|"0"
argument_list|,
name|all_props
argument_list|,
name|get_dir_props_cb
argument_list|,
operator|&
name|gdb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|props_handler
argument_list|)
expr_stmt|;
block|}
else|else
name|gdb
operator|.
name|ret_props
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dirent_handler
condition|)
block|{
name|err
operator|=
name|svn_error_trace
argument_list|(
name|svn_ra_serf__context_run_wait
argument_list|(
operator|&
name|dirent_handler
operator|->
name|done
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Unregisters outstanding requests */
return|return
name|err
return|;
block|}
if|if
condition|(
name|gdb
operator|.
name|supports_deadprop_count
operator|==
name|svn_tristate_false
operator|&&
name|session
operator|->
name|supports_deadprop_count
operator|==
name|svn_tristate_unknown
operator|&&
name|dirent_fields
operator|&
name|SVN_DIRENT_HAS_PROPS
condition|)
block|{
comment|/* We have to requery as the server didn't give us the right              information */
name|session
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_false
expr_stmt|;
name|apr_hash_clear
argument_list|(
name|gdb
operator|.
name|dirents
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|dirent_handler
argument_list|,
name|session
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|"1"
argument_list|,
name|get_dirent_props
argument_list|(
name|dirent_fields
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|get_dir_dirents_cb
argument_list|,
operator|&
name|gdb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|dirent_handler
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|props_handler
condition|)
block|{
name|err
operator|=
name|svn_error_trace
argument_list|(
name|svn_ra_serf__context_run_wait
argument_list|(
operator|&
name|props_handler
operator|->
name|done
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* And dirent again for the case when we had to send the request again */
if|if
condition|(
operator|!
name|err
operator|&&
name|dirent_handler
condition|)
block|{
name|err
operator|=
name|svn_error_trace
argument_list|(
name|svn_ra_serf__context_run_wait
argument_list|(
operator|&
name|dirent_handler
operator|->
name|done
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
operator|&&
name|gdb
operator|.
name|supports_deadprop_count
operator|!=
name|svn_tristate_unknown
condition|)
name|session
operator|->
name|supports_deadprop_count
operator|=
name|gdb
operator|.
name|supports_deadprop_count
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Unregisters outstanding requests */
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gdb
operator|.
name|is_directory
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get entries of non-directory"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ret_props
condition|)
operator|*
name|ret_props
operator|=
name|gdb
operator|.
name|ret_props
expr_stmt|;
if|if
condition|(
name|dirents
condition|)
operator|*
name|dirents
operator|=
name|gdb
operator|.
name|dirents
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

