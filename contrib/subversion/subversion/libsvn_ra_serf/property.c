begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * property.c : property routines for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dav_protocol.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Our current parsing state we're in for the PROPFIND response. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|prop_state_e
block|{
name|INITIAL
init|=
name|XML_STATE_INITIAL
block|,
name|MULTISTATUS
block|,
name|RESPONSE
block|,
name|HREF
block|,
name|PROPSTAT
block|,
name|STATUS
block|,
name|PROP
block|,
name|PROPVAL
block|,
name|COLLECTION
block|,
name|HREF_VALUE
block|}
name|prop_state_e
typedef|;
end_typedef

begin_comment
comment|/*  * This structure represents a pending PROPFIND response.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|propfind_context_t
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* the requested path */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* the requested version (in string form) */
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
comment|/* the request depth */
specifier|const
name|char
modifier|*
name|depth
decl_stmt|;
comment|/* the list of requested properties */
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|find_props
decl_stmt|;
name|svn_ra_serf__prop_func_t
name|prop_func
decl_stmt|;
name|void
modifier|*
name|prop_func_baton
decl_stmt|;
comment|/* hash table containing all the properties associated with the    * "current"<propstat> tag.  These will get copied into RET_PROPS    * if the status code similarly associated indicates that they are    * "good"; otherwise, they'll get discarded.    */
name|apr_hash_t
modifier|*
name|ps_props
decl_stmt|;
block|}
name|propfind_context_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|D_
value|"DAV:"
end_define

begin_define
define|#
directive|define
name|S_
value|SVN_XML_NAMESPACE
end_define

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_serf__xml_transition_t
name|propfind_ttable
index|[]
init|=
block|{
block|{
name|INITIAL
block|,
name|D_
block|,
literal|"multistatus"
block|,
name|MULTISTATUS
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|MULTISTATUS
block|,
name|D_
block|,
literal|"response"
block|,
name|RESPONSE
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|RESPONSE
block|,
name|D_
block|,
literal|"href"
block|,
name|HREF
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|RESPONSE
block|,
name|D_
block|,
literal|"propstat"
block|,
name|PROPSTAT
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROPSTAT
block|,
name|D_
block|,
literal|"status"
block|,
name|STATUS
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROPSTAT
block|,
name|D_
block|,
literal|"prop"
block|,
name|PROP
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|PROP
block|,
literal|"*"
block|,
literal|"*"
block|,
name|PROPVAL
block|,
name|TRUE
block|,
block|{
literal|"?V:encoding"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROPVAL
block|,
name|D_
block|,
literal|"collection"
block|,
name|COLLECTION
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROPVAL
block|,
name|D_
block|,
literal|"href"
block|,
name|HREF_VALUE
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|propfind_expected_status
index|[]
init|=
block|{
literal|207
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the HTTP status code contained in STATUS_LINE, or 0 if    there's a problem parsing it. */
end_comment

begin_function
specifier|static
name|apr_int64_t
name|parse_status_code
parameter_list|(
specifier|const
name|char
modifier|*
name|status_line
parameter_list|)
block|{
comment|/* STATUS_LINE should be of form: "HTTP/1.1 200 OK" */
if|if
condition|(
name|status_line
index|[
literal|0
index|]
operator|==
literal|'H'
operator|&&
name|status_line
index|[
literal|1
index|]
operator|==
literal|'T'
operator|&&
name|status_line
index|[
literal|2
index|]
operator|==
literal|'T'
operator|&&
name|status_line
index|[
literal|3
index|]
operator|==
literal|'P'
operator|&&
name|status_line
index|[
literal|4
index|]
operator|==
literal|'/'
operator|&&
operator|(
name|status_line
index|[
literal|5
index|]
operator|>=
literal|'0'
operator|&&
name|status_line
index|[
literal|5
index|]
operator|<=
literal|'9'
operator|)
operator|&&
name|status_line
index|[
literal|6
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|status_line
index|[
literal|7
index|]
operator|>=
literal|'0'
operator|&&
name|status_line
index|[
literal|7
index|]
operator|<=
literal|'9'
operator|)
operator|&&
name|status_line
index|[
literal|8
index|]
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|reason
decl_stmt|;
return|return
name|apr_strtoi64
argument_list|(
name|status_line
operator|+
literal|8
argument_list|,
operator|&
name|reason
argument_list|,
literal|10
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_opened_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|propfind_opened
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|entered_state
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|tag
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|entered_state
operator|==
name|PROPVAL
condition|)
block|{
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPVAL
argument_list|,
literal|"ns"
argument_list|,
name|tag
operator|->
name|xmlns
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPVAL
argument_list|,
literal|"name"
argument_list|,
name|tag
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entered_state
operator|==
name|PROPSTAT
condition|)
block|{
name|ctx
operator|->
name|ps_props
operator|=
name|apr_hash_make
argument_list|(
name|svn_ra_serf__xml_state_pool
argument_list|(
name|xes
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set PROPS for NS:NAME VAL. Helper for propfind_closed */
end_comment

begin_function
specifier|static
name|void
name|set_ns_prop
parameter_list|(
name|apr_hash_t
modifier|*
name|ns_props
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
init|=
name|svn_hash_gets
argument_list|(
name|ns_props
argument_list|,
name|ns
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|props
condition|)
block|{
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|ns
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|ns_props
argument_list|,
name|ns
argument_list|,
name|props
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
condition|)
block|{
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|svn_string_dup
argument_list|(
name|val
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_closed_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|propfind_closed
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|leaving_state
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|cdata
parameter_list|,
name|apr_hash_t
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|leaving_state
operator|==
name|MULTISTATUS
condition|)
block|{
comment|/* We've gathered all the data from the reponse. Add this item          onto the "done list". External callers will then know this          request has been completed (tho stray response bytes may still          arrive).  */
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|HREF
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ctx
operator|->
name|depth
argument_list|,
literal|"1"
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|cdata
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|path
operator|=
name|ctx
operator|->
name|path
expr_stmt|;
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|RESPONSE
argument_list|,
literal|"path"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|prop_func
argument_list|(
name|ctx
operator|->
name|prop_func_baton
argument_list|,
name|path
argument_list|,
name|D_
argument_list|,
literal|"href"
argument_list|,
name|cdata
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|COLLECTION
condition|)
block|{
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPVAL
argument_list|,
literal|"altvalue"
argument_list|,
literal|"collection"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|HREF_VALUE
condition|)
block|{
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPVAL
argument_list|,
literal|"altvalue"
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|STATUS
condition|)
block|{
comment|/* Parse the status field, and remember if this is a property          that we wish to ignore.  (Typically, if it's not a 200, the          status will be 404 to indicate that a property we          specifically requested from the server doesn't exist.)  */
name|apr_int64_t
name|status
init|=
name|parse_status_code
argument_list|(
name|cdata
operator|->
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|200
condition|)
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPSTAT
argument_list|,
literal|"ignore-prop"
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|PROPVAL
condition|)
block|{
specifier|const
name|char
modifier|*
name|encoding
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|val_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|ns
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|altvalue
decl_stmt|;
if|if
condition|(
operator|(
name|altvalue
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"altvalue"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|val_str
operator|=
name|svn_string_create
argument_list|(
name|altvalue
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|encoding
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"V:encoding"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"base64"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Got unrecognized encoding '%s'"
argument_list|)
argument_list|,
name|encoding
argument_list|)
return|;
comment|/* Decode into the right pool.  */
name|val_str
operator|=
name|svn_base64_decode_string
argument_list|(
name|cdata
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy into the right pool.  */
name|val_str
operator|=
name|cdata
expr_stmt|;
block|}
comment|/* The current path sits on the RESPONSE state.           Now, it would be nice if we could, at this point, know that          the status code for this property indicated a problem -- then          we could simply bail out here and ignore the property.          Sadly, though, we might get the status code *after* we get          the property value.  So we'll carry on with our processing          here, setting the property and value as expected.  Once we          know for sure the status code associate with the property,          we'll decide its fate.  */
name|ns
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"ns"
argument_list|)
expr_stmt|;
name|name
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|set_ns_prop
argument_list|(
name|ctx
operator|->
name|ps_props
argument_list|,
name|ns
argument_list|,
name|name
argument_list|,
name|val_str
argument_list|,
name|apr_hash_pool_get
argument_list|(
name|ctx
operator|->
name|ps_props
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_hash_t
modifier|*
name|gathered
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|leaving_state
operator|==
name|PROPSTAT
argument_list|)
expr_stmt|;
name|gathered
operator|=
name|svn_ra_serf__xml_gather_since
argument_list|(
name|xes
argument_list|,
name|RESPONSE
argument_list|)
expr_stmt|;
comment|/* If we've squirreled away a note that says we want to ignore          these properties, we'll do so.  Otherwise, we need to copy          them from the temporary hash into the ctx->ret_props hash. */
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|gathered
argument_list|,
literal|"ignore-prop"
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi_ns
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|path
operator|=
name|svn_hash_gets
argument_list|(
name|gathered
argument_list|,
literal|"path"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
name|ctx
operator|->
name|path
expr_stmt|;
for|for
control|(
name|hi_ns
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|ctx
operator|->
name|ps_props
argument_list|)
init|;
name|hi_ns
condition|;
name|hi_ns
operator|=
name|apr_hash_next
argument_list|(
name|hi_ns
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|ns
init|=
name|apr_hash_this_key
argument_list|(
name|hi_ns
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
init|=
name|apr_hash_this_val
argument_list|(
name|hi_ns
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi_prop
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi_prop
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|props
argument_list|)
init|;
name|hi_prop
condition|;
name|hi_prop
operator|=
name|apr_hash_next
argument_list|(
name|hi_prop
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|apr_hash_this_key
argument_list|(
name|hi_prop
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
init|=
name|apr_hash_this_val
argument_list|(
name|hi_prop
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|prop_func
argument_list|(
name|ctx
operator|->
name|prop_func_baton
argument_list|,
name|path
argument_list|,
name|ns
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|ps_props
operator|=
name|NULL
expr_stmt|;
comment|/* Allocated in PROPSTAT state pool */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_propfind_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|ctx
init|=
name|setup_baton
decl_stmt|;
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Depth"
argument_list|,
name|ctx
operator|->
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|label
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Label"
argument_list|,
name|ctx
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PROPFIND_HEADER
value|"<?xml version=\"1.0\" encoding=\"utf-8\"?><propfind xmlns=\"DAV:\">"
end_define

begin_define
define|#
directive|define
name|PROPFIND_TRAILER
value|"</propfind>"
end_define

begin_comment
comment|/* Implements svn_ra_serf__request_body_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_propfind_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|bkt
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|ctx
init|=
name|setup_baton
decl_stmt|;
name|serf_bucket_t
modifier|*
name|body_bkt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|prop
decl_stmt|;
name|svn_boolean_t
name|requested_allprop
init|=
name|FALSE
decl_stmt|;
name|body_bkt
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|prop
operator|=
name|ctx
operator|->
name|find_props
expr_stmt|;
while|while
condition|(
name|prop
operator|&&
name|prop
operator|->
name|xmlns
condition|)
block|{
comment|/* special case the allprop case. */
if|if
condition|(
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
literal|"allprop"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|requested_allprop
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*<*propname* xmlns="*propns*" /> */
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"<"
argument_list|,
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|" xmlns=\""
argument_list|,
sizeof|sizeof
argument_list|(
literal|" xmlns=\""
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|prop
operator|->
name|xmlns
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"\"/>"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"\"/>"
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|prop
operator|++
expr_stmt|;
block|}
comment|/* If we're not doing an allprop, add<prop> tags. */
if|if
condition|(
operator|!
name|requested_allprop
condition|)
block|{
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"<prop>"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"<prop>"
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_prepend
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
name|PROPFIND_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
name|PROPFIND_HEADER
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_prepend
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|requested_allprop
condition|)
block|{
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"</prop>"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"</prop>"
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
name|PROPFIND_TRAILER
argument_list|,
sizeof|sizeof
argument_list|(
name|PROPFIND_TRAILER
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|bkt
operator|=
name|body_bkt
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__create_propfind_handler
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
modifier|*
name|propfind_handler
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|depth
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|find_props
parameter_list|,
name|svn_ra_serf__prop_func_t
name|prop_func
parameter_list|,
name|void
modifier|*
name|prop_func_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|new_prop_ctx
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
name|new_prop_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_prop_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|new_prop_ctx
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|new_prop_ctx
operator|->
name|find_props
operator|=
name|find_props
expr_stmt|;
name|new_prop_ctx
operator|->
name|prop_func
operator|=
name|prop_func
expr_stmt|;
name|new_prop_ctx
operator|->
name|prop_func_baton
operator|=
name|prop_func_baton
expr_stmt|;
name|new_prop_ctx
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
block|{
name|new_prop_ctx
operator|->
name|label
operator|=
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_prop_ctx
operator|->
name|label
operator|=
name|NULL
expr_stmt|;
block|}
name|xmlctx
operator|=
name|svn_ra_serf__xml_context_create
argument_list|(
name|propfind_ttable
argument_list|,
name|propfind_opened
argument_list|,
name|propfind_closed
argument_list|,
name|NULL
argument_list|,
name|new_prop_ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_expat_handler
argument_list|(
name|sess
argument_list|,
name|xmlctx
argument_list|,
name|propfind_expected_status
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"PROPFIND"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_propfind_body
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/xml"
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|new_prop_ctx
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_propfind_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|new_prop_ctx
expr_stmt|;
name|handler
operator|->
name|no_dav_headers
operator|=
name|TRUE
expr_stmt|;
name|new_prop_ctx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
operator|*
name|propfind_handler
operator|=
name|handler
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__deliver_svn_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|props
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_name
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|prop_name
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Implementation of svn_ra_serf__prop_func_t that delivers all DAV properties  * in (const char * -> apr_hash_t *) on Namespace pointing to a second hash  *    (const char * -> svn_string_t *) to the values.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|deliver_node_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|nss
init|=
name|baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|nss
argument_list|)
decl_stmt|;
name|props
operator|=
name|svn_hash_gets
argument_list|(
name|nss
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|props
condition|)
block|{
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|ns
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|nss
argument_list|,
name|ns
argument_list|,
name|props
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|name
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__fetch_node_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|results
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|which_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|handler
argument_list|,
name|session
argument_list|,
name|url
argument_list|,
name|revision
argument_list|,
literal|"0"
argument_list|,
name|which_props
argument_list|,
name|deliver_node_props
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|results
operator|=
name|props
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_ra_serf__svnname_from_wirename
parameter_list|(
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ns
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_CUSTOM
argument_list|)
operator|==
literal|0
condition|)
return|return
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_SVN
argument_list|)
operator|==
literal|0
condition|)
return|return
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|name
argument_list|,
name|SVN_VA_NULL
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_PROP_PREFIX
argument_list|)
operator|==
literal|0
condition|)
return|return
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|name
argument_list|,
name|SVN_VA_NULL
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_DAV__VERSION_NAME
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_COMMITTED_REV
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_DAV__CREATIONDATE
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_COMMITTED_DATE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"creator-displayname"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_LAST_AUTHOR
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"repository-uuid"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_UUID
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"lock-token"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_LOCK_TOKEN
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"checked-in"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_RA_SERF__WC_CHECKED_IN_URL
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_DAV
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Here DAV: properties not yet converted to svn: properties should be          ignored. */
return|return
name|NULL
return|;
block|}
comment|/* An unknown namespace, must be a custom property. */
return|return
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|ns
argument_list|,
name|name
argument_list|,
name|SVN_VA_NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Contact the server (using CONN) to calculate baseline  * information for BASELINE_URL at REVISION (which may be  * SVN_INVALID_REVNUM to query the HEAD revision).  *  * If ACTUAL_REVISION is non-NULL, set *ACTUAL_REVISION to revision  * retrieved from the server as part of this process (which should  * match REVISION when REVISION is valid).  Set *BASECOLL_URL_P to the  * baseline collection URL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|retrieve_baseline_info
parameter_list|(
name|svn_revnum_t
modifier|*
name|actual_revision
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|basecoll_url_p
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|baseline_url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_hash_t
modifier|*
name|dav_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|basecoll_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_node_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
argument_list|,
name|baseline_url
argument_list|,
name|revision
argument_list|,
name|baseline_props
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|dav_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
literal|"DAV:"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If DAV_PROPS is NULL, then svn_prop_get_value() will return NULL.  */
name|basecoll_url
operator|=
name|svn_prop_get_value
argument_list|(
name|dav_props
argument_list|,
literal|"baseline-collection"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basecoll_url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_PROPS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include "
literal|"the requested baseline-collection value"
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|basecoll_url_p
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|basecoll_url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_revision
condition|)
block|{
specifier|const
name|char
modifier|*
name|version_name
decl_stmt|;
name|version_name
operator|=
name|svn_prop_get_value
argument_list|(
name|dav_props
argument_list|,
name|SVN_DAV__VERSION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|version_name
condition|)
block|{
name|apr_int64_t
name|rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|rev
argument_list|,
name|version_name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|actual_revision
operator|=
operator|(
name|svn_revnum_t
operator|)
name|rev
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|version_name
operator|||
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|actual_revision
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_PROPS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include "
literal|"the requested version-name value"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For HTTPv1 servers, do a PROPFIND dance on the VCC to fetch the youngest    revnum. If BASECOLL_URL is non-NULL, then the corresponding baseline    collection URL is also returned.     Do the work over CONN.     *BASECOLL_URL (if requested) will be allocated in RESULT_POOL. All    temporary allocations will be made in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|v1_get_youngest_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|basecoll_url
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|vcc_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|baseline_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|bc_url
decl_stmt|;
comment|/* Fetching DAV:checked-in from the VCC (with no Label: to specify a      revision) will return the latest Baseline resource's URL.  */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_dav_prop
argument_list|(
operator|&
name|baseline_url
argument_list|,
name|session
argument_list|,
name|vcc_url
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|"checked-in"
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|baseline_url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The OPTIONS response did not include "
literal|"the requested checked-in value"
argument_list|)
argument_list|)
return|;
block|}
name|baseline_url
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|baseline_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* From the Baseline resource, we can fetch the DAV:baseline-collection      and DAV:version-name properties. The latter is the revision number,      which is formally the name used in Label: headers.  */
comment|/* First check baseline information cache. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_get_baseline_info
argument_list|(
operator|&
name|bc_url
argument_list|,
name|youngest
argument_list|,
name|session
operator|->
name|blncache
argument_list|,
name|baseline_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bc_url
condition|)
block|{
name|SVN_ERR
argument_list|(
name|retrieve_baseline_info
argument_list|(
name|youngest
argument_list|,
operator|&
name|bc_url
argument_list|,
name|session
argument_list|,
name|baseline_url
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_set
argument_list|(
name|session
operator|->
name|blncache
argument_list|,
name|baseline_url
argument_list|,
operator|*
name|youngest
argument_list|,
name|bc_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basecoll_url
operator|!=
name|NULL
condition|)
operator|*
name|basecoll_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|bc_url
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_youngest_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__v2_get_youngest_revnum
argument_list|(
name|youngest
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|v1_get_youngest_revnum
argument_list|(
name|youngest
argument_list|,
name|NULL
argument_list|,
name|session
argument_list|,
name|vcc_url
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *BC_URL to the baseline collection url for REVISION. If REVISION    is SVN_INVALID_REVNUM, then the youngest revnum ("HEAD") is used.     *REVNUM_USED will be set to the revision used.     Uses the specified CONN, which is part of SESSION.     All allocations (results and temporary) are performed in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_baseline_info
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|bc_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|revnum_used
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* If we detected HTTP v2 support on the server, we can construct      the baseline collection URL ourselves, and fetch the latest      revision (if needed) with an OPTIONS request.  */
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
operator|*
name|revnum_used
operator|=
name|revision
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__v2_get_youngest_revnum
argument_list|(
name|revnum_used
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|bc_url
operator|=
name|apr_psprintf
argument_list|(
name|result_pool
argument_list|,
literal|"%s/%ld"
argument_list|,
name|session
operator|->
name|rev_root_stub
argument_list|,
operator|*
name|revnum_used
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we fall back to the old VCC_URL PROPFIND hunt.  */
else|else
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
comment|/* First check baseline information cache. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_get_bc_url
argument_list|(
name|bc_url
argument_list|,
name|session
operator|->
name|blncache
argument_list|,
name|revision
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bc_url
condition|)
block|{
name|SVN_ERR
argument_list|(
name|retrieve_baseline_info
argument_list|(
name|NULL
argument_list|,
name|bc_url
argument_list|,
name|session
argument_list|,
name|vcc_url
argument_list|,
name|revision
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_set
argument_list|(
name|session
operator|->
name|blncache
argument_list|,
name|NULL
argument_list|,
name|revision
argument_list|,
operator|*
name|bc_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|revnum_used
operator|=
name|revision
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|v1_get_youngest_revnum
argument_list|(
name|revnum_used
argument_list|,
name|bc_url
argument_list|,
name|session
argument_list|,
name|vcc_url
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_stable_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|stable_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|latest_revnum
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|basecoll_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_revnum_t
name|revnum_used
decl_stmt|;
comment|/* No URL? No sweat. We'll use the session URL.  */
if|if
condition|(
operator|!
name|url
condition|)
name|url
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_baseline_info
argument_list|(
operator|&
name|basecoll_url
argument_list|,
operator|&
name|revnum_used
argument_list|,
name|session
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_relative_path
argument_list|(
operator|&
name|repos_relpath
argument_list|,
name|url
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stable_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|basecoll_url
argument_list|,
name|repos_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|latest_revnum
condition|)
operator|*
name|latest_revnum
operator|=
name|revnum_used
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__fetch_dav_prop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_hash_t
modifier|*
name|dav_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_node_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
argument_list|,
name|url
argument_list|,
name|revision
argument_list|,
name|checked_in_props
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|dav_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
literal|"DAV:"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|dav_props
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_PROPS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include "
literal|"the requested 'DAV:' properties"
argument_list|)
argument_list|)
return|;
comment|/* We wouldn't get here if the resource was not found (404), so the      property should be present.       Note: it is okay to call apr_pstrdup() with NULL.  */
operator|*
name|value
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|svn_prop_get_value
argument_list|(
name|dav_props
argument_list|,
name|propname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Removes all non regular properties from PROPS */
end_comment

begin_function
name|void
name|svn_ra_serf__keep_only_regular_props
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_property_kind2
argument_list|(
name|propname
argument_list|)
operator|!=
name|svn_prop_regular_kind
condition|)
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

