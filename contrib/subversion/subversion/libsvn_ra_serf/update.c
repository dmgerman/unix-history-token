begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * update.c :  entry point for update RA functions for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_version.h>
end_include

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * This enum represents the current state of our XML parsing for a REPORT.  *  * A little explanation of how the parsing works.  Every time we see  * an open-directory tag, we enter the OPEN_DIR state.  Likewise, for  * add-directory, open-file, etc.  When we see the closing variant of the  * open-directory tag, we'll 'pop' out of that state.  *  * Each state has a pool associated with it that can have temporary  * allocations that will live as long as the tag is opened.  Once  * the tag is 'closed', the pool will be reused.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|report_state_e
block|{
name|INITIAL
init|=
name|XML_STATE_INITIAL
comment|/* = 0 */
block|,
name|UPDATE_REPORT
block|,
name|TARGET_REVISION
block|,
name|OPEN_DIR
block|,
name|ADD_DIR
block|,
name|OPEN_FILE
block|,
name|ADD_FILE
block|,
name|DELETE_ENTRY
block|,
name|ABSENT_DIR
block|,
name|ABSENT_FILE
block|,
name|SET_PROP
block|,
name|REMOVE_PROP
block|,
name|PROP
block|,
name|FETCH_FILE
block|,
name|FETCH_PROPS
block|,
name|TXDELTA
block|,
name|CHECKED_IN
block|,
name|CHECKED_IN_HREF
block|,
name|MD5_CHECKSUM
block|,
name|VERSION_NAME
block|,
name|CREATIONDATE
block|,
name|CREATOR_DISPLAYNAME
block|}
name|report_state_e
typedef|;
end_typedef

begin_define
define|#
directive|define
name|D_
value|"DAV:"
end_define

begin_define
define|#
directive|define
name|S_
value|SVN_XML_NAMESPACE
end_define

begin_define
define|#
directive|define
name|V_
value|SVN_DAV_PROP_NS_DAV
end_define

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_serf__xml_transition_t
name|update_ttable
index|[]
init|=
block|{
block|{
name|INITIAL
block|,
name|S_
block|,
literal|"update-report"
block|,
name|UPDATE_REPORT
block|,
name|FALSE
block|,
block|{
literal|"?inline-props"
block|,
literal|"?send-all"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|UPDATE_REPORT
block|,
name|S_
block|,
literal|"target-revision"
block|,
name|TARGET_REVISION
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|UPDATE_REPORT
block|,
name|S_
block|,
literal|"open-directory"
block|,
name|OPEN_DIR
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"open-directory"
block|,
name|OPEN_DIR
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"open-directory"
block|,
name|OPEN_DIR
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"add-directory"
block|,
name|ADD_DIR
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
comment|/*"?bc-url",*/
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"add-directory"
block|,
name|ADD_DIR
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
comment|/*"?bc-url",*/
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"open-file"
block|,
name|OPEN_FILE
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"open-file"
block|,
name|OPEN_FILE
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"add-file"
block|,
name|ADD_FILE
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
literal|"?sha1-checksum"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"add-file"
block|,
name|ADD_FILE
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
literal|"?sha1-checksum"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"delete-entry"
block|,
name|DELETE_ENTRY
block|,
name|FALSE
block|,
block|{
literal|"?rev"
block|,
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"delete-entry"
block|,
name|DELETE_ENTRY
block|,
name|FALSE
block|,
block|{
literal|"?rev"
block|,
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"absent-directory"
block|,
name|ABSENT_DIR
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"absent-directory"
block|,
name|ABSENT_DIR
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"absent-file"
block|,
name|ABSENT_FILE
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"absent-file"
block|,
name|ABSENT_FILE
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|D_
block|,
literal|"checked-in"
block|,
name|CHECKED_IN
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|D_
block|,
literal|"checked-in"
block|,
name|CHECKED_IN
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|OPEN_FILE
block|,
name|D_
block|,
literal|"checked-in"
block|,
name|CHECKED_IN
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|ADD_FILE
block|,
name|D_
block|,
literal|"checked-in"
block|,
name|CHECKED_IN
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"set-prop"
block|,
name|SET_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
literal|"?encoding"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"set-prop"
block|,
name|SET_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
literal|"?encoding"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_FILE
block|,
name|S_
block|,
literal|"set-prop"
block|,
name|SET_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
literal|"?encoding"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_FILE
block|,
name|S_
block|,
literal|"set-prop"
block|,
name|SET_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
literal|"?encoding"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"remove-prop"
block|,
name|REMOVE_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"remove-prop"
block|,
name|REMOVE_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_FILE
block|,
name|S_
block|,
literal|"remove-prop"
block|,
name|REMOVE_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_FILE
block|,
name|S_
block|,
literal|"remove-prop"
block|,
name|REMOVE_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_FILE
block|,
name|S_
block|,
literal|"prop"
block|,
name|PROP
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"prop"
block|,
name|PROP
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|ADD_FILE
block|,
name|S_
block|,
literal|"prop"
block|,
name|PROP
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"prop"
block|,
name|PROP
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|OPEN_FILE
block|,
name|S_
block|,
literal|"txdelta"
block|,
name|TXDELTA
block|,
name|FALSE
block|,
block|{
literal|"?base-checksum"
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_FILE
block|,
name|S_
block|,
literal|"txdelta"
block|,
name|TXDELTA
block|,
name|FALSE
block|,
block|{
literal|"?base-checksum"
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_FILE
block|,
name|S_
block|,
literal|"fetch-file"
block|,
name|FETCH_FILE
block|,
name|FALSE
block|,
block|{
literal|"?base-checksum"
block|,
literal|"?sha1-checksum"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_FILE
block|,
name|S_
block|,
literal|"fetch-file"
block|,
name|FETCH_FILE
block|,
name|FALSE
block|,
block|{
literal|"?base-checksum"
block|,
literal|"?sha1-checksum"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|CHECKED_IN
block|,
name|D_
block|,
literal|"href"
block|,
name|CHECKED_IN_HREF
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROP
block|,
name|V_
block|,
literal|"md5-checksum"
block|,
name|MD5_CHECKSUM
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
comment|/* These are only reported for<= 1.6.x mod_dav_svn */
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"fetch-props"
block|,
name|FETCH_PROPS
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|OPEN_FILE
block|,
name|S_
block|,
literal|"fetch-props"
block|,
name|FETCH_PROPS
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|PROP
block|,
name|D_
block|,
literal|"version-name"
block|,
name|VERSION_NAME
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROP
block|,
name|D_
block|,
literal|"creationdate"
block|,
name|CREATIONDATE
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROP
block|,
name|D_
block|,
literal|"creator-displayname"
block|,
name|CREATOR_DISPLAYNAME
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While we process the REPORT response, we will queue up GET and PROPFIND    requests. For a very large checkout, it is very easy to queue requests    faster than they are resolved. Thus, we need to pause the XML processing    (which queues more requests) to avoid queueing too many, with their    attendant memory costs. When the queue count drops low enough, we will    resume XML processing.     Note that we don't want the count to drop to zero. We have multiple    connections that we want to keep busy. These are also heuristic numbers    since network and parsing behavior (ie. it doesn't pause immediately)    can make the measurements quite imprecise.     We measure outstanding requests as the sum of NUM_ACTIVE_FETCHES and    NUM_ACTIVE_PROPFINDS in the report_context_t structure.  */
end_comment

begin_define
define|#
directive|define
name|REQUEST_COUNT_TO_PAUSE
value|50
end_define

begin_define
define|#
directive|define
name|REQUEST_COUNT_TO_RESUME
value|40
end_define

begin_define
define|#
directive|define
name|SPILLBUF_BLOCKSIZE
value|4096
end_define

begin_define
define|#
directive|define
name|SPILLBUF_MAXBUFFSIZE
value|131072
end_define

begin_define
define|#
directive|define
name|PARSE_CHUNK_SIZE
value|8000
end_define

begin_comment
comment|/* Copied from xml.c ### Needs tuning */
end_comment

begin_comment
comment|/* Forward-declare our report context. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|report_context_t
name|report_context_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|body_create_baton_t
name|body_create_baton_t
typedef|;
end_typedef

begin_comment
comment|/*  * This structure represents the information for a directory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dir_baton_t
block|{
name|struct
name|dir_baton_t
modifier|*
name|parent_dir
decl_stmt|;
comment|/* NULL when root */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Subpool for this directory */
comment|/* Pointer back to our original report context. */
name|report_context_t
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
comment|/* session relative path */
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
comment|/* Name of item "" for root */
comment|/* the canonical url for this directory after updating. (received) */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
comment|/* The original repos_relpath of this url (via the reporter)   directly, or via an ancestor. */
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_revnum_t
name|base_rev
decl_stmt|;
comment|/* base revision or NULL for Add */
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
comment|/* NULL for open */
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* SVN_INVALID_REVNUM for open */
comment|/* controlling dir baton - this is only created in ensure_dir_opened() */
name|svn_boolean_t
name|dir_opened
decl_stmt|;
name|void
modifier|*
name|dir_baton
decl_stmt|;
comment|/* How many references to this directory do we still have open? */
name|apr_size_t
name|ref_count
decl_stmt|;
name|svn_boolean_t
name|fetch_props
decl_stmt|;
comment|/* Use PROPFIND request? */
name|svn_ra_serf__handler_t
modifier|*
name|propfind_handler
decl_stmt|;
name|apr_hash_t
modifier|*
name|remove_props
decl_stmt|;
block|}
name|dir_baton_t
typedef|;
end_typedef

begin_comment
comment|/* * This structure represents the information for a file. * * This structure is created as we parse the REPORT response and * once the element is completed, we may create a fetch_ctx_t structure * to give to serf to retrieve this file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|file_baton_t
block|{
name|dir_baton_t
modifier|*
name|parent_dir
decl_stmt|;
comment|/* The parent */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Subpool for this file*/
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
comment|/* session relative path */
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
comment|/* the canonical url for this directory after updating. (received) */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
comment|/* The original repos_relpath of this url as reported. */
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
comment|/* lock token, if we had one to start off with. */
specifier|const
name|char
modifier|*
name|lock_token
decl_stmt|;
name|svn_revnum_t
name|base_rev
decl_stmt|;
comment|/* SVN_INVALID_REVNUM for Add */
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
comment|/* NULL for open */
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* SVN_INVALID_REVNUM for open */
comment|/* controlling dir baton - this is only created in ensure_file_opened() */
name|svn_boolean_t
name|file_opened
decl_stmt|;
name|void
modifier|*
name|file_baton
decl_stmt|;
name|svn_boolean_t
name|fetch_props
decl_stmt|;
comment|/* Use PROPFIND request? */
name|svn_ra_serf__handler_t
modifier|*
name|propfind_handler
decl_stmt|;
name|svn_boolean_t
name|found_lock_prop
decl_stmt|;
name|apr_hash_t
modifier|*
name|remove_props
decl_stmt|;
comment|/* Has the server told us to go fetch - only valid if we had it already */
name|svn_boolean_t
name|fetch_file
decl_stmt|;
comment|/* controlling file_baton and textdelta handler */
name|svn_txdelta_window_handler_t
name|txdelta
decl_stmt|;
name|void
modifier|*
name|txdelta_baton
decl_stmt|;
name|svn_checksum_t
modifier|*
name|base_md5_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|final_md5_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|final_sha1_checksum
decl_stmt|;
name|svn_stream_t
modifier|*
name|txdelta_stream
decl_stmt|;
comment|/* Stream that feeds windows when                                            written to within txdelta*/
block|}
name|file_baton_t
typedef|;
end_typedef

begin_comment
comment|/*  * This structure represents a single request to GET (fetch) a file with  * its associated Serf session/connection.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fetch_ctx_t
block|{
comment|/* The handler representing this particular fetch.  */
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_boolean_t
name|using_compression
decl_stmt|;
comment|/* Stores the information for the file we want to fetch. */
name|file_baton_t
modifier|*
name|file
decl_stmt|;
comment|/* Have we read our response headers yet? */
name|svn_boolean_t
name|read_headers
decl_stmt|;
comment|/* This flag is set when our response is aborted before we reach the    * end and we decide to requeue this request.    */
name|svn_boolean_t
name|aborted_read
decl_stmt|;
name|apr_off_t
name|aborted_read_size
decl_stmt|;
comment|/* This is the amount of data that we have read so far. */
name|apr_off_t
name|read_size
decl_stmt|;
comment|/* If we're writing this file to a stream, this will be non-NULL. */
name|svn_stream_t
modifier|*
name|result_stream
decl_stmt|;
comment|/* The base-rev header  */
specifier|const
name|char
modifier|*
name|delta_base
decl_stmt|;
block|}
name|fetch_ctx_t
typedef|;
end_typedef

begin_comment
comment|/*  * The master structure for a REPORT request and response.  */
end_comment

begin_struct
struct|struct
name|report_context_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|sess
decl_stmt|;
comment|/* Source path and destination path */
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
specifier|const
name|char
modifier|*
name|destination
decl_stmt|;
comment|/* Our update target. */
specifier|const
name|char
modifier|*
name|update_target
decl_stmt|;
comment|/* What is the target revision that we want for this REPORT? */
name|svn_revnum_t
name|target_rev
decl_stmt|;
comment|/* Where are we (used while parsing) */
name|dir_baton_t
modifier|*
name|cur_dir
decl_stmt|;
name|file_baton_t
modifier|*
name|cur_file
decl_stmt|;
comment|/* Have we been asked to ignore ancestry or textdeltas? */
name|svn_boolean_t
name|ignore_ancestry
decl_stmt|;
name|svn_boolean_t
name|text_deltas
decl_stmt|;
comment|/* Do we want the server to send copyfrom args or not? */
name|svn_boolean_t
name|send_copyfrom_args
decl_stmt|;
comment|/* Is the server sending everything in one response? */
name|svn_boolean_t
name|send_all_mode
decl_stmt|;
comment|/* Is the server including properties inline for newly added      files/dirs? */
name|svn_boolean_t
name|add_props_included
decl_stmt|;
comment|/* Path -> const char *repos_relpath mapping */
name|apr_hash_t
modifier|*
name|switched_paths
decl_stmt|;
comment|/* Our master update editor and baton. */
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|editor_baton
decl_stmt|;
comment|/* The file holding request body for the REPORT.    *    * ### todo: It will be better for performance to store small    * request bodies (like 4k) in memory and bigger bodies on disk.    */
name|svn_stream_t
modifier|*
name|body_template
decl_stmt|;
name|body_create_baton_t
modifier|*
name|body
decl_stmt|;
comment|/* number of pending GET requests */
name|unsigned
name|int
name|num_active_fetches
decl_stmt|;
comment|/* number of pending PROPFIND requests */
name|unsigned
name|int
name|num_active_propfinds
decl_stmt|;
comment|/* Are we done parsing the REPORT response? */
name|svn_boolean_t
name|done
decl_stmt|;
comment|/* Did we receive all data from the network? */
name|svn_boolean_t
name|report_received
decl_stmt|;
comment|/* Did we close the root directory? */
name|svn_boolean_t
name|closed_root
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Baton for collecting REPORT body. Depending on the size this    work is backed by a memory buffer (via serf buckets) or by    a file */
end_comment

begin_struct
struct|struct
name|body_create_baton_t
block|{
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
name|apr_size_t
name|total_bytes
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
name|serf_bucket_alloc_t
modifier|*
name|alloc
decl_stmt|;
name|serf_bucket_t
modifier|*
name|collect_bucket
decl_stmt|;
specifier|const
name|void
modifier|*
name|all_data
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_BODY_IN_RAM
value|(256*1024)
end_define

begin_comment
comment|/* Fold all previously collected data in a single buffer allocated in    RESULT_POOL and clear all intermediate state */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|body_allocate_all
parameter_list|(
name|body_create_baton_t
modifier|*
name|body
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|char
modifier|*
name|buffer
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
name|body
operator|->
name|total_bytes
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|sz
decl_stmt|;
name|apr_status_t
name|s
decl_stmt|;
name|apr_size_t
name|remaining
init|=
name|body
operator|->
name|total_bytes
decl_stmt|;
name|char
modifier|*
name|next
init|=
name|buffer
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|s
operator|=
name|serf_bucket_read
argument_list|(
name|body
operator|->
name|collect_bucket
argument_list|,
name|remaining
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|next
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|sz
expr_stmt|;
name|next
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
operator|!
name|remaining
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|next
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
name|serf_bucket_destroy
argument_list|(
name|body
operator|->
name|collect_bucket
argument_list|)
expr_stmt|;
name|body
operator|->
name|collect_bucket
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|s
operator|!=
name|APR_EOF
operator|)
condition|?
name|NULL
else|:
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Noop function. Make serf take care of freeing in error situations */
end_comment

begin_function
specifier|static
name|void
name|serf_free_no_error
parameter_list|(
name|void
modifier|*
name|unfreed_baton
parameter_list|,
name|void
modifier|*
name|block
parameter_list|)
block|{}
end_function

begin_comment
comment|/* Stream write function for body creation */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|body_write_fn
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|body_create_baton_t
modifier|*
name|bcb
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|bcb
operator|->
name|scratch_pool
condition|)
name|bcb
operator|->
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|bcb
operator|->
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcb
operator|->
name|file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|bcb
operator|->
name|file
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|,
name|NULL
argument_list|,
name|bcb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|bcb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|bcb
operator|->
name|total_bytes
operator|+=
operator|*
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|len
operator|+
name|bcb
operator|->
name|total_bytes
operator|>
name|MAX_BODY_IN_RAM
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|bcb
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|bcb
operator|->
name|result_pool
argument_list|,
name|bcb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcb
operator|->
name|total_bytes
condition|)
block|{
specifier|const
name|char
modifier|*
name|all
init|=
name|body_allocate_all
argument_list|(
name|bcb
argument_list|,
name|bcb
operator|->
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|bcb
operator|->
name|file
argument_list|,
name|all
argument_list|,
name|bcb
operator|->
name|total_bytes
argument_list|,
name|NULL
argument_list|,
name|bcb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|bcb
operator|->
name|file
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|,
name|NULL
argument_list|,
name|bcb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|bcb
operator|->
name|total_bytes
operator|+=
operator|*
name|len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bcb
operator|->
name|alloc
condition|)
name|bcb
operator|->
name|alloc
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|bcb
operator|->
name|scratch_pool
argument_list|,
name|serf_free_no_error
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bcb
operator|->
name|collect_bucket
condition|)
name|bcb
operator|->
name|collect_bucket
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|bcb
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|bcb
operator|->
name|collect_bucket
argument_list|,
name|serf_bucket_simple_copy_create
argument_list|(
name|data
argument_list|,
operator|*
name|len
argument_list|,
name|bcb
operator|->
name|alloc
argument_list|)
argument_list|)
expr_stmt|;
name|bcb
operator|->
name|total_bytes
operator|+=
operator|*
name|len
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Stream close function for collecting body */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|body_done_fn
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|body_create_baton_t
modifier|*
name|bcb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|bcb
operator|->
name|file
condition|)
block|{
comment|/* We need to flush the file, make it unbuffered (so that it can be         * zero-copied via mmap), and reset the position before attempting         * to deliver the file.         *         * N.B. If we have APR 1.3+, we can unbuffer the file to let us use         * mmap and zero-copy the PUT body.  However, on older APR versions,         * we can't check the buffer status; but serf will fall through and         * create a file bucket for us on the buffered handle.         */
name|SVN_ERR
argument_list|(
name|svn_io_file_flush
argument_list|(
name|bcb
operator|->
name|file
argument_list|,
name|bcb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_file_buffer_set
argument_list|(
name|bcb
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcb
operator|->
name|collect_bucket
condition|)
name|bcb
operator|->
name|all_data
operator|=
name|body_allocate_all
argument_list|(
name|bcb
argument_list|,
name|bcb
operator|->
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcb
operator|->
name|scratch_pool
condition|)
name|svn_pool_destroy
argument_list|(
name|bcb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_dir_baton
parameter_list|(
name|dir_baton_t
modifier|*
modifier|*
name|new_dir
parameter_list|,
name|report_context_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_baton_t
modifier|*
name|parent
init|=
name|ctx
operator|->
name|cur_dir
decl_stmt|;
name|apr_pool_t
modifier|*
name|dir_pool
decl_stmt|;
name|dir_baton_t
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
name|parent
condition|)
name|dir_pool
operator|=
name|svn_pool_create
argument_list|(
name|parent
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
name|dir_pool
operator|=
name|svn_pool_create
argument_list|(
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
name|dir
operator|=
name|apr_pcalloc
argument_list|(
name|dir_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|pool
operator|=
name|dir_pool
expr_stmt|;
name|dir
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|dir
operator|->
name|parent_dir
operator|=
name|parent
expr_stmt|;
name|parent
operator|->
name|ref_count
operator|++
expr_stmt|;
block|}
name|dir
operator|->
name|relpath
operator|=
name|parent
condition|?
name|svn_relpath_join
argument_list|(
name|parent
operator|->
name|relpath
argument_list|,
name|name
argument_list|,
name|dir_pool
argument_list|)
else|:
name|apr_pstrdup
argument_list|(
name|dir_pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dir
operator|->
name|base_name
operator|=
name|svn_relpath_basename
argument_list|(
name|dir
operator|->
name|relpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dir
operator|->
name|repos_relpath
operator|=
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|switched_paths
argument_list|,
name|dir
operator|->
name|relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
operator|->
name|repos_relpath
condition|)
block|{
if|if
condition|(
name|parent
condition|)
name|dir
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|parent
operator|->
name|repos_relpath
argument_list|,
name|name
argument_list|,
name|dir_pool
argument_list|)
expr_stmt|;
else|else
name|dir
operator|->
name|repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|repos_root_str
argument_list|,
name|ctx
operator|->
name|sess
operator|->
name|session_url_str
argument_list|,
name|dir_pool
argument_list|)
expr_stmt|;
block|}
name|dir
operator|->
name|base_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|dir
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|dir
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|cur_dir
operator|=
name|dir
expr_stmt|;
operator|*
name|new_dir
operator|=
name|dir
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_file_baton
parameter_list|(
name|file_baton_t
modifier|*
modifier|*
name|new_file
parameter_list|,
name|report_context_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_baton_t
modifier|*
name|parent
init|=
name|ctx
operator|->
name|cur_dir
decl_stmt|;
name|apr_pool_t
modifier|*
name|file_pool
decl_stmt|;
name|file_baton_t
modifier|*
name|file
decl_stmt|;
name|file_pool
operator|=
name|svn_pool_create
argument_list|(
name|parent
operator|->
name|pool
argument_list|)
expr_stmt|;
name|file
operator|=
name|apr_pcalloc
argument_list|(
name|file_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|pool
operator|=
name|file_pool
expr_stmt|;
name|file
operator|->
name|parent_dir
operator|=
name|parent
expr_stmt|;
name|parent
operator|->
name|ref_count
operator|++
expr_stmt|;
name|file
operator|->
name|relpath
operator|=
name|svn_relpath_join
argument_list|(
name|parent
operator|->
name|relpath
argument_list|,
name|name
argument_list|,
name|file_pool
argument_list|)
expr_stmt|;
name|file
operator|->
name|base_name
operator|=
name|svn_relpath_basename
argument_list|(
name|file
operator|->
name|relpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|file
operator|->
name|repos_relpath
operator|=
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|switched_paths
argument_list|,
name|file
operator|->
name|relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|repos_relpath
condition|)
name|file
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|parent
operator|->
name|repos_relpath
argument_list|,
name|name
argument_list|,
name|file_pool
argument_list|)
expr_stmt|;
comment|/* Sane defaults */
name|file
operator|->
name|base_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|file
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
operator|*
name|new_file
operator|=
name|file
expr_stmt|;
name|ctx
operator|->
name|cur_file
operator|=
name|file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/** Minimum nr. of outstanding requests needed before a new connection is  *  opened. */
end_comment

begin_define
define|#
directive|define
name|REQS_PER_CONN
value|8
end_define

begin_comment
comment|/** This function creates a new connection for this serf session, but only  * if the number of NUM_ACTIVE_REQS> REQS_PER_CONN or if there currently is  * only one main connection open.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_connection_if_needed
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|int
name|num_active_reqs
parameter_list|)
block|{
comment|/* For each REQS_PER_CONN outstanding requests open a new connection, with    * a minimum of 1 extra connection. */
if|if
condition|(
name|sess
operator|->
name|num_conns
operator|==
literal|1
operator|||
operator|(
operator|(
name|num_active_reqs
operator|/
name|REQS_PER_CONN
operator|)
operator|>
name|sess
operator|->
name|num_conns
operator|)
condition|)
block|{
name|int
name|cur
init|=
name|sess
operator|->
name|num_conns
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|sess
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sess
operator|->
name|conns
index|[
name|cur
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|->
name|bkt_alloc
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|sess
operator|->
name|pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|->
name|last_status_code
operator|=
operator|-
literal|1
expr_stmt|;
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|->
name|session
operator|=
name|sess
expr_stmt|;
name|status
operator|=
name|serf_connection_create2
argument_list|(
operator|&
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|->
name|conn
argument_list|,
name|sess
operator|->
name|context
argument_list|,
name|sess
operator|->
name|session_url
argument_list|,
name|svn_ra_serf__conn_setup
argument_list|,
name|sess
operator|->
name|conns
index|[
name|cur
index|]
argument_list|,
name|svn_ra_serf__conn_closed
argument_list|,
name|sess
operator|->
name|conns
index|[
name|cur
index|]
argument_list|,
name|sess
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
name|sess
operator|->
name|num_conns
operator|++
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Returns best connection for fetching files/properties. */
end_comment

begin_function
specifier|static
name|svn_ra_serf__connection_t
modifier|*
name|get_best_connection
parameter_list|(
name|report_context_t
modifier|*
name|ctx
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
name|int
name|first_conn
init|=
literal|1
decl_stmt|;
comment|/* Skip the first connection if the REPORT response hasn't been completely      received yet or if we're being told to limit our connections to      2 (because this could be an attempt to ensure that we do all our      auxiliary GETs/PROPFINDs on a single connection).       ### FIXME: This latter requirement (max_connections> 2) is      ### really just a hack to work around the fact that some update      ### editor implementations (such as svnrdump's dump editor)      ### simply can't handle the way ra_serf violates the editor v1      ### drive ordering requirements.      ###      ### See http://subversion.tigris.org/issues/show_bug.cgi?id=4116.   */
if|if
condition|(
name|ctx
operator|->
name|report_received
operator|&&
operator|(
name|ctx
operator|->
name|sess
operator|->
name|max_connections
operator|>
literal|2
operator|)
condition|)
name|first_conn
operator|=
literal|0
expr_stmt|;
comment|/* If there's only one available auxiliary connection to use, don't bother      doing all the cur_conn math -- just return that one connection.  */
if|if
condition|(
name|ctx
operator|->
name|sess
operator|->
name|num_conns
operator|-
name|first_conn
operator|==
literal|1
condition|)
block|{
name|conn
operator|=
name|ctx
operator|->
name|sess
operator|->
name|conns
index|[
name|first_conn
index|]
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|SERF_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|4
operator|,
literal|0
argument_list|)
comment|/* Often one connection is slower than others, e.g. because the server          process/thread has to do more work for the particular set of requests.          In the worst case, when REQUEST_COUNT_TO_RESUME requests are queued          on such a slow connection, ra_serf will completely stop sending          requests.           The method used here selects the connection with the least amount of          pending requests, thereby giving more work to lightly loaded server          processes.        */
name|int
name|i
decl_stmt|,
name|best_conn
init|=
name|first_conn
decl_stmt|;
name|unsigned
name|int
name|min
init|=
name|INT_MAX
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_conn
init|;
name|i
operator|<
name|ctx
operator|->
name|sess
operator|->
name|num_conns
condition|;
name|i
operator|++
control|)
block|{
name|serf_connection_t
modifier|*
name|sc
init|=
name|ctx
operator|->
name|sess
operator|->
name|conns
index|[
name|i
index|]
operator|->
name|conn
decl_stmt|;
name|unsigned
name|int
name|pending
init|=
name|serf_connection_pending_requests
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|pending
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|pending
expr_stmt|;
name|best_conn
operator|=
name|i
expr_stmt|;
block|}
block|}
name|conn
operator|=
name|ctx
operator|->
name|sess
operator|->
name|conns
index|[
name|best_conn
index|]
expr_stmt|;
else|#
directive|else
comment|/* We don't know how many requests are pending per connection, so just        cycle them. */
name|conn
operator|=
name|ctx
operator|->
name|sess
operator|->
name|conns
index|[
name|ctx
operator|->
name|sess
operator|->
name|cur_conn
index|]
expr_stmt|;
name|ctx
operator|->
name|sess
operator|->
name|cur_conn
operator|++
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|sess
operator|->
name|cur_conn
operator|>=
name|ctx
operator|->
name|sess
operator|->
name|num_conns
condition|)
name|ctx
operator|->
name|sess
operator|->
name|cur_conn
operator|=
name|first_conn
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|conn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Helpers to open and close directories */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_dir_opened
parameter_list|(
name|dir_baton_t
modifier|*
name|dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|dir
operator|->
name|ctx
decl_stmt|;
if|if
condition|(
name|dir
operator|->
name|dir_opened
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|dir
operator|->
name|base_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|destination
operator|&&
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|invalidate_wc_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|invalidate_wc_props
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callback_baton
argument_list|,
name|ctx
operator|->
name|update_target
argument_list|,
name|SVN_RA_SERF__WC_CHECKED_IN_URL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|open_root
argument_list|(
name|ctx
operator|->
name|editor_baton
argument_list|,
name|dir
operator|->
name|base_rev
argument_list|,
name|dir
operator|->
name|pool
argument_list|,
operator|&
name|dir
operator|->
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|dir
operator|->
name|parent_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|dir
operator|->
name|base_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|open_directory
argument_list|(
name|dir
operator|->
name|relpath
argument_list|,
name|dir
operator|->
name|parent_dir
operator|->
name|dir_baton
argument_list|,
name|dir
operator|->
name|base_rev
argument_list|,
name|dir
operator|->
name|pool
argument_list|,
operator|&
name|dir
operator|->
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|add_directory
argument_list|(
name|dir
operator|->
name|relpath
argument_list|,
name|dir
operator|->
name|parent_dir
operator|->
name|dir_baton
argument_list|,
name|dir
operator|->
name|copyfrom_path
argument_list|,
name|dir
operator|->
name|copyfrom_rev
argument_list|,
name|dir
operator|->
name|pool
argument_list|,
operator|&
name|dir
operator|->
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dir
operator|->
name|dir_opened
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_close_dir
parameter_list|(
name|dir_baton_t
modifier|*
name|dir
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|dir
operator|->
name|pool
decl_stmt|;
name|dir_baton_t
modifier|*
name|parent
init|=
name|dir
operator|->
name|parent_dir
decl_stmt|;
name|report_context_t
modifier|*
name|ctx
init|=
name|dir
operator|->
name|ctx
decl_stmt|;
if|if
condition|(
operator|--
name|dir
operator|->
name|ref_count
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|dir
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|remove_props
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|dir
operator|->
name|remove_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|dir
operator|->
name|dir_baton
argument_list|,
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
argument_list|,
name|NULL
comment|/* value */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|dir
operator|->
name|ctx
operator|->
name|editor
operator|->
name|close_directory
argument_list|(
name|dir
operator|->
name|dir_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|dir
operator|->
name|pool
comment|/* scratch_pool */
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
return|return
name|svn_error_trace
argument_list|(
name|maybe_close_dir
argument_list|(
name|parent
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_file_opened
parameter_list|(
name|file_baton_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|file
operator|->
name|parent_dir
operator|->
name|ctx
operator|->
name|editor
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|file_opened
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Ensure our parent is open. */
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|file
operator|->
name|parent_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open (or add) the file. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|file
operator|->
name|base_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_file
argument_list|(
name|file
operator|->
name|relpath
argument_list|,
name|file
operator|->
name|parent_dir
operator|->
name|dir_baton
argument_list|,
name|file
operator|->
name|base_rev
argument_list|,
name|file
operator|->
name|pool
argument_list|,
operator|&
name|file
operator|->
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_file
argument_list|(
name|file
operator|->
name|relpath
argument_list|,
name|file
operator|->
name|parent_dir
operator|->
name|dir_baton
argument_list|,
name|file
operator|->
name|copyfrom_path
argument_list|,
name|file
operator|->
name|copyfrom_rev
argument_list|,
name|file
operator|->
name|pool
argument_list|,
operator|&
name|file
operator|->
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|file
operator|->
name|file_opened
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Routines called when we are fetching a file */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|headers_fetch
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fetch_ctx_t
modifier|*
name|fetch_ctx
init|=
name|baton
decl_stmt|;
comment|/* note that we have old VC URL */
if|if
condition|(
name|fetch_ctx
operator|->
name|delta_base
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_DELTA_BASE_HEADER
argument_list|,
name|fetch_ctx
operator|->
name|delta_base
argument_list|)
expr_stmt|;
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Accept-Encoding"
argument_list|,
literal|"svndiff1;q=0.9,svndiff;q=0.8"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fetch_ctx
operator|->
name|using_compression
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Accept-Encoding"
argument_list|,
literal|"gzip"
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cancel_fetch
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|int
name|status_code
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|fetch_ctx_t
modifier|*
name|fetch_ctx
init|=
name|baton
decl_stmt|;
comment|/* Uh-oh.  Our connection died on us.    *    * The core ra_serf layer will requeue our request - we just need to note    * that we got cut off in the middle of our song.    */
if|if
condition|(
operator|!
name|response
condition|)
block|{
comment|/* If we already started the fetch and opened the file handle, we need        * to hold subsequent read() ops until we get back to where we were        * before the close and we can then resume the textdelta() calls.        */
if|if
condition|(
name|fetch_ctx
operator|->
name|read_headers
condition|)
block|{
if|if
condition|(
operator|!
name|fetch_ctx
operator|->
name|aborted_read
operator|&&
name|fetch_ctx
operator|->
name|read_size
condition|)
block|{
name|fetch_ctx
operator|->
name|aborted_read
operator|=
name|TRUE
expr_stmt|;
name|fetch_ctx
operator|->
name|aborted_read_size
operator|=
name|fetch_ctx
operator|->
name|read_size
expr_stmt|;
block|}
name|fetch_ctx
operator|->
name|read_size
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We have no idea what went wrong. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wield the editor referenced by INFO to open (or add) the file    file also associated with INFO, setting properties on the file and    calling the editor's apply_textdelta() function on it if necessary    (or if FORCE_APPLY_TEXTDELTA is set).     Callers will probably want to also see the function that serves    the opposite purpose of this one, close_updated_file().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file_txdelta
parameter_list|(
name|file_baton_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|file
operator|->
name|parent_dir
operator|->
name|ctx
operator|->
name|editor
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|file
operator|->
name|txdelta
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_file_opened
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get (maybe) a textdelta window handler for transmitting file      content changes. */
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|file
operator|->
name|file_baton
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|file
operator|->
name|base_md5_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|file
operator|->
name|pool
argument_list|,
operator|&
name|file
operator|->
name|txdelta
argument_list|,
operator|&
name|file
operator|->
name|txdelta_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Close the file, handling loose ends and cleanup */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|file_baton_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_baton_t
modifier|*
name|parent_dir
init|=
name|file
operator|->
name|parent_dir
decl_stmt|;
name|report_context_t
modifier|*
name|ctx
init|=
name|parent_dir
operator|->
name|ctx
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_file_opened
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set all of the properties we received */
if|if
condition|(
name|file
operator|->
name|remove_props
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|file
operator|->
name|remove_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file
operator|->
name|file_baton
argument_list|,
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
argument_list|,
name|NULL
comment|/* value */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for lock information. */
comment|/* This works around a bug in some older versions of mod_dav_svn in that it    * will not send remove-prop in the update report when a lock property    * disappears when send-all is false.     ### Given that we only fetch props on additions, is this really necessary?        Or is it covering up old local copy bugs where we copied locks to other        paths? */
if|if
condition|(
operator|!
name|ctx
operator|->
name|add_props_included
operator|&&
name|file
operator|->
name|lock_token
operator|&&
operator|!
name|file
operator|->
name|found_lock_prop
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|file
operator|->
name|base_rev
argument_list|)
comment|/* file_is_added */
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file
operator|->
name|file_baton
argument_list|,
name|SVN_PROP_ENTRY_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|->
name|url
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file
operator|->
name|file_baton
argument_list|,
name|SVN_RA_SERF__WC_CHECKED_IN_URL
argument_list|,
name|svn_string_create
argument_list|(
name|file
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Close the file via the editor. */
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|close_file
argument_list|(
name|file
operator|->
name|file_baton
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|file
operator|->
name|final_md5_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|file
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|maybe_close_dir
argument_list|(
name|parent_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove reference */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_fetch
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|fetch_ctx_t
modifier|*
name|fetch_ctx
init|=
name|handler_baton
decl_stmt|;
name|file_baton_t
modifier|*
name|file
init|=
name|fetch_ctx
operator|->
name|file
decl_stmt|;
comment|/* ### new field. make sure we didn't miss some initialization.  */
name|SVN_ERR_ASSERT
argument_list|(
name|fetch_ctx
operator|->
name|handler
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fetch_ctx
operator|->
name|read_headers
condition|)
block|{
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
comment|/* If the error code wasn't 200, something went wrong. Don't use the        * returned data as its probably an error message. Just bail out instead.        */
if|if
condition|(
name|fetch_ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|200
condition|)
block|{
name|fetch_ctx
operator|->
name|handler
operator|->
name|discard_body
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* Will return an error in the DONE handler */
block|}
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Content-Type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|svn_cstring_casecmp
argument_list|(
name|val
argument_list|,
name|SVN_SVNDIFF_MIME_TYPE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fetch_ctx
operator|->
name|result_stream
operator|=
name|svn_txdelta_parse_svndiff
argument_list|(
name|file
operator|->
name|txdelta
argument_list|,
name|file
operator|->
name|txdelta_baton
argument_list|,
name|TRUE
argument_list|,
name|file
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Validate the delta base claimed by the server matches              what we asked for! */
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
name|SVN_DAV_DELTA_BASE_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|fetch_ctx
operator|->
name|delta_base
operator|==
name|NULL
condition|)
block|{
comment|/* We recieved response with delta base header while we didn't                  requested it -- report it as error. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"GET request returned unexpected "
literal|"delta base: %s"
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|val
operator|&&
operator|(
name|strcmp
argument_list|(
name|val
argument_list|,
name|fetch_ctx
operator|->
name|delta_base
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"GET request returned unexpected "
literal|"delta base: %s"
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|fetch_ctx
operator|->
name|result_stream
operator|=
name|NULL
expr_stmt|;
block|}
name|fetch_ctx
operator|->
name|read_headers
operator|=
name|TRUE
expr_stmt|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
name|svn_txdelta_window_t
name|delta_window
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_txdelta_op_t
name|delta_op
decl_stmt|;
name|svn_string_t
name|window_data
decl_stmt|;
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
literal|8000
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|fetch_ctx
operator|->
name|read_size
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|fetch_ctx
operator|->
name|aborted_read
condition|)
block|{
name|apr_off_t
name|skip
decl_stmt|;
comment|/* We haven't caught up to where we were before. */
if|if
condition|(
name|fetch_ctx
operator|->
name|read_size
operator|<
name|fetch_ctx
operator|->
name|aborted_read_size
condition|)
block|{
comment|/* Eek.  What did the file shrink or something? */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
comment|/* Skip on to the next iteration of this loop. */
if|if
condition|(
name|status
comment|/* includes EAGAIN */
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
continue|continue;
block|}
comment|/* Woo-hoo.  We're back. */
name|fetch_ctx
operator|->
name|aborted_read
operator|=
name|FALSE
expr_stmt|;
comment|/* Update data and len to just provide the new data. */
name|skip
operator|=
name|len
operator|-
operator|(
name|fetch_ctx
operator|->
name|read_size
operator|-
name|fetch_ctx
operator|->
name|aborted_read_size
operator|)
expr_stmt|;
name|data
operator|+=
name|skip
expr_stmt|;
name|len
operator|-=
operator|(
name|apr_size_t
operator|)
name|skip
expr_stmt|;
block|}
if|if
condition|(
name|fetch_ctx
operator|->
name|result_stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|fetch_ctx
operator|->
name|result_stream
argument_list|,
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* otherwise, manually construct the text delta window. */
elseif|else
if|if
condition|(
name|len
condition|)
block|{
name|window_data
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|window_data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|delta_op
operator|.
name|action_code
operator|=
name|svn_txdelta_new
expr_stmt|;
name|delta_op
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|delta_op
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|delta_window
operator|.
name|tview_len
operator|=
name|len
expr_stmt|;
name|delta_window
operator|.
name|num_ops
operator|=
literal|1
expr_stmt|;
name|delta_window
operator|.
name|ops
operator|=
operator|&
name|delta_op
expr_stmt|;
name|delta_window
operator|.
name|new_data
operator|=
operator|&
name|window_data
expr_stmt|;
comment|/* write to the file located in the info. */
name|SVN_ERR
argument_list|(
name|file
operator|->
name|txdelta
argument_list|(
operator|&
name|delta_window
argument_list|,
name|file
operator|->
name|txdelta_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|fetch_ctx
operator|->
name|result_stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fetch_ctx
operator|->
name|result_stream
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|file
operator|->
name|txdelta
argument_list|(
name|NULL
argument_list|,
name|file
operator|->
name|txdelta_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Report EOF, EEAGAIN and other special errors to serf */
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------- */
end_comment

begin_comment
comment|/** Wrappers around our various property walkers **/
end_comment

begin_comment
comment|/* Implements svn_ra_serf__prop_func */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_file_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|file_baton_t
modifier|*
name|file
init|=
name|baton
decl_stmt|;
name|report_context_t
modifier|*
name|ctx
init|=
name|file
operator|->
name|parent_dir
operator|->
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_name
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_name
condition|)
block|{
comment|/* This works around a bug in some older versions of        * mod_dav_svn in that it will not send remove-prop in the update        * report when a lock property disappears when send-all is false.        *        * Therefore, we'll try to look at our properties and see if there's        * an active lock.  If not, then we'll assume there isn't a lock        * anymore.        */
comment|/* assert(!ctx->add_props_included); // Or we wouldn't be here */
if|if
condition|(
name|file
operator|->
name|lock_token
operator|&&
operator|!
name|file
operator|->
name|found_lock_prop
operator|&&
name|val
operator|&&
name|strcmp
argument_list|(
name|ns
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"lockdiscovery"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|new_lock
decl_stmt|;
name|new_lock
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|val
operator|->
name|data
argument_list|)
expr_stmt|;
name|apr_collapse_spaces
argument_list|(
name|new_lock
argument_list|,
name|new_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_lock
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|file
operator|->
name|found_lock_prop
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|ensure_file_opened
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file
operator|->
name|file_baton
argument_list|,
name|prop_name
argument_list|,
name|val
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_done_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_props_done
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|file_baton_t
modifier|*
name|file
init|=
name|baton
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|file
operator|->
name|propfind_handler
decl_stmt|;
if|if
condition|(
name|handler
operator|->
name|server_error
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__server_error_create
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|207
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
name|file
operator|->
name|parent_dir
operator|->
name|ctx
operator|->
name|num_active_propfinds
operator|--
expr_stmt|;
name|file
operator|->
name|fetch_props
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|fetch_file
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Still processing file request */
comment|/* Closing the file will automatically deliver the propfind props.    *    * Note that closing the directory may dispose the pool containing the    * handler, which is only a valid operation in this callback, as only    * after this callback our serf plumbing assumes the request is done. */
return|return
name|svn_error_trace
argument_list|(
name|close_file
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_fetch_done
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fetch_ctx_t
modifier|*
name|fetch_ctx
init|=
name|baton
decl_stmt|;
name|file_baton_t
modifier|*
name|file
init|=
name|fetch_ctx
operator|->
name|file
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|fetch_ctx
operator|->
name|handler
decl_stmt|;
if|if
condition|(
name|handler
operator|->
name|server_error
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__server_error_create
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|200
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
name|file
operator|->
name|parent_dir
operator|->
name|ctx
operator|->
name|num_active_fetches
operator|--
expr_stmt|;
name|file
operator|->
name|fetch_file
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|fetch_props
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Still processing PROPFIND request */
comment|/* Closing the file will automatically deliver the propfind props.    *    * Note that closing the directory may dispose the pool containing the    * handler, fetch_ctx, etc. which is only a valid operation in this    * callback, as only after this callback our serf plumbing assumes the    * request is done. */
return|return
name|svn_error_trace
argument_list|(
name|close_file
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initiates additional requests needed for a file when not in "send-all" mode.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_for_file
parameter_list|(
name|file_baton_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|file
operator|->
name|parent_dir
operator|->
name|ctx
decl_stmt|;
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* Open extra connections if we have enough requests to send. */
if|if
condition|(
name|ctx
operator|->
name|sess
operator|->
name|num_conns
operator|<
name|ctx
operator|->
name|sess
operator|->
name|max_connections
condition|)
name|SVN_ERR
argument_list|(
name|open_connection_if_needed
argument_list|(
name|ctx
operator|->
name|sess
argument_list|,
name|ctx
operator|->
name|num_active_fetches
operator|+
name|ctx
operator|->
name|num_active_propfinds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* What connection should we go on? */
name|conn
operator|=
name|get_best_connection
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Note that we (still) use conn for both requests.. Should we send      them out on different connections? */
if|if
condition|(
name|file
operator|->
name|fetch_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|open_file_txdelta
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|text_deltas
operator|||
name|file
operator|->
name|txdelta
operator|==
name|svn_delta_noop_window_handler
condition|)
block|{
name|SVN_ERR
argument_list|(
name|file
operator|->
name|txdelta
argument_list|(
name|NULL
argument_list|,
name|file
operator|->
name|txdelta_baton
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|fetch_file
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|->
name|fetch_file
operator|&&
name|file
operator|->
name|final_sha1_checksum
operator|&&
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stream_t
modifier|*
name|cached_contents
init|=
name|NULL
decl_stmt|;
name|err
operator|=
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callback_baton
argument_list|,
operator|&
name|cached_contents
argument_list|,
name|file
operator|->
name|final_sha1_checksum
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|!
name|cached_contents
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* ### Can we return some/most errors? */
else|else
block|{
comment|/* ### For debugging purposes we could validate the md5 here,                      but our implementations in libsvn_client already do that                      for us... */
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_stream
argument_list|(
name|cached_contents
argument_list|,
name|file
operator|->
name|txdelta
argument_list|,
name|file
operator|->
name|txdelta_baton
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|cached_contents
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|fetch_file
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|file
operator|->
name|fetch_file
condition|)
block|{
name|fetch_ctx_t
modifier|*
name|fetch_ctx
decl_stmt|;
comment|/* Let's fetch the file with a GET request... */
name|SVN_ERR_ASSERT
argument_list|(
name|file
operator|->
name|url
operator|&&
name|file
operator|->
name|repos_relpath
argument_list|)
expr_stmt|;
comment|/* Otherwise, we use a GET request for the file's contents. */
name|fetch_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|file
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fetch_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|fetch_ctx
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|fetch_ctx
operator|->
name|using_compression
operator|=
name|ctx
operator|->
name|sess
operator|->
name|using_compression
expr_stmt|;
comment|/* Can we somehow get away with just obtaining a DIFF? */
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|ctx
operator|->
name|sess
argument_list|)
condition|)
block|{
comment|/* If this file is switched vs the editor root we should provide                  its real url instead of the one calculated from the session root.               */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|file
operator|->
name|base_rev
argument_list|)
condition|)
block|{
name|fetch_ctx
operator|->
name|delta_base
operator|=
name|apr_psprintf
argument_list|(
name|file
operator|->
name|pool
argument_list|,
literal|"%s/%ld/%s"
argument_list|,
name|ctx
operator|->
name|sess
operator|->
name|rev_root_stub
argument_list|,
name|file
operator|->
name|base_rev
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|file
operator|->
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|file
operator|->
name|copyfrom_path
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|file
operator|->
name|copyfrom_rev
argument_list|)
argument_list|)
expr_stmt|;
name|fetch_ctx
operator|->
name|delta_base
operator|=
name|apr_psprintf
argument_list|(
name|file
operator|->
name|pool
argument_list|,
literal|"%s/%ld/%s"
argument_list|,
name|ctx
operator|->
name|sess
operator|->
name|rev_root_stub
argument_list|,
name|file
operator|->
name|copyfrom_rev
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|file
operator|->
name|copyfrom_path
operator|+
literal|1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|get_wc_prop
condition|)
block|{
comment|/* If we have a WC, we might be able to dive all the way into the WC               * to get the previous URL so we can do a differential GET with the               * base URL.               */
specifier|const
name|svn_string_t
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|get_wc_prop
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callback_baton
argument_list|,
name|file
operator|->
name|relpath
argument_list|,
name|SVN_RA_SERF__WC_CHECKED_IN_URL
argument_list|,
operator|&
name|value
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fetch_ctx
operator|->
name|delta_base
operator|=
name|value
condition|?
name|apr_pstrdup
argument_list|(
name|file
operator|->
name|pool
argument_list|,
name|value
operator|->
name|data
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|ctx
operator|->
name|sess
argument_list|,
name|file
operator|->
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"GET"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|file
operator|->
name|url
expr_stmt|;
name|handler
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
comment|/* Explicit scheduling */
name|handler
operator|->
name|custom_accept_encoding
operator|=
name|TRUE
expr_stmt|;
name|handler
operator|->
name|no_dav_headers
operator|=
name|TRUE
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|headers_fetch
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|fetch_ctx
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|handle_fetch
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|fetch_ctx
expr_stmt|;
name|handler
operator|->
name|response_error
operator|=
name|cancel_fetch
expr_stmt|;
name|handler
operator|->
name|response_error_baton
operator|=
name|fetch_ctx
expr_stmt|;
name|handler
operator|->
name|done_delegate
operator|=
name|file_fetch_done
expr_stmt|;
name|handler
operator|->
name|done_delegate_baton
operator|=
name|fetch_ctx
expr_stmt|;
name|fetch_ctx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_active_fetches
operator|++
expr_stmt|;
block|}
block|}
comment|/* If needed, create the PROPFIND to retrieve the file's properties. */
if|if
condition|(
name|file
operator|->
name|fetch_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|file
operator|->
name|propfind_handler
argument_list|,
name|ctx
operator|->
name|sess
argument_list|,
name|file
operator|->
name|url
argument_list|,
name|ctx
operator|->
name|target_rev
argument_list|,
literal|"0"
argument_list|,
name|all_props
argument_list|,
name|set_file_props
argument_list|,
name|file
argument_list|,
name|file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|propfind_handler
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
comment|/* Explicit scheduling */
name|file
operator|->
name|propfind_handler
operator|->
name|done_delegate
operator|=
name|file_props_done
expr_stmt|;
name|file
operator|->
name|propfind_handler
operator|->
name|done_delegate_baton
operator|=
name|file
expr_stmt|;
comment|/* Create a serf request for the PROPFIND.  */
name|svn_ra_serf__request_create
argument_list|(
name|file
operator|->
name|propfind_handler
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_active_propfinds
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|->
name|fetch_props
operator|||
name|file
operator|->
name|fetch_file
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Somehow we are done; probably via the local cache.      Close the file and release memory, etc. */
return|return
name|svn_error_trace
argument_list|(
name|close_file
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__prop_func */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_dir_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_baton_t
modifier|*
name|dir
init|=
name|baton
decl_stmt|;
name|report_context_t
modifier|*
name|ctx
init|=
name|dir
operator|->
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_name
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|dir
operator|->
name|dir_baton
argument_list|,
name|prop_name
argument_list|,
name|val
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_done_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dir_props_done
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_baton_t
modifier|*
name|dir
init|=
name|baton
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|dir
operator|->
name|propfind_handler
decl_stmt|;
if|if
condition|(
name|handler
operator|->
name|server_error
condition|)
return|return
name|svn_ra_serf__server_error_create
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
return|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|207
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
name|dir
operator|->
name|ctx
operator|->
name|num_active_propfinds
operator|--
expr_stmt|;
comment|/* Closing the directory will automatically deliver the propfind props.    *    * Note that closing the directory may dispose the pool containing the    * handler, which is only a valid operation in this callback, as after    * this callback serf assumes the request is done. */
return|return
name|svn_error_trace
argument_list|(
name|maybe_close_dir
argument_list|(
name|dir
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initiates additional requests needed for a directory when not in "send-all"  * mode */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_for_dir
parameter_list|(
name|dir_baton_t
modifier|*
name|dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|dir
operator|->
name|ctx
decl_stmt|;
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
comment|/* Open extra connections if we have enough requests to send. */
if|if
condition|(
name|ctx
operator|->
name|sess
operator|->
name|num_conns
operator|<
name|ctx
operator|->
name|sess
operator|->
name|max_connections
condition|)
name|SVN_ERR
argument_list|(
name|open_connection_if_needed
argument_list|(
name|ctx
operator|->
name|sess
argument_list|,
name|ctx
operator|->
name|num_active_fetches
operator|+
name|ctx
operator|->
name|num_active_propfinds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* What connection should we go on? */
name|conn
operator|=
name|get_best_connection
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* If needed, create the PROPFIND to retrieve the file's properties. */
if|if
condition|(
name|dir
operator|->
name|fetch_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|dir
operator|->
name|propfind_handler
argument_list|,
name|ctx
operator|->
name|sess
argument_list|,
name|dir
operator|->
name|url
argument_list|,
name|ctx
operator|->
name|target_rev
argument_list|,
literal|"0"
argument_list|,
name|all_props
argument_list|,
name|set_dir_prop
argument_list|,
name|dir
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|propfind_handler
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|dir
operator|->
name|propfind_handler
operator|->
name|done_delegate
operator|=
name|dir_props_done
expr_stmt|;
name|dir
operator|->
name|propfind_handler
operator|->
name|done_delegate_baton
operator|=
name|dir
expr_stmt|;
comment|/* Create a serf request for the PROPFIND.  */
name|svn_ra_serf__request_create
argument_list|(
name|dir
operator|->
name|propfind_handler
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_active_propfinds
operator|++
expr_stmt|;
block|}
else|else
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** XML callbacks for our update-report response parsing */
end_comment

begin_comment
comment|/* Conforms to svn_ra_serf__xml_opened_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_opened
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|entered_state
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|tag
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|attrs
decl_stmt|;
switch|switch
condition|(
name|entered_state
condition|)
block|{
case|case
name|UPDATE_REPORT
case|:
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|attrs
operator|=
name|svn_ra_serf__xml_gather_since
argument_list|(
name|xes
argument_list|,
name|UPDATE_REPORT
argument_list|)
expr_stmt|;
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"inline-props"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
operator|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|ctx
operator|->
name|add_props_included
operator|=
name|TRUE
expr_stmt|;
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"send-all"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
operator|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ctx
operator|->
name|send_all_mode
operator|=
name|TRUE
expr_stmt|;
comment|/* All properties are included in send-all mode. */
name|ctx
operator|->
name|add_props_included
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPEN_DIR
case|:
case|case
name|ADD_DIR
case|:
block|{
name|dir_baton_t
modifier|*
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|attrs
operator|=
name|svn_ra_serf__xml_gather_since
argument_list|(
name|xes
argument_list|,
name|entered_state
argument_list|)
expr_stmt|;
name|name
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
literal|""
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_dir_baton
argument_list|(
operator|&
name|dir
argument_list|,
name|ctx
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entered_state
operator|==
name|OPEN_DIR
condition|)
block|{
name|apr_int64_t
name|base_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|base_rev
argument_list|,
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"rev"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|base_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|base_rev
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|->
name|copyfrom_path
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"copyfrom-path"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|copyfrom_path
condition|)
block|{
name|apr_int64_t
name|copyfrom_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_rev_str
decl_stmt|;
name|dir
operator|->
name|copyfrom_path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|dir
operator|->
name|copyfrom_path
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|copyfrom_rev_str
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"copyfrom-rev"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copyfrom_rev_str
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_ATTRIB_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing '%s' attribute"
argument_list|)
argument_list|,
literal|"copyfrom-rev"
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|copyfrom_rev
argument_list|,
name|copyfrom_rev_str
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|copyfrom_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|copyfrom_rev
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ctx
operator|->
name|add_props_included
condition|)
name|dir
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPEN_FILE
case|:
case|case
name|ADD_FILE
case|:
block|{
name|file_baton_t
modifier|*
name|file
decl_stmt|;
name|attrs
operator|=
name|svn_ra_serf__xml_gather_since
argument_list|(
name|xes
argument_list|,
name|entered_state
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_file_baton
argument_list|(
operator|&
name|file
argument_list|,
name|ctx
argument_list|,
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entered_state
operator|==
name|OPEN_FILE
condition|)
block|{
name|apr_int64_t
name|base_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|base_rev
argument_list|,
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"rev"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|base_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|base_rev
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|sha1_checksum
decl_stmt|;
name|file
operator|->
name|copyfrom_path
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"copyfrom-path"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|copyfrom_path
condition|)
block|{
name|apr_int64_t
name|copyfrom_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_rev_str
decl_stmt|;
name|file
operator|->
name|copyfrom_path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|file
operator|->
name|copyfrom_path
argument_list|,
name|file
operator|->
name|pool
argument_list|)
expr_stmt|;
name|copyfrom_rev_str
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"copyfrom-rev"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copyfrom_rev_str
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_ATTRIB_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing '%s' attribute"
argument_list|)
argument_list|,
literal|"copyfrom-rev"
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|copyfrom_rev
argument_list|,
name|copyfrom_rev_str
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|copyfrom_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|copyfrom_rev
expr_stmt|;
block|}
name|sha1_checksum
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"sha1-checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1_checksum
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|file
operator|->
name|final_sha1_checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|sha1_checksum
argument_list|,
name|file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the server isn't in "send-all" mode, we should expect to                  fetch contents for added files. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|send_all_mode
condition|)
name|file
operator|->
name|fetch_file
operator|=
name|TRUE
expr_stmt|;
comment|/* If the server isn't included properties for added items,                  we'll need to fetch them ourselves. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|add_props_included
condition|)
name|file
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TXDELTA
case|:
block|{
name|file_baton_t
modifier|*
name|file
init|=
name|ctx
operator|->
name|cur_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_checksum
decl_stmt|;
comment|/* Pre 1.2, mod_dav_svn was using<txdelta> tags (in              addition to<fetch-file>s and such) when *not* in              "send-all" mode.  As a client, we're smart enough to know              that's wrong, so we'll just ignore these tags. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|send_all_mode
condition|)
break|break;
name|file
operator|->
name|fetch_file
operator|=
name|FALSE
expr_stmt|;
name|attrs
operator|=
name|svn_ra_serf__xml_gather_since
argument_list|(
name|xes
argument_list|,
name|entered_state
argument_list|)
expr_stmt|;
name|base_checksum
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"base-checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_checksum
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|file
operator|->
name|base_md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|base_checksum
argument_list|,
name|file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_file_txdelta
argument_list|(
name|ctx
operator|->
name|cur_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cur_file
operator|->
name|txdelta
operator|!=
name|svn_delta_noop_window_handler
condition|)
block|{
name|svn_stream_t
modifier|*
name|decoder
decl_stmt|;
name|decoder
operator|=
name|svn_txdelta_parse_svndiff
argument_list|(
name|file
operator|->
name|txdelta
argument_list|,
name|file
operator|->
name|txdelta_baton
argument_list|,
name|TRUE
comment|/* error early close*/
argument_list|,
name|file
operator|->
name|pool
argument_list|)
expr_stmt|;
name|file
operator|->
name|txdelta_stream
operator|=
name|svn_base64_decode
argument_list|(
name|decoder
argument_list|,
name|file
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|FETCH_PROPS
case|:
block|{
comment|/* Subversion<= 1.6 servers will return a fetch-props element on              open-file and open-dir when non entry props were changed in              !send-all mode. In turn we fetch the full set of properties              and send all of those as *changes* to the editor. So these              editors have to be aware that they receive-non property changes.              (In case of incomplete directories they have to be aware anyway)               In r1063337 this behavior was changed in mod_dav_svn to always              send property changes inline in these cases. (See issue #3657)               Note that before that change the property changes to the last_*              entry props were already inlined via specific xml elements. */
if|if
condition|(
name|ctx
operator|->
name|cur_file
condition|)
name|ctx
operator|->
name|cur_file
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|->
name|cur_dir
condition|)
name|ctx
operator|->
name|cur_dir
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_closed_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_closed
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|leaving_state
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|cdata
parameter_list|,
name|apr_hash_t
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
switch|switch
condition|(
name|leaving_state
condition|)
block|{
case|case
name|UPDATE_REPORT
case|:
name|ctx
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|TARGET_REVISION
case|:
block|{
specifier|const
name|char
modifier|*
name|revstr
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"rev"
argument_list|)
decl_stmt|;
name|apr_int64_t
name|rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|rev
argument_list|,
name|revstr
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|set_target_revision
argument_list|(
name|ctx
operator|->
name|editor_baton
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHECKED_IN_HREF
case|:
if|if
condition|(
name|ctx
operator|->
name|cur_file
condition|)
name|ctx
operator|->
name|cur_file
operator|->
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|cur_file
operator|->
name|pool
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
name|ctx
operator|->
name|cur_dir
operator|->
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|cur_dir
operator|->
name|pool
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET_PROP
case|:
case|case
name|REMOVE_PROP
case|:
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|encoding
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|leaving_state
operator|==
name|REMOVE_PROP
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|encoding
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"encoding"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"base64"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_UNKNOWN_ENCODING
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Got unrecognized encoding '%s'"
argument_list|)
argument_list|,
name|encoding
argument_list|)
return|;
name|value
operator|=
name|svn_base64_decode_string
argument_list|(
name|cdata
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
name|cdata
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cur_file
condition|)
block|{
name|file_baton_t
modifier|*
name|file
init|=
name|ctx
operator|->
name|cur_file
decl_stmt|;
if|if
condition|(
name|value
operator|||
name|ctx
operator|->
name|add_props_included
operator|||
name|SVN_IS_VALID_REVNUM
argument_list|(
name|file
operator|->
name|base_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ensure_file_opened
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file
operator|->
name|file_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|file
operator|->
name|remove_props
condition|)
name|file
operator|->
name|remove_props
operator|=
name|apr_hash_make
argument_list|(
name|file
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|file
operator|->
name|remove_props
argument_list|,
name|apr_pstrdup
argument_list|(
name|file
operator|->
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dir_baton_t
modifier|*
name|dir
init|=
name|ctx
operator|->
name|cur_dir
decl_stmt|;
if|if
condition|(
name|value
operator|||
name|ctx
operator|->
name|add_props_included
operator|||
name|SVN_IS_VALID_REVNUM
argument_list|(
name|dir
operator|->
name|base_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|dir
operator|->
name|dir_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dir
operator|->
name|remove_props
condition|)
name|dir
operator|->
name|remove_props
operator|=
name|apr_hash_make
argument_list|(
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|dir
operator|->
name|remove_props
argument_list|,
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|OPEN_DIR
case|:
case|case
name|ADD_DIR
case|:
block|{
name|dir_baton_t
modifier|*
name|dir
init|=
name|ctx
operator|->
name|cur_dir
decl_stmt|;
name|ctx
operator|->
name|cur_dir
operator|=
name|ctx
operator|->
name|cur_dir
operator|->
name|parent_dir
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|fetch_props
operator|&&
operator|!
name|dir
operator|->
name|url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The REPORT response did not "
literal|"include the requested checked-in "
literal|"value"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|dir
operator|->
name|fetch_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|maybe_close_dir
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* dir potentially no longer valid */
block|}
else|else
block|{
comment|/* Otherwise, if the server is *not* in "send-all" mode, we                  are at a point where we can queue up the PROPFIND request */
name|SVN_ERR
argument_list|(
name|fetch_for_dir
argument_list|(
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPEN_FILE
case|:
case|case
name|ADD_FILE
case|:
block|{
name|file_baton_t
modifier|*
name|file
init|=
name|ctx
operator|->
name|cur_file
decl_stmt|;
name|ctx
operator|->
name|cur_file
operator|=
name|NULL
expr_stmt|;
comment|/* go fetch info->name from DAV:checked-in */
if|if
condition|(
operator|(
name|file
operator|->
name|fetch_file
operator|||
name|file
operator|->
name|fetch_props
operator|)
operator|&&
operator|!
name|file
operator|->
name|url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The REPORT response did not "
literal|"include the requested checked-in "
literal|"value"
argument_list|)
argument_list|)
return|;
block|}
comment|/* If the server is in "send-all" mode or didn't get further work,              we can now close the file */
if|if
condition|(
operator|!
name|file
operator|->
name|fetch_file
operator|&&
operator|!
name|file
operator|->
name|fetch_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|close_file
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* file is no longer valid */
block|}
else|else
block|{
comment|/* Otherwise, if the server is *not* in "send-all" mode, we                  should be at a point where we can queue up any auxiliary                  content-fetching requests. */
name|SVN_ERR
argument_list|(
name|fetch_for_file
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MD5_CHECKSUM
case|:
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|ctx
operator|->
name|cur_file
operator|->
name|final_md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|cdata
operator|->
name|data
argument_list|,
name|ctx
operator|->
name|cur_file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FETCH_FILE
case|:
block|{
name|file_baton_t
modifier|*
name|file
init|=
name|ctx
operator|->
name|cur_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_checksum
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"base-checksum"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|sha1_checksum
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"sha1-checksum"
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_checksum
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|file
operator|->
name|base_md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|base_checksum
argument_list|,
name|file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Property is duplicated between add-file and fetch-file */
if|if
condition|(
name|sha1_checksum
operator|&&
operator|!
name|file
operator|->
name|final_sha1_checksum
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|file
operator|->
name|final_sha1_checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|sha1_checksum
argument_list|,
name|file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some 0.3x mod_dav_svn wrote both txdelta and fetch-file              elements in send-all mode. (See neon for history) */
if|if
condition|(
operator|!
name|ctx
operator|->
name|send_all_mode
condition|)
name|file
operator|->
name|fetch_file
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DELETE_ENTRY
case|:
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|revstr
decl_stmt|;
name|apr_int64_t
name|delete_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|ctx
operator|->
name|cur_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|revstr
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"rev"
argument_list|)
expr_stmt|;
if|if
condition|(
name|revstr
condition|)
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|delete_rev
argument_list|,
name|revstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|delete_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|delete_entry
argument_list|(
name|svn_relpath_join
argument_list|(
name|ctx
operator|->
name|cur_dir
operator|->
name|relpath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|delete_rev
argument_list|,
name|ctx
operator|->
name|cur_dir
operator|->
name|dir_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ABSENT_DIR
case|:
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|ctx
operator|->
name|cur_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|absent_directory
argument_list|(
name|svn_relpath_join
argument_list|(
name|ctx
operator|->
name|cur_dir
operator|->
name|relpath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|cur_dir
operator|->
name|dir_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ABSENT_FILE
case|:
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|ctx
operator|->
name|cur_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|absent_file
argument_list|(
name|svn_relpath_join
argument_list|(
name|ctx
operator|->
name|cur_dir
operator|->
name|relpath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|cur_dir
operator|->
name|dir_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TXDELTA
case|:
block|{
name|file_baton_t
modifier|*
name|file
init|=
name|ctx
operator|->
name|cur_file
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|txdelta_stream
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|file
operator|->
name|txdelta_stream
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|txdelta_stream
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
case|case
name|VERSION_NAME
case|:
case|case
name|CREATIONDATE
case|:
case|case
name|CREATOR_DISPLAYNAME
case|:
block|{
comment|/* Subversion<= 1.6 servers would return a fetch-props element on              open-file and open-dir when non entry props were changed in              !send-all mode. In turn we fetch the full set of properties and              send those as *changes* to the editor. So these editors have to              be aware that they receive non property changes.              (In case of incomplete directories they have to be aware anyway)               In that case the last_* entry props are posted as 3 specific xml              elements, which we handle here.               In r1063337 this behavior was changed in mod_dav_svn to always              send property changes inline in these cases. (See issue #3657)            */
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cur_file
condition|)
name|SVN_ERR
argument_list|(
name|ensure_file_opened
argument_list|(
name|ctx
operator|->
name|cur_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|->
name|cur_dir
condition|)
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|ctx
operator|->
name|cur_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
switch|switch
condition|(
name|leaving_state
condition|)
block|{
case|case
name|VERSION_NAME
case|:
name|propname
operator|=
name|SVN_PROP_ENTRY_COMMITTED_REV
expr_stmt|;
break|break;
case|case
name|CREATIONDATE
case|:
name|propname
operator|=
name|SVN_PROP_ENTRY_COMMITTED_DATE
expr_stmt|;
break|break;
case|case
name|CREATOR_DISPLAYNAME
case|:
name|propname
operator|=
name|SVN_PROP_ENTRY_LAST_AUTHOR
expr_stmt|;
break|break;
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* Impossible to reach */
block|}
if|if
condition|(
name|ctx
operator|->
name|cur_file
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|ctx
operator|->
name|cur_file
operator|->
name|file_baton
argument_list|,
name|propname
argument_list|,
name|cdata
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|ctx
operator|->
name|cur_dir
operator|->
name|dir_baton
argument_list|,
name|propname
argument_list|,
name|cdata
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_cdata_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_cdata
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|current_state
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|current_state
operator|==
name|TXDELTA
operator|&&
name|ctx
operator|->
name|cur_file
operator|&&
name|ctx
operator|->
name|cur_file
operator|->
name|txdelta_stream
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|ctx
operator|->
name|cur_file
operator|->
name|txdelta_stream
argument_list|,
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Editor callbacks given to callers to create request body */
end_comment

begin_comment
comment|/* Helper to create simple xml tag without attributes. */
end_comment

begin_function
specifier|static
name|void
name|make_simple_xml_tag
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|buf_p
parameter_list|,
specifier|const
name|char
modifier|*
name|tagname
parameter_list|,
specifier|const
name|char
modifier|*
name|cdata
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_xml_make_open_tag
argument_list|(
name|buf_p
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
name|tagname
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_xml_escape_cdata_cstring
argument_list|(
name|buf_p
argument_list|,
name|cdata
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
name|buf_p
argument_list|,
name|pool
argument_list|,
name|tagname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_path
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|report_baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
literal|"S:entry"
argument_list|,
literal|"rev"
argument_list|,
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|revision
argument_list|)
argument_list|,
literal|"lock-token"
argument_list|,
name|lock_token
argument_list|,
literal|"depth"
argument_list|,
name|svn_depth_to_word
argument_list|(
name|depth
argument_list|)
argument_list|,
literal|"start-empty"
argument_list|,
name|start_empty
condition|?
literal|"true"
else|:
name|NULL
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_xml_escape_cdata_cstring
argument_list|(
operator|&
name|buf
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|pool
argument_list|,
literal|"S:entry"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|report
operator|->
name|body_template
argument_list|,
name|buf
operator|->
name|data
argument_list|,
operator|&
name|buf
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_path
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|report_baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:missing"
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|report
operator|->
name|body_template
argument_list|,
name|buf
operator|->
name|data
argument_list|,
operator|&
name|buf
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|link_path
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|report_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|link
decl_stmt|,
modifier|*
name|report_target
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
comment|/* We need to pass in the baseline relative path.    *    * TODO Confirm that it's on the same server?    */
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|pool
argument_list|,
name|url
argument_list|,
operator|&
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to parse URL '%s'"
argument_list|)
argument_list|,
name|url
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_serf__report_resource
argument_list|(
operator|&
name|report_target
argument_list|,
name|report
operator|->
name|sess
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_relative_path
argument_list|(
operator|&
name|link
argument_list|,
name|uri
operator|.
name|path
argument_list|,
name|report
operator|->
name|sess
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|link
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
literal|"S:entry"
argument_list|,
literal|"rev"
argument_list|,
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|revision
argument_list|)
argument_list|,
literal|"lock-token"
argument_list|,
name|lock_token
argument_list|,
literal|"depth"
argument_list|,
name|svn_depth_to_word
argument_list|(
name|depth
argument_list|)
argument_list|,
literal|"linkpath"
argument_list|,
name|link
argument_list|,
literal|"start-empty"
argument_list|,
name|start_empty
condition|?
literal|"true"
else|:
name|NULL
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_xml_escape_cdata_cstring
argument_list|(
operator|&
name|buf
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|pool
argument_list|,
literal|"S:entry"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|report
operator|->
name|body_template
argument_list|,
name|buf
operator|->
name|data
argument_list|,
operator|&
name|buf
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the switch roots to allow generating repos_relpaths from just      the working copy paths. (Needed for HTTPv2) */
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|report
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|link
operator|=
name|apr_pstrdup
argument_list|(
name|report
operator|->
name|pool
argument_list|,
name|link
operator|+
literal|1
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|report
operator|->
name|switched_paths
argument_list|,
name|path
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
index|[
literal|0
index|]
operator|&&
name|report
operator|->
name|update_target
index|[
literal|0
index|]
condition|)
block|{
comment|/* The update root is switched. Make sure we store it the way          we expect it to find */
name|svn_hash_sets
argument_list|(
name|report
operator|->
name|switched_paths
argument_list|,
name|report
operator|->
name|update_target
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Serf callback to create update request body bucket.    Implements svn_ra_serf__request_body_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_update_report_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|body_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|baton
decl_stmt|;
name|body_create_baton_t
modifier|*
name|body
init|=
name|report
operator|->
name|body
decl_stmt|;
if|if
condition|(
name|body
operator|->
name|file
condition|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|body
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|body_bkt
operator|=
name|serf_bucket_file_create
argument_list|(
name|report
operator|->
name|body
operator|->
name|file
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|body_bkt
operator|=
name|serf_bucket_simple_create
argument_list|(
name|body
operator|->
name|all_data
argument_list|,
name|body
operator|->
name|total_bytes
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Serf callback to setup update request headers. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_update_report_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|report
operator|->
name|sess
operator|->
name|using_compression
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Accept-Encoding"
argument_list|,
literal|"gzip,svndiff1;q=0.9,svndiff;q=0.8"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Accept-Encoding"
argument_list|,
literal|"svndiff1;q=0.9,svndiff;q=0.8"
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for update_delay_handler */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|update_delay_baton_t
block|{
name|report_context_t
modifier|*
name|report
decl_stmt|;
name|svn_spillbuf_t
modifier|*
name|spillbuf
decl_stmt|;
name|svn_ra_serf__response_handler_t
name|inner_handler
decl_stmt|;
name|void
modifier|*
name|inner_handler_baton
decl_stmt|;
block|}
name|update_delay_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Helper for update_delay_handler() and process_pending() to    call UDB->INNER_HANDLER with buffer pointed by DATA. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|process_buffer
parameter_list|(
name|update_delay_baton_t
modifier|*
name|udb
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_boolean_t
name|at_eof
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|tmp_bucket
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* ### This code (and the eagain bucket code) can probably be       ### simplified by using a bit of aggregate bucket magic.       ### See mail from Ivan to dev@s.a.o. */
if|if
condition|(
name|at_eof
condition|)
block|{
name|tmp_bucket
operator|=
name|serf_bucket_simple_create
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp_bucket
operator|=
name|svn_ra_serf__create_bucket_with_eagain
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
comment|/* If not at EOF create a bucket that finishes with EAGAIN, otherwise       use a standard bucket with default EOF handling */
name|err
operator|=
name|udb
operator|->
name|inner_handler
argument_list|(
name|request
argument_list|,
name|tmp_bucket
argument_list|,
name|udb
operator|->
name|inner_handler_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* And free the bucket explicitly to avoid growing request allocator      storage (in a loop) */
name|serf_bucket_destroy
argument_list|(
name|tmp_bucket
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Delaying wrapping reponse handler, to avoid creating too many    requests to deliver efficiently */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_delay_handler
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_delay_baton_t
modifier|*
name|udb
init|=
name|handler_baton
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|udb
operator|->
name|spillbuf
condition|)
block|{
if|if
condition|(
name|udb
operator|->
name|report
operator|->
name|send_all_mode
condition|)
block|{
comment|/* Easy out... We only have one request, so avoid everything and just              call the inner handler.               We will always get in the loop (below) on the first chunk, as only              the server can get us in true send-all mode */
return|return
name|svn_error_trace
argument_list|(
name|udb
operator|->
name|inner_handler
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|udb
operator|->
name|inner_handler_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
while|while
condition|(
operator|(
name|udb
operator|->
name|report
operator|->
name|num_active_fetches
operator|+
name|udb
operator|->
name|report
operator|->
name|num_active_propfinds
operator|)
operator|<
name|REQUEST_COUNT_TO_RESUME
condition|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_boolean_t
name|at_eof
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
name|PARSE_CHUNK_SIZE
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
elseif|else
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
name|udb
operator|->
name|report
operator|->
name|report_received
operator|=
name|at_eof
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|iterpool
condition|)
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
operator|!
name|at_eof
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
name|err
operator|=
name|process_buffer
argument_list|(
name|udb
argument_list|,
name|request
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|at_eof
argument_list|,
name|serf_request_get_alloc
argument_list|(
name|request
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
elseif|else
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Throttling is working ok */
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* No buffering was necessary */
block|}
else|else
block|{
comment|/* SERF_ERROR_WAIT_CONN should be impossible? */
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* Let's start using the spill infrastructure */
name|udb
operator|->
name|spillbuf
operator|=
name|svn_spillbuf__create
argument_list|(
name|SPILLBUF_BLOCKSIZE
argument_list|,
name|SPILLBUF_MAXBUFFSIZE
argument_list|,
name|udb
operator|->
name|report
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Read everything we can to a spillbuffer */
do|do
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* ### What blocksize should we pass? */
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
literal|8
operator|*
name|PARSE_CHUNK_SIZE
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_spillbuf__write
argument_list|(
name|udb
operator|->
name|spillbuf
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
do|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
name|udb
operator|->
name|report
operator|->
name|report_received
operator|=
name|TRUE
expr_stmt|;
comment|/* We handle feeding the data from the main context loop, which will be right      after processing the pending data */
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Process pending data from the update report, if any */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|process_pending
parameter_list|(
name|update_delay_baton_t
modifier|*
name|udb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|NULL
decl_stmt|;
name|serf_bucket_alloc_t
modifier|*
name|alloc
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|udb
operator|->
name|report
operator|->
name|num_active_fetches
operator|+
name|udb
operator|->
name|report
operator|->
name|num_active_propfinds
operator|)
operator|<
name|REQUEST_COUNT_TO_RESUME
condition|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_boolean_t
name|at_eof
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|iterpool
condition|)
block|{
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|scratch_pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__read
argument_list|(
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|,
name|udb
operator|->
name|spillbuf
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|&&
operator|!
name|udb
operator|->
name|report
operator|->
name|report_received
condition|)
break|break;
elseif|else
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
name|at_eof
operator|=
name|TRUE
expr_stmt|;
else|else
name|at_eof
operator|=
name|FALSE
expr_stmt|;
name|err
operator|=
name|process_buffer
argument_list|(
name|udb
argument_list|,
name|NULL
comment|/* allowed? */
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|at_eof
argument_list|,
name|alloc
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Throttling is working */
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|udb
operator|->
name|spillbuf
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|iterpool
condition|)
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Process the 'update' editor report */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|process_editor_report
parameter_list|(
name|report_context_t
modifier|*
name|ctx
parameter_list|,
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|sess
init|=
name|ctx
operator|->
name|sess
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_interval_time_t
name|waittime_left
init|=
name|sess
operator|->
name|timeout
decl_stmt|;
name|update_delay_baton_t
modifier|*
name|ud
decl_stmt|;
comment|/* Now wrap the response handler with delay support to avoid sending      out too many requests at once */
name|ud
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ud
argument_list|)
argument_list|)
expr_stmt|;
name|ud
operator|->
name|report
operator|=
name|ctx
expr_stmt|;
name|ud
operator|->
name|inner_handler
operator|=
name|handler
operator|->
name|response_handler
expr_stmt|;
name|ud
operator|->
name|inner_handler_baton
operator|=
name|handler
operator|->
name|response_baton
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|update_delay_handler
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|ud
expr_stmt|;
comment|/* Open the first extra connection. */
name|SVN_ERR
argument_list|(
name|open_connection_if_needed
argument_list|(
name|sess
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sess
operator|->
name|cur_conn
operator|=
literal|1
expr_stmt|;
comment|/* Note that we may have no active GET or PROPFIND requests, yet the      processing has not been completed. This could be from a delay on the      network or because we've spooled the entire response into our "pending"      content of the XML parser. The DONE flag will get set when all the      XML content has been received *and* parsed.  */
while|while
condition|(
operator|!
name|handler
operator|->
name|done
operator|||
name|ctx
operator|->
name|num_active_fetches
operator|||
name|ctx
operator|->
name|num_active_propfinds
operator|||
operator|!
name|ctx
operator|->
name|done
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_serf__context_run
argument_list|(
name|sess
argument_list|,
operator|&
name|waittime_left
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|done
operator|&&
name|handler
operator|->
name|server_error
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_serf__server_error_create
argument_list|(
name|handler
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|err
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* If there is pending REPORT data, process it now. */
if|if
condition|(
name|ud
operator|->
name|spillbuf
condition|)
name|SVN_ERR
argument_list|(
name|process_pending
argument_list|(
name|ud
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Debugging purposes only! */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sess
operator|->
name|num_conns
condition|;
name|i
operator|++
control|)
block|{
name|serf_debug__closed_conn
argument_list|(
name|sess
operator|->
name|conns
index|[
name|i
index|]
operator|->
name|bkt_alloc
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If we got a complete report, close the edit.  Otherwise, abort it. */
if|if
condition|(
name|ctx
operator|->
name|done
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|close_edit
argument_list|(
name|ctx
operator|->
name|editor_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing update-report close tag"
argument_list|)
argument_list|)
return|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|finish_report
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|report_baton
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|sess
init|=
name|report
operator|->
name|sess
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|report_target
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|scratch_pool
argument_list|,
literal|"S:update-report"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|report
operator|->
name|body_template
argument_list|,
name|buf
operator|->
name|data
argument_list|,
operator|&
name|buf
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|report
operator|->
name|body_template
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__report_resource
argument_list|(
operator|&
name|report_target
argument_list|,
name|sess
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|xmlctx
operator|=
name|svn_ra_serf__xml_context_create
argument_list|(
name|update_ttable
argument_list|,
name|update_opened
argument_list|,
name|update_closed
argument_list|,
name|update_cdata
argument_list|,
name|report
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_expat_handler
argument_list|(
name|sess
argument_list|,
name|xmlctx
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"REPORT"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|report_target
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_update_report_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|report
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/xml"
expr_stmt|;
name|handler
operator|->
name|custom_accept_encoding
operator|=
name|TRUE
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_update_report_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|report
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|err
operator|=
name|process_editor_report
argument_list|(
name|report
argument_list|,
name|handler
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
name|svn_error_trace
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_error_trace
argument_list|(
name|report
operator|->
name|editor
operator|->
name|abort_edit
argument_list|(
name|report
operator|->
name|editor_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_report
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
literal|0
block|report_context_t *report = report_baton;
endif|#
directive|endif
comment|/* Should we perform some cleanup here? */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_reporter3_t
name|ra_serf_reporter
init|=
block|{
name|set_path
block|,
name|delete_path
block|,
name|link_path
block|,
name|finish_report
block|,
name|abort_report
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** RA function implementations and body */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_update_reporter
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|src_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dest_path
parameter_list|,
specifier|const
name|char
modifier|*
name|update_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|filter_editor
decl_stmt|;
name|void
modifier|*
name|filter_baton
decl_stmt|;
name|svn_boolean_t
name|has_target
init|=
operator|*
name|update_target
operator|!=
literal|'\0'
decl_stmt|;
name|svn_boolean_t
name|server_supports_depth
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|sess
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|use_bulk_updates
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|server_supports_depth
argument_list|,
name|SVN_RA_CAPABILITY_DEPTH
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can skip the depth filtering when the user requested      depth_files or depth_infinity because the server will      transmit the right stuff anyway. */
if|if
condition|(
operator|(
name|depth
operator|!=
name|svn_depth_files
operator|)
operator|&&
operator|(
name|depth
operator|!=
name|svn_depth_infinity
operator|)
operator|&&
operator|!
name|server_supports_depth
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_delta_depth_filter_editor
argument_list|(
operator|&
name|filter_editor
argument_list|,
operator|&
name|filter_baton
argument_list|,
name|update_editor
argument_list|,
name|update_baton
argument_list|,
name|depth
argument_list|,
name|has_target
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|update_editor
operator|=
name|filter_editor
expr_stmt|;
name|update_baton
operator|=
name|filter_baton
expr_stmt|;
block|}
name|report
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|report
argument_list|)
argument_list|)
expr_stmt|;
name|report
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|report
operator|->
name|sess
operator|=
name|sess
expr_stmt|;
name|report
operator|->
name|target_rev
operator|=
name|revision
expr_stmt|;
name|report
operator|->
name|ignore_ancestry
operator|=
name|ignore_ancestry
expr_stmt|;
name|report
operator|->
name|send_copyfrom_args
operator|=
name|send_copyfrom_args
expr_stmt|;
name|report
operator|->
name|text_deltas
operator|=
name|text_deltas
expr_stmt|;
name|report
operator|->
name|switched_paths
operator|=
name|apr_hash_make
argument_list|(
name|report
operator|->
name|pool
argument_list|)
expr_stmt|;
name|report
operator|->
name|source
operator|=
name|src_path
expr_stmt|;
name|report
operator|->
name|destination
operator|=
name|dest_path
expr_stmt|;
name|report
operator|->
name|update_target
operator|=
name|update_target
expr_stmt|;
name|report
operator|->
name|editor
operator|=
name|update_editor
expr_stmt|;
name|report
operator|->
name|editor_baton
operator|=
name|update_baton
expr_stmt|;
name|report
operator|->
name|done
operator|=
name|FALSE
expr_stmt|;
operator|*
name|reporter
operator|=
operator|&
name|ra_serf_reporter
expr_stmt|;
operator|*
name|report_baton
operator|=
name|report
expr_stmt|;
name|report
operator|->
name|body
operator|=
name|apr_pcalloc
argument_list|(
name|report
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|report
operator|->
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|report
operator|->
name|body
operator|->
name|result_pool
operator|=
name|report
operator|->
name|pool
expr_stmt|;
name|report
operator|->
name|body_template
operator|=
name|svn_stream_create
argument_list|(
name|report
operator|->
name|body
argument_list|,
name|report
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|report
operator|->
name|body_template
argument_list|,
name|body_write_fn
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|report
operator|->
name|body_template
argument_list|,
name|body_done_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|bulk_updates
operator|==
name|svn_tristate_true
condition|)
block|{
comment|/* User would like to use bulk updates. */
name|use_bulk_updates
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sess
operator|->
name|bulk_updates
operator|==
name|svn_tristate_false
condition|)
block|{
comment|/* User doesn't want bulk updates. */
name|use_bulk_updates
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* User doesn't have any preferences on bulk updates. Decide on server          preferences and capabilities. */
if|if
condition|(
name|sess
operator|->
name|server_allows_bulk
condition|)
block|{
if|if
condition|(
name|apr_strnatcasecmp
argument_list|(
name|sess
operator|->
name|server_allows_bulk
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Server doesn't want bulk updates */
name|use_bulk_updates
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_strnatcasecmp
argument_list|(
name|sess
operator|->
name|server_allows_bulk
argument_list|,
literal|"prefer"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Server prefers bulk updates, and we respect that */
name|use_bulk_updates
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Server allows bulk updates, but doesn't dictate its use. Do                  whatever is the default. */
name|use_bulk_updates
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Pre-1.8 server didn't send the bulk_updates header. Check if server              supports inlining properties in update editor report. */
if|if
condition|(
name|sess
operator|->
name|supports_inline_props
condition|)
block|{
comment|/* NOTE: both inlined properties and server->allows_bulk_update                  (flag SVN_DAV_ALLOW_BULK_UPDATES) were added in 1.8.0, so                  this code is never reached with a released version of                  mod_dav_svn.                   Basically by default a 1.8.0 client connecting to a 1.7.x or                  older server will always use bulk updates. */
comment|/* Inline props supported: do not use bulk updates. */
name|use_bulk_updates
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Inline props are not supported: use bulk updates to avoid                * PROPFINDs for every added node. */
name|use_bulk_updates
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|use_bulk_updates
condition|)
block|{
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|scratch_pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"S:update-report"
argument_list|,
literal|"xmlns:S"
argument_list|,
name|SVN_XML_NAMESPACE
argument_list|,
literal|"send-all"
argument_list|,
literal|"true"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|scratch_pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"S:update-report"
argument_list|,
literal|"xmlns:S"
argument_list|,
name|SVN_XML_NAMESPACE
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
comment|/* Subversion 1.8+ servers can be told to send properties for newly          added items inline even when doing a skelta response. */
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:include-props"
argument_list|,
literal|"yes"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:src-path"
argument_list|,
name|report
operator|->
name|source
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|report
operator|->
name|target_rev
argument_list|)
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:target-revision"
argument_list|,
name|apr_ltoa
argument_list|(
name|scratch_pool
argument_list|,
name|report
operator|->
name|target_rev
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|report
operator|->
name|destination
operator|&&
operator|*
name|report
operator|->
name|destination
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:dst-path"
argument_list|,
name|report
operator|->
name|destination
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|report
operator|->
name|update_target
operator|&&
operator|*
name|report
operator|->
name|update_target
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:update-target"
argument_list|,
name|report
operator|->
name|update_target
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|report
operator|->
name|ignore_ancestry
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:ignore-ancestry"
argument_list|,
literal|"yes"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|report
operator|->
name|send_copyfrom_args
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:send-copyfrom-args"
argument_list|,
literal|"yes"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Old servers know "recursive" but not "depth"; help them DTRT. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|||
name|depth
operator|==
name|svn_depth_empty
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:recursive"
argument_list|,
literal|"no"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* When in 'send-all' mode, mod_dav_svn will assume that it should      calculate and transmit real text-deltas (instead of empty windows      that merely indicate "text is changed") unless it finds this      element.       NOTE: Do NOT count on servers actually obeying this, as some exist      which obey send-all, but do not check for this directive at all!       NOTE 2: When not in 'send-all' mode, mod_dav_svn can still be configured to      override our request and send text-deltas. */
if|if
condition|(
operator|!
name|text_deltas
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:text-deltas"
argument_list|,
literal|"no"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:depth"
argument_list|,
name|svn_depth_to_word
argument_list|(
name|depth
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|report
operator|->
name|body_template
argument_list|,
name|buf
operator|->
name|data
argument_list|,
operator|&
name|buf
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__do_update
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision_to_update_to
parameter_list|,
specifier|const
name|char
modifier|*
name|update_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_update_reporter
argument_list|(
name|ra_session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|revision_to_update_to
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|update_target
argument_list|,
name|depth
argument_list|,
name|ignore_ancestry
argument_list|,
name|TRUE
comment|/* text_deltas */
argument_list|,
name|send_copyfrom_args
argument_list|,
name|update_editor
argument_list|,
name|update_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__do_diff
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|diff_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
specifier|const
name|char
modifier|*
name|versus_url
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|diff_editor
parameter_list|,
name|void
modifier|*
name|diff_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_update_reporter
argument_list|(
name|ra_session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|revision
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|versus_url
argument_list|,
name|diff_target
argument_list|,
name|depth
argument_list|,
name|ignore_ancestry
argument_list|,
name|text_deltas
argument_list|,
name|FALSE
comment|/* send_copyfrom */
argument_list|,
name|diff_editor
argument_list|,
name|diff_baton
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__do_status
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|status_target
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|status_editor
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_update_reporter
argument_list|(
name|ra_session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|revision
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|status_target
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|status_editor
argument_list|,
name|status_baton
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__do_switch
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision_to_switch_to
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|switch_editor
parameter_list|,
name|void
modifier|*
name|switch_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
return|return
name|make_update_reporter
argument_list|(
name|ra_session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|revision_to_switch_to
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|switch_url
argument_list|,
name|switch_target
argument_list|,
name|depth
argument_list|,
name|ignore_ancestry
argument_list|,
name|TRUE
comment|/* text_deltas */
argument_list|,
name|send_copyfrom_args
argument_list|,
name|switch_editor
argument_list|,
name|switch_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

end_unit

