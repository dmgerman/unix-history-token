begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * update.c :  entry point for update RA functions for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_version.h>
end_include

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * This enum represents the current state of our XML parsing for a REPORT.  *  * A little explanation of how the parsing works.  Every time we see  * an open-directory tag, we enter the OPEN_DIR state.  Likewise, for  * add-directory, open-file, etc.  When we see the closing variant of the  * open-directory tag, we'll 'pop' out of that state.  *  * Each state has a pool associated with it that can have temporary  * allocations that will live as long as the tag is opened.  Once  * the tag is 'closed', the pool will be reused.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|report_state_e
block|{
name|NONE
init|=
literal|0
block|,
name|INITIAL
init|=
literal|0
block|,
name|UPDATE_REPORT
block|,
name|TARGET_REVISION
block|,
name|OPEN_DIR
block|,
name|ADD_DIR
block|,
name|ABSENT_DIR
block|,
name|OPEN_FILE
block|,
name|ADD_FILE
block|,
name|ABSENT_FILE
block|,
name|PROP
block|,
name|IGNORE_PROP_NAME
block|,
name|NEED_PROP_NAME
block|,
name|TXDELTA
block|}
name|report_state_e
typedef|;
end_typedef

begin_comment
comment|/* While we process the REPORT response, we will queue up GET and PROPFIND    requests. For a very large checkout, it is very easy to queue requests    faster than they are resolved. Thus, we need to pause the XML processing    (which queues more requests) to avoid queueing too many, with their    attendant memory costs. When the queue count drops low enough, we will    resume XML processing.     Note that we don't want the count to drop to zero. We have multiple    connections that we want to keep busy. These are also heuristic numbers    since network and parsing behavior (ie. it doesn't pause immediately)    can make the measurements quite imprecise.     We measure outstanding requests as the sum of NUM_ACTIVE_FETCHES and    NUM_ACTIVE_PROPFINDS in the report_context_t structure.  */
end_comment

begin_define
define|#
directive|define
name|REQUEST_COUNT_TO_PAUSE
value|50
end_define

begin_define
define|#
directive|define
name|REQUEST_COUNT_TO_RESUME
value|40
end_define

begin_comment
comment|/* Forward-declare our report context. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|report_context_t
name|report_context_t
typedef|;
end_typedef

begin_comment
comment|/*  * This structure represents the information for a directory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|report_dir_t
block|{
comment|/* Our parent directory.    *    * This value is NULL when we are the root.    */
name|struct
name|report_dir_t
modifier|*
name|parent_dir
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Pointer back to our original report context. */
name|report_context_t
modifier|*
name|report_context
decl_stmt|;
comment|/* Our name sans any parents. */
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
comment|/* the expanded directory name (including all parent names) */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the canonical url for this directory after updating. (received) */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
comment|/* The original repos_relpath of this url (from the working copy)      or NULL if the repos_relpath can be calculated from the edit root. */
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
comment|/* Our base revision - SVN_INVALID_REVNUM if we're adding this dir. */
name|svn_revnum_t
name|base_rev
decl_stmt|;
comment|/* controlling dir baton - this is only created in ensure_dir_opened() */
name|void
modifier|*
name|dir_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|dir_baton_pool
decl_stmt|;
comment|/* How many references to this directory do we still have open? */
name|apr_size_t
name|ref_count
decl_stmt|;
comment|/* Namespace list allocated out of this ->pool. */
name|svn_ra_serf__ns_t
modifier|*
name|ns_list
decl_stmt|;
comment|/* hashtable for all of the properties (shared within a dir) */
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* hashtable for all to-be-removed properties (shared within a dir) */
name|apr_hash_t
modifier|*
name|removed_props
decl_stmt|;
comment|/* The propfind request for our current directory */
name|svn_ra_serf__handler_t
modifier|*
name|propfind_handler
decl_stmt|;
comment|/* Has the server told us to fetch the dir props? */
name|svn_boolean_t
name|fetch_props
decl_stmt|;
comment|/* Have we closed the directory tag (meaning no more additions)? */
name|svn_boolean_t
name|tag_closed
decl_stmt|;
comment|/* The children of this directory  */
name|struct
name|report_dir_t
modifier|*
name|children
decl_stmt|;
comment|/* The next sibling of this directory */
name|struct
name|report_dir_t
modifier|*
name|sibling
decl_stmt|;
block|}
name|report_dir_t
typedef|;
end_typedef

begin_comment
comment|/*  * This structure represents the information for a file.  *  * A directory may have a report_info_t associated with it as well.  *  * This structure is created as we parse the REPORT response and  * once the element is completed, we create a report_fetch_t structure  * to give to serf to retrieve this file.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|report_info_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The enclosing directory.    *    * If this structure refers to a directory, the dir it points to will be    * itself.    */
name|report_dir_t
modifier|*
name|dir
decl_stmt|;
comment|/* Our name sans any directory info. */
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
comment|/* the expanded file name (including all parent directory names) */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the canonical url for this file. */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
comment|/* lock token, if we had one to start off with. */
specifier|const
name|char
modifier|*
name|lock_token
decl_stmt|;
comment|/* Our base revision - SVN_INVALID_REVNUM if we're adding this file. */
name|svn_revnum_t
name|base_rev
decl_stmt|;
comment|/* our delta base, if present (NULL if we're adding the file) */
specifier|const
name|char
modifier|*
name|delta_base
decl_stmt|;
comment|/* Path of original item if add with history */
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
comment|/* Revision of original item if add with history */
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* The propfind request for our current file (if present) */
name|svn_ra_serf__handler_t
modifier|*
name|propfind_handler
decl_stmt|;
comment|/* Has the server told us to fetch the file props? */
name|svn_boolean_t
name|fetch_props
decl_stmt|;
comment|/* Has the server told us to go fetch - only valid if we had it already */
name|svn_boolean_t
name|fetch_file
decl_stmt|;
comment|/* The properties for this file */
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* pool passed to update->add_file, etc. */
name|apr_pool_t
modifier|*
name|editor_pool
decl_stmt|;
comment|/* controlling file_baton and textdelta handler */
name|void
modifier|*
name|file_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|final_sha1_checksum
decl_stmt|;
name|svn_txdelta_window_handler_t
name|textdelta
decl_stmt|;
name|void
modifier|*
name|textdelta_baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|svndiff_decoder
decl_stmt|;
name|svn_stream_t
modifier|*
name|base64_decoder
decl_stmt|;
comment|/* Checksum for close_file */
specifier|const
name|char
modifier|*
name|final_checksum
decl_stmt|;
comment|/* Stream containing file contents already cached in the working      copy (which may be used to avoid a GET request for the same). */
name|svn_stream_t
modifier|*
name|cached_contents
decl_stmt|;
comment|/* temporary property for this file which is currently being parsed    * It will eventually be stored in our parent directory's property hash.    */
specifier|const
name|char
modifier|*
name|prop_ns
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|prop_value
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_encoding
decl_stmt|;
block|}
name|report_info_t
typedef|;
end_typedef

begin_comment
comment|/*  * This structure represents a single request to GET (fetch) a file with  * its associated Serf session/connection.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|report_fetch_t
block|{
comment|/* The handler representing this particular fetch.  */
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* The session we should use to fetch the file. */
name|svn_ra_serf__session_t
modifier|*
name|sess
decl_stmt|;
comment|/* The connection we should use to fetch file. */
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
comment|/* Stores the information for the file we want to fetch. */
name|report_info_t
modifier|*
name|info
decl_stmt|;
comment|/* Have we read our response headers yet? */
name|svn_boolean_t
name|read_headers
decl_stmt|;
comment|/* This flag is set when our response is aborted before we reach the    * end and we decide to requeue this request.    */
name|svn_boolean_t
name|aborted_read
decl_stmt|;
name|apr_off_t
name|aborted_read_size
decl_stmt|;
comment|/* This is the amount of data that we have read so far. */
name|apr_off_t
name|read_size
decl_stmt|;
comment|/* If we're receiving an svndiff, this will be non-NULL. */
name|svn_stream_t
modifier|*
name|delta_stream
decl_stmt|;
comment|/* If we're writing this file to a stream, this will be non-NULL. */
name|svn_stream_t
modifier|*
name|target_stream
decl_stmt|;
comment|/* Are we done fetching this file? */
name|svn_boolean_t
name|done
decl_stmt|;
comment|/* Discard the rest of the content? */
name|svn_boolean_t
name|discard
decl_stmt|;
name|svn_ra_serf__list_t
modifier|*
modifier|*
name|done_list
decl_stmt|;
name|svn_ra_serf__list_t
name|done_item
decl_stmt|;
block|}
name|report_fetch_t
typedef|;
end_typedef

begin_comment
comment|/*  * The master structure for a REPORT request and response.  */
end_comment

begin_struct
struct|struct
name|report_context_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|sess
decl_stmt|;
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
comment|/* Source path and destination path */
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
specifier|const
name|char
modifier|*
name|destination
decl_stmt|;
comment|/* Our update target. */
specifier|const
name|char
modifier|*
name|update_target
decl_stmt|;
comment|/* What is the target revision that we want for this REPORT? */
name|svn_revnum_t
name|target_rev
decl_stmt|;
comment|/* Have we been asked to ignore ancestry or textdeltas? */
name|svn_boolean_t
name|ignore_ancestry
decl_stmt|;
name|svn_boolean_t
name|text_deltas
decl_stmt|;
comment|/* Do we want the server to send copyfrom args or not? */
name|svn_boolean_t
name|send_copyfrom_args
decl_stmt|;
comment|/* Is the server sending everything in one response? */
name|svn_boolean_t
name|send_all_mode
decl_stmt|;
comment|/* Is the server including properties inline for newly added      files/dirs? */
name|svn_boolean_t
name|add_props_included
decl_stmt|;
comment|/* Path -> const char *repos_relpath mapping */
name|apr_hash_t
modifier|*
name|switched_paths
decl_stmt|;
comment|/* Boolean indicating whether "" is switched.      (This indicates that the we are updating a single file) */
name|svn_boolean_t
name|root_is_switched
decl_stmt|;
comment|/* Our master update editor and baton. */
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
decl_stmt|;
name|void
modifier|*
name|update_baton
decl_stmt|;
comment|/* The file holding request body for the REPORT.    *    * ### todo: It will be better for performance to store small    * request bodies (like 4k) in memory and bigger bodies on disk.    */
name|apr_file_t
modifier|*
name|body_file
decl_stmt|;
comment|/* root directory object */
name|report_dir_t
modifier|*
name|root_dir
decl_stmt|;
comment|/* number of pending GET requests */
name|unsigned
name|int
name|num_active_fetches
decl_stmt|;
comment|/* completed fetches (contains report_fetch_t) */
name|svn_ra_serf__list_t
modifier|*
name|done_fetches
decl_stmt|;
comment|/* number of pending PROPFIND requests */
name|unsigned
name|int
name|num_active_propfinds
decl_stmt|;
comment|/* completed PROPFIND requests (contains svn_ra_serf__handler_t) */
name|svn_ra_serf__list_t
modifier|*
name|done_propfinds
decl_stmt|;
name|svn_ra_serf__list_t
modifier|*
name|done_dir_propfinds
decl_stmt|;
comment|/* list of outstanding prop changes (contains report_dir_t) */
name|svn_ra_serf__list_t
modifier|*
name|active_dir_propfinds
decl_stmt|;
comment|/* list of files that only have prop changes (contains report_info_t) */
name|svn_ra_serf__list_t
modifier|*
name|file_propchanges_only
decl_stmt|;
comment|/* The path to the REPORT request */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Are we done parsing the REPORT response? */
name|svn_boolean_t
name|done
decl_stmt|;
comment|/* Did we receive all data from the network? */
name|svn_boolean_t
name|report_received
decl_stmt|;
comment|/* Did we get a complete (non-truncated) report? */
name|svn_boolean_t
name|report_completed
decl_stmt|;
comment|/* The XML parser context for the REPORT response.  */
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser_ctx
decl_stmt|;
comment|/* Did we close the root directory? */
name|svn_boolean_t
name|closed_root
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_USED_YET
end_ifdef

begin_define
define|#
directive|define
name|D_
value|"DAV:"
end_define

begin_define
define|#
directive|define
name|S_
value|SVN_XML_NAMESPACE
end_define

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_serf__xml_transition_t
name|update_ttable
index|[]
init|=
block|{
block|{
name|INITIAL
block|,
name|S_
block|,
literal|"update-report"
block|,
name|UPDATE_REPORT
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|UPDATE_REPORT
block|,
name|S_
block|,
literal|"target-revision"
block|,
name|TARGET_REVISION
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|UPDATE_REPORT
block|,
name|S_
block|,
literal|"open-directory"
block|,
name|OPEN_DIR
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"open-directory"
block|,
name|OPEN_DIR
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"add-directory"
block|,
name|ADD_DIR
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"add-directory"
block|,
name|ADD_DIR
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"open-file"
block|,
name|OPEN_FILE
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"add-file"
block|,
name|ADD_FILE
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"add-file"
block|,
name|ADD_FILE
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"delete-entry"
block|,
name|OPEN_FILE
block|,
name|FALSE
block|,
block|{
literal|"?rev"
block|,
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"absent-directory"
block|,
name|ABSENT_DIR
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"absent-directory"
block|,
name|ABSENT_DIR
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|OPEN_DIR
block|,
name|S_
block|,
literal|"absent-file"
block|,
name|ABSENT_FILE
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ADD_DIR
block|,
name|S_
block|,
literal|"absent-file"
block|,
name|ABSENT_FILE
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Conforms to svn_ra_serf__xml_opened_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_opened
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|entered_state
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|tag
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_closed_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_closed
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|leaving_state
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|cdata
parameter_list|,
name|apr_hash_t
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|leaving_state
operator|==
name|TARGET_REVISION
condition|)
block|{
specifier|const
name|char
modifier|*
name|rev
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"rev"
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|update_editor
operator|->
name|set_target_revision
argument_list|(
name|ctx
operator|->
name|update_baton
argument_list|,
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
argument_list|,
name|ctx
operator|->
name|sess
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_cdata_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_cdata
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|current_state
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOT_USED_YET */
end_comment

begin_comment
comment|/* Returns best connection for fetching files/properties. */
end_comment

begin_function
specifier|static
name|svn_ra_serf__connection_t
modifier|*
name|get_best_connection
parameter_list|(
name|report_context_t
modifier|*
name|ctx
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
name|int
name|first_conn
init|=
literal|1
decl_stmt|;
comment|/* Skip the first connection if the REPORT response hasn't been completely      received yet or if we're being told to limit our connections to      2 (because this could be an attempt to ensure that we do all our      auxiliary GETs/PROPFINDs on a single connection).       ### FIXME: This latter requirement (max_connections> 2) is      ### really just a hack to work around the fact that some update      ### editor implementations (such as svnrdump's dump editor)      ### simply can't handle the way ra_serf violates the editor v1      ### drive ordering requirements.      ###      ### See http://subversion.tigris.org/issues/show_bug.cgi?id=4116.   */
if|if
condition|(
name|ctx
operator|->
name|report_received
operator|&&
operator|(
name|ctx
operator|->
name|sess
operator|->
name|max_connections
operator|>
literal|2
operator|)
condition|)
name|first_conn
operator|=
literal|0
expr_stmt|;
comment|/* Currently, we just cycle connections.  In the future we could      store the number of pending requests on each connection, or      perform other heuristics, to achieve better connection usage.      (As an optimization, if there's only one available auxiliary      connection to use, don't bother doing all the cur_conn math --      just return that one connection.)  */
if|if
condition|(
name|ctx
operator|->
name|sess
operator|->
name|num_conns
operator|-
name|first_conn
operator|==
literal|1
condition|)
block|{
name|conn
operator|=
name|ctx
operator|->
name|sess
operator|->
name|conns
index|[
name|first_conn
index|]
expr_stmt|;
block|}
else|else
block|{
name|conn
operator|=
name|ctx
operator|->
name|sess
operator|->
name|conns
index|[
name|ctx
operator|->
name|sess
operator|->
name|cur_conn
index|]
expr_stmt|;
name|ctx
operator|->
name|sess
operator|->
name|cur_conn
operator|++
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|sess
operator|->
name|cur_conn
operator|>=
name|ctx
operator|->
name|sess
operator|->
name|num_conns
condition|)
name|ctx
operator|->
name|sess
operator|->
name|cur_conn
operator|=
name|first_conn
expr_stmt|;
block|}
return|return
name|conn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Report state management helper **/
end_comment

begin_function
specifier|static
name|report_info_t
modifier|*
name|push_state
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|report_context_t
modifier|*
name|ctx
parameter_list|,
name|report_state_e
name|state
parameter_list|)
block|{
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|apr_pool_t
modifier|*
name|info_parent_pool
decl_stmt|;
name|svn_ra_serf__xml_push_state
argument_list|(
name|parser
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|info
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
comment|/* Our private pool needs to be disjoint from the state pool. */
if|if
condition|(
operator|!
name|info
condition|)
block|{
name|info_parent_pool
operator|=
name|ctx
operator|->
name|pool
expr_stmt|;
block|}
else|else
block|{
name|info_parent_pool
operator|=
name|info
operator|->
name|pool
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
condition|)
block|{
name|report_info_t
modifier|*
name|new_info
decl_stmt|;
name|new_info
operator|=
name|apr_pcalloc
argument_list|(
name|info_parent_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_info
argument_list|)
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|info_parent_pool
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|lock_token
operator|=
name|NULL
expr_stmt|;
name|new_info
operator|->
name|prop_value
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|new_info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|dir
operator|=
name|apr_pcalloc
argument_list|(
name|new_info
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_info
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|dir
operator|->
name|pool
operator|=
name|new_info
operator|->
name|pool
expr_stmt|;
comment|/* Create the root property tree. */
name|new_info
operator|->
name|dir
operator|->
name|props
operator|=
name|apr_hash_make
argument_list|(
name|new_info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|props
operator|=
name|new_info
operator|->
name|dir
operator|->
name|props
expr_stmt|;
name|new_info
operator|->
name|dir
operator|->
name|removed_props
operator|=
name|apr_hash_make
argument_list|(
name|new_info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|dir
operator|->
name|report_context
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|info
condition|)
block|{
name|info
operator|->
name|dir
operator|->
name|ref_count
operator|++
expr_stmt|;
name|new_info
operator|->
name|dir
operator|->
name|parent_dir
operator|=
name|info
operator|->
name|dir
expr_stmt|;
comment|/* Point our ns_list at our parents to try to reuse it. */
name|new_info
operator|->
name|dir
operator|->
name|ns_list
operator|=
name|info
operator|->
name|dir
operator|->
name|ns_list
expr_stmt|;
comment|/* Add ourselves to our parent's list */
name|new_info
operator|->
name|dir
operator|->
name|sibling
operator|=
name|info
operator|->
name|dir
operator|->
name|children
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|children
operator|=
name|new_info
operator|->
name|dir
expr_stmt|;
block|}
else|else
block|{
comment|/* Allow us to be found later. */
name|ctx
operator|->
name|root_dir
operator|=
name|new_info
operator|->
name|dir
expr_stmt|;
block|}
name|parser
operator|->
name|state
operator|->
name|private
operator|=
name|new_info
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|OPEN_FILE
operator|||
name|state
operator|==
name|ADD_FILE
condition|)
block|{
name|report_info_t
modifier|*
name|new_info
decl_stmt|;
name|new_info
operator|=
name|apr_pcalloc
argument_list|(
name|info_parent_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_info
argument_list|)
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|info_parent_pool
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|file_baton
operator|=
name|NULL
expr_stmt|;
name|new_info
operator|->
name|lock_token
operator|=
name|NULL
expr_stmt|;
name|new_info
operator|->
name|fetch_file
operator|=
name|FALSE
expr_stmt|;
name|new_info
operator|->
name|prop_value
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|new_info
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Point at our parent's directory state. */
name|new_info
operator|->
name|dir
operator|=
name|info
operator|->
name|dir
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|ref_count
operator|++
expr_stmt|;
name|new_info
operator|->
name|props
operator|=
name|apr_hash_make
argument_list|(
name|new_info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|parser
operator|->
name|state
operator|->
name|private
operator|=
name|new_info
expr_stmt|;
block|}
return|return
name|parser
operator|->
name|state
operator|->
name|private
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Wrappers around our various property walkers **/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_file_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_info_t
modifier|*
name|info
init|=
name|baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|info
operator|->
name|dir
operator|->
name|report_context
operator|->
name|update_editor
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_name
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
operator|!=
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|info
operator|->
name|file_baton
argument_list|,
name|prop_name
argument_list|,
name|val
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_dir_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_dir_t
modifier|*
name|dir
init|=
name|baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|dir
operator|->
name|report_context
operator|->
name|update_editor
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_name
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
operator|!=
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|dir
operator|->
name|dir_baton
argument_list|,
name|prop_name
argument_list|,
name|val
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_file_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_info_t
modifier|*
name|info
init|=
name|baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|info
operator|->
name|dir
operator|->
name|report_context
operator|->
name|update_editor
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_name
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
operator|!=
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|info
operator|->
name|file_baton
argument_list|,
name|prop_name
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_dir_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_dir_t
modifier|*
name|dir
init|=
name|baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|dir
operator|->
name|report_context
operator|->
name|update_editor
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_name
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
operator|!=
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|dir
operator|->
name|dir_baton
argument_list|,
name|prop_name
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Helpers to open and close directories */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_dir_opened
parameter_list|(
name|report_dir_t
modifier|*
name|dir
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|dir
operator|->
name|report_context
decl_stmt|;
comment|/* if we're already open, return now */
if|if
condition|(
name|dir
operator|->
name|dir_baton
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|dir
operator|->
name|base_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|dir
operator|->
name|dir_baton_pool
operator|=
name|svn_pool_create
argument_list|(
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|destination
operator|&&
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|invalidate_wc_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|invalidate_wc_props
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callback_baton
argument_list|,
name|ctx
operator|->
name|update_target
argument_list|,
name|SVN_RA_SERF__WC_CHECKED_IN_URL
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|update_editor
operator|->
name|open_root
argument_list|(
name|ctx
operator|->
name|update_baton
argument_list|,
name|dir
operator|->
name|base_rev
argument_list|,
name|dir
operator|->
name|dir_baton_pool
argument_list|,
operator|&
name|dir
operator|->
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|dir
operator|->
name|parent_dir
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|dir_baton_pool
operator|=
name|svn_pool_create
argument_list|(
name|dir
operator|->
name|parent_dir
operator|->
name|dir_baton_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|dir
operator|->
name|base_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|update_editor
operator|->
name|open_directory
argument_list|(
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|parent_dir
operator|->
name|dir_baton
argument_list|,
name|dir
operator|->
name|base_rev
argument_list|,
name|dir
operator|->
name|dir_baton_pool
argument_list|,
operator|&
name|dir
operator|->
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|update_editor
operator|->
name|add_directory
argument_list|(
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|parent_dir
operator|->
name|dir_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|dir
operator|->
name|dir_baton_pool
argument_list|,
operator|&
name|dir
operator|->
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_dir
parameter_list|(
name|report_dir_t
modifier|*
name|dir
parameter_list|)
block|{
name|report_dir_t
modifier|*
name|prev
decl_stmt|;
name|report_dir_t
modifier|*
name|sibling
decl_stmt|;
comment|/* ### is there a better pool... this is tossed at end-of-func  */
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|dir
operator|->
name|dir_baton_pool
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|dir
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_all_props
argument_list|(
name|dir
operator|->
name|props
argument_list|,
name|dir
operator|->
name|base_name
argument_list|,
name|dir
operator|->
name|base_rev
argument_list|,
name|set_dir_props
argument_list|,
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_all_props
argument_list|(
name|dir
operator|->
name|removed_props
argument_list|,
name|dir
operator|->
name|base_name
argument_list|,
name|dir
operator|->
name|base_rev
argument_list|,
name|remove_dir_props
argument_list|,
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|fetch_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_all_props
argument_list|(
name|dir
operator|->
name|props
argument_list|,
name|dir
operator|->
name|url
argument_list|,
name|dir
operator|->
name|report_context
operator|->
name|target_rev
argument_list|,
name|set_dir_props
argument_list|,
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|dir
operator|->
name|report_context
operator|->
name|update_editor
operator|->
name|close_directory
argument_list|(
name|dir
operator|->
name|dir_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove us from our parent's children list */
if|if
condition|(
name|dir
operator|->
name|parent_dir
condition|)
block|{
name|prev
operator|=
name|NULL
expr_stmt|;
name|sibling
operator|=
name|dir
operator|->
name|parent_dir
operator|->
name|children
expr_stmt|;
while|while
condition|(
name|sibling
operator|!=
name|dir
condition|)
block|{
name|prev
operator|=
name|sibling
expr_stmt|;
name|sibling
operator|=
name|sibling
operator|->
name|sibling
expr_stmt|;
if|if
condition|(
operator|!
name|sibling
condition|)
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prev
condition|)
block|{
name|dir
operator|->
name|parent_dir
operator|->
name|children
operator|=
name|dir
operator|->
name|sibling
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|sibling
operator|=
name|dir
operator|->
name|sibling
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|dir
operator|->
name|dir_baton_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_all_dirs
parameter_list|(
name|report_dir_t
modifier|*
name|dir
parameter_list|)
block|{
while|while
condition|(
name|dir
operator|->
name|children
condition|)
block|{
name|SVN_ERR
argument_list|(
name|close_all_dirs
argument_list|(
name|dir
operator|->
name|children
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|ref_count
operator|--
expr_stmt|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|dir
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|close_dir
argument_list|(
name|dir
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Routines called when we are fetching a file */
end_comment

begin_comment
comment|/* This function works around a bug in some older versions of  * mod_dav_svn in that it will not send remove-prop in the update  * report when a lock property disappears when send-all is false.  *  * Therefore, we'll try to look at our properties and see if there's  * an active lock.  If not, then we'll assume there isn't a lock  * anymore.  */
end_comment

begin_function
specifier|static
name|void
name|check_lock
parameter_list|(
name|report_info_t
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|lock_val
decl_stmt|;
name|lock_val
operator|=
name|svn_ra_serf__get_ver_prop
argument_list|(
name|info
operator|->
name|props
argument_list|,
name|info
operator|->
name|url
argument_list|,
name|info
operator|->
name|dir
operator|->
name|report_context
operator|->
name|target_rev
argument_list|,
literal|"DAV:"
argument_list|,
literal|"lockdiscovery"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_val
condition|)
block|{
name|char
modifier|*
name|new_lock
decl_stmt|;
name|new_lock
operator|=
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|editor_pool
argument_list|,
name|lock_val
argument_list|)
expr_stmt|;
name|apr_collapse_spaces
argument_list|(
name|new_lock
argument_list|,
name|new_lock
argument_list|)
expr_stmt|;
name|lock_val
operator|=
name|new_lock
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lock_val
operator|||
name|lock_val
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|svn_string_t
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|svn_string_ncreate
argument_list|(
literal|""
argument_list|,
literal|1
argument_list|,
name|info
operator|->
name|editor_pool
argument_list|)
expr_stmt|;
name|svn_ra_serf__set_ver_prop
argument_list|(
name|info
operator|->
name|dir
operator|->
name|removed_props
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|base_rev
argument_list|,
literal|"DAV:"
argument_list|,
literal|"lock-token"
argument_list|,
name|str
argument_list|,
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|headers_fetch
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_fetch_t
modifier|*
name|fetch_ctx
init|=
name|baton
decl_stmt|;
comment|/* note that we have old VC URL */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|fetch_ctx
operator|->
name|info
operator|->
name|base_rev
argument_list|)
operator|&&
name|fetch_ctx
operator|->
name|info
operator|->
name|delta_base
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_DELTA_BASE_HEADER
argument_list|,
name|fetch_ctx
operator|->
name|info
operator|->
name|delta_base
argument_list|)
expr_stmt|;
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Accept-Encoding"
argument_list|,
literal|"svndiff1;q=0.9,svndiff;q=0.8"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fetch_ctx
operator|->
name|sess
operator|->
name|using_compression
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Accept-Encoding"
argument_list|,
literal|"gzip"
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cancel_fetch
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|int
name|status_code
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|report_fetch_t
modifier|*
name|fetch_ctx
init|=
name|baton
decl_stmt|;
comment|/* Uh-oh.  Our connection died on us.    *    * The core ra_serf layer will requeue our request - we just need to note    * that we got cut off in the middle of our song.    */
if|if
condition|(
operator|!
name|response
condition|)
block|{
comment|/* If we already started the fetch and opened the file handle, we need        * to hold subsequent read() ops until we get back to where we were        * before the close and we can then resume the textdelta() calls.        */
if|if
condition|(
name|fetch_ctx
operator|->
name|read_headers
condition|)
block|{
if|if
condition|(
operator|!
name|fetch_ctx
operator|->
name|aborted_read
operator|&&
name|fetch_ctx
operator|->
name|read_size
condition|)
block|{
name|fetch_ctx
operator|->
name|aborted_read
operator|=
name|TRUE
expr_stmt|;
name|fetch_ctx
operator|->
name|aborted_read_size
operator|=
name|fetch_ctx
operator|->
name|read_size
expr_stmt|;
block|}
name|fetch_ctx
operator|->
name|read_size
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We have no idea what went wrong. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|error_fetch
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|report_fetch_t
modifier|*
name|fetch_ctx
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
name|fetch_ctx
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
name|fetch_ctx
operator|->
name|done_item
operator|.
name|data
operator|=
name|fetch_ctx
expr_stmt|;
name|fetch_ctx
operator|->
name|done_item
operator|.
name|next
operator|=
operator|*
name|fetch_ctx
operator|->
name|done_list
expr_stmt|;
operator|*
name|fetch_ctx
operator|->
name|done_list
operator|=
operator|&
name|fetch_ctx
operator|->
name|done_item
expr_stmt|;
comment|/* Discard the rest of this request      (This makes sure it doesn't error when the request is aborted later) */
name|serf_request_set_handler
argument_list|(
name|request
argument_list|,
name|svn_ra_serf__response_discard_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Some errors would be handled by serf; make sure they really make      the update fail by wrapping it in a different error. */
if|if
condition|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SERF_WRAPPED_ERROR
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Wield the editor referenced by INFO to open (or add) the file    file also associated with INFO, setting properties on the file and    calling the editor's apply_textdelta() function on it if necessary    (or if FORCE_APPLY_TEXTDELTA is set).     Callers will probably want to also see the function that serves    the opposite purpose of this one, close_updated_file().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_updated_file
parameter_list|(
name|report_info_t
modifier|*
name|info
parameter_list|,
name|svn_boolean_t
name|force_apply_textdelta
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|info
operator|->
name|dir
operator|->
name|report_context
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
init|=
name|ctx
operator|->
name|update_editor
decl_stmt|;
comment|/* Ensure our parent is open. */
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|info
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|editor_pool
operator|=
name|svn_pool_create
argument_list|(
name|info
operator|->
name|dir
operator|->
name|dir_baton_pool
argument_list|)
expr_stmt|;
comment|/* Expand our full name now if we haven't done so yet. */
if|if
condition|(
operator|!
name|info
operator|->
name|name
condition|)
block|{
name|info
operator|->
name|name
operator|=
name|svn_relpath_join
argument_list|(
name|info
operator|->
name|dir
operator|->
name|name
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|editor_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Open (or add) the file. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|base_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|update_editor
operator|->
name|open_file
argument_list|(
name|info
operator|->
name|name
argument_list|,
name|info
operator|->
name|dir
operator|->
name|dir_baton
argument_list|,
name|info
operator|->
name|base_rev
argument_list|,
name|info
operator|->
name|editor_pool
argument_list|,
operator|&
name|info
operator|->
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|update_editor
operator|->
name|add_file
argument_list|(
name|info
operator|->
name|name
argument_list|,
name|info
operator|->
name|dir
operator|->
name|dir_baton
argument_list|,
name|info
operator|->
name|copyfrom_path
argument_list|,
name|info
operator|->
name|copyfrom_rev
argument_list|,
name|info
operator|->
name|editor_pool
argument_list|,
operator|&
name|info
operator|->
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for lock information. */
if|if
condition|(
name|info
operator|->
name|lock_token
condition|)
name|check_lock
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Get (maybe) a textdelta window handler for transmitting file      content changes. */
if|if
condition|(
name|info
operator|->
name|fetch_file
operator|||
name|force_apply_textdelta
condition|)
block|{
name|SVN_ERR
argument_list|(
name|update_editor
operator|->
name|apply_textdelta
argument_list|(
name|info
operator|->
name|file_baton
argument_list|,
name|info
operator|->
name|base_checksum
argument_list|,
name|info
operator|->
name|editor_pool
argument_list|,
operator|&
name|info
operator|->
name|textdelta
argument_list|,
operator|&
name|info
operator|->
name|textdelta_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Close the file associated with INFO->file_baton, and cleanup other    bits of that structure managed by open_updated_file(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_updated_file
parameter_list|(
name|report_info_t
modifier|*
name|info
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|info
operator|->
name|dir
operator|->
name|report_context
decl_stmt|;
comment|/* Set all of the properties we received */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_all_props
argument_list|(
name|info
operator|->
name|props
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|base_rev
argument_list|,
name|set_file_props
argument_list|,
name|info
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_all_props
argument_list|(
name|info
operator|->
name|dir
operator|->
name|removed_props
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|base_rev
argument_list|,
name|remove_file_props
argument_list|,
name|info
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fetch_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_all_props
argument_list|(
name|info
operator|->
name|props
argument_list|,
name|info
operator|->
name|url
argument_list|,
name|ctx
operator|->
name|target_rev
argument_list|,
name|set_file_props
argument_list|,
name|info
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Close the file via the editor. */
name|SVN_ERR
argument_list|(
name|info
operator|->
name|dir
operator|->
name|report_context
operator|->
name|update_editor
operator|->
name|close_file
argument_list|(
name|info
operator|->
name|file_baton
argument_list|,
name|info
operator|->
name|final_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're done with our editor pool. */
name|svn_pool_destroy
argument_list|(
name|info
operator|->
name|editor_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_fetch
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|report_fetch_t
modifier|*
name|fetch_ctx
init|=
name|handler_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* ### new field. make sure we didn't miss some initialization.  */
name|SVN_ERR_ASSERT
argument_list|(
name|fetch_ctx
operator|->
name|handler
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fetch_ctx
operator|->
name|read_headers
condition|)
block|{
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Content-Type"
argument_list|)
expr_stmt|;
name|info
operator|=
name|fetch_ctx
operator|->
name|info
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|svn_cstring_casecmp
argument_list|(
name|val
argument_list|,
name|SVN_SVNDIFF_MIME_TYPE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fetch_ctx
operator|->
name|delta_stream
operator|=
name|svn_txdelta_parse_svndiff
argument_list|(
name|info
operator|->
name|textdelta
argument_list|,
name|info
operator|->
name|textdelta_baton
argument_list|,
name|TRUE
argument_list|,
name|info
operator|->
name|editor_pool
argument_list|)
expr_stmt|;
comment|/* Validate the delta base claimed by the server matches              what we asked for! */
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
name|SVN_DAV_DELTA_BASE_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
operator|(
name|strcmp
argument_list|(
name|val
argument_list|,
name|info
operator|->
name|delta_base
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"GET request returned unexpected "
literal|"delta base: %s"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|error_fetch
argument_list|(
name|request
argument_list|,
name|fetch_ctx
argument_list|,
name|err
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|fetch_ctx
operator|->
name|delta_stream
operator|=
name|NULL
expr_stmt|;
block|}
name|fetch_ctx
operator|->
name|read_headers
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If the error code wasn't 200, something went wrong. Don't use the returned      data as its probably an error message. Just bail out instead. */
if|if
condition|(
name|fetch_ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|200
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"GET request failed: %d %s"
argument_list|)
argument_list|,
name|fetch_ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
argument_list|,
name|fetch_ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|reason
argument_list|)
expr_stmt|;
return|return
name|error_fetch
argument_list|(
name|request
argument_list|,
name|fetch_ctx
argument_list|,
name|err
argument_list|)
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|svn_txdelta_window_t
name|delta_window
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_txdelta_op_t
name|delta_op
decl_stmt|;
name|svn_string_t
name|window_data
decl_stmt|;
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
literal|8000
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|fetch_ctx
operator|->
name|read_size
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|fetch_ctx
operator|->
name|aborted_read
condition|)
block|{
name|apr_off_t
name|skip
decl_stmt|;
comment|/* We haven't caught up to where we were before. */
if|if
condition|(
name|fetch_ctx
operator|->
name|read_size
operator|<
name|fetch_ctx
operator|->
name|aborted_read_size
condition|)
block|{
comment|/* Eek.  What did the file shrink or something? */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
comment|/* Skip on to the next iteration of this loop. */
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
continue|continue;
block|}
comment|/* Woo-hoo.  We're back. */
name|fetch_ctx
operator|->
name|aborted_read
operator|=
name|FALSE
expr_stmt|;
comment|/* Update data and len to just provide the new data. */
name|skip
operator|=
name|len
operator|-
operator|(
name|fetch_ctx
operator|->
name|read_size
operator|-
name|fetch_ctx
operator|->
name|aborted_read_size
operator|)
expr_stmt|;
name|data
operator|+=
name|skip
expr_stmt|;
name|len
operator|-=
name|skip
expr_stmt|;
block|}
if|if
condition|(
name|fetch_ctx
operator|->
name|delta_stream
condition|)
block|{
name|err
operator|=
name|svn_stream_write
argument_list|(
name|fetch_ctx
operator|->
name|delta_stream
argument_list|,
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|error_fetch
argument_list|(
name|request
argument_list|,
name|fetch_ctx
argument_list|,
name|err
argument_list|)
return|;
block|}
block|}
comment|/* otherwise, manually construct the text delta window. */
elseif|else
if|if
condition|(
name|len
condition|)
block|{
name|window_data
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|window_data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|delta_op
operator|.
name|action_code
operator|=
name|svn_txdelta_new
expr_stmt|;
name|delta_op
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|delta_op
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|delta_window
operator|.
name|tview_len
operator|=
name|len
expr_stmt|;
name|delta_window
operator|.
name|num_ops
operator|=
literal|1
expr_stmt|;
name|delta_window
operator|.
name|ops
operator|=
operator|&
name|delta_op
expr_stmt|;
name|delta_window
operator|.
name|new_data
operator|=
operator|&
name|window_data
expr_stmt|;
comment|/* write to the file located in the info. */
name|err
operator|=
name|fetch_ctx
operator|->
name|info
operator|->
name|textdelta
argument_list|(
operator|&
name|delta_window
argument_list|,
name|fetch_ctx
operator|->
name|info
operator|->
name|textdelta_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|error_fetch
argument_list|(
name|request
argument_list|,
name|fetch_ctx
argument_list|,
name|err
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|report_info_t
modifier|*
name|info
init|=
name|fetch_ctx
operator|->
name|info
decl_stmt|;
if|if
condition|(
name|fetch_ctx
operator|->
name|delta_stream
condition|)
name|err
operator|=
name|svn_error_trace
argument_list|(
name|svn_stream_close
argument_list|(
name|fetch_ctx
operator|->
name|delta_stream
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|svn_error_trace
argument_list|(
name|info
operator|->
name|textdelta
argument_list|(
name|NULL
argument_list|,
name|info
operator|->
name|textdelta_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|error_fetch
argument_list|(
name|request
argument_list|,
name|fetch_ctx
argument_list|,
name|err
argument_list|)
return|;
block|}
name|err
operator|=
name|close_updated_file
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|error_fetch
argument_list|(
name|request
argument_list|,
name|fetch_ctx
argument_list|,
name|err
argument_list|)
argument_list|)
return|;
block|}
name|fetch_ctx
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
name|fetch_ctx
operator|->
name|done_item
operator|.
name|data
operator|=
name|fetch_ctx
expr_stmt|;
name|fetch_ctx
operator|->
name|done_item
operator|.
name|next
operator|=
operator|*
name|fetch_ctx
operator|->
name|done_list
expr_stmt|;
operator|*
name|fetch_ctx
operator|->
name|done_list
operator|=
operator|&
name|fetch_ctx
operator|->
name|done_item
expr_stmt|;
comment|/* We're done with our pool. */
name|svn_pool_destroy
argument_list|(
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
comment|/* not reached */
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_stream
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_fetch_t
modifier|*
name|fetch_ctx
init|=
name|handler_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* ### new field. make sure we didn't miss some initialization.  */
name|SVN_ERR_ASSERT
argument_list|(
name|fetch_ctx
operator|->
name|handler
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_serf__error_on_status
argument_list|(
name|fetch_ctx
operator|->
name|handler
operator|->
name|sline
argument_list|,
name|fetch_ctx
operator|->
name|info
operator|->
name|name
argument_list|,
name|fetch_ctx
operator|->
name|handler
operator|->
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fetch_ctx
operator|->
name|handler
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_serf__handle_discard_body
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
literal|8000
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|fetch_ctx
operator|->
name|read_size
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|fetch_ctx
operator|->
name|aborted_read
condition|)
block|{
comment|/* We haven't caught up to where we were before. */
if|if
condition|(
name|fetch_ctx
operator|->
name|read_size
operator|<
name|fetch_ctx
operator|->
name|aborted_read_size
condition|)
block|{
comment|/* Eek.  What did the file shrink or something? */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
comment|/* Skip on to the next iteration of this loop. */
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
continue|continue;
block|}
comment|/* Woo-hoo.  We're back. */
name|fetch_ctx
operator|->
name|aborted_read
operator|=
name|FALSE
expr_stmt|;
comment|/* Increment data and len by the difference. */
name|data
operator|+=
name|fetch_ctx
operator|->
name|read_size
operator|-
name|fetch_ctx
operator|->
name|aborted_read_size
expr_stmt|;
name|len
operator|+=
name|fetch_ctx
operator|->
name|read_size
operator|-
name|fetch_ctx
operator|->
name|aborted_read_size
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|apr_size_t
name|written_len
decl_stmt|;
name|written_len
operator|=
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|fetch_ctx
operator|->
name|target_stream
argument_list|,
name|data
argument_list|,
operator|&
name|written_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|fetch_ctx
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
comment|/* not reached */
block|}
end_function

begin_comment
comment|/* Close the directory represented by DIR -- and any suitable parents    thereof -- if we are able to do so.  This is the case whenever:       - there are no remaining open items within the directory, and      - the directory's XML close tag has been processed (so we know        there are no more children to worry about in the future), and      - either:          - we aren't fetching properties for this directory, or          - we've already finished fetching those properties. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_close_dir_chain
parameter_list|(
name|report_dir_t
modifier|*
name|dir
parameter_list|)
block|{
name|report_dir_t
modifier|*
name|cur_dir
init|=
name|dir
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|cur_dir
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_dir
operator|&&
operator|!
name|cur_dir
operator|->
name|ref_count
operator|&&
name|cur_dir
operator|->
name|tag_closed
operator|&&
operator|(
operator|!
name|cur_dir
operator|->
name|fetch_props
operator|||
name|cur_dir
operator|->
name|propfind_handler
operator|->
name|done
operator|)
condition|)
block|{
name|report_dir_t
modifier|*
name|parent
init|=
name|cur_dir
operator|->
name|parent_dir
decl_stmt|;
name|report_context_t
modifier|*
name|report_context
init|=
name|cur_dir
operator|->
name|report_context
decl_stmt|;
name|svn_boolean_t
name|propfind_in_done_list
init|=
name|FALSE
decl_stmt|;
name|svn_ra_serf__list_t
modifier|*
name|done_list
decl_stmt|;
comment|/* Make sure there are no references to this dir in the          active_dir_propfinds list.  If there are, don't close the          directory -- which would delete the pool from which the          relevant active_dir_propfinds list item is allocated -- and          of course don't crawl upward to check the parents for          a closure opportunity, either.  */
name|done_list
operator|=
name|report_context
operator|->
name|active_dir_propfinds
expr_stmt|;
while|while
condition|(
name|done_list
condition|)
block|{
if|if
condition|(
name|done_list
operator|->
name|data
operator|==
name|cur_dir
condition|)
block|{
name|propfind_in_done_list
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|done_list
operator|=
name|done_list
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|propfind_in_done_list
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|close_dir
argument_list|(
name|cur_dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|parent
operator|->
name|ref_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|report_context
operator|->
name|closed_root
operator|=
name|TRUE
expr_stmt|;
block|}
name|cur_dir
operator|=
name|parent
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open the file associated with INFO for editing, pass along any    propchanges we've recorded for it, and then close the file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_propchange_only
parameter_list|(
name|report_info_t
modifier|*
name|info
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|open_updated_file
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|close_updated_file
argument_list|(
name|info
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're done with our pool. */
name|svn_pool_destroy
argument_list|(
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|ref_count
operator|--
expr_stmt|;
comment|/* See if the parent directory of this file (and perhaps even      parents of that) can be closed now.  */
name|SVN_ERR
argument_list|(
name|maybe_close_dir_chain
argument_list|(
name|info
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* "Fetch" a file whose contents were made available via the    get_wc_contents() callback (as opposed to requiring a GET to the    server), and feed the information through the associated update    editor.  In editor-speak, this will add/open the file, transmit any    property changes, handle the contents, and then close the file.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_local_content
parameter_list|(
name|report_info_t
modifier|*
name|info
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_stream
argument_list|(
name|info
operator|->
name|cached_contents
argument_list|,
name|info
operator|->
name|textdelta
argument_list|,
name|info
operator|->
name|textdelta_baton
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|info
operator|->
name|cached_contents
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|cached_contents
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|close_updated_file
argument_list|(
name|info
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're done with our pool. */
name|svn_pool_destroy
argument_list|(
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|ref_count
operator|--
expr_stmt|;
comment|/* See if the parent directory of this fetched item (and      perhaps even parents of that) can be closed now. */
name|SVN_ERR
argument_list|(
name|maybe_close_dir_chain
argument_list|(
name|info
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_file
parameter_list|(
name|report_context_t
modifier|*
name|ctx
parameter_list|,
name|report_info_t
modifier|*
name|info
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* What connection should we go on? */
name|conn
operator|=
name|get_best_connection
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* If needed, create the PROPFIND to retrieve the file's properties. */
name|info
operator|->
name|propfind_handler
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fetch_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__deliver_props
argument_list|(
operator|&
name|info
operator|->
name|propfind_handler
argument_list|,
name|info
operator|->
name|props
argument_list|,
name|ctx
operator|->
name|sess
argument_list|,
name|conn
argument_list|,
name|info
operator|->
name|url
argument_list|,
name|ctx
operator|->
name|target_rev
argument_list|,
literal|"0"
argument_list|,
name|all_props
argument_list|,
operator|&
name|ctx
operator|->
name|done_propfinds
argument_list|,
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|info
operator|->
name|propfind_handler
argument_list|)
expr_stmt|;
comment|/* Create a serf request for the PROPFIND.  */
name|svn_ra_serf__request_create
argument_list|(
name|info
operator|->
name|propfind_handler
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_active_propfinds
operator|++
expr_stmt|;
block|}
comment|/* If we've been asked to fetch the file or it's an add, do so.    * Otherwise, handle the case where only the properties changed.    */
if|if
condition|(
name|info
operator|->
name|fetch_file
operator|&&
name|ctx
operator|->
name|text_deltas
condition|)
block|{
name|svn_stream_t
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
comment|/* Open the file for editing. */
name|SVN_ERR
argument_list|(
name|open_updated_file
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|textdelta
operator|==
name|svn_delta_noop_window_handler
condition|)
block|{
comment|/* There is nobody looking for an actual stream.               Just report an empty stream instead of fetching              to be ingored data */
name|info
operator|->
name|cached_contents
operator|=
name|svn_stream_empty
argument_list|(
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
operator|&&
name|info
operator|->
name|final_sha1_checksum
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
init|=
name|NULL
decl_stmt|;
comment|/* Parse the optional SHA1 checksum (1.7+) */
name|err
operator|=
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|info
operator|->
name|final_sha1_checksum
argument_list|,
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Okay so far?  Let's try to get a stream on some readily              available matching content. */
if|if
condition|(
operator|!
name|err
operator|&&
name|checksum
condition|)
block|{
name|err
operator|=
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callback_baton
argument_list|,
operator|&
name|contents
argument_list|,
name|checksum
argument_list|,
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|info
operator|->
name|cached_contents
operator|=
name|contents
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* Meh.  Maybe we'll care one day why we're in an                  errorful state, but this codepath is optional.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the working copy can provide cached contents for this          file, we don't have to fetch them from the server. */
if|if
condition|(
name|info
operator|->
name|cached_contents
condition|)
block|{
comment|/* If we'll be doing a PROPFIND for this file... */
if|if
condition|(
name|info
operator|->
name|propfind_handler
condition|)
block|{
comment|/* ... then we'll just leave ourselves a little "todo"                  about that fact (and we'll deal with the file content                  stuff later, after we've handled that PROPFIND                  response. */
name|svn_ra_serf__list_t
modifier|*
name|list_item
decl_stmt|;
name|list_item
operator|=
name|apr_pcalloc
argument_list|(
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|list_item
argument_list|)
argument_list|)
expr_stmt|;
name|list_item
operator|->
name|data
operator|=
name|info
expr_stmt|;
name|list_item
operator|->
name|next
operator|=
name|ctx
operator|->
name|file_propchanges_only
expr_stmt|;
name|ctx
operator|->
name|file_propchanges_only
operator|=
name|list_item
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, if we've no PROPFIND to do, we might as                  well take care of those locally accessible file                  contents now. */
name|SVN_ERR
argument_list|(
name|handle_local_content
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise, we use a GET request for the file's contents. */
name|report_fetch_t
modifier|*
name|fetch_ctx
decl_stmt|;
name|fetch_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fetch_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|fetch_ctx
operator|->
name|info
operator|=
name|info
expr_stmt|;
name|fetch_ctx
operator|->
name|done_list
operator|=
operator|&
name|ctx
operator|->
name|done_fetches
expr_stmt|;
name|fetch_ctx
operator|->
name|sess
operator|=
name|ctx
operator|->
name|sess
expr_stmt|;
name|fetch_ctx
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|handler
operator|=
name|apr_pcalloc
argument_list|(
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|->
name|handler_pool
operator|=
name|info
operator|->
name|dir
operator|->
name|pool
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"GET"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|fetch_ctx
operator|->
name|info
operator|->
name|url
expr_stmt|;
name|handler
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|handler
operator|->
name|session
operator|=
name|ctx
operator|->
name|sess
expr_stmt|;
name|handler
operator|->
name|custom_accept_encoding
operator|=
name|TRUE
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|headers_fetch
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|fetch_ctx
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|handle_fetch
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|fetch_ctx
expr_stmt|;
name|handler
operator|->
name|response_error
operator|=
name|cancel_fetch
expr_stmt|;
name|handler
operator|->
name|response_error_baton
operator|=
name|fetch_ctx
expr_stmt|;
name|fetch_ctx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_active_fetches
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|propfind_handler
condition|)
block|{
name|svn_ra_serf__list_t
modifier|*
name|list_item
decl_stmt|;
name|list_item
operator|=
name|apr_pcalloc
argument_list|(
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|list_item
argument_list|)
argument_list|)
expr_stmt|;
name|list_item
operator|->
name|data
operator|=
name|info
expr_stmt|;
name|list_item
operator|->
name|next
operator|=
name|ctx
operator|->
name|file_propchanges_only
expr_stmt|;
name|ctx
operator|->
name|file_propchanges_only
operator|=
name|list_item
expr_stmt|;
block|}
else|else
block|{
comment|/* No propfind or GET request.  Just handle the prop changes now. */
name|SVN_ERR
argument_list|(
name|handle_propchange_only
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|num_active_fetches
operator|+
name|ctx
operator|->
name|num_active_propfinds
operator|>
name|REQUEST_COUNT_TO_PAUSE
condition|)
name|ctx
operator|->
name|parser_ctx
operator|->
name|paused
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** XML callbacks for our update-report response parsing */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|start_report
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
name|report_state_e
name|state
decl_stmt|;
name|state
operator|=
name|parser
operator|->
name|state
operator|->
name|current_state
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NONE
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"update-report"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"inline-props"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
operator|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|ctx
operator|->
name|add_props_included
operator|=
name|TRUE
expr_stmt|;
name|val
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"send-all"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
operator|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ctx
operator|->
name|send_all_mode
operator|=
name|TRUE
expr_stmt|;
comment|/* All properties are included in send-all mode. */
name|ctx
operator|->
name|add_props_included
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|NONE
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"target-revision"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|rev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision attr in target-revision element"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|update_editor
operator|->
name|set_target_revision
argument_list|(
name|ctx
operator|->
name|update_baton
argument_list|,
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
argument_list|,
name|ctx
operator|->
name|sess
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|NONE
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-directory"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|rev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision attr in open-directory element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|OPEN_DIR
argument_list|)
expr_stmt|;
name|info
operator|->
name|base_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|base_rev
operator|=
name|info
operator|->
name|base_rev
expr_stmt|;
name|info
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|base_name
operator|=
literal|""
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|name
operator|=
literal|""
expr_stmt|;
name|info
operator|->
name|base_name
operator|=
name|info
operator|->
name|dir
operator|->
name|base_name
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|info
operator|->
name|dir
operator|->
name|name
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|repos_relpath
operator|=
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|switched_paths
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|dir
operator|->
name|repos_relpath
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_relative_path
argument_list|(
operator|&
name|info
operator|->
name|dir
operator|->
name|repos_relpath
argument_list|,
name|ctx
operator|->
name|sess
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|ctx
operator|->
name|sess
argument_list|,
name|ctx
operator|->
name|conn
argument_list|,
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|NONE
condition|)
block|{
comment|/* do nothing as we haven't seen our valid start tag yet. */
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-directory"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|rev
decl_stmt|,
modifier|*
name|dirname
decl_stmt|;
name|report_dir_t
modifier|*
name|dir
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|rev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision attr in open-directory element"
argument_list|)
argument_list|)
return|;
block|}
name|dirname
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirname
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in open-directory element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|OPEN_DIR
argument_list|)
expr_stmt|;
name|dir
operator|=
name|info
operator|->
name|dir
expr_stmt|;
name|info
operator|->
name|base_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|dir
operator|->
name|base_rev
operator|=
name|info
operator|->
name|base_rev
expr_stmt|;
name|info
operator|->
name|fetch_props
operator|=
name|FALSE
expr_stmt|;
name|dir
operator|->
name|base_name
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|info
operator|->
name|base_name
operator|=
name|dir
operator|->
name|base_name
expr_stmt|;
comment|/* Expand our name. */
name|dir
operator|->
name|name
operator|=
name|svn_relpath_join
argument_list|(
name|dir
operator|->
name|parent_dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|base_name
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|dir
operator|->
name|name
expr_stmt|;
name|dir
operator|->
name|repos_relpath
operator|=
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|switched_paths
argument_list|,
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
operator|->
name|repos_relpath
condition|)
name|dir
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|dir
operator|->
name|parent_dir
operator|->
name|repos_relpath
argument_list|,
name|dir
operator|->
name|base_name
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"add-directory"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|dir_name
decl_stmt|,
modifier|*
name|cf
decl_stmt|,
modifier|*
name|cr
decl_stmt|;
name|report_dir_t
modifier|*
name|dir
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|dir_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in add-directory element"
argument_list|)
argument_list|)
return|;
block|}
name|cf
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"copyfrom-path"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|cr
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"copyfrom-rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|ADD_DIR
argument_list|)
expr_stmt|;
name|dir
operator|=
name|info
operator|->
name|dir
expr_stmt|;
name|dir
operator|->
name|base_name
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|info
operator|->
name|base_name
operator|=
name|dir
operator|->
name|base_name
expr_stmt|;
comment|/* Expand our name. */
name|dir
operator|->
name|name
operator|=
name|svn_relpath_join
argument_list|(
name|dir
operator|->
name|parent_dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|base_name
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|dir
operator|->
name|name
expr_stmt|;
name|info
operator|->
name|copyfrom_path
operator|=
name|cf
condition|?
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|pool
argument_list|,
name|cf
argument_list|)
else|:
name|NULL
expr_stmt|;
name|info
operator|->
name|copyfrom_rev
operator|=
name|cr
condition|?
name|SVN_STR_TO_REV
argument_list|(
name|cr
argument_list|)
else|:
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Mark that we don't have a base. */
name|info
operator|->
name|base_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|dir
operator|->
name|base_rev
operator|=
name|info
operator|->
name|base_rev
expr_stmt|;
comment|/* If the server isn't included properties for added items,          we'll need to fetch them ourselves. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|add_props_included
condition|)
name|dir
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
name|dir
operator|->
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|dir
operator|->
name|parent_dir
operator|->
name|repos_relpath
argument_list|,
name|dir
operator|->
name|base_name
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|file_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in open-file element"
argument_list|)
argument_list|)
return|;
block|}
name|rev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision attr in open-file element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|OPEN_FILE
argument_list|)
expr_stmt|;
name|info
operator|->
name|base_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|info
operator|->
name|fetch_props
operator|=
name|FALSE
expr_stmt|;
name|info
operator|->
name|base_name
operator|=
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|pool
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"add-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|,
modifier|*
name|cf
decl_stmt|,
modifier|*
name|cr
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|file_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|cf
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"copyfrom-path"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|cr
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"copyfrom-rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in add-file element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|ADD_FILE
argument_list|)
expr_stmt|;
name|info
operator|->
name|base_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* If the server isn't in "send-all" mode, we should expect to          fetch contents for added files. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|send_all_mode
condition|)
name|info
operator|->
name|fetch_file
operator|=
name|TRUE
expr_stmt|;
comment|/* If the server isn't included properties for added items,          we'll need to fetch them ourselves. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|add_props_included
condition|)
name|info
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
name|info
operator|->
name|base_name
operator|=
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|pool
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|copyfrom_path
operator|=
name|cf
condition|?
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|pool
argument_list|,
name|cf
argument_list|)
else|:
name|NULL
expr_stmt|;
name|info
operator|->
name|copyfrom_rev
operator|=
name|cr
condition|?
name|SVN_STR_TO_REV
argument_list|(
name|cr
argument_list|)
else|:
name|SVN_INVALID_REVNUM
expr_stmt|;
name|info
operator|->
name|final_sha1_checksum
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"sha1-checksum"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|final_sha1_checksum
condition|)
name|info
operator|->
name|final_sha1_checksum
operator|=
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|pool
argument_list|,
name|info
operator|->
name|final_sha1_checksum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"delete-entry"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_str
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|apr_pool_t
modifier|*
name|tmppool
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|svn_revnum_t
name|delete_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|file_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in delete-entry element"
argument_list|)
argument_list|)
return|;
block|}
name|rev_str
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev_str
condition|)
comment|/* Not available on older repositories! */
name|delete_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|rev_str
argument_list|)
expr_stmt|;
name|info
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|info
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|tmppool
operator|=
name|svn_pool_create
argument_list|(
name|info
operator|->
name|dir
operator|->
name|dir_baton_pool
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_relpath_join
argument_list|(
name|info
operator|->
name|dir
operator|->
name|name
argument_list|,
name|file_name
argument_list|,
name|tmppool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|update_editor
operator|->
name|delete_entry
argument_list|(
name|full_path
argument_list|,
name|delete_rev
argument_list|,
name|info
operator|->
name|dir
operator|->
name|dir_baton
argument_list|,
name|tmppool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|tmppool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"absent-directory"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|file_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in absent-directory element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|info
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|update_editor
operator|->
name|absent_directory
argument_list|(
name|svn_relpath_join
argument_list|(
name|info
operator|->
name|name
argument_list|,
name|file_name
argument_list|,
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|)
argument_list|,
name|info
operator|->
name|dir
operator|->
name|dir_baton
argument_list|,
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"absent-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|file_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in absent-file element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_dir_opened
argument_list|(
name|info
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|update_editor
operator|->
name|absent_file
argument_list|(
name|svn_relpath_join
argument_list|(
name|info
operator|->
name|name
argument_list|,
name|file_name
argument_list|,
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|)
argument_list|,
name|info
operator|->
name|dir
operator|->
name|dir_baton
argument_list|,
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
condition|)
block|{
name|report_info_t
modifier|*
name|info
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"checked-in"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|IGNORE_PROP_NAME
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_ns
operator|=
name|name
operator|.
name|namespace
expr_stmt|;
name|info
operator|->
name|prop_name
operator|=
name|apr_pstrdup
argument_list|(
name|parser
operator|->
name|state
operator|->
name|pool
argument_list|,
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_encoding
operator|=
name|NULL
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|info
operator|->
name|prop_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"set-prop"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"remove-prop"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|full_prop_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|colon
decl_stmt|;
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|PROP
argument_list|)
expr_stmt|;
name|full_prop_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|full_prop_name
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in %s element"
argument_list|)
argument_list|,
name|name
operator|.
name|name
argument_list|)
return|;
block|}
name|colon
operator|=
name|strchr
argument_list|(
name|full_prop_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
name|colon
operator|++
expr_stmt|;
else|else
name|colon
operator|=
name|full_prop_name
expr_stmt|;
name|info
operator|->
name|prop_ns
operator|=
name|apr_pstrmemdup
argument_list|(
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|,
name|full_prop_name
argument_list|,
name|colon
operator|-
name|full_prop_name
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_name
operator|=
name|apr_pstrdup
argument_list|(
name|parser
operator|->
name|state
operator|->
name|pool
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_encoding
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"encoding"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|info
operator|->
name|prop_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"prop"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* need to fetch it. */
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|NEED_PROP_NAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"fetch-props"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown tag '%s' while at state %d"
argument_list|)
argument_list|,
name|name
operator|.
name|name
argument_list|,
name|state
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|OPEN_FILE
operator|||
name|state
operator|==
name|ADD_FILE
condition|)
block|{
name|report_info_t
modifier|*
name|info
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"checked-in"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|IGNORE_PROP_NAME
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_ns
operator|=
name|name
operator|.
name|namespace
expr_stmt|;
name|info
operator|->
name|prop_name
operator|=
name|apr_pstrdup
argument_list|(
name|parser
operator|->
name|state
operator|->
name|pool
argument_list|,
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_encoding
operator|=
name|NULL
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|info
operator|->
name|prop_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"prop"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* need to fetch it. */
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|NEED_PROP_NAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"fetch-props"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
name|info
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"fetch-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
name|info
operator|->
name|base_checksum
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"base-checksum"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|base_checksum
condition|)
name|info
operator|->
name|base_checksum
operator|=
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|pool
argument_list|,
name|info
operator|->
name|base_checksum
argument_list|)
expr_stmt|;
name|info
operator|->
name|final_sha1_checksum
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"sha1-checksum"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|final_sha1_checksum
condition|)
name|info
operator|->
name|final_sha1_checksum
operator|=
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|pool
argument_list|,
name|info
operator|->
name|final_sha1_checksum
argument_list|)
expr_stmt|;
name|info
operator|->
name|fetch_file
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"set-prop"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"remove-prop"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|full_prop_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|colon
decl_stmt|;
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|PROP
argument_list|)
expr_stmt|;
name|full_prop_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|full_prop_name
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in %s element"
argument_list|)
argument_list|,
name|name
operator|.
name|name
argument_list|)
return|;
block|}
name|colon
operator|=
name|strchr
argument_list|(
name|full_prop_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
name|colon
operator|++
expr_stmt|;
else|else
name|colon
operator|=
name|full_prop_name
expr_stmt|;
name|info
operator|->
name|prop_ns
operator|=
name|apr_pstrmemdup
argument_list|(
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|,
name|full_prop_name
argument_list|,
name|colon
operator|-
name|full_prop_name
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_name
operator|=
name|apr_pstrdup
argument_list|(
name|parser
operator|->
name|state
operator|->
name|pool
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_encoding
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"encoding"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|info
operator|->
name|prop_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"txdelta"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Pre 1.2, mod_dav_svn was using<txdelta> tags (in              addition to<fetch-file>s and such) when *not* in              "send-all" mode.  As a client, we're smart enough to know              that's wrong, so we'll just ignore these tags. */
if|if
condition|(
name|ctx
operator|->
name|send_all_mode
condition|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
init|=
name|ctx
operator|->
name|update_editor
decl_stmt|;
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|TXDELTA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|file_baton
condition|)
block|{
name|SVN_ERR
argument_list|(
name|open_updated_file
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|base_checksum
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"base-checksum"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|update_editor
operator|->
name|apply_textdelta
argument_list|(
name|info
operator|->
name|file_baton
argument_list|,
name|info
operator|->
name|base_checksum
argument_list|,
name|info
operator|->
name|editor_pool
argument_list|,
operator|&
name|info
operator|->
name|textdelta
argument_list|,
operator|&
name|info
operator|->
name|textdelta_baton
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|svndiff_decoder
operator|=
name|svn_txdelta_parse_svndiff
argument_list|(
name|info
operator|->
name|textdelta
argument_list|,
name|info
operator|->
name|textdelta_baton
argument_list|,
name|TRUE
argument_list|,
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|info
operator|->
name|base64_decoder
operator|=
name|svn_base64_decode
argument_list|(
name|info
operator|->
name|svndiff_decoder
argument_list|,
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown tag '%s' while at state %d"
argument_list|)
argument_list|,
name|name
operator|.
name|name
argument_list|,
name|state
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|IGNORE_PROP_NAME
condition|)
block|{
name|report_info_t
modifier|*
name|info
init|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|PROP
argument_list|)
decl_stmt|;
name|info
operator|->
name|prop_encoding
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"encoding"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|NEED_PROP_NAME
condition|)
block|{
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|PROP
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_ns
operator|=
name|name
operator|.
name|namespace
expr_stmt|;
name|info
operator|->
name|prop_name
operator|=
name|apr_pstrdup
argument_list|(
name|parser
operator|->
name|state
operator|->
name|pool
argument_list|,
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|prop_encoding
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"encoding"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|info
operator|->
name|prop_value
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|end_report
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
name|report_state_e
name|state
decl_stmt|;
name|state
operator|=
name|parser
operator|->
name|state
operator|->
name|current_state
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NONE
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"update-report"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctx
operator|->
name|report_completed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* nothing to close yet. */
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-directory"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|state
operator|==
name|ADD_DIR
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"add-directory"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|checked_in_url
decl_stmt|;
name|report_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
comment|/* We've now closed this directory; note it. */
name|info
operator|->
name|dir
operator|->
name|tag_closed
operator|=
name|TRUE
expr_stmt|;
comment|/* go fetch info->file_name from DAV:checked-in */
name|checked_in_url
operator|=
name|svn_ra_serf__get_ver_prop
argument_list|(
name|info
operator|->
name|dir
operator|->
name|props
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|base_rev
argument_list|,
literal|"DAV:"
argument_list|,
literal|"checked-in"
argument_list|)
expr_stmt|;
comment|/* If we were expecting to have the properties and we aren't able to        * get it, bail.        */
if|if
condition|(
operator|!
name|checked_in_url
operator|&&
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|dir
operator|->
name|base_rev
argument_list|)
operator|||
name|info
operator|->
name|dir
operator|->
name|fetch_props
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The REPORT or PROPFIND response did not "
literal|"include the requested checked-in value"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|->
name|dir
operator|->
name|url
operator|=
name|checked_in_url
expr_stmt|;
comment|/* At this point, we should have the checked-in href.        * If needed, create the PROPFIND to retrieve the dir's properties.        */
if|if
condition|(
name|info
operator|->
name|dir
operator|->
name|fetch_props
condition|)
block|{
name|svn_ra_serf__list_t
modifier|*
name|list_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__deliver_props
argument_list|(
operator|&
name|info
operator|->
name|dir
operator|->
name|propfind_handler
argument_list|,
name|info
operator|->
name|dir
operator|->
name|props
argument_list|,
name|ctx
operator|->
name|sess
argument_list|,
name|get_best_connection
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|info
operator|->
name|dir
operator|->
name|url
argument_list|,
name|ctx
operator|->
name|target_rev
argument_list|,
literal|"0"
argument_list|,
name|all_props
argument_list|,
operator|&
name|ctx
operator|->
name|done_dir_propfinds
argument_list|,
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|info
operator|->
name|dir
operator|->
name|propfind_handler
argument_list|)
expr_stmt|;
comment|/* Create a serf request for the PROPFIND.  */
name|svn_ra_serf__request_create
argument_list|(
name|info
operator|->
name|dir
operator|->
name|propfind_handler
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_active_propfinds
operator|++
expr_stmt|;
name|list_item
operator|=
name|apr_pcalloc
argument_list|(
name|info
operator|->
name|dir
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|list_item
argument_list|)
argument_list|)
expr_stmt|;
name|list_item
operator|->
name|data
operator|=
name|info
operator|->
name|dir
expr_stmt|;
name|list_item
operator|->
name|next
operator|=
name|ctx
operator|->
name|active_dir_propfinds
expr_stmt|;
name|ctx
operator|->
name|active_dir_propfinds
operator|=
name|list_item
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|num_active_fetches
operator|+
name|ctx
operator|->
name|num_active_propfinds
operator|>
name|REQUEST_COUNT_TO_PAUSE
condition|)
name|ctx
operator|->
name|parser_ctx
operator|->
name|paused
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|info
operator|->
name|dir
operator|->
name|propfind_handler
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* See if this directory (and perhaps even parents of that) can          be closed now.  This is likely to be the case only if we          didn't need to contact the server for supplemental          information required to handle any of this directory's          children.  */
name|SVN_ERR
argument_list|(
name|maybe_close_dir_chain
argument_list|(
name|info
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|OPEN_FILE
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|report_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
comment|/* Expand our full name now if we haven't done so yet. */
if|if
condition|(
operator|!
name|info
operator|->
name|name
condition|)
block|{
name|info
operator|->
name|name
operator|=
name|svn_relpath_join
argument_list|(
name|info
operator|->
name|dir
operator|->
name|name
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|lock_token
operator|&&
operator|!
name|info
operator|->
name|fetch_props
condition|)
name|info
operator|->
name|fetch_props
operator|=
name|TRUE
expr_stmt|;
comment|/* If possible, we'd like to fetch only a delta against a        * version of the file we already have in our working copy,        * rather than fetching a fulltext.        *        * In HTTP v2, we can simply construct the URL we need given the        * repos_relpath and base revision number.        */
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|ctx
operator|->
name|sess
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
comment|/* If this file is switched vs the editor root we should provide              its real url instead of the one calculated from the session root.            */
name|repos_relpath
operator|=
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|switched_paths
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|repos_relpath
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|root_is_switched
condition|)
block|{
comment|/* We are updating a direct target (most likely a file)                      that is switched vs its parent url */
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|svn_relpath_dirname
argument_list|(
name|info
operator|->
name|name
argument_list|,
name|info
operator|->
name|pool
argument_list|)
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|repos_relpath
operator|=
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|switched_paths
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|info
operator|->
name|dir
operator|->
name|repos_relpath
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|delta_base
operator|=
name|apr_psprintf
argument_list|(
name|info
operator|->
name|pool
argument_list|,
literal|"%s/%ld/%s"
argument_list|,
name|ctx
operator|->
name|sess
operator|->
name|rev_root_stub
argument_list|,
name|info
operator|->
name|base_rev
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|repos_relpath
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|get_wc_prop
condition|)
block|{
comment|/* If we have a WC, we might be able to dive all the way into the WC            * to get the previous URL so we can do a differential GET with the            * base URL.            */
specifier|const
name|svn_string_t
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callbacks
operator|->
name|get_wc_prop
argument_list|(
name|ctx
operator|->
name|sess
operator|->
name|wc_callback_baton
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|SVN_RA_SERF__WC_CHECKED_IN_URL
argument_list|,
operator|&
name|value
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|delta_base
operator|=
name|value
condition|?
name|value
operator|->
name|data
else|:
name|NULL
expr_stmt|;
block|}
comment|/* go fetch info->name from DAV:checked-in */
name|info
operator|->
name|url
operator|=
name|svn_ra_serf__get_ver_prop
argument_list|(
name|info
operator|->
name|props
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|base_rev
argument_list|,
literal|"DAV:"
argument_list|,
literal|"checked-in"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The REPORT or PROPFIND response did not "
literal|"include the requested checked-in value"
argument_list|)
argument_list|)
return|;
block|}
comment|/* If the server is in "send-all" mode, we might have opened the          file when we started seeing content for it.  If we didn't get          any content for it, we still need to open the file.  But in          any case, we can then immediately close it.  */
if|if
condition|(
name|ctx
operator|->
name|send_all_mode
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|file_baton
condition|)
block|{
name|SVN_ERR
argument_list|(
name|open_updated_file
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|close_updated_file
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|ref_count
operator|--
expr_stmt|;
block|}
comment|/* Otherwise, if the server is *not* in "send-all" mode, we          should be at a point where we can queue up any auxiliary          content-fetching requests.  */
else|else
block|{
name|SVN_ERR
argument_list|(
name|fetch_file
argument_list|(
name|ctx
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|ADD_FILE
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"add-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|report_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
comment|/* go fetch info->name from DAV:checked-in */
name|info
operator|->
name|url
operator|=
name|svn_ra_serf__get_ver_prop
argument_list|(
name|info
operator|->
name|props
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|base_rev
argument_list|,
literal|"DAV:"
argument_list|,
literal|"checked-in"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The REPORT or PROPFIND response did not "
literal|"include the requested checked-in value"
argument_list|)
argument_list|)
return|;
block|}
comment|/* If the server is in "send-all" mode, we might have opened the          file when we started seeing content for it.  If we didn't get          any content for it, we still need to open the file.  But in          any case, we can then immediately close it.  */
if|if
condition|(
name|ctx
operator|->
name|send_all_mode
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|file_baton
condition|)
block|{
name|SVN_ERR
argument_list|(
name|open_updated_file
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|close_updated_file
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|dir
operator|->
name|ref_count
operator|--
expr_stmt|;
block|}
comment|/* Otherwise, if the server is *not* in "send-all" mode, we          should be at a point where we can queue up any auxiliary          content-fetching requests.  */
else|else
block|{
name|SVN_ERR
argument_list|(
name|fetch_file
argument_list|(
name|ctx
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|TXDELTA
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"txdelta"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|report_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
comment|/* Pre 1.2, mod_dav_svn was using<txdelta> tags (in addition to<fetch-file>s and such) when *not* in "send-all" mode.  As a          client, we're smart enough to know that's wrong, so when not          in "receiving-all" mode, we'll ignore these tags. */
if|if
condition|(
name|ctx
operator|->
name|send_all_mode
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|info
operator|->
name|base64_decoder
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|PROP
condition|)
block|{
comment|/* We need to move the prop_ns, prop_name, and prop_value into the        * same lifetime as the dir->pool.        */
name|svn_ra_serf__ns_t
modifier|*
name|ns
decl_stmt|,
modifier|*
name|ns_name_match
decl_stmt|;
name|svn_boolean_t
name|found
init|=
name|FALSE
decl_stmt|;
name|report_info_t
modifier|*
name|info
decl_stmt|;
name|report_dir_t
modifier|*
name|dir
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|set_val_str
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|info
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
name|dir
operator|=
name|info
operator|->
name|dir
expr_stmt|;
comment|/* We're going to be slightly tricky.  We don't care what the ->url        * field is here at this point.  So, we're going to stick a single        * copy of the property name inside of the ->url field.        */
name|ns_name_match
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ns
operator|=
name|dir
operator|->
name|ns_list
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ns
operator|->
name|namespace
argument_list|,
name|info
operator|->
name|prop_ns
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ns_name_match
operator|=
name|ns
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
operator|->
name|url
argument_list|,
name|info
operator|->
name|prop_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|ns
operator|=
name|apr_palloc
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_name_match
condition|)
block|{
name|ns
operator|->
name|namespace
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|info
operator|->
name|prop_ns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|->
name|namespace
operator|=
name|ns_name_match
operator|->
name|namespace
expr_stmt|;
block|}
name|ns
operator|->
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|info
operator|->
name|prop_name
argument_list|)
expr_stmt|;
name|ns
operator|->
name|next
operator|=
name|dir
operator|->
name|ns_list
expr_stmt|;
name|dir
operator|->
name|ns_list
operator|=
name|ns
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"remove-prop"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|props
operator|=
name|info
operator|->
name|props
expr_stmt|;
name|pool
operator|=
name|info
operator|->
name|pool
expr_stmt|;
block|}
else|else
block|{
name|props
operator|=
name|dir
operator|->
name|removed_props
expr_stmt|;
name|pool
operator|=
name|dir
operator|->
name|pool
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|info
operator|->
name|prop_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|prop_encoding
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|info
operator|->
name|prop_encoding
argument_list|,
literal|"base64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_string_t
name|tmp
decl_stmt|;
comment|/* Don't use morph_info_string cuz we need prop_value to                  remain usable.  */
name|tmp
operator|.
name|data
operator|=
name|info
operator|->
name|prop_value
operator|->
name|data
expr_stmt|;
name|tmp
operator|.
name|len
operator|=
name|info
operator|->
name|prop_value
operator|->
name|len
expr_stmt|;
name|set_val_str
operator|=
name|svn_base64_decode_string
argument_list|(
operator|&
name|tmp
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Got unrecognized encoding '%s'"
argument_list|)
argument_list|,
name|info
operator|->
name|prop_encoding
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|set_val_str
operator|=
name|svn_string_create_from_buf
argument_list|(
name|info
operator|->
name|prop_value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|svn_ra_serf__set_ver_prop
argument_list|(
name|props
argument_list|,
name|info
operator|->
name|base_name
argument_list|,
name|info
operator|->
name|base_rev
argument_list|,
name|ns
operator|->
name|namespace
argument_list|,
name|ns
operator|->
name|url
argument_list|,
name|set_val_str
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Advance handling:  if we spotted the md5-checksum property on          the wire, remember it's value. */
if|if
condition|(
name|strcmp
argument_list|(
name|ns
operator|->
name|url
argument_list|,
literal|"md5-checksum"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|ns
operator|->
name|namespace
argument_list|,
name|SVN_DAV_PROP_NS_DAV
argument_list|)
operator|==
literal|0
condition|)
name|info
operator|->
name|final_checksum
operator|=
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|pool
argument_list|,
name|set_val_str
operator|->
name|data
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|IGNORE_PROP_NAME
operator|||
name|state
operator|==
name|NEED_PROP_NAME
condition|)
block|{
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cdata_report
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
name|UNUSED_CTX
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|state
operator|->
name|current_state
operator|==
name|PROP
condition|)
block|{
name|report_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|info
operator|->
name|prop_value
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parser
operator|->
name|state
operator|->
name|current_state
operator|==
name|TXDELTA
condition|)
block|{
comment|/* Pre 1.2, mod_dav_svn was using<txdelta> tags (in addition to<fetch-file>s and such) when *not* in "send-all" mode.  As a          client, we're smart enough to know that's wrong, so when not          in "receiving-all" mode, we'll ignore these tags. */
if|if
condition|(
name|ctx
operator|->
name|send_all_mode
condition|)
block|{
name|apr_size_t
name|nlen
init|=
name|len
decl_stmt|;
name|report_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|info
operator|->
name|base64_decoder
argument_list|,
name|data
argument_list|,
operator|&
name|nlen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlen
operator|!=
name|len
condition|)
block|{
comment|/* Short write without associated error?  "Can't happen." */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_STREAM_UNEXPECTED_EOF
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error writing to '%s': unexpected EOF"
argument_list|)
argument_list|,
name|info
operator|->
name|name
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Editor callbacks given to callers to create request body */
end_comment

begin_comment
comment|/* Helper to create simple xml tag without attributes. */
end_comment

begin_function
specifier|static
name|void
name|make_simple_xml_tag
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|buf_p
parameter_list|,
specifier|const
name|char
modifier|*
name|tagname
parameter_list|,
specifier|const
name|char
modifier|*
name|cdata
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_xml_make_open_tag
argument_list|(
name|buf_p
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
name|tagname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_xml_escape_cdata_cstring
argument_list|(
name|buf_p
argument_list|,
name|cdata
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
name|buf_p
argument_list|,
name|pool
argument_list|,
name|tagname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_path
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|report_baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
literal|"S:entry"
argument_list|,
literal|"rev"
argument_list|,
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|revision
argument_list|)
argument_list|,
literal|"lock-token"
argument_list|,
name|lock_token
argument_list|,
literal|"depth"
argument_list|,
name|svn_depth_to_word
argument_list|(
name|depth
argument_list|)
argument_list|,
literal|"start-empty"
argument_list|,
name|start_empty
condition|?
literal|"true"
else|:
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_xml_escape_cdata_cstring
argument_list|(
operator|&
name|buf
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|pool
argument_list|,
literal|"S:entry"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|report
operator|->
name|body_file
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_path
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|report_baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:missing"
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|report
operator|->
name|body_file
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|link_path
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|report_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|link
decl_stmt|,
modifier|*
name|report_target
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
comment|/* We need to pass in the baseline relative path.    *    * TODO Confirm that it's on the same server?    */
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|pool
argument_list|,
name|url
argument_list|,
operator|&
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to parse URL '%s'"
argument_list|)
argument_list|,
name|url
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_serf__report_resource
argument_list|(
operator|&
name|report_target
argument_list|,
name|report
operator|->
name|sess
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_relative_path
argument_list|(
operator|&
name|link
argument_list|,
name|uri
operator|.
name|path
argument_list|,
name|report
operator|->
name|sess
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|link
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
literal|"S:entry"
argument_list|,
literal|"rev"
argument_list|,
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|revision
argument_list|)
argument_list|,
literal|"lock-token"
argument_list|,
name|lock_token
argument_list|,
literal|"depth"
argument_list|,
name|svn_depth_to_word
argument_list|(
name|depth
argument_list|)
argument_list|,
literal|"linkpath"
argument_list|,
name|link
argument_list|,
literal|"start-empty"
argument_list|,
name|start_empty
condition|?
literal|"true"
else|:
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_xml_escape_cdata_cstring
argument_list|(
operator|&
name|buf
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|pool
argument_list|,
literal|"S:entry"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|report
operator|->
name|body_file
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the switch roots to allow generating repos_relpaths from just      the working copy paths. (Needed for HTTPv2) */
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|report
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|report
operator|->
name|switched_paths
argument_list|,
name|path
argument_list|,
name|apr_pstrdup
argument_list|(
name|report
operator|->
name|pool
argument_list|,
name|link
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|path
condition|)
name|report
operator|->
name|root_is_switched
operator|=
name|TRUE
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/** Minimum nr. of outstanding requests needed before a new connection is  *  opened. */
end_comment

begin_define
define|#
directive|define
name|REQS_PER_CONN
value|8
end_define

begin_comment
comment|/** This function creates a new connection for this serf session, but only  * if the number of NUM_ACTIVE_REQS> REQS_PER_CONN or if there currently is  * only one main connection open.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_connection_if_needed
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|int
name|num_active_reqs
parameter_list|)
block|{
comment|/* For each REQS_PER_CONN outstanding requests open a new connection, with    * a minimum of 1 extra connection. */
if|if
condition|(
name|sess
operator|->
name|num_conns
operator|==
literal|1
operator|||
operator|(
operator|(
name|num_active_reqs
operator|/
name|REQS_PER_CONN
operator|)
operator|>
name|sess
operator|->
name|num_conns
operator|)
condition|)
block|{
name|int
name|cur
init|=
name|sess
operator|->
name|num_conns
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|sess
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sess
operator|->
name|conns
index|[
name|cur
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|->
name|bkt_alloc
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|sess
operator|->
name|pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|->
name|last_status_code
operator|=
operator|-
literal|1
expr_stmt|;
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|->
name|session
operator|=
name|sess
expr_stmt|;
name|status
operator|=
name|serf_connection_create2
argument_list|(
operator|&
name|sess
operator|->
name|conns
index|[
name|cur
index|]
operator|->
name|conn
argument_list|,
name|sess
operator|->
name|context
argument_list|,
name|sess
operator|->
name|session_url
argument_list|,
name|svn_ra_serf__conn_setup
argument_list|,
name|sess
operator|->
name|conns
index|[
name|cur
index|]
argument_list|,
name|svn_ra_serf__conn_closed
argument_list|,
name|sess
operator|->
name|conns
index|[
name|cur
index|]
argument_list|,
name|sess
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
name|sess
operator|->
name|num_conns
operator|++
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Serf callback to create update request body bucket. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_update_report_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|body_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|baton
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|apr_file_seek
argument_list|(
name|report
operator|->
name|body_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
operator|*
name|body_bkt
operator|=
name|serf_bucket_file_create
argument_list|(
name|report
operator|->
name|body_file
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Serf callback to setup update request headers. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_update_report_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|report
operator|->
name|sess
operator|->
name|using_compression
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Accept-Encoding"
argument_list|,
literal|"gzip,svndiff1;q=0.9,svndiff;q=0.8"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Accept-Encoding"
argument_list|,
literal|"svndiff1;q=0.9,svndiff;q=0.8"
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|finish_report
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
init|=
name|report_baton
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|sess
init|=
name|report
operator|->
name|sess
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser_ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|report_target
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_interval_time_t
name|waittime_left
init|=
name|sess
operator|->
name|timeout
decl_stmt|;
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|iterpool
argument_list|,
literal|"S:update-report"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|report
operator|->
name|body_file
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to flush the file, make it unbuffered (so that it can be    * zero-copied via mmap), and reset the position before attempting to    * deliver the file.    *    * N.B. If we have APR 1.3+, we can unbuffer the file to let us use mmap    * and zero-copy the PUT body.  However, on older APR versions, we can't    * check the buffer status; but serf will fall through and create a file    * bucket for us on the buffered svndiff handle.    */
name|apr_file_flush
argument_list|(
name|report
operator|->
name|body_file
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|3
operator|,
literal|0
argument_list|)
name|apr_file_buffer_set
argument_list|(
name|report
operator|->
name|body_file
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|svn_ra_serf__report_resource
argument_list|(
operator|&
name|report_target
argument_list|,
name|sess
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create and deliver request */
name|report
operator|->
name|path
operator|=
name|report_target
expr_stmt|;
name|handler
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|->
name|handler_pool
operator|=
name|pool
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"REPORT"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|report
operator|->
name|path
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_update_report_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|report
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/xml"
expr_stmt|;
name|handler
operator|->
name|custom_accept_encoding
operator|=
name|TRUE
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_update_report_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|report
expr_stmt|;
name|handler
operator|->
name|conn
operator|=
name|sess
operator|->
name|conns
index|[
literal|0
index|]
expr_stmt|;
name|handler
operator|->
name|session
operator|=
name|sess
expr_stmt|;
name|parser_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|parser_ctx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|parser_ctx
operator|->
name|response_type
operator|=
literal|"update-report"
expr_stmt|;
name|parser_ctx
operator|->
name|user_data
operator|=
name|report
expr_stmt|;
name|parser_ctx
operator|->
name|start
operator|=
name|start_report
expr_stmt|;
name|parser_ctx
operator|->
name|end
operator|=
name|end_report
expr_stmt|;
name|parser_ctx
operator|->
name|cdata
operator|=
name|cdata_report
expr_stmt|;
name|parser_ctx
operator|->
name|done
operator|=
operator|&
name|report
operator|->
name|done
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__handle_xml_parser
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|parser_ctx
expr_stmt|;
name|report
operator|->
name|parser_ctx
operator|=
name|parser_ctx
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
comment|/* Open the first extra connection. */
name|SVN_ERR
argument_list|(
name|open_connection_if_needed
argument_list|(
name|sess
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sess
operator|->
name|cur_conn
operator|=
literal|1
expr_stmt|;
comment|/* Note that we may have no active GET or PROPFIND requests, yet the      processing has not been completed. This could be from a delay on the      network or because we've spooled the entire response into our "pending"      content of the XML parser. The DONE flag will get set when all the      XML content has been received *and* parsed.  */
while|while
condition|(
operator|!
name|report
operator|->
name|done
operator|||
name|report
operator|->
name|num_active_fetches
operator|||
name|report
operator|->
name|num_active_propfinds
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool_inner
decl_stmt|;
name|svn_ra_serf__list_t
modifier|*
name|done_list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* Note: this throws out the old ITERPOOL_INNER.  */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|sess
operator|->
name|cancel_func
argument_list|(
name|sess
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to be careful between the outer and inner ITERPOOLs,          and what items are allocated within.  */
name|iterpool_inner
operator|=
name|svn_pool_create
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|status
operator|=
name|serf_context_run
argument_list|(
name|sess
operator|->
name|context
argument_list|,
name|SVN_RA_SERF__CONTEXT_RUN_DURATION
argument_list|,
name|iterpool_inner
argument_list|)
expr_stmt|;
name|err
operator|=
name|sess
operator|->
name|pending_error
expr_stmt|;
name|sess
operator|->
name|pending_error
operator|=
name|SVN_NO_ERROR
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|handler
operator|->
name|done
operator|&&
name|handler
operator|->
name|server_error
condition|)
block|{
name|err
operator|=
name|handler
operator|->
name|server_error
operator|->
name|error
expr_stmt|;
block|}
comment|/* If the context duration timeout is up, we'll subtract that          duration from the total time alloted for such things.  If          there's no time left, we fail with a message indicating that          the connection timed out.  */
if|if
condition|(
name|APR_STATUS_IS_TIMEUP
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
name|waittime_left
operator|>
name|SVN_RA_SERF__CONTEXT_RUN_DURATION
condition|)
block|{
name|waittime_left
operator|-=
name|SVN_RA_SERF__CONTEXT_RUN_DURATION
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_CONN_TIMEOUT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Connection timed out"
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
name|waittime_left
operator|=
name|sess
operator|->
name|timeout
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&&
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|200
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|svn_ra_serf__error_on_status
argument_list|(
name|handler
operator|->
name|sline
argument_list|,
name|handler
operator|->
name|path
argument_list|,
name|handler
operator|->
name|location
argument_list|)
argument_list|,
name|err
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Error retrieving REPORT"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Open extra connections if we have enough requests to send. */
if|if
condition|(
name|sess
operator|->
name|num_conns
operator|<
name|sess
operator|->
name|max_connections
condition|)
name|SVN_ERR
argument_list|(
name|open_connection_if_needed
argument_list|(
name|sess
argument_list|,
name|report
operator|->
name|num_active_fetches
operator|+
name|report
operator|->
name|num_active_propfinds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prune completed file PROPFINDs. */
name|done_list
operator|=
name|report
operator|->
name|done_propfinds
expr_stmt|;
while|while
condition|(
name|done_list
condition|)
block|{
name|svn_ra_serf__list_t
modifier|*
name|next_done
init|=
name|done_list
operator|->
name|next
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool_inner
argument_list|)
expr_stmt|;
name|report
operator|->
name|num_active_propfinds
operator|--
expr_stmt|;
comment|/* If we have some files that we won't be fetching the content            * for, ensure that we update the file with any altered props.            */
if|if
condition|(
name|report
operator|->
name|file_propchanges_only
condition|)
block|{
name|svn_ra_serf__list_t
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
name|report
operator|->
name|file_propchanges_only
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
name|report_info_t
modifier|*
name|item
init|=
name|cur
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|propfind_handler
operator|==
name|done_list
operator|->
name|data
condition|)
block|{
break|break;
block|}
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
comment|/* If we found a match, set the new props and remove this                * propchange from our list.                */
if|if
condition|(
name|cur
condition|)
block|{
name|report_info_t
modifier|*
name|info
init|=
name|cur
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
block|{
name|report
operator|->
name|file_propchanges_only
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
comment|/* If we've got cached file content for this file,                      take care of the locally collected properties and                      file content at once.  Otherwise, just deal with                      the collected properties.                       NOTE:  These functions below could delete                      info->dir->pool (via maybe_close_dir_chain()),                      from which is allocated the list item in                      report->file_propchanges_only.                   */
if|if
condition|(
name|info
operator|->
name|cached_contents
condition|)
block|{
name|SVN_ERR
argument_list|(
name|handle_local_content
argument_list|(
name|info
argument_list|,
name|iterpool_inner
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|handle_propchange_only
argument_list|(
name|info
argument_list|,
name|iterpool_inner
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|done_list
operator|=
name|next_done
expr_stmt|;
block|}
name|report
operator|->
name|done_propfinds
operator|=
name|NULL
expr_stmt|;
comment|/* Prune completed fetches from our list. */
name|done_list
operator|=
name|report
operator|->
name|done_fetches
expr_stmt|;
while|while
condition|(
name|done_list
condition|)
block|{
name|report_fetch_t
modifier|*
name|done_fetch
init|=
name|done_list
operator|->
name|data
decl_stmt|;
name|svn_ra_serf__list_t
modifier|*
name|next_done
init|=
name|done_list
operator|->
name|next
decl_stmt|;
name|report_dir_t
modifier|*
name|cur_dir
decl_stmt|;
comment|/* Decrease the refcount in the parent directory of the file              whose fetch has completed. */
name|cur_dir
operator|=
name|done_fetch
operator|->
name|info
operator|->
name|dir
expr_stmt|;
name|cur_dir
operator|->
name|ref_count
operator|--
expr_stmt|;
comment|/* Decrement our active fetch count. */
name|report
operator|->
name|num_active_fetches
operator|--
expr_stmt|;
comment|/* See if the parent directory of this fetched item (and              perhaps even parents of that) can be closed now.               NOTE:  This could delete cur_dir->pool, from which is              allocated the list item in report->done_fetches.           */
name|SVN_ERR
argument_list|(
name|maybe_close_dir_chain
argument_list|(
name|cur_dir
argument_list|)
argument_list|)
expr_stmt|;
name|done_list
operator|=
name|next_done
expr_stmt|;
block|}
name|report
operator|->
name|done_fetches
operator|=
name|NULL
expr_stmt|;
comment|/* Prune completed directory PROPFINDs. */
name|done_list
operator|=
name|report
operator|->
name|done_dir_propfinds
expr_stmt|;
while|while
condition|(
name|done_list
condition|)
block|{
name|svn_ra_serf__list_t
modifier|*
name|next_done
init|=
name|done_list
operator|->
name|next
decl_stmt|;
name|report
operator|->
name|num_active_propfinds
operator|--
expr_stmt|;
if|if
condition|(
name|report
operator|->
name|active_dir_propfinds
condition|)
block|{
name|svn_ra_serf__list_t
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
name|report
operator|->
name|active_dir_propfinds
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
name|report_dir_t
modifier|*
name|item
init|=
name|cur
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|propfind_handler
operator|==
name|done_list
operator|->
name|data
condition|)
block|{
break|break;
block|}
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|cur
argument_list|)
expr_stmt|;
comment|/* we expect to find a matching propfind! */
comment|/* If we found a match, set the new props and remove this                * propchange from our list.                */
if|if
condition|(
name|cur
condition|)
block|{
name|report_dir_t
modifier|*
name|cur_dir
init|=
name|cur
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
block|{
name|report
operator|->
name|active_dir_propfinds
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
comment|/* See if this directory (and perhaps even parents of that)                      can be closed now.                       NOTE:  This could delete cur_dir->pool, from which is                      allocated the list item in report->active_dir_propfinds.                   */
name|SVN_ERR
argument_list|(
name|maybe_close_dir_chain
argument_list|(
name|cur_dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|done_list
operator|=
name|next_done
expr_stmt|;
block|}
name|report
operator|->
name|done_dir_propfinds
operator|=
name|NULL
expr_stmt|;
comment|/* If the parser is paused, and the number of active requests has          dropped far enough, then resume parsing.  */
if|if
condition|(
name|parser_ctx
operator|->
name|paused
operator|&&
operator|(
name|report
operator|->
name|num_active_fetches
operator|+
name|report
operator|->
name|num_active_propfinds
operator|<
name|REQUEST_COUNT_TO_RESUME
operator|)
condition|)
name|parser_ctx
operator|->
name|paused
operator|=
name|FALSE
expr_stmt|;
comment|/* If we have not paused the parser and it looks like data MAY be          present (we can't know for sure because of the private structure),          then go process the pending content.  */
if|if
condition|(
operator|!
name|parser_ctx
operator|->
name|paused
operator|&&
name|parser_ctx
operator|->
name|pending
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_serf__process_pending
argument_list|(
name|parser_ctx
argument_list|,
operator|&
name|report
operator|->
name|report_received
argument_list|,
name|iterpool_inner
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Debugging purposes only! */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sess
operator|->
name|num_conns
condition|;
name|i
operator|++
control|)
block|{
name|serf_debug__closed_conn
argument_list|(
name|sess
operator|->
name|conns
index|[
name|i
index|]
operator|->
name|bkt_alloc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we got a complete report, close the edit.  Otherwise, abort it. */
if|if
condition|(
name|report
operator|->
name|report_completed
condition|)
block|{
comment|/* Ensure that we opened and closed our root dir and that we closed        * all of our children. */
if|if
condition|(
operator|!
name|report
operator|->
name|closed_root
operator|&&
name|report
operator|->
name|root_dir
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|close_all_dirs
argument_list|(
name|report
operator|->
name|root_dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|report
operator|->
name|update_editor
operator|->
name|close_edit
argument_list|(
name|report
operator|->
name|update_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Tell the editor that something failed */
name|err
operator|=
name|report
operator|->
name|update_editor
operator|->
name|abort_edit
argument_list|(
name|report
operator|->
name|update_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Missing update-report close tag"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_report
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
literal|0
block|report_context_t *report = report_baton;
endif|#
directive|endif
comment|/* Should we perform some cleanup here? */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_reporter3_t
name|ra_serf_reporter
init|=
block|{
name|set_path
block|,
name|delete_path
block|,
name|link_path
block|,
name|finish_report
block|,
name|abort_report
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** RA function implementations and body */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_update_reporter
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|src_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dest_path
parameter_list|,
specifier|const
name|char
modifier|*
name|update_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|report_context_t
modifier|*
name|report
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|filter_editor
decl_stmt|;
name|void
modifier|*
name|filter_baton
decl_stmt|;
name|svn_boolean_t
name|has_target
init|=
operator|*
name|update_target
operator|!=
literal|'\0'
decl_stmt|;
name|svn_boolean_t
name|server_supports_depth
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|sess
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|use_bulk_updates
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|server_supports_depth
argument_list|,
name|SVN_RA_CAPABILITY_DEPTH
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can skip the depth filtering when the user requested      depth_files or depth_infinity because the server will      transmit the right stuff anyway. */
if|if
condition|(
operator|(
name|depth
operator|!=
name|svn_depth_files
operator|)
operator|&&
operator|(
name|depth
operator|!=
name|svn_depth_infinity
operator|)
operator|&&
operator|!
name|server_supports_depth
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_delta_depth_filter_editor
argument_list|(
operator|&
name|filter_editor
argument_list|,
operator|&
name|filter_baton
argument_list|,
name|update_editor
argument_list|,
name|update_baton
argument_list|,
name|depth
argument_list|,
name|has_target
argument_list|,
name|sess
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|update_editor
operator|=
name|filter_editor
expr_stmt|;
name|update_baton
operator|=
name|filter_baton
expr_stmt|;
block|}
name|report
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|report
argument_list|)
argument_list|)
expr_stmt|;
name|report
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|report
operator|->
name|sess
operator|=
name|sess
expr_stmt|;
name|report
operator|->
name|conn
operator|=
name|report
operator|->
name|sess
operator|->
name|conns
index|[
literal|0
index|]
expr_stmt|;
name|report
operator|->
name|target_rev
operator|=
name|revision
expr_stmt|;
name|report
operator|->
name|ignore_ancestry
operator|=
name|ignore_ancestry
expr_stmt|;
name|report
operator|->
name|send_copyfrom_args
operator|=
name|send_copyfrom_args
expr_stmt|;
name|report
operator|->
name|text_deltas
operator|=
name|text_deltas
expr_stmt|;
name|report
operator|->
name|switched_paths
operator|=
name|apr_hash_make
argument_list|(
name|report
operator|->
name|pool
argument_list|)
expr_stmt|;
name|report
operator|->
name|source
operator|=
name|src_path
expr_stmt|;
name|report
operator|->
name|destination
operator|=
name|dest_path
expr_stmt|;
name|report
operator|->
name|update_target
operator|=
name|update_target
expr_stmt|;
name|report
operator|->
name|update_editor
operator|=
name|update_editor
expr_stmt|;
name|report
operator|->
name|update_baton
operator|=
name|update_baton
expr_stmt|;
name|report
operator|->
name|done
operator|=
name|FALSE
expr_stmt|;
operator|*
name|reporter
operator|=
operator|&
name|ra_serf_reporter
expr_stmt|;
operator|*
name|report_baton
operator|=
name|report
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|report
operator|->
name|body_file
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|report
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|bulk_updates
operator|==
name|svn_tristate_true
condition|)
block|{
comment|/* User would like to use bulk updates. */
name|use_bulk_updates
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sess
operator|->
name|bulk_updates
operator|==
name|svn_tristate_false
condition|)
block|{
comment|/* User doesn't want bulk updates. */
name|use_bulk_updates
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* User doesn't have any preferences on bulk updates. Decide on server          preferences and capabilities. */
if|if
condition|(
name|sess
operator|->
name|server_allows_bulk
condition|)
block|{
if|if
condition|(
name|apr_strnatcasecmp
argument_list|(
name|sess
operator|->
name|server_allows_bulk
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Server doesn't want bulk updates */
name|use_bulk_updates
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_strnatcasecmp
argument_list|(
name|sess
operator|->
name|server_allows_bulk
argument_list|,
literal|"prefer"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Server prefers bulk updates, and we respect that */
name|use_bulk_updates
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Server allows bulk updates, but doesn't dictate its use. Do                  whatever is the default. */
name|use_bulk_updates
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Pre-1.8 server didn't send the bulk_updates header. Check if server              supports inlining properties in update editor report. */
if|if
condition|(
name|sess
operator|->
name|supports_inline_props
condition|)
block|{
comment|/* Inline props supported: do not use bulk updates. */
name|use_bulk_updates
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Inline props are not supported: use bulk updates to avoid                * PROPFINDs for every added node. */
name|use_bulk_updates
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|use_bulk_updates
condition|)
block|{
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|scratch_pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"S:update-report"
argument_list|,
literal|"xmlns:S"
argument_list|,
name|SVN_XML_NAMESPACE
argument_list|,
literal|"send-all"
argument_list|,
literal|"true"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|buf
argument_list|,
name|scratch_pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"S:update-report"
argument_list|,
literal|"xmlns:S"
argument_list|,
name|SVN_XML_NAMESPACE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Subversion 1.8+ servers can be told to send properties for newly          added items inline even when doing a skelta response. */
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:include-props"
argument_list|,
literal|"yes"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:src-path"
argument_list|,
name|report
operator|->
name|source
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|report
operator|->
name|target_rev
argument_list|)
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:target-revision"
argument_list|,
name|apr_ltoa
argument_list|(
name|scratch_pool
argument_list|,
name|report
operator|->
name|target_rev
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|report
operator|->
name|destination
operator|&&
operator|*
name|report
operator|->
name|destination
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:dst-path"
argument_list|,
name|report
operator|->
name|destination
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|report
operator|->
name|update_target
operator|&&
operator|*
name|report
operator|->
name|update_target
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:update-target"
argument_list|,
name|report
operator|->
name|update_target
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|report
operator|->
name|ignore_ancestry
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:ignore-ancestry"
argument_list|,
literal|"yes"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|report
operator|->
name|send_copyfrom_args
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:send-copyfrom-args"
argument_list|,
literal|"yes"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Old servers know "recursive" but not "depth"; help them DTRT. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|||
name|depth
operator|==
name|svn_depth_empty
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:recursive"
argument_list|,
literal|"no"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* When in 'send-all' mode, mod_dav_svn will assume that it should      calculate and transmit real text-deltas (instead of empty windows      that merely indicate "text is changed") unless it finds this      element.       NOTE: Do NOT count on servers actually obeying this, as some exist      which obey send-all, but do not check for this directive at all!       NOTE 2: When not in 'send-all' mode, mod_dav_svn can still be configured to      override our request and send text-deltas. */
if|if
condition|(
operator|!
name|text_deltas
condition|)
block|{
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:text-deltas"
argument_list|,
literal|"no"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|make_simple_xml_tag
argument_list|(
operator|&
name|buf
argument_list|,
literal|"S:depth"
argument_list|,
name|svn_depth_to_word
argument_list|(
name|depth
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|report
operator|->
name|body_file
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__do_update
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision_to_update_to
parameter_list|,
specifier|const
name|char
modifier|*
name|update_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_update_reporter
argument_list|(
name|ra_session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|revision_to_update_to
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|update_target
argument_list|,
name|depth
argument_list|,
name|ignore_ancestry
argument_list|,
name|TRUE
comment|/* text_deltas */
argument_list|,
name|send_copyfrom_args
argument_list|,
name|update_editor
argument_list|,
name|update_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__do_diff
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|diff_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
specifier|const
name|char
modifier|*
name|versus_url
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|diff_editor
parameter_list|,
name|void
modifier|*
name|diff_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_update_reporter
argument_list|(
name|ra_session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|revision
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|versus_url
argument_list|,
name|diff_target
argument_list|,
name|depth
argument_list|,
name|ignore_ancestry
argument_list|,
name|text_deltas
argument_list|,
name|FALSE
argument_list|,
name|diff_editor
argument_list|,
name|diff_baton
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__do_status
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|status_target
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|status_editor
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_update_reporter
argument_list|(
name|ra_session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|revision
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|status_target
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|status_editor
argument_list|,
name|status_baton
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__do_switch
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision_to_switch_to
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|switch_editor
parameter_list|,
name|void
modifier|*
name|switch_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
return|return
name|make_update_reporter
argument_list|(
name|ra_session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|revision_to_switch_to
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|switch_url
argument_list|,
name|switch_target
argument_list|,
name|depth
argument_list|,
name|ignore_ancestry
argument_list|,
name|TRUE
comment|/* text_deltas */
argument_list|,
name|send_copyfrom_args
argument_list|,
name|switch_editor
argument_list|,
name|switch_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper svn_ra_serf__get_file(). Attempts to fetch file contents  * using SESSION->wc_callbacks->get_wc_contents() if sha1 property is  * present in PROPS.  *  * Sets *FOUND_P to TRUE if file contents was successfuly fetched.  *  * Performs all temporary allocations in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|try_get_wc_contents
parameter_list|(
name|svn_boolean_t
modifier|*
name|found_p
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_stream_t
modifier|*
name|dst_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|svn_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|sha1_checksum_prop
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_stream_t
modifier|*
name|wc_stream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* No contents found by default. */
operator|*
name|found_p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
condition|)
block|{
comment|/* No callback, nothing to do. */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|svn_props
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_DAV_PROP_NS_DAV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_props
condition|)
block|{
comment|/* No properties -- therefore no checksum property -- in response. */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|sha1_checksum_prop
operator|=
name|svn_prop_get_value
argument_list|(
name|svn_props
argument_list|,
literal|"sha1-checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1_checksum_prop
operator|==
name|NULL
condition|)
block|{
comment|/* No checksum property in response. */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|sha1_checksum_prop
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|session
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
argument_list|(
name|session
operator|->
name|wc_callback_baton
argument_list|,
operator|&
name|wc_stream
argument_list|,
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Ignore errors for now. */
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|wc_stream
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|wc_stream
argument_list|,
name|svn_stream_disown
argument_list|(
name|dst_stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|found_p
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_file
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
specifier|const
name|char
modifier|*
name|fetch_url
decl_stmt|;
name|apr_hash_t
modifier|*
name|fetch_props
decl_stmt|;
name|svn_node_kind_t
name|res_kind
decl_stmt|;
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|which_props
decl_stmt|;
comment|/* What connection should we go on? */
name|conn
operator|=
name|session
operator|->
name|conns
index|[
name|session
operator|->
name|cur_conn
index|]
expr_stmt|;
comment|/* Fetch properties. */
name|fetch_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* The simple case is if we want HEAD - then a GET on the fetch_url is fine.    *    * Otherwise, we need to get the baseline version for this particular    * revision and then fetch that file.    */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
operator|||
name|fetched_rev
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|fetch_url
argument_list|,
name|fetched_rev
argument_list|,
name|session
argument_list|,
name|conn
argument_list|,
name|fetch_url
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* REVISION is always SVN_INVALID_REVNUM  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
condition|)
block|{
name|which_props
operator|=
name|all_props
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stream
operator|&&
name|session
operator|->
name|wc_callbacks
operator|->
name|get_wc_contents
condition|)
block|{
name|which_props
operator|=
name|type_and_checksum_props
expr_stmt|;
block|}
else|else
block|{
name|which_props
operator|=
name|check_path_props
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_node_props
argument_list|(
operator|&
name|fetch_props
argument_list|,
name|conn
argument_list|,
name|fetch_url
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|which_props
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify that resource type is not collection. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_resource_type
argument_list|(
operator|&
name|res_kind
argument_list|,
name|fetch_props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_kind
operator|!=
name|svn_node_file
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get text contents of a directory"
argument_list|)
argument_list|)
return|;
block|}
comment|/* TODO Filter out all of our props into a usable format. */
if|if
condition|(
name|props
condition|)
block|{
comment|/* ### flatten_props() does not copy PROPVALUE, but fetch_node_props()          ### put them into POOL, so we're okay.  */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__flatten_props
argument_list|(
name|props
argument_list|,
name|fetch_props
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stream
condition|)
block|{
name|svn_boolean_t
name|found
decl_stmt|;
name|SVN_ERR
argument_list|(
name|try_get_wc_contents
argument_list|(
operator|&
name|found
argument_list|,
name|session
argument_list|,
name|fetch_props
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No contents found in the WC, let's fetch from server. */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|report_fetch_t
modifier|*
name|stream_ctx
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* Create the fetch context. */
name|stream_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|stream_ctx
operator|->
name|target_stream
operator|=
name|stream
expr_stmt|;
name|stream_ctx
operator|->
name|sess
operator|=
name|session
expr_stmt|;
name|stream_ctx
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|stream_ctx
operator|->
name|info
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream_ctx
operator|->
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|stream_ctx
operator|->
name|info
operator|->
name|name
operator|=
name|fetch_url
expr_stmt|;
name|handler
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|->
name|handler_pool
operator|=
name|pool
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"GET"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|fetch_url
expr_stmt|;
name|handler
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|handler
operator|->
name|session
operator|=
name|session
expr_stmt|;
name|handler
operator|->
name|custom_accept_encoding
operator|=
name|TRUE
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|headers_fetch
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|stream_ctx
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|handle_stream
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|stream_ctx
expr_stmt|;
name|handler
operator|->
name|response_error
operator|=
name|cancel_fetch
expr_stmt|;
name|handler
operator|->
name|response_error_baton
operator|=
name|stream_ctx
expr_stmt|;
name|stream_ctx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_wait
argument_list|(
operator|&
name|stream_ctx
operator|->
name|done
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

