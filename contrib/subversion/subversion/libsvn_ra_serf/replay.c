begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * replay.c :  entry point for replay RA functions for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * This enum represents the current state of our XML parsing.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|replay_state_e
block|{
name|INITIAL
init|=
name|XML_STATE_INITIAL
block|,
name|REPLAY_REPORT
block|,
name|REPLAY_TARGET_REVISION
block|,
name|REPLAY_OPEN_ROOT
block|,
name|REPLAY_OPEN_DIRECTORY
block|,
name|REPLAY_OPEN_FILE
block|,
name|REPLAY_ADD_DIRECTORY
block|,
name|REPLAY_ADD_FILE
block|,
name|REPLAY_DELETE_ENTRY
block|,
name|REPLAY_CLOSE_FILE
block|,
name|REPLAY_CLOSE_DIRECTORY
block|,
name|REPLAY_CHANGE_DIRECTORY_PROP
block|,
name|REPLAY_CHANGE_FILE_PROP
block|,
name|REPLAY_APPLY_TEXTDELTA
block|}
name|replay_state_e
typedef|;
end_typedef

begin_define
define|#
directive|define
name|S_
value|SVN_XML_NAMESPACE
end_define

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_serf__xml_transition_t
name|replay_ttable
index|[]
init|=
block|{
block|{
name|INITIAL
block|,
name|S_
block|,
literal|"editor-report"
block|,
name|REPLAY_REPORT
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
comment|/* Replay just throws every operation as xml element directly      in the replay report, so we can't really use the nice exit      handling of the transition parser to handle clean callbacks */
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"target-revision"
block|,
name|REPLAY_TARGET_REVISION
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"open-root"
block|,
name|REPLAY_OPEN_ROOT
block|,
name|FALSE
block|,
block|{
literal|"rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"open-directory"
block|,
name|REPLAY_OPEN_DIRECTORY
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
literal|"rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"open-file"
block|,
name|REPLAY_OPEN_FILE
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
literal|"rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"add-directory"
block|,
name|REPLAY_ADD_DIRECTORY
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"add-file"
block|,
name|REPLAY_ADD_FILE
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
literal|"?copyfrom-path"
block|,
literal|"?copyfrom-rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"delete-entry"
block|,
name|REPLAY_DELETE_ENTRY
block|,
name|FALSE
block|,
block|{
literal|"name"
block|,
literal|"rev"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"close-file"
block|,
name|REPLAY_CLOSE_FILE
block|,
name|FALSE
block|,
block|{
literal|"?checksum"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"close-directory"
block|,
name|REPLAY_CLOSE_DIRECTORY
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"change-dir-prop"
block|,
name|REPLAY_CHANGE_DIRECTORY_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
literal|"?del"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"change-file-prop"
block|,
name|REPLAY_CHANGE_FILE_PROP
block|,
name|TRUE
block|,
block|{
literal|"name"
block|,
literal|"?del"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|REPLAY_REPORT
block|,
name|S_
block|,
literal|"apply-textdelta"
block|,
name|REPLAY_APPLY_TEXTDELTA
block|,
name|FALSE
block|,
block|{
literal|"?checksum"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per directory/file state */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|replay_node_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* pool allocating this node's data */
name|svn_boolean_t
name|file
decl_stmt|;
comment|/* file or dir */
name|void
modifier|*
name|baton
decl_stmt|;
comment|/* node baton */
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* stream while handling txdata */
name|struct
name|replay_node_t
modifier|*
name|parent
decl_stmt|;
comment|/* parent node or NULL */
block|}
name|replay_node_t
typedef|;
end_typedef

begin_comment
comment|/* Per revision replay report state */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|revision_report_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* per revision pool */
name|struct
name|replay_node_t
modifier|*
name|current_node
decl_stmt|;
name|struct
name|replay_node_t
modifier|*
name|root_node
decl_stmt|;
comment|/* Are we done fetching this file?      Handles book-keeping in multi-report case */
name|svn_boolean_t
modifier|*
name|done
decl_stmt|;
name|int
modifier|*
name|replay_reports
decl_stmt|;
comment|/* NULL or number of outstanding reports */
comment|/* callback to get an editor */
name|svn_ra_replay_revstart_callback_t
name|revstart_func
decl_stmt|;
name|svn_ra_replay_revfinish_callback_t
name|revfinish_func
decl_stmt|;
name|void
modifier|*
name|replay_baton
decl_stmt|;
comment|/* replay receiver function and baton */
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|editor_baton
decl_stmt|;
comment|/* Path and revision used to filter replayed changes.  If      INCLUDE_PATH is non-NULL, REVISION is unnecessary and will not be      included in the replay REPORT.  (Because the REPORT is being      aimed an HTTP v2 revision resource.)  */
specifier|const
name|char
modifier|*
name|include_path
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* Information needed to create the replay report body */
name|svn_revnum_t
name|low_water_mark
decl_stmt|;
name|svn_boolean_t
name|send_deltas
decl_stmt|;
comment|/* Target and revision to fetch revision properties on */
specifier|const
name|char
modifier|*
name|revprop_target
decl_stmt|;
name|svn_revnum_t
name|revprop_rev
decl_stmt|;
comment|/* Revision properties for this revision. */
name|apr_hash_t
modifier|*
name|rev_props
decl_stmt|;
comment|/* Handlers for the PROPFIND and REPORT for the current revision. */
name|svn_ra_serf__handler_t
modifier|*
name|propfind_handler
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|report_handler
decl_stmt|;
comment|/* For done handler */
block|}
name|revision_report_t
typedef|;
end_typedef

begin_comment
comment|/* Conforms to svn_ra_serf__xml_opened_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_opened
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|entered_state
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|tag
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_report_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|entered_state
operator|==
name|REPLAY_REPORT
condition|)
block|{
comment|/* Before we can continue, we need the revision properties. */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|ctx
operator|->
name|propfind_handler
operator|||
name|ctx
operator|->
name|propfind_handler
operator|->
name|done
argument_list|)
expr_stmt|;
name|svn_ra_serf__keep_only_regular_props
argument_list|(
name|ctx
operator|->
name|rev_props
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|revstart_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|revstart_func
argument_list|(
name|ctx
operator|->
name|revision
argument_list|,
name|ctx
operator|->
name|replay_baton
argument_list|,
operator|&
name|ctx
operator|->
name|editor
argument_list|,
operator|&
name|ctx
operator|->
name|editor_baton
argument_list|,
name|ctx
operator|->
name|rev_props
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entered_state
operator|==
name|REPLAY_APPLY_TEXTDELTA
condition|)
block|{
name|struct
name|replay_node_t
modifier|*
name|node
init|=
name|ctx
operator|->
name|current_node
decl_stmt|;
name|apr_hash_t
modifier|*
name|attrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|checksum
decl_stmt|;
name|svn_txdelta_window_handler_t
name|handler
decl_stmt|;
name|void
modifier|*
name|handler_baton
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|||
operator|!
name|node
operator|->
name|file
operator|||
name|node
operator|->
name|stream
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* ### Is there a better way to access a specific attr here? */
name|attrs
operator|=
name|svn_ra_serf__xml_gather_since
argument_list|(
name|xes
argument_list|,
name|REPLAY_APPLY_TEXTDELTA
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"checksum"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|node
operator|->
name|baton
argument_list|,
name|checksum
argument_list|,
name|node
operator|->
name|pool
argument_list|,
operator|&
name|handler
argument_list|,
operator|&
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|!=
name|svn_delta_noop_window_handler
condition|)
block|{
name|node
operator|->
name|stream
operator|=
name|svn_base64_decode
argument_list|(
name|svn_txdelta_parse_svndiff
argument_list|(
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|TRUE
argument_list|,
name|node
operator|->
name|pool
argument_list|)
argument_list|,
name|node
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_closed_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_closed
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|leaving_state
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|cdata
parameter_list|,
name|apr_hash_t
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_report_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_REPORT
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|current_node
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|ctx
operator|->
name|revfinish_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|revfinish_func
argument_list|(
name|ctx
operator|->
name|revision
argument_list|,
name|ctx
operator|->
name|replay_baton
argument_list|,
name|ctx
operator|->
name|editor
argument_list|,
name|ctx
operator|->
name|editor_baton
argument_list|,
name|ctx
operator|->
name|rev_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_TARGET_REVISION
condition|)
block|{
specifier|const
name|char
modifier|*
name|revstr
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"rev"
argument_list|)
decl_stmt|;
name|apr_int64_t
name|rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|rev
argument_list|,
name|revstr
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|set_target_revision
argument_list|(
name|ctx
operator|->
name|editor_baton
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_OPEN_ROOT
condition|)
block|{
specifier|const
name|char
modifier|*
name|revstr
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"rev"
argument_list|)
decl_stmt|;
name|apr_int64_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|root_pool
init|=
name|svn_pool_create
argument_list|(
name|ctx
operator|->
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|current_node
operator|||
name|ctx
operator|->
name|root_node
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|ctx
operator|->
name|root_node
operator|=
name|apr_pcalloc
argument_list|(
name|root_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
operator|->
name|root_node
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|root_node
operator|->
name|pool
operator|=
name|root_pool
expr_stmt|;
name|ctx
operator|->
name|current_node
operator|=
name|ctx
operator|->
name|root_node
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|rev
argument_list|,
name|revstr
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|open_root
argument_list|(
name|ctx
operator|->
name|editor_baton
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|rev
argument_list|,
name|root_pool
argument_list|,
operator|&
name|ctx
operator|->
name|current_node
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_OPEN_DIRECTORY
operator|||
name|leaving_state
operator|==
name|REPLAY_OPEN_FILE
operator|||
name|leaving_state
operator|==
name|REPLAY_ADD_DIRECTORY
operator|||
name|leaving_state
operator|==
name|REPLAY_ADD_FILE
condition|)
block|{
name|struct
name|replay_node_t
modifier|*
name|node
decl_stmt|;
name|apr_pool_t
modifier|*
name|node_pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_str
decl_stmt|;
name|apr_int64_t
name|rev
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|current_node
operator|||
name|ctx
operator|->
name|current_node
operator|->
name|file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|node_pool
operator|=
name|svn_pool_create
argument_list|(
name|ctx
operator|->
name|current_node
operator|->
name|pool
argument_list|)
expr_stmt|;
name|node
operator|=
name|apr_pcalloc
argument_list|(
name|node_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|pool
operator|=
name|node_pool
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|ctx
operator|->
name|current_node
expr_stmt|;
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_OPEN_DIRECTORY
operator|||
name|leaving_state
operator|==
name|REPLAY_OPEN_FILE
condition|)
block|{
name|rev_str
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"rev"
argument_list|)
expr_stmt|;
block|}
else|else
name|rev_str
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"copyfrom-rev"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev_str
condition|)
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|rev
argument_list|,
name|rev_str
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
switch|switch
condition|(
name|leaving_state
condition|)
block|{
case|case
name|REPLAY_OPEN_DIRECTORY
case|:
name|node
operator|->
name|file
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|open_directory
argument_list|(
name|name
argument_list|,
name|ctx
operator|->
name|current_node
operator|->
name|baton
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|rev
argument_list|,
name|node
operator|->
name|pool
argument_list|,
operator|&
name|node
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLAY_OPEN_FILE
case|:
name|node
operator|->
name|file
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|open_file
argument_list|(
name|name
argument_list|,
name|ctx
operator|->
name|current_node
operator|->
name|baton
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|rev
argument_list|,
name|node
operator|->
name|pool
argument_list|,
operator|&
name|node
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLAY_ADD_DIRECTORY
case|:
name|node
operator|->
name|file
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|add_directory
argument_list|(
name|name
argument_list|,
name|ctx
operator|->
name|current_node
operator|->
name|baton
argument_list|,
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|?
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"copyfrom-path"
argument_list|)
else|:
name|NULL
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|rev
argument_list|,
name|node
operator|->
name|pool
argument_list|,
operator|&
name|node
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLAY_ADD_FILE
case|:
name|node
operator|->
name|file
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|add_file
argument_list|(
name|name
argument_list|,
name|ctx
operator|->
name|current_node
operator|->
name|baton
argument_list|,
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|?
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"copyfrom-path"
argument_list|)
else|:
name|NULL
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|rev
argument_list|,
name|node
operator|->
name|pool
argument_list|,
operator|&
name|node
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* default: unreachable */
block|}
name|ctx
operator|->
name|current_node
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_CLOSE_FILE
condition|)
block|{
name|struct
name|replay_node_t
modifier|*
name|node
init|=
name|ctx
operator|->
name|current_node
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|||
operator|!
name|node
operator|->
name|file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|close_file
argument_list|(
name|node
operator|->
name|baton
argument_list|,
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"checksum"
argument_list|)
argument_list|,
name|node
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|current_node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|node
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_CLOSE_DIRECTORY
condition|)
block|{
name|struct
name|replay_node_t
modifier|*
name|node
init|=
name|ctx
operator|->
name|current_node
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|||
name|node
operator|->
name|file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|close_directory
argument_list|(
name|node
operator|->
name|baton
argument_list|,
name|node
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|current_node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|node
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_DELETE_ENTRY
condition|)
block|{
name|struct
name|replay_node_t
modifier|*
name|parent_node
init|=
name|ctx
operator|->
name|current_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|revstr
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"rev"
argument_list|)
decl_stmt|;
name|apr_int64_t
name|rev
decl_stmt|;
if|if
condition|(
operator|!
name|parent_node
operator|||
name|parent_node
operator|->
name|file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|rev
argument_list|,
name|revstr
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|delete_entry
argument_list|(
name|name
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|rev
argument_list|,
name|parent_node
operator|->
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_CHANGE_FILE_PROP
operator|||
name|leaving_state
operator|==
name|REPLAY_CHANGE_DIRECTORY_PROP
condition|)
block|{
name|struct
name|replay_node_t
modifier|*
name|node
init|=
name|ctx
operator|->
name|current_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|||
name|node
operator|->
name|file
operator|!=
operator|(
name|leaving_state
operator|==
name|REPLAY_CHANGE_FILE_PROP
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|name
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"del"
argument_list|)
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
else|else
name|value
operator|=
name|svn_base64_decode_string
argument_list|(
name|cdata
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|node
operator|->
name|baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|node
operator|->
name|baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|REPLAY_APPLY_TEXTDELTA
condition|)
block|{
name|struct
name|replay_node_t
modifier|*
name|node
init|=
name|ctx
operator|->
name|current_node
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|||
operator|!
name|node
operator|->
name|file
operator|||
operator|!
name|node
operator|->
name|stream
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|node
operator|->
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_cdata_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_cdata
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|current_state
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_report_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|current_state
operator|==
name|REPLAY_APPLY_TEXTDELTA
condition|)
block|{
name|struct
name|replay_node_t
modifier|*
name|node
init|=
name|ctx
operator|->
name|current_node
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|||
operator|!
name|node
operator|->
name|file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|node
operator|->
name|stream
condition|)
block|{
name|apr_size_t
name|written
init|=
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|node
operator|->
name|stream
argument_list|,
name|data
argument_list|,
operator|&
name|written
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|!=
name|len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_UNEXPECTED_EOF
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error writing stream: unexpected EOF"
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__request_body_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_replay_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_report_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|serf_bucket_t
modifier|*
name|body_bkt
decl_stmt|;
name|body_bkt
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"S:replay-report"
argument_list|,
literal|"xmlns:S"
argument_list|,
name|SVN_XML_NAMESPACE
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
comment|/* If we have a non-NULL include path, we add it to the body and      omit the revision; otherwise, the reverse. */
if|if
condition|(
name|ctx
operator|->
name|include_path
condition|)
block|{
name|svn_ra_serf__add_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
literal|"S:include-path"
argument_list|,
name|ctx
operator|->
name|include_path
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_ra_serf__add_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
literal|"S:revision"
argument_list|,
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|ctx
operator|->
name|revision
argument_list|)
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|svn_ra_serf__add_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
literal|"S:low-water-mark"
argument_list|,
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|ctx
operator|->
name|low_water_mark
argument_list|)
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
literal|"S:send-deltas"
argument_list|,
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|ctx
operator|->
name|send_deltas
argument_list|)
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"S:replay-report"
argument_list|)
expr_stmt|;
operator|*
name|bkt
operator|=
name|body_bkt
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__replay
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_report_t
name|ctx
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|report_target
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__report_resource
argument_list|(
operator|&
name|report_target
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|editor
operator|=
name|editor
expr_stmt|;
name|ctx
operator|.
name|editor_baton
operator|=
name|edit_baton
expr_stmt|;
name|ctx
operator|.
name|done
operator|=
name|FALSE
expr_stmt|;
name|ctx
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|ctx
operator|.
name|low_water_mark
operator|=
name|low_water_mark
expr_stmt|;
name|ctx
operator|.
name|send_deltas
operator|=
name|send_deltas
expr_stmt|;
name|ctx
operator|.
name|rev_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|xmlctx
operator|=
name|svn_ra_serf__xml_context_create
argument_list|(
name|replay_ttable
argument_list|,
name|replay_opened
argument_list|,
name|replay_closed
argument_list|,
name|replay_cdata
argument_list|,
operator|&
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_expat_handler
argument_list|(
name|session
argument_list|,
name|xmlctx
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"REPORT"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_replay_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
operator|&
name|ctx
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/xml"
expr_stmt|;
comment|/* Not setting up done handler as we don't use a global context */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__error_on_status
argument_list|(
name|handler
operator|->
name|sline
argument_list|,
name|handler
operator|->
name|path
argument_list|,
name|handler
operator|->
name|location
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The maximum number of outstanding requests at any time. When this  * number is reached, ra_serf will stop sending requests until  * responses on the previous requests are received and handled.  *  * Some observations about serf which lead us to the current value.  * ----------------------------------------------------------------  *  * We aim to keep serf's outgoing queue filled with enough requests so  * the network bandwidth and server capacity is used  * optimally. Originally we used 5 as the max. number of outstanding  * requests, but this turned out to be too low.  *  * Serf doesn't exit out of the svn_ra_serf__context_run_wait loop as long as  * it has data to send or receive. With small responses (revs of a few  * kB), serf doesn't come out of this loop at all. So with  * MAX_OUTSTANDING_REQUESTS set to a low number, there's a big chance  * that serf handles those requests completely in its internal loop,  * and only then gives us a chance to create new requests. This  * results in hiccups, slowing down the whole process.  *  * With a larger MAX_OUTSTANDING_REQUESTS, like 100 or more, there's  * more chance that serf can come out of its internal loop so we can  * replenish the outgoing request queue.  There's no real disadvantage  * of using a large number here, besides the memory used to store the  * message, parser and handler objects (approx. 250 bytes).  *  * In my test setup peak performance was reached at max. 30-35  * requests. So I added a small margin and chose 50.  */
end_comment

begin_define
define|#
directive|define
name|MAX_OUTSTANDING_REQUESTS
value|50
end_define

begin_comment
comment|/* Implements svn_ra_serf__response_done_delegate_t for svn_ra_serf__replay_range */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_done
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|revision_report_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|ctx
operator|->
name|report_handler
decl_stmt|;
if|if
condition|(
name|handler
operator|->
name|server_error
condition|)
return|return
name|svn_ra_serf__server_error_create
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
return|;
elseif|else
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|200
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
operator|*
name|ctx
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
comment|/* Breaks out svn_ra_serf__context_run_wait */
comment|/* Are re replaying multiple revisions? */
if|if
condition|(
name|ctx
operator|->
name|replay_reports
condition|)
block|{
operator|(
operator|*
name|ctx
operator|->
name|replay_reports
operator|)
operator|--
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Destroys handler and request! */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__replay_range
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
name|svn_ra_replay_revstart_callback_t
name|revstart_func
parameter_list|,
name|svn_ra_replay_revfinish_callback_t
name|revfinish_func
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_revnum_t
name|rev
init|=
name|start_revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|report_target
decl_stmt|;
name|int
name|active_reports
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|include_path
decl_stmt|;
name|svn_boolean_t
name|done
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__report_resource
argument_list|(
operator|&
name|report_target
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prior to 1.8, mod_dav_svn expect to get replay REPORT requests      aimed at the session URL.  But that's incorrect -- these reports      aren't about specific resources -- they are above revisions.  The      path-based filtering offered by this API is just that: a filter      applied to the full set of changes made in the revision.  As      such, the correct target for these REPORT requests is the "me      resource" (or, pre-http-v2, the default VCC).       Our server should have told us if it supported this protocol      correction.  If so, we aimed our report at the correct resource      and include the filtering path as metadata within the report      body.  Otherwise, we fall back to the pre-1.8 behavior and just      wish for the best.       See issue #4287:      http://subversion.tigris.org/issues/show_bug.cgi?id=4287   */
if|if
condition|(
name|session
operator|->
name|supports_rev_rsrc_replay
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_relative_path
argument_list|(
operator|&
name|include_path
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|include_path
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|active_reports
operator|||
name|rev
operator|<=
name|end_revision
condition|)
block|{
if|if
condition|(
name|session
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|session
operator|->
name|cancel_func
argument_list|(
name|session
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send pending requests, if any. Limit the number of outstanding          requests to MAX_OUTSTANDING_REQUESTS. */
if|if
condition|(
name|rev
operator|<=
name|end_revision
operator|&&
name|active_reports
operator|<
name|MAX_OUTSTANDING_REQUESTS
condition|)
block|{
name|struct
name|revision_report_t
modifier|*
name|rev_ctx
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|apr_pool_t
modifier|*
name|rev_pool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|replay_target
decl_stmt|;
name|rev_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|rev_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rev_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|rev_ctx
operator|->
name|pool
operator|=
name|rev_pool
expr_stmt|;
name|rev_ctx
operator|->
name|revstart_func
operator|=
name|revstart_func
expr_stmt|;
name|rev_ctx
operator|->
name|revfinish_func
operator|=
name|revfinish_func
expr_stmt|;
name|rev_ctx
operator|->
name|replay_baton
operator|=
name|replay_baton
expr_stmt|;
name|rev_ctx
operator|->
name|done
operator|=
operator|&
name|done
expr_stmt|;
name|rev_ctx
operator|->
name|replay_reports
operator|=
operator|&
name|active_reports
expr_stmt|;
name|rev_ctx
operator|->
name|include_path
operator|=
name|include_path
expr_stmt|;
name|rev_ctx
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|rev_ctx
operator|->
name|low_water_mark
operator|=
name|low_water_mark
expr_stmt|;
name|rev_ctx
operator|->
name|send_deltas
operator|=
name|send_deltas
expr_stmt|;
comment|/* Request all properties of a certain revision. */
name|rev_ctx
operator|->
name|rev_props
operator|=
name|apr_hash_make
argument_list|(
name|rev_ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
block|{
name|rev_ctx
operator|->
name|revprop_target
operator|=
name|apr_psprintf
argument_list|(
name|rev_pool
argument_list|,
literal|"%s/%ld"
argument_list|,
name|session
operator|->
name|rev_stub
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|rev_ctx
operator|->
name|revprop_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
name|rev_ctx
operator|->
name|revprop_target
operator|=
name|report_target
expr_stmt|;
name|rev_ctx
operator|->
name|revprop_rev
operator|=
name|rev
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|rev_ctx
operator|->
name|propfind_handler
argument_list|,
name|session
argument_list|,
name|rev_ctx
operator|->
name|revprop_target
argument_list|,
name|rev_ctx
operator|->
name|revprop_rev
argument_list|,
literal|"0"
argument_list|,
name|all_props
argument_list|,
name|svn_ra_serf__deliver_svn_props
argument_list|,
name|rev_ctx
operator|->
name|rev_props
argument_list|,
name|rev_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Spin up the serf request for the PROPFIND.  */
name|svn_ra_serf__request_create
argument_list|(
name|rev_ctx
operator|->
name|propfind_handler
argument_list|)
expr_stmt|;
comment|/* Send the replay REPORT request. */
if|if
condition|(
name|session
operator|->
name|supports_rev_rsrc_replay
condition|)
block|{
name|replay_target
operator|=
name|apr_psprintf
argument_list|(
name|rev_pool
argument_list|,
literal|"%s/%ld"
argument_list|,
name|session
operator|->
name|rev_stub
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|replay_target
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
block|}
name|xmlctx
operator|=
name|svn_ra_serf__xml_context_create
argument_list|(
name|replay_ttable
argument_list|,
name|replay_opened
argument_list|,
name|replay_closed
argument_list|,
name|replay_cdata
argument_list|,
name|rev_ctx
argument_list|,
name|rev_pool
argument_list|)
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_expat_handler
argument_list|(
name|session
argument_list|,
name|xmlctx
argument_list|,
name|NULL
argument_list|,
name|rev_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"REPORT"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|replay_target
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_replay_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|rev_ctx
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/xml"
expr_stmt|;
name|handler
operator|->
name|done_delegate
operator|=
name|replay_done
expr_stmt|;
name|handler
operator|->
name|done_delegate_baton
operator|=
name|rev_ctx
expr_stmt|;
name|rev_ctx
operator|->
name|report_handler
operator|=
name|handler
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|rev
operator|++
expr_stmt|;
name|active_reports
operator|++
expr_stmt|;
block|}
comment|/* Run the serf loop. */
name|done
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_wait
argument_list|(
operator|&
name|done
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The done handler of reports decrements active_reports when a report          is done. This same handler reports (fatal) report errors, so we can          just loop here. */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MAX_OUTSTANDING_REQUESTS
end_undef

end_unit

