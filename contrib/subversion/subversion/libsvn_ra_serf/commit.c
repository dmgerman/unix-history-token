begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * commit.c :  entry point for commit RA functions for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_comment
comment|/* Baton passed back with the commit editor. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|commit_context_t
block|{
comment|/* Pool for our commit. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
decl_stmt|;
name|apr_hash_t
modifier|*
name|revprop_table
decl_stmt|;
name|svn_commit_callback2_t
name|callback
decl_stmt|;
name|void
modifier|*
name|callback_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|lock_tokens
decl_stmt|;
name|svn_boolean_t
name|keep_locks
decl_stmt|;
name|apr_hash_t
modifier|*
name|deleted_entries
decl_stmt|;
comment|/* deleted files (for delete+add detection) */
comment|/* HTTP v2 stuff */
specifier|const
name|char
modifier|*
name|txn_url
decl_stmt|;
comment|/* txn URL (!svn/txn/TXN_NAME) */
specifier|const
name|char
modifier|*
name|txn_root_url
decl_stmt|;
comment|/* commit anchor txn root URL */
comment|/* HTTP v1 stuff (only valid when 'txn_url' is NULL) */
specifier|const
name|char
modifier|*
name|activity_url
decl_stmt|;
comment|/* activity base URL... */
specifier|const
name|char
modifier|*
name|baseline_url
decl_stmt|;
comment|/* the working-baseline resource */
specifier|const
name|char
modifier|*
name|checked_in_url
decl_stmt|;
comment|/* checked-in root to base CHECKOUTs from */
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
comment|/* vcc url */
block|}
name|commit_context_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|USING_HTTPV2_COMMIT_SUPPORT
parameter_list|(
name|commit_ctx
parameter_list|)
value|((commit_ctx)->txn_url != NULL)
end_define

begin_comment
comment|/* Structure associated with a PROPPATCH request. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|proppatch_context_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|commit_context_t
modifier|*
name|commit_ctx
decl_stmt|;
comment|/* Changed properties. const char * -> svn_prop_t * */
name|apr_hash_t
modifier|*
name|prop_changes
decl_stmt|;
comment|/* Same, for the old value, or NULL. */
name|apr_hash_t
modifier|*
name|old_props
decl_stmt|;
comment|/* In HTTP v2, this is the file/directory version we think we're changing. */
name|svn_revnum_t
name|base_revision
decl_stmt|;
block|}
name|proppatch_context_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|delete_context_t
block|{
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|commit_context_t
modifier|*
name|commit_ctx
decl_stmt|;
block|}
name|delete_context_t
typedef|;
end_typedef

begin_comment
comment|/* Represents a directory. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dir_context_t
block|{
comment|/* Pool for our directory. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The root commit we're in progress for. */
name|commit_context_t
modifier|*
name|commit_ctx
decl_stmt|;
comment|/* URL to operate against (used for CHECKOUT and PROPPATCH before      HTTP v2, for PROPPATCH in HTTP v2).  */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
comment|/* How many pending changes we have left in this directory. */
name|unsigned
name|int
name|ref_count
decl_stmt|;
comment|/* Is this directory being added?  (Otherwise, just opened.) */
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* Our parent */
name|struct
name|dir_context_t
modifier|*
name|parent_dir
decl_stmt|;
comment|/* The directory name; if "", we're the 'root' */
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
comment|/* The basename of the directory. "" for the 'root' */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The base revision of the dir. */
name|svn_revnum_t
name|base_revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_path
decl_stmt|;
name|svn_revnum_t
name|copy_revision
decl_stmt|;
comment|/* Changed properties (const char * -> svn_prop_t *) */
name|apr_hash_t
modifier|*
name|prop_changes
decl_stmt|;
comment|/* The checked-out working resource for this directory.  May be NULL; if so      call checkout_dir() first.  */
specifier|const
name|char
modifier|*
name|working_url
decl_stmt|;
block|}
name|dir_context_t
typedef|;
end_typedef

begin_comment
comment|/* Represents a file to be committed. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|file_context_t
block|{
comment|/* Pool for our file. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The root commit we're in progress for. */
name|commit_context_t
modifier|*
name|commit_ctx
decl_stmt|;
comment|/* Is this file being added?  (Otherwise, just opened.) */
name|svn_boolean_t
name|added
decl_stmt|;
name|dir_context_t
modifier|*
name|parent_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The checked-out working resource for this file. */
specifier|const
name|char
modifier|*
name|working_url
decl_stmt|;
comment|/* The base revision of the file. */
name|svn_revnum_t
name|base_revision
decl_stmt|;
comment|/* Copy path and revision */
specifier|const
name|char
modifier|*
name|copy_path
decl_stmt|;
name|svn_revnum_t
name|copy_revision
decl_stmt|;
comment|/* stream */
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* Temporary file containing the svndiff. */
name|apr_file_t
modifier|*
name|svndiff
decl_stmt|;
comment|/* Our base checksum as reported by the WC. */
specifier|const
name|char
modifier|*
name|base_checksum
decl_stmt|;
comment|/* Our resulting checksum as reported by the WC. */
specifier|const
name|char
modifier|*
name|result_checksum
decl_stmt|;
comment|/* Changed properties (const char * -> svn_prop_t *) */
name|apr_hash_t
modifier|*
name|prop_changes
decl_stmt|;
comment|/* URL to PUT the file at. */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
block|}
name|file_context_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Setup routines and handlers for various requests we'll invoke. */
end_comment

begin_comment
comment|/* Implements svn_ra_serf__request_body_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_checkout_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|activity_url
init|=
name|baton
decl_stmt|;
name|serf_bucket_t
modifier|*
name|body_bkt
decl_stmt|;
name|body_bkt
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_xml_header_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:checkout"
argument_list|,
literal|"xmlns:D"
argument_list|,
literal|"DAV:"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:activity-set"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:href"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|activity_url
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_cdata_len_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
name|activity_url
argument_list|,
name|strlen
argument_list|(
name|activity_url
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:href"
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:activity-set"
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_empty_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:apply-to-version"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:checkout"
argument_list|)
expr_stmt|;
operator|*
name|bkt
operator|=
name|body_bkt
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Using the HTTPv1 protocol, perform a CHECKOUT of NODE_URL within the    given COMMIT_CTX. The resulting working resource will be returned in    *WORKING_URL, allocated from RESULT_POOL. All temporary allocations    are performed in SCRATCH_POOL.     ### are these URLs actually repos relpath values? or fspath? or maybe    ### the abspath portion of the full URL.     This function operates synchronously.     Strictly speaking, we could perform "all" of the CHECKOUT requests    when the commit starts, and only block when we need a specific    answer. Or, at a minimum, send off these individual requests async    and block when we need the answer (eg PUT or PROPPATCH).     However: the investment to speed this up is not worthwhile, given    that CHECKOUT (and the related round trip) is completely obviated    in HTTPv2. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|checkout_node
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|working_url
parameter_list|,
specifier|const
name|commit_context_t
modifier|*
name|commit_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|node_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
comment|/* HANDLER_POOL is the scratch pool since we don't need to remember      anything from the handler. We just want the working resource.  */
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|commit_ctx
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_checkout_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
operator|(
comment|/* const */
name|void
operator|*
operator|)
name|commit_ctx
operator|->
name|activity_url
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/xml"
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"CHECKOUT"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|node_url
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|201
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|handler
operator|->
name|location
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No Location header received"
argument_list|)
argument_list|)
return|;
comment|/* We only want the path portion of the Location header.      (code.google.com sometimes returns an 'http:' scheme for an      'https:' transaction ... we'll work around that by stripping the      scheme, host, and port here and re-adding the correct ones      later.  */
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|scratch_pool
argument_list|,
name|handler
operator|->
name|location
argument_list|,
operator|&
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error parsing Location header value"
argument_list|)
argument_list|)
return|;
operator|*
name|working_url
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|uri
operator|.
name|path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is a wrapper around checkout_node() (which see for    documentation) which simply retries the CHECKOUT request when it    fails due to an SVN_ERR_APMOD_BAD_BASELINE error return from the    server.     See http://subversion.tigris.org/issues/show_bug.cgi?id=4127 for    details. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|retry_checkout_node
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|working_url
parameter_list|,
specifier|const
name|commit_context_t
modifier|*
name|commit_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|node_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|int
name|retry_count
init|=
literal|5
decl_stmt|;
comment|/* Magic, arbitrary number. */
do|do
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|checkout_node
argument_list|(
name|working_url
argument_list|,
name|commit_ctx
argument_list|,
name|node_url
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* There's a small chance of a race condition here if Apache is          experiencing heavy commit concurrency or if the network has          long latency.  It's possible that the value of HEAD changed          between the time we fetched the latest baseline and the time          we try to CHECKOUT that baseline.  If that happens, Apache          will throw us a BAD_BASELINE error (deltaV says you can only          checkout the latest baseline).  We just ignore that specific          error and retry a few times, asking for the latest baseline          again. */
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_APMOD_BAD_BASELINE
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
do|while
condition|(
name|err
operator|&&
name|retry_count
operator|--
condition|)
do|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|checkout_dir
parameter_list|(
name|dir_context_t
modifier|*
name|dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|c_dir
init|=
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|checkout_url
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|working
decl_stmt|;
if|if
condition|(
name|dir
operator|->
name|working_url
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Is this directory or one of our parent dirs newly added?    * If so, we're already implicitly checked out. */
while|while
condition|(
name|c_dir
condition|)
block|{
if|if
condition|(
name|c_dir
operator|->
name|added
condition|)
block|{
comment|/* Calculate the working_url by skipping the shared ancestor between            * the c_dir_parent->relpath and dir->relpath. This is safe since an            * add is guaranteed to have a parent that is checked out. */
name|dir_context_t
modifier|*
name|c_dir_parent
init|=
name|c_dir
operator|->
name|parent_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_relpath_skip_ancestor
argument_list|(
name|c_dir_parent
operator|->
name|relpath
argument_list|,
name|dir
operator|->
name|relpath
argument_list|)
decl_stmt|;
comment|/* Implicitly checkout this dir now. */
name|SVN_ERR_ASSERT
argument_list|(
name|c_dir_parent
operator|->
name|working_url
argument_list|)
expr_stmt|;
name|dir
operator|->
name|working_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|c_dir_parent
operator|->
name|working_url
argument_list|,
name|relpath
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|c_dir
operator|=
name|c_dir
operator|->
name|parent_dir
expr_stmt|;
block|}
comment|/* We could be called twice for the root: once to checkout the baseline;    * once to checkout the directory itself if we need to do so.    * Note: CHECKOUT_URL should live longer than HANDLER.    */
if|if
condition|(
operator|!
name|dir
operator|->
name|parent_dir
operator|&&
operator|!
name|dir
operator|->
name|commit_ctx
operator|->
name|baseline_url
condition|)
block|{
name|checkout_url
operator|=
name|dir
operator|->
name|commit_ctx
operator|->
name|vcc_url
expr_stmt|;
name|working
operator|=
operator|&
name|dir
operator|->
name|commit_ctx
operator|->
name|baseline_url
expr_stmt|;
block|}
else|else
block|{
name|checkout_url
operator|=
name|dir
operator|->
name|url
expr_stmt|;
name|working
operator|=
operator|&
name|dir
operator|->
name|working_url
expr_stmt|;
block|}
comment|/* Checkout our directory into the activity URL now. */
return|return
name|svn_error_trace
argument_list|(
name|retry_checkout_node
argument_list|(
name|working
argument_list|,
name|dir
operator|->
name|commit_ctx
argument_list|,
name|checkout_url
argument_list|,
name|dir
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *CHECKED_IN_URL to the appropriate DAV version url for  * RELPATH (relative to the root of SESSION).  *  * Try to find this version url in three ways:  * First, if SESSION->callbacks->get_wc_prop() is defined, try to read the  * version url from the working copy properties.  * Second, if the version url of the parent directory PARENT_VSN_URL is  * defined, set *CHECKED_IN_URL to the concatenation of PARENT_VSN_URL with  * RELPATH.  * Else, fetch the version url for the root of SESSION using CONN and  * BASE_REVISION, and set *CHECKED_IN_URL to the concatenation of that  * with RELPATH.  *  * Allocate the result in RESULT_POOL, and use SCRATCH_POOL for  * temporary allocation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_version_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|checked_in_url
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_vsn_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|root_checkout
decl_stmt|;
if|if
condition|(
name|session
operator|->
name|wc_callbacks
operator|->
name|get_wc_prop
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|current_version
decl_stmt|;
name|SVN_ERR
argument_list|(
name|session
operator|->
name|wc_callbacks
operator|->
name|get_wc_prop
argument_list|(
name|session
operator|->
name|wc_callback_baton
argument_list|,
name|relpath
argument_list|,
name|SVN_RA_SERF__WC_CHECKED_IN_URL
argument_list|,
operator|&
name|current_version
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_version
condition|)
block|{
operator|*
name|checked_in_url
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|current_version
operator|->
name|data
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
name|parent_vsn_url
condition|)
block|{
name|root_checkout
operator|=
name|parent_vsn_url
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|propfind_url
decl_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
block|{
comment|/* mod_dav_svn can't handle the "Label:" header that              svn_ra_serf__deliver_props() is going to try to use for              this lookup, so we'll do things the hard(er) way, by              looking up the version URL from a resource in the              baseline collection. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|propfind_url
argument_list|,
name|NULL
comment|/* latest_revnum */
argument_list|,
name|session
argument_list|,
name|NULL
comment|/* url */
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|propfind_url
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_dav_prop
argument_list|(
operator|&
name|root_checkout
argument_list|,
name|session
argument_list|,
name|propfind_url
argument_list|,
name|base_revision
argument_list|,
literal|"checked-in"
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root_checkout
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' not present"
argument_list|)
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|)
return|;
name|root_checkout
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|root_checkout
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|checked_in_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|root_checkout
argument_list|,
name|relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|checkout_file
parameter_list|(
name|file_context_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|parent_dir
init|=
name|file
operator|->
name|parent_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|checkout_url
decl_stmt|;
comment|/* Is one of our parent dirs newly added?  If so, we're already    * implicitly checked out.    */
while|while
condition|(
name|parent_dir
condition|)
block|{
if|if
condition|(
name|parent_dir
operator|->
name|added
condition|)
block|{
comment|/* Implicitly checkout this file now. */
name|SVN_ERR_ASSERT
argument_list|(
name|parent_dir
operator|->
name|working_url
argument_list|)
expr_stmt|;
name|file
operator|->
name|working_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|parent_dir
operator|->
name|working_url
argument_list|,
name|svn_relpath_skip_ancestor
argument_list|(
name|parent_dir
operator|->
name|relpath
argument_list|,
name|file
operator|->
name|relpath
argument_list|)
argument_list|,
name|file
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|parent_dir
operator|=
name|parent_dir
operator|->
name|parent_dir
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|get_version_url
argument_list|(
operator|&
name|checkout_url
argument_list|,
name|file
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|file
operator|->
name|relpath
argument_list|,
name|file
operator|->
name|base_revision
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Checkout our file into the activity URL now. */
return|return
name|svn_error_trace
argument_list|(
name|retry_checkout_node
argument_list|(
operator|&
name|file
operator|->
name|working_url
argument_list|,
name|file
operator|->
name|commit_ctx
argument_list|,
name|checkout_url
argument_list|,
name|file
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for proppatch_walker() below. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_encoding_and_cdata
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|encoding_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|encoded_value_p
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
operator|*
name|encoding_p
operator|=
name|NULL
expr_stmt|;
operator|*
name|encoded_value_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If a property is XML-safe, XML-encode it.  Else, base64-encode      it. */
if|if
condition|(
name|svn_xml_is_xml_safe
argument_list|(
name|value
operator|->
name|data
argument_list|,
name|value
operator|->
name|len
argument_list|)
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|xml_esc
init|=
name|NULL
decl_stmt|;
name|svn_xml_escape_cdata_string
argument_list|(
operator|&
name|xml_esc
argument_list|,
name|value
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|encoding_p
operator|=
name|NULL
expr_stmt|;
operator|*
name|encoded_value_p
operator|=
name|svn_string_create_from_buf
argument_list|(
name|xml_esc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|encoding_p
operator|=
literal|"base64"
expr_stmt|;
operator|*
name|encoded_value_p
operator|=
name|svn_base64_encode_string2
argument_list|(
name|value
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for create_proppatch_body. Writes per property xml to body */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_prop_xml
parameter_list|(
specifier|const
name|proppatch_context_t
modifier|*
name|proppatch
parameter_list|,
name|serf_bucket_t
modifier|*
name|body_bkt
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
specifier|const
name|svn_prop_t
modifier|*
name|prop
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|cdata_bkt
decl_stmt|;
specifier|const
name|char
modifier|*
name|encoding
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|encoded_value
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
specifier|const
name|svn_prop_t
modifier|*
name|old_prop
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_encoding_and_cdata
argument_list|(
operator|&
name|encoding
argument_list|,
operator|&
name|encoded_value
argument_list|,
name|alloc
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded_value
condition|)
block|{
name|cdata_bkt
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
name|encoded_value
operator|->
name|data
argument_list|,
name|encoded_value
operator|->
name|len
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cdata_bkt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Use the namespace prefix instead of adding the xmlns attribute to support      property names containing ':' */
if|if
condition|(
name|strncmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_PROP_PREFIX
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prop_name
operator|=
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
literal|"S:"
argument_list|,
name|prop
operator|->
name|name
operator|+
sizeof|sizeof
argument_list|(
name|SVN_PROP_PREFIX
argument_list|)
operator|-
literal|1
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prop_name
operator|=
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
literal|"C:"
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdata_bkt
condition|)
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
name|prop_name
argument_list|,
literal|"V:encoding"
argument_list|,
name|encoding
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
else|else
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
name|prop_name
argument_list|,
literal|"V:"
name|SVN_DAV__OLD_VALUE__ABSENT
argument_list|,
literal|"1"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|old_prop
operator|=
name|proppatch
operator|->
name|old_props
condition|?
name|svn_hash_gets
argument_list|(
name|proppatch
operator|->
name|old_props
argument_list|,
name|prop
operator|->
name|name
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|old_prop
condition|)
block|{
specifier|const
name|char
modifier|*
name|encoding2
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|encoded_value2
decl_stmt|;
name|serf_bucket_t
modifier|*
name|cdata_bkt2
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_encoding_and_cdata
argument_list|(
operator|&
name|encoding2
argument_list|,
operator|&
name|encoded_value2
argument_list|,
name|alloc
argument_list|,
name|old_prop
operator|->
name|value
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded_value2
condition|)
block|{
name|cdata_bkt2
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
name|encoded_value2
operator|->
name|data
argument_list|,
name|encoded_value2
operator|->
name|len
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cdata_bkt2
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cdata_bkt2
condition|)
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"V:"
name|SVN_DAV__OLD_VALUE
argument_list|,
literal|"V:encoding"
argument_list|,
name|encoding2
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
else|else
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"V:"
name|SVN_DAV__OLD_VALUE
argument_list|,
literal|"V:"
name|SVN_DAV__OLD_VALUE__ABSENT
argument_list|,
literal|"1"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdata_bkt2
condition|)
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|cdata_bkt2
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"V:"
name|SVN_DAV__OLD_VALUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdata_bkt
condition|)
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|cdata_bkt
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Possible add the lock-token "If:" precondition header to HEADERS if    an examination of COMMIT_CTX and RELPATH indicates that this is the    right thing to do.     Generally speaking, if the client provided a lock token for    RELPATH, it's the right thing to do.  There is a notable instance    where this is not the case, however.  If the file at RELPATH was    explicitly deleted in this commit already, then mod_dav removed its    lock token when it fielded the DELETE request, so we don't want to    set the lock precondition again.  (See    http://subversion.tigris.org/issues/show_bug.cgi?id=3674 for details.) */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_set_lock_token_header
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|commit_context_t
modifier|*
name|commit_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|relpath
operator|&&
name|commit_ctx
operator|->
name|lock_tokens
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|commit_ctx
operator|->
name|deleted_entries
argument_list|,
name|relpath
argument_list|)
condition|)
block|{
name|token
operator|=
name|svn_hash_gets
argument_list|(
name|commit_ctx
operator|->
name|lock_tokens
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
condition|)
block|{
specifier|const
name|char
modifier|*
name|token_header
decl_stmt|;
specifier|const
name|char
modifier|*
name|token_uri
decl_stmt|;
name|apr_uri_t
name|uri
init|=
name|commit_ctx
operator|->
name|session
operator|->
name|session_url
decl_stmt|;
comment|/* Supplying the optional URI affects apache response when              the lock is broken, see issue 4369.  When present any URI              must be absolute (RFC 2518 9.4). */
name|uri
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|svn_path_url_add_component2
argument_list|(
name|uri
operator|.
name|path
argument_list|,
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|token_uri
operator|=
name|apr_uri_unparse
argument_list|(
name|pool
argument_list|,
operator|&
name|uri
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|token_header
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"<"
argument_list|,
name|token_uri
argument_list|,
literal|"> (<"
argument_list|,
name|token
argument_list|,
literal|">)"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
literal|"If"
argument_list|,
name|token_header
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_proppatch_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|proppatch_context_t
modifier|*
name|proppatch
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|proppatch
operator|->
name|base_revision
argument_list|)
condition|)
block|{
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_VERSION_NAME_HEADER
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|proppatch
operator|->
name|base_revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proppatch
operator|->
name|relpath
operator|&&
name|proppatch
operator|->
name|commit_ctx
condition|)
name|SVN_ERR
argument_list|(
name|maybe_set_lock_token_header
argument_list|(
name|headers
argument_list|,
name|proppatch
operator|->
name|commit_ctx
argument_list|,
name|proppatch
operator|->
name|relpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__request_body_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_proppatch_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|proppatch_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|serf_bucket_t
modifier|*
name|body_bkt
decl_stmt|;
name|svn_boolean_t
name|opened
init|=
name|FALSE
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|body_bkt
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_xml_header_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:propertyupdate"
argument_list|,
literal|"xmlns:D"
argument_list|,
literal|"DAV:"
argument_list|,
literal|"xmlns:V"
argument_list|,
name|SVN_DAV_PROP_NS_DAV
argument_list|,
literal|"xmlns:C"
argument_list|,
name|SVN_DAV_PROP_NS_CUSTOM
argument_list|,
literal|"xmlns:S"
argument_list|,
name|SVN_DAV_PROP_NS_SVN
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
comment|/* First we write property SETs */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|ctx
operator|->
name|prop_changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|->
name|value
operator|||
operator|(
name|ctx
operator|->
name|old_props
operator|&&
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|old_props
argument_list|,
name|prop
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|opened
condition|)
block|{
name|opened
operator|=
name|TRUE
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:set"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:prop"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|write_prop_xml
argument_list|(
name|ctx
argument_list|,
name|body_bkt
argument_list|,
name|alloc
argument_list|,
name|prop
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opened
condition|)
block|{
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:prop"
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:set"
argument_list|)
expr_stmt|;
block|}
comment|/* And then property REMOVEs */
name|opened
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|ctx
operator|->
name|prop_changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|value
operator|&&
operator|!
operator|(
name|ctx
operator|->
name|old_props
operator|&&
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|old_props
argument_list|,
name|prop
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|opened
condition|)
block|{
name|opened
operator|=
name|TRUE
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:remove"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:prop"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|write_prop_xml
argument_list|(
name|ctx
argument_list|,
name|body_bkt
argument_list|,
name|alloc
argument_list|,
name|prop
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opened
condition|)
block|{
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:prop"
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:remove"
argument_list|)
expr_stmt|;
block|}
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"D:propertyupdate"
argument_list|)
expr_stmt|;
operator|*
name|bkt
operator|=
name|body_bkt
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|proppatch_resource
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|proppatch_context_t
modifier|*
name|proppatch
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|session
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"PROPPATCH"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|proppatch
operator|->
name|path
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_proppatch_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|proppatch
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_proppatch_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|proppatch
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__handle_multistatus_only
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
name|err
operator|=
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|207
condition|)
name|err
operator|=
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use specific error code for property handling errors.      Use loop to provide the right result with tracing */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_REQUEST_FAILED
condition|)
block|{
name|svn_error_t
modifier|*
name|e
init|=
name|err
decl_stmt|;
while|while
condition|(
name|e
operator|&&
name|e
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_REQUEST_FAILED
condition|)
block|{
name|e
operator|->
name|apr_err
operator|=
name|SVN_ERR_RA_DAV_PROPPATCH_FAILED
expr_stmt|;
name|e
operator|=
name|e
operator|->
name|child
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__request_body_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_put_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|body_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|file_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
comment|/* We need to flush the file, make it unbuffered (so that it can be    * zero-copied via mmap), and reset the position before attempting to    * deliver the file.    *    * N.B. If we have APR 1.3+, we can unbuffer the file to let us use mmap    * and zero-copy the PUT body.  However, on older APR versions, we can't    * check the buffer status; but serf will fall through and create a file    * bucket for us on the buffered svndiff handle.    */
name|SVN_ERR
argument_list|(
name|svn_io_file_flush
argument_list|(
name|ctx
operator|->
name|svndiff
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_file_buffer_set
argument_list|(
name|ctx
operator|->
name|svndiff
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|ctx
operator|->
name|svndiff
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|body_bkt
operator|=
name|serf_bucket_file_create
argument_list|(
name|ctx
operator|->
name|svndiff
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__request_body_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_empty_put_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|body_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|body_bkt
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
literal|""
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_put_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|file_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|ctx
operator|->
name|base_revision
argument_list|)
condition|)
block|{
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_VERSION_NAME_HEADER
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|ctx
operator|->
name|base_revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|base_checksum
condition|)
block|{
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_BASE_FULLTEXT_MD5_HEADER
argument_list|,
name|ctx
operator|->
name|base_checksum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|result_checksum
condition|)
block|{
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_RESULT_FULLTEXT_MD5_HEADER
argument_list|,
name|ctx
operator|->
name|result_checksum
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|maybe_set_lock_token_header
argument_list|(
name|headers
argument_list|,
name|ctx
operator|->
name|commit_ctx
argument_list|,
name|ctx
operator|->
name|relpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_copy_file_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|file_context_t
modifier|*
name|file
init|=
name|baton
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
specifier|const
name|char
modifier|*
name|absolute_uri
decl_stmt|;
comment|/* The Dest URI must be absolute.  Bummer. */
name|uri
operator|=
name|file
operator|->
name|commit_ctx
operator|->
name|session
operator|->
name|session_url
expr_stmt|;
name|uri
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|file
operator|->
name|url
expr_stmt|;
name|absolute_uri
operator|=
name|apr_uri_unparse
argument_list|(
name|pool
argument_list|,
operator|&
name|uri
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
literal|"Destination"
argument_list|,
name|absolute_uri
argument_list|)
expr_stmt|;
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Overwrite"
argument_list|,
literal|"F"
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_if_header_recursive
parameter_list|(
name|svn_boolean_t
modifier|*
name|added
parameter_list|,
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|commit_context_t
modifier|*
name|commit_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|rq_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|sb
init|=
name|NULL
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|commit_ctx
operator|->
name|lock_tokens
condition|)
block|{
operator|*
name|added
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We try to create a directory, so within the Subversion world that      would imply that there is nothing here, but mod_dav_svn still sees      locks on the old nodes here as in DAV it is perfectly legal to lock      something that is not there...       Let's make mod_dav, mod_dav_svn and the DAV RFC happy by providing      the locks we know of with the request */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|commit_ctx
operator|->
name|lock_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
if|if
condition|(
operator|!
name|svn_relpath_skip_ancestor
argument_list|(
name|rq_relpath
argument_list|,
name|relpath
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|commit_ctx
operator|->
name|deleted_entries
argument_list|,
name|relpath
argument_list|)
condition|)
block|{
comment|/* When a path is already explicit deleted then its lock              will be removed by mod_dav. But mod_dav doesn't remove              locks on descendants */
continue|continue;
block|}
if|if
condition|(
operator|!
name|iterpool
condition|)
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
name|sb
operator|=
name|svn_stringbuf_create
argument_list|(
literal|""
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_appendbyte
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|uri
operator|=
name|commit_ctx
operator|->
name|session
operator|->
name|session_url
expr_stmt|;
name|uri
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|svn_path_url_add_component2
argument_list|(
name|uri
operator|.
name|path
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|sb
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
name|apr_uri_unparse
argument_list|(
name|iterpool
argument_list|,
operator|&
name|uri
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
literal|"> (<"
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
literal|">)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iterpool
condition|)
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
condition|)
block|{
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
literal|"If"
argument_list|,
name|sb
operator|->
name|data
argument_list|)
expr_stmt|;
operator|*
name|added
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
operator|*
name|added
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_add_dir_common_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|dir
init|=
name|baton
decl_stmt|;
name|svn_boolean_t
name|added
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|setup_if_header_recursive
argument_list|(
operator|&
name|added
argument_list|,
name|headers
argument_list|,
name|dir
operator|->
name|commit_ctx
argument_list|,
name|dir
operator|->
name|relpath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_copy_dir_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|dir
init|=
name|baton
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
specifier|const
name|char
modifier|*
name|absolute_uri
decl_stmt|;
comment|/* The Dest URI must be absolute.  Bummer. */
name|uri
operator|=
name|dir
operator|->
name|commit_ctx
operator|->
name|session
operator|->
name|session_url
expr_stmt|;
if|if
condition|(
name|USING_HTTPV2_COMMIT_SUPPORT
argument_list|(
name|dir
operator|->
name|commit_ctx
argument_list|)
condition|)
block|{
name|uri
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|dir
operator|->
name|url
expr_stmt|;
block|}
else|else
block|{
name|uri
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|svn_path_url_add_component2
argument_list|(
name|dir
operator|->
name|parent_dir
operator|->
name|working_url
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|absolute_uri
operator|=
name|apr_uri_unparse
argument_list|(
name|pool
argument_list|,
operator|&
name|uri
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
literal|"Destination"
argument_list|,
name|absolute_uri
argument_list|)
expr_stmt|;
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Depth"
argument_list|,
literal|"infinity"
argument_list|)
expr_stmt|;
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Overwrite"
argument_list|,
literal|"F"
argument_list|)
expr_stmt|;
comment|/* Implicitly checkout this dir now. */
name|dir
operator|->
name|working_url
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|uri
operator|.
name|path
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|setup_add_dir_common_headers
argument_list|(
name|headers
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_delete_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|delete_context_t
modifier|*
name|del
init|=
name|baton
decl_stmt|;
name|svn_boolean_t
name|added
decl_stmt|;
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_VERSION_NAME_HEADER
argument_list|,
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|del
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|setup_if_header_recursive
argument_list|(
operator|&
name|added
argument_list|,
name|headers
argument_list|,
name|del
operator|->
name|commit_ctx
argument_list|,
name|del
operator|->
name|relpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
operator|&&
name|del
operator|->
name|commit_ctx
operator|->
name|keep_locks
condition|)
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_OPTIONS_HEADER
argument_list|,
name|SVN_DAV_OPTION_KEEP_LOCKS
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* POST against 'me' resource handlers. */
end_comment

begin_comment
comment|/* Implements svn_ra_serf__request_body_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_txn_post_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|body_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|revprops
init|=
name|baton
decl_stmt|;
name|svn_skel_t
modifier|*
name|request_skel
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|skel_str
decl_stmt|;
name|request_skel
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|revprops
condition|)
block|{
name|svn_skel_t
modifier|*
name|proplist_skel
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|proplist_skel
argument_list|,
name|revprops
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|proplist_skel
argument_list|,
name|request_skel
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
literal|"create-txn-with-props"
argument_list|,
name|request_skel
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|skel_str
operator|=
name|svn_skel__unparse
argument_list|(
name|request_skel
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|body_bkt
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|skel_str
operator|->
name|data
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|body_bkt
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
literal|"( create-txn )"
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__request_header_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_post_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_DAV_SEND_VTXN_NAME
comment|/* Enable this to exercise the VTXN-NAME code based on a client      supplied transaction name. */
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_VTXN_NAME_HEADER
argument_list|,
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handler baton for POST request. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|post_response_ctx_t
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|commit_context_t
modifier|*
name|commit_ctx
decl_stmt|;
block|}
name|post_response_ctx_t
typedef|;
end_typedef

begin_comment
comment|/* This implements serf_bucket_headers_do_callback_fn_t.   */
end_comment

begin_function
specifier|static
name|int
name|post_headers_iterator_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|post_response_ctx_t
modifier|*
name|prc
init|=
name|baton
decl_stmt|;
name|commit_context_t
modifier|*
name|prc_cc
init|=
name|prc
operator|->
name|commit_ctx
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|sess
init|=
name|prc_cc
operator|->
name|session
decl_stmt|;
comment|/* If we provided a UUID to the POST request, we should get back      from the server an SVN_DAV_VTXN_NAME_HEADER header; otherwise we      expect the SVN_DAV_TXN_NAME_HEADER.  We certainly don't expect to      see both. */
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
name|key
argument_list|,
name|SVN_DAV_TXN_NAME_HEADER
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Build out txn and txn-root URLs using the txn name we're          given, and store the whole lot of it in the commit context.  */
name|prc_cc
operator|->
name|txn_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|sess
operator|->
name|txn_stub
argument_list|,
name|val
argument_list|,
name|prc_cc
operator|->
name|pool
argument_list|)
expr_stmt|;
name|prc_cc
operator|->
name|txn_root_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|sess
operator|->
name|txn_root_stub
argument_list|,
name|val
argument_list|,
name|prc_cc
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
name|key
argument_list|,
name|SVN_DAV_VTXN_NAME_HEADER
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Build out vtxn and vtxn-root URLs using the vtxn name we're          given, and store the whole lot of it in the commit context.  */
name|prc_cc
operator|->
name|txn_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|sess
operator|->
name|vtxn_stub
argument_list|,
name|val
argument_list|,
name|prc_cc
operator|->
name|pool
argument_list|)
expr_stmt|;
name|prc_cc
operator|->
name|txn_root_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|sess
operator|->
name|vtxn_root_stub
argument_list|,
name|val
argument_list|,
name|prc_cc
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A custom serf_response_handler_t which is mostly a wrapper around    svn_ra_serf__expect_empty_body -- it just notices POST response    headers, too.     Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|post_response_handler
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|post_response_ctx_t
modifier|*
name|prc
init|=
name|baton
decl_stmt|;
name|serf_bucket_t
modifier|*
name|hdrs
init|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
decl_stmt|;
comment|/* Then see which ones we can discover. */
name|serf_bucket_headers_do
argument_list|(
name|hdrs
argument_list|,
name|post_headers_iterator_callback
argument_list|,
name|prc
argument_list|)
expr_stmt|;
comment|/* Execute the 'real' response handler to XML-parse the repsonse body. */
return|return
name|svn_ra_serf__expect_empty_body
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|prc
operator|->
name|handler
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commit baton callbacks */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|dir_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|commit_context_t
modifier|*
name|commit_ctx
init|=
name|edit_baton
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|proppatch_context_t
modifier|*
name|proppatch_ctx
decl_stmt|;
name|dir_context_t
modifier|*
name|dir
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|proppatch_target
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|dir_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|commit_ctx
operator|->
name|session
argument_list|)
condition|)
block|{
name|post_response_ctx_t
modifier|*
name|prc
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_path
decl_stmt|;
name|svn_boolean_t
name|post_with_revprops
init|=
operator|(
name|NULL
operator|!=
name|svn_hash_gets
argument_list|(
name|commit_ctx
operator|->
name|session
operator|->
name|supported_posts
argument_list|,
literal|"create-txn-with-props"
argument_list|)
operator|)
decl_stmt|;
comment|/* Create our activity URL now on the server. */
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|commit_ctx
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"POST"
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
name|SVN_SKEL_MIME_TYPE
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_txn_post_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|post_with_revprops
condition|?
name|commit_ctx
operator|->
name|revprop_table
else|:
name|NULL
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_post_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|NULL
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|commit_ctx
operator|->
name|session
operator|->
name|me_resource
expr_stmt|;
name|prc
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prc
argument_list|)
argument_list|)
expr_stmt|;
name|prc
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|prc
operator|->
name|commit_ctx
operator|=
name|commit_ctx
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|post_response_handler
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|prc
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|201
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|commit_ctx
operator|->
name|txn_root_url
operator|&&
name|commit_ctx
operator|->
name|txn_url
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"POST request did not return transaction information"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fixup the txn_root_url to point to the anchor of the commit. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_relative_path
argument_list|(
operator|&
name|rel_path
argument_list|,
name|commit_ctx
operator|->
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|commit_ctx
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|commit_ctx
operator|->
name|txn_root_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|commit_ctx
operator|->
name|txn_root_url
argument_list|,
name|rel_path
argument_list|,
name|commit_ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Build our directory baton. */
name|dir
operator|=
name|apr_pcalloc
argument_list|(
name|dir_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|pool
operator|=
name|dir_pool
expr_stmt|;
name|dir
operator|->
name|commit_ctx
operator|=
name|commit_ctx
expr_stmt|;
name|dir
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
name|dir
operator|->
name|relpath
operator|=
literal|""
expr_stmt|;
name|dir
operator|->
name|name
operator|=
literal|""
expr_stmt|;
name|dir
operator|->
name|prop_changes
operator|=
name|apr_hash_make
argument_list|(
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|dir
operator|->
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|commit_ctx
operator|->
name|txn_root_url
argument_list|)
expr_stmt|;
comment|/* If we included our revprops in the POST, we need not          PROPPATCH them. */
name|proppatch_target
operator|=
name|post_with_revprops
condition|?
name|NULL
else|:
name|commit_ctx
operator|->
name|txn_url
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|activity_str
init|=
name|commit_ctx
operator|->
name|session
operator|->
name|activity_collection_url
decl_stmt|;
if|if
condition|(
operator|!
name|activity_str
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_serf__v1_get_activity_collection
argument_list|(
operator|&
name|activity_str
argument_list|,
name|commit_ctx
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|commit_ctx
operator|->
name|activity_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|activity_str
argument_list|,
name|svn_uuid_generate
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
name|commit_ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Create our activity URL now on the server. */
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|commit_ctx
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"MKACTIVITY"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|commit_ctx
operator|->
name|activity_url
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|201
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
comment|/* Now go fetch our VCC and baseline so we can do a CHECKOUT. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
operator|(
name|commit_ctx
operator|->
name|vcc_url
operator|)
argument_list|,
name|commit_ctx
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build our directory baton. */
name|dir
operator|=
name|apr_pcalloc
argument_list|(
name|dir_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|pool
operator|=
name|dir_pool
expr_stmt|;
name|dir
operator|->
name|commit_ctx
operator|=
name|commit_ctx
expr_stmt|;
name|dir
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
name|dir
operator|->
name|relpath
operator|=
literal|""
expr_stmt|;
name|dir
operator|->
name|name
operator|=
literal|""
expr_stmt|;
name|dir
operator|->
name|prop_changes
operator|=
name|apr_hash_make
argument_list|(
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_version_url
argument_list|(
operator|&
name|dir
operator|->
name|url
argument_list|,
name|dir
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|dir
operator|->
name|relpath
argument_list|,
name|dir
operator|->
name|base_revision
argument_list|,
name|commit_ctx
operator|->
name|checked_in_url
argument_list|,
name|dir
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|commit_ctx
operator|->
name|checked_in_url
operator|=
name|apr_pstrdup
argument_list|(
name|commit_ctx
operator|->
name|pool
argument_list|,
name|dir
operator|->
name|url
argument_list|)
expr_stmt|;
comment|/* Checkout our root dir */
name|SVN_ERR
argument_list|(
name|checkout_dir
argument_list|(
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|proppatch_target
operator|=
name|commit_ctx
operator|->
name|baseline_url
expr_stmt|;
block|}
comment|/* Unless this is NULL -- which means we don't need to PROPPATCH the      transaction with our revprops -- then, you know, PROPPATCH the      transaction with our revprops.  */
if|if
condition|(
name|proppatch_target
condition|)
block|{
name|proppatch_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|proppatch_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|proppatch_ctx
operator|->
name|pool
operator|=
name|scratch_pool
expr_stmt|;
name|proppatch_ctx
operator|->
name|commit_ctx
operator|=
name|NULL
expr_stmt|;
comment|/* No lock info */
name|proppatch_ctx
operator|->
name|path
operator|=
name|proppatch_target
expr_stmt|;
name|proppatch_ctx
operator|->
name|prop_changes
operator|=
name|apr_hash_make
argument_list|(
name|proppatch_ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
name|proppatch_ctx
operator|->
name|base_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|commit_ctx
operator|->
name|revprop_table
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
decl_stmt|;
name|prop
operator|->
name|name
operator|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|prop
operator|->
name|value
operator|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|proppatch_ctx
operator|->
name|prop_changes
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|proppatch_resource
argument_list|(
name|commit_ctx
operator|->
name|session
argument_list|,
name|proppatch_ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|root_baton
operator|=
name|dir
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|dir
init|=
name|parent_baton
decl_stmt|;
name|delete_context_t
modifier|*
name|delete_ctx
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
specifier|const
name|char
modifier|*
name|delete_target
decl_stmt|;
if|if
condition|(
name|USING_HTTPV2_COMMIT_SUPPORT
argument_list|(
name|dir
operator|->
name|commit_ctx
argument_list|)
condition|)
block|{
name|delete_target
operator|=
name|svn_path_url_add_component2
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|txn_root_url
argument_list|,
name|path
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ensure our directory has been checked out */
name|SVN_ERR
argument_list|(
name|checkout_dir
argument_list|(
name|dir
argument_list|,
name|pool
comment|/* scratch_pool */
argument_list|)
argument_list|)
expr_stmt|;
name|delete_target
operator|=
name|svn_path_url_add_component2
argument_list|(
name|dir
operator|->
name|working_url
argument_list|,
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* DELETE our entry */
name|delete_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|delete_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|delete_ctx
operator|->
name|relpath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|delete_ctx
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|delete_ctx
operator|->
name|commit_ctx
operator|=
name|dir
operator|->
name|commit_ctx
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_delete_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|delete_ctx
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"DELETE"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|delete_target
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 204 No Content: item successfully deleted */
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|204
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
name|svn_hash_sets
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|deleted_entries
argument_list|,
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|pool
argument_list|,
name|path
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|dir_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|parent
init|=
name|parent_baton
decl_stmt|;
name|dir_context_t
modifier|*
name|dir
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|mkcol_target
decl_stmt|;
name|dir
operator|=
name|apr_pcalloc
argument_list|(
name|dir_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|pool
operator|=
name|dir_pool
expr_stmt|;
name|dir
operator|->
name|parent_dir
operator|=
name|parent
expr_stmt|;
name|dir
operator|->
name|commit_ctx
operator|=
name|parent
operator|->
name|commit_ctx
expr_stmt|;
name|dir
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
name|dir
operator|->
name|base_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|dir
operator|->
name|copy_revision
operator|=
name|copyfrom_revision
expr_stmt|;
name|dir
operator|->
name|copy_path
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|copyfrom_path
argument_list|)
expr_stmt|;
name|dir
operator|->
name|relpath
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|dir
operator|->
name|name
operator|=
name|svn_relpath_basename
argument_list|(
name|dir
operator|->
name|relpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dir
operator|->
name|prop_changes
operator|=
name|apr_hash_make
argument_list|(
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|USING_HTTPV2_COMMIT_SUPPORT
argument_list|(
name|dir
operator|->
name|commit_ctx
argument_list|)
condition|)
block|{
name|dir
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|parent
operator|->
name|commit_ctx
operator|->
name|txn_root_url
argument_list|,
name|path
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|mkcol_target
operator|=
name|dir
operator|->
name|url
expr_stmt|;
block|}
else|else
block|{
comment|/* Ensure our parent is checked out. */
name|SVN_ERR
argument_list|(
name|checkout_dir
argument_list|(
name|parent
argument_list|,
name|dir
operator|->
name|pool
comment|/* scratch_pool */
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|parent
operator|->
name|commit_ctx
operator|->
name|checked_in_url
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|mkcol_target
operator|=
name|svn_path_url_add_component2
argument_list|(
name|parent
operator|->
name|working_url
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
if|if
condition|(
operator|!
name|dir
operator|->
name|copy_path
condition|)
block|{
name|handler
operator|->
name|method
operator|=
literal|"MKCOL"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|mkcol_target
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_add_dir_common_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|dir
expr_stmt|;
block|}
else|else
block|{
name|apr_uri_t
name|uri
decl_stmt|;
specifier|const
name|char
modifier|*
name|req_url
decl_stmt|;
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|dir
operator|->
name|copy_path
argument_list|,
operator|&
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to parse URL '%s'"
argument_list|)
argument_list|,
name|dir
operator|->
name|copy_path
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|req_url
argument_list|,
name|NULL
comment|/* latest_revnum */
argument_list|,
name|dir
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|uri
operator|.
name|path
argument_list|,
name|dir
operator|->
name|copy_revision
argument_list|,
name|dir_pool
argument_list|,
name|dir_pool
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"COPY"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|req_url
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_copy_dir_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|dir
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|201
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
operator|*
name|child_baton
operator|=
name|dir
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|dir_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|parent
init|=
name|parent_baton
decl_stmt|;
name|dir_context_t
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|apr_pcalloc
argument_list|(
name|dir_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|pool
operator|=
name|dir_pool
expr_stmt|;
name|dir
operator|->
name|parent_dir
operator|=
name|parent
expr_stmt|;
name|dir
operator|->
name|commit_ctx
operator|=
name|parent
operator|->
name|commit_ctx
expr_stmt|;
name|dir
operator|->
name|added
operator|=
name|FALSE
expr_stmt|;
name|dir
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
name|dir
operator|->
name|relpath
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|dir
operator|->
name|name
operator|=
name|svn_relpath_basename
argument_list|(
name|dir
operator|->
name|relpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dir
operator|->
name|prop_changes
operator|=
name|apr_hash_make
argument_list|(
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|USING_HTTPV2_COMMIT_SUPPORT
argument_list|(
name|dir
operator|->
name|commit_ctx
argument_list|)
condition|)
block|{
name|dir
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|parent
operator|->
name|commit_ctx
operator|->
name|txn_root_url
argument_list|,
name|path
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|get_version_url
argument_list|(
operator|&
name|dir
operator|->
name|url
argument_list|,
name|dir
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|dir
operator|->
name|relpath
argument_list|,
name|dir
operator|->
name|base_revision
argument_list|,
name|dir
operator|->
name|commit_ctx
operator|->
name|checked_in_url
argument_list|,
name|dir
operator|->
name|pool
argument_list|,
name|dir
operator|->
name|pool
comment|/* scratch_pool */
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|child_baton
operator|=
name|dir
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|dir
init|=
name|dir_baton
decl_stmt|;
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
if|if
condition|(
operator|!
name|USING_HTTPV2_COMMIT_SUPPORT
argument_list|(
name|dir
operator|->
name|commit_ctx
argument_list|)
condition|)
block|{
comment|/* Ensure we have a checked out dir. */
name|SVN_ERR
argument_list|(
name|checkout_dir
argument_list|(
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prop
operator|=
name|apr_palloc
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|dir
operator|->
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|prop
operator|->
name|value
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|dir
operator|->
name|prop_changes
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|dir
init|=
name|dir_baton
decl_stmt|;
comment|/* Huh?  We're going to be called before the texts are sent.  Ugh.    * Therefore, just wave politely at our caller.    */
comment|/* PROPPATCH our prop change and pass it along.  */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|dir
operator|->
name|prop_changes
argument_list|)
condition|)
block|{
name|proppatch_context_t
modifier|*
name|proppatch_ctx
decl_stmt|;
name|proppatch_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|proppatch_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|proppatch_ctx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|proppatch_ctx
operator|->
name|commit_ctx
operator|=
name|NULL
comment|/* No lock tokens necessary */
expr_stmt|;
name|proppatch_ctx
operator|->
name|relpath
operator|=
name|dir
operator|->
name|relpath
expr_stmt|;
name|proppatch_ctx
operator|->
name|prop_changes
operator|=
name|dir
operator|->
name|prop_changes
expr_stmt|;
name|proppatch_ctx
operator|->
name|base_revision
operator|=
name|dir
operator|->
name|base_revision
expr_stmt|;
if|if
condition|(
name|USING_HTTPV2_COMMIT_SUPPORT
argument_list|(
name|dir
operator|->
name|commit_ctx
argument_list|)
condition|)
block|{
name|proppatch_ctx
operator|->
name|path
operator|=
name|dir
operator|->
name|url
expr_stmt|;
block|}
else|else
block|{
name|proppatch_ctx
operator|->
name|path
operator|=
name|dir
operator|->
name|working_url
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|proppatch_resource
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|proppatch_ctx
argument_list|,
name|dir
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_path
parameter_list|,
name|svn_revnum_t
name|copy_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|file_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|dir
init|=
name|parent_baton
decl_stmt|;
name|file_context_t
modifier|*
name|new_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|deleted_parent
init|=
name|path
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|file_pool
argument_list|)
decl_stmt|;
name|new_file
operator|=
name|apr_pcalloc
argument_list|(
name|file_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_file
argument_list|)
argument_list|)
expr_stmt|;
name|new_file
operator|->
name|pool
operator|=
name|file_pool
expr_stmt|;
name|dir
operator|->
name|ref_count
operator|++
expr_stmt|;
name|new_file
operator|->
name|parent_dir
operator|=
name|dir
expr_stmt|;
name|new_file
operator|->
name|commit_ctx
operator|=
name|dir
operator|->
name|commit_ctx
expr_stmt|;
name|new_file
operator|->
name|relpath
operator|=
name|apr_pstrdup
argument_list|(
name|new_file
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|new_file
operator|->
name|name
operator|=
name|svn_relpath_basename
argument_list|(
name|new_file
operator|->
name|relpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_file
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
name|new_file
operator|->
name|base_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|new_file
operator|->
name|copy_path
operator|=
name|apr_pstrdup
argument_list|(
name|new_file
operator|->
name|pool
argument_list|,
name|copy_path
argument_list|)
expr_stmt|;
name|new_file
operator|->
name|copy_revision
operator|=
name|copy_revision
expr_stmt|;
name|new_file
operator|->
name|prop_changes
operator|=
name|apr_hash_make
argument_list|(
name|new_file
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Ensure that the file doesn't exist by doing a HEAD on the      resource.  If we're using HTTP v2, we'll just look into the      transaction root tree for this thing.  */
if|if
condition|(
name|USING_HTTPV2_COMMIT_SUPPORT
argument_list|(
name|dir
operator|->
name|commit_ctx
argument_list|)
condition|)
block|{
name|new_file
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|txn_root_url
argument_list|,
name|path
argument_list|,
name|new_file
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ensure our parent directory has been checked out */
name|SVN_ERR
argument_list|(
name|checkout_dir
argument_list|(
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_file
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|dir
operator|->
name|working_url
argument_list|,
name|new_file
operator|->
name|name
argument_list|,
name|new_file
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|deleted_parent
operator|&&
name|deleted_parent
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|deleted_entries
argument_list|,
name|deleted_parent
argument_list|)
condition|)
block|{
break|break;
block|}
name|deleted_parent
operator|=
name|svn_relpath_dirname
argument_list|(
name|deleted_parent
argument_list|,
name|file_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy_path
condition|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
specifier|const
name|char
modifier|*
name|req_url
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* Create the copy directly as cheap 'does exist/out of date'          check. We update the copy (if needed) from close_file() */
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|scratch_pool
argument_list|,
name|copy_path
argument_list|,
operator|&
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|req_url
argument_list|,
name|NULL
comment|/* latest_revnum */
argument_list|,
name|dir
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|uri
operator|.
name|path
argument_list|,
name|copy_revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"COPY"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|req_url
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_copy_file_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|new_file
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|201
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|dir
operator|->
name|added
operator|&&
operator|!
name|dir
operator|->
name|copy_path
operator|)
operator|||
operator|(
name|deleted_parent
operator|&&
name|deleted_parent
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|)
condition|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"HEAD"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|svn_path_url_add_component2
argument_list|(
name|dir
operator|->
name|commit_ctx
operator|->
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
name|handler
operator|->
name|no_dav_headers
operator|=
name|TRUE
expr_stmt|;
comment|/* Read only operation outside txn */
name|err
operator|=
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Great. We can create a new file! */
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ALREADY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"File '%s' already exists"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|new_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|file_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|dir_context_t
modifier|*
name|parent
init|=
name|parent_baton
decl_stmt|;
name|file_context_t
modifier|*
name|new_file
decl_stmt|;
name|new_file
operator|=
name|apr_pcalloc
argument_list|(
name|file_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_file
argument_list|)
argument_list|)
expr_stmt|;
name|new_file
operator|->
name|pool
operator|=
name|file_pool
expr_stmt|;
name|parent
operator|->
name|ref_count
operator|++
expr_stmt|;
name|new_file
operator|->
name|parent_dir
operator|=
name|parent
expr_stmt|;
name|new_file
operator|->
name|commit_ctx
operator|=
name|parent
operator|->
name|commit_ctx
expr_stmt|;
name|new_file
operator|->
name|relpath
operator|=
name|apr_pstrdup
argument_list|(
name|new_file
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|new_file
operator|->
name|name
operator|=
name|svn_relpath_basename
argument_list|(
name|new_file
operator|->
name|relpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_file
operator|->
name|added
operator|=
name|FALSE
expr_stmt|;
name|new_file
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
name|new_file
operator|->
name|prop_changes
operator|=
name|apr_hash_make
argument_list|(
name|new_file
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|USING_HTTPV2_COMMIT_SUPPORT
argument_list|(
name|parent
operator|->
name|commit_ctx
argument_list|)
condition|)
block|{
name|new_file
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|parent
operator|->
name|commit_ctx
operator|->
name|txn_root_url
argument_list|,
name|path
argument_list|,
name|new_file
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CHECKOUT the file into our activity. */
name|SVN_ERR
argument_list|(
name|checkout_file
argument_list|(
name|new_file
argument_list|,
name|new_file
operator|->
name|pool
comment|/* scratch_pool */
argument_list|)
argument_list|)
expr_stmt|;
name|new_file
operator|->
name|url
operator|=
name|new_file
operator|->
name|working_url
expr_stmt|;
block|}
operator|*
name|file_baton
operator|=
name|new_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_lazyopen_func_t for apply_textdelta */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delayed_commit_stream_open
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|file_context_t
modifier|*
name|file_ctx
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|file_ctx
operator|->
name|svndiff
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|file_ctx
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file_ctx
operator|->
name|svndiff
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|file_context_t
modifier|*
name|ctx
init|=
name|file_baton
decl_stmt|;
comment|/* Store the stream in a temporary file; we'll give it to serf when we    * close this file.    *    * TODO: There should be a way we can stream the request body instead of    * writing to a temporary file (ugh). A special svn stream serf bucket    * that returns EAGAIN until we receive the done call?  But, when    * would we run through the serf context?  Grr.    */
name|ctx
operator|->
name|stream
operator|=
name|svn_stream_lazyopen_create
argument_list|(
name|delayed_commit_stream_open
argument_list|,
name|ctx
argument_list|,
name|FALSE
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_txdelta_to_svndiff3
argument_list|(
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|ctx
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_checksum
condition|)
name|ctx
operator|->
name|base_checksum
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
name|base_checksum
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|file_context_t
modifier|*
name|file
init|=
name|file_baton
decl_stmt|;
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
name|prop
operator|=
name|apr_palloc
argument_list|(
name|file
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|file
operator|->
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|prop
operator|->
name|value
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|file
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|file
operator|->
name|prop_changes
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|file_context_t
modifier|*
name|ctx
init|=
name|file_baton
decl_stmt|;
name|svn_boolean_t
name|put_empty_file
init|=
name|FALSE
decl_stmt|;
name|ctx
operator|->
name|result_checksum
operator|=
name|text_checksum
expr_stmt|;
comment|/* If we got no stream of changes, but this is an added-without-history    * file, make a note that we'll be PUTting a zero-byte file to the server.    */
if|if
condition|(
operator|(
operator|!
name|ctx
operator|->
name|svndiff
operator|)
operator|&&
name|ctx
operator|->
name|added
operator|&&
operator|(
operator|!
name|ctx
operator|->
name|copy_path
operator|)
condition|)
name|put_empty_file
operator|=
name|TRUE
expr_stmt|;
comment|/* If we had a stream of changes, push them to the server... */
if|if
condition|(
name|ctx
operator|->
name|svndiff
operator|||
name|put_empty_file
condition|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|int
name|expected_result
decl_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|ctx
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"PUT"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|ctx
operator|->
name|url
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
if|if
condition|(
name|put_empty_file
condition|)
block|{
name|handler
operator|->
name|body_delegate
operator|=
name|create_empty_put_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|ctx
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/plain"
expr_stmt|;
block|}
else|else
block|{
name|handler
operator|->
name|body_delegate
operator|=
name|create_put_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|ctx
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
name|SVN_SVNDIFF_MIME_TYPE
expr_stmt|;
block|}
name|handler
operator|->
name|header_delegate
operator|=
name|setup_put_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|ctx
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|added
operator|&&
operator|!
name|ctx
operator|->
name|copy_path
condition|)
name|expected_result
operator|=
literal|201
expr_stmt|;
comment|/* Created */
else|else
name|expected_result
operator|=
literal|204
expr_stmt|;
comment|/* Updated */
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
name|expected_result
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|svndiff
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|ctx
operator|->
name|svndiff
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we had any prop changes, push them via PROPPATCH. */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|ctx
operator|->
name|prop_changes
argument_list|)
condition|)
block|{
name|proppatch_context_t
modifier|*
name|proppatch
decl_stmt|;
name|proppatch
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|proppatch
argument_list|)
argument_list|)
expr_stmt|;
name|proppatch
operator|->
name|pool
operator|=
name|scratch_pool
expr_stmt|;
name|proppatch
operator|->
name|relpath
operator|=
name|ctx
operator|->
name|relpath
expr_stmt|;
name|proppatch
operator|->
name|path
operator|=
name|ctx
operator|->
name|url
expr_stmt|;
name|proppatch
operator|->
name|commit_ctx
operator|=
name|ctx
operator|->
name|commit_ctx
expr_stmt|;
name|proppatch
operator|->
name|prop_changes
operator|=
name|ctx
operator|->
name|prop_changes
expr_stmt|;
name|proppatch
operator|->
name|base_revision
operator|=
name|ctx
operator|->
name|base_revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|proppatch_resource
argument_list|(
name|ctx
operator|->
name|commit_ctx
operator|->
name|session
argument_list|,
name|proppatch
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|commit_context_t
modifier|*
name|ctx
init|=
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_target
init|=
name|ctx
operator|->
name|activity_url
condition|?
name|ctx
operator|->
name|activity_url
else|:
name|ctx
operator|->
name|txn_url
decl_stmt|;
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
comment|/* MERGE our activity */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__run_merge
argument_list|(
operator|&
name|commit_info
argument_list|,
name|ctx
operator|->
name|session
argument_list|,
name|merge_target
argument_list|,
name|ctx
operator|->
name|lock_tokens
argument_list|,
name|ctx
operator|->
name|keep_locks
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|txn_url
operator|=
name|NULL
expr_stmt|;
comment|/* If HTTPv2, the txn is now done */
comment|/* Inform the WC that we did a commit.  */
if|if
condition|(
name|ctx
operator|->
name|callback
condition|)
name|err
operator|=
name|ctx
operator|->
name|callback
argument_list|(
name|commit_info
argument_list|,
name|ctx
operator|->
name|callback_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we're using activities, DELETE our completed activity.  */
if|if
condition|(
name|ctx
operator|->
name|activity_url
condition|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|ctx
operator|->
name|session
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"DELETE"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|ctx
operator|->
name|activity_url
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
name|ctx
operator|->
name|activity_url
operator|=
name|NULL
expr_stmt|;
comment|/* Don't try again in abort_edit() on fail */
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|204
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|commit_context_t
modifier|*
name|ctx
init|=
name|edit_baton
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* If an activity or transaction wasn't even created, don't bother      trying to delete it. */
if|if
condition|(
operator|!
operator|(
name|ctx
operator|->
name|activity_url
operator|||
name|ctx
operator|->
name|txn_url
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* An error occurred on conns[0]. serf 0.4.0 remembers that the connection      had a problem. We need to reset it, in order to use it again.  */
name|serf_connection_reset
argument_list|(
name|ctx
operator|->
name|session
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|conn
argument_list|)
expr_stmt|;
comment|/* DELETE our aborted activity */
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|ctx
operator|->
name|session
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"DELETE"
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
name|handler
operator|->
name|no_fail_on_http_failure_status
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|USING_HTTPV2_COMMIT_SUPPORT
argument_list|(
name|ctx
argument_list|)
condition|)
comment|/* HTTP v2 */
name|handler
operator|->
name|path
operator|=
name|ctx
operator|->
name|txn_url
expr_stmt|;
else|else
name|handler
operator|->
name|path
operator|=
name|ctx
operator|->
name|activity_url
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 204 if deleted,      403 if DELETE was forbidden (indicates MKACTIVITY was forbidden too),      404 if the activity wasn't found. */
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|204
operator|&&
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|403
operator|&&
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|404
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__unexpected_status
argument_list|(
name|handler
argument_list|)
argument_list|)
return|;
block|}
comment|/* Don't delete again if somebody aborts twice */
name|ctx
operator|->
name|activity_url
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|txn_url
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_commit_editor
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|ret_editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|callback
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|commit_context_t
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_relpath
decl_stmt|;
name|svn_boolean_t
name|supports_ephemeral_props
decl_stmt|;
name|ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|ctx
operator|->
name|session
operator|=
name|session
expr_stmt|;
name|ctx
operator|->
name|revprop_table
operator|=
name|svn_prop_hash_dup
argument_list|(
name|revprop_table
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If the server supports ephemeral properties, add some carrying      interesting version information. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|supports_ephemeral_props
argument_list|,
name|SVN_RA_CAPABILITY_EPHEMERAL_TXNPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|supports_ephemeral_props
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|ctx
operator|->
name|revprop_table
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|SVN_PROP_TXN_CLIENT_COMPAT_VERSION
argument_list|)
argument_list|,
name|svn_string_create
argument_list|(
name|SVN_VER_NUMBER
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|ctx
operator|->
name|revprop_table
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|SVN_PROP_TXN_USER_AGENT
argument_list|)
argument_list|,
name|svn_string_create
argument_list|(
name|session
operator|->
name|useragent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|ctx
operator|->
name|callback_baton
operator|=
name|callback_baton
expr_stmt|;
name|ctx
operator|->
name|lock_tokens
operator|=
operator|(
name|lock_tokens
operator|&&
name|apr_hash_count
argument_list|(
name|lock_tokens
argument_list|)
operator|)
condition|?
name|lock_tokens
else|:
name|NULL
expr_stmt|;
name|ctx
operator|->
name|keep_locks
operator|=
name|keep_locks
expr_stmt|;
name|ctx
operator|->
name|deleted_entries
operator|=
name|apr_hash_make
argument_list|(
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
name|editor
operator|=
name|svn_delta_default_editor
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|editor
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|editor
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
name|editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|editor
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|editor
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|editor
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|editor
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|editor
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
name|editor
operator|->
name|abort_edit
operator|=
name|abort_edit
expr_stmt|;
operator|*
name|ret_editor
operator|=
name|editor
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|ctx
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_repos_root
argument_list|(
name|ra_session
argument_list|,
operator|&
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|base_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root
argument_list|,
name|session
operator|->
name|session_url_str
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor__insert_shims
argument_list|(
name|ret_editor
argument_list|,
name|edit_baton
argument_list|,
operator|*
name|ret_editor
argument_list|,
operator|*
name|edit_baton
argument_list|,
name|repos_root
argument_list|,
name|base_relpath
argument_list|,
name|session
operator|->
name|shim_callbacks
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__change_rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|proppatch_context_t
modifier|*
name|proppatch_ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|proppatch_target
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|tmp_old_value
decl_stmt|;
name|svn_boolean_t
name|atomic_capable
init|=
name|FALSE
decl_stmt|;
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|old_value_p
operator|||
operator|!
name|value
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_serf__has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|atomic_capable
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_value_p
condition|)
block|{
comment|/* How did you get past the same check in svn_ra_change_rev_prop2()? */
name|SVN_ERR_ASSERT
argument_list|(
name|atomic_capable
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|value
operator|&&
name|atomic_capable
condition|)
block|{
name|svn_string_t
modifier|*
name|old_value
decl_stmt|;
comment|/* mod_dav_svn doesn't report a failure when a property delete fails. The          atomic revprop change behavior is a nice workaround, to allow getting          access to the error anyway.           Somehow the mod_dav maintainers think that returning an error from          mod_dav's property delete is an RFC violation.          See https://issues.apache.org/bugzilla/show_bug.cgi?id=53525 */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__rev_prop
argument_list|(
name|ra_session
argument_list|,
name|rev
argument_list|,
name|name
argument_list|,
operator|&
name|old_value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_value
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Nothing to delete */
comment|/* The api expects a double const pointer. Let's make one */
name|tmp_old_value
operator|=
name|old_value
expr_stmt|;
name|old_value_p
operator|=
operator|&
name|tmp_old_value
expr_stmt|;
block|}
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
block|{
name|proppatch_target
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s/%ld"
argument_list|,
name|session
operator|->
name|rev_stub
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_dav_prop
argument_list|(
operator|&
name|proppatch_target
argument_list|,
name|session
argument_list|,
name|vcc_url
argument_list|,
name|rev
argument_list|,
literal|"href"
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* PROPPATCH our log message and pass it along.  */
name|proppatch_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|proppatch_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|proppatch_ctx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|proppatch_ctx
operator|->
name|commit_ctx
operator|=
name|NULL
expr_stmt|;
comment|/* No lock headers */
name|proppatch_ctx
operator|->
name|path
operator|=
name|proppatch_target
expr_stmt|;
name|proppatch_ctx
operator|->
name|prop_changes
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|proppatch_ctx
operator|->
name|base_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|old_value_p
condition|)
block|{
name|prop
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|prop
operator|->
name|value
operator|=
operator|*
name|old_value_p
expr_stmt|;
name|proppatch_ctx
operator|->
name|old_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|proppatch_ctx
operator|->
name|old_props
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
argument_list|)
expr_stmt|;
block|}
name|prop
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|prop
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|proppatch_ctx
operator|->
name|prop_changes
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|err
operator|=
name|proppatch_resource
argument_list|(
name|session
argument_list|,
name|proppatch_ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Use specific error code for old property value mismatch.      Use loop to provide the right result with tracing */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_PRECONDITION_FAILED
condition|)
block|{
name|svn_error_t
modifier|*
name|e
init|=
name|err
decl_stmt|;
while|while
condition|(
name|e
operator|&&
name|e
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_PRECONDITION_FAILED
condition|)
block|{
name|e
operator|->
name|apr_err
operator|=
name|SVN_ERR_FS_PROP_BASEVALUE_MISMATCH
expr_stmt|;
name|e
operator|=
name|e
operator|->
name|child
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

end_unit

