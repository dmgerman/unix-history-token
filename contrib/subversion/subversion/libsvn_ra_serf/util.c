begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util.c : serf utility routines for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|<serf_bucket_types.h>
end_include

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_auth_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cert.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Fix for older expat 1.95.x's that do not define  * XML_STATUS_OK/XML_STATUS_ERROR  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XML_STATUS_OK
end_ifndef

begin_define
define|#
directive|define
name|XML_STATUS_OK
value|1
end_define

begin_define
define|#
directive|define
name|XML_STATUS_ERROR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XML_VERSION_AT_LEAST
end_ifndef

begin_define
define|#
directive|define
name|XML_VERSION_AT_LEAST
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|,
name|patch
parameter_list|)
define|\
value|(((major)< XML_MAJOR_VERSION)                                       \  || ((major) == XML_MAJOR_VERSION&& (minor)< XML_MINOR_VERSION)    \  || ((major) == XML_MAJOR_VERSION&& (minor) == XML_MINOR_VERSION&& \      (patch)<= XML_MICRO_VERSION))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_VERSION_AT_LEAST */
end_comment

begin_if
if|#
directive|if
name|XML_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|95
operator|,
literal|8
argument_list|)
end_if

begin_define
define|#
directive|define
name|EXPAT_HAS_STOPPARSER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read/write chunks of this size into the spillbuf.  */
end_comment

begin_define
define|#
directive|define
name|PARSE_CHUNK_SIZE
value|8000
end_define

begin_comment
comment|/* We will store one megabyte in memory, before switching to store content    into a temporary file.  */
end_comment

begin_define
define|#
directive|define
name|SPILL_SIZE
value|1000000
end_define

begin_comment
comment|/* This structure records pending data for the parser in memory blocks,    and possibly into a temporary file if "too much" content arrives.  */
end_comment

begin_struct
struct|struct
name|svn_ra_serf__pending_t
block|{
comment|/* The spillbuf where we record the pending data.  */
name|svn_spillbuf_t
modifier|*
name|buf
decl_stmt|;
comment|/* This flag is set when the network has reached EOF. The PENDING      processing can then properly detect when parsing has completed.  */
name|svn_boolean_t
name|network_eof
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HAS_PENDING_DATA
parameter_list|(
name|p
parameter_list|)
value|((p) != NULL&& (p)->buf != NULL \&& svn_spillbuf__get_size((p)->buf) != 0)
end_define

begin_struct
struct|struct
name|expat_ctx_t
block|{
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
name|XML_Parser
name|parser
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_error_t
modifier|*
name|inner_error
decl_stmt|;
comment|/* Do not use this pool for allocation. It is merely recorded for running      the cleanup handler.  */
name|apr_pool_t
modifier|*
name|cleanup_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|apr_uint32_t
name|serf_failure_map
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
name|SERF_SSL_CERT_NOTYETVALID
block|,
name|SVN_AUTH_SSL_NOTYETVALID
block|}
block|,
block|{
name|SERF_SSL_CERT_EXPIRED
block|,
name|SVN_AUTH_SSL_EXPIRED
block|}
block|,
block|{
name|SERF_SSL_CERT_SELF_SIGNED
block|,
name|SVN_AUTH_SSL_UNKNOWNCA
block|}
block|,
block|{
name|SERF_SSL_CERT_UNKNOWNCA
block|,
name|SVN_AUTH_SSL_UNKNOWNCA
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a Subversion failure mask based on FAILURES, a serf SSL    failure mask.  If anything in FAILURES is not directly mappable to    Subversion failures, set SVN_AUTH_SSL_OTHER in the returned mask. */
end_comment

begin_function
specifier|static
name|apr_uint32_t
name|ssl_convert_serf_failures
parameter_list|(
name|int
name|failures
parameter_list|)
block|{
name|apr_uint32_t
name|svn_failures
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|serf_failure_map
argument_list|)
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|apr_uint32_t
argument_list|)
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|failures
operator|&
name|serf_failure_map
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
name|svn_failures
operator||=
name|serf_failure_map
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
name|failures
operator|&=
operator|~
name|serf_failure_map
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
comment|/* Map any remaining failure bits to our OTHER bit. */
if|if
condition|(
name|failures
condition|)
block|{
name|svn_failures
operator||=
name|SVN_AUTH_SSL_OTHER
expr_stmt|;
block|}
return|return
name|svn_failures
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|save_error
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
name|err
operator|||
name|session
operator|->
name|pending_error
condition|)
block|{
name|session
operator|->
name|pending_error
operator|=
name|svn_error_compose_create
argument_list|(
name|session
operator|->
name|pending_error
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|session
operator|->
name|pending_error
operator|->
name|apr_err
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Construct the realmstring, e.g. https://svn.collab.net:443. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|construct_realm
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|realm
decl_stmt|;
name|apr_port_t
name|port
decl_stmt|;
if|if
condition|(
name|session
operator|->
name|session_url
operator|.
name|port_str
condition|)
block|{
name|port
operator|=
name|session
operator|->
name|session_url
operator|.
name|port
expr_stmt|;
block|}
else|else
block|{
name|port
operator|=
name|apr_uri_port_of_scheme
argument_list|(
name|session
operator|->
name|session_url
operator|.
name|scheme
argument_list|)
expr_stmt|;
block|}
name|realm
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s://%s:%d"
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|scheme
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|hostname
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|realm
return|;
block|}
end_function

begin_comment
comment|/* Convert a hash table containing the fields (as documented in X.509) of an    organisation to a string ORG, allocated in POOL. ORG is as returned by    serf_ssl_cert_issuer() and serf_ssl_cert_subject(). */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|convert_organisation_to_str
parameter_list|(
name|apr_hash_t
modifier|*
name|org
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|org_unit
init|=
name|svn_hash_gets
argument_list|(
name|org
argument_list|,
literal|"OU"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|org_name
init|=
name|svn_hash_gets
argument_list|(
name|org
argument_list|,
literal|"O"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|locality
init|=
name|svn_hash_gets
argument_list|(
name|org
argument_list|,
literal|"L"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|state
init|=
name|svn_hash_gets
argument_list|(
name|org
argument_list|,
literal|"ST"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|country
init|=
name|svn_hash_gets
argument_list|(
name|org
argument_list|,
literal|"C"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|email
init|=
name|svn_hash_gets
argument_list|(
name|org
argument_list|,
literal|"E"
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|org_unit
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|org_unit
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|org_name
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|org_name
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locality
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|locality
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|country
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|country
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
comment|/* Chop ', ' if any. */
name|svn_stringbuf_chop
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|email
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|email
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|->
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_reason
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|errmsg
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
name|int
modifier|*
name|reasons
parameter_list|)
block|{
if|if
condition|(
operator|*
name|reasons
operator|<
literal|1
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|errmsg
argument_list|,
name|_
argument_list|(
literal|": "
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_appendcstr
argument_list|(
name|errmsg
argument_list|,
name|_
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|errmsg
argument_list|,
name|reason
argument_list|)
expr_stmt|;
operator|(
operator|*
name|reasons
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called on receiving a ssl certificate of a server when    opening a https connection. It allows Subversion to override the initial    validation done by serf.    Serf provides us the @a baton as provided in the call to    serf_ssl_server_cert_callback_set. The result of serf's initial validation    of the certificate @a CERT is returned as a bitmask in FAILURES. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ssl_server_cert
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|failures
parameter_list|,
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
init|=
name|baton
decl_stmt|;
name|svn_auth_ssl_server_cert_info_t
name|cert_info
decl_stmt|;
name|svn_auth_cred_ssl_server_trust_t
modifier|*
name|server_creds
init|=
name|NULL
decl_stmt|;
name|svn_auth_iterstate_t
modifier|*
name|state
decl_stmt|;
specifier|const
name|char
modifier|*
name|realmstring
decl_stmt|;
name|apr_uint32_t
name|svn_failures
decl_stmt|;
name|apr_hash_t
modifier|*
name|issuer
decl_stmt|;
name|apr_hash_t
modifier|*
name|subject
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|serf_cert
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|creds
decl_stmt|;
name|svn_failures
operator|=
operator|(
name|ssl_convert_serf_failures
argument_list|(
name|failures
argument_list|)
operator||
name|conn
operator|->
name|server_cert_failures
operator|)
expr_stmt|;
if|if
condition|(
name|serf_ssl_cert_depth
argument_list|(
name|cert
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If the depth is 0, the hostname must match the certificate.        ### This should really be handled by serf, which should pass an error           for this case, but that has backwards compatibility issues. */
name|apr_array_header_t
modifier|*
name|san
decl_stmt|;
name|svn_boolean_t
name|found_san_entry
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|found_matching_hostname
init|=
name|FALSE
decl_stmt|;
name|svn_string_t
modifier|*
name|actual_hostname
init|=
name|svn_string_create
argument_list|(
name|conn
operator|->
name|session
operator|->
name|session_url
operator|.
name|hostname
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|serf_cert
operator|=
name|serf_ssl_cert_certificate
argument_list|(
name|cert
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|san
operator|=
name|svn_hash_gets
argument_list|(
name|serf_cert
argument_list|,
literal|"subjectAltName"
argument_list|)
expr_stmt|;
comment|/* Try to find matching server name via subjectAltName first... */
if|if
condition|(
name|san
condition|)
block|{
name|int
name|i
decl_stmt|;
name|found_san_entry
operator|=
name|san
operator|->
name|nelts
operator|>
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|san
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|APR_ARRAY_IDX
argument_list|(
name|san
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|cert_hostname
init|=
name|svn_string_create
argument_list|(
name|s
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_cert__match_dns_identity
argument_list|(
name|cert_hostname
argument_list|,
name|actual_hostname
argument_list|)
condition|)
block|{
name|found_matching_hostname
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Match server certificate CN with the hostname of the server iff        * we didn't find any subjectAltName fields and try to match them.        * Per RFC 2818 they are authoritative if present and CommonName        * should be ignored. */
if|if
condition|(
operator|!
name|found_matching_hostname
operator|&&
operator|!
name|found_san_entry
condition|)
block|{
specifier|const
name|char
modifier|*
name|hostname
init|=
name|NULL
decl_stmt|;
name|subject
operator|=
name|serf_ssl_cert_subject
argument_list|(
name|cert
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|subject
condition|)
name|hostname
operator|=
name|svn_hash_gets
argument_list|(
name|subject
argument_list|,
literal|"CN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
condition|)
block|{
name|svn_string_t
modifier|*
name|cert_hostname
init|=
name|svn_string_create
argument_list|(
name|hostname
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_cert__match_dns_identity
argument_list|(
name|cert_hostname
argument_list|,
name|actual_hostname
argument_list|)
condition|)
block|{
name|found_matching_hostname
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found_matching_hostname
condition|)
name|svn_failures
operator||=
name|SVN_AUTH_SSL_CNMISMATCH
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svn_failures
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Extract the info from the certificate */
if|if
condition|(
operator|!
name|subject
condition|)
name|subject
operator|=
name|serf_ssl_cert_subject
argument_list|(
name|cert
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|issuer
operator|=
name|serf_ssl_cert_issuer
argument_list|(
name|cert
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|serf_cert
condition|)
name|serf_cert
operator|=
name|serf_ssl_cert_certificate
argument_list|(
name|cert
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|cert_info
operator|.
name|hostname
operator|=
name|svn_hash_gets
argument_list|(
name|subject
argument_list|,
literal|"CN"
argument_list|)
expr_stmt|;
name|cert_info
operator|.
name|fingerprint
operator|=
name|svn_hash_gets
argument_list|(
name|serf_cert
argument_list|,
literal|"sha1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert_info
operator|.
name|fingerprint
condition|)
name|cert_info
operator|.
name|fingerprint
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|cert_info
operator|.
name|valid_from
operator|=
name|svn_hash_gets
argument_list|(
name|serf_cert
argument_list|,
literal|"notBefore"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert_info
operator|.
name|valid_from
condition|)
name|cert_info
operator|.
name|valid_from
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
literal|"[invalid date]"
argument_list|)
expr_stmt|;
name|cert_info
operator|.
name|valid_until
operator|=
name|svn_hash_gets
argument_list|(
name|serf_cert
argument_list|,
literal|"notAfter"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert_info
operator|.
name|valid_until
condition|)
name|cert_info
operator|.
name|valid_until
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
literal|"[invalid date]"
argument_list|)
expr_stmt|;
name|cert_info
operator|.
name|issuer_dname
operator|=
name|convert_organisation_to_str
argument_list|(
name|issuer
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|cert_info
operator|.
name|ascii_cert
operator|=
name|serf_ssl_cert_export
argument_list|(
name|cert
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Handle any non-server certs. */
if|if
condition|(
name|serf_ssl_cert_depth
argument_list|(
name|cert
argument_list|)
operator|>
literal|0
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_auth_set_parameter
argument_list|(
name|conn
operator|->
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_SSL_SERVER_CERT_INFO
argument_list|,
operator|&
name|cert_info
argument_list|)
expr_stmt|;
name|svn_auth_set_parameter
argument_list|(
name|conn
operator|->
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_SSL_SERVER_FAILURES
argument_list|,
operator|&
name|svn_failures
argument_list|)
expr_stmt|;
name|realmstring
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"AUTHORITY:%s"
argument_list|,
name|cert_info
operator|.
name|fingerprint
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_auth_first_credentials
argument_list|(
operator|&
name|creds
argument_list|,
operator|&
name|state
argument_list|,
name|SVN_AUTH_CRED_SSL_SERVER_AUTHORITY
argument_list|,
name|realmstring
argument_list|,
name|conn
operator|->
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_auth_set_parameter
argument_list|(
name|conn
operator|->
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_SSL_SERVER_CERT_INFO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_auth_set_parameter
argument_list|(
name|conn
operator|->
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_SSL_SERVER_FAILURES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_AUTHN_NO_PROVIDER
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* No provider registered that handles server authorities */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|creds
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|creds
condition|)
block|{
name|server_creds
operator|=
name|creds
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_auth_save_credentials
argument_list|(
name|state
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_failures
operator|&=
operator|~
name|server_creds
operator|->
name|accepted_failures
expr_stmt|;
block|}
if|if
condition|(
name|svn_failures
condition|)
name|conn
operator|->
name|server_cert_failures
operator||=
name|svn_failures
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
name|svn_auth_set_parameter
argument_list|(
name|conn
operator|->
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_SSL_SERVER_FAILURES
argument_list|,
operator|&
name|svn_failures
argument_list|)
expr_stmt|;
name|svn_auth_set_parameter
argument_list|(
name|conn
operator|->
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_SSL_SERVER_CERT_INFO
argument_list|,
operator|&
name|cert_info
argument_list|)
expr_stmt|;
name|realmstring
operator|=
name|construct_realm
argument_list|(
name|conn
operator|->
name|session
argument_list|,
name|conn
operator|->
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_auth_first_credentials
argument_list|(
operator|&
name|creds
argument_list|,
operator|&
name|state
argument_list|,
name|SVN_AUTH_CRED_SSL_SERVER_TRUST
argument_list|,
name|realmstring
argument_list|,
name|conn
operator|->
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|creds
condition|)
block|{
name|server_creds
operator|=
name|creds
expr_stmt|;
name|svn_failures
operator|&=
operator|~
name|server_creds
operator|->
name|accepted_failures
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_auth_save_credentials
argument_list|(
name|state
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|svn_failures
operator|&&
name|creds
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_auth_next_credentials
argument_list|(
operator|&
name|creds
argument_list|,
name|state
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|creds
condition|)
block|{
name|server_creds
operator|=
name|creds
expr_stmt|;
name|svn_failures
operator|&=
operator|~
name|server_creds
operator|->
name|accepted_failures
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_auth_save_credentials
argument_list|(
name|state
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_auth_set_parameter
argument_list|(
name|conn
operator|->
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_SSL_SERVER_CERT_INFO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Are there non accepted failures left? */
if|if
condition|(
name|svn_failures
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|errmsg
decl_stmt|;
name|int
name|reasons
init|=
literal|0
decl_stmt|;
name|errmsg
operator|=
name|svn_stringbuf_create
argument_list|(
name|_
argument_list|(
literal|"Server SSL certificate verification failed"
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_failures
operator|&
name|SVN_AUTH_SSL_NOTYETVALID
condition|)
name|append_reason
argument_list|(
name|errmsg
argument_list|,
name|_
argument_list|(
literal|"certificate is not yet valid"
argument_list|)
argument_list|,
operator|&
name|reasons
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_failures
operator|&
name|SVN_AUTH_SSL_EXPIRED
condition|)
name|append_reason
argument_list|(
name|errmsg
argument_list|,
name|_
argument_list|(
literal|"certificate has expired"
argument_list|)
argument_list|,
operator|&
name|reasons
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_failures
operator|&
name|SVN_AUTH_SSL_CNMISMATCH
condition|)
name|append_reason
argument_list|(
name|errmsg
argument_list|,
name|_
argument_list|(
literal|"certificate issued for a different hostname"
argument_list|)
argument_list|,
operator|&
name|reasons
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_failures
operator|&
name|SVN_AUTH_SSL_UNKNOWNCA
condition|)
name|append_reason
argument_list|(
name|errmsg
argument_list|,
name|_
argument_list|(
literal|"issuer is not trusted"
argument_list|)
argument_list|,
operator|&
name|reasons
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_failures
operator|&
name|SVN_AUTH_SSL_OTHER
condition|)
name|append_reason
argument_list|(
name|errmsg
argument_list|,
name|_
argument_list|(
literal|"and other reason(s)"
argument_list|)
argument_list|,
operator|&
name|reasons
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SERF_SSL_CERT_UNTRUSTED
argument_list|,
name|NULL
argument_list|,
name|errmsg
operator|->
name|data
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements serf_ssl_need_server_cert_t for ssl_server_cert */
end_comment

begin_function
specifier|static
name|apr_status_t
name|ssl_server_cert_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|failures
parameter_list|,
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
init|=
name|baton
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|conn
operator|->
name|session
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|ssl_server_cert
argument_list|(
name|baton
argument_list|,
name|failures
argument_list|,
name|cert
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|save_error
argument_list|(
name|session
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|load_authorities
parameter_list|(
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|authorities
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|files
init|=
name|svn_cstring_split
argument_list|(
name|authorities
argument_list|,
literal|";"
argument_list|,
name|TRUE
comment|/* chop_whitespace */
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|files
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|file
init|=
name|APR_ARRAY_IDX
argument_list|(
name|files
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|serf_ssl_certificate_t
modifier|*
name|ca_cert
decl_stmt|;
name|apr_status_t
name|status
init|=
name|serf_ssl_load_cert_file
argument_list|(
operator|&
name|ca_cert
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
name|status
operator|=
name|serf_ssl_trust_cert
argument_list|(
name|conn
operator|->
name|ssl_context
argument_list|,
name|ca_cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid config: unable to load certificate file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conn_setup
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|read_bkt
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|write_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
init|=
name|baton
decl_stmt|;
operator|*
name|read_bkt
operator|=
name|serf_context_bucket_socket_create
argument_list|(
name|conn
operator|->
name|session
operator|->
name|context
argument_list|,
name|sock
argument_list|,
name|conn
operator|->
name|bkt_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|session
operator|->
name|using_ssl
condition|)
block|{
comment|/* input stream */
operator|*
name|read_bkt
operator|=
name|serf_bucket_ssl_decrypt_create
argument_list|(
operator|*
name|read_bkt
argument_list|,
name|conn
operator|->
name|ssl_context
argument_list|,
name|conn
operator|->
name|bkt_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conn
operator|->
name|ssl_context
condition|)
block|{
name|conn
operator|->
name|ssl_context
operator|=
name|serf_bucket_ssl_encrypt_context_get
argument_list|(
operator|*
name|read_bkt
argument_list|)
expr_stmt|;
name|serf_ssl_set_hostname
argument_list|(
name|conn
operator|->
name|ssl_context
argument_list|,
name|conn
operator|->
name|session
operator|->
name|session_url
operator|.
name|hostname
argument_list|)
expr_stmt|;
name|serf_ssl_client_cert_provider_set
argument_list|(
name|conn
operator|->
name|ssl_context
argument_list|,
name|svn_ra_serf__handle_client_cert
argument_list|,
name|conn
argument_list|,
name|conn
operator|->
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
name|serf_ssl_client_cert_password_set
argument_list|(
name|conn
operator|->
name|ssl_context
argument_list|,
name|svn_ra_serf__handle_client_cert_pw
argument_list|,
name|conn
argument_list|,
name|conn
operator|->
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
name|serf_ssl_server_cert_callback_set
argument_list|(
name|conn
operator|->
name|ssl_context
argument_list|,
name|ssl_server_cert_cb
argument_list|,
name|conn
argument_list|)
expr_stmt|;
comment|/* See if the user wants us to trust "default" openssl CAs. */
if|if
condition|(
name|conn
operator|->
name|session
operator|->
name|trust_default_ca
condition|)
block|{
name|serf_ssl_use_default_certificates
argument_list|(
name|conn
operator|->
name|ssl_context
argument_list|)
expr_stmt|;
block|}
comment|/* Are there custom CAs to load? */
if|if
condition|(
name|conn
operator|->
name|session
operator|->
name|ssl_authorities
condition|)
block|{
name|SVN_ERR
argument_list|(
name|load_authorities
argument_list|(
name|conn
argument_list|,
name|conn
operator|->
name|session
operator|->
name|ssl_authorities
argument_list|,
name|conn
operator|->
name|session
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|write_bkt
condition|)
block|{
comment|/* output stream */
operator|*
name|write_bkt
operator|=
name|serf_bucket_ssl_encrypt_create
argument_list|(
operator|*
name|write_bkt
argument_list|,
name|conn
operator|->
name|ssl_context
argument_list|,
name|conn
operator|->
name|bkt_alloc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* svn_ra_serf__conn_setup is a callback for serf. This function    creates a read bucket and will wrap the write bucket if SSL    is needed. */
end_comment

begin_function
name|apr_status_t
name|svn_ra_serf__conn_setup
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|read_bkt
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|write_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
init|=
name|baton
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|conn
operator|->
name|session
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|conn_setup
argument_list|(
name|sock
argument_list|,
name|read_bkt
argument_list|,
name|write_bkt
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|save_error
argument_list|(
name|session
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Our default serf response acceptor.  */
end_comment

begin_function
specifier|static
name|serf_bucket_t
modifier|*
name|accept_response
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|acceptor_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|c
decl_stmt|;
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
decl_stmt|;
name|bkt_alloc
operator|=
name|serf_request_get_alloc
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|c
operator|=
name|serf_bucket_barrier_create
argument_list|(
name|stream
argument_list|,
name|bkt_alloc
argument_list|)
expr_stmt|;
return|return
name|serf_bucket_response_create
argument_list|(
name|c
argument_list|,
name|bkt_alloc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Custom response acceptor for HEAD requests.  */
end_comment

begin_function
specifier|static
name|serf_bucket_t
modifier|*
name|accept_head
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|acceptor_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|accept_response
argument_list|(
name|request
argument_list|,
name|stream
argument_list|,
name|acceptor_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We know we shouldn't get a response body. */
name|serf_bucket_response_set_head
argument_list|(
name|response
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|connection_closed
parameter_list|(
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|apr_status_t
name|why
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|why
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|why
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|conn
operator|->
name|session
operator|->
name|using_ssl
condition|)
name|conn
operator|->
name|ssl_context
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_ra_serf__conn_closed
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|void
modifier|*
name|closed_baton
parameter_list|,
name|apr_status_t
name|why
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|ra_conn
init|=
name|closed_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|connection_closed
argument_list|(
name|ra_conn
argument_list|,
name|why
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|save_error
argument_list|(
name|ra_conn
operator|->
name|session
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implementation of svn_ra_serf__handle_client_cert */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_client_cert
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cert_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
init|=
name|data
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|conn
operator|->
name|session
decl_stmt|;
specifier|const
name|char
modifier|*
name|realm
decl_stmt|;
name|void
modifier|*
name|creds
decl_stmt|;
operator|*
name|cert_path
operator|=
name|NULL
expr_stmt|;
name|realm
operator|=
name|construct_realm
argument_list|(
name|session
argument_list|,
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conn
operator|->
name|ssl_client_auth_state
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_auth_first_credentials
argument_list|(
operator|&
name|creds
argument_list|,
operator|&
name|conn
operator|->
name|ssl_client_auth_state
argument_list|,
name|SVN_AUTH_CRED_SSL_CLIENT_CERT
argument_list|,
name|realm
argument_list|,
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_auth_next_credentials
argument_list|(
operator|&
name|creds
argument_list|,
name|conn
operator|->
name|ssl_client_auth_state
argument_list|,
name|session
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|creds
condition|)
block|{
name|svn_auth_cred_ssl_client_cert_t
modifier|*
name|client_creds
decl_stmt|;
name|client_creds
operator|=
name|creds
expr_stmt|;
operator|*
name|cert_path
operator|=
name|client_creds
operator|->
name|cert_file
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements serf_ssl_need_client_cert_t for handle_client_cert */
end_comment

begin_function
name|apr_status_t
name|svn_ra_serf__handle_client_cert
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cert_path
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
init|=
name|data
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|conn
operator|->
name|session
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|handle_client_cert
argument_list|(
name|data
argument_list|,
name|cert_path
argument_list|,
name|session
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|save_error
argument_list|(
name|session
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implementation for svn_ra_serf__handle_client_cert_pw */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_client_cert_pw
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|cert_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|password
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
init|=
name|data
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|conn
operator|->
name|session
decl_stmt|;
name|void
modifier|*
name|creds
decl_stmt|;
operator|*
name|password
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|conn
operator|->
name|ssl_client_pw_auth_state
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_auth_first_credentials
argument_list|(
operator|&
name|creds
argument_list|,
operator|&
name|conn
operator|->
name|ssl_client_pw_auth_state
argument_list|,
name|SVN_AUTH_CRED_SSL_CLIENT_CERT_PW
argument_list|,
name|cert_path
argument_list|,
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_auth_next_credentials
argument_list|(
operator|&
name|creds
argument_list|,
name|conn
operator|->
name|ssl_client_pw_auth_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|creds
condition|)
block|{
name|svn_auth_cred_ssl_client_cert_pw_t
modifier|*
name|pw_creds
decl_stmt|;
name|pw_creds
operator|=
name|creds
expr_stmt|;
operator|*
name|password
operator|=
name|pw_creds
operator|->
name|password
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Implements serf_ssl_need_client_cert_pw_t for handle_client_cert_pw */
end_comment

begin_function
name|apr_status_t
name|svn_ra_serf__handle_client_cert_pw
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|cert_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|password
parameter_list|)
block|{
name|svn_ra_serf__connection_t
modifier|*
name|conn
init|=
name|data
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|conn
operator|->
name|session
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|handle_client_cert_pw
argument_list|(
name|data
argument_list|,
name|cert_path
argument_list|,
name|password
argument_list|,
name|session
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|save_error
argument_list|(
name|session
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a REQUEST on connection CONN, construct a request bucket for it,  * returning the bucket in *REQ_BKT.  *  * If HDRS_BKT is not-NULL, it will be set to a headers_bucket that  * corresponds to the new request.  *  * The request will be METHOD at URL.  *  * If BODY_BKT is not-NULL, it will be sent as the request body.  *  * If CONTENT_TYPE is not-NULL, it will be sent as the Content-Type header.  *  * REQUEST_POOL should live for the duration of the request. Serf will  * construct this and provide it to the request_setup callback, so we  * should just use that one.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_serf_req
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|req_bkt
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|hdrs_bkt
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|serf_bucket_t
modifier|*
name|body_bkt
parameter_list|,
specifier|const
name|char
modifier|*
name|content_type
parameter_list|,
specifier|const
name|char
modifier|*
name|accept_encoding
parameter_list|,
name|apr_pool_t
modifier|*
name|request_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|serf_bucket_alloc_t
modifier|*
name|allocator
init|=
name|serf_request_get_alloc
argument_list|(
name|request
argument_list|)
decl_stmt|;
name|svn_spillbuf_t
modifier|*
name|buf
decl_stmt|;
name|svn_boolean_t
name|set_CL
init|=
name|session
operator|->
name|http10
operator|||
operator|!
name|session
operator|->
name|using_chunked_requests
decl_stmt|;
if|if
condition|(
name|set_CL
operator|&&
name|body_bkt
operator|!=
name|NULL
condition|)
block|{
comment|/* Ugh. Use HTTP/1.0 to talk to the server because we don't know if          it speaks HTTP/1.1 (and thus, chunked requests), or because the          server actually responded as only supporting HTTP/1.0.           We'll take the existing body_bkt, spool it into a spillbuf, and          then wrap a bucket around that spillbuf. The spillbuf will give          us the Content-Length value.  */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__copy_into_spillbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|body_bkt
argument_list|,
name|request_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Destroy original bucket since it content is already copied          to spillbuf. */
name|serf_bucket_destroy
argument_list|(
name|body_bkt
argument_list|)
expr_stmt|;
name|body_bkt
operator|=
name|svn_ra_serf__create_sb_bucket
argument_list|(
name|buf
argument_list|,
name|allocator
argument_list|,
name|request_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Create a request bucket.  Note that this sucker is kind enough to      add a "Host" header for us.  */
operator|*
name|req_bkt
operator|=
name|serf_request_bucket_request_create
argument_list|(
name|request
argument_list|,
name|method
argument_list|,
name|url
argument_list|,
name|body_bkt
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
comment|/* Set the Content-Length value. This will also trigger an HTTP/1.0      request (rather than the default chunked request).  */
if|if
condition|(
name|set_CL
condition|)
block|{
if|if
condition|(
name|body_bkt
operator|==
name|NULL
condition|)
name|serf_bucket_request_set_CL
argument_list|(
operator|*
name|req_bkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|serf_bucket_request_set_CL
argument_list|(
operator|*
name|req_bkt
argument_list|,
name|svn_spillbuf__get_size
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|hdrs_bkt
operator|=
name|serf_bucket_request_get_headers
argument_list|(
operator|*
name|req_bkt
argument_list|)
expr_stmt|;
comment|/* We use serf_bucket_headers_setn() because the USERAGENT has a      lifetime longer than this bucket. Thus, there is no need to copy      the header values.  */
name|serf_bucket_headers_setn
argument_list|(
operator|*
name|hdrs_bkt
argument_list|,
literal|"User-Agent"
argument_list|,
name|session
operator|->
name|useragent
argument_list|)
expr_stmt|;
if|if
condition|(
name|content_type
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
operator|*
name|hdrs_bkt
argument_list|,
literal|"Content-Type"
argument_list|,
name|content_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|session
operator|->
name|http10
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
operator|*
name|hdrs_bkt
argument_list|,
literal|"Connection"
argument_list|,
literal|"keep-alive"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accept_encoding
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
operator|*
name|hdrs_bkt
argument_list|,
literal|"Accept-Encoding"
argument_list|,
name|accept_encoding
argument_list|)
expr_stmt|;
block|}
comment|/* These headers need to be sent with every request; see issue #3255      ("mod_dav_svn does not pass client capabilities to start-commit      hooks") for why. */
name|serf_bucket_headers_setn
argument_list|(
operator|*
name|hdrs_bkt
argument_list|,
literal|"DAV"
argument_list|,
name|SVN_DAV_NS_DAV_SVN_DEPTH
argument_list|)
expr_stmt|;
name|serf_bucket_headers_setn
argument_list|(
operator|*
name|hdrs_bkt
argument_list|,
literal|"DAV"
argument_list|,
name|SVN_DAV_NS_DAV_SVN_MERGEINFO
argument_list|)
expr_stmt|;
name|serf_bucket_headers_setn
argument_list|(
operator|*
name|hdrs_bkt
argument_list|,
literal|"DAV"
argument_list|,
name|SVN_DAV_NS_DAV_SVN_LOG_REVPROPS
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__context_run_wait
parameter_list|(
name|svn_boolean_t
modifier|*
name|done
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_interval_time_t
name|waittime_left
init|=
name|sess
operator|->
name|timeout
decl_stmt|;
name|assert
argument_list|(
name|sess
operator|->
name|pending_error
operator|==
name|SVN_NO_ERROR
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|*
name|done
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|sess
operator|->
name|cancel_func
call|)
argument_list|(
name|sess
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|serf_context_run
argument_list|(
name|sess
operator|->
name|context
argument_list|,
name|SVN_RA_SERF__CONTEXT_RUN_DURATION
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|sess
operator|->
name|pending_error
expr_stmt|;
name|sess
operator|->
name|pending_error
operator|=
name|SVN_NO_ERROR
expr_stmt|;
comment|/* If the context duration timeout is up, we'll subtract that          duration from the total time alloted for such things.  If          there's no time left, we fail with a message indicating that          the connection timed out.  */
if|if
condition|(
name|APR_STATUS_IS_TIMEUP
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
name|waittime_left
operator|>
name|SVN_RA_SERF__CONTEXT_RUN_DURATION
condition|)
block|{
name|waittime_left
operator|-=
name|SVN_RA_SERF__CONTEXT_RUN_DURATION
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_CONN_TIMEOUT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Connection timed out"
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
name|waittime_left
operator|=
name|sess
operator|->
name|timeout
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|status
operator|>=
name|SVN_ERR_BAD_CATEGORY_START
operator|&&
name|status
operator|<
name|SVN_ERR_LAST
condition|)
block|{
comment|/* apr can't translate subversion errors to text */
name|SVN_ERR_W
argument_list|(
name|svn_error_create
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Error running context"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Error running context"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Debugging purposes only! */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sess
operator|->
name|num_conns
condition|;
name|i
operator|++
control|)
block|{
name|serf_debug__closed_conn
argument_list|(
name|sess
operator|->
name|conns
index|[
name|i
index|]
operator|->
name|bkt_alloc
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__context_run_one
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Create a serf request based on HANDLER.  */
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
comment|/* Wait until the response logic marks its DONE status.  */
name|err
operator|=
name|svn_ra_serf__context_run_wait
argument_list|(
operator|&
name|handler
operator|->
name|done
argument_list|,
name|handler
operator|->
name|session
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* A callback invocation has been canceled. In this simple case of      context_run_one, we can keep the ra-session operational by resetting      the connection.       If we don't do this, the next context run will notice that the connection      is still in the error state and will just return SVN_ERR_CEASE_INVOCATION      (=the last error for the connection) again  */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CEASE_INVOCATION
condition|)
block|{
name|apr_status_t
name|status
init|=
name|serf_connection_reset
argument_list|(
name|handler
operator|->
name|conn
operator|->
name|conn
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
condition|)
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handler
operator|->
name|server_error
condition|)
block|{
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|handler
operator|->
name|server_error
operator|->
name|error
argument_list|)
expr_stmt|;
name|handler
operator|->
name|server_error
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expat callback invoked on a start element tag for an error response.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|start_error
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|namespace
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctx
operator|->
name|in_error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"human-readable"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|err_code
decl_stmt|;
name|err_code
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"errcode"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_code
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|err_code
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|error
operator|->
name|apr_err
operator|=
operator|(
name|apr_status_t
operator|)
name|val
expr_stmt|;
block|}
comment|/* If there's no error code provided, or if the provided code is          0 (which can happen sometimes depending on how the error is          constructed on the server-side), just pick a generic error          code to run with. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|error
operator|->
name|apr_err
condition|)
block|{
name|ctx
operator|->
name|error
operator|->
name|apr_err
operator|=
name|SVN_ERR_RA_DAV_REQUEST_FAILED
expr_stmt|;
block|}
comment|/* Start collecting cdata. */
name|svn_stringbuf_setempty
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|collect_cdata
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Expat callback invoked on an end element tag for a PROPFIND response.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|end_error
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|namespace
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctx
operator|->
name|in_error
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"human-readable"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* On the server dav_error_response_tag() will add a leading          and trailing newline if DEBUG_CR is defined in mod_dav.h,          so remove any such characters here. */
name|svn_stringbuf_strip_whitespace
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|error
operator|->
name|message
operator|=
name|apr_pstrmemdup
argument_list|(
name|ctx
operator|->
name|error
operator|->
name|pool
argument_list|,
name|ctx
operator|->
name|cdata
operator|->
name|data
argument_list|,
name|ctx
operator|->
name|cdata
operator|->
name|len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|collect_cdata
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Expat callback invoked on CDATA elements in an error response.  *  * This callback can be called multiple times.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cdata_error
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|collect_cdata
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|drain_bucket
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
comment|/* Read whatever is in the bucket, and just drop it.  */
while|while
condition|(
literal|1
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|bucket
argument_list|,
name|SERF_READ_ALL_AVAIL
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|svn_ra_serf__server_error_t
modifier|*
name|begin_error_parsing
parameter_list|(
name|svn_ra_serf__xml_start_element_t
name|start
parameter_list|,
name|svn_ra_serf__xml_end_element_t
name|end
parameter_list|,
name|svn_ra_serf__xml_cdata_chunk_handler_t
name|cdata
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|server_err
decl_stmt|;
name|server_err
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|server_err
argument_list|)
argument_list|)
expr_stmt|;
name|server_err
operator|->
name|error
operator|=
name|svn_error_create
argument_list|(
name|APR_SUCCESS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|server_err
operator|->
name|contains_precondition_error
operator|=
name|FALSE
expr_stmt|;
name|server_err
operator|->
name|cdata
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|server_err
operator|->
name|error
operator|->
name|pool
argument_list|)
expr_stmt|;
name|server_err
operator|->
name|collect_cdata
operator|=
name|FALSE
expr_stmt|;
name|server_err
operator|->
name|parser
operator|.
name|pool
operator|=
name|server_err
operator|->
name|error
operator|->
name|pool
expr_stmt|;
name|server_err
operator|->
name|parser
operator|.
name|user_data
operator|=
name|server_err
expr_stmt|;
name|server_err
operator|->
name|parser
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|server_err
operator|->
name|parser
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|server_err
operator|->
name|parser
operator|.
name|cdata
operator|=
name|cdata
expr_stmt|;
name|server_err
operator|->
name|parser
operator|.
name|ignore_errors
operator|=
name|TRUE
expr_stmt|;
return|return
name|server_err
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_discard_body
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|drain_bucket
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|apr_status_t
name|svn_ra_serf__response_discard_handler
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|drain_bucket
argument_list|(
name|response
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the RESPONSE's Location header if any, or NULL    otherwise.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|response_get_location
parameter_list|(
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
specifier|const
name|char
modifier|*
name|base_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|headers
decl_stmt|;
specifier|const
name|char
modifier|*
name|location
decl_stmt|;
name|headers
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|location
operator|=
name|serf_bucket_headers_get
argument_list|(
name|headers
argument_list|,
literal|"Location"
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* The RFCs say we should have received a full url in LOCATION, but      older apache versions and many custom web handlers just return a      relative path here...       And we can't trust anything because it is network data.    */
if|if
condition|(
operator|*
name|location
operator|==
literal|'/'
condition|)
block|{
name|apr_uri_t
name|uri
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|scratch_pool
argument_list|,
name|base_url
argument_list|,
operator|&
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|NULL
return|;
comment|/* Replace the path path with what we got */
name|uri
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|svn_urlpath__canonicalize
argument_list|(
name|location
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* And make APR produce a proper full url for us */
name|location
operator|=
name|apr_uri_unparse
argument_list|(
name|scratch_pool
argument_list|,
operator|&
name|uri
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through to ensure our canonicalization rules */
block|}
elseif|else
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|location
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
comment|/* Any other formats we should support? */
block|}
return|return
name|svn_uri_canonicalize
argument_list|(
name|location
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__expect_empty_body
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|baton
decl_stmt|;
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
comment|/* This function is just like handle_multistatus_only() except for the      XML parsing callbacks. We want to look for the human-readable element.  */
comment|/* We should see this just once, in order to initialize SERVER_ERROR.      At that point, the core error processing will take over. If we choose      not to parse an error, then we'll never return here (because we      change the response handler).  */
name|SVN_ERR_ASSERT
argument_list|(
name|handler
operator|->
name|server_error
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Content-Type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|strncasecmp
argument_list|(
name|val
argument_list|,
literal|"text/xml"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"text/xml"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|server_err
decl_stmt|;
name|server_err
operator|=
name|begin_error_parsing
argument_list|(
name|start_error
argument_list|,
name|end_error
argument_list|,
name|cdata_error
argument_list|,
name|handler
operator|->
name|handler_pool
argument_list|)
expr_stmt|;
comment|/* Get the parser to set our DONE flag.  */
name|server_err
operator|->
name|parser
operator|.
name|done
operator|=
operator|&
name|handler
operator|->
name|done
expr_stmt|;
name|handler
operator|->
name|server_error
operator|=
name|server_err
expr_stmt|;
block|}
else|else
block|{
comment|/* The body was not text/xml, so we don't know what to do with it.          Toss anything that arrives.  */
name|handler
operator|->
name|discard_body
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Returning SVN_NO_ERROR will return APR_SUCCESS to serf, which tells it      to call the response handler again. That will start up the XML parsing,      or it will be dropped on the floor (per the decision above).  */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a string like "HTTP/1.1 500 (status)" in BUF, parse out the numeric    status code into *STATUS_CODE_OUT.  Ignores leading whitespace. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_dav_status
parameter_list|(
name|int
modifier|*
name|status_code_out
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|buf
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|char
modifier|*
name|tok_status
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|temp_buf
init|=
name|svn_stringbuf_dup
argument_list|(
name|buf
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|temp_buf
argument_list|)
expr_stmt|;
name|token
operator|=
name|apr_strtok
argument_list|(
name|temp_buf
operator|->
name|data
argument_list|,
literal|" \t\r\n"
argument_list|,
operator|&
name|tok_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
condition|)
name|token
operator|=
name|apr_strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t\r\n"
argument_list|,
operator|&
name|tok_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed DAV:status CDATA '%s'"
argument_list|)
argument_list|,
name|buf
operator|->
name|data
argument_list|)
return|;
name|err
operator|=
name|svn_cstring_atoi
argument_list|(
name|status_code_out
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Malformed DAV:status CDATA '%s'"
argument_list|)
argument_list|,
name|buf
operator|->
name|data
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Expat callback invoked on a start element tag for a 207 response.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|start_207
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|namespace
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"multistatus"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctx
operator|->
name|in_error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"responsedescription"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Start collecting cdata. */
name|svn_stringbuf_setempty
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|collect_cdata
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|namespace
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"status"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Start collecting cdata. */
name|svn_stringbuf_setempty
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|collect_cdata
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Expat callback invoked on an end element tag for a 207 response.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|end_207
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|namespace
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"multistatus"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctx
operator|->
name|in_error
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"responsedescription"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Remove leading newline added by DEBUG_CR on server */
name|svn_stringbuf_strip_whitespace
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|collect_cdata
operator|=
name|FALSE
expr_stmt|;
name|ctx
operator|->
name|error
operator|->
name|message
operator|=
name|apr_pstrmemdup
argument_list|(
name|ctx
operator|->
name|error
operator|->
name|pool
argument_list|,
name|ctx
operator|->
name|cdata
operator|->
name|data
argument_list|,
name|ctx
operator|->
name|cdata
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|contains_precondition_error
condition|)
name|ctx
operator|->
name|error
operator|->
name|apr_err
operator|=
name|SVN_ERR_FS_PROP_BASEVALUE_MISMATCH
expr_stmt|;
else|else
name|ctx
operator|->
name|error
operator|->
name|apr_err
operator|=
name|SVN_ERR_RA_DAV_REQUEST_FAILED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|in_error
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|namespace
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"status"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|status_code
decl_stmt|;
name|ctx
operator|->
name|collect_cdata
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_dav_status
argument_list|(
operator|&
name|status_code
argument_list|,
name|ctx
operator|->
name|cdata
argument_list|,
name|parser
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|==
literal|412
condition|)
name|ctx
operator|->
name|contains_precondition_error
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Expat callback invoked on CDATA elements in a 207 response.  *  * This callback can be called multiple times.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cdata_207
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|collect_cdata
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_multistatus_only
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|baton
decl_stmt|;
comment|/* This function is just like expect_empty_body() except for the      XML parsing callbacks. We are looking for very limited pieces of      the multistatus response.  */
comment|/* We should see this just once, in order to initialize SERVER_ERROR.      At that point, the core error processing will take over. If we choose      not to parse an error, then we'll never return here (because we      change the response handler).  */
name|SVN_ERR_ASSERT
argument_list|(
name|handler
operator|->
name|server_error
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|{
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Content-Type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|strncasecmp
argument_list|(
name|val
argument_list|,
literal|"text/xml"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"text/xml"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|server_err
decl_stmt|;
name|server_err
operator|=
name|begin_error_parsing
argument_list|(
name|start_207
argument_list|,
name|end_207
argument_list|,
name|cdata_207
argument_list|,
name|handler
operator|->
name|handler_pool
argument_list|)
expr_stmt|;
comment|/* Get the parser to set our DONE flag.  */
name|server_err
operator|->
name|parser
operator|.
name|done
operator|=
operator|&
name|handler
operator|->
name|done
expr_stmt|;
name|handler
operator|->
name|server_error
operator|=
name|server_err
expr_stmt|;
block|}
else|else
block|{
comment|/* The body was not text/xml, so we don't know what to do with it.              Toss anything that arrives.  */
name|handler
operator|->
name|discard_body
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Returning SVN_NO_ERROR will return APR_SUCCESS to serf, which tells it      to call the response handler again. That will start up the XML parsing,      or it will be dropped on the floor (per the decision above).  */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to Expat's XML_StartElementHandler  */
end_comment

begin_function
specifier|static
name|void
name|start_xml
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attrs
parameter_list|)
block|{
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
init|=
name|userData
decl_stmt|;
name|svn_ra_serf__dav_props_t
name|name
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|error
condition|)
return|return;
if|if
condition|(
operator|!
name|parser
operator|->
name|state
condition|)
name|svn_ra_serf__xml_push_state
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ### get a real scratch_pool  */
name|scratch_pool
operator|=
name|parser
operator|->
name|state
operator|->
name|pool
expr_stmt|;
name|svn_ra_serf__define_ns
argument_list|(
operator|&
name|parser
operator|->
name|state
operator|->
name|ns_list
argument_list|,
name|attrs
argument_list|,
name|parser
operator|->
name|state
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_ra_serf__expand_ns
argument_list|(
operator|&
name|name
argument_list|,
name|parser
operator|->
name|state
operator|->
name|ns_list
argument_list|,
name|raw_name
argument_list|)
expr_stmt|;
name|err
operator|=
name|parser
operator|->
name|start
argument_list|(
name|parser
argument_list|,
name|name
argument_list|,
name|attrs
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SERF_WRAPPED_ERROR
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parser
operator|->
name|error
operator|=
name|err
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Conforms to Expat's XML_EndElementHandler  */
end_comment

begin_function
specifier|static
name|void
name|end_xml
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|)
block|{
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
init|=
name|userData
decl_stmt|;
name|svn_ra_serf__dav_props_t
name|name
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|error
condition|)
return|return;
comment|/* ### get a real scratch_pool  */
name|scratch_pool
operator|=
name|parser
operator|->
name|state
operator|->
name|pool
expr_stmt|;
name|svn_ra_serf__expand_ns
argument_list|(
operator|&
name|name
argument_list|,
name|parser
operator|->
name|state
operator|->
name|ns_list
argument_list|,
name|raw_name
argument_list|)
expr_stmt|;
name|err
operator|=
name|parser
operator|->
name|end
argument_list|(
name|parser
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SERF_WRAPPED_ERROR
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parser
operator|->
name|error
operator|=
name|err
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Conforms to Expat's XML_CharacterDataHandler  */
end_comment

begin_function
specifier|static
name|void
name|cdata_xml
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
init|=
name|userData
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|error
condition|)
return|return;
if|if
condition|(
operator|!
name|parser
operator|->
name|state
condition|)
name|svn_ra_serf__xml_push_state
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ### get a real scratch_pool  */
name|scratch_pool
operator|=
name|parser
operator|->
name|state
operator|->
name|pool
expr_stmt|;
name|err
operator|=
name|parser
operator|->
name|cdata
argument_list|(
name|parser
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SERF_WRAPPED_ERROR
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parser
operator|->
name|error
operator|=
name|err
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flip the requisite bits in CTX to indicate that processing of the    response is complete, adding the current "done item" to the list of    completed items. */
end_comment

begin_function
specifier|static
name|void
name|add_done_item
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|ctx
parameter_list|)
block|{
comment|/* Make sure we don't add to DONE_LIST twice.  */
if|if
condition|(
operator|!
operator|*
name|ctx
operator|->
name|done
condition|)
block|{
operator|*
name|ctx
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|done_list
condition|)
block|{
name|ctx
operator|->
name|done_item
operator|->
name|data
operator|=
name|ctx
operator|->
name|user_data
expr_stmt|;
name|ctx
operator|->
name|done_item
operator|->
name|next
operator|=
operator|*
name|ctx
operator|->
name|done_list
expr_stmt|;
operator|*
name|ctx
operator|->
name|done_list
operator|=
name|ctx
operator|->
name|done_item
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_to_pending
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|pending
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|pending
operator|=
name|apr_pcalloc
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
operator|->
name|pending
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|pending
operator|->
name|buf
operator|=
name|svn_spillbuf__create
argument_list|(
name|PARSE_CHUNK_SIZE
argument_list|,
name|SPILL_SIZE
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the data into one or more chunks in the spill buffer.  */
return|return
name|svn_error_trace
argument_list|(
name|svn_spillbuf__write
argument_list|(
name|ctx
operator|->
name|pending
operator|->
name|buf
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|inject_to_parser
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
specifier|const
name|serf_status_line
modifier|*
name|sl
parameter_list|)
block|{
name|int
name|xml_status
decl_stmt|;
name|xml_status
operator|=
name|XML_Parse
argument_list|(
name|ctx
operator|->
name|xmlp
argument_list|,
name|data
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|ignore_errors
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml_status
operator|!=
name|XML_STATUS_OK
condition|)
block|{
if|if
condition|(
name|sl
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"XML parsing failed"
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"XML parsing failed: (%d %s)"
argument_list|)
argument_list|,
name|sl
operator|->
name|code
argument_list|,
name|sl
operator|->
name|reason
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Apr pool cleanup handler to release an XML_Parser in success and error    conditions */
end_comment

begin_function
specifier|static
name|apr_status_t
name|xml_parser_cleanup
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|XML_Parser
modifier|*
name|xmlp
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|*
name|xmlp
condition|)
block|{
operator|(
name|void
operator|)
name|XML_ParserFree
argument_list|(
operator|*
name|xmlp
argument_list|)
expr_stmt|;
operator|*
name|xmlp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Limit the amount of pending content to parse at once to< 100KB per    iteration. This number is chosen somewhat arbitrarely. Making it lower    will have a drastical negative impact on performance, whereas increasing it    increases the risk for connection timeouts.  */
end_comment

begin_define
define|#
directive|define
name|PENDING_TO_PARSE
value|PARSE_CHUNK_SIZE * 5
end_define

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__process_pending
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_boolean_t
modifier|*
name|network_eof
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|pending_empty
init|=
name|FALSE
decl_stmt|;
name|apr_size_t
name|cur_read
init|=
literal|0
decl_stmt|;
comment|/* Fast path exit: already paused, nothing to do, or already done.  */
if|if
condition|(
name|parser
operator|->
name|paused
operator|||
name|parser
operator|->
name|pending
operator|==
name|NULL
operator|||
operator|*
name|parser
operator|->
name|done
condition|)
block|{
operator|*
name|network_eof
operator|=
name|parser
operator|->
name|pending
condition|?
name|parser
operator|->
name|pending
operator|->
name|network_eof
else|:
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Parsing the pending conten in the spillbuf will result in many disc i/o      operations. This can be so slow that we don't run the network event      processing loop often enough, resulting in timed out connections.       So we limit the amounts of bytes parsed per iteration.    */
while|while
condition|(
name|cur_read
operator|<
name|PENDING_TO_PARSE
condition|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* Get a block of content, stopping the loop when we run out.  */
name|SVN_ERR
argument_list|(
name|svn_spillbuf__read
argument_list|(
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|,
name|parser
operator|->
name|pending
operator|->
name|buf
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
comment|/* Inject the content into the XML parser.  */
name|SVN_ERR
argument_list|(
name|inject_to_parser
argument_list|(
name|parser
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the XML parsing callbacks paused us, then we're done for now.  */
if|if
condition|(
name|parser
operator|->
name|paused
condition|)
break|break;
name|cur_read
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* The buffer is empty. */
name|pending_empty
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* If the PENDING structures are empty *and* we consumed all content from      the network, then we're completely done with the parsing.  */
if|if
condition|(
name|pending_empty
operator|&&
name|parser
operator|->
name|pending
operator|->
name|network_eof
condition|)
block|{
name|int
name|xml_status
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|parser
operator|->
name|xmlp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Tell the parser that no more content will be parsed. */
name|xml_status
operator|=
name|XML_Parse
argument_list|(
name|parser
operator|->
name|xmlp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_run
argument_list|(
name|parser
operator|->
name|pool
argument_list|,
operator|&
name|parser
operator|->
name|xmlp
argument_list|,
name|xml_parser_cleanup
argument_list|)
expr_stmt|;
name|parser
operator|->
name|xmlp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|parser
operator|->
name|ignore_errors
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parser
operator|->
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml_status
operator|!=
name|XML_STATUS_OK
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"XML parsing failed"
argument_list|)
argument_list|)
return|;
block|}
block|}
name|add_done_item
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
operator|*
name|network_eof
operator|=
name|parser
operator|->
name|pending
condition|?
name|parser
operator|->
name|pending
operator|->
name|network_eof
else|:
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|PENDING_TO_PARSE
end_undef

begin_comment
comment|/* ### this is still broken conceptually. just shifting incrementally... */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_server_error
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__server_error_t
name|server_err
init|=
block|{
literal|0
block|}
decl_stmt|;
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|apr_status_t
name|err
decl_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Content-Type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|strncasecmp
argument_list|(
name|val
argument_list|,
literal|"text/xml"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"text/xml"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ### we should figure out how to reuse begin_error_parsing  */
name|server_err
operator|.
name|error
operator|=
name|svn_error_create
argument_list|(
name|APR_SUCCESS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|server_err
operator|.
name|contains_precondition_error
operator|=
name|FALSE
expr_stmt|;
name|server_err
operator|.
name|cdata
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|server_err
operator|.
name|collect_cdata
operator|=
name|FALSE
expr_stmt|;
name|server_err
operator|.
name|parser
operator|.
name|pool
operator|=
name|server_err
operator|.
name|error
operator|->
name|pool
expr_stmt|;
name|server_err
operator|.
name|parser
operator|.
name|user_data
operator|=
operator|&
name|server_err
expr_stmt|;
name|server_err
operator|.
name|parser
operator|.
name|start
operator|=
name|start_error
expr_stmt|;
name|server_err
operator|.
name|parser
operator|.
name|end
operator|=
name|end_error
expr_stmt|;
name|server_err
operator|.
name|parser
operator|.
name|cdata
operator|=
name|cdata_error
expr_stmt|;
name|server_err
operator|.
name|parser
operator|.
name|done
operator|=
operator|&
name|server_err
operator|.
name|done
expr_stmt|;
name|server_err
operator|.
name|parser
operator|.
name|ignore_errors
operator|=
name|TRUE
expr_stmt|;
comment|/* We don't care about any errors except for SERVER_ERR.ERROR  */
name|svn_error_clear
argument_list|(
name|svn_ra_serf__handle_xml_parser
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
operator|&
name|server_err
operator|.
name|parser
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### checking DONE is silly. the above only parses whatever has          ### been received at the network interface. totally wrong. but          ### it is what we have for now (maintaining historical code),          ### until we fully migrate.  */
if|if
condition|(
name|server_err
operator|.
name|done
operator|&&
name|server_err
operator|.
name|error
operator|->
name|apr_err
operator|==
name|APR_SUCCESS
condition|)
block|{
name|svn_error_clear
argument_list|(
name|server_err
operator|.
name|error
argument_list|)
expr_stmt|;
name|server_err
operator|.
name|error
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|server_err
operator|.
name|error
argument_list|)
return|;
block|}
comment|/* The only error that we will return is from the XML response body.      Otherwise, ignore the entire body but allow SUCCESS/EOF/EAGAIN to      surface. */
name|err
operator|=
name|drain_bucket
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|err
argument_list|)
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_xml_parser
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_status_line
name|sl
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|svn_ra_serf__xml_parser_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* ### get the HANDLER rather than fetching this.  */
name|status
operator|=
name|serf_bucket_response_status
argument_list|(
name|response
argument_list|,
operator|&
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* Woo-hoo.  Nothing here to see.  */
if|if
condition|(
name|sl
operator|.
name|code
operator|==
literal|404
operator|&&
operator|!
name|ctx
operator|->
name|ignore_errors
condition|)
block|{
name|err
operator|=
name|handle_server_error
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
name|add_done_item
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ctx
operator|->
name|xmlp
condition|)
block|{
name|ctx
operator|->
name|xmlp
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
operator|&
name|ctx
operator|->
name|xmlp
argument_list|,
name|xml_parser_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|ctx
operator|->
name|xmlp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|ctx
operator|->
name|xmlp
argument_list|,
name|start_xml
argument_list|,
name|end_xml
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cdata
condition|)
block|{
name|XML_SetCharacterDataHandler
argument_list|(
name|ctx
operator|->
name|xmlp
argument_list|,
name|cdata_xml
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
name|PARSE_CHUNK_SIZE
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* Note: once the callbacks invoked by inject_to_parser() sets the          PAUSED flag, then it will not be cleared. write_to_pending() will          only save the content. Logic outside of serf_context_run() will          clear that flag, as appropriate, along with processing the          content that we have placed into the PENDING buffer.           We want to save arriving content into the PENDING structures if          the parser has been paused, or we already have data in there (so          the arriving data is appended, rather than injected out of order)  */
if|if
condition|(
name|ctx
operator|->
name|paused
operator|||
name|HAS_PENDING_DATA
argument_list|(
name|ctx
operator|->
name|pending
argument_list|)
condition|)
block|{
name|err
operator|=
name|write_to_pending
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|inject_to_parser
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
operator|&
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Should have no errors if IGNORE_ERRORS is set.  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|ctx
operator|->
name|ignore_errors
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|ctx
operator|->
name|xmlp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_run
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
operator|&
name|ctx
operator|->
name|xmlp
argument_list|,
name|xml_parser_cleanup
argument_list|)
expr_stmt|;
name|add_done_item
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|pending
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|pending
operator|->
name|network_eof
operator|=
name|TRUE
expr_stmt|;
comment|/* We just hit the end of the network content. If we have nothing              in the PENDING structures, then we're completely done.  */
if|if
condition|(
operator|!
name|HAS_PENDING_DATA
argument_list|(
name|ctx
operator|->
name|pending
argument_list|)
condition|)
block|{
name|int
name|xml_status
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ctx
operator|->
name|xmlp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xml_status
operator|=
name|XML_Parse
argument_list|(
name|ctx
operator|->
name|xmlp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_run
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
operator|&
name|ctx
operator|->
name|xmlp
argument_list|,
name|xml_parser_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|ignore_errors
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml_status
operator|!=
name|XML_STATUS_OK
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The XML response contains invalid XML"
argument_list|)
argument_list|)
return|;
block|}
block|}
name|add_done_item
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* feed me! */
block|}
comment|/* not reached */
block|}
end_function

begin_function
name|apr_status_t
name|svn_ra_serf__credentials_callback
parameter_list|(
name|char
modifier|*
modifier|*
name|username
parameter_list|,
name|char
modifier|*
modifier|*
name|password
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|authn_type
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|baton
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|handler
operator|->
name|session
decl_stmt|;
name|void
modifier|*
name|creds
decl_stmt|;
name|svn_auth_cred_simple_t
modifier|*
name|simple_creds
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|401
condition|)
block|{
comment|/* Use svn_auth_first_credentials if this is the first time we ask for          credentials during this session OR if the last time we asked          session->auth_state wasn't set (eg. if the credentials provider was          cancelled by the user). */
if|if
condition|(
operator|!
name|session
operator|->
name|auth_state
condition|)
block|{
name|err
operator|=
name|svn_auth_first_credentials
argument_list|(
operator|&
name|creds
argument_list|,
operator|&
name|session
operator|->
name|auth_state
argument_list|,
name|SVN_AUTH_CRED_SIMPLE
argument_list|,
name|realm
argument_list|,
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|svn_auth_next_credentials
argument_list|(
operator|&
name|creds
argument_list|,
name|session
operator|->
name|auth_state
argument_list|,
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
operator|(
name|void
operator|)
name|save_error
argument_list|(
name|session
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
operator|->
name|apr_err
return|;
block|}
name|session
operator|->
name|auth_attempts
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|creds
operator|||
name|session
operator|->
name|auth_attempts
operator|>
literal|4
condition|)
block|{
comment|/* No more credentials. */
operator|(
name|void
operator|)
name|save_error
argument_list|(
name|session
argument_list|,
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHN_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No more credentials or we tried too many "
literal|"times.\nAuthentication failed"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_ERR_AUTHN_FAILED
return|;
block|}
name|simple_creds
operator|=
name|creds
expr_stmt|;
operator|*
name|username
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|simple_creds
operator|->
name|username
argument_list|)
expr_stmt|;
operator|*
name|password
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|simple_creds
operator|->
name|password
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|username
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|session
operator|->
name|proxy_username
argument_list|)
expr_stmt|;
operator|*
name|password
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|session
operator|->
name|proxy_password
argument_list|)
expr_stmt|;
name|session
operator|->
name|proxy_auth_attempts
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|proxy_username
operator|||
name|session
operator|->
name|proxy_auth_attempts
operator|>
literal|4
condition|)
block|{
comment|/* No more credentials. */
operator|(
name|void
operator|)
name|save_error
argument_list|(
name|session
argument_list|,
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHN_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Proxy authentication failed"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_ERR_AUTHN_FAILED
return|;
block|}
block|}
name|handler
operator|->
name|conn
operator|->
name|last_status_code
operator|=
name|code
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Wait for HTTP response status and headers, and invoke HANDLER->    response_handler() to carry out operation-specific processing.    Afterwards, check for connection close.     SERF_STATUS allows returning errors to serf without creating a    subversion error object.    */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_response
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|apr_status_t
modifier|*
name|serf_status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* ### need to verify whether this already gets init'd on every      ### successful exit. for an error-exit, it will (properly) be      ### ignored by the caller.  */
operator|*
name|serf_status
operator|=
name|APR_SUCCESS
expr_stmt|;
if|if
condition|(
operator|!
name|response
condition|)
block|{
comment|/* Uh-oh. Our connection died.  */
if|if
condition|(
name|handler
operator|->
name|response_error
condition|)
block|{
comment|/* Give a handler chance to prevent request requeue. */
name|SVN_ERR
argument_list|(
name|handler
operator|->
name|response_error
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
literal|0
argument_list|,
name|handler
operator|->
name|response_error_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/* Response error callback is not configured. Requeue another request          for this handler only if we didn't started to process body.          Return error otherwise. */
elseif|else
if|if
condition|(
operator|!
name|handler
operator|->
name|reading_body
condition|)
block|{
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s request on '%s' failed"
argument_list|)
argument_list|,
name|handler
operator|->
name|method
argument_list|,
name|handler
operator|->
name|path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If we're reading the body, then skip all this preparation.  */
if|if
condition|(
name|handler
operator|->
name|reading_body
condition|)
goto|goto
name|process_body
goto|;
comment|/* Copy the Status-Line info into HANDLER, if we don't yet have it.  */
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|version
operator|==
literal|0
condition|)
block|{
name|serf_status_line
name|sl
decl_stmt|;
name|status
operator|=
name|serf_bucket_response_status
argument_list|(
name|response
argument_list|,
operator|&
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
block|{
comment|/* The response line is not (yet) ready, or some other error.  */
operator|*
name|serf_status
operator|=
name|status
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* Handled by serf */
block|}
comment|/* If we got APR_SUCCESS, then we should have Status-Line info.  */
name|SVN_ERR_ASSERT
argument_list|(
name|sl
operator|.
name|version
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|handler
operator|->
name|sline
operator|=
name|sl
expr_stmt|;
name|handler
operator|->
name|sline
operator|.
name|reason
operator|=
name|apr_pstrdup
argument_list|(
name|handler
operator|->
name|handler_pool
argument_list|,
name|sl
operator|.
name|reason
argument_list|)
expr_stmt|;
comment|/* HTTP/1.1? (or later)  */
if|if
condition|(
name|sl
operator|.
name|version
operator|!=
name|SERF_HTTP_10
condition|)
name|handler
operator|->
name|session
operator|->
name|http10
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Keep reading from the network until we've read all the headers.  */
name|status
operator|=
name|serf_bucket_response_wait_for_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* The typical "error" will be APR_EAGAIN, meaning that more input          from the network is required to complete the reading of the          headers.  */
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* Either the headers are not (yet) complete, or there really              was an error.  */
operator|*
name|serf_status
operator|=
name|status
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* wait_for_headers() will return EOF if there is no body in this          response, or if we completely read the body. The latter is not          true since we would have set READING_BODY to get the body read,          and we would not be back to this code block.           It can also return EOF if we truly hit EOF while (say) processing          the headers. aka Badness.  */
comment|/* Cases where a lack of a response body (via EOF) is okay:        *  - A HEAD request        *  - 204/304 response        *        * Otherwise, if we get an EOF here, something went really wrong: either        * the server closed on us early or we're reading too much.  Either way,        * scream loudly.        */
if|if
condition|(
name|strcmp
argument_list|(
name|handler
operator|->
name|method
argument_list|,
literal|"HEAD"
argument_list|)
operator|!=
literal|0
operator|&&
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|204
operator|&&
name|handler
operator|->
name|sline
operator|.
name|code
operator|!=
literal|304
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Premature EOF seen from server"
literal|" (http status=%d)"
argument_list|)
argument_list|,
name|handler
operator|->
name|sline
operator|.
name|code
argument_list|)
expr_stmt|;
comment|/* In case anything else arrives... discard it.  */
name|handler
operator|->
name|discard_body
operator|=
name|TRUE
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
comment|/* ... and set up the header fields in HANDLER.  */
name|handler
operator|->
name|location
operator|=
name|response_get_location
argument_list|(
name|response
argument_list|,
name|handler
operator|->
name|session
operator|->
name|session_url_str
argument_list|,
name|handler
operator|->
name|handler_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* On the last request, we failed authentication. We succeeded this time,      so let's save away these credentials.  */
if|if
condition|(
name|handler
operator|->
name|conn
operator|->
name|last_status_code
operator|==
literal|401
operator|&&
name|handler
operator|->
name|sline
operator|.
name|code
operator|<
literal|400
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_auth_save_credentials
argument_list|(
name|handler
operator|->
name|session
operator|->
name|auth_state
argument_list|,
name|handler
operator|->
name|session
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|->
name|session
operator|->
name|auth_attempts
operator|=
literal|0
expr_stmt|;
name|handler
operator|->
name|session
operator|->
name|auth_state
operator|=
name|NULL
expr_stmt|;
block|}
name|handler
operator|->
name|conn
operator|->
name|last_status_code
operator|=
name|handler
operator|->
name|sline
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|==
literal|405
operator|||
name|handler
operator|->
name|sline
operator|.
name|code
operator|==
literal|408
operator|||
name|handler
operator|->
name|sline
operator|.
name|code
operator|==
literal|409
operator|||
name|handler
operator|->
name|sline
operator|.
name|code
operator|>=
literal|500
condition|)
block|{
comment|/* 405 Method Not allowed.          408 Request Timeout          409 Conflict: can indicate a hook error.          5xx (Internal) Server error. */
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Content-Type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|strncasecmp
argument_list|(
name|val
argument_list|,
literal|"text/xml"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"text/xml"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_ra_serf__server_error_t
modifier|*
name|server_err
decl_stmt|;
name|server_err
operator|=
name|begin_error_parsing
argument_list|(
name|start_error
argument_list|,
name|end_error
argument_list|,
name|cdata_error
argument_list|,
name|handler
operator|->
name|handler_pool
argument_list|)
expr_stmt|;
comment|/* Get the parser to set our DONE flag.  */
name|server_err
operator|->
name|parser
operator|.
name|done
operator|=
operator|&
name|handler
operator|->
name|done
expr_stmt|;
name|handler
operator|->
name|server_error
operator|=
name|server_err
expr_stmt|;
block|}
else|else
block|{
name|handler
operator|->
name|discard_body
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|handler
operator|->
name|session
operator|->
name|pending_error
condition|)
block|{
name|apr_status_t
name|apr_err
init|=
name|SVN_ERR_RA_DAV_REQUEST_FAILED
decl_stmt|;
comment|/* 405 == Method Not Allowed (Occurs when trying to lock a working                 copy path which no longer exists at HEAD in the repository. */
if|if
condition|(
name|handler
operator|->
name|sline
operator|.
name|code
operator|==
literal|405
operator|&&
name|strcmp
argument_list|(
name|handler
operator|->
name|method
argument_list|,
literal|"LOCK"
argument_list|)
operator|==
literal|0
condition|)
name|apr_err
operator|=
name|SVN_ERR_FS_OUT_OF_DATE
expr_stmt|;
name|handler
operator|->
name|session
operator|->
name|pending_error
operator|=
name|svn_error_createf
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s request on '%s' failed: %d %s"
argument_list|)
argument_list|,
name|handler
operator|->
name|method
argument_list|,
name|handler
operator|->
name|path
argument_list|,
name|handler
operator|->
name|sline
operator|.
name|code
argument_list|,
name|handler
operator|->
name|sline
operator|.
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Stop processing the above, on every packet arrival.  */
name|handler
operator|->
name|reading_body
operator|=
name|TRUE
expr_stmt|;
name|process_body
label|:
comment|/* We've been instructed to ignore the body. Drain whatever is present.  */
if|if
condition|(
name|handler
operator|->
name|discard_body
condition|)
block|{
operator|*
name|serf_status
operator|=
name|drain_bucket
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* If the handler hasn't set done (which it shouldn't have) and          we now have the EOF, go ahead and set it so that we can stop          our context loops.        */
if|if
condition|(
operator|!
name|handler
operator|->
name|done
operator|&&
name|APR_STATUS_IS_EOF
argument_list|(
operator|*
name|serf_status
argument_list|)
condition|)
name|handler
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If we are supposed to parse the body as a server_error, then do      that now.  */
if|if
condition|(
name|handler
operator|->
name|server_error
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|svn_ra_serf__handle_xml_parser
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
operator|&
name|handler
operator|->
name|server_error
operator|->
name|parser
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If we do not receive an error or it is a non-transient error, return          immediately.           APR_EOF will be returned when parsing is complete.           APR_EAGAIN& WAIT_CONN may be intermittently returned as we proceed through          parsing and the network has no more data right now.  If we receive that,          clear the error and return - allowing serf to wait for more data.          */
if|if
condition|(
operator|!
name|err
operator|||
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
operator|*
name|serf_status
operator|=
name|err
operator|->
name|apr_err
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Clear the EOF. We don't need it.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* If the parsing is done, and we did not extract an error, then          simply toss everything, and anything else that might arrive.          The higher-level code will need to investigate HANDLER->SLINE,          as we have no further information for them.  */
if|if
condition|(
name|handler
operator|->
name|done
operator|&&
name|handler
operator|->
name|server_error
operator|->
name|error
operator|->
name|apr_err
operator|==
name|APR_SUCCESS
condition|)
block|{
name|svn_error_clear
argument_list|(
name|handler
operator|->
name|server_error
operator|->
name|error
argument_list|)
expr_stmt|;
comment|/* Stop parsing for a server error.  */
name|handler
operator|->
name|server_error
operator|=
name|NULL
expr_stmt|;
comment|/* If anything arrives after this, then just discard it.  */
name|handler
operator|->
name|discard_body
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|serf_status
operator|=
name|APR_EOF
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Pass the body along to the registered response handler.  */
name|err
operator|=
name|handler
operator|->
name|response_handler
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|handler
operator|->
name|response_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNRESET
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNABORTED
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
comment|/* These errors are special cased in serf          ### We hope no handler returns these by accident. */
operator|*
name|serf_status
operator|=
name|err
operator|->
name|apr_err
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements serf_response_handler_t for handle_response. Storing    errors in handler->session->pending_error if appropriate. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|handle_response_cb
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_status_t
name|inner_status
decl_stmt|;
name|apr_status_t
name|outer_status
decl_stmt|;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|handle_response
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|handler
argument_list|,
operator|&
name|inner_status
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Select the right status value to return.  */
name|outer_status
operator|=
name|save_error
argument_list|(
name|handler
operator|->
name|session
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outer_status
condition|)
name|outer_status
operator|=
name|inner_status
expr_stmt|;
comment|/* Make sure the DONE flag is set properly.  */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|outer_status
argument_list|)
operator|||
name|APR_STATUS_IS_EOF
argument_list|(
name|inner_status
argument_list|)
condition|)
name|handler
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
return|return
name|outer_status
return|;
block|}
end_function

begin_comment
comment|/* Perform basic request setup, with special handling for HEAD requests,    and finer-grained callbacks invoked (if non-NULL) to produce the request    headers and body. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_request
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|req_bkt
parameter_list|,
name|apr_pool_t
modifier|*
name|request_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|body_bkt
decl_stmt|;
name|serf_bucket_t
modifier|*
name|headers_bkt
decl_stmt|;
specifier|const
name|char
modifier|*
name|accept_encoding
decl_stmt|;
if|if
condition|(
name|handler
operator|->
name|body_delegate
condition|)
block|{
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
init|=
name|serf_request_get_alloc
argument_list|(
name|request
argument_list|)
decl_stmt|;
comment|/* ### should pass the scratch_pool  */
name|SVN_ERR
argument_list|(
name|handler
operator|->
name|body_delegate
argument_list|(
operator|&
name|body_bkt
argument_list|,
name|handler
operator|->
name|body_delegate_baton
argument_list|,
name|bkt_alloc
argument_list|,
name|request_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|body_bkt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|handler
operator|->
name|custom_accept_encoding
condition|)
block|{
name|accept_encoding
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|handler
operator|->
name|session
operator|->
name|using_compression
condition|)
block|{
comment|/* Accept gzip compression if enabled. */
name|accept_encoding
operator|=
literal|"gzip"
expr_stmt|;
block|}
else|else
block|{
name|accept_encoding
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|setup_serf_req
argument_list|(
name|request
argument_list|,
name|req_bkt
argument_list|,
operator|&
name|headers_bkt
argument_list|,
name|handler
operator|->
name|session
argument_list|,
name|handler
operator|->
name|method
argument_list|,
name|handler
operator|->
name|path
argument_list|,
name|body_bkt
argument_list|,
name|handler
operator|->
name|body_type
argument_list|,
name|accept_encoding
argument_list|,
name|request_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|->
name|header_delegate
condition|)
block|{
comment|/* ### should pass the scratch_pool  */
name|SVN_ERR
argument_list|(
name|handler
operator|->
name|header_delegate
argument_list|(
name|headers_bkt
argument_list|,
name|handler
operator|->
name|header_delegate_baton
argument_list|,
name|request_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Implements the serf_request_setup_t interface (which sets up both a    request and its response handler callback). Handles errors for    setup_request_cb */
end_comment

begin_function
specifier|static
name|apr_status_t
name|setup_request_cb
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|req_bkt
parameter_list|,
name|serf_response_acceptor_t
modifier|*
name|acceptor
parameter_list|,
name|void
modifier|*
modifier|*
name|acceptor_baton
parameter_list|,
name|serf_response_handler_t
modifier|*
name|s_handler
parameter_list|,
name|void
modifier|*
modifier|*
name|s_handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
init|=
name|setup_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* ### construct a scratch_pool? serf gives us a pool that will live for      ### the duration of the request.  */
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|pool
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|handler
operator|->
name|method
argument_list|,
literal|"HEAD"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|acceptor
operator|=
name|accept_head
expr_stmt|;
else|else
operator|*
name|acceptor
operator|=
name|accept_response
expr_stmt|;
operator|*
name|acceptor_baton
operator|=
name|handler
operator|->
name|session
expr_stmt|;
operator|*
name|s_handler
operator|=
name|handle_response_cb
expr_stmt|;
operator|*
name|s_handler_baton
operator|=
name|handler
expr_stmt|;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|setup_request
argument_list|(
name|request
argument_list|,
name|handler
argument_list|,
name|req_bkt
argument_list|,
name|pool
comment|/* request_pool */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|save_error
argument_list|(
name|handler
operator|->
name|session
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|svn_ra_serf__request_create
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|)
block|{
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|handler
operator|->
name|handler_pool
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* In case HANDLER is re-queued, reset the various transient fields.       ### prior to recent changes, HANDLER was constant. maybe we should      ### break out these processing fields, apart from the request      ### definition.  */
name|handler
operator|->
name|done
operator|=
name|FALSE
expr_stmt|;
name|handler
operator|->
name|server_error
operator|=
name|NULL
expr_stmt|;
name|handler
operator|->
name|sline
operator|.
name|version
operator|=
literal|0
expr_stmt|;
name|handler
operator|->
name|location
operator|=
name|NULL
expr_stmt|;
name|handler
operator|->
name|reading_body
operator|=
name|FALSE
expr_stmt|;
name|handler
operator|->
name|discard_body
operator|=
name|FALSE
expr_stmt|;
comment|/* ### do we ever alter the>response_handler?  */
comment|/* ### do we need to hold onto the returned request object, or just      ### not worry about it (the serf ctx will manage it).  */
operator|(
name|void
operator|)
name|serf_connection_request_create
argument_list|(
name|handler
operator|->
name|conn
operator|->
name|conn
argument_list|,
name|setup_request_cb
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__discover_vcc
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|vcc_url
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|relative_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
comment|/* If we've already got the information our caller seeks, just return it.  */
if|if
condition|(
name|session
operator|->
name|vcc_url
operator|&&
name|session
operator|->
name|repos_root_str
condition|)
block|{
operator|*
name|vcc_url
operator|=
name|session
operator|->
name|vcc_url
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If no connection is provided, use the default one. */
if|if
condition|(
operator|!
name|conn
condition|)
block|{
name|conn
operator|=
name|session
operator|->
name|conns
index|[
literal|0
index|]
expr_stmt|;
block|}
name|path
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
operator|*
name|vcc_url
operator|=
name|NULL
expr_stmt|;
name|uuid
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_ra_serf__fetch_node_props
argument_list|(
operator|&
name|props
argument_list|,
name|conn
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|base_props
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|apr_hash_t
modifier|*
name|ns_props
decl_stmt|;
name|ns_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
literal|"DAV:"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|vcc_url
operator|=
name|svn_prop_get_value
argument_list|(
name|ns_props
argument_list|,
literal|"version-controlled-configuration"
argument_list|)
expr_stmt|;
name|ns_props
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_DAV_PROP_NS_DAV
argument_list|)
expr_stmt|;
name|relative_path
operator|=
name|svn_prop_get_value
argument_list|(
name|ns_props
argument_list|,
literal|"baseline-relative-path"
argument_list|)
expr_stmt|;
name|uuid
operator|=
name|svn_prop_get_value
argument_list|(
name|ns_props
argument_list|,
literal|"repository-uuid"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_FS_NOT_FOUND
operator|)
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_RA_DAV_FORBIDDEN
operator|)
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* found a _real_ error */
block|}
else|else
block|{
comment|/* This happens when the file is missing in HEAD. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Okay, strip off a component from PATH. */
name|path
operator|=
name|svn_urlpath__dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* An error occurred on conns. serf 0.4.0 remembers that                  the connection had a problem. We need to reset it, in                  order to use it again.  */
name|serf_connection_reset
argument_list|(
name|conn
operator|->
name|conn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|path
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
do|;
if|if
condition|(
operator|!
operator|*
name|vcc_url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include the "
literal|"requested version-controlled-configuration "
literal|"value"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Store our VCC in our cache. */
if|if
condition|(
operator|!
name|session
operator|->
name|vcc_url
condition|)
block|{
name|session
operator|->
name|vcc_url
operator|=
name|apr_pstrdup
argument_list|(
name|session
operator|->
name|pool
argument_list|,
operator|*
name|vcc_url
argument_list|)
expr_stmt|;
block|}
comment|/* Update our cached repository root URL. */
if|if
condition|(
operator|!
name|session
operator|->
name|repos_root_str
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|url_buf
decl_stmt|;
name|url_buf
operator|=
name|svn_stringbuf_create
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_path_remove_components
argument_list|(
name|url_buf
argument_list|,
name|svn_path_component_count
argument_list|(
name|relative_path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now recreate the root_url. */
name|session
operator|->
name|repos_root
operator|=
name|session
operator|->
name|session_url
expr_stmt|;
name|session
operator|->
name|repos_root
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|svn_fspath__canonicalize
argument_list|(
name|url_buf
operator|->
name|data
argument_list|,
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
name|session
operator|->
name|repos_root_str
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|apr_uri_unparse
argument_list|(
name|session
operator|->
name|pool
argument_list|,
operator|&
name|session
operator|->
name|repos_root
argument_list|,
literal|0
argument_list|)
argument_list|,
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Store the repository UUID in the cache. */
if|if
condition|(
operator|!
name|session
operator|->
name|uuid
condition|)
block|{
name|session
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|session
operator|->
name|pool
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_relative_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|rel_path
parameter_list|,
specifier|const
name|char
modifier|*
name|orig_path
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|decoded_root
decl_stmt|,
modifier|*
name|decoded_orig
decl_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|repos_root
operator|.
name|path
condition|)
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
comment|/* This should only happen if we haven't detected HTTP v2          support from the server.  */
name|assert
argument_list|(
operator|!
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't actually care about the VCC_URL, but this API          promises to populate the session's root-url cache, and that's          what we really want. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|conn
condition|?
name|conn
else|:
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|decoded_root
operator|=
name|svn_path_uri_decode
argument_list|(
name|session
operator|->
name|repos_root
operator|.
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|decoded_orig
operator|=
name|svn_path_uri_decode
argument_list|(
name|orig_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|rel_path
operator|=
name|svn_urlpath__skip_ancestor
argument_list|(
name|decoded_root
argument_list|,
name|decoded_orig
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|rel_path
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__report_resource
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|report_target
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* If we have HTTP v2 support, we want to report against the 'me'      resource. */
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
operator|*
name|report_target
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|session
operator|->
name|me_resource
argument_list|)
expr_stmt|;
comment|/* Otherwise, we'll use the default VCC. */
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
name|report_target
argument_list|,
name|session
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__error_on_status
parameter_list|(
name|serf_status_line
name|sline
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|location
parameter_list|)
block|{
switch|switch
condition|(
name|sline
operator|.
name|code
condition|)
block|{
case|case
literal|301
case|:
case|case
literal|302
case|:
case|case
literal|307
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_RELOCATED
argument_list|,
name|NULL
argument_list|,
operator|(
name|sline
operator|.
name|code
operator|==
literal|301
operator|)
condition|?
name|_
argument_list|(
literal|"Repository moved permanently to '%s';"
literal|" please relocate"
argument_list|)
else|:
name|_
argument_list|(
literal|"Repository moved temporarily to '%s';"
literal|" please relocate"
argument_list|)
argument_list|,
name|location
argument_list|)
return|;
case|case
literal|403
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_FORBIDDEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Access to '%s' forbidden"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
case|case
literal|404
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' path not found"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
case|case
literal|423
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s': no lock token available"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
case|case
literal|411
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"DAV request failed: 411 Content length required. The "
literal|"server or an intermediate proxy does not accept "
literal|"chunked encoding. Try setting 'http-chunked-requests' "
literal|"to 'auto' or 'no' in your client configuration."
argument_list|)
argument_list|)
return|;
case|case
literal|501
case|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The requested feature is not supported by "
literal|"'%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
if|if
condition|(
name|sline
operator|.
name|code
operator|>=
literal|300
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected HTTP status %d '%s' on '%s'\n"
argument_list|)
argument_list|,
name|sline
operator|.
name|code
argument_list|,
name|sline
operator|.
name|reason
argument_list|,
name|path
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__register_editor_shim_callbacks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|session
operator|->
name|shim_callbacks
operator|=
name|callbacks
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to Expat's XML_StartElementHandler  */
end_comment

begin_function
specifier|static
name|void
name|expat_start
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attrs
parameter_list|)
block|{
name|struct
name|expat_ctx_t
modifier|*
name|ectx
init|=
name|userData
decl_stmt|;
if|if
condition|(
name|ectx
operator|->
name|inner_error
operator|!=
name|NULL
condition|)
return|return;
name|ectx
operator|->
name|inner_error
operator|=
name|svn_error_trace
argument_list|(
name|svn_ra_serf__xml_cb_start
argument_list|(
name|ectx
operator|->
name|xmlctx
argument_list|,
name|raw_name
argument_list|,
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAT_HAS_STOPPARSER
if|if
condition|(
name|ectx
operator|->
name|inner_error
condition|)
operator|(
name|void
operator|)
name|XML_StopParser
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
literal|0
comment|/* resumable */
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Conforms to Expat's XML_EndElementHandler  */
end_comment

begin_function
specifier|static
name|void
name|expat_end
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|)
block|{
name|struct
name|expat_ctx_t
modifier|*
name|ectx
init|=
name|userData
decl_stmt|;
if|if
condition|(
name|ectx
operator|->
name|inner_error
operator|!=
name|NULL
condition|)
return|return;
name|ectx
operator|->
name|inner_error
operator|=
name|svn_error_trace
argument_list|(
name|svn_ra_serf__xml_cb_end
argument_list|(
name|ectx
operator|->
name|xmlctx
argument_list|,
name|raw_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAT_HAS_STOPPARSER
if|if
condition|(
name|ectx
operator|->
name|inner_error
condition|)
operator|(
name|void
operator|)
name|XML_StopParser
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
literal|0
comment|/* resumable */
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Conforms to Expat's XML_CharacterDataHandler  */
end_comment

begin_function
specifier|static
name|void
name|expat_cdata
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|expat_ctx_t
modifier|*
name|ectx
init|=
name|userData
decl_stmt|;
if|if
condition|(
name|ectx
operator|->
name|inner_error
operator|!=
name|NULL
condition|)
return|return;
name|ectx
operator|->
name|inner_error
operator|=
name|svn_error_trace
argument_list|(
name|svn_ra_serf__xml_cb_cdata
argument_list|(
name|ectx
operator|->
name|xmlctx
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAT_HAS_STOPPARSER
if|if
condition|(
name|ectx
operator|->
name|inner_error
condition|)
operator|(
name|void
operator|)
name|XML_StopParser
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
literal|0
comment|/* resumable */
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|expat_response_handler
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|expat_ctx_t
modifier|*
name|ectx
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|ectx
operator|->
name|parser
condition|)
block|{
name|ectx
operator|->
name|parser
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|ectx
operator|->
name|cleanup_pool
argument_list|,
operator|&
name|ectx
operator|->
name|parser
argument_list|,
name|xml_parser_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|ectx
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|expat_start
argument_list|,
name|expat_end
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|expat_cdata
argument_list|)
expr_stmt|;
block|}
comment|/* ### TODO: sline.code< 200 should really be handled by the core */
if|if
condition|(
operator|(
name|ectx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
operator|<
literal|200
operator|)
operator|||
operator|(
name|ectx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
operator|>=
literal|300
operator|)
condition|)
block|{
comment|/* By deferring to expect_empty_body(), it will make a choice on          how to handle the body. Whatever the decision, the core handler          will take over, and we will not be called again.  */
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__expect_empty_body
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|ectx
operator|->
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|int
name|expat_status
decl_stmt|;
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
name|PARSE_CHUNK_SIZE
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* ### move restart/skip into the core handler  */
block|ectx->handler->read_size += len;
endif|#
directive|endif
comment|/* ### move PAUSED behavior to a new response handler that can feed          ### an inner handler, or can pause for a while.  */
comment|/* ### should we have an IGNORE_ERRORS flag like the v1 parser?  */
name|expat_status
operator|=
name|XML_Parse
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|data
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
literal|0
comment|/* isFinal */
argument_list|)
expr_stmt|;
comment|/* We need to check INNER_ERROR first. This is an error from the          callbacks that has been "dropped off" for us to retrieve. On          current Expat parsers, we stop the parser when an error occurs,          so we want to ignore EXPAT_STATUS (which reports the stoppage).           If an error is not present, THEN we go ahead and look for parsing          errors.  */
if|if
condition|(
name|ectx
operator|->
name|inner_error
condition|)
block|{
name|apr_pool_cleanup_run
argument_list|(
name|ectx
operator|->
name|cleanup_pool
argument_list|,
operator|&
name|ectx
operator|->
name|parser
argument_list|,
name|xml_parser_cleanup
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|ectx
operator|->
name|inner_error
argument_list|)
return|;
block|}
if|if
condition|(
name|expat_status
operator|==
name|XML_STATUS_ERROR
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_XML_MALFORMED
argument_list|,
name|ectx
operator|->
name|inner_error
argument_list|,
name|_
argument_list|(
literal|"The %s response contains invalid XML"
literal|" (%d %s)"
argument_list|)
argument_list|,
name|ectx
operator|->
name|handler
operator|->
name|method
argument_list|,
name|ectx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
argument_list|,
name|ectx
operator|->
name|handler
operator|->
name|sline
operator|.
name|reason
argument_list|)
return|;
comment|/* The parsing went fine. What has the bucket told us?  */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* Tell expat we've reached the end of the content. Ignore the              return status. We just don't care.  */
operator|(
name|void
operator|)
name|XML_Parse
argument_list|(
name|ectx
operator|->
name|parser
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
comment|/* isFinal */
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_context_destroy
argument_list|(
name|ectx
operator|->
name|xmlctx
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_run
argument_list|(
name|ectx
operator|->
name|cleanup_pool
argument_list|,
operator|&
name|ectx
operator|->
name|parser
argument_list|,
name|xml_parser_cleanup
argument_list|)
expr_stmt|;
comment|/* ### should check XMLCTX to see if it has returned to the              ### INITIAL state. we may have ended early...  */
block|}
if|if
condition|(
name|status
operator|&&
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|svn_ra_serf__handler_t
modifier|*
name|svn_ra_serf__create_expat_handler
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|struct
name|expat_ctx_t
modifier|*
name|ectx
decl_stmt|;
name|ectx
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ectx
argument_list|)
argument_list|)
expr_stmt|;
name|ectx
operator|->
name|xmlctx
operator|=
name|xmlctx
expr_stmt|;
name|ectx
operator|->
name|parser
operator|=
name|NULL
expr_stmt|;
name|ectx
operator|->
name|cleanup_pool
operator|=
name|result_pool
expr_stmt|;
name|handler
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|->
name|handler_pool
operator|=
name|result_pool
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|expat_response_handler
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|ectx
expr_stmt|;
name|ectx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
return|return
name|handler
return|;
block|}
end_function

end_unit

