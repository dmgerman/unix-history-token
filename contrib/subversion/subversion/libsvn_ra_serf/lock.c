begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * lock.c :  entry point for locking RA functions for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * This enum represents the current state of our XML parsing for a REPORT.  */
end_comment

begin_enum
enum|enum
block|{
name|INITIAL
init|=
literal|0
block|,
name|PROP
block|,
name|LOCK_DISCOVERY
block|,
name|ACTIVE_LOCK
block|,
name|LOCK_TYPE
block|,
name|LOCK_SCOPE
block|,
name|DEPTH
block|,
name|TIMEOUT
block|,
name|LOCK_TOKEN
block|,
name|OWNER
block|,
name|HREF
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|lock_ctx_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
comment|/* For unlock */
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
comment|/* For lock */
name|svn_boolean_t
name|force
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_boolean_t
name|read_headers
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* The expat handler. We wrap this to do a bit more work.  */
name|svn_ra_serf__response_handler_t
name|inner_handler
decl_stmt|;
name|void
modifier|*
name|inner_baton
decl_stmt|;
block|}
name|lock_ctx_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|D_
value|"DAV:"
end_define

begin_define
define|#
directive|define
name|S_
value|SVN_XML_NAMESPACE
end_define

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_serf__xml_transition_t
name|locks_ttable
index|[]
init|=
block|{
comment|/* The INITIAL state can transition into D:prop (LOCK) or      to D:multistatus (PROPFIND)  */
block|{
name|INITIAL
block|,
name|D_
block|,
literal|"prop"
block|,
name|PROP
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|PROP
block|,
name|D_
block|,
literal|"lockdiscovery"
block|,
name|LOCK_DISCOVERY
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|LOCK_DISCOVERY
block|,
name|D_
block|,
literal|"activelock"
block|,
name|ACTIVE_LOCK
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
if|#
directive|if
literal|0
comment|/* ### we don't really need to parse locktype/lockscope. we know what      ### the values are going to be. we *could* validate that the only      ### possible children are D:write and D:exclusive. we'd need to      ### modify the state transition to tell us about all children      ### (ie. maybe support "*" for the name) and then validate. but it      ### just isn't important to validate, so disable this for now... */
block|{ ACTIVE_LOCK, D_, "locktype", LOCK_TYPE,     FALSE, { NULL }, FALSE },    { LOCK_TYPE, D_, "write", WRITE,     FALSE, { NULL }, TRUE },    { ACTIVE_LOCK, D_, "lockscope", LOCK_SCOPE,     FALSE, { NULL }, FALSE },    { LOCK_SCOPE, D_, "exclusive", EXCLUSIVE,     FALSE, { NULL }, TRUE },
endif|#
directive|endif
comment|/* 0  */
block|{
name|ACTIVE_LOCK
block|,
name|D_
block|,
literal|"timeout"
block|,
name|TIMEOUT
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ACTIVE_LOCK
block|,
name|D_
block|,
literal|"locktoken"
block|,
name|LOCK_TOKEN
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|LOCK_TOKEN
block|,
name|D_
block|,
literal|"href"
block|,
name|HREF
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|ACTIVE_LOCK
block|,
name|D_
block|,
literal|"owner"
block|,
name|OWNER
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
comment|/* ACTIVE_LOCK has a D:depth child, but we can ignore that.  */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Conforms to svn_ra_serf__xml_closed_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|locks_closed
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|leaving_state
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|cdata
parameter_list|,
name|apr_hash_t
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|lock_ctx_t
modifier|*
name|lock_ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|leaving_state
operator|==
name|TIMEOUT
condition|)
block|{
comment|/* This function just parses the result of our own lock request,          so on a normal server we will only encounter 'Infinite' here. */
if|if
condition|(
name|strcasecmp
argument_list|(
name|cdata
operator|->
name|data
argument_list|,
literal|"Infinite"
argument_list|)
operator|==
literal|0
condition|)
name|lock_ctx
operator|->
name|lock
operator|->
name|expiration_date
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|cdata
operator|->
name|data
argument_list|,
literal|"Second-"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|n
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoui
argument_list|(
operator|&
name|n
argument_list|,
name|cdata
operator|->
name|data
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|lock_ctx
operator|->
name|lock
operator|->
name|expiration_date
operator|=
name|apr_time_now
argument_list|()
operator|+
name|apr_time_from_sec
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid LOCK timeout value '%s'"
argument_list|)
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|HREF
condition|)
block|{
if|if
condition|(
name|cdata
operator|->
name|len
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|apr_pstrmemdup
argument_list|(
name|lock_ctx
operator|->
name|pool
argument_list|,
name|cdata
operator|->
name|data
argument_list|,
name|cdata
operator|->
name|len
argument_list|)
decl_stmt|;
name|apr_collapse_spaces
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|lock_ctx
operator|->
name|lock
operator|->
name|token
operator|=
name|buf
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|OWNER
condition|)
block|{
if|if
condition|(
name|cdata
operator|->
name|len
condition|)
block|{
name|lock_ctx
operator|->
name|lock
operator|->
name|comment
operator|=
name|apr_pstrmemdup
argument_list|(
name|lock_ctx
operator|->
name|pool
argument_list|,
name|cdata
operator|->
name|data
argument_list|,
name|cdata
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_lock_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|lock_ctx_t
modifier|*
name|lock_ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|lock_ctx
operator|->
name|force
condition|)
block|{
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_OPTIONS_HEADER
argument_list|,
name|SVN_DAV_OPTION_LOCK_STEAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|lock_ctx
operator|->
name|revision
argument_list|)
condition|)
block|{
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_VERSION_NAME_HEADER
argument_list|,
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|lock_ctx
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Helper function for svn_ra_serf__lock and svn_ra_serf__unlock */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_locks
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|apr_array_header_t
modifier|*
name|lock_ctxs
parameter_list|,
name|svn_boolean_t
name|locking
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_interval_time_t
name|waittime_left
init|=
name|sess
operator|->
name|timeout
decl_stmt|;
name|assert
argument_list|(
name|sess
operator|->
name|pending_error
operator|==
name|SVN_NO_ERROR
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|lock_ctxs
operator|->
name|nelts
condition|)
block|{
name|int
name|i
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run
argument_list|(
name|sess
argument_list|,
operator|&
name|waittime_left
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lock_ctxs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|lock_ctx_t
modifier|*
name|ctx
init|=
name|APR_ARRAY_IDX
argument_list|(
name|lock_ctxs
argument_list|,
name|i
argument_list|,
name|lock_ctx_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|handler
operator|->
name|done
condition|)
block|{
name|svn_error_t
modifier|*
name|server_err
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|cb_err
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|handler
operator|->
name|server_error
condition|)
name|server_err
operator|=
name|svn_ra_serf__server_error_create
argument_list|(
name|ctx
operator|->
name|handler
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Api users expect specific error code to detect failures,                  pass the rest to svn_ra_serf__error_on_status */
switch|switch
condition|(
name|ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
condition|)
block|{
case|case
literal|200
case|:
case|case
literal|204
case|:
name|err
operator|=
name|NULL
expr_stmt|;
comment|/* (un)lock succeeded */
break|break;
case|case
literal|400
case|:
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_LOCK
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No lock on path '%s' (%d %s)"
argument_list|)
argument_list|,
name|ctx
operator|->
name|path
argument_list|,
name|ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
argument_list|,
name|ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|reason
argument_list|)
expr_stmt|;
break|break;
case|case
literal|403
case|:
comment|/* ### Authz can also lead to 403. */
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_LOCK_OWNER_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unlock of '%s' failed (%d %s)"
argument_list|)
argument_list|,
name|ctx
operator|->
name|path
argument_list|,
name|ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
argument_list|,
name|ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|reason
argument_list|)
expr_stmt|;
break|break;
case|case
literal|405
case|:
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in "
literal|"HEAD revision (%d %s)"
argument_list|)
argument_list|,
name|ctx
operator|->
name|path
argument_list|,
name|ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
argument_list|,
name|ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|reason
argument_list|)
expr_stmt|;
break|break;
case|case
literal|423
case|:
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PATH_ALREADY_LOCKED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' already locked "
literal|"(%d %s)"
argument_list|)
argument_list|,
name|ctx
operator|->
name|path
argument_list|,
name|ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|code
argument_list|,
name|ctx
operator|->
name|handler
operator|->
name|sline
operator|.
name|reason
argument_list|)
expr_stmt|;
break|break;
case|case
literal|404
case|:
case|case
literal|409
case|:
case|case
literal|500
case|:
if|if
condition|(
name|server_err
condition|)
block|{
comment|/* Handle out of date, etc by just passing the server                            error */
name|err
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Fall through */
default|default:
name|err
operator|=
name|svn_ra_serf__unexpected_status
argument_list|(
name|ctx
operator|->
name|handler
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|server_err
operator|&&
name|err
operator|&&
name|server_err
operator|->
name|apr_err
operator|==
name|err
operator|->
name|apr_err
condition|)
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|server_err
argument_list|,
name|err
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|server_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|SVN_ERR_IS_UNLOCK_ERROR
argument_list|(
name|err
argument_list|)
operator|&&
operator|!
name|SVN_ERR_IS_LOCK_ERROR
argument_list|(
name|err
argument_list|)
condition|)
block|{
comment|/* If the error that we are going to report is just about the                      POST unlock hook, we should first report that the operation                      succeeded, or the repository and working copy will be                      out of sync... */
if|if
condition|(
name|lock_func
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_REPOS_POST_UNLOCK_HOOK_FAILED
condition|)
block|{
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|lock_func
argument_list|(
name|lock_baton
argument_list|,
name|ctx
operator|->
name|path
argument_list|,
name|locking
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* Don't go through callbacks */
block|}
if|if
condition|(
name|lock_func
condition|)
block|{
name|svn_lock_t
modifier|*
name|report_lock
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|locking
operator|&&
name|ctx
operator|->
name|lock
operator|->
name|token
condition|)
name|report_lock
operator|=
name|ctx
operator|->
name|lock
expr_stmt|;
name|cb_err
operator|=
name|lock_func
argument_list|(
name|lock_baton
argument_list|,
name|ctx
operator|->
name|path
argument_list|,
name|locking
argument_list|,
name|report_lock
argument_list|,
name|err
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cb_err
argument_list|)
expr_stmt|;
name|waittime_left
operator|=
name|sess
operator|->
name|timeout
expr_stmt|;
name|svn_sort__array_delete
argument_list|(
name|lock_ctxs
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__response_handler_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_lock
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|lock_ctx_t
modifier|*
name|ctx
init|=
name|handler_baton
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|read_headers
condition|)
block|{
name|serf_bucket_t
modifier|*
name|headers
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|headers
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_LOCK_OWNER_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|ctx
operator|->
name|lock
operator|->
name|owner
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_CREATIONDATE_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|ctx
operator|->
name|lock
operator|->
name|creation_date
argument_list|,
name|val
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|read_headers
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|ctx
operator|->
name|inner_handler
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|ctx
operator|->
name|inner_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_serf__request_body_delegate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_lock_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|body_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|lock_ctx_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|serf_bucket_t
modifier|*
name|buckets
decl_stmt|;
name|buckets
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_xml_header_buckets
argument_list|(
name|buckets
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|buckets
argument_list|,
name|alloc
argument_list|,
literal|"lockinfo"
argument_list|,
literal|"xmlns"
argument_list|,
literal|"DAV:"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|buckets
argument_list|,
name|alloc
argument_list|,
literal|"lockscope"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_empty_tag_buckets
argument_list|(
name|buckets
argument_list|,
name|alloc
argument_list|,
literal|"exclusive"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|buckets
argument_list|,
name|alloc
argument_list|,
literal|"lockscope"
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|buckets
argument_list|,
name|alloc
argument_list|,
literal|"locktype"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_empty_tag_buckets
argument_list|(
name|buckets
argument_list|,
name|alloc
argument_list|,
literal|"write"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|buckets
argument_list|,
name|alloc
argument_list|,
literal|"locktype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|lock
operator|->
name|comment
condition|)
block|{
name|svn_ra_serf__add_tag_buckets
argument_list|(
name|buckets
argument_list|,
literal|"owner"
argument_list|,
name|ctx
operator|->
name|lock
operator|->
name|comment
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|buckets
argument_list|,
name|alloc
argument_list|,
literal|"lockinfo"
argument_list|)
expr_stmt|;
operator|*
name|body_bkt
operator|=
name|buckets
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_revs
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_array_header_t
modifier|*
name|lock_requests
decl_stmt|;
name|lock_requests
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|apr_hash_count
argument_list|(
name|path_revs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|lock_ctx_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Perhaps we should open more connections than just one? See update.c */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|path_revs
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|req_url
decl_stmt|;
name|lock_ctx_t
modifier|*
name|lock_ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|lock_pool
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|lock_pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|lock_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lock_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|lock_ctx
operator|->
name|pool
operator|=
name|lock_pool
expr_stmt|;
name|lock_ctx
operator|->
name|path
operator|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|lock_ctx
operator|->
name|revision
operator|=
operator|*
operator|(
operator|(
name|svn_revnum_t
operator|*
operator|)
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
operator|)
expr_stmt|;
name|lock_ctx
operator|->
name|lock
operator|=
name|svn_lock_create
argument_list|(
name|lock_pool
argument_list|)
expr_stmt|;
name|lock_ctx
operator|->
name|lock
operator|->
name|path
operator|=
name|lock_ctx
operator|->
name|path
expr_stmt|;
name|lock_ctx
operator|->
name|lock
operator|->
name|comment
operator|=
name|comment
expr_stmt|;
name|lock_ctx
operator|->
name|force
operator|=
name|force
expr_stmt|;
name|req_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|lock_ctx
operator|->
name|path
argument_list|,
name|lock_pool
argument_list|)
expr_stmt|;
name|xmlctx
operator|=
name|svn_ra_serf__xml_context_create
argument_list|(
name|locks_ttable
argument_list|,
name|NULL
argument_list|,
name|locks_closed
argument_list|,
name|NULL
argument_list|,
name|lock_ctx
argument_list|,
name|lock_pool
argument_list|)
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_expat_handler
argument_list|(
name|session
argument_list|,
name|xmlctx
argument_list|,
name|NULL
argument_list|,
name|lock_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"LOCK"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|req_url
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/xml"
expr_stmt|;
comment|/* Same stupid algorithm from get_best_connection() in update.c */
name|handler
operator|->
name|conn
operator|=
name|session
operator|->
name|conns
index|[
name|session
operator|->
name|cur_conn
index|]
expr_stmt|;
name|session
operator|->
name|cur_conn
operator|++
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|cur_conn
operator|>=
name|session
operator|->
name|num_conns
condition|)
name|session
operator|->
name|cur_conn
operator|=
literal|0
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|set_lock_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|lock_ctx
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_lock_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|lock_ctx
expr_stmt|;
name|lock_ctx
operator|->
name|inner_handler
operator|=
name|handler
operator|->
name|response_handler
expr_stmt|;
name|lock_ctx
operator|->
name|inner_baton
operator|=
name|handler
operator|->
name|response_baton
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|handle_lock
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|lock_ctx
expr_stmt|;
name|handler
operator|->
name|no_fail_on_http_failure_status
operator|=
name|TRUE
expr_stmt|;
name|lock_ctx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|lock_requests
argument_list|,
name|lock_ctx_t
operator|*
argument_list|)
operator|=
name|lock_ctx
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|run_locks
argument_list|(
name|session
argument_list|,
name|lock_requests
argument_list|,
name|TRUE
argument_list|,
name|lock_func
argument_list|,
name|lock_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_unlock_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* request pool */
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|lock_ctx_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
literal|"Lock-Token"
argument_list|,
name|ctx
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|force
condition|)
block|{
name|serf_bucket_headers_set
argument_list|(
name|headers
argument_list|,
name|SVN_DAV_OPTIONS_HEADER
argument_list|,
name|SVN_DAV_OPTION_LOCK_BREAK
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__unlock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_tokens
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_array_header_t
modifier|*
name|lock_requests
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If we are stealing locks we need the lock tokens */
if|if
condition|(
name|force
condition|)
block|{
comment|/* Theoretically this part can be improved (for performance) by using          svn_ra_get_locks() to obtain all the locks in a single request, but          do we really want to improve the performance of             $ svn unlock --force *        */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|path_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|svn_lock_t
modifier|*
name|existing_lock
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|path
operator|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|token
operator|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|&&
name|token
index|[
literal|0
index|]
condition|)
continue|continue;
if|if
condition|(
name|session
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|session
operator|->
name|cancel_func
argument_list|(
name|session
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_serf__get_lock
argument_list|(
name|ra_session
argument_list|,
operator|&
name|existing_lock
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|existing_lock
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|path_tokens
argument_list|,
name|path
argument_list|,
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|existing_lock
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_NOT_LOCKED
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"'%s' is not locked in the repository"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_func
condition|)
block|{
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|err2
operator|=
name|lock_func
argument_list|(
name|lock_baton
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|err
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|path_tokens
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ### Perhaps we should open more connections than just one? See update.c */
name|lock_requests
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|apr_hash_count
argument_list|(
name|path_tokens
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|lock_ctx_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|path_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
specifier|const
name|char
modifier|*
name|req_url
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|lock_ctx_t
modifier|*
name|lock_ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|lock_pool
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|lock_pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|lock_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|lock_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lock_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|lock_ctx
operator|->
name|pool
operator|=
name|lock_pool
expr_stmt|;
name|lock_ctx
operator|->
name|path
operator|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|token
operator|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|lock_ctx
operator|->
name|force
operator|=
name|force
expr_stmt|;
name|lock_ctx
operator|->
name|token
operator|=
name|apr_pstrcat
argument_list|(
name|lock_pool
argument_list|,
literal|"<"
argument_list|,
name|token
argument_list|,
literal|">"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|req_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|lock_ctx
operator|->
name|path
argument_list|,
name|lock_pool
argument_list|)
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_handler
argument_list|(
name|session
argument_list|,
name|lock_pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"UNLOCK"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|req_url
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|set_unlock_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|lock_ctx
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__expect_empty_body
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|handler
expr_stmt|;
name|handler
operator|->
name|no_fail_on_http_failure_status
operator|=
name|TRUE
expr_stmt|;
name|lock_ctx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|lock_requests
argument_list|,
name|lock_ctx_t
operator|*
argument_list|)
operator|=
name|lock_ctx
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|run_locks
argument_list|(
name|session
argument_list|,
name|lock_requests
argument_list|,
name|FALSE
argument_list|,
name|lock_func
argument_list|,
name|lock_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

