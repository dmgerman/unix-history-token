begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ra_serf.h : Private declarations for the Serf-based DAV RA module.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_LIBSVN_RA_SERF_RA_SERF_H
end_ifndef

begin_define
define|#
directive|define
name|SVN_LIBSVN_RA_SERF_RA_SERF_H
end_define

begin_escape
end_escape

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_comment
comment|/* for XML_Parser  */
end_comment

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dav_protocol.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_editor.h"
end_include

begin_include
include|#
directive|include
file|"blncache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
comment|/* Enforce the minimum version of serf. */
if|#
directive|if
operator|!
name|SERF_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|2
operator|,
literal|1
argument_list|)
error|#
directive|error
error|Please update your version of serf to at least 1.2.1.
endif|#
directive|endif
comment|/** Wait duration (in microseconds) used in calls to serf_context_run() */
define|#
directive|define
name|SVN_RA_SERF__CONTEXT_RUN_DURATION
value|500000
comment|/* Forward declarations. */
typedef|typedef
name|struct
name|svn_ra_serf__session_t
name|svn_ra_serf__session_t
typedef|;
comment|/* A serf connection and optionally associated SSL context.  */
typedef|typedef
struct|struct
name|svn_ra_serf__connection_t
block|{
comment|/* Our connection to a server. */
name|serf_connection_t
modifier|*
name|conn
decl_stmt|;
comment|/* Bucket allocator for this connection. */
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
decl_stmt|;
comment|/* Collected cert failures in chain.  */
name|int
name|server_cert_failures
decl_stmt|;
comment|/* What was the last HTTP status code we got on this connection? */
name|int
name|last_status_code
decl_stmt|;
comment|/* Optional SSL context for this connection. */
name|serf_ssl_context_t
modifier|*
name|ssl_context
decl_stmt|;
name|svn_auth_iterstate_t
modifier|*
name|ssl_client_auth_state
decl_stmt|;
name|svn_auth_iterstate_t
modifier|*
name|ssl_client_pw_auth_state
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
decl_stmt|;
block|}
name|svn_ra_serf__connection_t
typedef|;
comment|/** Maximum value we'll allow for the http-max-connections config option.  *  * Note: minimum 2 connections are required for ra_serf to function  * correctly!  */
define|#
directive|define
name|SVN_RA_SERF__MAX_CONNECTIONS_LIMIT
value|8
comment|/*  * The master serf RA session.  *  * This is stored in the ra session ->priv field.  *  * ### Check ra_serf_dup_session when adding fields.  */
struct|struct
name|svn_ra_serf__session_t
block|{
comment|/* Pool for allocations during this session */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_hash_t
modifier|*
name|config
decl_stmt|;
comment|/* For duplicating */
comment|/* The current context */
name|serf_context_t
modifier|*
name|context
decl_stmt|;
comment|/* The maximum number of connections we'll use for parallelized      fetch operations (updates, etc.) */
name|apr_int64_t
name|max_connections
decl_stmt|;
comment|/* Are we using ssl */
name|svn_boolean_t
name|using_ssl
decl_stmt|;
comment|/* Should we ask for compressed responses? */
name|svn_boolean_t
name|using_compression
decl_stmt|;
comment|/* The user agent string */
specifier|const
name|char
modifier|*
name|useragent
decl_stmt|;
comment|/* The current connection */
name|svn_ra_serf__connection_t
modifier|*
name|conns
index|[
name|SVN_RA_SERF__MAX_CONNECTIONS_LIMIT
index|]
decl_stmt|;
name|int
name|num_conns
decl_stmt|;
name|int
name|cur_conn
decl_stmt|;
comment|/* The URL that was passed into _open() */
name|apr_uri_t
name|session_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|session_url_str
decl_stmt|;
comment|/* The actual discovered root; may be NULL until we know it. */
name|apr_uri_t
name|repos_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_str
decl_stmt|;
comment|/* The server is not Apache/mod_dav_svn (directly) and only supports      HTTP/1.0. Thus, we cannot send chunked requests.  */
name|svn_boolean_t
name|http10
decl_stmt|;
comment|/* Should we use Transfer-Encoding: chunked for HTTP/1.1 servers. */
name|svn_boolean_t
name|using_chunked_requests
decl_stmt|;
comment|/* Do we need to detect whether the connection supports chunked requests?      i.e. is there a (reverse) proxy that does not support them?  */
name|svn_boolean_t
name|detect_chunking
decl_stmt|;
comment|/* Our Version-Controlled-Configuration; may be NULL until we know it. */
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
comment|/* Authentication related properties. */
name|svn_auth_iterstate_t
modifier|*
name|auth_state
decl_stmt|;
name|int
name|auth_attempts
decl_stmt|;
comment|/* Callback functions to get info from WC */
specifier|const
name|svn_ra_callbacks2_t
modifier|*
name|wc_callbacks
decl_stmt|;
name|void
modifier|*
name|wc_callback_baton
decl_stmt|;
name|svn_auth_baton_t
modifier|*
name|auth_baton
decl_stmt|;
comment|/* Callback function to send progress info to the client */
name|svn_ra_progress_notify_func_t
name|progress_func
decl_stmt|;
name|void
modifier|*
name|progress_baton
decl_stmt|;
comment|/* Callback function to handle cancellation */
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
comment|/* Ev2 shim callbacks */
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
decl_stmt|;
comment|/* Error that we've received but not yet returned upstream. */
name|svn_error_t
modifier|*
name|pending_error
decl_stmt|;
comment|/* List of authn types supported by the client.*/
name|int
name|authn_types
decl_stmt|;
comment|/* Maps SVN_RA_CAPABILITY_foo keys to "yes" or "no" values.      If a capability is not yet discovered, it is absent from the table.      The table itself is allocated in the svn_ra_serf__session_t's pool;      keys and values must have at least that lifetime.  Most likely      the keys and values are constants anyway (and sufficiently      well-informed internal code may just compare against those      constants' addresses, therefore). */
name|apr_hash_t
modifier|*
name|capabilities
decl_stmt|;
comment|/* Activity collection URL.  (Cached from the initial OPTIONS      request when run against HTTPv1 servers.)  */
specifier|const
name|char
modifier|*
name|activity_collection_url
decl_stmt|;
comment|/* Are we using a proxy? */
name|svn_boolean_t
name|using_proxy
decl_stmt|;
specifier|const
name|char
modifier|*
name|proxy_username
decl_stmt|;
specifier|const
name|char
modifier|*
name|proxy_password
decl_stmt|;
name|int
name|proxy_auth_attempts
decl_stmt|;
comment|/* SSL server certificates */
name|svn_boolean_t
name|trust_default_ca
decl_stmt|;
specifier|const
name|char
modifier|*
name|ssl_authorities
decl_stmt|;
comment|/* Repository UUID */
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
comment|/* Connection timeout value */
name|apr_interval_time_t
name|timeout
decl_stmt|;
comment|/* HTTPv1 flags */
name|svn_tristate_t
name|supports_deadprop_count
decl_stmt|;
comment|/*** HTTP v2 protocol stuff. ***    *    * We assume that if mod_dav_svn sends one of the special v2 OPTIONs    * response headers, it has sent all of them.  Specifically, we'll    * be looking at the presence of the "me resource" as a flag that    * the server supports v2 of our HTTP protocol.    */
comment|/* The "me resource".  Typically used as a target for REPORTs that      are path-agnostic.  If we have this, we can speak HTTP v2 to the      server.  */
specifier|const
name|char
modifier|*
name|me_resource
decl_stmt|;
comment|/* Opaque URL "stubs".  If the OPTIONS response returns these, then      we know we're using HTTP protocol v2. */
specifier|const
name|char
modifier|*
name|rev_stub
decl_stmt|;
comment|/* for accessing revisions (i.e. revprops) */
specifier|const
name|char
modifier|*
name|rev_root_stub
decl_stmt|;
comment|/* for accessing REV/PATH pairs */
specifier|const
name|char
modifier|*
name|txn_stub
decl_stmt|;
comment|/* for accessing transactions (i.e. txnprops) */
specifier|const
name|char
modifier|*
name|txn_root_stub
decl_stmt|;
comment|/* for accessing TXN/PATH pairs */
specifier|const
name|char
modifier|*
name|vtxn_stub
decl_stmt|;
comment|/* for accessing transactions (i.e. txnprops) */
specifier|const
name|char
modifier|*
name|vtxn_root_stub
decl_stmt|;
comment|/* for accessing TXN/PATH pairs */
comment|/* Hash mapping const char * server-supported POST types to      disinteresting-but-non-null values. */
name|apr_hash_t
modifier|*
name|supported_posts
decl_stmt|;
comment|/*** End HTTP v2 stuff ***/
name|svn_ra_serf__blncache_t
modifier|*
name|blncache
decl_stmt|;
comment|/* Trisate flag that indicates user preference for using bulk updates      (svn_tristate_true) with all the properties and content in the      update-report response. If svn_tristate_false, request a skelta      update-report with inlined properties. If svn_tristate_unknown then use      server preference. */
name|svn_tristate_t
name|bulk_updates
decl_stmt|;
comment|/* Indicates if the server wants bulk update requests (Prefer) or only      accepts skelta requests (Off). If this value is On both options are      allowed. */
specifier|const
name|char
modifier|*
name|server_allows_bulk
decl_stmt|;
comment|/* Indicates if the server supports sending inlined props in update editor    * in skelta mode (send-all == 'false'). */
name|svn_boolean_t
name|supports_inline_props
decl_stmt|;
comment|/* Indicates whether the server supports issuing replay REPORTs      against rev resources (children of `rev_stub', elsestruct). */
name|svn_boolean_t
name|supports_rev_rsrc_replay
decl_stmt|;
block|}
struct|;
define|#
directive|define
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
parameter_list|(
name|sess
parameter_list|)
value|((sess)->me_resource != NULL)
comment|/*  * Structure which represents a DAV element with a NAMESPACE and NAME.  */
typedef|typedef
struct|struct
name|svn_ra_serf__dav_props_t
block|{
comment|/* Element namespace */
specifier|const
name|char
modifier|*
name|xmlns
decl_stmt|;
comment|/* Element name */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|svn_ra_serf__dav_props_t
typedef|;
comment|/** DAV property sets **/
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|base_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"version-controlled-configuration"
block|}
block|,
block|{
literal|"DAV:"
block|,
literal|"resourcetype"
block|}
block|,
block|{
name|SVN_DAV_PROP_NS_DAV
block|,
literal|"baseline-relative-path"
block|}
block|,
block|{
name|SVN_DAV_PROP_NS_DAV
block|,
literal|"repository-uuid"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|checked_in_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"checked-in"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|baseline_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"baseline-collection"
block|}
block|,
block|{
literal|"DAV:"
block|,
name|SVN_DAV__VERSION_NAME
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|all_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"allprop"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|check_path_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"resourcetype"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|type_and_checksum_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"resourcetype"
block|}
block|,
block|{
name|SVN_DAV_PROP_NS_DAV
block|,
literal|"sha1-checksum"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
comment|/* WC props compatibility with ra_neon. */
define|#
directive|define
name|SVN_RA_SERF__WC_CHECKED_IN_URL
value|SVN_PROP_WC_PREFIX "ra_dav:version-url"
comment|/** Serf utility functions **/
name|apr_status_t
name|svn_ra_serf__conn_setup
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|read_bkt
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|write_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
name|void
name|svn_ra_serf__conn_closed
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|void
modifier|*
name|closed_baton
parameter_list|,
name|apr_status_t
name|why
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Helper function to provide SSL client certificates.  *  * NOTE: This function sets the session's 'pending_error' member when  *       returning an non-success status.  */
name|apr_status_t
name|svn_ra_serf__handle_client_cert
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cert_path
parameter_list|)
function_decl|;
comment|/* Helper function to provide SSL client certificate passwords.  *  * NOTE: This function sets the session's 'pending_error' member when  *       returning an non-success status.  */
name|apr_status_t
name|svn_ra_serf__handle_client_cert_pw
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|cert_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|password
parameter_list|)
function_decl|;
comment|/*  * This function will run the serf context in SESS until *DONE is TRUE.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__context_run_wait
parameter_list|(
name|svn_boolean_t
modifier|*
name|done
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Run the context once. Manage waittime_left to handle timing out when    nothing happens over the session->timout.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__context_run
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|apr_interval_time_t
modifier|*
name|waittime_left
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback for response handlers */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__response_handler_t
function_decl|)
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback when the request is done */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__response_done_delegate_t
function_decl|)
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|done_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback for when a request body is needed. */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__request_body_delegate_t
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|body_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|request_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback for when request headers are needed. */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__request_header_delegate_t
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|request_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback for when a response has an error. */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__response_error_t
function_decl|)
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|int
name|status_code
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
function_decl|;
comment|/* ### we should reorder the types in this file.  */
typedef|typedef
name|struct
name|svn_ra_serf__server_error_t
name|svn_ra_serf__server_error_t
typedef|;
comment|/*  * Structure that can be passed to our default handler to guide the  * execution of the request through its lifecycle.  *  * Use svn_ra_serf__create_handler() to create instances of this struct.  */
typedef|typedef
struct|struct
name|svn_ra_serf__handler_t
block|{
comment|/* The HTTP method string of the request */
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
comment|/* The resource to the execute the method on. */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The content-type of the request body. */
specifier|const
name|char
modifier|*
name|body_type
decl_stmt|;
comment|/* If TRUE then default Accept-Encoding request header is not configured for      request. If FALSE then 'gzip' accept encoding will be used if compression      enabled. */
name|svn_boolean_t
name|custom_accept_encoding
decl_stmt|;
comment|/* If TRUE then default DAV: capabilities request headers is not configured      for request. */
name|svn_boolean_t
name|no_dav_headers
decl_stmt|;
comment|/* If TRUE doesn't fail requests on HTTP error statuses like 405, 408, 500      (see util.c response_done()) */
name|svn_boolean_t
name|no_fail_on_http_failure_status
decl_stmt|;
comment|/* If TRUE doesn't fail requests on HTTP redirect statuses like 301, 307 */
name|svn_boolean_t
name|no_fail_on_http_redirect_status
decl_stmt|;
comment|/* Has the request/response been completed?  */
name|svn_boolean_t
name|done
decl_stmt|;
name|svn_boolean_t
name|scheduled
decl_stmt|;
comment|/* Is the request scheduled in a context */
comment|/* If we captured an error from the server, then this will be non-NULL.      It will be allocated from HANDLER_POOL.  */
name|svn_ra_serf__server_error_t
modifier|*
name|server_error
decl_stmt|;
comment|/* The handler and baton pair for our handler. */
name|svn_ra_serf__response_handler_t
name|response_handler
decl_stmt|;
name|void
modifier|*
name|response_baton
decl_stmt|;
comment|/* When REPONSE_HANDLER is invoked, the following fields will be set      based on the response header. HANDLER_POOL must be non-NULL for these      values to be filled in. SLINE.REASON and LOCATION will be allocated      within HANDLER_POOL.  */
name|serf_status_line
name|sline
decl_stmt|;
comment|/* The parsed Status-Line  */
specifier|const
name|char
modifier|*
name|location
decl_stmt|;
comment|/* The Location: header, if any  */
comment|/* This function and baton pair allows handling the completion of request.    *    * The default handler is responsible for the HTTP failure processing.    *    * If no_fail_on_http_failure_status is not TRUE, then the callback will    * return recorded server errors or if there is none and the http status    * specifies an error returns an error for that.    *    * The default baton is the handler itself.    */
name|svn_ra_serf__response_done_delegate_t
name|done_delegate
decl_stmt|;
name|void
modifier|*
name|done_delegate_baton
decl_stmt|;
comment|/* The handler and baton pair to be executed when a non-recoverable error    * is detected.  If it is NULL in the presence of an error, an abort() may    * be triggered.    */
name|svn_ra_serf__response_error_t
name|response_error
decl_stmt|;
name|void
modifier|*
name|response_error_baton
decl_stmt|;
comment|/* This function and baton pair allows for custom request headers to    * be set.    *    * It will be executed after the request has been set up but before it is    * delivered.    */
name|svn_ra_serf__request_header_delegate_t
name|header_delegate
decl_stmt|;
name|void
modifier|*
name|header_delegate_baton
decl_stmt|;
comment|/* This function and baton pair allows a body to be created right before    * delivery.    *    * It will be executed after the request has been set up but before it is    * delivered.    *    * May be NULL if there is no body to send.    *    */
name|svn_ra_serf__request_body_delegate_t
name|body_delegate
decl_stmt|;
name|void
modifier|*
name|body_delegate_baton
decl_stmt|;
comment|/* The connection and session to be used for this request. */
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
decl_stmt|;
comment|/* Internal flag to indicate we've parsed the headers.  */
name|svn_boolean_t
name|reading_body
decl_stmt|;
comment|/* When this flag will be set, the core handler will discard any unread      portion of the response body. The registered response handler will      no longer be called.  */
name|svn_boolean_t
name|discard_body
decl_stmt|;
comment|/* Pool for allocating SLINE.REASON and LOCATION. If this pool is NULL,      then the requestor does not care about SLINE and LOCATION.  */
name|apr_pool_t
modifier|*
name|handler_pool
decl_stmt|;
block|}
name|svn_ra_serf__handler_t
typedef|;
comment|/* Run one request and process the response.     Similar to context_run_wait(), but this creates the request for HANDLER    and then waits for it to complete.     WARNING: context_run_wait() does NOT create a request, whereas this    function DOES. Avoid a double-create.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__context_run_one
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * Helper function to queue a request in the @a handler's connection.  */
name|void
name|svn_ra_serf__request_create
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|)
function_decl|;
comment|/* v2 of the XML parsing functions  */
comment|/* The XML parsing context.  */
typedef|typedef
name|struct
name|svn_ra_serf__xml_context_t
name|svn_ra_serf__xml_context_t
typedef|;
comment|/* An opaque structure for the XML parse element/state.  */
typedef|typedef
name|struct
name|svn_ra_serf__xml_estate_t
name|svn_ra_serf__xml_estate_t
typedef|;
comment|/* Called just after the parser moves into ENTERED_STATE. The tag causing    the transition is passed in TAG.     This callback is applied to a parsing context by using the    svn_ra_serf__xml_context_customize() function.     NOTE: this callback, when set, will be invoked on *every* transition.    The callback must examine ENTERED_STATE to determine if any action    must be taken. The original state is not provided, but must be derived    from ENTERED_STATE and/or the TAG causing the transition (if needed).  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__xml_opened_t
function_decl|)
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|entered_state
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|tag
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Called just before the parser leaves LEAVING_STATE.     If cdata collection was enabled for this state, then CDATA will be    non-NULL and contain the collected cdata.     If attribute collection was enabled for this state, then ATTRS will    contain the attributes collected for this element only, along with    any values stored via svn_ra_serf__xml_note().     Use svn_ra_serf__xml_gather_since() to gather up data from outer states.     ATTRS is char* -> char*.     Temporary allocations may be made in SCRATCH_POOL.  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__xml_closed_t
function_decl|)
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|leaving_state
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|cdata
parameter_list|,
name|apr_hash_t
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Called for all states that are not using the builtin cdata collection.    This callback is (only) appropriate for unbounded-size cdata content.     CURRENT_STATE may be used to decide what to do with the data.     Temporary allocations may be made in SCRATCH_POOL.  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__xml_cdata_t
function_decl|)
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|current_state
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Magic state value for the initial state in a svn_ra_serf__xml_transition_t    table */
define|#
directive|define
name|XML_STATE_INITIAL
value|0
comment|/* State transition table.     When the XML Context is constructed, it is in state 0. User states are    positive integers.     In a list of transitions, use { 0 } to indicate the end. Specifically,    the code looks for NS == NULL.     The initial state for each transition table is XML_STATE_INITIAL.     ### more docco */
typedef|typedef
struct|struct
name|svn_ra_serf__xml_transition_t
block|{
comment|/* This transition applies when in this state  */
name|int
name|from_state
decl_stmt|;
comment|/* And when this tag is observed  */
specifier|const
name|char
modifier|*
name|ns
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Moving to this state  */
name|int
name|to_state
decl_stmt|;
comment|/* Should the cdata of NAME be collected? Note that CUSTOM_CLOSE should      be TRUE in order to capture this cdata.  */
name|svn_boolean_t
name|collect_cdata
decl_stmt|;
comment|/* Which attributes of NAME should be collected? Terminate with NULL.      Maximum of 10 attributes may be collected. Note that attribute      namespaces are ignored at this time.       Attribute names beginning with "?" are optional. Other names must      exist on the element, or SVN_ERR_XML_ATTRIB_NOT_FOUND will be raised.  */
specifier|const
name|char
modifier|*
name|collect_attrs
index|[
literal|11
index|]
decl_stmt|;
comment|/* When NAME is closed, should the callback be invoked?  */
name|svn_boolean_t
name|custom_close
decl_stmt|;
block|}
name|svn_ra_serf__xml_transition_t
typedef|;
comment|/* Constructor for svn_ra_serf__handler_t. Initializes a new handler    with default settings for SESSION. */
name|svn_ra_serf__handler_t
modifier|*
name|svn_ra_serf__create_handler
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/* Construct an XML parsing context, based on the TTABLE transition table.    As content is parsed, the CLOSED_CB callback will be invoked according    to the definition in the table.     If OPENED_CB is not NULL, then it will be invoked for *every* tag-open    event. The callback will need to use the ENTERED_STATE and TAG parameters    to decide what it would like to do.     If CDATA_CB is not NULL, then it will be called for all cdata that is    not be automatically collected (based on the transition table record's    COLLECT_CDATA flag). It will be called in every state, so the callback    must examine the CURRENT_STATE parameter to decide what to do.     The same BATON value will be passed to all three callbacks.     The context will be created within RESULT_POOL.  */
name|svn_ra_serf__xml_context_t
modifier|*
name|svn_ra_serf__xml_context_create
parameter_list|(
specifier|const
name|svn_ra_serf__xml_transition_t
modifier|*
name|ttable
parameter_list|,
name|svn_ra_serf__xml_opened_t
name|opened_cb
parameter_list|,
name|svn_ra_serf__xml_closed_t
name|closed_cb
parameter_list|,
name|svn_ra_serf__xml_cdata_t
name|cdata_cb
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/* Verifies if the parsing completed successfully and destroys    all subpools. */
name|svn_error_t
modifier|*
name|svn_ra_serf__xml_context_done
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|)
function_decl|;
comment|/* Construct a handler with the response function/baton set up to parse    a response body using the given XML context. The handler and its    internal structures are allocated in RESULT_POOL.     As part of the handling the http status value is compared to 200, or    if EXPECTED_STATUS is not NULL to all the values in EXPECTED_STATUS.    EXPECTED_STATUS is expected to be a list of integers ending with a 0    that lives at least as long as RESULT_POOL. If the status doesn't    match the request has failed and will be parsed as en error response.     This also initializes HANDLER_POOL to the given RESULT_POOL.  */
name|svn_ra_serf__handler_t
modifier|*
name|svn_ra_serf__create_expat_handler
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
specifier|const
name|int
modifier|*
name|expected_status
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/* Allocated within XES->STATE_POOL. Changes are not allowd (callers    should make a deep copy if they need to make changes).     The resulting hash maps char* names to char* values.  */
name|apr_hash_t
modifier|*
name|svn_ra_serf__xml_gather_since
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|int
name|stop_state
parameter_list|)
function_decl|;
comment|/* Attach the NAME/VALUE pair onto this/parent state identified by STATE.    The name and value will be copied into the target state's pool.     These values will be available to the CLOSED_CB for the target state,    or part of the gathered state via xml_gather_since().     Typically, this function is used by a child state's close callback,    or within an opening callback to store additional data.     Note: if the state is not found, then a programmer error has occurred,    so the function will invoke SVN_ERR_MALFUNCTION().  */
name|void
name|svn_ra_serf__xml_note
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|int
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
comment|/* Returns XES->STATE_POOL for allocating structures that should live    as long as the state identified by XES.     Note: a state pool is created upon demand, so only use this function    when memory is required for a given state.  */
name|apr_pool_t
modifier|*
name|svn_ra_serf__xml_state_pool
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|)
function_decl|;
comment|/*  * Parses a server-side error message into a local Subversion error.  */
struct|struct
name|svn_ra_serf__server_error_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* XML parser and namespace used to parse the remote response */
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
name|svn_ra_serf__response_handler_t
name|response_handler
decl_stmt|;
name|void
modifier|*
name|response_baton
decl_stmt|;
comment|/* The partial errors to construct the final error from */
name|apr_array_header_t
modifier|*
name|items
decl_stmt|;
comment|/* The hooked handler */
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
block|}
struct|;
comment|/*  * Handler that discards the entire @a response body associated with a  * @a request.  Implements svn_ra_serf__response_handler_t.  *  * If @a baton is a svn_ra_serf__server_error_t (i.e. non-NULL) and an  * error is detected, it will be populated for later detection.  *  * All temporary allocations will be made in a @a pool.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_discard_body
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/*  * Handler that retrieves the embedded XML multistatus response from the  * the @a RESPONSE body associated with a @a REQUEST.  *  * Implements svn_ra_serf__response_handler_t.  *  * The @a BATON should be of type svn_ra_serf__handler_t. When the request  * is complete, the handler's DONE flag will be set to TRUE.  *  * All temporary allocations will be made in a @a scratch_pool.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_multistatus_only
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Handler that expects an empty body.     If a body IS present, and it is text/xml, then it will be parsed for    a server-side error.     BATON should be the svn_ra_serf__handler_t running REQUEST.     Status line information will be in HANDLER->SLINE.     Any parsed errors will be left in HANDLER->SERVER_ERROR. That member    may be NULL if no body was present, or a problem occurred trying to    parse the body.     All temporary allocations will be made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__expect_empty_body
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * This function sets up error parsing for an existing request  */
name|svn_error_t
modifier|*
name|svn_ra_serf__setup_error_parsing
parameter_list|(
name|svn_ra_serf__server_error_t
modifier|*
modifier|*
name|server_err
parameter_list|,
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|svn_boolean_t
name|expect_207_only
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * Forwards response data to the server error parser  */
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_server_error
parameter_list|(
name|svn_ra_serf__server_error_t
modifier|*
name|server_error
parameter_list|,
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|apr_status_t
modifier|*
name|serf_status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * Creates the svn_error_t * instance from the error recorded in  * HANDLER->server_error  */
name|svn_error_t
modifier|*
name|svn_ra_serf__server_error_create
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* serf_response_handler_t implementation that completely discards  * the response.  *  * All temporary allocations will be made in @a pool.  */
name|apr_status_t
name|svn_ra_serf__response_discard_handler
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/*  * Add the appropriate serf buckets to @a agg_bucket represented by  * the XML * @a tag and @a value.  *  * The bucket will be allocated from @a bkt_alloc.  */
name|void
name|svn_ra_serf__add_tag_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|)
function_decl|;
comment|/*  * Add the appropriate serf buckets to AGG_BUCKET with standard XML header:  *<?xml version="1.0" encoding="utf-8"?>  *  * The bucket will be allocated from BKT_ALLOC.  */
name|void
name|svn_ra_serf__add_xml_header_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|)
function_decl|;
comment|/*  * Add the appropriate serf buckets to AGG_BUCKET representing the XML  * open tag with name TAG.  *  * Take the tag's attributes from varargs, a NULL-terminated list of  * alternating<tt>char *</tt> key and<tt>char *</tt> val.  Attribute  * will be ignored if it's value is NULL.  *  * NOTE: Callers are responsible for XML-escaping attribute values as  * necessary.  *  * The bucket will be allocated from BKT_ALLOC.  */
name|void
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|serf_bucket_t
operator|*
name|agg_bucket
argument_list|,
name|serf_bucket_alloc_t
operator|*
name|bkt_alloc
argument_list|,
specifier|const
name|char
operator|*
name|tag
argument_list|,
operator|...
argument_list|)
name|SVN_NEEDS_SENTINEL_NULL
decl_stmt|;
comment|/*  * Add the appropriate serf buckets to AGG_BUCKET representing xml tag close  * with name TAG.  *  * The bucket will be allocated from BKT_ALLOC.  */
name|void
name|svn_ra_serf__add_close_tag_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
function_decl|;
comment|/* Add the appropriate serf buckets to AGG_BUCKET representing the XML  * open tag with name TAG, and then immediately closes the tag using the />  * notation  */
name|void
name|svn_ra_serf__add_empty_tag_buckets
argument_list|(
name|serf_bucket_t
operator|*
name|agg_bucket
argument_list|,
name|serf_bucket_alloc_t
operator|*
name|bkt_alloc
argument_list|,
specifier|const
name|char
operator|*
name|tag
argument_list|,
operator|...
argument_list|)
name|SVN_NEEDS_SENTINEL_NULL
decl_stmt|;
comment|/*  * Add the appropriate serf buckets to AGG_BUCKET with xml-escaped  * version of DATA.  *  * The bucket will be allocated from BKT_ALLOC.  */
name|void
name|svn_ra_serf__add_cdata_len_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
function_decl|;
comment|/** PROPFIND-related functions **/
comment|/* Removes all non regular properties from PROPS */
name|void
name|svn_ra_serf__keep_only_regular_props
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback used via svn_ra_serf__deliver_props2 */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__prop_func_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * Implementation of svn_ra_serf__prop_func_t that just delivers svn compatible  * properties  in the apr_hash_t * that is used as baton.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__deliver_svn_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * This function will create a handler for a PROPFIND request, which will deliver  * properties to PROP_FUNC() with PROP_BATON for the properties listed in LOOKUP_PROPS  * at URL for DEPTH ("0","1","infinity").  */
name|svn_error_t
modifier|*
name|svn_ra_serf__create_propfind_handler
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
modifier|*
name|handler
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|depth
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|find_props
parameter_list|,
name|svn_ra_serf__prop_func_t
name|prop_func
parameter_list|,
name|void
modifier|*
name|prop_func_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/* Using SESSION, fetch the properties specified by WHICH_PROPS using CONN    for URL at REVISION. The resulting properties are placed into a 2-level    hash in RESULTS, mapping NAMESPACE -> hash<PROPNAME, PROPVALUE>, which    is allocated in RESULT_POOL.     If REVISION is SVN_INVALID_REVNUM, then the properties are fetched    from HEAD for URL.     This function performs the request synchronously.     Temporary allocations are made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__fetch_node_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|results
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|which_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Using SESSION, fetch a DAV: property from the resource identified by URL    within REVISION. The PROPNAME may be one of:       "checked-in"      "href"     The resulting value will be allocated in RESULT_POOL, and may be NULL    if the property does not exist (note: "href" always exists).     This function performs the request synchronously.     Temporary allocations are made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__fetch_dav_prop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Map a property name, as passed over the wire, into its corresponding    Subversion-internal name. The returned name will be a static value,    or allocated within RESULT_POOL.     If the property should be ignored (eg. some DAV properties), then NULL    will be returned.  */
specifier|const
name|char
modifier|*
name|svn_ra_serf__svnname_from_wirename
parameter_list|(
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/** MERGE-related functions **/
name|void
name|svn_ra_serf__merge_lock_token_list
parameter_list|(
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
specifier|const
name|char
modifier|*
name|parent
parameter_list|,
name|serf_bucket_t
modifier|*
name|body
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Create an MERGE request aimed at the SESSION url, requesting the    merge of the resource identified by MERGE_RESOURCE_URL.    LOCK_TOKENS is a hash mapping paths to lock tokens owned by the    client.  If KEEP_LOCKS is set, instruct the server to not release    locks set on the paths included in this commit.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__run_merge
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
modifier|*
name|commit_info
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|merge_resource_url
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/** OPTIONS-related functions **/
comment|/* When running with a proxy, we may need to detect and correct for problems.    This probing function will send a simple OPTIONS request to detect problems    with the connection.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__probe_proxy
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|serf_sess
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* On HTTPv2 connections, run an OPTIONS request over CONN to fetch the    current youngest revnum, returning it in *YOUNGEST.     (the revnum is headers of the OPTIONS response)     This function performs the request synchronously.     All temporary allocations will be made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__v2_get_youngest_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* On HTTPv1 connections, run an OPTIONS request over CONN to fetch the    activity collection set and return it in *ACTIVITY_URL, allocated    from RESULT_POOL.     (the activity-collection-set is in the body of the OPTIONS response)     This function performs the request synchronously.     All temporary allocations will be made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__v1_get_activity_collection
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|activity_url
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Set @a VCC_URL to the default VCC for our repository based on @a  * ORIG_PATH for the session @a SESSION, ensuring that the VCC URL and  * repository root URLs are cached in @a SESSION.  *  * All temporary allocations will be made in @a SCRATCH_POOL. */
name|svn_error_t
modifier|*
name|svn_ra_serf__discover_vcc
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|vcc_url
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Set @a REPORT_TARGET to the URI of the resource at which generic  * (path-agnostic) REPORTs should be aimed for @a SESSION.  *  * All temporary allocations will be made in @a POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__report_resource
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|report_target
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set @a REL_PATH to a path (not URI-encoded) relative to the root of  * the repository pointed to by @a SESSION, based on original path  * (URI-encoded) @a ORIG_PATH.  Use @a CONN for any required network  * communications if it is non-NULL; otherwise use the default  * connection.  Use POOL for allocations.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_relative_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|rel_path
parameter_list|,
specifier|const
name|char
modifier|*
name|orig_path
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Using the default connection in SESSION (conns[0]), get the youngest    revnum from the server, returning it in *YOUNGEST.     This function operates synchronously.     All temporary allocations are performed in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_youngest_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Generate a revision-stable URL.     The RA APIs all refer to user/public URLs that float along with the    youngest revision. In many cases, we do NOT want to work with that URL    since it can change from one moment to the next. Especially if we    attempt to operation against multiple floating URLs -- we could end up    referring to two separate revisions.     The DAV RA provider(s) solve this by generating a URL that is specific    to a revision by using a URL into a "baseline collection".     For a specified SESSION, generate a revision-stable URL for URL at    REVISION. If REVISION is    SVN_INVALID_REVNUM, then the stable URL will    refer to the youngest revision at the time this function was called.     If URL is NULL, then the session root will be used.     The stable URL will be placed into *STABLE_URL, allocated from RESULT_POOL.     If LATEST_REVNUM is not NULL, then the revision used will be placed into    *LATEST_REVNUM. That will be equal to youngest, or the given REVISION.     This function operates synchronously, if any communication to the server    is required. Communication is needed if REVISION is SVN_INVALID_REVNUM    (to get the current youngest revnum), or if the specified REVISION is not    (yet) in our cache of baseline collections.     All temporary allocations are performed in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_stable_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|stable_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|latest_revnum
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/** RA functions **/
comment|/* Implements svn_ra__vtable_t.reparent(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__reparent
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.rev_prop(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_string_t
modifier|*
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_log(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_log
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.check_path(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__check_path
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.stat(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__stat
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_dirent_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_locations(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_locations
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locations
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|location_revisions
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_location_segments(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_location_segments
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_location_segment_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.do_diff(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__do_diff
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|diff_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
specifier|const
name|char
modifier|*
name|versus_url
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|diff_editor
parameter_list|,
name|void
modifier|*
name|diff_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.do_status(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__do_status
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|status_target
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|status_editor
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.do_update(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__do_update
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision_to_update_to
parameter_list|,
specifier|const
name|char
modifier|*
name|update_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.do_switch(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__do_switch
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision_to_switch_to
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|switch_editor
parameter_list|,
name|void
modifier|*
name|switch_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_file_revs(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_file_revs
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
name|svn_file_rev_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_dated_revision(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_dated_revision
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|apr_time_t
name|tm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_commit_editor().  *  * Note: Like other commit editors, the returned editor requires that the  * @c copyfrom_path parameter passed to its @c add_file and @c add_directory  * methods is a URL, not a relative path.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_commit_editor
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|callback
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_file(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_file
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_dir(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_dir
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|dirents
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|ret_props
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_uint32_t
name|dirent_fields
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.change_rev_prop(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__change_rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.replay(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__replay
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.replay_range(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__replay_range
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
name|svn_ra_replay_revstart_callback_t
name|revstart_func
parameter_list|,
name|svn_ra_replay_revfinish_callback_t
name|revfinish_func
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.lock(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_revs
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.unlock(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__unlock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_tokens
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_lock(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_lock_t
modifier|*
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_locks(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_locks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locks
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Request a mergeinfo-report from the URL attached to SESSION,    and fill in the MERGEINFO hash with the results.     Implements svn_ra__vtable_t.get_mergeinfo().  */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_mergeinfo
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|mergeinfo
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Exchange capabilities with the server, by sending an OPTIONS  * request announcing the client's capabilities, and by filling  * SERF_SESS->capabilities with the server's capabilities as read from  * the response headers.  Use POOL only for temporary allocation.  *  * If the CORRECTED_URL is non-NULL, allow the OPTIONS response to  * report a server-dictated redirect or relocation (HTTP 301 or 302  * error codes), setting *CORRECTED_URL to the value of the corrected  * repository URL.  Otherwise, such responses from the server will  * generate an error.  (In either case, no capabilities are exchanged  * if there is, in fact, such a response from the server.)  */
name|svn_error_t
modifier|*
name|svn_ra_serf__exchange_capabilities
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|serf_sess
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|corrected_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.has_capability(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__has_capability
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_boolean_t
modifier|*
name|has
parameter_list|,
specifier|const
name|char
modifier|*
name|capability
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_deleted_rev(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_deleted_rev
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision_deleted
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements the get_inherited_props RA layer function. */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_inherited_props
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|iprops
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_repos_root(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_repos_root
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.register_editor_shim_callbacks(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__register_editor_shim_callbacks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
parameter_list|)
function_decl|;
comment|/*** Authentication handler declarations ***/
comment|/**  * Callback function that loads the credentials for Basic and Digest  * authentications, both for server and proxy authentication.  */
name|apr_status_t
name|svn_ra_serf__credentials_callback
parameter_list|(
name|char
modifier|*
modifier|*
name|username
parameter_list|,
name|char
modifier|*
modifier|*
name|password
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|authn_type
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/*** General utility functions ***/
comment|/**  * Convert an HTTP STATUS_CODE resulting from a WebDAV request against  * PATH to the relevant error code.  Use the response-supplied LOCATION  * where it necessary.  *  * Returns SVN_NO_ERROR if sline doesn't specify an error condition  */
name|svn_error_t
modifier|*
name|svn_ra_serf__error_on_status
parameter_list|(
name|serf_status_line
name|sline
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|location
parameter_list|)
function_decl|;
comment|/**  * Convert an unexpected HTTP STATUS_CODE from a request to the relevant error  * code. Unlike svn_ra_serf__error_on_status() this function creates an error  * for any result  */
name|svn_error_t
modifier|*
name|svn_ra_serf__unexpected_status
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|)
function_decl|;
comment|/* ###? */
name|svn_error_t
modifier|*
name|svn_ra_serf__copy_into_spillbuf
parameter_list|(
name|svn_spillbuf_t
modifier|*
modifier|*
name|spillbuf
parameter_list|,
name|serf_bucket_t
modifier|*
name|bkt
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* ###? */
name|serf_bucket_t
modifier|*
name|svn_ra_serf__create_sb_bucket
parameter_list|(
name|svn_spillbuf_t
modifier|*
name|spillbuf
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/** Wrap STATUS from an serf function. If STATUS is not serf error code,   * this is equivalent to svn_error_wrap_apr().  */
name|svn_error_t
modifier|*
name|svn_ra_serf__wrap_err
parameter_list|(
name|apr_status_t
name|status
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/* Create a bucket that just returns DATA (with length LEN) and then returns    the APR_EAGAIN status */
name|serf_bucket_t
modifier|*
name|svn_ra_serf__create_bucket_with_eagain
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* Parse a given URL_STR, fill in all supplied fields of URI  * structure.  *  * This function is a compatibility wrapper around apr_uri_parse().  * Different apr-util versions set apr_uri_t.path to either NULL or ""  * for root paths, and serf expects to see "/". This function always  * sets URI.path to "/" for these paths. */
name|svn_error_t
modifier|*
name|svn_ra_serf__uri_parse
parameter_list|(
name|apr_uri_t
modifier|*
name|uri
parameter_list|,
specifier|const
name|char
modifier|*
name|url_str
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
comment|/* Wrapper macros to collect file and line information */
define|#
directive|define
name|svn_ra_serf__wrap_err
define|\
value|(svn_error__locate(__FILE__,__LINE__), (svn_ra_serf__wrap_err))
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __cplusplus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_LIBSVN_RA_SERF_RA_SERF_H */
end_comment

end_unit

