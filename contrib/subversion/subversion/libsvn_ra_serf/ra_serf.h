begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ra_serf.h : Private declarations for the Serf-based DAV RA module.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_LIBSVN_RA_SERF_RA_SERF_H
end_ifndef

begin_define
define|#
directive|define
name|SVN_LIBSVN_RA_SERF_RA_SERF_H
end_define

begin_escape
end_escape

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_comment
comment|/* for XML_Parser  */
end_comment

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dav_protocol.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_editor.h"
end_include

begin_include
include|#
directive|include
file|"blncache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
comment|/* Enforce the minimum version of serf. */
if|#
directive|if
operator|!
name|SERF_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|2
operator|,
literal|1
argument_list|)
error|#
directive|error
error|Please update your version of serf to at least 1.2.1.
endif|#
directive|endif
comment|/** Use this to silence compiler warnings about unused parameters. */
define|#
directive|define
name|UNUSED_CTX
parameter_list|(
name|x
parameter_list|)
value|((void)(x))
comment|/** Our User-Agent string. */
define|#
directive|define
name|USER_AGENT
value|"SVN/" SVN_VER_NUMBER " (" SVN_BUILD_TARGET ")" \                    " serf/" \                    APR_STRINGIFY(SERF_MAJOR_VERSION) "." \                    APR_STRINGIFY(SERF_MINOR_VERSION) "." \                    APR_STRINGIFY(SERF_PATCH_VERSION)
comment|/** Wait duration (in microseconds) used in calls to serf_context_run() */
define|#
directive|define
name|SVN_RA_SERF__CONTEXT_RUN_DURATION
value|500000
comment|/* Forward declarations. */
typedef|typedef
name|struct
name|svn_ra_serf__session_t
name|svn_ra_serf__session_t
typedef|;
comment|/* A serf connection and optionally associated SSL context.  */
typedef|typedef
struct|struct
name|svn_ra_serf__connection_t
block|{
comment|/* Our connection to a server. */
name|serf_connection_t
modifier|*
name|conn
decl_stmt|;
comment|/* Bucket allocator for this connection. */
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
decl_stmt|;
comment|/* Collected cert failures in chain.  */
name|int
name|server_cert_failures
decl_stmt|;
comment|/* What was the last HTTP status code we got on this connection? */
name|int
name|last_status_code
decl_stmt|;
comment|/* Optional SSL context for this connection. */
name|serf_ssl_context_t
modifier|*
name|ssl_context
decl_stmt|;
name|svn_auth_iterstate_t
modifier|*
name|ssl_client_auth_state
decl_stmt|;
name|svn_auth_iterstate_t
modifier|*
name|ssl_client_pw_auth_state
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
decl_stmt|;
block|}
name|svn_ra_serf__connection_t
typedef|;
comment|/** Maximum value we'll allow for the http-max-connections config option.  *  * Note: minimum 2 connections are required for ra_serf to function  * correctly!  */
define|#
directive|define
name|SVN_RA_SERF__MAX_CONNECTIONS_LIMIT
value|8
comment|/*  * The master serf RA session.  *  * This is stored in the ra session ->priv field.  */
struct|struct
name|svn_ra_serf__session_t
block|{
comment|/* Pool for allocations during this session */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The current context */
name|serf_context_t
modifier|*
name|context
decl_stmt|;
comment|/* The maximum number of connections we'll use for parallelized      fetch operations (updates, etc.) */
name|apr_int64_t
name|max_connections
decl_stmt|;
comment|/* Are we using ssl */
name|svn_boolean_t
name|using_ssl
decl_stmt|;
comment|/* Should we ask for compressed responses? */
name|svn_boolean_t
name|using_compression
decl_stmt|;
comment|/* The user agent string */
specifier|const
name|char
modifier|*
name|useragent
decl_stmt|;
comment|/* The current connection */
name|svn_ra_serf__connection_t
modifier|*
name|conns
index|[
name|SVN_RA_SERF__MAX_CONNECTIONS_LIMIT
index|]
decl_stmt|;
name|int
name|num_conns
decl_stmt|;
name|int
name|cur_conn
decl_stmt|;
comment|/* The URL that was passed into _open() */
name|apr_uri_t
name|session_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|session_url_str
decl_stmt|;
comment|/* The actual discovered root; may be NULL until we know it. */
name|apr_uri_t
name|repos_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_str
decl_stmt|;
comment|/* The server is not Apache/mod_dav_svn (directly) and only supports      HTTP/1.0. Thus, we cannot send chunked requests.  */
name|svn_boolean_t
name|http10
decl_stmt|;
comment|/* Our Version-Controlled-Configuration; may be NULL until we know it. */
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
comment|/* Authentication related properties. */
name|svn_auth_iterstate_t
modifier|*
name|auth_state
decl_stmt|;
name|int
name|auth_attempts
decl_stmt|;
comment|/* Callback functions to get info from WC */
specifier|const
name|svn_ra_callbacks2_t
modifier|*
name|wc_callbacks
decl_stmt|;
name|void
modifier|*
name|wc_callback_baton
decl_stmt|;
comment|/* Callback function to send progress info to the client */
name|svn_ra_progress_notify_func_t
name|progress_func
decl_stmt|;
name|void
modifier|*
name|progress_baton
decl_stmt|;
comment|/* Callback function to handle cancellation */
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
comment|/* Ev2 shim callbacks */
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
decl_stmt|;
comment|/* Error that we've received but not yet returned upstream. */
name|svn_error_t
modifier|*
name|pending_error
decl_stmt|;
comment|/* List of authn types supported by the client.*/
name|int
name|authn_types
decl_stmt|;
comment|/* Maps SVN_RA_CAPABILITY_foo keys to "yes" or "no" values.      If a capability is not yet discovered, it is absent from the table.      The table itself is allocated in the svn_ra_serf__session_t's pool;      keys and values must have at least that lifetime.  Most likely      the keys and values are constants anyway (and sufficiently      well-informed internal code may just compare against those      constants' addresses, therefore). */
name|apr_hash_t
modifier|*
name|capabilities
decl_stmt|;
comment|/* Activity collection URL.  (Cached from the initial OPTIONS      request when run against HTTPv1 servers.)  */
specifier|const
name|char
modifier|*
name|activity_collection_url
decl_stmt|;
comment|/* Are we using a proxy? */
name|int
name|using_proxy
decl_stmt|;
specifier|const
name|char
modifier|*
name|proxy_username
decl_stmt|;
specifier|const
name|char
modifier|*
name|proxy_password
decl_stmt|;
name|int
name|proxy_auth_attempts
decl_stmt|;
comment|/* SSL server certificates */
name|svn_boolean_t
name|trust_default_ca
decl_stmt|;
specifier|const
name|char
modifier|*
name|ssl_authorities
decl_stmt|;
comment|/* Repository UUID */
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
comment|/* Connection timeout value */
name|apr_interval_time_t
name|timeout
decl_stmt|;
comment|/* HTTPv1 flags */
name|svn_tristate_t
name|supports_deadprop_count
decl_stmt|;
comment|/*** HTTP v2 protocol stuff. ***    *    * We assume that if mod_dav_svn sends one of the special v2 OPTIONs    * response headers, it has sent all of them.  Specifically, we'll    * be looking at the presence of the "me resource" as a flag that    * the server supports v2 of our HTTP protocol.    */
comment|/* The "me resource".  Typically used as a target for REPORTs that      are path-agnostic.  If we have this, we can speak HTTP v2 to the      server.  */
specifier|const
name|char
modifier|*
name|me_resource
decl_stmt|;
comment|/* Opaque URL "stubs".  If the OPTIONS response returns these, then      we know we're using HTTP protocol v2. */
specifier|const
name|char
modifier|*
name|rev_stub
decl_stmt|;
comment|/* for accessing revisions (i.e. revprops) */
specifier|const
name|char
modifier|*
name|rev_root_stub
decl_stmt|;
comment|/* for accessing REV/PATH pairs */
specifier|const
name|char
modifier|*
name|txn_stub
decl_stmt|;
comment|/* for accessing transactions (i.e. txnprops) */
specifier|const
name|char
modifier|*
name|txn_root_stub
decl_stmt|;
comment|/* for accessing TXN/PATH pairs */
specifier|const
name|char
modifier|*
name|vtxn_stub
decl_stmt|;
comment|/* for accessing transactions (i.e. txnprops) */
specifier|const
name|char
modifier|*
name|vtxn_root_stub
decl_stmt|;
comment|/* for accessing TXN/PATH pairs */
comment|/* Hash mapping const char * server-supported POST types to      disinteresting-but-non-null values. */
name|apr_hash_t
modifier|*
name|supported_posts
decl_stmt|;
comment|/*** End HTTP v2 stuff ***/
name|svn_ra_serf__blncache_t
modifier|*
name|blncache
decl_stmt|;
comment|/* Trisate flag that indicates user preference for using bulk updates      (svn_tristate_true) with all the properties and content in the      update-report response. If svn_tristate_false, request a skelta      update-report with inlined properties. If svn_tristate_unknown then use      server preference. */
name|svn_tristate_t
name|bulk_updates
decl_stmt|;
comment|/* Indicates if the server wants bulk update requests (Prefer) or only      accepts skelta requests (Off). If this value is On both options are      allowed. */
specifier|const
name|char
modifier|*
name|server_allows_bulk
decl_stmt|;
comment|/* Indicates if the server supports sending inlined props in update editor    * in skelta mode (send-all == 'false'). */
name|svn_boolean_t
name|supports_inline_props
decl_stmt|;
comment|/* Indicates whether the server supports issuing replay REPORTs      against rev resources (children of `rev_stub', elsestruct). */
name|svn_boolean_t
name|supports_rev_rsrc_replay
decl_stmt|;
block|}
struct|;
define|#
directive|define
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
parameter_list|(
name|sess
parameter_list|)
value|((sess)->me_resource != NULL)
comment|/*  * Structure which represents a DAV element with a NAMESPACE and NAME.  */
typedef|typedef
struct|struct
name|svn_ra_serf__dav_props_t
block|{
comment|/* Element namespace */
specifier|const
name|char
modifier|*
name|namespace
decl_stmt|;
comment|/* Element name */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|svn_ra_serf__dav_props_t
typedef|;
comment|/*  * Structure which represents an XML namespace.  */
typedef|typedef
struct|struct
name|ns_t
block|{
comment|/* The assigned name. */
specifier|const
name|char
modifier|*
name|namespace
decl_stmt|;
comment|/* The full URL for this namespace. */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
comment|/* The next namespace in our list. */
name|struct
name|ns_t
modifier|*
name|next
decl_stmt|;
block|}
name|svn_ra_serf__ns_t
typedef|;
comment|/*  * An incredibly simple list.  */
typedef|typedef
struct|struct
name|ra_serf_list_t
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|struct
name|ra_serf_list_t
modifier|*
name|next
decl_stmt|;
block|}
name|svn_ra_serf__list_t
typedef|;
comment|/** DAV property sets **/
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|base_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"version-controlled-configuration"
block|}
block|,
block|{
literal|"DAV:"
block|,
literal|"resourcetype"
block|}
block|,
block|{
name|SVN_DAV_PROP_NS_DAV
block|,
literal|"baseline-relative-path"
block|}
block|,
block|{
name|SVN_DAV_PROP_NS_DAV
block|,
literal|"repository-uuid"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|checked_in_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"checked-in"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|baseline_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"baseline-collection"
block|}
block|,
block|{
literal|"DAV:"
block|,
name|SVN_DAV__VERSION_NAME
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|all_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"allprop"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|check_path_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"resourcetype"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
name|type_and_checksum_props
index|[]
init|=
block|{
block|{
literal|"DAV:"
block|,
literal|"resourcetype"
block|}
block|,
block|{
name|SVN_DAV_PROP_NS_DAV
block|,
literal|"sha1-checksum"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
comment|/* WC props compatibility with ra_neon. */
define|#
directive|define
name|SVN_RA_SERF__WC_CHECKED_IN_URL
value|SVN_PROP_WC_PREFIX "ra_dav:version-url"
comment|/** Serf utility functions **/
name|apr_status_t
name|svn_ra_serf__conn_setup
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|read_bkt
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|write_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
name|void
name|svn_ra_serf__conn_closed
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|void
modifier|*
name|closed_baton
parameter_list|,
name|apr_status_t
name|why
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Helper function to provide SSL client certificates.  *  * NOTE: This function sets the session's 'pending_error' member when  *       returning an non-success status.  */
name|apr_status_t
name|svn_ra_serf__handle_client_cert
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cert_path
parameter_list|)
function_decl|;
comment|/* Helper function to provide SSL client certificate passwords.  *  * NOTE: This function sets the session's 'pending_error' member when  *       returning an non-success status.  */
name|apr_status_t
name|svn_ra_serf__handle_client_cert_pw
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|cert_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|password
parameter_list|)
function_decl|;
comment|/*  * This function will run the serf context in SESS until *DONE is TRUE.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__context_run_wait
parameter_list|(
name|svn_boolean_t
modifier|*
name|done
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback for response handlers */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__response_handler_t
function_decl|)
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback for when a request body is needed. */
comment|/* ### should pass a scratch_pool  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__request_body_delegate_t
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|body_bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|request_pool
parameter_list|)
function_decl|;
comment|/* Callback for when request headers are needed. */
comment|/* ### should pass a scratch_pool  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__request_header_delegate_t
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|request_pool
parameter_list|)
function_decl|;
comment|/* Callback for when a response has an error. */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__response_error_t
function_decl|)
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|int
name|status_code
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
function_decl|;
comment|/* ### we should reorder the types in this file.  */
typedef|typedef
name|struct
name|svn_ra_serf__server_error_t
name|svn_ra_serf__server_error_t
typedef|;
comment|/*  * Structure that can be passed to our default handler to guide the  * execution of the request through its lifecycle.  */
typedef|typedef
struct|struct
name|svn_ra_serf__handler_t
block|{
comment|/* The HTTP method string of the request */
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
comment|/* The resource to the execute the method on. */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The content-type of the request body. */
specifier|const
name|char
modifier|*
name|body_type
decl_stmt|;
comment|/* If TRUE then default Accept-Encoding request header is not configured for      request. If FALSE then 'gzip' accept encoding will be used if compression      enabled. */
name|svn_boolean_t
name|custom_accept_encoding
decl_stmt|;
comment|/* Has the request/response been completed?  */
name|svn_boolean_t
name|done
decl_stmt|;
comment|/* If we captured an error from the server, then this will be non-NULL.      It will be allocated from HANDLER_POOL.  */
name|svn_ra_serf__server_error_t
modifier|*
name|server_error
decl_stmt|;
comment|/* The handler and baton pair for our handler. */
name|svn_ra_serf__response_handler_t
name|response_handler
decl_stmt|;
name|void
modifier|*
name|response_baton
decl_stmt|;
comment|/* When REPONSE_HANDLER is invoked, the following fields will be set      based on the response header. HANDLER_POOL must be non-NULL for these      values to be filled in. SLINE.REASON and LOCATION will be allocated      within HANDLER_POOL.  */
name|serf_status_line
name|sline
decl_stmt|;
comment|/* The parsed Status-Line  */
specifier|const
name|char
modifier|*
name|location
decl_stmt|;
comment|/* The Location: header, if any  */
comment|/* The handler and baton pair to be executed when a non-recoverable error    * is detected.  If it is NULL in the presence of an error, an abort() may    * be triggered.    */
name|svn_ra_serf__response_error_t
name|response_error
decl_stmt|;
name|void
modifier|*
name|response_error_baton
decl_stmt|;
comment|/* This function and baton pair allows for custom request headers to    * be set.    *    * It will be executed after the request has been set up but before it is    * delivered.    */
name|svn_ra_serf__request_header_delegate_t
name|header_delegate
decl_stmt|;
name|void
modifier|*
name|header_delegate_baton
decl_stmt|;
comment|/* This function and baton pair allows a body to be created right before    * delivery.    *    * It will be executed after the request has been set up but before it is    * delivered.    *    * May be NULL if there is no body to send.    *    */
name|svn_ra_serf__request_body_delegate_t
name|body_delegate
decl_stmt|;
name|void
modifier|*
name|body_delegate_baton
decl_stmt|;
comment|/* The connection and session to be used for this request. */
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
decl_stmt|;
comment|/* Internal flag to indicate we've parsed the headers.  */
name|svn_boolean_t
name|reading_body
decl_stmt|;
comment|/* When this flag will be set, the core handler will discard any unread      portion of the response body. The registered response handler will      no longer be called.  */
name|svn_boolean_t
name|discard_body
decl_stmt|;
comment|/* Pool for allocating SLINE.REASON and LOCATION. If this pool is NULL,      then the requestor does not care about SLINE and LOCATION.  */
name|apr_pool_t
modifier|*
name|handler_pool
decl_stmt|;
block|}
name|svn_ra_serf__handler_t
typedef|;
comment|/* Run one request and process the response.     Similar to context_run_wait(), but this creates the request for HANDLER    and then waits for it to complete.     WARNING: context_run_wait() does NOT create a request, whereas this    function DOES. Avoid a double-create.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__context_run_one
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * Helper function to queue a request in the @a handler's connection.  */
name|void
name|svn_ra_serf__request_create
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|)
function_decl|;
comment|/* XML helper callbacks. */
typedef|typedef
struct|struct
name|svn_ra_serf__xml_state_t
block|{
comment|/* A numeric value that represents the current state in parsing.    *    * Value 0 is reserved for use as the default state.    */
name|int
name|current_state
decl_stmt|;
comment|/* Private pointer set by the parsing code. */
name|void
modifier|*
name|private
decl_stmt|;
comment|/* Allocations should be made in this pool to match the lifetime of the    * state.    */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The currently-declared namespace for this state. */
name|svn_ra_serf__ns_t
modifier|*
name|ns_list
decl_stmt|;
comment|/* Our previous states. */
name|struct
name|svn_ra_serf__xml_state_t
modifier|*
name|prev
decl_stmt|;
block|}
name|svn_ra_serf__xml_state_t
typedef|;
comment|/* Forward declaration of the XML parser structure. */
typedef|typedef
name|struct
name|svn_ra_serf__xml_parser_t
name|svn_ra_serf__xml_parser_t
typedef|;
comment|/* Callback invoked with @a baton by our XML @a parser when an element with  * the @a name containing @a attrs is opened.  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__xml_start_element_t
function_decl|)
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback invoked with @a baton by our XML @a parser when an element with  * the @a name is closed.  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__xml_end_element_t
function_decl|)
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Callback invoked with @a baton by our XML @a parser when a CDATA portion  * of @a data with size @a len is encountered.  *  * This may be invoked multiple times for the same tag.  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__xml_cdata_chunk_handler_t
function_decl|)
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * Helper structure associated with handle_xml_parser handler that will  * specify how an XML response will be processed.  */
struct|struct
name|svn_ra_serf__xml_parser_t
block|{
comment|/* Temporary allocations should be made in this pool. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* What kind of response are we parsing? If set, this should typically      define the report name.  */
specifier|const
name|char
modifier|*
name|response_type
decl_stmt|;
comment|/* Caller-specific data passed to the start, end, cdata callbacks.  */
name|void
modifier|*
name|user_data
decl_stmt|;
comment|/* Callback invoked when a tag is opened. */
name|svn_ra_serf__xml_start_element_t
name|start
decl_stmt|;
comment|/* Callback invoked when a tag is closed. */
name|svn_ra_serf__xml_end_element_t
name|end
decl_stmt|;
comment|/* Callback invoked when a cdata chunk is received. */
name|svn_ra_serf__xml_cdata_chunk_handler_t
name|cdata
decl_stmt|;
comment|/* Our associated expat-based XML parser. */
name|XML_Parser
name|xmlp
decl_stmt|;
comment|/* Our current state. */
name|svn_ra_serf__xml_state_t
modifier|*
name|state
decl_stmt|;
comment|/* Our previously used states (will be reused). */
name|svn_ra_serf__xml_state_t
modifier|*
name|free_state
decl_stmt|;
comment|/* If non-NULL, this value will be set to TRUE when the response is    * completed.    */
name|svn_boolean_t
modifier|*
name|done
decl_stmt|;
comment|/* If non-NULL, when this parser completes, it will add done_item to    * the list.    */
name|svn_ra_serf__list_t
modifier|*
modifier|*
name|done_list
decl_stmt|;
comment|/* A pointer to the item that will be inserted into the list upon    * completeion.    */
name|svn_ra_serf__list_t
modifier|*
name|done_item
decl_stmt|;
comment|/* If this flag is TRUE, errors during parsing will be ignored.    *    * This is mainly used when we are processing an error XML response to    * avoid infinite loops.    */
name|svn_boolean_t
name|ignore_errors
decl_stmt|;
comment|/* If an error occurred, this value will be non-NULL. */
name|svn_error_t
modifier|*
name|error
decl_stmt|;
comment|/* Deciding whether to pause, or not, is performed within the parsing      callbacks. If a callback decides to set this flag, then the loop      driving the parse (generally, a series of calls to serf_context_run())      is going to need to coordinate the un-pausing of the parser by      processing pending content. Thus, deciding to pause the parser is a      coordinate effort rather than merely setting this flag.       When an XML parsing callback sets this flag, note that additional      elements may be parsed (as the current buffer is consumed). At some      point, the flag will be recognized and arriving network content will      be stashed away in the PENDING structure (see below).       At some point, the controlling loop should clear this value. The      underlying network processing will note the change and begin passing      content into the XML callbacks.       Note that the controlling loop should also process pending content      since the arriving network content will typically finish first.  */
name|svn_boolean_t
name|paused
decl_stmt|;
comment|/* While the XML parser is paused, content arriving from the server      must be saved locally. We cannot stop reading, or the server may      decide to drop the connection. The content will be stored in memory      up to a certain limit, and will then be spilled over to disk.       See libsvn_ra_serf/util.c  */
name|struct
name|svn_ra_serf__pending_t
modifier|*
name|pending
decl_stmt|;
comment|/* Response restart support */
specifier|const
name|void
modifier|*
name|headers_baton
decl_stmt|;
comment|/* Last pointer to headers */
name|apr_off_t
name|skip_size
decl_stmt|;
comment|/* Number of bytes to skip */
name|apr_off_t
name|read_size
decl_stmt|;
comment|/* Number of bytes read from response */
block|}
struct|;
comment|/* v2 of the XML parsing functions  */
comment|/* The XML parsing context.  */
typedef|typedef
name|struct
name|svn_ra_serf__xml_context_t
name|svn_ra_serf__xml_context_t
typedef|;
comment|/* An opaque structure for the XML parse element/state.  */
typedef|typedef
name|struct
name|svn_ra_serf__xml_estate_t
name|svn_ra_serf__xml_estate_t
typedef|;
comment|/* Called just after the parser moves into ENTERED_STATE. The tag causing    the transition is passed in TAG.     This callback is applied to a parsing context by using the    svn_ra_serf__xml_context_customize() function.     NOTE: this callback, when set, will be invoked on *every* transition.    The callback must examine ENTERED_STATE to determine if any action    must be taken. The original state is not provided, but must be derived    from ENTERED_STATE and/or the TAG causing the transition (if needed).  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__xml_opened_t
function_decl|)
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|entered_state
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|tag
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Called just before the parser leaves LEAVING_STATE.     If cdata collection was enabled for this state, then CDATA will be    non-NULL and contain the collected cdata.     If attribute collection was enabled for this state, then ATTRS will    contain the attributes collected for this element only, along with    any values stored via svn_ra_serf__xml_note().     Use svn_ra_serf__xml_gather_since() to gather up data from outer states.     ATTRS is char* -> char*.     Temporary allocations may be made in SCRATCH_POOL.  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__xml_closed_t
function_decl|)
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|leaving_state
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|cdata
parameter_list|,
name|apr_hash_t
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Called for all states that are not using the builtin cdata collection.    This callback is (only) appropriate for unbounded-size cdata content.     CURRENT_STATE may be used to decide what to do with the data.     Temporary allocations may be made in SCRATCH_POOL.  */
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__xml_cdata_t
function_decl|)
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|current_state
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* State transition table.     When the XML Context is constructed, it is in state 0. User states are    positive integers.     In a list of transitions, use { 0 } to indicate the end. Specifically,    the code looks for NS == NULL.     ### more docco */
typedef|typedef
struct|struct
name|svn_ra_serf__xml_transition_t
block|{
comment|/* This transition applies when in this state  */
name|int
name|from_state
decl_stmt|;
comment|/* And when this tag is observed  */
specifier|const
name|char
modifier|*
name|ns
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Moving to this state  */
name|int
name|to_state
decl_stmt|;
comment|/* Should the cdata of NAME be collected? Note that CUSTOM_CLOSE should      be TRUE in order to capture this cdata.  */
name|svn_boolean_t
name|collect_cdata
decl_stmt|;
comment|/* Which attributes of NAME should be collected? Terminate with NULL.      Maximum of 10 attributes may be collected. Note that attribute      namespaces are ignored at this time.       Attribute names beginning with "?" are optional. Other names must      exist on the element, or SVN_ERR_XML_ATTRIB_NOT_FOUND will be raised.  */
specifier|const
name|char
modifier|*
name|collect_attrs
index|[
literal|11
index|]
decl_stmt|;
comment|/* When NAME is closed, should the callback be invoked?  */
name|svn_boolean_t
name|custom_close
decl_stmt|;
block|}
name|svn_ra_serf__xml_transition_t
typedef|;
comment|/* Construct an XML parsing context, based on the TTABLE transition table.    As content is parsed, the CLOSED_CB callback will be invoked according    to the definition in the table.     If OPENED_CB is not NULL, then it will be invoked for *every* tag-open    event. The callback will need to use the ENTERED_STATE and TAG parameters    to decide what it would like to do.     If CDATA_CB is not NULL, then it will be called for all cdata that is    not be automatically collected (based on the transition table record's    COLLECT_CDATA flag). It will be called in every state, so the callback    must examine the CURRENT_STATE parameter to decide what to do.     The same BATON value will be passed to all three callbacks.     The context will be created within RESULT_POOL.  */
name|svn_ra_serf__xml_context_t
modifier|*
name|svn_ra_serf__xml_context_create
parameter_list|(
specifier|const
name|svn_ra_serf__xml_transition_t
modifier|*
name|ttable
parameter_list|,
name|svn_ra_serf__xml_opened_t
name|opened_cb
parameter_list|,
name|svn_ra_serf__xml_closed_t
name|closed_cb
parameter_list|,
name|svn_ra_serf__xml_cdata_t
name|cdata_cb
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/* Destroy all subpools for this structure. */
name|void
name|svn_ra_serf__xml_context_destroy
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|)
function_decl|;
comment|/* Construct a handler with the response function/baton set up to parse    a response body using the given XML context. The handler and its    internal structures are allocated in RESULT_POOL.     This also initializes HANDLER_POOL to the given RESULT_POOL.  */
name|svn_ra_serf__handler_t
modifier|*
name|svn_ra_serf__create_expat_handler
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/* Allocated within XES->STATE_POOL. Changes are not allowd (callers    should make a deep copy if they need to make changes).     The resulting hash maps char* names to char* values.  */
name|apr_hash_t
modifier|*
name|svn_ra_serf__xml_gather_since
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|int
name|stop_state
parameter_list|)
function_decl|;
comment|/* Attach the NAME/VALUE pair onto this/parent state identified by STATE.    The name and value will be copied into the target state's pool.     These values will be available to the CLOSED_CB for the target state,    or part of the gathered state via xml_gather_since().     Typically, this function is used by a child state's close callback,    or within an opening callback to store additional data.     Note: if the state is not found, then a programmer error has occurred,    so the function will invoke SVN_ERR_MALFUNCTION().  */
name|void
name|svn_ra_serf__xml_note
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|int
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
comment|/* Returns XES->STATE_POOL for allocating structures that should live    as long as the state identified by XES.     Note: a state pool is created upon demand, so only use this function    when memory is required for a given state.  */
name|apr_pool_t
modifier|*
name|svn_ra_serf__xml_state_pool
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|)
function_decl|;
comment|/* Any XML parser may be used. When an opening tag is seen, call this    function to feed the information into XMLCTX.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__xml_cb_start
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|attrs
parameter_list|)
function_decl|;
comment|/* When a close tag is seen, call this function to feed the information    into XMLCTX.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__xml_cb_end
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_name
parameter_list|)
function_decl|;
comment|/* When cdata is parsed by the wrapping XML parser, call this function to    feed the cdata into the XMLCTX.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__xml_cb_cdata
parameter_list|(
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
function_decl|;
comment|/*  * Parses a server-side error message into a local Subversion error.  */
struct|struct
name|svn_ra_serf__server_error_t
block|{
comment|/* Our local representation of the error. */
name|svn_error_t
modifier|*
name|error
decl_stmt|;
comment|/* Are we done with the response? */
name|svn_boolean_t
name|done
decl_stmt|;
comment|/* Have we seen an error tag? */
name|svn_boolean_t
name|in_error
decl_stmt|;
comment|/* Have we seen a HTTP "412 Precondition Failed" error? */
name|svn_boolean_t
name|contains_precondition_error
decl_stmt|;
comment|/* Should we be collecting the XML cdata? */
name|svn_boolean_t
name|collect_cdata
decl_stmt|;
comment|/* Collected cdata. NULL if cdata not needed. */
name|svn_stringbuf_t
modifier|*
name|cdata
decl_stmt|;
comment|/* XML parser and namespace used to parse the remote response */
name|svn_ra_serf__xml_parser_t
name|parser
decl_stmt|;
block|}
struct|;
comment|/*  * Handler that discards the entire @a response body associated with a  * @a request.  Implements svn_ra_serf__response_handler_t.  *  * If @a baton is a svn_ra_serf__server_error_t (i.e. non-NULL) and an  * error is detected, it will be populated for later detection.  *  * All temporary allocations will be made in a @a pool.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_discard_body
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/*  * Handler that retrieves the embedded XML multistatus response from the  * the @a RESPONSE body associated with a @a REQUEST.  *  * Implements svn_ra_serf__response_handler_t.  *  * The @a BATON should be of type svn_ra_serf__handler_t. When the request  * is complete, the handler's DONE flag will be set to TRUE.  *  * All temporary allocations will be made in a @a scratch_pool.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_multistatus_only
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Handler that expects an empty body.     If a body IS present, and it is text/xml, then it will be parsed for    a server-side error.     BATON should be the svn_ra_serf__handler_t running REQUEST.     Status line information will be in HANDLER->SLINE.     Any parsed errors will be left in HANDLER->SERVER_ERROR. That member    may be NULL if no body was present, or a problem occurred trying to    parse the body.     All temporary allocations will be made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__expect_empty_body
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * This function will feed the RESPONSE body into XMLP.  When parsing is  * completed (i.e. an EOF is received), *DONE is set to TRUE.  * Implements svn_ra_serf__response_handler_t.  *  * If an error occurs during processing RESP_ERR is invoked with the  * RESP_ERR_BATON.  *  * Temporary allocations are made in POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__handle_xml_parser
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* serf_response_handler_t implementation that completely discards  * the response.  *  * All temporary allocations will be made in @a pool.  */
name|apr_status_t
name|svn_ra_serf__response_discard_handler
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/** XML helper functions. **/
comment|/*  * Advance the internal XML @a parser to the @a state.  */
name|void
name|svn_ra_serf__xml_push_state
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
comment|/*  * Return to the previous internal XML @a parser state.  */
name|void
name|svn_ra_serf__xml_pop_state
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
name|svn_error_t
modifier|*
name|svn_ra_serf__process_pending
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_boolean_t
modifier|*
name|network_eof
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/*  * Add the appropriate serf buckets to @a agg_bucket represented by  * the XML * @a tag and @a value.  *  * The bucket will be allocated from @a bkt_alloc.  */
name|void
name|svn_ra_serf__add_tag_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|)
function_decl|;
comment|/*  * Add the appropriate serf buckets to AGG_BUCKET with standard XML header:  *<?xml version="1.0" encoding="utf-8"?>  *  * The bucket will be allocated from BKT_ALLOC.  */
name|void
name|svn_ra_serf__add_xml_header_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|)
function_decl|;
comment|/*  * Add the appropriate serf buckets to AGG_BUCKET representing the XML  * open tag with name TAG.  *  * Take the tag's attributes from varargs, a NULL-terminated list of  * alternating<tt>char *</tt> key and<tt>char *</tt> val.  Attribute  * will be ignored if it's value is NULL.  *  * NOTE: Callers are responsible for XML-escaping attribute values as  * necessary.  *  * The bucket will be allocated from BKT_ALLOC.  */
name|void
name|svn_ra_serf__add_open_tag_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/*  * Add the appropriate serf buckets to AGG_BUCKET representing xml tag close  * with name TAG.  *  * The bucket will be allocated from BKT_ALLOC.  */
name|void
name|svn_ra_serf__add_close_tag_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
function_decl|;
comment|/*  * Add the appropriate serf buckets to AGG_BUCKET with xml-escaped  * version of DATA.  *  * The bucket will be allocated from BKT_ALLOC.  */
name|void
name|svn_ra_serf__add_cdata_len_buckets
parameter_list|(
name|serf_bucket_t
modifier|*
name|agg_bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|bkt_alloc
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
function_decl|;
comment|/*  * Look up the @a attrs array for namespace definitions and add each one  * to the @a ns_list of namespaces.  *  * New namespaces will be allocated in RESULT_POOL.  */
name|void
name|svn_ra_serf__define_ns
parameter_list|(
name|svn_ra_serf__ns_t
modifier|*
modifier|*
name|ns_list
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/*  * Look up @a name in the @a ns_list list for previously declared namespace  * definitions.  *  * Return (in @a *returned_prop_name) a #svn_ra_serf__dav_props_t tuple  * representing the expanded name.  */
name|void
name|svn_ra_serf__expand_ns
parameter_list|(
name|svn_ra_serf__dav_props_t
modifier|*
name|returned_prop_name
parameter_list|,
specifier|const
name|svn_ra_serf__ns_t
modifier|*
name|ns_list
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/** PROPFIND-related functions **/
comment|/*  * This function will deliver a PROP_CTX PROPFIND request in the SESS  * serf context for the properties listed in LOOKUP_PROPS at URL for  * DEPTH ("0","1","infinity").  *  * This function will not block waiting for the response. Callers are  * expected to call svn_ra_serf__wait_for_props().  */
name|svn_error_t
modifier|*
name|svn_ra_serf__deliver_props
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
modifier|*
name|propfind_handler
parameter_list|,
name|apr_hash_t
modifier|*
name|prop_vals
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|depth
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|lookup_props
parameter_list|,
name|svn_ra_serf__list_t
modifier|*
modifier|*
name|done_list
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/*  * This helper function will block until PROPFIND_HANDLER indicates that is  * done or another error is returned.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__wait_for_props
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* This is a blocking version of deliver_props.     The properties are fetched and placed into RESULTS, allocated in    RESULT_POOL.     ### more docco about the other params.     Temporary allocations are made in SCRATCH_POOL. */
name|svn_error_t
modifier|*
name|svn_ra_serf__retrieve_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|results
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|depth
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Using CONN, fetch the properties specified by WHICH_PROPS using CONN    for URL at REVISION. The resulting properties are placed into a 2-level    hash in RESULTS, mapping NAMESPACE -> hash<PROPNAME, PROPVALUE>, which    is allocated in RESULT_POOL.     If REVISION is SVN_INVALID_REVNUM, then the properties are fetched    from HEAD for URL.     This function performs the request synchronously.     Temporary allocations are made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__fetch_node_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|results
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|which_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Using CONN, fetch a DAV: property from the resource identified by URL    within REVISION. The PROPNAME may be one of:       "checked-in"      "href"     The resulting value will be allocated in RESULT_POOL, and may be NULL    if the property does not exist (note: "href" always exists).     This function performs the request synchronously.     Temporary allocations are made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__fetch_dav_prop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Set PROPS for PATH at REV revision with a NS:NAME VAL.  *  * The POOL governs allocation.  */
name|void
name|svn_ra_serf__set_ver_prop
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
define|#
directive|define
name|svn_ra_serf__set_rev_prop
value|svn_ra_serf__set_ver_prop
comment|/** Property walker functions **/
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__walker_visitor_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
name|svn_error_t
modifier|*
name|svn_ra_serf__walk_all_props
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_ra_serf__walker_visitor_t
name|walker
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Like walk_all_props(), but a 2-level hash.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__walk_node_props
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_ra_serf__walker_visitor_t
name|walker
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_ra_serf__path_rev_walker_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_ssize_t
name|path_len
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
name|apr_ssize_t
name|ns_len
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_ssize_t
name|name_len
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
name|svn_error_t
modifier|*
name|svn_ra_serf__walk_all_paths
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_ra_serf__path_rev_walker_t
name|walker
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Map a property name, as passed over the wire, into its corresponding    Subversion-internal name. The returned name will be a static value,    or allocated within RESULT_POOL.     If the property should be ignored (eg. some DAV properties), then NULL    will be returned.  */
specifier|const
name|char
modifier|*
name|svn_ra_serf__svnname_from_wirename
parameter_list|(
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/* Select the basic revision properties from the set of "all" properties.    Return these in *REVPROPS, allocated from RESULT_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__select_revprops
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|revprops
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|all_revprops
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* PROPS is nested hash tables mapping NS -> NAME -> VALUE.    This function takes the NS:NAME:VALUE hashes and flattens them into a set of    names to VALUE. The names are composed of NS:NAME, with specific    rewrite from wire names (DAV) to SVN names. This mapping is managed    by the svn_ra_serf__set_baton_props() function.     FLAT_PROPS is allocated in RESULT_POOL.    ### right now, we do a shallow copy from PROPS to FLAT_PROPS. therefore,    ### the names and values in PROPS must be in the proper pool.     Temporary allocations are made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__flatten_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|flat_props
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Return the property value for PATH at REV revision with a NS:NAME.  * PROPS is a four-level nested hash: (svn_revnum_t => char *path =>  * char *ns => char *name => svn_string_t *). */
specifier|const
name|svn_string_t
modifier|*
name|svn_ra_serf__get_ver_prop_string
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* Same as svn_ra_serf__get_ver_prop_string(), but returns a C string. */
specifier|const
name|char
modifier|*
name|svn_ra_serf__get_ver_prop
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* Same as svn_ra_serf__get_ver_prop_string(), but for the unknown revision. */
specifier|const
name|svn_string_t
modifier|*
name|svn_ra_serf__get_prop_string
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* Same as svn_ra_serf__get_ver_prop(), but for the unknown revision. */
specifier|const
name|char
modifier|*
name|svn_ra_serf__get_prop
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* Same as svn_ra_serf__set_rev_prop(), but for the unknown revision. */
name|void
name|svn_ra_serf__set_prop
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
name|svn_error_t
modifier|*
name|svn_ra_serf__get_resource_type
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|)
function_decl|;
comment|/** MERGE-related functions **/
name|void
name|svn_ra_serf__merge_lock_token_list
parameter_list|(
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
specifier|const
name|char
modifier|*
name|parent
parameter_list|,
name|serf_bucket_t
modifier|*
name|body
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Create an MERGE request aimed at the SESSION url, requesting the    merge of the resource identified by MERGE_RESOURCE_URL.    LOCK_TOKENS is a hash mapping paths to lock tokens owned by the    client.  If KEEP_LOCKS is set, instruct the server to not release    locks set on the paths included in this commit.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__run_merge
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
modifier|*
name|commit_info
parameter_list|,
name|int
modifier|*
name|response_code
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|merge_resource_url
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/** OPTIONS-related functions **/
comment|/* On HTTPv2 connections, run an OPTIONS request over CONN to fetch the    current youngest revnum, returning it in *YOUNGEST.     (the revnum is headers of the OPTIONS response)     This function performs the request synchronously.     All temporary allocations will be made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__v2_get_youngest_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* On HTTPv1 connections, run an OPTIONS request over CONN to fetch the    activity collection set and return it in *ACTIVITY_URL, allocated    from RESULT_POOL.     (the activity-collection-set is in the body of the OPTIONS response)     This function performs the request synchronously.     All temporary allocations will be made in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__v1_get_activity_collection
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|activity_url
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Set @a VCC_URL to the default VCC for our repository based on @a  * ORIG_PATH for the session @a SESSION, ensuring that the VCC URL and  * repository root URLs are cached in @a SESSION.  Use @a CONN for any  * required network communications if it is non-NULL; otherwise use the  * default connection.  *  * All temporary allocations will be made in @a POOL. */
name|svn_error_t
modifier|*
name|svn_ra_serf__discover_vcc
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|vcc_url
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set @a REPORT_TARGET to the URI of the resource at which generic  * (path-agnostic) REPORTs should be aimed for @a SESSION.  Use @a  * CONN for any required network communications if it is non-NULL;  * otherwise use the default connection.  *  * All temporary allocations will be made in @a POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__report_resource
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|report_target
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Set @a REL_PATH to a path (not URI-encoded) relative to the root of  * the repository pointed to by @a SESSION, based on original path  * (URI-encoded) @a ORIG_PATH.  Use @a CONN for any required network  * communications if it is non-NULL; otherwise use the default  * connection.  Use POOL for allocations.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_relative_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|rel_path
parameter_list|,
specifier|const
name|char
modifier|*
name|orig_path
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Using the default connection in SESSION (conns[0]), get the youngest    revnum from the server, returning it in *YOUNGEST.     This function operates synchronously.     All temporary allocations are performed in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_youngest_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Generate a revision-stable URL.     The RA APIs all refer to user/public URLs that float along with the    youngest revision. In many cases, we do NOT want to work with that URL    since it can change from one moment to the next. Especially if we    attempt to operation against multiple floating URLs -- we could end up    referring to two separate revisions.     The DAV RA provider(s) solve this by generating a URL that is specific    to a revision by using a URL into a "baseline collection".     For a specified SESSION, with an optional CONN (if NULL, then the    session's default connection will be used; specifically SESSION->conns[0]),    generate a revision-stable URL for URL at REVISION. If REVISION is    SVN_INVALID_REVNUM, then the stable URL will refer to the youngest    revision at the time this function was called.     If URL is NULL, then the session root will be used.     The stable URL will be placed into *STABLE_URL, allocated from RESULT_POOL.     If LATEST_REVNUM is not NULL, then the revision used will be placed into    *LATEST_REVNUM. That will be equal to youngest, or the given REVISION.     This function operates synchronously, if any communication to the server    is required. Communication is needed if REVISION is SVN_INVALID_REVNUM    (to get the current youngest revnum), or if the specified REVISION is not    (yet) in our cache of baseline collections.     All temporary allocations are performed in SCRATCH_POOL.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_stable_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|stable_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|latest_revnum
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/** RA functions **/
comment|/* Implements svn_ra__vtable_t.get_log(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_log
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_locations(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_locations
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locations
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|location_revisions
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_location_segments(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_location_segments
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_location_segment_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.do_diff(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__do_diff
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|diff_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
specifier|const
name|char
modifier|*
name|versus_url
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|diff_editor
parameter_list|,
name|void
modifier|*
name|diff_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.do_status(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__do_status
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|status_target
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|status_editor
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.do_update(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__do_update
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision_to_update_to
parameter_list|,
specifier|const
name|char
modifier|*
name|update_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.do_switch(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__do_switch
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision_to_switch_to
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|switch_editor
parameter_list|,
name|void
modifier|*
name|switch_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_file_revs(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_file_revs
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
name|svn_file_rev_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_dated_revision(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_dated_revision
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|apr_time_t
name|tm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_commit_editor(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_commit_editor
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|callback
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_file(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_file
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.change_rev_prop(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__change_rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.replay(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__replay
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.replay_range(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__replay_range
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
name|svn_ra_replay_revstart_callback_t
name|revstart_func
parameter_list|,
name|svn_ra_replay_revfinish_callback_t
name|revfinish_func
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.lock(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_revs
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.unlock(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__unlock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_tokens
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_lock(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_lock_t
modifier|*
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_locks(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_locks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locks
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Request a mergeinfo-report from the URL attached to SESSION,    and fill in the MERGEINFO hash with the results.     Implements svn_ra__vtable_t.get_mergeinfo().  */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_mergeinfo
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|mergeinfo
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Exchange capabilities with the server, by sending an OPTIONS  * request announcing the client's capabilities, and by filling  * SERF_SESS->capabilities with the server's capabilities as read from  * the response headers.  Use POOL only for temporary allocation.  *  * If the CORRECTED_URL is non-NULL, allow the OPTIONS response to  * report a server-dictated redirect or relocation (HTTP 301 or 302  * error codes), setting *CORRECTED_URL to the value of the corrected  * repository URL.  Otherwise, such responses from the server will  * generate an error.  (In either case, no capabilities are exchanged  * if there is, in fact, such a response from the server.)  */
name|svn_error_t
modifier|*
name|svn_ra_serf__exchange_capabilities
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|serf_sess
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|corrected_url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.has_capability(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__has_capability
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_boolean_t
modifier|*
name|has
parameter_list|,
specifier|const
name|char
modifier|*
name|capability
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_deleted_rev(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_deleted_rev
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision_deleted
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements the get_inherited_props RA layer function. */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_inherited_props
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|iprops
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.get_repos_root(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__get_repos_root
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Implements svn_ra__vtable_t.register_editor_shim_callbacks(). */
name|svn_error_t
modifier|*
name|svn_ra_serf__register_editor_shim_callbacks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
parameter_list|)
function_decl|;
comment|/*** Authentication handler declarations ***/
comment|/**  * Callback function that loads the credentials for Basic and Digest  * authentications, both for server and proxy authentication.  */
name|apr_status_t
name|svn_ra_serf__credentials_callback
parameter_list|(
name|char
modifier|*
modifier|*
name|username
parameter_list|,
name|char
modifier|*
modifier|*
name|password
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|authn_type
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/*** General utility functions ***/
comment|/**  * Convert an HTTP STATUS_CODE resulting from a WebDAV request against  * PATH to the relevant error code.  Use the response-supplied LOCATION  * where it necessary.  */
name|svn_error_t
modifier|*
name|svn_ra_serf__error_on_status
parameter_list|(
name|int
name|status_code
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|location
parameter_list|)
function_decl|;
comment|/* ###? */
name|svn_error_t
modifier|*
name|svn_ra_serf__copy_into_spillbuf
parameter_list|(
name|svn_spillbuf_t
modifier|*
modifier|*
name|spillbuf
parameter_list|,
name|serf_bucket_t
modifier|*
name|bkt
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* ###? */
name|serf_bucket_t
modifier|*
name|svn_ra_serf__create_sb_bucket
parameter_list|(
name|svn_spillbuf_t
modifier|*
name|spillbuf
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/** Wrap STATUS from an serf function. If STATUS is not serf error code,   * this is equivalent to svn_error_wrap_apr().  */
name|svn_error_t
modifier|*
name|svn_ra_serf__wrap_err
parameter_list|(
name|apr_status_t
name|status
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
comment|/* Wrapper macros to collect file and line information */
define|#
directive|define
name|svn_ra_serf__wrap_err
define|\
value|(svn_error__locate(__FILE__,__LINE__), (svn_ra_serf__wrap_err))
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __cplusplus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_LIBSVN_RA_SERF_RA_SERF_H */
end_comment

end_unit

