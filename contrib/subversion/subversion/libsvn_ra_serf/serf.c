begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * serf.c :  entry point for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dav_protocol.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Implements svn_ra__vtable_t.get_version(). */
end_comment

begin_function
specifier|static
specifier|const
name|svn_version_t
modifier|*
name|ra_serf_version
parameter_list|(
name|void
parameter_list|)
block|{
name|SVN_VERSION_BODY
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RA_SERF_DESCRIPTION
define|\
value|N_("Module for accessing a repository via WebDAV protocol using serf.")
end_define

begin_define
define|#
directive|define
name|RA_SERF_DESCRIPTION_VER
define|\
value|N_("Module for accessing a repository via WebDAV protocol using serf.\n" \        "  - using serf %d.%d.%d (compiled with %d.%d.%d)")
end_define

begin_comment
comment|/* Implements svn_ra__vtable_t.get_description(). */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ra_serf_get_description
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|patch
decl_stmt|;
name|serf_lib_version
argument_list|(
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|,
operator|&
name|patch
argument_list|)
expr_stmt|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
name|RA_SERF_DESCRIPTION_VER
argument_list|)
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|patch
argument_list|,
name|SERF_MAJOR_VERSION
argument_list|,
name|SERF_MINOR_VERSION
argument_list|,
name|SERF_PATCH_VERSION
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.get_schemes(). */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|ra_serf_get_schemes
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|serf_ssl
index|[]
init|=
block|{
literal|"http"
block|,
literal|"https"
block|,
name|NULL
block|}
decl_stmt|;
if|#
directive|if
literal|0
comment|/* ### Temporary: to shut up a warning. */
block|static const char *serf_no_ssl[] = { "http", NULL };
endif|#
directive|endif
comment|/* TODO: Runtime detection. */
return|return
name|serf_ssl
return|;
block|}
end_function

begin_comment
comment|/* Load the setting http-auth-types from the global or server specific    section, parse its value and set the types of authentication we should    accept from the server. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|load_http_auth_types
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_config_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|server_group
parameter_list|,
name|int
modifier|*
name|authn_types
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|http_auth_types
init|=
name|NULL
decl_stmt|;
operator|*
name|authn_types
operator|=
name|SERF_AUTHN_NONE
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|http_auth_types
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_AUTH_TYPES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_group
condition|)
block|{
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|http_auth_types
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_AUTH_TYPES
argument_list|,
name|http_auth_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|http_auth_types
condition|)
block|{
name|char
modifier|*
name|token
decl_stmt|;
name|char
modifier|*
name|auth_types_list
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|strlen
argument_list|(
name|http_auth_types
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|apr_collapse_spaces
argument_list|(
name|auth_types_list
argument_list|,
name|http_auth_types
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|";"
argument_list|,
operator|&
name|auth_types_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
literal|"basic"
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|authn_types
operator||=
name|SERF_AUTHN_BASIC
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
literal|"digest"
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|authn_types
operator||=
name|SERF_AUTHN_DIGEST
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
literal|"ntlm"
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|authn_types
operator||=
name|SERF_AUTHN_NTLM
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
literal|"negotiate"
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|authn_types
operator||=
name|SERF_AUTHN_NEGOTIATE
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid config: unknown %s "
literal|"'%s'"
argument_list|)
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_AUTH_TYPES
argument_list|,
name|token
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* Nothing specified by the user, so accept all types. */
operator|*
name|authn_types
operator|=
name|SERF_AUTHN_ALL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Default HTTP timeout (in seconds); overridden by the 'http-timeout'    runtime configuration variable. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_HTTP_TIMEOUT
value|600
end_define

begin_function
specifier|static
name|svn_error_t
modifier|*
name|load_config
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|config_hash
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|config_client
decl_stmt|;
specifier|const
name|char
modifier|*
name|server_group
decl_stmt|;
specifier|const
name|char
modifier|*
name|proxy_host
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|port_str
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|timeout_str
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|exceptions
decl_stmt|;
name|apr_port_t
name|proxy_port
decl_stmt|;
name|svn_tristate_t
name|chunked_requests
decl_stmt|;
if|#
directive|if
name|SERF_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|4
operator|,
literal|0
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SVN_SERF_NO_LOGGING
argument_list|)
name|apr_int64_t
name|log_components
decl_stmt|;
name|apr_int64_t
name|log_level
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|config_hash
condition|)
block|{
name|config
operator|=
name|svn_hash_gets
argument_list|(
name|config_hash
argument_list|,
name|SVN_CONFIG_CATEGORY_SERVERS
argument_list|)
expr_stmt|;
name|config_client
operator|=
name|svn_hash_gets
argument_list|(
name|config_hash
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|config
operator|=
name|NULL
expr_stmt|;
name|config_client
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|using_compression
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_COMPRESSION
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|timeout_str
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_TIMEOUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|auth_baton
condition|)
block|{
if|if
condition|(
name|config_client
condition|)
block|{
name|svn_auth_set_parameter
argument_list|(
name|session
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_CONFIG_CATEGORY_CONFIG
argument_list|,
name|config_client
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config
condition|)
block|{
name|svn_auth_set_parameter
argument_list|(
name|session
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_CONFIG_CATEGORY_SERVERS
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Use the default proxy-specific settings if and only if      "http-proxy-exceptions" is not set to exclude this host. */
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|exceptions
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_EXCEPTIONS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_cstring_match_glob_list
argument_list|(
name|session
operator|->
name|session_url
operator|.
name|hostname
argument_list|,
name|svn_cstring_split
argument_list|(
name|exceptions
argument_list|,
literal|","
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
condition|)
block|{
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|proxy_host
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_HOST
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|port_str
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_PORT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|proxy_username
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_USERNAME
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|proxy_password
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_PASSWORD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Load the global ssl settings, if set. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|trust_default_ca
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_SSL_TRUST_DEFAULT_CA
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|ssl_authorities
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_SSL_AUTHORITY_FILES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If set, read the flag that tells us to do bulk updates or not. Defaults      to skelta updates. */
name|SVN_ERR
argument_list|(
name|svn_config_get_tristate
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|bulk_updates
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_BULK_UPDATES
argument_list|,
literal|"auto"
argument_list|,
name|svn_tristate_unknown
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load the maximum number of parallel session connections. */
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|max_connections
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS
argument_list|,
name|SVN_CONFIG_DEFAULT_OPTION_HTTP_MAX_CONNECTIONS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Should we use chunked transfer encoding. */
name|SVN_ERR
argument_list|(
name|svn_config_get_tristate
argument_list|(
name|config
argument_list|,
operator|&
name|chunked_requests
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_CHUNKED_REQUESTS
argument_list|,
literal|"auto"
argument_list|,
name|svn_tristate_unknown
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SERF_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|4
operator|,
literal|0
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SVN_SERF_NO_LOGGING
argument_list|)
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|log_components
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_SERF_LOG_COMPONENTS
argument_list|,
name|SERF_LOGCOMP_NONE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|log_level
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_SERF_LOG_LEVEL
argument_list|,
name|SERF_LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|server_group
operator|=
name|svn_auth_get_parameter
argument_list|(
name|session
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_SERVER_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_group
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|using_compression
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_COMPRESSION
argument_list|,
name|session
operator|->
name|using_compression
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|timeout_str
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_TIMEOUT
argument_list|,
name|timeout_str
argument_list|)
expr_stmt|;
comment|/* Load the group proxy server settings, overriding global          settings.  We intentionally ignore 'http-proxy-exceptions'          here because, well, if this site was an exception, why is          there a per-server proxy configuration for it?  */
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|proxy_host
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_HOST
argument_list|,
name|proxy_host
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|port_str
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_PORT
argument_list|,
name|port_str
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|proxy_username
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_USERNAME
argument_list|,
name|session
operator|->
name|proxy_username
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|proxy_password
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_PASSWORD
argument_list|,
name|session
operator|->
name|proxy_password
argument_list|)
expr_stmt|;
comment|/* Load the group ssl settings. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|trust_default_ca
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_SSL_TRUST_DEFAULT_CA
argument_list|,
name|session
operator|->
name|trust_default_ca
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|ssl_authorities
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_SSL_AUTHORITY_FILES
argument_list|,
name|session
operator|->
name|ssl_authorities
argument_list|)
expr_stmt|;
comment|/* Load the group bulk updates flag. */
name|SVN_ERR
argument_list|(
name|svn_config_get_tristate
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|bulk_updates
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_BULK_UPDATES
argument_list|,
literal|"auto"
argument_list|,
name|session
operator|->
name|bulk_updates
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load the maximum number of parallel session connections,          overriding global values. */
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|max_connections
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS
argument_list|,
name|session
operator|->
name|max_connections
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Should we use chunked transfer encoding. */
name|SVN_ERR
argument_list|(
name|svn_config_get_tristate
argument_list|(
name|config
argument_list|,
operator|&
name|chunked_requests
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_CHUNKED_REQUESTS
argument_list|,
literal|"auto"
argument_list|,
name|chunked_requests
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SERF_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|4
operator|,
literal|0
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SVN_SERF_NO_LOGGING
argument_list|)
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|log_components
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_SERF_LOG_COMPONENTS
argument_list|,
name|log_components
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|log_level
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_SERF_LOG_LEVEL
argument_list|,
name|log_level
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|SERF_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|4
operator|,
literal|0
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SVN_SERF_NO_LOGGING
argument_list|)
if|if
condition|(
name|log_components
operator|!=
name|SERF_LOGCOMP_NONE
condition|)
block|{
name|serf_log_output_t
modifier|*
name|output
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|serf_logging_create_stream_output
argument_list|(
operator|&
name|output
argument_list|,
name|session
operator|->
name|context
argument_list|,
operator|(
name|apr_uint32_t
operator|)
name|log_level
argument_list|,
operator|(
name|apr_uint32_t
operator|)
name|log_components
argument_list|,
name|SERF_LOG_DEFAULT_LAYOUT
argument_list|,
name|stderr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
name|serf_logging_add_output
argument_list|(
name|session
operator|->
name|context
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Don't allow the http-max-connections value to be larger than our      compiled-in limit, or to be too small to operate.  Broken      functionality and angry administrators are equally undesirable. */
if|if
condition|(
name|session
operator|->
name|max_connections
operator|>
name|SVN_RA_SERF__MAX_CONNECTIONS_LIMIT
condition|)
name|session
operator|->
name|max_connections
operator|=
name|SVN_RA_SERF__MAX_CONNECTIONS_LIMIT
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|max_connections
operator|<
literal|2
condition|)
name|session
operator|->
name|max_connections
operator|=
literal|2
expr_stmt|;
comment|/* Parse the connection timeout value, if any. */
name|session
operator|->
name|timeout
operator|=
name|apr_time_from_sec
argument_list|(
name|DEFAULT_HTTP_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout_str
condition|)
block|{
name|char
modifier|*
name|endstr
decl_stmt|;
specifier|const
name|long
name|int
name|timeout
init|=
name|strtol
argument_list|(
name|timeout_str
argument_list|,
operator|&
name|endstr
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|endstr
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid config: illegal character in "
literal|"timeout value"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid config: negative timeout value"
argument_list|)
argument_list|)
return|;
name|session
operator|->
name|timeout
operator|=
name|apr_time_from_sec
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|session
operator|->
name|timeout
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert the proxy port value, if any. */
if|if
condition|(
name|port_str
condition|)
block|{
name|char
modifier|*
name|endstr
decl_stmt|;
specifier|const
name|long
name|int
name|port
init|=
name|strtol
argument_list|(
name|port_str
argument_list|,
operator|&
name|endstr
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|endstr
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid URL: illegal character in proxy "
literal|"port number"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid URL: negative proxy port number"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|port
operator|>
literal|65535
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid URL: proxy port number greater "
literal|"than maximum TCP port number 65535"
argument_list|)
argument_list|)
return|;
name|proxy_port
operator|=
operator|(
name|apr_port_t
operator|)
name|port
expr_stmt|;
block|}
else|else
block|{
name|proxy_port
operator|=
literal|80
expr_stmt|;
block|}
if|if
condition|(
name|proxy_host
condition|)
block|{
name|apr_sockaddr_t
modifier|*
name|proxy_addr
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|apr_sockaddr_info_get
argument_list|(
operator|&
name|proxy_addr
argument_list|,
name|proxy_host
argument_list|,
name|APR_UNSPEC
argument_list|,
name|proxy_port
argument_list|,
literal|0
argument_list|,
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Could not resolve proxy server '%s'"
argument_list|)
argument_list|,
name|proxy_host
argument_list|)
return|;
block|}
name|session
operator|->
name|using_proxy
operator|=
name|TRUE
expr_stmt|;
name|serf_config_proxy
argument_list|(
name|session
operator|->
name|context
argument_list|,
name|proxy_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|session
operator|->
name|using_proxy
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Setup detect_chunking and using_chunked_requests based on    * the chunked_requests tristate */
if|if
condition|(
name|chunked_requests
operator|==
name|svn_tristate_unknown
condition|)
block|{
name|session
operator|->
name|detect_chunking
operator|=
name|TRUE
expr_stmt|;
name|session
operator|->
name|using_chunked_requests
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunked_requests
operator|==
name|svn_tristate_true
condition|)
block|{
name|session
operator|->
name|detect_chunking
operator|=
name|FALSE
expr_stmt|;
name|session
operator|->
name|using_chunked_requests
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
comment|/* chunked_requests == svn_tristate_false */
block|{
name|session
operator|->
name|detect_chunking
operator|=
name|FALSE
expr_stmt|;
name|session
operator|->
name|using_chunked_requests
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Setup authentication. */
name|SVN_ERR
argument_list|(
name|load_http_auth_types
argument_list|(
name|pool
argument_list|,
name|config
argument_list|,
name|server_group
argument_list|,
operator|&
name|session
operator|->
name|authn_types
argument_list|)
argument_list|)
expr_stmt|;
name|serf_config_authn_types
argument_list|(
name|session
operator|->
name|context
argument_list|,
name|session
operator|->
name|authn_types
argument_list|)
expr_stmt|;
name|serf_config_credentials_callback
argument_list|(
name|session
operator|->
name|context
argument_list|,
name|svn_ra_serf__credentials_callback
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DEFAULT_HTTP_TIMEOUT
end_undef

begin_function
specifier|static
name|void
name|svn_ra_serf__progress
parameter_list|(
name|void
modifier|*
name|progress_baton
parameter_list|,
name|apr_off_t
name|read
parameter_list|,
name|apr_off_t
name|written
parameter_list|)
block|{
specifier|const
name|svn_ra_serf__session_t
modifier|*
name|serf_sess
init|=
name|progress_baton
decl_stmt|;
if|if
condition|(
name|serf_sess
operator|->
name|progress_func
condition|)
block|{
name|serf_sess
operator|->
name|progress_func
argument_list|(
name|read
operator|+
name|written
argument_list|,
operator|-
literal|1
argument_list|,
name|serf_sess
operator|->
name|progress_baton
argument_list|,
name|serf_sess
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Our User-Agent string. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_user_agent_string
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|patch
decl_stmt|;
name|serf_lib_version
argument_list|(
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|,
operator|&
name|patch
argument_list|)
expr_stmt|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"SVN/%s (%s) serf/%d.%d.%d"
argument_list|,
name|SVN_VER_NUMBER
argument_list|,
name|SVN_BUILD_TARGET
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|patch
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.open_session(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__open
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|corrected_url
parameter_list|,
specifier|const
name|char
modifier|*
name|session_URL
parameter_list|,
specifier|const
name|svn_ra_callbacks2_t
modifier|*
name|callbacks
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|svn_auth_baton_t
modifier|*
name|auth_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|serf_sess
decl_stmt|;
name|apr_uri_t
name|url
decl_stmt|;
specifier|const
name|char
modifier|*
name|client_string
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|corrected_url
condition|)
operator|*
name|corrected_url
operator|=
name|NULL
expr_stmt|;
name|serf_sess
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|serf_sess
argument_list|)
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
if|if
condition|(
name|config
condition|)
name|SVN_ERR
argument_list|(
name|svn_config_copy_config
argument_list|(
operator|&
name|serf_sess
operator|->
name|config
argument_list|,
name|config
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|serf_sess
operator|->
name|config
operator|=
name|NULL
expr_stmt|;
name|serf_sess
operator|->
name|wc_callbacks
operator|=
name|callbacks
expr_stmt|;
name|serf_sess
operator|->
name|wc_callback_baton
operator|=
name|callback_baton
expr_stmt|;
name|serf_sess
operator|->
name|auth_baton
operator|=
name|auth_baton
expr_stmt|;
name|serf_sess
operator|->
name|progress_func
operator|=
name|callbacks
operator|->
name|progress_func
expr_stmt|;
name|serf_sess
operator|->
name|progress_baton
operator|=
name|callbacks
operator|->
name|progress_baton
expr_stmt|;
name|serf_sess
operator|->
name|cancel_func
operator|=
name|callbacks
operator|->
name|cancel_func
expr_stmt|;
name|serf_sess
operator|->
name|cancel_baton
operator|=
name|callback_baton
expr_stmt|;
comment|/* todo: reuse serf context across sessions */
name|serf_sess
operator|->
name|context
operator|=
name|serf_context_create
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_create
argument_list|(
operator|&
name|serf_sess
operator|->
name|blncache
argument_list|,
name|serf_sess
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__uri_parse
argument_list|(
operator|&
name|url
argument_list|,
name|session_URL
argument_list|,
name|serf_sess
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|url
operator|.
name|port
condition|)
block|{
name|url
operator|.
name|port
operator|=
name|apr_uri_port_of_scheme
argument_list|(
name|url
operator|.
name|scheme
argument_list|)
expr_stmt|;
block|}
name|serf_sess
operator|->
name|session_url
operator|=
name|url
expr_stmt|;
name|serf_sess
operator|->
name|session_url_str
operator|=
name|apr_pstrdup
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|,
name|session_URL
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|using_ssl
operator|=
operator|(
name|svn_cstring_casecmp
argument_list|(
name|url
operator|.
name|scheme
argument_list|,
literal|"https"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|serf_sess
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_unknown
expr_stmt|;
name|serf_sess
operator|->
name|capabilities
operator|=
name|apr_hash_make
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* We have to assume that the server only supports HTTP/1.0. Once it's clear      HTTP/1.1 is supported, we can upgrade. */
name|serf_sess
operator|->
name|http10
operator|=
name|TRUE
expr_stmt|;
comment|/* If we switch to HTTP/1.1, then we will use chunked requests. We may disable      this, if we find an intervening proxy does not support chunked requests.  */
name|serf_sess
operator|->
name|using_chunked_requests
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|load_config
argument_list|(
name|serf_sess
argument_list|,
name|config
argument_list|,
name|serf_sess
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|bkt_alloc
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|session
operator|=
name|serf_sess
expr_stmt|;
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|last_status_code
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* create the user agent string */
if|if
condition|(
name|callbacks
operator|->
name|get_client_string
condition|)
name|SVN_ERR
argument_list|(
name|callbacks
operator|->
name|get_client_string
argument_list|(
name|callback_baton
argument_list|,
operator|&
name|client_string
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_string
condition|)
name|serf_sess
operator|->
name|useragent
operator|=
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|get_user_agent_string
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
literal|" "
argument_list|,
name|client_string
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
else|else
name|serf_sess
operator|->
name|useragent
operator|=
name|get_user_agent_string
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* go ahead and tell serf about the connection. */
name|status
operator|=
name|serf_connection_create2
argument_list|(
operator|&
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|conn
argument_list|,
name|serf_sess
operator|->
name|context
argument_list|,
name|url
argument_list|,
name|svn_ra_serf__conn_setup
argument_list|,
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|svn_ra_serf__conn_closed
argument_list|,
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|serf_sess
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Set the progress callback. */
name|serf_context_set_progress_cb
argument_list|(
name|serf_sess
operator|->
name|context
argument_list|,
name|svn_ra_serf__progress
argument_list|,
name|serf_sess
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|num_conns
operator|=
literal|1
expr_stmt|;
name|session
operator|->
name|priv
operator|=
name|serf_sess
expr_stmt|;
comment|/* The following code explicitly works around a bug in serf<= r2319 / 1.3.8      where serf doesn't report the request as failed/cancelled when the      authorization request handler fails to handle the request.       As long as we allocate the request in a subpool of the serf connection      pool, we know that the handler is always cleaned before the connection.       Luckily our caller now passes us two pools which handle this case.    */
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
operator|&&
operator|!
name|SERF_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|4
operator|,
literal|0
argument_list|)
comment|/* Currently ensured by svn_ra_open4().      If failing causes segfault in basic_tests.py 48, "basic auth test" */
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|serf_sess
operator|->
name|pool
operator|!=
name|scratch_pool
operator|)
operator|&&
name|apr_pool_is_ancestor
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|svn_ra_serf__exchange_capabilities
argument_list|(
name|serf_sess
argument_list|,
name|corrected_url
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* serf should produce a usable error code instead of APR_EGENERAL */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|APR_EGENERAL
condition|)
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Connection to '%s' failed"
argument_list|)
argument_list|,
name|session_URL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We have set up a useful connection (that doesn't indication a redirect).      If we've been told there is possibly a worrisome proxy in our path to the      server AND we switched to HTTP/1.1 (chunked requests), then probe for      problems in any proxy.  */
if|if
condition|(
operator|(
name|corrected_url
operator|==
name|NULL
operator|||
operator|*
name|corrected_url
operator|==
name|NULL
operator|)
operator|&&
name|serf_sess
operator|->
name|detect_chunking
operator|&&
operator|!
name|serf_sess
operator|->
name|http10
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_serf__probe_proxy
argument_list|(
name|serf_sess
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.dup_session */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_serf_dup_session
parameter_list|(
name|svn_ra_session_t
modifier|*
name|new_session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|old_session
parameter_list|,
specifier|const
name|char
modifier|*
name|new_session_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|old_sess
init|=
name|old_session
operator|->
name|priv
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|new_sess
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|new_sess
operator|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|old_sess
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_sess
argument_list|)
argument_list|)
expr_stmt|;
name|new_sess
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
if|if
condition|(
name|new_sess
operator|->
name|config
condition|)
name|SVN_ERR
argument_list|(
name|svn_config_copy_config
argument_list|(
operator|&
name|new_sess
operator|->
name|config
argument_list|,
name|new_sess
operator|->
name|config
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* max_connections */
comment|/* using_ssl */
comment|/* using_compression */
comment|/* http10 */
comment|/* using_chunked_requests */
comment|/* detect_chunking */
if|if
condition|(
name|new_sess
operator|->
name|useragent
condition|)
name|new_sess
operator|->
name|useragent
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|useragent
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sess
operator|->
name|vcc_url
condition|)
name|new_sess
operator|->
name|vcc_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|vcc_url
argument_list|)
expr_stmt|;
name|new_sess
operator|->
name|auth_state
operator|=
name|NULL
expr_stmt|;
name|new_sess
operator|->
name|auth_attempts
operator|=
literal|0
expr_stmt|;
comment|/* Callback functions to get info from WC */
comment|/* wc_callbacks */
comment|/* wc_callback_baton */
comment|/* progress_func */
comment|/* progress_baton */
comment|/* cancel_func */
comment|/* cancel_baton */
comment|/* shim_callbacks */
name|new_sess
operator|->
name|pending_error
operator|=
name|NULL
expr_stmt|;
comment|/* authn_types */
comment|/* Keys and values are static */
if|if
condition|(
name|new_sess
operator|->
name|capabilities
condition|)
name|new_sess
operator|->
name|capabilities
operator|=
name|apr_hash_copy
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|capabilities
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sess
operator|->
name|activity_collection_url
condition|)
block|{
name|new_sess
operator|->
name|activity_collection_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|activity_collection_url
argument_list|)
expr_stmt|;
block|}
comment|/* using_proxy */
if|if
condition|(
name|new_sess
operator|->
name|proxy_username
condition|)
block|{
name|new_sess
operator|->
name|proxy_username
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|proxy_username
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_sess
operator|->
name|proxy_password
condition|)
block|{
name|new_sess
operator|->
name|proxy_username
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|proxy_password
argument_list|)
expr_stmt|;
block|}
name|new_sess
operator|->
name|proxy_auth_attempts
operator|=
literal|0
expr_stmt|;
comment|/* trust_default_ca */
if|if
condition|(
name|new_sess
operator|->
name|ssl_authorities
condition|)
block|{
name|new_sess
operator|->
name|ssl_authorities
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|ssl_authorities
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_sess
operator|->
name|uuid
condition|)
name|new_sess
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|uuid
argument_list|)
expr_stmt|;
comment|/* timeout */
comment|/* supports_deadprop_count */
if|if
condition|(
name|new_sess
operator|->
name|me_resource
condition|)
name|new_sess
operator|->
name|me_resource
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|me_resource
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sess
operator|->
name|rev_stub
condition|)
name|new_sess
operator|->
name|rev_stub
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|rev_stub
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sess
operator|->
name|txn_stub
condition|)
name|new_sess
operator|->
name|txn_stub
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|txn_stub
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sess
operator|->
name|txn_root_stub
condition|)
name|new_sess
operator|->
name|txn_root_stub
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|txn_root_stub
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sess
operator|->
name|vtxn_stub
condition|)
name|new_sess
operator|->
name|vtxn_stub
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|vtxn_stub
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sess
operator|->
name|vtxn_root_stub
condition|)
name|new_sess
operator|->
name|vtxn_root_stub
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|vtxn_root_stub
argument_list|)
expr_stmt|;
comment|/* Keys and values are static */
if|if
condition|(
name|new_sess
operator|->
name|supported_posts
condition|)
name|new_sess
operator|->
name|supported_posts
operator|=
name|apr_hash_copy
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|supported_posts
argument_list|)
expr_stmt|;
comment|/* ### Can we copy this? */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_create
argument_list|(
operator|&
name|new_sess
operator|->
name|blncache
argument_list|,
name|new_sess
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sess
operator|->
name|server_allows_bulk
condition|)
name|new_sess
operator|->
name|server_allows_bulk
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|server_allows_bulk
argument_list|)
expr_stmt|;
name|new_sess
operator|->
name|repos_root_str
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_sess
operator|->
name|repos_root_str
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__uri_parse
argument_list|(
operator|&
name|new_sess
operator|->
name|repos_root
argument_list|,
name|new_sess
operator|->
name|repos_root_str
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_sess
operator|->
name|session_url_str
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|new_session_url
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__uri_parse
argument_list|(
operator|&
name|new_sess
operator|->
name|session_url
argument_list|,
name|new_sess
operator|->
name|session_url_str
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* svn_boolean_t supports_inline_props */
comment|/* supports_rev_rsrc_replay */
name|new_sess
operator|->
name|context
operator|=
name|serf_context_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|load_config
argument_list|(
name|new_sess
argument_list|,
name|old_sess
operator|->
name|config
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_sess
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|new_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|bkt_alloc
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|result_pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|session
operator|=
name|new_sess
expr_stmt|;
name|new_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|last_status_code
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* go ahead and tell serf about the connection. */
name|status
operator|=
name|serf_connection_create2
argument_list|(
operator|&
name|new_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|conn
argument_list|,
name|new_sess
operator|->
name|context
argument_list|,
name|new_sess
operator|->
name|session_url
argument_list|,
name|svn_ra_serf__conn_setup
argument_list|,
name|new_sess
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|svn_ra_serf__conn_closed
argument_list|,
name|new_sess
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Set the progress callback. */
name|serf_context_set_progress_cb
argument_list|(
name|new_sess
operator|->
name|context
argument_list|,
name|svn_ra_serf__progress
argument_list|,
name|new_sess
argument_list|)
expr_stmt|;
name|new_sess
operator|->
name|num_conns
operator|=
literal|1
expr_stmt|;
name|new_sess
operator|->
name|cur_conn
operator|=
literal|0
expr_stmt|;
name|new_session
operator|->
name|priv
operator|=
name|new_sess
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.reparent(). */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__reparent
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_uri_t
name|new_url
decl_stmt|;
comment|/* If it's the URL we already have, wave our hands and do nothing. */
if|if
condition|(
name|strcmp
argument_list|(
name|session
operator|->
name|session_url_str
argument_list|,
name|url
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|session
operator|->
name|repos_root_str
condition|)
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|session
operator|->
name|repos_root_str
argument_list|,
name|url
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"URL '%s' is not a child of the session's repository root "
literal|"URL '%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|session
operator|->
name|repos_root_str
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_serf__uri_parse
argument_list|(
operator|&
name|new_url
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Maybe we should use a string buffer for these strings so we      ### don't allocate memory in the session on every reparent? */
name|session
operator|->
name|session_url
operator|.
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|session
operator|->
name|pool
argument_list|,
name|new_url
operator|.
name|path
argument_list|)
expr_stmt|;
name|session
operator|->
name|session_url_str
operator|=
name|apr_pstrdup
argument_list|(
name|session
operator|->
name|pool
argument_list|,
name|url
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.get_session_url(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__get_session_url
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
operator|*
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|session
operator|->
name|session_url_str
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.get_latest_revnum(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__get_latest_revnum
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
modifier|*
name|latest_revnum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__get_youngest_revnum
argument_list|(
name|latest_revnum
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implementation of svn_ra_serf__rev_proplist(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|serf__rev_proplist
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|fetch_props
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|ret_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|char
modifier|*
name|propfind_path
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
block|{
name|propfind_path
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%s/%ld"
argument_list|,
name|session
operator|->
name|rev_stub
argument_list|,
name|rev
argument_list|)
expr_stmt|;
comment|/* svn_ra_serf__retrieve_props() wants to added the revision as          a Label to the PROPFIND, which isn't really necessary when          querying a rev-stub URI.  *Shrug*  Probably okay to leave the          Label, but whatever. */
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the VCC as the propfind target path. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|propfind_path
argument_list|,
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__create_propfind_handler
argument_list|(
operator|&
name|handler
argument_list|,
name|session
argument_list|,
name|propfind_path
argument_list|,
name|rev
argument_list|,
literal|"0"
argument_list|,
name|fetch_props
argument_list|,
name|svn_ra_serf__deliver_svn_props
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__keep_only_regular_props
argument_list|(
name|props
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|ret_props
operator|=
name|props
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.rev_proplist(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__rev_proplist
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|ret_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|serf__rev_proplist
argument_list|(
name|ra_session
argument_list|,
name|rev
argument_list|,
name|all_props
argument_list|,
name|ret_props
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.rev_prop(). */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_string_t
modifier|*
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_ra_serf__dav_props_t
name|specific_props
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|fetch_props
init|=
name|all_props
decl_stmt|;
comment|/* The DAV propfind doesn't allow property fetches for any property name      as there is no defined way to quote values. If we are just fetching a      "svn:property" we can safely do this. In other cases we just fetch all      revision properties and filter the right one out */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_PROP_PREFIX
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|strchr
argument_list|(
name|name
operator|+
sizeof|sizeof
argument_list|(
name|SVN_PROP_PREFIX
argument_list|)
operator|-
literal|1
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|specific_props
index|[
literal|0
index|]
operator|.
name|xmlns
operator|=
name|SVN_DAV_PROP_NS_SVN
expr_stmt|;
name|specific_props
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|name
operator|+
sizeof|sizeof
argument_list|(
name|SVN_PROP_PREFIX
argument_list|)
operator|-
literal|1
expr_stmt|;
name|specific_props
index|[
literal|1
index|]
operator|.
name|xmlns
operator|=
name|NULL
expr_stmt|;
name|specific_props
index|[
literal|1
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|fetch_props
operator|=
name|specific_props
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|serf__rev_proplist
argument_list|(
name|session
argument_list|,
name|rev
argument_list|,
name|fetch_props
argument_list|,
operator|&
name|props
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_repos_root
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|repos_root_str
condition|)
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|url
operator|=
name|session
operator|->
name|repos_root_str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* TODO: to fetch the uuid from the repository, we need:    1. a path that exists in HEAD    2. a path that's readable     get_uuid handles the case where a path doesn't exist in HEAD and also the    case where the root of the repository is not readable.    However, it does not handle the case where we're fetching path not existing    in HEAD of a repository with unreadable root directory.     Implements svn_ra__vtable_t.get_uuid().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__get_uuid
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|uuid
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|uuid
condition|)
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
comment|/* We should never get here if we have HTTP v2 support, because          any server with that support should be transmitting the          UUID in the initial OPTIONS response.  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're not interested in vcc_url and relative_url, but this call also          stores the repository's uuid in the session. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|uuid
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_RESPONSE_HEADER_BADNESS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The UUID property was not found on the "
literal|"resource or any of its parents"
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|*
name|uuid
operator|=
name|session
operator|->
name|uuid
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra__vtable_t
name|serf_vtable
init|=
block|{
name|ra_serf_version
block|,
name|ra_serf_get_description
block|,
name|ra_serf_get_schemes
block|,
name|svn_ra_serf__open
block|,
name|ra_serf_dup_session
block|,
name|svn_ra_serf__reparent
block|,
name|svn_ra_serf__get_session_url
block|,
name|svn_ra_serf__get_latest_revnum
block|,
name|svn_ra_serf__get_dated_revision
block|,
name|svn_ra_serf__change_rev_prop
block|,
name|svn_ra_serf__rev_proplist
block|,
name|svn_ra_serf__rev_prop
block|,
name|svn_ra_serf__get_commit_editor
block|,
name|svn_ra_serf__get_file
block|,
name|svn_ra_serf__get_dir
block|,
name|svn_ra_serf__get_mergeinfo
block|,
name|svn_ra_serf__do_update
block|,
name|svn_ra_serf__do_switch
block|,
name|svn_ra_serf__do_status
block|,
name|svn_ra_serf__do_diff
block|,
name|svn_ra_serf__get_log
block|,
name|svn_ra_serf__check_path
block|,
name|svn_ra_serf__stat
block|,
name|svn_ra_serf__get_uuid
block|,
name|svn_ra_serf__get_repos_root
block|,
name|svn_ra_serf__get_locations
block|,
name|svn_ra_serf__get_location_segments
block|,
name|svn_ra_serf__get_file_revs
block|,
name|svn_ra_serf__lock
block|,
name|svn_ra_serf__unlock
block|,
name|svn_ra_serf__get_lock
block|,
name|svn_ra_serf__get_locks
block|,
name|svn_ra_serf__replay
block|,
name|svn_ra_serf__has_capability
block|,
name|svn_ra_serf__replay_range
block|,
name|svn_ra_serf__get_deleted_rev
block|,
name|svn_ra_serf__register_editor_shim_callbacks
block|,
name|svn_ra_serf__get_inherited_props
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__init
parameter_list|(
specifier|const
name|svn_version_t
modifier|*
name|loader_version
parameter_list|,
specifier|const
name|svn_ra__vtable_t
modifier|*
modifier|*
name|vtable
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|int
name|serf_major
decl_stmt|;
name|int
name|serf_minor
decl_stmt|;
name|int
name|serf_patch
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ver_check_list2
argument_list|(
name|ra_serf_version
argument_list|()
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Simplified version check to make sure we can safely use the      VTABLE parameter. The RA loader does a more exhaustive check. */
if|if
condition|(
name|loader_version
operator|->
name|major
operator|!=
name|SVN_VER_MAJOR
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_VERSION_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported RA loader version (%d) for ra_serf"
argument_list|)
argument_list|,
name|loader_version
operator|->
name|major
argument_list|)
return|;
block|}
comment|/* Make sure that we have loaded a compatible library: the MAJOR must      match, and the minor must be at *least* what we compiled against.      The patch level is simply ignored.  */
name|serf_lib_version
argument_list|(
operator|&
name|serf_major
argument_list|,
operator|&
name|serf_minor
argument_list|,
operator|&
name|serf_patch
argument_list|)
expr_stmt|;
if|if
condition|(
name|serf_major
operator|!=
name|SERF_MAJOR_VERSION
operator|||
name|serf_minor
operator|<
name|SERF_MINOR_VERSION
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
comment|/* ### should return a unique error  */
name|SVN_ERR_VERSION_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"ra_serf was compiled for serf %d.%d.%d but loaded "
literal|"an incompatible %d.%d.%d library"
argument_list|)
argument_list|,
name|SERF_MAJOR_VERSION
argument_list|,
name|SERF_MINOR_VERSION
argument_list|,
name|SERF_PATCH_VERSION
argument_list|,
name|serf_major
argument_list|,
name|serf_minor
argument_list|,
name|serf_patch
argument_list|)
return|;
block|}
operator|*
name|vtable
operator|=
operator|&
name|serf_vtable
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compatibility wrapper for pre-1.2 subversions.  Needed? */
end_comment

begin_define
define|#
directive|define
name|NAME
value|"ra_serf"
end_define

begin_define
define|#
directive|define
name|DESCRIPTION
value|RA_SERF_DESCRIPTION
end_define

begin_define
define|#
directive|define
name|VTBL
value|serf_vtable
end_define

begin_define
define|#
directive|define
name|INITFUNC
value|svn_ra_serf__init
end_define

begin_define
define|#
directive|define
name|COMPAT_INITFUNC
value|svn_ra_serf_init
end_define

begin_include
include|#
directive|include
file|"../libsvn_ra/wrapper_template.h"
end_include

end_unit

