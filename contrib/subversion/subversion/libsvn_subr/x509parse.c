begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  X.509 certificate and private key decoding  *  *  Based on XySSL: Copyright (C) 2006-2008   Christophe Devine  *  *  Copyright (C) 2009  Paul Bakker<polarssl_maintainer at polarssl dot org>  *  *  All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *    * Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *    * Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *    * Neither the names of PolarSSL or XySSL nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  The ITU-T X.509 standard defines a certificate format for PKI.  *  *  http://www.ietf.org/rfc/rfc5280.txt  *  http://www.ietf.org/rfc/rfc3279.txt  *  http://www.ietf.org/rfc/rfc6818.txt  *  *  ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-1v2.asc  *  *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf  *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"x509.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*  * ASN.1 DER decoding routines  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|asn1_get_len
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|ptrdiff_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
operator|(
name|end
operator|-
operator|*
name|p
operator|)
operator|<
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_OUT_OF_DATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
operator|(
operator|*
operator|*
name|p
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
operator|*
name|len
operator|=
operator|*
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
else|else
switch|switch
condition|(
operator|*
operator|*
name|p
operator|&
literal|0x7F
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|end
operator|-
operator|*
name|p
operator|)
operator|<
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_OUT_OF_DATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
operator|*
name|len
operator|=
operator|(
operator|*
name|p
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|end
operator|-
operator|*
name|p
operator|)
operator|<
literal|3
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_OUT_OF_DATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
operator|*
name|len
operator|=
operator|(
operator|(
operator|*
name|p
operator|)
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|p
operator|)
index|[
literal|2
index|]
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|+=
literal|3
expr_stmt|;
break|break;
default|default:
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_INVALID_LENGTH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
break|break;
block|}
if|if
condition|(
operator|*
name|len
operator|>
operator|(
name|end
operator|-
operator|*
name|p
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_OUT_OF_DATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|asn1_get_tag
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|ptrdiff_t
modifier|*
name|len
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
if|if
condition|(
operator|(
name|end
operator|-
operator|*
name|p
operator|)
operator|<
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_OUT_OF_DATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
operator|*
operator|*
name|p
operator|!=
name|tag
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_UNEXPECTED_TAG
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|asn1_get_len
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|asn1_get_int
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
block|{
name|ptrdiff_t
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_INTEGER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reject bit patterns that would overflow the output and those that      represent negative values. */
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|||
operator|(
operator|*
operator|*
name|p
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_INVALID_LENGTH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* This would be undefined for bit-patterns of negative values. */
operator|*
name|val
operator|=
operator|(
operator|*
name|val
operator|<<
literal|8
operator|)
operator||
operator|*
operator|*
name|p
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|equal
parameter_list|(
specifier|const
name|void
modifier|*
name|left
parameter_list|,
name|apr_size_t
name|left_len
parameter_list|,
specifier|const
name|void
modifier|*
name|right
parameter_list|,
name|apr_size_t
name|right_len
parameter_list|)
block|{
if|if
condition|(
name|left_len
operator|!=
name|right_len
condition|)
return|return
name|FALSE
return|;
return|return
name|memcmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|right_len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|oids_equal
parameter_list|(
name|x509_buf
modifier|*
name|left
parameter_list|,
name|x509_buf
modifier|*
name|right
parameter_list|)
block|{
return|return
name|equal
argument_list|(
name|left
operator|->
name|p
argument_list|,
name|left
operator|->
name|len
argument_list|,
name|right
operator|->
name|p
argument_list|,
name|right
operator|->
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Version   ::=  INTEGER  {  v1(0), v2(1), v3(2)  }  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_version
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|int
modifier|*
name|ver
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
comment|/*    * As defined in the Basic Certificate fields:    *   version         [0]  EXPLICIT Version DEFAULT v1,    * the version is the context specific tag 0.    */
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONTEXT_SPECIFIC
operator||
name|ASN1_CONSTRUCTED
operator||
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ASN1_UNEXPECTED_TAG
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|ver
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|end
operator|=
operator|*
name|p
operator|+
name|len
expr_stmt|;
name|err
operator|=
name|asn1_get_int
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
name|ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_VERSION
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
operator|*
name|p
operator|!=
name|end
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_LENGTH_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_VERSION
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  *  CertificateSerialNumber   ::=  INTEGER  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_serial
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|x509_buf
modifier|*
name|serial
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|end
operator|-
operator|*
name|p
operator|)
operator|<
literal|1
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_OUT_OF_DATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_SERIAL
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|p
operator|!=
operator|(
name|ASN1_CONTEXT_SPECIFIC
operator||
name|ASN1_PRIMITIVE
operator||
literal|2
operator|)
operator|&&
operator|*
operator|*
name|p
operator|!=
name|ASN1_INTEGER
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_UNEXPECTED_TAG
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_SERIAL
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|serial
operator|->
name|tag
operator|=
operator|*
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
name|err
operator|=
name|asn1_get_len
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|serial
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_SERIAL
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|serial
operator|->
name|p
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|+=
name|serial
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  *  AlgorithmIdentifier   ::=  SEQUENCE  {  *     algorithm         OBJECT IDENTIFIER,  *     parameters        ANY DEFINED BY algorithm OPTIONAL  }  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_alg
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|x509_buf
modifier|*
name|alg
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_ALG
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|end
operator|=
operator|*
name|p
operator|+
name|len
expr_stmt|;
name|alg
operator|->
name|tag
operator|=
operator|*
operator|*
name|p
expr_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|alg
operator|->
name|len
argument_list|,
name|ASN1_OID
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_ALG
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|alg
operator|->
name|p
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|+=
name|alg
operator|->
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|end
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/*    * assume the algorithm parameters must be NULL    */
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_ALG
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
operator|*
name|p
operator|!=
name|end
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_LENGTH_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_ALG
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  *  AttributeTypeAndValue ::= SEQUENCE {  *    type     AttributeType,  *    value     AttributeValue }  *  *  AttributeType ::= OBJECT IDENTIFIER  *  *  AttributeValue ::= ANY DEFINED BY AttributeType  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_attribute
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|x509_name
modifier|*
name|cur
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
name|x509_buf
modifier|*
name|oid
decl_stmt|;
name|x509_buf
modifier|*
name|val
decl_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_NAME
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|end
operator|=
operator|*
name|p
operator|+
name|len
expr_stmt|;
name|oid
operator|=
operator|&
name|cur
operator|->
name|oid
expr_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|oid
operator|->
name|len
argument_list|,
name|ASN1_OID
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_NAME
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|oid
operator|->
name|tag
operator|=
name|ASN1_OID
expr_stmt|;
name|oid
operator|->
name|p
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|+=
name|oid
operator|->
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|-
operator|*
name|p
operator|)
operator|<
literal|1
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_OUT_OF_DATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_NAME
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|p
operator|!=
name|ASN1_BMP_STRING
operator|&&
operator|*
operator|*
name|p
operator|!=
name|ASN1_UTF8_STRING
operator|&&
operator|*
operator|*
name|p
operator|!=
name|ASN1_T61_STRING
operator|&&
operator|*
operator|*
name|p
operator|!=
name|ASN1_PRINTABLE_STRING
operator|&&
operator|*
operator|*
name|p
operator|!=
name|ASN1_IA5_STRING
operator|&&
operator|*
operator|*
name|p
operator|!=
name|ASN1_UNIVERSAL_STRING
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_UNEXPECTED_TAG
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_NAME
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|val
operator|=
operator|&
name|cur
operator|->
name|val
expr_stmt|;
name|val
operator|->
name|tag
operator|=
operator|*
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
name|err
operator|=
name|asn1_get_len
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|val
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_NAME
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|val
operator|->
name|p
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|+=
name|val
operator|->
name|len
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
name|end
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_LENGTH_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_NAME
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  *   RelativeDistinguishedName ::=  *   SET SIZE (1..MAX) OF AttributeTypeAndValue  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|name_end
parameter_list|,
name|x509_name
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|set_end
decl_stmt|;
name|x509_name
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|name_end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_NAME
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|set_end
operator|=
operator|*
name|p
operator|+
name|len
expr_stmt|;
comment|/*    * iterate until the end of the SET is reached    */
while|while
condition|(
operator|*
name|p
operator|<
name|set_end
condition|)
block|{
if|if
condition|(
operator|!
name|cur
condition|)
block|{
name|cur
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|->
name|next
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|x509_name
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|x509_get_attribute
argument_list|(
name|p
argument_list|,
name|set_end
argument_list|,
name|cur
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * recurse until end of SEQUENCE (name) is reached    */
if|if
condition|(
operator|*
name|p
operator|==
name|name_end
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|cur
operator|->
name|next
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|x509_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|x509_get_name
argument_list|(
name|p
argument_list|,
name|name_end
argument_list|,
name|cur
operator|->
name|next
argument_list|,
name|result_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the date from the X.509 cert data between *P and END in either  * UTCTime or GeneralizedTime format (as defined in RFC 5280 s. 4.1.2.5.1 and  * 4.1.2.5.2 respectively) and place the result in WHEN using  SCRATCH_POOL  * for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_date
parameter_list|(
name|apr_time_t
modifier|*
name|when
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_status_t
name|ret
decl_stmt|;
name|int
name|tag
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|apr_time_exp_t
name|xt
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|tz
decl_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_UTC_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ASN1_UNEXPECTED_TAG
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_GENERALIZED_TIME
argument_list|)
expr_stmt|;
name|tag
operator|=
name|ASN1_GENERALIZED_TIME
expr_stmt|;
block|}
else|else
block|{
name|tag
operator|=
name|ASN1_UTC_TIME
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_DATE
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|date
operator|=
name|apr_pstrndup
argument_list|(
name|scratch_pool
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|*
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|ASN1_UTC_TIME
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|date
argument_list|,
literal|"%2d%2d%2d%2d%2d%2d%c"
argument_list|,
operator|&
name|xt
operator|.
name|tm_year
argument_list|,
operator|&
name|xt
operator|.
name|tm_mon
argument_list|,
operator|&
name|xt
operator|.
name|tm_mday
argument_list|,
operator|&
name|xt
operator|.
name|tm_hour
argument_list|,
operator|&
name|xt
operator|.
name|tm_min
argument_list|,
operator|&
name|xt
operator|.
name|tm_sec
argument_list|,
operator|&
name|tz
argument_list|)
operator|<
literal|6
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_DATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* UTCTime only provides a 2 digit year.  X.509 specifies that years        * greater than or equal to 50 must be interpreted as 19YY and years        * less than 50 be interpreted as 20YY.  This format is not used for        * years greater than 2049. apr_time_exp_t wants years as the number        * of years since 1900, so don't convert to 4 digits here. */
name|xt
operator|.
name|tm_year
operator|+=
literal|100
operator|*
operator|(
name|xt
operator|.
name|tm_year
operator|<
literal|50
operator|)
expr_stmt|;
break|break;
case|case
name|ASN1_GENERALIZED_TIME
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|date
argument_list|,
literal|"%4d%2d%2d%2d%2d%2d%c"
argument_list|,
operator|&
name|xt
operator|.
name|tm_year
argument_list|,
operator|&
name|xt
operator|.
name|tm_mon
argument_list|,
operator|&
name|xt
operator|.
name|tm_mday
argument_list|,
operator|&
name|xt
operator|.
name|tm_hour
argument_list|,
operator|&
name|xt
operator|.
name|tm_min
argument_list|,
operator|&
name|xt
operator|.
name|tm_sec
argument_list|,
operator|&
name|tz
argument_list|)
operator|<
literal|6
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_DATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* GeneralizedTime has the full 4 digit year.  But apr_time_exp_t        * wants years as the number of years since 1900. */
name|xt
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
break|break;
default|default:
comment|/* shouldn't ever get here because we should error out above in the        * asn1_get_tag() bits but doesn't hurt to be extra paranoid. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_DATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
break|break;
block|}
comment|/* check that the timezone is GMT    * ASN.1 allows for the timezone to be specified but X.509 says it must    * always be GMT.  A little bit of extra paranoia here seems like a good    * idea. */
if|if
condition|(
name|tz
operator|!=
literal|'Z'
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_DATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* apr_time_exp_t expects months to be zero indexed, 0=Jan, 11=Dec. */
name|xt
operator|.
name|tm_mon
operator|-=
literal|1
expr_stmt|;
name|ret
operator|=
name|apr_time_exp_gmt_get
argument_list|(
name|when
argument_list|,
operator|&
name|xt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|ret
argument_list|,
name|NULL
argument_list|)
return|;
operator|*
name|p
operator|+=
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  *  Validity ::= SEQUENCE {  *     notBefore    Time,  *     notAfter    Time }  *  *  Time ::= CHOICE {  *     utcTime    UTCTime,  *     generalTime  GeneralizedTime }  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_dates
parameter_list|(
name|apr_time_t
modifier|*
name|from
parameter_list|,
name|apr_time_t
modifier|*
name|to
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_DATE
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|end
operator|=
operator|*
name|p
operator|+
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|x509_get_date
argument_list|(
name|from
argument_list|,
name|p
argument_list|,
name|end
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|x509_get_date
argument_list|(
name|to
argument_list|,
name|p
argument_list|,
name|end
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
name|end
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_LENGTH_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_DATE
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_sig
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|x509_buf
modifier|*
name|sig
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_BIT_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_SIGNATURE
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|sig
operator|->
name|tag
operator|=
name|ASN1_BIT_STRING
expr_stmt|;
if|if
condition|(
operator|--
name|len
operator|<
literal|1
operator|||
operator|*
operator|(
operator|*
name|p
operator|)
operator|++
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_SIGNATURE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|sig
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|sig
operator|->
name|p
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|+=
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * X.509 v2/v3 unique identifier (not parsed)  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_uid
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|x509_buf
modifier|*
name|uid
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|end
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|uid
operator|->
name|len
argument_list|,
name|ASN1_CONTEXT_SPECIFIC
operator||
name|ASN1_CONSTRUCTED
operator||
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ASN1_UNEXPECTED_TAG
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|uid
operator|->
name|tag
operator|=
name|ASN1_CONTEXT_SPECIFIC
operator||
name|ASN1_CONSTRUCTED
operator||
name|n
expr_stmt|;
name|uid
operator|->
name|p
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|+=
name|uid
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * X.509 v3 extensions (not parsed)  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_get_ext
parameter_list|(
name|apr_array_header_t
modifier|*
name|dnsnames
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|end
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONTEXT_SPECIFIC
operator||
name|ASN1_CONSTRUCTED
operator||
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* If there aren't extensions that's ok they aren't required */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ASN1_UNEXPECTED_TAG
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|end
operator|=
operator|*
name|p
operator|+
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
operator|*
name|p
operator|+
name|len
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_LENGTH_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_EXTENSIONS
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
while|while
condition|(
operator|*
name|p
operator|<
name|end
condition|)
block|{
name|ptrdiff_t
name|ext_len
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|ext_start
decl_stmt|,
modifier|*
name|sna_end
decl_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|ext_len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_EXTENSIONS
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|ext_start
operator|=
operator|*
name|p
expr_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_OID
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_EXTENSIONS
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* skip all extensions except SubjectAltName */
if|if
condition|(
operator|!
name|equal
argument_list|(
operator|*
name|p
argument_list|,
name|len
argument_list|,
name|OID_SUBJECT_ALT_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|OID_SUBJECT_ALT_NAME
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|*
name|p
operator|+=
name|ext_len
operator|-
operator|(
operator|*
name|p
operator|-
name|ext_start
operator|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|+=
name|len
expr_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_OCTET_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_EXTENSIONS
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
comment|/*   SubjectAltName ::= GeneralNames             GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName             GeneralName ::= CHOICE {                 other Name                      [0]     OtherName,                 rfc822Name                      [1]     IA5String,                 dNSName                         [2]     IA5String,                 x400Address                     [3]     ORAddress,                 directoryName                   [4]     Name,                 ediPartyName                    [5]     EDIPartyName,                 uniformResourceIdentifier       [6]     IA5String,                 iPAddress                       [7]     OCTET STRING,                 registeredID                    [8]     OBJECT IDENTIFIER } */
name|sna_end
operator|=
operator|*
name|p
operator|+
name|len
expr_stmt|;
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|sna_end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_EXTENSIONS
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|sna_end
operator|!=
operator|*
name|p
operator|+
name|len
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_LENGTH_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_EXTENSIONS
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
while|while
condition|(
operator|*
name|p
operator|<
name|sna_end
condition|)
block|{
name|err
operator|=
name|asn1_get_tag
argument_list|(
name|p
argument_list|,
name|sna_end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONTEXT_SPECIFIC
operator||
name|ASN1_PRIMITIVE
operator||
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* not not a dNSName */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ASN1_UNEXPECTED_TAG
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* need to skip the tag and then find the length to                    * skip to ignore this SNA entry. */
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|asn1_get_len
argument_list|(
name|p
argument_list|,
name|sna_end
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|+=
name|len
expr_stmt|;
continue|continue;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
block|{
comment|/* We found a dNSName entry */
name|x509_buf
modifier|*
name|dnsname
init|=
name|apr_palloc
argument_list|(
name|dnsnames
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|x509_buf
argument_list|)
argument_list|)
decl_stmt|;
name|dnsname
operator|->
name|tag
operator|=
name|ASN1_IA5_STRING
expr_stmt|;
comment|/* implicit based on dNSName */
name|dnsname
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|dnsname
operator|->
name|p
operator|=
operator|*
name|p
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|dnsnames
argument_list|,
name|x509_buf
operator|*
argument_list|)
operator|=
name|dnsname
expr_stmt|;
block|}
operator|*
name|p
operator|+=
name|len
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Escape all non-ascii or control characters similar to  * svn_xml_fuzzy_escape() and svn_utf_cstring_from_utf8_fuzzy().  * All of the encoding formats somewhat overlap with ascii (BMPString  * and UniversalString are actually always wider so you'll end up  * with a bunch of escaped nul bytes, but ideally we don't get here  * for those).  The result is always a nul-terminated C string. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fuzzy_escape
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|src
operator|->
name|data
operator|+
name|src
operator|->
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|src
operator|->
name|data
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|outstr
decl_stmt|;
name|char
name|escaped_char
index|[
literal|6
index|]
decl_stmt|;
comment|/* ? \ u u u \0 */
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
operator|<
name|end
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|svn_ctype_isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|||
name|svn_ctype_iscntrl
argument_list|(
operator|*
name|q
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|end
condition|)
return|return
name|src
operator|->
name|data
return|;
name|outstr
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
comment|/* Traverse till either unsafe character or eos. */
while|while
condition|(
name|q
operator|<
name|end
operator|&&
name|svn_ctype_isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
operator|!
name|svn_ctype_iscntrl
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|q
operator|++
expr_stmt|;
comment|/* copy chunk before marker */
name|svn_stringbuf_appendbytes
argument_list|(
name|outstr
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|end
condition|)
break|break;
name|apr_snprintf
argument_list|(
name|escaped_char
argument_list|,
sizeof|sizeof
argument_list|(
name|escaped_char
argument_list|)
argument_list|,
literal|"?\\%03u"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|outstr
argument_list|,
name|escaped_char
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|outstr
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Escape only NUL characters from a string that is presumed to  * be UTF-8 encoded and return a nul-terminated C string. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|nul_escape
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|src
operator|->
name|data
operator|+
name|src
operator|->
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|src
operator|->
name|data
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|outstr
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
operator|<
name|end
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|end
condition|)
return|return
name|src
operator|->
name|data
return|;
name|outstr
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
comment|/* Traverse till either unsafe character or eos. */
while|while
condition|(
name|q
operator|<
name|end
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
name|q
operator|++
expr_stmt|;
comment|/* copy chunk before marker */
name|svn_stringbuf_appendbytes
argument_list|(
name|outstr
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|end
condition|)
break|break;
name|svn_stringbuf_appendcstr
argument_list|(
name|outstr
argument_list|,
literal|"?\\000"
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|outstr
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Convert an ISO-8859-1 (Latin-1) string to UTF-8.    ISO-8859-1 is a strict subset of Unicode. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|latin1_to_utf8
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_int32_t
modifier|*
name|ucs4buf
decl_stmt|;
name|svn_membuf_t
name|resultbuf
decl_stmt|;
name|apr_size_t
name|length
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|svn_string_t
modifier|*
name|res
decl_stmt|;
name|ucs4buf
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|src
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ucs4buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|len
condition|;
operator|++
name|i
control|)
name|ucs4buf
index|[
name|i
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|src
operator|->
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|svn_membuf__create
argument_list|(
operator|&
name|resultbuf
argument_list|,
literal|2
operator|*
name|src
operator|->
name|len
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf__encode_ucs4_string
argument_list|(
operator|&
name|resultbuf
argument_list|,
name|ucs4buf
argument_list|,
name|src
operator|->
name|len
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|data
operator|=
name|resultbuf
operator|.
name|data
expr_stmt|;
name|res
operator|->
name|len
operator|=
name|length
expr_stmt|;
operator|*
name|result
operator|=
name|res
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make a best effort to convert a X.509 name to a UTF-8 encoded  * string and return it.  If we can't properly convert just do a  * fuzzy conversion so we have something to display. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|x509name_to_utf8_string
parameter_list|(
specifier|const
name|x509_name
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|src_string
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|utf8_string
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|src_string
operator|=
name|svn_string_ncreate
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
operator|->
name|val
operator|.
name|p
argument_list|,
name|name
operator|->
name|val
operator|.
name|len
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|name
operator|->
name|val
operator|.
name|tag
condition|)
block|{
case|case
name|ASN1_UTF8_STRING
case|:
if|if
condition|(
name|svn_utf__is_valid
argument_list|(
name|src_string
operator|->
name|data
argument_list|,
name|src_string
operator|->
name|len
argument_list|)
condition|)
return|return
name|nul_escape
argument_list|(
name|src_string
argument_list|,
name|result_pool
argument_list|)
return|;
else|else
comment|/* not a valid UTF-8 string, who knows what it is,          * so run it through the fuzzy_escape code.  */
return|return
name|fuzzy_escape
argument_list|(
name|src_string
argument_list|,
name|result_pool
argument_list|)
return|;
break|break;
comment|/* Both BMP and UNIVERSAL should always be in Big Endian (aka        * network byte order).  But rumor has it that there are certs        * out there with other endianess and even Byte Order Marks.        * If we actually run into these, we might need to do something        * about it. */
case|case
name|ASN1_BMP_STRING
case|:
if|if
condition|(
literal|0
operator|!=
name|src_string
operator|->
name|len
operator|%
sizeof|sizeof
argument_list|(
name|apr_uint16_t
argument_list|)
condition|)
return|return
name|fuzzy_escape
argument_list|(
name|src_string
argument_list|,
name|result_pool
argument_list|)
return|;
name|err
operator|=
name|svn_utf__utf16_to_utf8
argument_list|(
operator|&
name|utf8_string
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|src_string
operator|->
name|data
operator|)
argument_list|,
name|src_string
operator|->
name|len
operator|/
sizeof|sizeof
argument_list|(
name|apr_uint16_t
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASN1_UNIVERSAL_STRING
case|:
if|if
condition|(
literal|0
operator|!=
name|src_string
operator|->
name|len
operator|%
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
condition|)
return|return
name|fuzzy_escape
argument_list|(
name|src_string
argument_list|,
name|result_pool
argument_list|)
return|;
name|err
operator|=
name|svn_utf__utf32_to_utf8
argument_list|(
operator|&
name|utf8_string
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|src_string
operator|->
name|data
operator|)
argument_list|,
name|src_string
operator|->
name|len
operator|/
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
break|break;
comment|/* Despite what all the IETF, ISO, ITU bits say everything out        * on the Internet that I can find treats this as ISO-8859-1.        * Even the name is misleading, it's not actually T.61.  All the        * gory details can be found in the Character Sets section of:        * https://www.cs.auckland.ac.nz/~pgut001/pubs/x509guide.txt        */
case|case
name|ASN1_T61_STRING
case|:
name|err
operator|=
name|latin1_to_utf8
argument_list|(
operator|&
name|utf8_string
argument_list|,
name|src_string
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
break|break;
comment|/* This leaves two types out there in the wild.  PrintableString,        * which is just a subset of ASCII and IA5 which is ASCII (though        * 0x24 '$' and 0x23 '#' may be defined with differnet symbols        * depending on the location, in practice it seems everyone just        * treats it as ASCII).  Since these are just ASCII run through        * the fuzzy_escape code to deal with anything that isn't actually        * ASCII.  There shouldn't be any other types here but if we find        * a cert with some other encoding, the best we can do is the        * fuzzy_escape().  Note: Technically IA5 isn't valid in this        * context, however in the real world it may pop up. */
default|default:
return|return
name|fuzzy_escape
argument_list|(
name|src_string
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|fuzzy_escape
argument_list|(
name|src_string
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
return|return
name|nul_escape
argument_list|(
name|utf8_string
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x509_name_to_certinfo
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|x509_name
modifier|*
name|dn
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|x509_name
modifier|*
name|name
init|=
name|dn
decl_stmt|;
operator|*
name|result
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|6
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_x509_name_attr_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|svn_x509_name_attr_t
modifier|*
name|attr
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_x509_name_attr_t
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|oid_len
operator|=
name|name
operator|->
name|oid
operator|.
name|len
expr_stmt|;
name|attr
operator|->
name|oid
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|attr
operator|->
name|oid_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|attr
operator|->
name|oid
argument_list|,
name|name
operator|->
name|oid
operator|.
name|p
argument_list|,
name|attr
operator|->
name|oid_len
argument_list|)
expr_stmt|;
name|attr
operator|->
name|utf8_value
operator|=
name|x509name_to_utf8_string
argument_list|(
name|name
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr
operator|->
name|utf8_value
condition|)
comment|/* this should never happen */
name|attr
operator|->
name|utf8_value
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
literal|"??"
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|result
argument_list|,
specifier|const
name|svn_x509_name_attr_t
operator|*
argument_list|)
operator|=
name|attr
expr_stmt|;
name|name
operator|=
name|name
operator|->
name|next
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_hostname
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|str
index|[
name|i
index|]
decl_stmt|;
comment|/* '-' is only legal when not at the start or end of a label */
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|len
condition|)
block|{
if|if
condition|(
name|str
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
name|FALSE
return|;
comment|/* '-' preceeds a '.' */
block|}
else|else
return|return
name|FALSE
return|;
comment|/* '-' is at end of string */
comment|/* determine the previous character. */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* '-' is at start of string */
elseif|else
if|if
condition|(
name|str
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
name|FALSE
return|;
comment|/* '-' follows a '.' */
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
operator|!
name|svn_ctype_isalnum
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* some character not allowed */
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|x509parse_get_cn
parameter_list|(
name|apr_array_header_t
modifier|*
name|subject
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subject
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_x509_name_attr_t
modifier|*
name|attr
init|=
name|APR_ARRAY_IDX
argument_list|(
name|subject
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_x509_name_attr_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|equal
argument_list|(
name|attr
operator|->
name|oid
argument_list|,
name|attr
operator|->
name|oid_len
argument_list|,
name|SVN_X509_OID_COMMON_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_X509_OID_COMMON_NAME
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|attr
operator|->
name|utf8_value
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|x509parse_get_hostnames
parameter_list|(
name|svn_x509_certinfo_t
modifier|*
name|ci
parameter_list|,
name|x509_cert
modifier|*
name|crt
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|ci
operator|->
name|hostnames
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|crt
operator|->
name|dnsnames
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ci
operator|->
name|hostnames
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|crt
operator|->
name|dnsnames
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Subject Alt Names take priority */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|crt
operator|->
name|dnsnames
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|x509_buf
modifier|*
name|dnsname
init|=
name|APR_ARRAY_IDX
argument_list|(
name|crt
operator|->
name|dnsnames
argument_list|,
name|i
argument_list|,
name|x509_buf
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|temp
init|=
name|svn_string_ncreate
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|dnsname
operator|->
name|p
argument_list|,
name|dnsname
operator|->
name|len
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|ci
operator|->
name|hostnames
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|fuzzy_escape
argument_list|(
name|temp
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* no SAN then get the hostname from the CommonName on the cert */
specifier|const
name|char
modifier|*
name|utf8_value
decl_stmt|;
name|utf8_value
operator|=
name|x509parse_get_cn
argument_list|(
name|ci
operator|->
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|utf8_value
operator|&&
name|is_hostname
argument_list|(
name|utf8_value
argument_list|)
condition|)
block|{
name|ci
operator|->
name|hostnames
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|ci
operator|->
name|hostnames
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|utf8_value
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Parse one certificate.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_x509_parse_cert
parameter_list|(
name|svn_x509_certinfo_t
modifier|*
modifier|*
name|certinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|buflen
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|x509_cert
modifier|*
name|crt
decl_stmt|;
name|svn_x509_certinfo_t
modifier|*
name|ci
decl_stmt|;
name|crt
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|crt
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|len
operator|=
name|buflen
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|len
expr_stmt|;
comment|/*    * Certificate  ::=      SEQUENCE  {    *              tbsCertificate           TBSCertificate,    *              signatureAlgorithm       AlgorithmIdentifier,    *              signatureValue           BIT STRING      }    */
name|err
operator|=
name|asn1_get_tag
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_FORMAT
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|len
operator|!=
operator|(
name|end
operator|-
name|p
operator|)
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_LENGTH_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_FORMAT
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/*    * TBSCertificate  ::=  SEQUENCE  {    */
name|err
operator|=
name|asn1_get_tag
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_FORMAT
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|end
operator|=
name|p
operator|+
name|len
expr_stmt|;
comment|/*    * Version      ::=      INTEGER  {      v1(0), v2(1), v3(2)  }    *    * CertificateSerialNumber      ::=      INTEGER    *    * signature                    AlgorithmIdentifier    */
name|SVN_ERR
argument_list|(
name|x509_get_version
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|crt
operator|->
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|x509_get_serial
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|crt
operator|->
name|serial
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|x509_get_alg
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|crt
operator|->
name|sig_oid1
argument_list|)
argument_list|)
expr_stmt|;
name|crt
operator|->
name|version
operator|++
expr_stmt|;
if|if
condition|(
name|crt
operator|->
name|version
operator|>
literal|3
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_UNKNOWN_VERSION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/*    * issuer                               Name    */
name|err
operator|=
name|asn1_get_tag
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_FORMAT
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|x509_get_name
argument_list|(
operator|&
name|p
argument_list|,
name|p
operator|+
name|len
argument_list|,
operator|&
name|crt
operator|->
name|issuer
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Validity ::= SEQUENCE {    *              notBefore          Time,    *              notAfter           Time }    *    */
name|SVN_ERR
argument_list|(
name|x509_get_dates
argument_list|(
operator|&
name|crt
operator|->
name|valid_from
argument_list|,
operator|&
name|crt
operator|->
name|valid_to
argument_list|,
operator|&
name|p
argument_list|,
name|end
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * subject                              Name    */
name|err
operator|=
name|asn1_get_tag
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_FORMAT
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|x509_get_name
argument_list|(
operator|&
name|p
argument_list|,
name|p
operator|+
name|len
argument_list|,
operator|&
name|crt
operator|->
name|subject
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * SubjectPublicKeyInfo  ::=  SEQUENCE    *              algorithm                        AlgorithmIdentifier,    *              subjectPublicKey         BIT STRING      }    */
name|err
operator|=
name|asn1_get_tag
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|len
argument_list|,
name|ASN1_CONSTRUCTED
operator||
name|ASN1_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_FORMAT
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Skip pubkey. */
name|p
operator|+=
name|len
expr_stmt|;
comment|/*    *      issuerUniqueID  [1]      IMPLICIT UniqueIdentifier OPTIONAL,    *                                               -- If present, version shall be v2 or v3    *      subjectUniqueID [2]      IMPLICIT UniqueIdentifier OPTIONAL,    *                                               -- If present, version shall be v2 or v3    *      extensions              [3]      EXPLICIT Extensions OPTIONAL    *                                               -- If present, version shall be v3    */
name|crt
operator|->
name|dnsnames
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|x509_buf
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to parse issuerUniqueID, subjectUniqueID and extensions for *every*    * version (X.509 v1, v2 and v3), not just v2 or v3.  If they aren't present,    * we are fine, but we don't want to throw an error if they are.  v1 and v2    * certificates with the corresponding extra fields are ill-formed per RFC    * 5280 s. 4.1, but we suspect they could exist in the real world.  Other    * X.509 parsers (e.g., within OpenSSL or Microsoft CryptoAPI) aren't picky    * about these certificates, and we also allow them. */
name|SVN_ERR
argument_list|(
name|x509_get_uid
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|crt
operator|->
name|issuer_id
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|x509_get_uid
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|crt
operator|->
name|subject_id
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|x509_get_ext
argument_list|(
name|crt
operator|->
name|dnsnames
argument_list|,
operator|&
name|p
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_LENGTH_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_FORMAT
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|end
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|+
name|buflen
expr_stmt|;
comment|/*    *      signatureAlgorithm       AlgorithmIdentifier,    *      signatureValue           BIT STRING    */
name|SVN_ERR
argument_list|(
name|x509_get_alg
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|crt
operator|->
name|sig_oid2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oids_equal
argument_list|(
operator|&
name|crt
operator|->
name|sig_oid1
argument_list|,
operator|&
name|crt
operator|->
name|sig_oid2
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_SIG_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|x509_get_sig
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
operator|&
name|crt
operator|->
name|sig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_ASN1_LENGTH_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_X509_CERT_INVALID_FORMAT
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|ci
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ci
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the subject name */
name|SVN_ERR
argument_list|(
name|x509_name_to_certinfo
argument_list|(
operator|&
name|ci
operator|->
name|subject
argument_list|,
operator|&
name|crt
operator|->
name|subject
argument_list|,
name|scratch_pool
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the issuer name */
name|SVN_ERR
argument_list|(
name|x509_name_to_certinfo
argument_list|(
operator|&
name|ci
operator|->
name|issuer
argument_list|,
operator|&
name|crt
operator|->
name|issuer
argument_list|,
name|scratch_pool
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the validity range */
name|ci
operator|->
name|valid_from
operator|=
name|crt
operator|->
name|valid_from
expr_stmt|;
name|ci
operator|->
name|valid_to
operator|=
name|crt
operator|->
name|valid_to
expr_stmt|;
comment|/* Calculate the SHA1 digest of the certificate, otherwise known as     the fingerprint */
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|ci
operator|->
name|digest
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Construct the array of host names */
name|x509parse_get_hostnames
argument_list|(
name|ci
argument_list|,
name|crt
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|certinfo
operator|=
name|ci
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

