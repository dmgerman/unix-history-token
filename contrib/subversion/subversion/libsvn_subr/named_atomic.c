begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svn_named_atomic.c: routines for machine-wide named atomics.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"private/svn_named_atomic.h"
end_include

begin_include
include|#
directive|include
file|<apr_global_mutex.h>
end_include

begin_include
include|#
directive|include
file|<apr_mmap.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mutex.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_comment
comment|/* Implementation aspects.  *  * We use a single shared memory block (memory mapped file) that will be  * created by the first user and merely mapped by all subsequent ones.  * The memory block contains an short header followed by a fixed-capacity  * array of named atomics. The number of entries currently in use is stored  * in the header part.  *  * Finding / creating the MMAP object as well as adding new array entries  * is being guarded by an APR global mutex. Since releasing the MMAP  * structure and closing the underlying does not affect other users of the  * same, cleanup will not be synchronized.  *  * The array is append-only.  Once a process mapped the block into its  * address space, it may freely access any of the used entries.  However,  * it must synchronize access to the volatile data within the entries.  * On Windows and where otherwise supported by GCC, lightweight "lock-free"  * synchronization will be used. Other targets serialize all access using  * a global mutex.  *  * Atomics will be identified by their name (a short string) and lookup  * takes linear time. But even that takes only about 10 microseconds for a  * full array scan -- which is in the same order of magnitude than e.g. a  * single global mutex lock / unlock pair.  */
end_comment

begin_comment
comment|/* Capacity of our shared memory object, i.e. max number of named atomics  * that may be created. Should have the form 2**N - 1.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ATOMIC_COUNT
value|1023
end_define

begin_comment
comment|/* We choose the size of a single named atomic object to fill a complete  * cache line (on most architectures).  Thereby, we minimize the cache  * sync. overhead between different CPU cores.  */
end_comment

begin_define
define|#
directive|define
name|CACHE_LINE_LENGTH
value|64
end_define

begin_comment
comment|/* We need 8 bytes for the actual value and the remainder is used to  * store the NUL-terminated name.  *  * Must not be smaller than SVN_NAMED_ATOMIC__MAX_NAME_LENGTH.  */
end_comment

begin_define
define|#
directive|define
name|MAX_NAME_LENGTH
value|(CACHE_LINE_LENGTH - sizeof(apr_int64_t) - 1)
end_define

begin_comment
comment|/* Particle that will be appended to the namespace name to form the  * name of the mutex / lock file used for that namespace.  */
end_comment

begin_define
define|#
directive|define
name|MUTEX_NAME_SUFFIX
value|".mutex"
end_define

begin_comment
comment|/* Particle that will be appended to the namespace name to form the  * name of the shared memory file that backs that namespace.  */
end_comment

begin_define
define|#
directive|define
name|SHM_NAME_SUFFIX
value|".shm"
end_define

begin_comment
comment|/* Platform-dependent implementations of our basic atomic operations.  * NA_SYNCHRONIZE(op) will ensure that the OP gets executed atomically.  * This will be zero-overhead if OP itself is already atomic.  *  * (We don't call it SYNCHRONIZE because Windows has a preprocess macro by  * that name.)  *  * The default implementation will use the same mutex for initialization  * as well as any type of data access.  This is quite expensive and we  * can do much better on most platforms.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|(
operator|(
name|_WIN32_WINNT
operator|>=
literal|0x0502
operator|)
operator|||
name|defined
argument_list|(
name|InterlockedExchangeAdd64
argument_list|)
operator|)
end_if

begin_comment
comment|/* Interlocked API / intrinsics guarantee full data synchronization  */
end_comment

begin_define
define|#
directive|define
name|synched_read
parameter_list|(
name|mem
parameter_list|)
value|*mem
end_define

begin_define
define|#
directive|define
name|synched_write
parameter_list|(
name|mem
parameter_list|,
name|value
parameter_list|)
value|InterlockedExchange64(mem, value)
end_define

begin_define
define|#
directive|define
name|synched_add
parameter_list|(
name|mem
parameter_list|,
name|delta
parameter_list|)
value|InterlockedExchangeAdd64(mem, delta)
end_define

begin_define
define|#
directive|define
name|synched_cmpxchg
parameter_list|(
name|mem
parameter_list|,
name|value
parameter_list|,
name|comperand
parameter_list|)
define|\
value|InterlockedCompareExchange64(mem, value, comperand)
end_define

begin_define
define|#
directive|define
name|NA_SYNCHRONIZE
parameter_list|(
name|_atomic
parameter_list|,
name|op
parameter_list|)
value|op;
end_define

begin_define
define|#
directive|define
name|NA_SYNCHRONIZE_IS_FAST
value|TRUE
end_define

begin_elif
elif|#
directive|elif
name|SVN_HAS_ATOMIC_BUILTINS
end_elif

begin_comment
comment|/* GCC provides atomic intrinsics for most common CPU types  */
end_comment

begin_define
define|#
directive|define
name|synched_read
parameter_list|(
name|mem
parameter_list|)
value|*mem
end_define

begin_define
define|#
directive|define
name|synched_write
parameter_list|(
name|mem
parameter_list|,
name|value
parameter_list|)
value|__sync_lock_test_and_set(mem, value)
end_define

begin_define
define|#
directive|define
name|synched_add
parameter_list|(
name|mem
parameter_list|,
name|delta
parameter_list|)
value|__sync_add_and_fetch(mem, delta)
end_define

begin_define
define|#
directive|define
name|synched_cmpxchg
parameter_list|(
name|mem
parameter_list|,
name|value
parameter_list|,
name|comperand
parameter_list|)
define|\
value|__sync_val_compare_and_swap(mem, comperand, value)
end_define

begin_define
define|#
directive|define
name|NA_SYNCHRONIZE
parameter_list|(
name|_atomic
parameter_list|,
name|op
parameter_list|)
value|op;
end_define

begin_define
define|#
directive|define
name|NA_SYNCHRONIZE_IS_FAST
value|TRUE
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Default implementation  */
end_comment

begin_function
specifier|static
name|apr_int64_t
name|synched_read
parameter_list|(
specifier|volatile
name|apr_int64_t
modifier|*
name|mem
parameter_list|)
block|{
return|return
operator|*
name|mem
return|;
block|}
end_function

begin_function
specifier|static
name|apr_int64_t
name|synched_write
parameter_list|(
specifier|volatile
name|apr_int64_t
modifier|*
name|mem
parameter_list|,
name|apr_int64_t
name|value
parameter_list|)
block|{
name|apr_int64_t
name|old_value
init|=
operator|*
name|mem
decl_stmt|;
operator|*
name|mem
operator|=
name|value
expr_stmt|;
return|return
name|old_value
return|;
block|}
end_function

begin_function
specifier|static
name|apr_int64_t
name|synched_add
parameter_list|(
specifier|volatile
name|apr_int64_t
modifier|*
name|mem
parameter_list|,
name|apr_int64_t
name|delta
parameter_list|)
block|{
return|return
operator|*
name|mem
operator|+=
name|delta
return|;
block|}
end_function

begin_function
specifier|static
name|apr_int64_t
name|synched_cmpxchg
parameter_list|(
specifier|volatile
name|apr_int64_t
modifier|*
name|mem
parameter_list|,
name|apr_int64_t
name|value
parameter_list|,
name|apr_int64_t
name|comperand
parameter_list|)
block|{
name|apr_int64_t
name|old_value
init|=
operator|*
name|mem
decl_stmt|;
if|if
condition|(
name|old_value
operator|==
name|comperand
condition|)
operator|*
name|mem
operator|=
name|value
expr_stmt|;
return|return
name|old_value
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NA_SYNCHRONIZE
parameter_list|(
name|_atomic
parameter_list|,
name|op
parameter_list|)
define|\
value|do{\   SVN_ERR(lock(_atomic->mutex));\   op;\   SVN_ERR(unlock(_atomic->mutex,SVN_NO_ERROR));\   }while(0)
end_define

begin_define
define|#
directive|define
name|NA_SYNCHRONIZE_IS_FAST
value|FALSE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Structure describing a single atomic: its VALUE and NAME.  */
end_comment

begin_struct
struct|struct
name|named_atomic_data_t
block|{
specifier|volatile
name|apr_int64_t
name|value
decl_stmt|;
name|char
name|name
index|[
name|MAX_NAME_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Content of our shared memory buffer.  COUNT is the number  * of used entries in ATOMICS.  Insertion is append-only.  * PADDING is used to align the header information with the  * atomics to create a favorable data alignment.  */
end_comment

begin_struct
struct|struct
name|shared_data_t
block|{
specifier|volatile
name|apr_uint32_t
name|count
decl_stmt|;
name|char
name|padding
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|named_atomic_data_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|apr_uint32_t
argument_list|)
index|]
decl_stmt|;
name|struct
name|named_atomic_data_t
name|atomics
index|[
name|MAX_ATOMIC_COUNT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure combining all objects that we need for access serialization.  */
end_comment

begin_struct
struct|struct
name|mutex_t
block|{
comment|/* Inter-process sync. is handled by through lock file. */
name|apr_file_t
modifier|*
name|lock_file
decl_stmt|;
comment|/* Pool to be used with lock / unlock functions */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* API structure combining the atomic data and the access mutex  */
end_comment

begin_struct
struct|struct
name|svn_named_atomic__t
block|{
comment|/* pointer into the shared memory */
name|struct
name|named_atomic_data_t
modifier|*
name|data
decl_stmt|;
comment|/* sync. object; never NULL (even if unused) */
name|struct
name|mutex_t
modifier|*
name|mutex
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is intended to be a singleton struct.  It contains all  * information necessary to initialize and access the shared  * memory.  */
end_comment

begin_struct
struct|struct
name|svn_atomic_namespace__t
block|{
comment|/* Pointer to the shared data mapped into our process */
name|struct
name|shared_data_t
modifier|*
name|data
decl_stmt|;
comment|/* Last time we checked, this was the number of used    * (i.e. fully initialized) items.  I.e. we can read    * their names without further sync. */
specifier|volatile
name|svn_atomic_t
name|min_used
decl_stmt|;
comment|/* for each atomic in the shared memory, we hand out    * at most one API-level object. */
name|struct
name|svn_named_atomic__t
name|atomics
index|[
name|MAX_ATOMIC_COUNT
index|]
decl_stmt|;
comment|/* Synchronization object for this namespace */
name|struct
name|mutex_t
name|mutex
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* On most operating systems APR implements file locks per process, not  * per file. I.e. the lock file will only sync. among processes but within  * a process, we must use a mutex to sync the threads. */
end_comment

begin_comment
comment|/* Compare ../libsvn_fs_fs/fs.h:SVN_FS_FS__USE_LOCK_MUTEX */
end_comment

begin_if
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_THREAD_MUTEX
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_THREAD_MUTEX
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used for process-local thread sync.  */
end_comment

begin_decl_stmt
specifier|static
name|svn_mutex__t
modifier|*
name|thread_mutex
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|APR_HAS_MMAP
end_if

begin_comment
comment|/* Initialization flag for the above used by svn_atomic__init_once.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|svn_atomic_t
name|mutex_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the thread sync. structures.  * To be called by svn_atomic__init_once.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_thread_mutex
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* let the mutex live as long as the APR */
name|apr_pool_t
modifier|*
name|global_pool
init|=
name|svn_pool_create
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
return|return
name|svn_mutex__init
argument_list|(
operator|&
name|thread_mutex
argument_list|,
name|USE_THREAD_MUTEX
argument_list|,
name|global_pool
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_MMAP */
end_comment

begin_comment
comment|/* Utility that acquires our global mutex and converts error types.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lock
parameter_list|(
name|struct
name|mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Get lock on the filehandle. */
name|SVN_ERR
argument_list|(
name|svn_mutex__lock
argument_list|(
name|thread_mutex
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_lock_open_file
argument_list|(
name|mutex
operator|->
name|lock_file
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|mutex
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
name|svn_mutex__unlock
argument_list|(
name|thread_mutex
argument_list|,
name|err
argument_list|)
else|:
name|err
return|;
block|}
end_function

begin_comment
comment|/* Utility that releases the lock previously acquired via lock().  If the  * unlock succeeds and OUTER_ERR is not NULL, OUTER_ERR will be returned.  * Otherwise, return the result of the unlock operation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock
parameter_list|(
name|struct
name|mutex_t
modifier|*
name|mutex
parameter_list|,
name|svn_error_t
modifier|*
name|outer_err
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|unlock_err
init|=
name|svn_io_unlock_open_file
argument_list|(
name|mutex
operator|->
name|lock_file
argument_list|,
name|mutex
operator|->
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_mutex__unlock
argument_list|(
name|thread_mutex
argument_list|,
name|svn_error_compose_create
argument_list|(
name|outer_err
argument_list|,
name|unlock_err
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_MMAP
end_if

begin_comment
comment|/* The last user to close a particular namespace should also remove the  * lock file.  Failure to do so, however, does not affect further uses  * of the same namespace.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|delete_lock_file
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mutex_t
modifier|*
name|mutex
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_name
init|=
name|NULL
decl_stmt|;
comment|/* locks have already been cleaned up. Simply close the file */
name|apr_status_t
name|status
init|=
name|apr_file_close
argument_list|(
name|mutex
operator|->
name|lock_file
argument_list|)
decl_stmt|;
comment|/* Remove the file from disk. This will fail if there ares still other    * users of this lock file, i.e. namespace. */
name|apr_file_name_get
argument_list|(
operator|&
name|lock_name
argument_list|,
name|mutex
operator|->
name|lock_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_name
condition|)
name|apr_file_remove
argument_list|(
name|lock_name
argument_list|,
name|mutex
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_MMAP */
end_comment

begin_comment
comment|/* Validate the ATOMIC parameter, i.e it's address.  Correct code will  * never need this but if someone should accidentally to use a NULL or  * incomplete structure, let's catch that here instead of segfaulting.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|validate
parameter_list|(
name|svn_named_atomic__t
modifier|*
name|atomic
parameter_list|)
block|{
return|return
name|atomic
operator|&&
name|atomic
operator|->
name|data
operator|&&
name|atomic
operator|->
name|mutex
condition|?
name|SVN_NO_ERROR
else|:
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_ATOMIC
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Not a valid atomic"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Auto-initialize and return in *ATOMIC the API-level object for the  * atomic with index I within NS. */
end_comment

begin_function
specifier|static
name|void
name|return_atomic
parameter_list|(
name|svn_named_atomic__t
modifier|*
modifier|*
name|atomic
parameter_list|,
name|svn_atomic_namespace__t
modifier|*
name|ns
parameter_list|,
name|int
name|i
parameter_list|)
block|{
operator|*
name|atomic
operator|=
operator|&
name|ns
operator|->
name|atomics
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|atomics
index|[
name|i
index|]
operator|.
name|data
operator|==
name|NULL
condition|)
block|{
operator|(
operator|*
name|atomic
operator|)
operator|->
name|mutex
operator|=
operator|&
name|ns
operator|->
name|mutex
expr_stmt|;
operator|(
operator|*
name|atomic
operator|)
operator|->
name|data
operator|=
operator|&
name|ns
operator|->
name|data
operator|->
name|atomics
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement API */
end_comment

begin_function
name|svn_boolean_t
name|svn_named_atomic__is_supported
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|APR_HAS_MMAP
return|return
name|FALSE
return|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
return|return
name|TRUE
return|;
else|#
directive|else
specifier|static
name|svn_tristate_t
name|result
init|=
name|svn_tristate_unknown
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|svn_tristate_unknown
condition|)
block|{
comment|/* APR SHM implementation requires the creation of global objects */
name|HANDLE
name|handle
init|=
name|CreateFileMappingA
argument_list|(
name|INVALID_HANDLE_VALUE
argument_list|,
name|NULL
argument_list|,
name|PAGE_READONLY
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"Global\\__RandomXZY_svn"
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
name|NULL
condition|)
block|{
name|CloseHandle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|result
operator|=
name|svn_tristate_true
expr_stmt|;
block|}
else|else
name|result
operator|=
name|svn_tristate_false
expr_stmt|;
block|}
return|return
name|result
operator|==
name|svn_tristate_true
return|;
endif|#
directive|endif
comment|/* _WIN32 */
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_named_atomic__is_efficient
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|NA_SYNCHRONIZE_IS_FAST
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_atomic_namespace__create
parameter_list|(
name|svn_atomic_namespace__t
modifier|*
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
if|#
directive|if
operator|!
name|APR_HAS_MMAP
return|return
name|svn_error_create
argument_list|(
name|APR_ENOTIMPL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
else|#
directive|else
name|apr_status_t
name|apr_err
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|apr_mmap_t
modifier|*
name|mmap
decl_stmt|;
specifier|const
name|char
modifier|*
name|shm_name
decl_stmt|,
modifier|*
name|lock_name
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
comment|/* allocate the namespace data structure    */
name|svn_atomic_namespace__t
modifier|*
name|new_ns
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|ns
argument_list|)
argument_list|)
decl_stmt|;
comment|/* construct the names of the system objects that we need    */
name|shm_name
operator|=
name|apr_pstrcat
argument_list|(
name|subpool
argument_list|,
name|name
argument_list|,
name|SHM_NAME_SUFFIX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lock_name
operator|=
name|apr_pstrcat
argument_list|(
name|subpool
argument_list|,
name|name
argument_list|,
name|MUTEX_NAME_SUFFIX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* initialize the lock objects    */
name|SVN_ERR
argument_list|(
name|svn_atomic__init_once
argument_list|(
operator|&
name|mutex_initialized
argument_list|,
name|init_thread_mutex
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_ns
operator|->
name|mutex
operator|.
name|pool
operator|=
name|result_pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|new_ns
operator|->
name|mutex
operator|.
name|lock_file
argument_list|,
name|lock_name
argument_list|,
name|APR_READ
operator||
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the last user of our lock file will actually remove it.    * Please note that only the last file handle begin closed will actually    * remove the underlying file (see docstring for apr_file_remove).    */
name|apr_pool_cleanup_register
argument_list|(
name|result_pool
argument_list|,
operator|&
name|new_ns
operator|->
name|mutex
argument_list|,
name|delete_lock_file
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* Prevent concurrent initialization.    */
name|SVN_ERR
argument_list|(
name|lock
argument_list|(
operator|&
name|new_ns
operator|->
name|mutex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First, make sure that the underlying file exists.  If it doesn't    * exist, create one and initialize its content.    */
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|shm_name
argument_list|,
name|APR_READ
operator||
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|err
operator|=
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|shm_name
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|finfo
operator|.
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|shared_data_t
argument_list|)
condition|)
block|{
comment|/* Zero all counters, values and names.             */
name|struct
name|shared_data_t
name|initial_data
decl_stmt|;
name|memset
argument_list|(
operator|&
name|initial_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|initial_data
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
operator|&
name|initial_data
argument_list|,
sizeof|sizeof
argument_list|(
name|initial_data
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, map it into memory.    */
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|apr_err
operator|=
name|apr_mmap_create
argument_list|(
operator|&
name|mmap
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_ns
operator|->
name|data
argument_list|)
argument_list|,
name|APR_MMAP_READ
operator||
name|APR_MMAP_WRITE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apr_err
condition|)
name|new_ns
operator|->
name|data
operator|=
name|mmap
operator|->
name|mm
expr_stmt|;
else|else
name|err
operator|=
name|svn_error_createf
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"MMAP failed for file '%s'"
argument_list|)
argument_list|,
name|shm_name
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|new_ns
operator|->
name|data
condition|)
block|{
comment|/* Detect severe cases of corruption (i.e. when some outsider messed        * with our data file)        */
if|if
condition|(
name|new_ns
operator|->
name|data
operator|->
name|count
operator|>
name|MAX_ATOMIC_COUNT
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CORRUPTED_ATOMIC_STORAGE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Number of atomics in namespace is too large."
argument_list|)
argument_list|)
return|;
comment|/* Cache the number of existing, complete entries.  There can't be        * incomplete ones from other processes because we hold the mutex.        * Our process will also not access this information since we are        * either being called from within svn_atomic__init_once or by        * svn_atomic_namespace__create for a new object.        */
name|new_ns
operator|->
name|min_used
operator|=
name|new_ns
operator|->
name|data
operator|->
name|count
expr_stmt|;
operator|*
name|ns
operator|=
name|new_ns
expr_stmt|;
block|}
comment|/* Unlock to allow other processes may access the shared memory as well.    */
return|return
name|unlock
argument_list|(
operator|&
name|new_ns
operator|->
name|mutex
argument_list|,
name|err
argument_list|)
return|;
endif|#
directive|endif
comment|/* APR_HAS_MMAP */
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_atomic_namespace__cleanup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|shm_name
decl_stmt|,
modifier|*
name|lock_name
decl_stmt|;
comment|/* file names used for the specified namespace */
name|shm_name
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|name
argument_list|,
name|SHM_NAME_SUFFIX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lock_name
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|name
argument_list|,
name|MUTEX_NAME_SUFFIX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* remove these files if they exist */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|shm_name
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|lock_name
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_named_atomic__get
parameter_list|(
name|svn_named_atomic__t
modifier|*
modifier|*
name|atomic
parameter_list|,
name|svn_atomic_namespace__t
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_boolean_t
name|auto_create
parameter_list|)
block|{
name|apr_uint32_t
name|i
decl_stmt|,
name|count
decl_stmt|;
name|svn_error_t
modifier|*
name|error
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* Check parameters and make sure we return a NULL atomic    * in case of failure.    */
operator|*
name|atomic
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SVN_NAMED_ATOMIC__MAX_NAME_LENGTH
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_ATOMIC
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Atomic's name is too long."
argument_list|)
argument_list|)
return|;
comment|/* If no namespace has been provided, bail out.    */
if|if
condition|(
name|ns
operator|==
name|NULL
operator|||
name|ns
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_ATOMIC
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Namespace has not been initialized."
argument_list|)
argument_list|)
return|;
comment|/* Optimistic lookup.    * Because we never change the name of existing atomics and may only    * append new ones, we can safely compare the name of existing ones    * with the name that we are looking for.    */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
name|svn_atomic_read
argument_list|(
operator|&
name|ns
operator|->
name|min_used
argument_list|)
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|ns
operator|->
name|data
operator|->
name|atomics
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|return_atomic
argument_list|(
name|atomic
argument_list|,
name|ns
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Try harder:    * Serialize all lookup and insert the item, if necessary and allowed.    */
name|SVN_ERR
argument_list|(
name|lock
argument_list|(
operator|&
name|ns
operator|->
name|mutex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We only need to check for new entries.    */
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|<
name|ns
operator|->
name|data
operator|->
name|count
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|ns
operator|->
name|data
operator|->
name|atomics
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|return_atomic
argument_list|(
name|atomic
argument_list|,
name|ns
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Update our cached number of complete entries. */
name|svn_atomic_set
argument_list|(
operator|&
name|ns
operator|->
name|min_used
argument_list|,
name|ns
operator|->
name|data
operator|->
name|count
argument_list|)
expr_stmt|;
return|return
name|unlock
argument_list|(
operator|&
name|ns
operator|->
name|mutex
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* Not found.  Append a new entry, if allowed& possible.    */
if|if
condition|(
name|auto_create
condition|)
block|{
if|if
condition|(
name|ns
operator|->
name|data
operator|->
name|count
operator|<
name|MAX_ATOMIC_COUNT
condition|)
block|{
name|ns
operator|->
name|data
operator|->
name|atomics
index|[
name|ns
operator|->
name|data
operator|->
name|count
index|]
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|ns
operator|->
name|data
operator|->
name|atomics
index|[
name|ns
operator|->
name|data
operator|->
name|count
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|return_atomic
argument_list|(
name|atomic
argument_list|,
name|ns
argument_list|,
name|ns
operator|->
name|data
operator|->
name|count
argument_list|)
expr_stmt|;
operator|++
name|ns
operator|->
name|data
operator|->
name|count
expr_stmt|;
block|}
else|else
name|error
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_ATOMIC
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Out of slots for named atomic."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We are mainly done here.  Let others continue their work.    */
name|SVN_ERR
argument_list|(
name|unlock
argument_list|(
operator|&
name|ns
operator|->
name|mutex
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only now can we be sure that a full memory barrier has been set    * and that the new entry has been written to memory in full.    */
name|svn_atomic_set
argument_list|(
operator|&
name|ns
operator|->
name|min_used
argument_list|,
name|ns
operator|->
name|data
operator|->
name|count
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_named_atomic__read
parameter_list|(
name|apr_int64_t
modifier|*
name|value
parameter_list|,
name|svn_named_atomic__t
modifier|*
name|atomic
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|validate
argument_list|(
name|atomic
argument_list|)
argument_list|)
expr_stmt|;
name|NA_SYNCHRONIZE
argument_list|(
name|atomic
argument_list|,
operator|*
name|value
operator|=
name|synched_read
argument_list|(
operator|&
name|atomic
operator|->
name|data
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_named_atomic__write
parameter_list|(
name|apr_int64_t
modifier|*
name|old_value
parameter_list|,
name|apr_int64_t
name|new_value
parameter_list|,
name|svn_named_atomic__t
modifier|*
name|atomic
parameter_list|)
block|{
name|apr_int64_t
name|temp
decl_stmt|;
name|SVN_ERR
argument_list|(
name|validate
argument_list|(
name|atomic
argument_list|)
argument_list|)
expr_stmt|;
name|NA_SYNCHRONIZE
argument_list|(
name|atomic
argument_list|,
name|temp
operator|=
name|synched_write
argument_list|(
operator|&
name|atomic
operator|->
name|data
operator|->
name|value
argument_list|,
name|new_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_value
condition|)
operator|*
name|old_value
operator|=
name|temp
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_named_atomic__add
parameter_list|(
name|apr_int64_t
modifier|*
name|new_value
parameter_list|,
name|apr_int64_t
name|delta
parameter_list|,
name|svn_named_atomic__t
modifier|*
name|atomic
parameter_list|)
block|{
name|apr_int64_t
name|temp
decl_stmt|;
name|SVN_ERR
argument_list|(
name|validate
argument_list|(
name|atomic
argument_list|)
argument_list|)
expr_stmt|;
name|NA_SYNCHRONIZE
argument_list|(
name|atomic
argument_list|,
name|temp
operator|=
name|synched_add
argument_list|(
operator|&
name|atomic
operator|->
name|data
operator|->
name|value
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_value
condition|)
operator|*
name|new_value
operator|=
name|temp
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_named_atomic__cmpxchg
parameter_list|(
name|apr_int64_t
modifier|*
name|old_value
parameter_list|,
name|apr_int64_t
name|new_value
parameter_list|,
name|apr_int64_t
name|comperand
parameter_list|,
name|svn_named_atomic__t
modifier|*
name|atomic
parameter_list|)
block|{
name|apr_int64_t
name|temp
decl_stmt|;
name|SVN_ERR
argument_list|(
name|validate
argument_list|(
name|atomic
argument_list|)
argument_list|)
expr_stmt|;
name|NA_SYNCHRONIZE
argument_list|(
name|atomic
argument_list|,
name|temp
operator|=
name|synched_cmpxchg
argument_list|(
operator|&
name|atomic
operator|->
name|data
operator|->
name|value
argument_list|,
name|new_value
argument_list|,
name|comperand
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_value
condition|)
operator|*
name|old_value
operator|=
name|temp
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

