begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * stream.c:   svn_stream operations  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_error_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_eol_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_struct
struct|struct
name|svn_stream_t
block|{
name|void
modifier|*
name|baton
decl_stmt|;
name|svn_read_fn_t
name|read_fn
decl_stmt|;
name|svn_stream_skip_fn_t
name|skip_fn
decl_stmt|;
name|svn_write_fn_t
name|write_fn
decl_stmt|;
name|svn_close_fn_t
name|close_fn
decl_stmt|;
name|svn_stream_mark_fn_t
name|mark_fn
decl_stmt|;
name|svn_stream_seek_fn_t
name|seek_fn
decl_stmt|;
name|svn_stream__is_buffered_fn_t
name|is_buffered_fn
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* Maybe NULL */
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/*** Forward declarations. ***/
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|skip_default_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_read_fn_t
name|read_fn
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*** Generic streams. ***/
end_comment

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_create
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|stream
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
name|stream
operator|->
name|read_fn
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|skip_fn
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|write_fn
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|close_fn
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|mark_fn
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|seek_fn
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|is_buffered_fn
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_baton
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|stream
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_read
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_read_fn_t
name|read_fn
parameter_list|)
block|{
name|stream
operator|->
name|read_fn
operator|=
name|read_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_skip
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_skip_fn_t
name|skip_fn
parameter_list|)
block|{
name|stream
operator|->
name|skip_fn
operator|=
name|skip_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_write
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_write_fn_t
name|write_fn
parameter_list|)
block|{
name|stream
operator|->
name|write_fn
operator|=
name|write_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_close
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_close_fn_t
name|close_fn
parameter_list|)
block|{
name|stream
operator|->
name|close_fn
operator|=
name|close_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_mark
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_mark_fn_t
name|mark_fn
parameter_list|)
block|{
name|stream
operator|->
name|mark_fn
operator|=
name|mark_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_seek
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_seek_fn_t
name|seek_fn
parameter_list|)
block|{
name|stream
operator|->
name|seek_fn
operator|=
name|seek_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream__set_is_buffered
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream__is_buffered_fn_t
name|is_buffered_fn
parameter_list|)
block|{
name|stream
operator|->
name|is_buffered_fn
operator|=
name|is_buffered_fn
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_read
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|stream
operator|->
name|read_fn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|read_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_skip
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|skip_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|skip_default_handler
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|len
argument_list|,
name|stream
operator|->
name|read_fn
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|skip_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_write
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|stream
operator|->
name|write_fn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|write_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_reset
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_seek
argument_list|(
name|stream
argument_list|,
name|NULL
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_stream_supports_mark
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|stream
operator|->
name|mark_fn
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_mark
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|mark_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_SEEK_NOT_SUPPORTED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|mark_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|mark
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_seek
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|seek_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_SEEK_NOT_SUPPORTED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|seek_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|mark
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_stream__is_buffered
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|is_buffered_fn
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|stream
operator|->
name|is_buffered_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_close
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|close_fn
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|close_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_puts
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|apr_size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|str
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_printf
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
name|message
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_printf_from_utf8
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|,
modifier|*
name|translated
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
name|translated
argument_list|,
name|message
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
name|translated
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Size that 90% of the lines we encounter will be not longer than.    used by stream_readline_bytewise() and stream_readline_chunky().  */
end_comment

begin_define
define|#
directive|define
name|LINE_CHUNK_SIZE
value|80
end_define

begin_comment
comment|/* Guts of svn_stream_readline().  * Returns the line read from STREAM in *STRINGBUF, and indicates  * end-of-file in *EOF.  If DETECT_EOL is TRUE, the end-of-line indicator  * is detected automatically and returned in *EOL.  * If DETECT_EOL is FALSE, *EOL must point to the desired end-of-line  * indicator.  STRINGBUF is allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_readline_bytewise
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|str
decl_stmt|;
name|apr_size_t
name|numbytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|match
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Since we're reading one character at a time, let's at least      optimize for the 90% case.  90% of the time, we can avoid the      stringbuf ever having to realloc() itself if we start it out at      80 chars.  */
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|LINE_CHUNK_SIZE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Read into STR up to and including the next EOL sequence. */
name|match
operator|=
name|eol
expr_stmt|;
while|while
condition|(
operator|*
name|match
condition|)
block|{
name|numbytes
operator|=
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|numbytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbytes
operator|!=
literal|1
condition|)
block|{
comment|/* a 'short' read means the stream has run out. */
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
operator|*
name|stringbuf
operator|=
name|str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|match
condition|)
name|match
operator|++
expr_stmt|;
else|else
name|match
operator|=
name|eol
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|eof
operator|=
name|FALSE
expr_stmt|;
name|svn_stringbuf_chop
argument_list|(
name|str
argument_list|,
name|match
operator|-
name|eol
argument_list|)
expr_stmt|;
operator|*
name|stringbuf
operator|=
name|str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_readline_chunky
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Read larger chunks of data at once into this buffer and scan    * that for EOL. A good chunk size should be about 80 chars since    * most text lines will be shorter. However, don't use a much    * larger value because filling the buffer from the stream takes    * time as well.    */
name|char
name|buffer
index|[
name|LINE_CHUNK_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* variables */
name|svn_stream_mark_t
modifier|*
name|mark
decl_stmt|;
name|apr_size_t
name|numbytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_pos
decl_stmt|;
name|apr_size_t
name|total_parsed
init|=
literal|0
decl_stmt|;
comment|/* invariant for this call */
specifier|const
name|size_t
name|eol_len
init|=
name|strlen
argument_list|(
name|eol
argument_list|)
decl_stmt|;
comment|/* Remember the line start so this plus the line length will be    * the position to move to at the end of this function.    */
name|SVN_ERR
argument_list|(
name|svn_stream_mark
argument_list|(
name|stream
argument_list|,
operator|&
name|mark
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the first chunk. */
name|numbytes
operator|=
name|LINE_CHUNK_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|numbytes
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
index|[
name|numbytes
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look for the EOL in this first chunk. If we find it, we are done here.    */
name|eol_pos
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
name|eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_pos
operator|!=
name|NULL
condition|)
block|{
operator|*
name|stringbuf
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|buffer
argument_list|,
name|eol_pos
operator|-
name|buffer
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|total_parsed
operator|=
name|eol_pos
operator|-
name|buffer
operator|+
name|eol_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numbytes
operator|<
name|LINE_CHUNK_SIZE
condition|)
block|{
comment|/* We hit EOF but not EOL.        */
operator|*
name|stringbuf
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|buffer
argument_list|,
name|numbytes
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* A larger buffer for the string is needed. */
name|svn_stringbuf_t
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|2
operator|*
name|LINE_CHUNK_SIZE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|buffer
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
operator|*
name|stringbuf
operator|=
name|str
expr_stmt|;
comment|/* Loop reading chunks until an EOL was found. If we hit EOF, fall        * back to the standard implementation. */
do|do
block|{
comment|/* Append the next chunk to the string read so far.          */
name|svn_stringbuf_ensure
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|len
operator|+
name|LINE_CHUNK_SIZE
argument_list|)
expr_stmt|;
name|numbytes
operator|=
name|LINE_CHUNK_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
name|str
operator|->
name|data
operator|+
name|str
operator|->
name|len
argument_list|,
operator|&
name|numbytes
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|->
name|len
operator|+=
name|numbytes
expr_stmt|;
name|str
operator|->
name|data
index|[
name|str
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look for the EOL in the new data plus the last part of the          * previous chunk because the EOL may span over the boundary          * between both chunks.          */
name|eol_pos
operator|=
name|strstr
argument_list|(
name|str
operator|->
name|data
operator|+
name|str
operator|->
name|len
operator|-
name|numbytes
operator|-
operator|(
name|eol_len
operator|-
literal|1
operator|)
argument_list|,
name|eol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numbytes
operator|<
name|LINE_CHUNK_SIZE
operator|)
operator|&&
operator|(
name|eol_pos
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* We hit EOF instead of EOL. */
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
do|while
condition|(
name|eol_pos
operator|==
name|NULL
condition|)
do|;
comment|/* Number of bytes we actually consumed (i.e. line + EOF).        * We need to "return" the rest to the stream by moving its        * read pointer.        */
name|total_parsed
operator|=
name|eol_pos
operator|-
name|str
operator|->
name|data
operator|+
name|eol_len
expr_stmt|;
comment|/* Terminate the string at the EOL postion and return it. */
name|str
operator|->
name|len
operator|=
name|eol_pos
operator|-
name|str
operator|->
name|data
expr_stmt|;
name|str
operator|->
name|data
index|[
name|str
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Move the stream read pointer to the first position behind the EOL.    */
name|SVN_ERR
argument_list|(
name|svn_stream_seek
argument_list|(
name|stream
argument_list|,
name|mark
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_skip
argument_list|(
name|stream
argument_list|,
name|total_parsed
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Guts of svn_stream_readline().  * Returns the line read from STREAM in *STRINGBUF, and indicates  * end-of-file in *EOF.  EOL must point to the desired end-of-line  * indicator.  STRINGBUF is allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_readline
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|eof
operator|=
name|FALSE
expr_stmt|;
comment|/* Often, we operate on APR file or string-based streams and know what    * EOL we are looking for. Optimize that common case.    */
if|if
condition|(
name|svn_stream_supports_mark
argument_list|(
name|stream
argument_list|)
operator|&&
name|svn_stream__is_buffered
argument_list|(
name|stream
argument_list|)
condition|)
block|{
comment|/* We can efficiently read chunks speculatively and reposition the        * stream pointer to the end of the line once we found that.        */
name|SVN_ERR
argument_list|(
name|stream_readline_chunky
argument_list|(
name|stringbuf
argument_list|,
name|eof
argument_list|,
name|eol
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the standard byte-byte implementation.        */
name|SVN_ERR
argument_list|(
name|stream_readline_bytewise
argument_list|(
name|stringbuf
argument_list|,
name|eof
argument_list|,
name|eol
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_readline
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|stream_readline
argument_list|(
name|stringbuf
argument_list|,
name|eof
argument_list|,
name|eol
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_copy3
parameter_list|(
name|svn_stream_t
modifier|*
name|from
parameter_list|,
name|svn_stream_t
modifier|*
name|to
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
comment|/* Read and write chunks until we get a short read, indicating the      end of the stream.  (We can't get a short write without an      associated error.) */
while|while
condition|(
literal|1
condition|)
block|{
name|apr_size_t
name|len
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
block|{
name|err
operator|=
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|err
operator|=
name|svn_stream_read
argument_list|(
name|from
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|err
operator|=
name|svn_stream_write
argument_list|(
name|to
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|(
name|len
operator|!=
name|SVN__STREAM_CHUNK_SIZE
operator|)
condition|)
break|break;
block|}
name|err2
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_stream_close
argument_list|(
name|from
argument_list|)
argument_list|,
name|svn_stream_close
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_contents_same2
parameter_list|(
name|svn_boolean_t
modifier|*
name|same
parameter_list|,
name|svn_stream_t
modifier|*
name|stream1
parameter_list|,
name|svn_stream_t
modifier|*
name|stream2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|buf1
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|apr_size_t
name|bytes_read1
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|apr_size_t
name|bytes_read2
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
operator|*
name|same
operator|=
name|TRUE
expr_stmt|;
comment|/* assume TRUE, until disproved below */
while|while
condition|(
name|bytes_read1
operator|==
name|SVN__STREAM_CHUNK_SIZE
operator|&&
name|bytes_read2
operator|==
name|SVN__STREAM_CHUNK_SIZE
condition|)
block|{
name|err
operator|=
name|svn_stream_read
argument_list|(
name|stream1
argument_list|,
name|buf1
argument_list|,
operator|&
name|bytes_read1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|err
operator|=
name|svn_stream_read
argument_list|(
name|stream2
argument_list|,
name|buf2
argument_list|,
operator|&
name|bytes_read2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
operator|(
name|bytes_read1
operator|!=
name|bytes_read2
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
name|bytes_read1
argument_list|)
operator|)
condition|)
block|{
operator|*
name|same
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_error_compose_create
argument_list|(
name|svn_stream_close
argument_list|(
name|stream1
argument_list|)
argument_list|,
name|svn_stream_close
argument_list|(
name|stream2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Stream implementation utilities ***/
end_comment

begin_comment
comment|/* Skip data from any stream by reading and simply discarding it. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_default_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_read_fn_t
name|read_fn
parameter_list|)
block|{
name|apr_size_t
name|bytes_read
init|=
literal|1
decl_stmt|;
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|apr_size_t
name|to_read
init|=
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|to_read
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bytes_read
operator|>
literal|0
operator|)
condition|)
block|{
name|bytes_read
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|<
name|to_read
condition|?
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
else|:
name|to_read
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_fn
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
operator|&
name|bytes_read
argument_list|)
argument_list|)
expr_stmt|;
name|to_read
operator|-=
name|bytes_read
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Generic readable empty stream ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|mark
operator|=
name|NULL
expr_stmt|;
comment|/* Seek to start of stream marker */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_empty
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|stream
argument_list|,
name|read_handler_empty
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_empty
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_empty
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_empty
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_handler_empty
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Stream duplication support ***/
end_comment

begin_struct
struct|struct
name|baton_tee
block|{
name|svn_stream_t
modifier|*
name|out1
decl_stmt|;
name|svn_stream_t
modifier|*
name|out2
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_tee
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|baton_tee
modifier|*
name|bt
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|bt
operator|->
name|out1
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|bt
operator|->
name|out2
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_tee
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|baton_tee
modifier|*
name|bt
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|bt
operator|->
name|out1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|bt
operator|->
name|out2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_tee
parameter_list|(
name|svn_stream_t
modifier|*
name|out1
parameter_list|,
name|svn_stream_t
modifier|*
name|out2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|baton_tee
modifier|*
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
name|out1
operator|==
name|NULL
condition|)
return|return
name|out2
return|;
if|if
condition|(
name|out2
operator|==
name|NULL
condition|)
return|return
name|out1
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|out1
operator|=
name|out1
expr_stmt|;
name|baton
operator|->
name|out2
operator|=
name|out2
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_tee
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|close_handler_tee
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Ownership detaching stream ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_read
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_skip
argument_list|(
name|baton
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_write
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_mark
argument_list|(
name|baton
argument_list|,
name|mark
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_seek
argument_list|(
name|baton
argument_list|,
name|mark
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|svn_stream__is_buffered
argument_list|(
name|baton
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_disown
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|s
init|=
name|svn_stream_create
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_stream_set_read
argument_list|(
name|s
argument_list|,
name|read_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|s
argument_list|,
name|skip_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|s
argument_list|,
name|write_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|s
argument_list|,
name|mark_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|s
argument_list|,
name|seek_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|s
argument_list|,
name|is_buffered_handler_disown
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Generic stream for APR files ***/
end_comment

begin_struct
struct|struct
name|baton_apr
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* svn_stream_mark_t for streams backed by APR files. */
end_comment

begin_struct
struct|struct
name|mark_apr
block|{
name|apr_off_t
name|off
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
if|if
condition|(
operator|*
name|len
operator|==
literal|1
condition|)
block|{
name|err
operator|=
name|svn_io_file_getc
argument_list|(
name|buffer
argument_list|,
name|btn
operator|->
name|file
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
block|}
block|}
else|else
name|err
operator|=
name|svn_io_file_read_full2
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
operator|*
name|len
argument_list|,
name|len
argument_list|,
operator|&
name|eof
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_off_t
name|offset
init|=
name|len
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_seek
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|*
name|len
operator|==
literal|1
condition|)
block|{
name|err
operator|=
name|svn_io_file_putc
argument_list|(
operator|*
name|data
argument_list|,
name|btn
operator|->
name|file
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
operator|*
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|err
operator|=
name|svn_io_file_write_full
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|,
name|len
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_close
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|struct
name|mark_apr
modifier|*
name|mark_apr
decl_stmt|;
name|mark_apr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mark_apr
argument_list|)
argument_list|)
expr_stmt|;
name|mark_apr
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|mark_apr
operator|->
name|off
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mark
operator|=
operator|(
name|svn_stream_mark_t
operator|*
operator|)
name|mark_apr
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_off_t
name|offset
init|=
operator|(
name|mark
operator|!=
name|NULL
operator|)
condition|?
operator|(
operator|(
specifier|const
expr|struct
name|mark_apr
operator|*
operator|)
name|mark
operator|)
operator|->
name|off
else|:
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
return|return
operator|(
name|apr_file_flags_get
argument_list|(
name|btn
operator|->
name|file
argument_list|)
operator|&
name|APR_BUFFERED
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_open_readonly
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_open_writable
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path
argument_list|,
name|APR_WRITE
operator||
name|APR_BUFFERED
operator||
name|APR_CREATE
operator||
name|APR_EXCL
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_open_unique
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|temp_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dirpath
parameter_list|,
name|svn_io_file_del_t
name|delete_when
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|file
argument_list|,
name|temp_path
argument_list|,
name|dirpath
argument_list|,
name|delete_when
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_from_aprfile2
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_boolean_t
name|disown
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|stream
argument_list|,
name|read_handler_apr
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_apr
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|stream
argument_list|,
name|skip_handler_apr
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_apr
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_apr
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_handler_apr
argument_list|)
expr_stmt|;
name|stream
operator|->
name|file
operator|=
name|file
expr_stmt|;
if|if
condition|(
operator|!
name|disown
condition|)
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|close_handler_apr
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|apr_file_t
modifier|*
name|svn_stream__aprfile
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|stream
operator|->
name|file
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compressed stream support */
end_comment

begin_define
define|#
directive|define
name|ZBUFFER_SIZE
value|4096
end_define

begin_comment
comment|/* The size of the buffer the                                    compressed stream uses to read from                                    the substream. Basically an                                    arbitrary value, picked to be about                                    page-sized. */
end_comment

begin_struct
struct|struct
name|zbaton
block|{
name|z_stream
modifier|*
name|in
decl_stmt|;
comment|/* compressed stream for reading */
name|z_stream
modifier|*
name|out
decl_stmt|;
comment|/* compressed stream for writing */
name|svn_read_fn_t
name|read
decl_stmt|;
comment|/* substream's read function */
name|svn_write_fn_t
name|write
decl_stmt|;
comment|/* substream's write function */
name|svn_close_fn_t
name|close
decl_stmt|;
comment|/* substream's close function */
name|void
modifier|*
name|read_buffer
decl_stmt|;
comment|/* buffer   used   for  reading   from                                    substream */
name|int
name|read_flush
decl_stmt|;
comment|/* what flush mode to use while                                    reading */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The pool this baton is allocated                                    on */
name|void
modifier|*
name|subbaton
decl_stmt|;
comment|/* The substream's baton */
block|}
struct|;
end_struct

begin_comment
comment|/* zlib alloc function. opaque is the pool we need. */
end_comment

begin_function
specifier|static
name|voidpf
name|zalloc
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|uInt
name|items
parameter_list|,
name|uInt
name|size
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|opaque
decl_stmt|;
return|return
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|items
operator|*
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* zlib free function */
end_comment

begin_function
specifier|static
name|void
name|zfree
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|voidpf
name|address
parameter_list|)
block|{
comment|/* Empty, since we allocate on the pool */
block|}
end_function

begin_comment
comment|/* Helper function to figure out the sync mode */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_helper_gz
parameter_list|(
name|svn_read_fn_t
name|read_fn
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|uInt
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|zflush
parameter_list|)
block|{
name|uInt
name|orig_len
init|=
operator|*
name|len
decl_stmt|;
comment|/* There's no reason this value should grow bigger than the range of      uInt, but Subversion's API requires apr_size_t. */
name|apr_size_t
name|apr_len
init|=
operator|(
name|apr_size_t
operator|)
operator|*
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|read_fn
call|)
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
operator|&
name|apr_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Type cast back to uInt type that zlib uses.  On LP64 platforms      apr_size_t will be bigger than uInt. */
operator|*
name|len
operator|=
operator|(
name|uInt
operator|)
name|apr_len
expr_stmt|;
comment|/* I wanted to use Z_FINISH here, but we need to know our buffer is      big enough */
operator|*
name|zflush
operator|=
operator|(
operator|*
name|len
operator|)
operator|<
name|orig_len
condition|?
name|Z_SYNC_FLUSH
else|:
name|Z_SYNC_FLUSH
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handle reading from a compressed stream */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_gz
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|zbaton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|int
name|zerr
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|in
operator|==
name|NULL
condition|)
block|{
name|btn
operator|->
name|in
operator|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|zalloc
operator|=
name|zalloc
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|zfree
operator|=
name|zfree
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|opaque
operator|=
name|btn
operator|->
name|pool
expr_stmt|;
name|btn
operator|->
name|read_buffer
operator|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
name|ZBUFFER_SIZE
argument_list|)
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|next_in
operator|=
name|btn
operator|->
name|read_buffer
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|avail_in
operator|=
name|ZBUFFER_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_helper_gz
argument_list|(
name|btn
operator|->
name|read
argument_list|,
name|btn
operator|->
name|subbaton
argument_list|,
name|btn
operator|->
name|read_buffer
argument_list|,
operator|&
name|btn
operator|->
name|in
operator|->
name|avail_in
argument_list|,
operator|&
name|btn
operator|->
name|read_flush
argument_list|)
argument_list|)
expr_stmt|;
name|zerr
operator|=
name|inflateInit
argument_list|(
name|btn
operator|->
name|in
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"inflateInit"
argument_list|,
name|btn
operator|->
name|in
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|btn
operator|->
name|in
operator|->
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|buffer
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|avail_out
operator|=
operator|(
name|uInt
operator|)
operator|*
name|len
expr_stmt|;
while|while
condition|(
name|btn
operator|->
name|in
operator|->
name|avail_out
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|btn
operator|->
name|in
operator|->
name|avail_in
operator|<=
literal|0
condition|)
block|{
name|btn
operator|->
name|in
operator|->
name|avail_in
operator|=
name|ZBUFFER_SIZE
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|next_in
operator|=
name|btn
operator|->
name|read_buffer
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_helper_gz
argument_list|(
name|btn
operator|->
name|read
argument_list|,
name|btn
operator|->
name|subbaton
argument_list|,
name|btn
operator|->
name|read_buffer
argument_list|,
operator|&
name|btn
operator|->
name|in
operator|->
name|avail_in
argument_list|,
operator|&
name|btn
operator|->
name|read_flush
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Short read means underlying stream has run out. */
if|if
condition|(
name|btn
operator|->
name|in
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|zerr
operator|=
name|inflate
argument_list|(
name|btn
operator|->
name|in
argument_list|,
name|btn
operator|->
name|read_flush
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerr
operator|==
name|Z_STREAM_END
condition|)
break|break;
elseif|else
if|if
condition|(
name|zerr
operator|!=
name|Z_OK
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"inflate"
argument_list|,
name|btn
operator|->
name|in
operator|->
name|msg
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|len
operator|-=
name|btn
operator|->
name|in
operator|->
name|avail_out
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compress data and write it to the substream */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_gz
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|zbaton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|void
modifier|*
name|write_buf
decl_stmt|;
name|apr_size_t
name|buf_size
decl_stmt|,
name|write_len
decl_stmt|;
name|int
name|zerr
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|out
operator|==
name|NULL
condition|)
block|{
name|btn
operator|->
name|out
operator|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|zalloc
operator|=
name|zalloc
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|zfree
operator|=
name|zfree
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|opaque
operator|=
name|btn
operator|->
name|pool
expr_stmt|;
name|zerr
operator|=
name|deflateInit
argument_list|(
name|btn
operator|->
name|out
argument_list|,
name|Z_DEFAULT_COMPRESSION
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"deflateInit"
argument_list|,
name|btn
operator|->
name|out
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The largest buffer we should need is 0.1% larger than the      compressed data, + 12 bytes. This info comes from zlib.h.  */
name|buf_size
operator|=
operator|*
name|len
operator|+
operator|(
operator|*
name|len
operator|/
literal|1000
operator|)
operator|+
literal|13
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
name|write_buf
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|buffer
expr_stmt|;
comment|/* Casting away const! */
name|btn
operator|->
name|out
operator|->
name|avail_in
operator|=
operator|(
name|uInt
operator|)
operator|*
name|len
expr_stmt|;
while|while
condition|(
name|btn
operator|->
name|out
operator|->
name|avail_in
operator|>
literal|0
condition|)
block|{
name|btn
operator|->
name|out
operator|->
name|next_out
operator|=
name|write_buf
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|buf_size
expr_stmt|;
name|zerr
operator|=
name|deflate
argument_list|(
name|btn
operator|->
name|out
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"deflate"
argument_list|,
name|btn
operator|->
name|out
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|write_len
operator|=
name|buf_size
operator|-
name|btn
operator|->
name|out
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|write_len
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|btn
operator|->
name|write
argument_list|(
name|btn
operator|->
name|subbaton
argument_list|,
name|write_buf
argument_list|,
operator|&
name|write_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handle flushing and closing the stream */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_gz
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|zbaton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|int
name|zerr
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|in
operator|!=
name|NULL
condition|)
block|{
name|zerr
operator|=
name|inflateEnd
argument_list|(
name|btn
operator|->
name|in
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"inflateEnd"
argument_list|,
name|btn
operator|->
name|in
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|btn
operator|->
name|out
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|apr_size_t
name|write_len
decl_stmt|;
name|buf
operator|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
name|ZBUFFER_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|btn
operator|->
name|out
operator|->
name|next_out
operator|=
name|buf
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|avail_out
operator|=
name|ZBUFFER_SIZE
expr_stmt|;
name|zerr
operator|=
name|deflate
argument_list|(
name|btn
operator|->
name|out
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerr
operator|!=
name|Z_STREAM_END
operator|&&
name|zerr
operator|!=
name|Z_OK
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"deflate"
argument_list|,
name|btn
operator|->
name|out
operator|->
name|msg
argument_list|)
argument_list|)
return|;
name|write_len
operator|=
name|ZBUFFER_SIZE
operator|-
name|btn
operator|->
name|out
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|write_len
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|btn
operator|->
name|write
argument_list|(
name|btn
operator|->
name|subbaton
argument_list|,
name|buf
argument_list|,
operator|&
name|write_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerr
operator|==
name|Z_STREAM_END
condition|)
break|break;
block|}
name|zerr
operator|=
name|deflateEnd
argument_list|(
name|btn
operator|->
name|out
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"deflateEnd"
argument_list|,
name|btn
operator|->
name|out
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|btn
operator|->
name|close
operator|!=
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|btn
operator|->
name|close
argument_list|(
name|btn
operator|->
name|subbaton
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_compressed
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svn_stream_t
modifier|*
name|zstream
decl_stmt|;
name|struct
name|zbaton
modifier|*
name|baton
decl_stmt|;
name|assert
argument_list|(
name|stream
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|in
operator|=
name|baton
operator|->
name|out
operator|=
name|NULL
expr_stmt|;
name|baton
operator|->
name|read
operator|=
name|stream
operator|->
name|read_fn
expr_stmt|;
name|baton
operator|->
name|write
operator|=
name|stream
operator|->
name|write_fn
expr_stmt|;
name|baton
operator|->
name|close
operator|=
name|stream
operator|->
name|close_fn
expr_stmt|;
name|baton
operator|->
name|subbaton
operator|=
name|stream
operator|->
name|baton
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|baton
operator|->
name|read_buffer
operator|=
name|NULL
expr_stmt|;
name|baton
operator|->
name|read_flush
operator|=
name|Z_SYNC_FLUSH
expr_stmt|;
name|zstream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|zstream
argument_list|,
name|read_handler_gz
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|zstream
argument_list|,
name|write_handler_gz
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|zstream
argument_list|,
name|close_handler_gz
argument_list|)
expr_stmt|;
return|return
name|zstream
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Checksummed stream support */
end_comment

begin_struct
struct|struct
name|checksum_stream_baton
block|{
name|svn_checksum_ctx_t
modifier|*
name|read_ctx
decl_stmt|,
modifier|*
name|write_ctx
decl_stmt|;
name|svn_checksum_t
modifier|*
modifier|*
name|read_checksum
decl_stmt|;
comment|/* Output value. */
name|svn_checksum_t
modifier|*
modifier|*
name|write_checksum
decl_stmt|;
comment|/* Output value. */
name|svn_stream_t
modifier|*
name|proxy
decl_stmt|;
comment|/* True if more data should be read when closing the stream. */
name|svn_boolean_t
name|read_more
decl_stmt|;
comment|/* Pool to allocate read buffer and output values from. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_checksum
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|checksum_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|saved_len
init|=
operator|*
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|btn
operator|->
name|proxy
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|btn
operator|->
name|read_checksum
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|btn
operator|->
name|read_ctx
argument_list|,
name|buffer
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_len
operator|!=
operator|*
name|len
condition|)
name|btn
operator|->
name|read_more
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_checksum
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|checksum_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|write_checksum
operator|&&
operator|*
name|len
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|btn
operator|->
name|write_ctx
argument_list|,
name|buffer
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_write
argument_list|(
name|btn
operator|->
name|proxy
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_checksum
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|checksum_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
comment|/* If we're supposed to drain the stream, do so before finalizing the      checksum. */
if|if
condition|(
name|btn
operator|->
name|read_more
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|apr_size_t
name|len
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
do|do
block|{
name|SVN_ERR
argument_list|(
name|read_handler_checksum
argument_list|(
name|baton
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|btn
operator|->
name|read_more
condition|)
do|;
block|}
if|if
condition|(
name|btn
operator|->
name|read_ctx
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
name|btn
operator|->
name|read_checksum
argument_list|,
name|btn
operator|->
name|read_ctx
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|btn
operator|->
name|write_ctx
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
name|btn
operator|->
name|write_checksum
argument_list|,
name|btn
operator|->
name|write_ctx
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_close
argument_list|(
name|btn
operator|->
name|proxy
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_checksummed2
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|read_checksum
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|write_checksum
parameter_list|,
name|svn_checksum_kind_t
name|checksum_kind
parameter_list|,
name|svn_boolean_t
name|read_all
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|struct
name|checksum_stream_baton
modifier|*
name|baton
decl_stmt|;
if|if
condition|(
name|read_checksum
operator|==
name|NULL
operator|&&
name|write_checksum
operator|==
name|NULL
condition|)
return|return
name|stream
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_checksum
condition|)
name|baton
operator|->
name|read_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|checksum_kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|baton
operator|->
name|read_ctx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|write_checksum
condition|)
name|baton
operator|->
name|write_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|checksum_kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|baton
operator|->
name|write_ctx
operator|=
name|NULL
expr_stmt|;
name|baton
operator|->
name|read_checksum
operator|=
name|read_checksum
expr_stmt|;
name|baton
operator|->
name|write_checksum
operator|=
name|write_checksum
expr_stmt|;
name|baton
operator|->
name|proxy
operator|=
name|stream
expr_stmt|;
name|baton
operator|->
name|read_more
operator|=
name|read_all
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|s
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|s
argument_list|,
name|read_handler_checksum
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|s
argument_list|,
name|write_handler_checksum
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|s
argument_list|,
name|close_handler_checksum
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_struct
struct|struct
name|md5_stream_baton
block|{
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|read_digest
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|write_digest
decl_stmt|;
name|svn_checksum_t
modifier|*
name|read_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|write_checksum
decl_stmt|;
name|svn_stream_t
modifier|*
name|proxy
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_md5
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|md5_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_read
argument_list|(
name|btn
operator|->
name|proxy
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_md5
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|struct
name|md5_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_skip
argument_list|(
name|btn
operator|->
name|proxy
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_md5
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|md5_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_write
argument_list|(
name|btn
operator|->
name|proxy
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_md5
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|md5_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|btn
operator|->
name|proxy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|btn
operator|->
name|read_digest
condition|)
operator|*
name|btn
operator|->
name|read_digest
operator|=
name|apr_pmemdup
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
name|btn
operator|->
name|read_checksum
operator|->
name|digest
argument_list|,
name|APR_MD5_DIGESTSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|btn
operator|->
name|write_digest
condition|)
operator|*
name|btn
operator|->
name|write_digest
operator|=
name|apr_pmemdup
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
name|btn
operator|->
name|write_checksum
operator|->
name|digest
argument_list|,
name|APR_MD5_DIGESTSIZE
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_checksummed
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|read_digest
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|write_digest
parameter_list|,
name|svn_boolean_t
name|read_all
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|struct
name|md5_stream_baton
modifier|*
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|read_digest
operator|&&
operator|!
name|write_digest
condition|)
return|return
name|stream
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|read_digest
operator|=
name|read_digest
expr_stmt|;
name|baton
operator|->
name|write_digest
operator|=
name|write_digest
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Set BATON->proxy to a stream that will fill in BATON->read_checksum    * and BATON->write_checksum (if we want them) when it is closed. */
name|baton
operator|->
name|proxy
operator|=
name|svn_stream_checksummed2
argument_list|(
name|stream
argument_list|,
name|read_digest
condition|?
operator|&
name|baton
operator|->
name|read_checksum
else|:
name|NULL
argument_list|,
name|write_digest
condition|?
operator|&
name|baton
operator|->
name|write_checksum
else|:
name|NULL
argument_list|,
name|svn_checksum_md5
argument_list|,
name|read_all
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Create a stream that will forward its read/write/close operations to    * BATON->proxy and will fill in *READ_DIGEST and *WRITE_DIGEST (if we    * want them) after it closes BATON->proxy. */
name|s
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|s
argument_list|,
name|read_handler_md5
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|s
argument_list|,
name|skip_handler_md5
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|s
argument_list|,
name|write_handler_md5
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|s
argument_list|,
name|close_handler_md5
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous stream functions. */
end_comment

begin_struct
struct|struct
name|stringbuf_stream_baton
block|{
name|svn_stringbuf_t
modifier|*
name|str
decl_stmt|;
name|apr_size_t
name|amt_read
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* svn_stream_mark_t for streams backed by stringbufs. */
end_comment

begin_struct
struct|struct
name|stringbuf_stream_mark
block|{
name|apr_size_t
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|left_to_read
init|=
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
decl_stmt|;
operator|*
name|len
operator|=
operator|(
operator|*
name|len
operator|>
name|left_to_read
operator|)
condition|?
name|left_to_read
else|:
operator|*
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|btn
operator|->
name|str
operator|->
name|data
operator|+
name|btn
operator|->
name|amt_read
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|+=
operator|*
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|left_to_read
init|=
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
decl_stmt|;
name|len
operator|=
operator|(
name|len
operator|>
name|left_to_read
operator|)
condition|?
name|left_to_read
else|:
name|len
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|+=
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|btn
operator|->
name|str
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
decl_stmt|;
name|struct
name|stringbuf_stream_mark
modifier|*
name|stringbuf_stream_mark
decl_stmt|;
name|btn
operator|=
name|baton
expr_stmt|;
name|stringbuf_stream_mark
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stringbuf_stream_mark
argument_list|)
argument_list|)
expr_stmt|;
name|stringbuf_stream_mark
operator|->
name|pos
operator|=
name|btn
operator|->
name|amt_read
expr_stmt|;
operator|*
name|mark
operator|=
operator|(
name|svn_stream_mark_t
operator|*
operator|)
name|stringbuf_stream_mark
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|mark
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|stringbuf_stream_mark
modifier|*
name|stringbuf_stream_mark
decl_stmt|;
name|stringbuf_stream_mark
operator|=
operator|(
specifier|const
expr|struct
name|stringbuf_stream_mark
operator|*
operator|)
name|mark
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|=
name|stringbuf_stream_mark
operator|->
name|pos
expr_stmt|;
block|}
else|else
name|btn
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_from_stringbuf
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|struct
name|stringbuf_stream_baton
modifier|*
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|str
operator|=
name|str
expr_stmt|;
name|baton
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|stream
argument_list|,
name|read_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|stream
argument_list|,
name|skip_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_handler_stringbuf
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_struct
struct|struct
name|string_stream_baton
block|{
specifier|const
name|svn_string_t
modifier|*
name|str
decl_stmt|;
name|apr_size_t
name|amt_read
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* svn_stream_mark_t for streams backed by stringbufs. */
end_comment

begin_struct
struct|struct
name|string_stream_mark
block|{
name|apr_size_t
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|string_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|left_to_read
init|=
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
decl_stmt|;
operator|*
name|len
operator|=
operator|(
operator|*
name|len
operator|>
name|left_to_read
operator|)
condition|?
name|left_to_read
else|:
operator|*
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|btn
operator|->
name|str
operator|->
name|data
operator|+
name|btn
operator|->
name|amt_read
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|+=
operator|*
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|string_stream_baton
modifier|*
name|btn
decl_stmt|;
name|struct
name|string_stream_mark
modifier|*
name|marker
decl_stmt|;
name|btn
operator|=
name|baton
expr_stmt|;
name|marker
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|marker
argument_list|)
argument_list|)
expr_stmt|;
name|marker
operator|->
name|pos
operator|=
name|btn
operator|->
name|amt_read
expr_stmt|;
operator|*
name|mark
operator|=
operator|(
name|svn_stream_mark_t
operator|*
operator|)
name|marker
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
name|struct
name|string_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|mark
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|string_stream_mark
modifier|*
name|marker
decl_stmt|;
name|marker
operator|=
operator|(
specifier|const
expr|struct
name|string_stream_mark
operator|*
operator|)
name|mark
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|=
name|marker
operator|->
name|pos
expr_stmt|;
block|}
else|else
name|btn
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|struct
name|string_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|left_to_read
init|=
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
decl_stmt|;
name|len
operator|=
operator|(
name|len
operator|>
name|left_to_read
operator|)
condition|?
name|left_to_read
else|:
name|len
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|+=
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_from_string
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|struct
name|string_stream_baton
modifier|*
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|str
operator|=
name|str
expr_stmt|;
name|baton
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|stream
argument_list|,
name|read_handler_string
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_string
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_string
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|stream
argument_list|,
name|skip_handler_string
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_handler_string
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_for_stdin
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|stdin_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_err
operator|=
name|apr_file_open_stdin
argument_list|(
operator|&
name|stdin_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't open stdin"
argument_list|)
return|;
operator|*
name|in
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|stdin_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_for_stdout
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|out
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|stdout_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_err
operator|=
name|apr_file_open_stdout
argument_list|(
operator|&
name|stdout_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't open stdout"
argument_list|)
return|;
operator|*
name|out
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|stdout_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_for_stderr
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|err
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|stderr_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_err
operator|=
name|apr_file_open_stderr
argument_list|(
operator|&
name|stderr_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't open stderr"
argument_list|)
return|;
operator|*
name|err
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|stderr_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_string_from_stream
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|result
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|work
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|SVN__STREAM_CHUNK_SIZE
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|apr_size_t
name|len
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|work
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|SVN__STREAM_CHUNK_SIZE
condition|)
break|break;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|=
name|work
operator|->
name|data
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|len
operator|=
name|work
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* These are somewhat arbirary, if we ever get good empirical data as to    actually valid values, feel free to update them. */
end_comment

begin_define
define|#
directive|define
name|BUFFER_BLOCK_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|BUFFER_MAX_SIZE
value|100000
end_define

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_buffered
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
return|return
name|svn_stream__from_spillbuf
argument_list|(
name|BUFFER_BLOCK_SIZE
argument_list|,
name|BUFFER_MAX_SIZE
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Lazyopen Streams ***/
end_comment

begin_comment
comment|/* Custom baton for lazyopen-style wrapper streams. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lazyopen_baton_t
block|{
comment|/* Callback function and baton for opening the wrapped stream. */
name|svn_stream_lazyopen_func_t
name|open_func
decl_stmt|;
name|void
modifier|*
name|open_baton
decl_stmt|;
comment|/* The wrapped stream, or NULL if the stream hasn't yet been      opened. */
name|svn_stream_t
modifier|*
name|real_stream
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Whether to open the wrapped stream on a close call. */
name|svn_boolean_t
name|open_on_close
decl_stmt|;
block|}
name|lazyopen_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Use B->open_func/baton to create and set B->real_stream iff it    isn't already set. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lazyopen_if_unopened
parameter_list|(
name|lazyopen_baton_t
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|->
name|real_stream
operator|==
name|NULL
condition|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|b
operator|->
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|b
operator|->
name|open_func
argument_list|(
operator|&
name|stream
argument_list|,
name|b
operator|->
name|open_baton
argument_list|,
name|b
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|real_stream
operator|=
name|stream
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_read_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_skip_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_skip
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_write_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_close_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|open_on_close
condition|)
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|real_stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|b
operator|->
name|real_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_mark_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_mark
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|mark
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_seek_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_seek
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|mark
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream__is_buffered_fn_t */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* No lazy open as we cannot handle an open error. */
if|if
condition|(
operator|!
name|b
operator|->
name|real_stream
condition|)
return|return
name|FALSE
return|;
return|return
name|svn_stream__is_buffered
argument_list|(
name|b
operator|->
name|real_stream
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_lazyopen_create
parameter_list|(
name|svn_stream_lazyopen_func_t
name|open_func
parameter_list|,
name|void
modifier|*
name|open_baton
parameter_list|,
name|svn_boolean_t
name|open_on_close
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|lob
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lob
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|lob
operator|->
name|open_func
operator|=
name|open_func
expr_stmt|;
name|lob
operator|->
name|open_baton
operator|=
name|open_baton
expr_stmt|;
name|lob
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|lob
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|lob
operator|->
name|open_on_close
operator|=
name|open_on_close
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|lob
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|stream
argument_list|,
name|read_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|stream
argument_list|,
name|skip_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|close_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_lazyopen
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

end_unit

