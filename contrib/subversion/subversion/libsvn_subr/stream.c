begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * stream.c:   svn_stream operations  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_include
include|#
directive|include
file|<apr_poll.h>
end_include

begin_include
include|#
directive|include
file|<apr_portable.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_error_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_eol_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_struct
struct|struct
name|svn_stream_t
block|{
name|void
modifier|*
name|baton
decl_stmt|;
name|svn_read_fn_t
name|read_fn
decl_stmt|;
name|svn_read_fn_t
name|read_full_fn
decl_stmt|;
name|svn_stream_skip_fn_t
name|skip_fn
decl_stmt|;
name|svn_write_fn_t
name|write_fn
decl_stmt|;
name|svn_close_fn_t
name|close_fn
decl_stmt|;
name|svn_stream_mark_fn_t
name|mark_fn
decl_stmt|;
name|svn_stream_seek_fn_t
name|seek_fn
decl_stmt|;
name|svn_stream_data_available_fn_t
name|data_available_fn
decl_stmt|;
name|svn_stream__is_buffered_fn_t
name|is_buffered_fn
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* Maybe NULL */
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/*** Forward declarations. ***/
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|skip_default_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_read_fn_t
name|read_full_fn
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*** Generic streams. ***/
end_comment

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_create
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|stream
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_baton
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|stream
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_read2
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_read_fn_t
name|read_fn
parameter_list|,
name|svn_read_fn_t
name|read_full_fn
parameter_list|)
block|{
name|stream
operator|->
name|read_fn
operator|=
name|read_fn
expr_stmt|;
name|stream
operator|->
name|read_full_fn
operator|=
name|read_full_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_skip
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_skip_fn_t
name|skip_fn
parameter_list|)
block|{
name|stream
operator|->
name|skip_fn
operator|=
name|skip_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_write
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_write_fn_t
name|write_fn
parameter_list|)
block|{
name|stream
operator|->
name|write_fn
operator|=
name|write_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_close
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_close_fn_t
name|close_fn
parameter_list|)
block|{
name|stream
operator|->
name|close_fn
operator|=
name|close_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_mark
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_mark_fn_t
name|mark_fn
parameter_list|)
block|{
name|stream
operator|->
name|mark_fn
operator|=
name|mark_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_seek
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_seek_fn_t
name|seek_fn
parameter_list|)
block|{
name|stream
operator|->
name|seek_fn
operator|=
name|seek_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream_set_data_available
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_data_available_fn_t
name|data_available_fn
parameter_list|)
block|{
name|stream
operator|->
name|data_available_fn
operator|=
name|data_available_fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stream__set_is_buffered
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream__is_buffered_fn_t
name|is_buffered_fn
parameter_list|)
block|{
name|stream
operator|->
name|is_buffered_fn
operator|=
name|is_buffered_fn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Standard implementation for svn_stream_read_full() based on    multiple svn_stream_read2() calls (in separate function to make    it more likely for svn_stream_read_full to be inlined) */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|full_read_fallback
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_size_t
name|remaining
init|=
operator|*
name|len
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|length
init|=
name|remaining
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read2
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
operator|*
name|len
operator|-=
name|remaining
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|remaining
operator|-=
name|length
expr_stmt|;
name|buffer
operator|+=
name|length
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_stream_supports_partial_read
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|stream
operator|->
name|read_fn
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_read2
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|read_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_NOT_SUPPORTED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|read_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_read_full
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|read_full_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|full_read_fallback
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|read_full_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_skip
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|skip_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|skip_default_handler
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|len
argument_list|,
name|stream
operator|->
name|read_full_fn
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|skip_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_write
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|write_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_NOT_SUPPORTED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|write_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_reset
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_seek
argument_list|(
name|stream
argument_list|,
name|NULL
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_stream_supports_mark
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|stream
operator|->
name|mark_fn
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_mark
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|mark_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_SEEK_NOT_SUPPORTED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|mark_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|mark
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_seek
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|seek_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_SEEK_NOT_SUPPORTED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|seek_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|mark
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_data_available
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_boolean_t
modifier|*
name|data_available
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|data_available_fn
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_NOT_SUPPORTED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|data_available_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|,
name|data_available
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_stream__is_buffered
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|is_buffered_fn
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|stream
operator|->
name|is_buffered_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_close
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|close_fn
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_trace
argument_list|(
name|stream
operator|->
name|close_fn
argument_list|(
name|stream
operator|->
name|baton
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_puts
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|apr_size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|str
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_printf
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
name|message
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_printf_from_utf8
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|,
modifier|*
name|translated
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
name|translated
argument_list|,
name|message
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
name|translated
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Guts of svn_stream_readline().  * Returns the line read from STREAM in *STRINGBUF, and indicates  * end-of-file in *EOF.  If DETECT_EOL is TRUE, the end-of-line indicator  * is detected automatically and returned in *EOL.  * If DETECT_EOL is FALSE, *EOL must point to the desired end-of-line  * indicator.  STRINGBUF is allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_readline_bytewise
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|str
decl_stmt|;
name|apr_size_t
name|numbytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|match
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Since we're reading one character at a time, let's at least      optimize for the 90% case.  90% of the time, we can avoid the      stringbuf ever having to realloc() itself if we start it out at      80 chars.  */
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|SVN__LINE_CHUNK_SIZE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Read into STR up to and including the next EOL sequence. */
name|match
operator|=
name|eol
expr_stmt|;
while|while
condition|(
operator|*
name|match
condition|)
block|{
name|numbytes
operator|=
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|numbytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbytes
operator|!=
literal|1
condition|)
block|{
comment|/* a 'short' read means the stream has run out. */
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
operator|*
name|stringbuf
operator|=
name|str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|match
condition|)
name|match
operator|++
expr_stmt|;
else|else
name|match
operator|=
name|eol
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|eof
operator|=
name|FALSE
expr_stmt|;
name|svn_stringbuf_chop
argument_list|(
name|str
argument_list|,
name|match
operator|-
name|eol
argument_list|)
expr_stmt|;
operator|*
name|stringbuf
operator|=
name|str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_readline_chunky
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Read larger chunks of data at once into this buffer and scan    * that for EOL. A good chunk size should be about 80 chars since    * most text lines will be shorter. However, don't use a much    * larger value because filling the buffer from the stream takes    * time as well.    */
name|char
name|buffer
index|[
name|SVN__LINE_CHUNK_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* variables */
name|svn_stream_mark_t
modifier|*
name|mark
decl_stmt|;
name|apr_size_t
name|numbytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_pos
decl_stmt|;
name|apr_size_t
name|total_parsed
init|=
literal|0
decl_stmt|;
comment|/* invariant for this call */
specifier|const
name|size_t
name|eol_len
init|=
name|strlen
argument_list|(
name|eol
argument_list|)
decl_stmt|;
comment|/* Remember the line start so this plus the line length will be    * the position to move to at the end of this function.    */
name|SVN_ERR
argument_list|(
name|svn_stream_mark
argument_list|(
name|stream
argument_list|,
operator|&
name|mark
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the first chunk. */
name|numbytes
operator|=
name|SVN__LINE_CHUNK_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|numbytes
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
index|[
name|numbytes
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look for the EOL in this first chunk. If we find it, we are done here.    */
name|eol_pos
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
name|eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_pos
operator|!=
name|NULL
condition|)
block|{
operator|*
name|stringbuf
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|buffer
argument_list|,
name|eol_pos
operator|-
name|buffer
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|total_parsed
operator|=
name|eol_pos
operator|-
name|buffer
operator|+
name|eol_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numbytes
operator|<
name|SVN__LINE_CHUNK_SIZE
condition|)
block|{
comment|/* We hit EOF but not EOL.        */
operator|*
name|stringbuf
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|buffer
argument_list|,
name|numbytes
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* A larger buffer for the string is needed. */
name|svn_stringbuf_t
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|2
operator|*
name|SVN__LINE_CHUNK_SIZE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|buffer
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
operator|*
name|stringbuf
operator|=
name|str
expr_stmt|;
comment|/* Loop reading chunks until an EOL was found. If we hit EOF, fall        * back to the standard implementation. */
do|do
block|{
comment|/* Append the next chunk to the string read so far.          */
name|svn_stringbuf_ensure
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|len
operator|+
name|SVN__LINE_CHUNK_SIZE
argument_list|)
expr_stmt|;
name|numbytes
operator|=
name|SVN__LINE_CHUNK_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
name|str
operator|->
name|data
operator|+
name|str
operator|->
name|len
argument_list|,
operator|&
name|numbytes
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|->
name|len
operator|+=
name|numbytes
expr_stmt|;
name|str
operator|->
name|data
index|[
name|str
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look for the EOL in the new data plus the last part of the          * previous chunk because the EOL may span over the boundary          * between both chunks.          */
name|eol_pos
operator|=
name|strstr
argument_list|(
name|str
operator|->
name|data
operator|+
name|str
operator|->
name|len
operator|-
name|numbytes
operator|-
operator|(
name|eol_len
operator|-
literal|1
operator|)
argument_list|,
name|eol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numbytes
operator|<
name|SVN__LINE_CHUNK_SIZE
operator|)
operator|&&
operator|(
name|eol_pos
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* We hit EOF instead of EOL. */
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
do|while
condition|(
name|eol_pos
operator|==
name|NULL
condition|)
do|;
comment|/* Number of bytes we actually consumed (i.e. line + EOF).        * We need to "return" the rest to the stream by moving its        * read pointer.        */
name|total_parsed
operator|=
name|eol_pos
operator|-
name|str
operator|->
name|data
operator|+
name|eol_len
expr_stmt|;
comment|/* Terminate the string at the EOL postion and return it. */
name|str
operator|->
name|len
operator|=
name|eol_pos
operator|-
name|str
operator|->
name|data
expr_stmt|;
name|str
operator|->
name|data
index|[
name|str
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Move the stream read pointer to the first position behind the EOL.    */
name|SVN_ERR
argument_list|(
name|svn_stream_seek
argument_list|(
name|stream
argument_list|,
name|mark
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_skip
argument_list|(
name|stream
argument_list|,
name|total_parsed
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Guts of svn_stream_readline().  * Returns the line read from STREAM in *STRINGBUF, and indicates  * end-of-file in *EOF.  EOL must point to the desired end-of-line  * indicator.  STRINGBUF is allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_readline
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|eof
operator|=
name|FALSE
expr_stmt|;
comment|/* Often, we operate on APR file or string-based streams and know what    * EOL we are looking for. Optimize that common case.    */
if|if
condition|(
name|svn_stream_supports_mark
argument_list|(
name|stream
argument_list|)
operator|&&
name|svn_stream__is_buffered
argument_list|(
name|stream
argument_list|)
condition|)
block|{
comment|/* We can efficiently read chunks speculatively and reposition the        * stream pointer to the end of the line once we found that.        */
name|SVN_ERR
argument_list|(
name|stream_readline_chunky
argument_list|(
name|stringbuf
argument_list|,
name|eof
argument_list|,
name|eol
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the standard byte-byte implementation.        */
name|SVN_ERR
argument_list|(
name|stream_readline_bytewise
argument_list|(
name|stringbuf
argument_list|,
name|eof
argument_list|,
name|eol
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_readline
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|stream_readline
argument_list|(
name|stringbuf
argument_list|,
name|eof
argument_list|,
name|eol
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_copy3
parameter_list|(
name|svn_stream_t
modifier|*
name|from
parameter_list|,
name|svn_stream_t
modifier|*
name|to
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
comment|/* Read and write chunks until we get a short read, indicating the      end of the stream.  (We can't get a short write without an      associated error.) */
while|while
condition|(
literal|1
condition|)
block|{
name|apr_size_t
name|len
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
block|{
name|err
operator|=
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|err
operator|=
name|svn_stream_read_full
argument_list|(
name|from
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|err
operator|=
name|svn_stream_write
argument_list|(
name|to
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|(
name|len
operator|!=
name|SVN__STREAM_CHUNK_SIZE
operator|)
condition|)
break|break;
block|}
name|err2
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_stream_close
argument_list|(
name|from
argument_list|)
argument_list|,
name|svn_stream_close
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_contents_same2
parameter_list|(
name|svn_boolean_t
modifier|*
name|same
parameter_list|,
name|svn_stream_t
modifier|*
name|stream1
parameter_list|,
name|svn_stream_t
modifier|*
name|stream2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|buf1
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|apr_size_t
name|bytes_read1
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|apr_size_t
name|bytes_read2
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
operator|*
name|same
operator|=
name|TRUE
expr_stmt|;
comment|/* assume TRUE, until disproved below */
while|while
condition|(
name|bytes_read1
operator|==
name|SVN__STREAM_CHUNK_SIZE
operator|&&
name|bytes_read2
operator|==
name|SVN__STREAM_CHUNK_SIZE
condition|)
block|{
name|err
operator|=
name|svn_stream_read_full
argument_list|(
name|stream1
argument_list|,
name|buf1
argument_list|,
operator|&
name|bytes_read1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|err
operator|=
name|svn_stream_read_full
argument_list|(
name|stream2
argument_list|,
name|buf2
argument_list|,
operator|&
name|bytes_read2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
operator|(
name|bytes_read1
operator|!=
name|bytes_read2
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
name|bytes_read1
argument_list|)
operator|)
condition|)
block|{
operator|*
name|same
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_error_compose_create
argument_list|(
name|svn_stream_close
argument_list|(
name|stream1
argument_list|)
argument_list|,
name|svn_stream_close
argument_list|(
name|stream2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Stream implementation utilities ***/
end_comment

begin_comment
comment|/* Skip data from any stream by reading and simply discarding it. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_default_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_read_fn_t
name|read_full_fn
parameter_list|)
block|{
name|apr_size_t
name|bytes_read
init|=
literal|1
decl_stmt|;
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|apr_size_t
name|to_read
init|=
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|to_read
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bytes_read
operator|>
literal|0
operator|)
condition|)
block|{
name|bytes_read
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|<
name|to_read
condition|?
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
else|:
name|to_read
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_full_fn
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
operator|&
name|bytes_read
argument_list|)
argument_list|)
expr_stmt|;
name|to_read
operator|-=
name|bytes_read
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Generic readable empty stream ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|mark
operator|=
name|NULL
expr_stmt|;
comment|/* Seek to start of stream marker */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_empty
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_empty
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
name|stream
argument_list|,
name|read_handler_empty
argument_list|,
name|read_handler_empty
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_empty
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_empty
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_empty
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_handler_empty
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Stream duplication support ***/
end_comment

begin_struct
struct|struct
name|baton_tee
block|{
name|svn_stream_t
modifier|*
name|out1
decl_stmt|;
name|svn_stream_t
modifier|*
name|out2
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_tee
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|baton_tee
modifier|*
name|bt
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|bt
operator|->
name|out1
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|bt
operator|->
name|out2
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_tee
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|baton_tee
modifier|*
name|bt
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|bt
operator|->
name|out1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|bt
operator|->
name|out2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_tee
parameter_list|(
name|svn_stream_t
modifier|*
name|out1
parameter_list|,
name|svn_stream_t
modifier|*
name|out2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|baton_tee
modifier|*
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
name|out1
operator|==
name|NULL
condition|)
return|return
name|out2
return|;
if|if
condition|(
name|out2
operator|==
name|NULL
condition|)
return|return
name|out1
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|out1
operator|=
name|out1
expr_stmt|;
name|baton
operator|->
name|out2
operator|=
name|out2
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_tee
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|close_handler_tee
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Ownership detaching stream ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_read2
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_full_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_read_full
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_skip
argument_list|(
name|baton
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_write
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_mark
argument_list|(
name|baton
argument_list|,
name|mark
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_seek
argument_list|(
name|baton
argument_list|,
name|mark
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|data_available_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|data_available
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_data_available
argument_list|(
name|baton
argument_list|,
name|data_available
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_disown
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|svn_stream__is_buffered
argument_list|(
name|baton
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_disown
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|s
init|=
name|svn_stream_create
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_stream_set_read2
argument_list|(
name|s
argument_list|,
name|read_handler_disown
argument_list|,
name|read_full_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|s
argument_list|,
name|skip_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|s
argument_list|,
name|write_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|s
argument_list|,
name|mark_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|s
argument_list|,
name|seek_handler_disown
argument_list|)
expr_stmt|;
name|svn_stream_set_data_available
argument_list|(
name|s
argument_list|,
name|data_available_disown
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|s
argument_list|,
name|is_buffered_handler_disown
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Generic stream for APR files ***/
end_comment

begin_struct
struct|struct
name|baton_apr
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* svn_stream_mark_t for streams backed by APR files. */
end_comment

begin_struct
struct|struct
name|mark_apr
block|{
name|apr_off_t
name|off
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|*
name|len
operator|==
literal|1
condition|)
block|{
name|err
operator|=
name|svn_io_file_getc
argument_list|(
name|buffer
argument_list|,
name|btn
operator|->
name|file
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|err
operator|=
name|svn_io_file_read
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_full_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
if|if
condition|(
operator|*
name|len
operator|==
literal|1
condition|)
block|{
name|err
operator|=
name|svn_io_file_getc
argument_list|(
name|buffer
argument_list|,
name|btn
operator|->
name|file
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
block|}
block|}
else|else
name|err
operator|=
name|svn_io_file_read_full2
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
operator|*
name|len
argument_list|,
name|len
argument_list|,
operator|&
name|eof
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_off_t
name|offset
init|=
name|len
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_seek
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|*
name|len
operator|==
literal|1
condition|)
block|{
name|err
operator|=
name|svn_io_file_putc
argument_list|(
operator|*
name|data
argument_list|,
name|btn
operator|->
name|file
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
operator|*
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|err
operator|=
name|svn_io_file_write_full
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|,
name|len
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_close
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|struct
name|mark_apr
modifier|*
name|mark_apr
decl_stmt|;
name|mark_apr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mark_apr
argument_list|)
argument_list|)
expr_stmt|;
name|mark_apr
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|mark_apr
operator|->
name|off
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mark
operator|=
operator|(
name|svn_stream_mark_t
operator|*
operator|)
name|mark_apr
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_off_t
name|offset
init|=
operator|(
name|mark
operator|!=
name|NULL
operator|)
condition|?
operator|(
operator|(
specifier|const
expr|struct
name|mark_apr
operator|*
operator|)
name|mark
operator|)
operator|->
name|off
else|:
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|btn
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|data_available_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|data_available
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|APR_FILES_AS_SOCKETS
name|apr_pollfd_t
name|pfd
decl_stmt|;
name|int
name|n
decl_stmt|;
name|pfd
operator|.
name|desc_type
operator|=
name|APR_POLL_FILE
expr_stmt|;
name|pfd
operator|.
name|desc
operator|.
name|f
operator|=
name|btn
operator|->
name|file
expr_stmt|;
name|pfd
operator|.
name|p
operator|=
name|btn
operator|->
name|pool
expr_stmt|;
comment|/* If we had a scratch pool... Luckily apr doesn't                         store anything in this pool at this time */
name|pfd
operator|.
name|reqevents
operator|=
name|APR_POLLIN
expr_stmt|;
name|status
operator|=
name|apr_poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
operator|&
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
block|{
operator|*
name|data_available
operator|=
operator|(
name|n
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_TIMEUP
argument_list|(
name|status
argument_list|)
condition|)
block|{
operator|*
name|data_available
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_NOT_SUPPORTED
argument_list|,
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Polling for available data on filestream "
literal|"failed"
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
else|#
directive|else
name|HANDLE
name|h
decl_stmt|;
name|DWORD
name|dwAvail
decl_stmt|;
name|status
operator|=
name|apr_os_file_get
argument_list|(
operator|&
name|h
argument_list|,
name|btn
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|PeekNamedPipe
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|dwAvail
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|*
name|data_available
operator|=
operator|(
name|dwAvail
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_NOT_SUPPORTED
argument_list|,
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Windows doesn't support polling on files"
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_apr
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
return|return
operator|(
name|apr_file_flags_get
argument_list|(
name|btn
operator|->
name|file
argument_list|)
operator|&
name|APR_BUFFERED
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_open_readonly
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_open_writable
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path
argument_list|,
name|APR_WRITE
operator||
name|APR_BUFFERED
operator||
name|APR_CREATE
operator||
name|APR_EXCL
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_open_unique
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|temp_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dirpath
parameter_list|,
name|svn_io_file_del_t
name|delete_when
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|file
argument_list|,
name|temp_path
argument_list|,
name|dirpath
argument_list|,
name|delete_when
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function that creates a stream from an APR file. */
end_comment

begin_function
specifier|static
name|svn_stream_t
modifier|*
name|make_stream_from_apr_file
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_boolean_t
name|disown
parameter_list|,
name|svn_boolean_t
name|supports_seek
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|baton_apr
modifier|*
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
name|stream
argument_list|,
name|read_handler_apr
argument_list|,
name|read_full_handler_apr
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_apr
argument_list|)
expr_stmt|;
if|if
condition|(
name|supports_seek
condition|)
block|{
name|svn_stream_set_skip
argument_list|(
name|stream
argument_list|,
name|skip_handler_apr
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_apr
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_apr
argument_list|)
expr_stmt|;
block|}
name|svn_stream_set_data_available
argument_list|(
name|stream
argument_list|,
name|data_available_handler_apr
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_handler_apr
argument_list|)
expr_stmt|;
name|stream
operator|->
name|file
operator|=
name|file
expr_stmt|;
if|if
condition|(
operator|!
name|disown
condition|)
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|close_handler_apr
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_from_aprfile2
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_boolean_t
name|disown
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|make_stream_from_apr_file
argument_list|(
name|file
argument_list|,
name|disown
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_file_t
modifier|*
name|svn_stream__aprfile
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|stream
operator|->
name|file
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compressed stream support */
end_comment

begin_define
define|#
directive|define
name|ZBUFFER_SIZE
value|4096
end_define

begin_comment
comment|/* The size of the buffer the                                    compressed stream uses to read from                                    the substream. Basically an                                    arbitrary value, picked to be about                                    page-sized. */
end_comment

begin_struct
struct|struct
name|zbaton
block|{
name|z_stream
modifier|*
name|in
decl_stmt|;
comment|/* compressed stream for reading */
name|z_stream
modifier|*
name|out
decl_stmt|;
comment|/* compressed stream for writing */
name|void
modifier|*
name|substream
decl_stmt|;
comment|/* The substream */
name|void
modifier|*
name|read_buffer
decl_stmt|;
comment|/* buffer   used   for  reading   from                                    substream */
name|int
name|read_flush
decl_stmt|;
comment|/* what flush mode to use while                                    reading */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The pool this baton is allocated                                    on */
block|}
struct|;
end_struct

begin_comment
comment|/* zlib alloc function. opaque is the pool we need. */
end_comment

begin_function
specifier|static
name|voidpf
name|zalloc
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|uInt
name|items
parameter_list|,
name|uInt
name|size
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|opaque
decl_stmt|;
return|return
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|items
operator|*
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* zlib free function */
end_comment

begin_function
specifier|static
name|void
name|zfree
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|voidpf
name|address
parameter_list|)
block|{
comment|/* Empty, since we allocate on the pool */
block|}
end_function

begin_comment
comment|/* Helper function to figure out the sync mode */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_helper_gz
parameter_list|(
name|svn_stream_t
modifier|*
name|substream
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|uInt
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|zflush
parameter_list|)
block|{
name|uInt
name|orig_len
init|=
operator|*
name|len
decl_stmt|;
comment|/* There's no reason this value should grow bigger than the range of      uInt, but Subversion's API requires apr_size_t. */
name|apr_size_t
name|apr_len
init|=
operator|(
name|apr_size_t
operator|)
operator|*
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|substream
argument_list|,
name|buffer
argument_list|,
operator|&
name|apr_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Type cast back to uInt type that zlib uses.  On LP64 platforms      apr_size_t will be bigger than uInt. */
operator|*
name|len
operator|=
operator|(
name|uInt
operator|)
name|apr_len
expr_stmt|;
comment|/* I wanted to use Z_FINISH here, but we need to know our buffer is      big enough */
operator|*
name|zflush
operator|=
operator|(
operator|*
name|len
operator|)
operator|<
name|orig_len
condition|?
name|Z_SYNC_FLUSH
else|:
name|Z_SYNC_FLUSH
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handle reading from a compressed stream */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_gz
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|zbaton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|int
name|zerr
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|in
operator|==
name|NULL
condition|)
block|{
name|btn
operator|->
name|in
operator|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|zalloc
operator|=
name|zalloc
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|zfree
operator|=
name|zfree
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|opaque
operator|=
name|btn
operator|->
name|pool
expr_stmt|;
name|btn
operator|->
name|read_buffer
operator|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
name|ZBUFFER_SIZE
argument_list|)
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|next_in
operator|=
name|btn
operator|->
name|read_buffer
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|avail_in
operator|=
name|ZBUFFER_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_helper_gz
argument_list|(
name|btn
operator|->
name|substream
argument_list|,
name|btn
operator|->
name|read_buffer
argument_list|,
operator|&
name|btn
operator|->
name|in
operator|->
name|avail_in
argument_list|,
operator|&
name|btn
operator|->
name|read_flush
argument_list|)
argument_list|)
expr_stmt|;
name|zerr
operator|=
name|inflateInit
argument_list|(
name|btn
operator|->
name|in
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"inflateInit"
argument_list|,
name|btn
operator|->
name|in
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|btn
operator|->
name|in
operator|->
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|buffer
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|avail_out
operator|=
operator|(
name|uInt
operator|)
operator|*
name|len
expr_stmt|;
while|while
condition|(
name|btn
operator|->
name|in
operator|->
name|avail_out
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|btn
operator|->
name|in
operator|->
name|avail_in
operator|<=
literal|0
condition|)
block|{
name|btn
operator|->
name|in
operator|->
name|avail_in
operator|=
name|ZBUFFER_SIZE
expr_stmt|;
name|btn
operator|->
name|in
operator|->
name|next_in
operator|=
name|btn
operator|->
name|read_buffer
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_helper_gz
argument_list|(
name|btn
operator|->
name|substream
argument_list|,
name|btn
operator|->
name|read_buffer
argument_list|,
operator|&
name|btn
operator|->
name|in
operator|->
name|avail_in
argument_list|,
operator|&
name|btn
operator|->
name|read_flush
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Short read means underlying stream has run out. */
if|if
condition|(
name|btn
operator|->
name|in
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|zerr
operator|=
name|inflate
argument_list|(
name|btn
operator|->
name|in
argument_list|,
name|btn
operator|->
name|read_flush
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerr
operator|==
name|Z_STREAM_END
condition|)
break|break;
elseif|else
if|if
condition|(
name|zerr
operator|!=
name|Z_OK
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"inflate"
argument_list|,
name|btn
operator|->
name|in
operator|->
name|msg
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|len
operator|-=
name|btn
operator|->
name|in
operator|->
name|avail_out
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compress data and write it to the substream */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_gz
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|zbaton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|void
modifier|*
name|write_buf
decl_stmt|;
name|apr_size_t
name|buf_size
decl_stmt|,
name|write_len
decl_stmt|;
name|int
name|zerr
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|out
operator|==
name|NULL
condition|)
block|{
name|btn
operator|->
name|out
operator|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|zalloc
operator|=
name|zalloc
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|zfree
operator|=
name|zfree
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|opaque
operator|=
name|btn
operator|->
name|pool
expr_stmt|;
name|zerr
operator|=
name|deflateInit
argument_list|(
name|btn
operator|->
name|out
argument_list|,
name|Z_DEFAULT_COMPRESSION
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"deflateInit"
argument_list|,
name|btn
operator|->
name|out
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The largest buffer we should need is 0.1% larger than the      compressed data, + 12 bytes. This info comes from zlib.h.  */
name|buf_size
operator|=
operator|*
name|len
operator|+
operator|(
operator|*
name|len
operator|/
literal|1000
operator|)
operator|+
literal|13
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|btn
operator|->
name|pool
argument_list|)
expr_stmt|;
name|write_buf
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|buffer
expr_stmt|;
comment|/* Casting away const! */
name|btn
operator|->
name|out
operator|->
name|avail_in
operator|=
operator|(
name|uInt
operator|)
operator|*
name|len
expr_stmt|;
while|while
condition|(
name|btn
operator|->
name|out
operator|->
name|avail_in
operator|>
literal|0
condition|)
block|{
name|btn
operator|->
name|out
operator|->
name|next_out
operator|=
name|write_buf
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|buf_size
expr_stmt|;
name|zerr
operator|=
name|deflate
argument_list|(
name|btn
operator|->
name|out
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"deflate"
argument_list|,
name|btn
operator|->
name|out
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|write_len
operator|=
name|buf_size
operator|-
name|btn
operator|->
name|out
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|write_len
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|btn
operator|->
name|substream
argument_list|,
name|write_buf
argument_list|,
operator|&
name|write_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handle flushing and closing the stream */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_gz
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|zbaton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|int
name|zerr
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|in
operator|!=
name|NULL
condition|)
block|{
name|zerr
operator|=
name|inflateEnd
argument_list|(
name|btn
operator|->
name|in
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"inflateEnd"
argument_list|,
name|btn
operator|->
name|in
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|btn
operator|->
name|out
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|apr_size_t
name|write_len
decl_stmt|;
name|buf
operator|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
name|ZBUFFER_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|btn
operator|->
name|out
operator|->
name|next_out
operator|=
name|buf
expr_stmt|;
name|btn
operator|->
name|out
operator|->
name|avail_out
operator|=
name|ZBUFFER_SIZE
expr_stmt|;
name|zerr
operator|=
name|deflate
argument_list|(
name|btn
operator|->
name|out
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerr
operator|!=
name|Z_STREAM_END
operator|&&
name|zerr
operator|!=
name|Z_OK
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"deflate"
argument_list|,
name|btn
operator|->
name|out
operator|->
name|msg
argument_list|)
argument_list|)
return|;
name|write_len
operator|=
name|ZBUFFER_SIZE
operator|-
name|btn
operator|->
name|out
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|write_len
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|btn
operator|->
name|substream
argument_list|,
name|buf
argument_list|,
operator|&
name|write_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerr
operator|==
name|Z_STREAM_END
condition|)
break|break;
block|}
name|zerr
operator|=
name|deflateEnd
argument_list|(
name|btn
operator|->
name|out
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"deflateEnd"
argument_list|,
name|btn
operator|->
name|out
operator|->
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_close
argument_list|(
name|btn
operator|->
name|substream
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_compressed
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svn_stream_t
modifier|*
name|zstream
decl_stmt|;
name|struct
name|zbaton
modifier|*
name|baton
decl_stmt|;
name|assert
argument_list|(
name|stream
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|in
operator|=
name|baton
operator|->
name|out
operator|=
name|NULL
expr_stmt|;
name|baton
operator|->
name|substream
operator|=
name|stream
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|baton
operator|->
name|read_buffer
operator|=
name|NULL
expr_stmt|;
name|baton
operator|->
name|read_flush
operator|=
name|Z_SYNC_FLUSH
expr_stmt|;
name|zstream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
name|zstream
argument_list|,
name|NULL
comment|/* only full read support */
argument_list|,
name|read_handler_gz
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|zstream
argument_list|,
name|write_handler_gz
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|zstream
argument_list|,
name|close_handler_gz
argument_list|)
expr_stmt|;
return|return
name|zstream
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Checksummed stream support */
end_comment

begin_struct
struct|struct
name|checksum_stream_baton
block|{
name|svn_checksum_ctx_t
modifier|*
name|read_ctx
decl_stmt|,
modifier|*
name|write_ctx
decl_stmt|;
name|svn_checksum_t
modifier|*
modifier|*
name|read_checksum
decl_stmt|;
comment|/* Output value. */
name|svn_checksum_t
modifier|*
modifier|*
name|write_checksum
decl_stmt|;
comment|/* Output value. */
name|svn_stream_t
modifier|*
name|proxy
decl_stmt|;
comment|/* True if more data should be read when closing the stream. */
name|svn_boolean_t
name|read_more
decl_stmt|;
comment|/* Pool to allocate read buffer and output values from. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_checksum
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|checksum_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read2
argument_list|(
name|btn
operator|->
name|proxy
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|btn
operator|->
name|read_checksum
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|btn
operator|->
name|read_ctx
argument_list|,
name|buffer
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_full_handler_checksum
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|checksum_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|saved_len
init|=
operator|*
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|btn
operator|->
name|proxy
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|btn
operator|->
name|read_checksum
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|btn
operator|->
name|read_ctx
argument_list|,
name|buffer
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_len
operator|!=
operator|*
name|len
condition|)
name|btn
operator|->
name|read_more
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_checksum
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|checksum_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|write_checksum
operator|&&
operator|*
name|len
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|btn
operator|->
name|write_ctx
argument_list|,
name|buffer
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_write
argument_list|(
name|btn
operator|->
name|proxy
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|data_available_handler_checksum
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|data_available
parameter_list|)
block|{
name|struct
name|checksum_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_data_available
argument_list|(
name|btn
operator|->
name|proxy
argument_list|,
name|data_available
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_checksum
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|checksum_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
comment|/* If we're supposed to drain the stream, do so before finalizing the      checksum. */
if|if
condition|(
name|btn
operator|->
name|read_more
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|apr_palloc
argument_list|(
name|btn
operator|->
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|apr_size_t
name|len
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
do|do
block|{
name|SVN_ERR
argument_list|(
name|read_full_handler_checksum
argument_list|(
name|baton
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|btn
operator|->
name|read_more
condition|)
do|;
block|}
if|if
condition|(
name|btn
operator|->
name|read_ctx
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
name|btn
operator|->
name|read_checksum
argument_list|,
name|btn
operator|->
name|read_ctx
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|btn
operator|->
name|write_ctx
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
name|btn
operator|->
name|write_checksum
argument_list|,
name|btn
operator|->
name|write_ctx
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_close
argument_list|(
name|btn
operator|->
name|proxy
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_checksummed2
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|read_checksum
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|write_checksum
parameter_list|,
name|svn_checksum_kind_t
name|checksum_kind
parameter_list|,
name|svn_boolean_t
name|read_all
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|struct
name|checksum_stream_baton
modifier|*
name|baton
decl_stmt|;
if|if
condition|(
name|read_checksum
operator|==
name|NULL
operator|&&
name|write_checksum
operator|==
name|NULL
condition|)
return|return
name|stream
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_checksum
condition|)
name|baton
operator|->
name|read_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|checksum_kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|baton
operator|->
name|read_ctx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|write_checksum
condition|)
name|baton
operator|->
name|write_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|checksum_kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|baton
operator|->
name|write_ctx
operator|=
name|NULL
expr_stmt|;
name|baton
operator|->
name|read_checksum
operator|=
name|read_checksum
expr_stmt|;
name|baton
operator|->
name|write_checksum
operator|=
name|write_checksum
expr_stmt|;
name|baton
operator|->
name|proxy
operator|=
name|stream
expr_stmt|;
name|baton
operator|->
name|read_more
operator|=
name|read_all
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|s
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
name|s
argument_list|,
name|read_handler_checksum
argument_list|,
name|read_full_handler_checksum
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|s
argument_list|,
name|write_handler_checksum
argument_list|)
expr_stmt|;
name|svn_stream_set_data_available
argument_list|(
name|s
argument_list|,
name|data_available_handler_checksum
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|s
argument_list|,
name|close_handler_checksum
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Miscellaneous stream functions. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_stringbuf_from_stream
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|str
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_size_t
name|len_hint
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
define|#
directive|define
name|MIN_READ_SIZE
value|64
name|apr_size_t
name|to_read
init|=
literal|0
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|text
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|len_hint
condition|?
name|len_hint
else|:
name|MIN_READ_SIZE
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
do|do
block|{
name|to_read
operator|=
name|text
operator|->
name|blocksize
operator|-
literal|1
operator|-
name|text
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
name|text
operator|->
name|data
operator|+
name|text
operator|->
name|len
argument_list|,
operator|&
name|to_read
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|->
name|len
operator|+=
name|to_read
expr_stmt|;
if|if
condition|(
name|to_read
operator|&&
name|text
operator|->
name|blocksize
operator|<
name|text
operator|->
name|len
operator|+
name|MIN_READ_SIZE
condition|)
name|svn_stringbuf_ensure
argument_list|(
name|text
argument_list|,
name|text
operator|->
name|blocksize
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|to_read
condition|)
do|;
name|text
operator|->
name|data
index|[
name|text
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|str
operator|=
name|text
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|stringbuf_stream_baton
block|{
name|svn_stringbuf_t
modifier|*
name|str
decl_stmt|;
name|apr_size_t
name|amt_read
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* svn_stream_mark_t for streams backed by stringbufs. */
end_comment

begin_struct
struct|struct
name|stringbuf_stream_mark
block|{
name|apr_size_t
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|left_to_read
init|=
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
decl_stmt|;
operator|*
name|len
operator|=
operator|(
operator|*
name|len
operator|>
name|left_to_read
operator|)
condition|?
name|left_to_read
else|:
operator|*
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|btn
operator|->
name|str
operator|->
name|data
operator|+
name|btn
operator|->
name|amt_read
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|+=
operator|*
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|left_to_read
init|=
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
decl_stmt|;
name|len
operator|=
operator|(
name|len
operator|>
name|left_to_read
operator|)
condition|?
name|left_to_read
else|:
name|len
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|+=
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|btn
operator|->
name|str
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
decl_stmt|;
name|struct
name|stringbuf_stream_mark
modifier|*
name|stringbuf_stream_mark
decl_stmt|;
name|btn
operator|=
name|baton
expr_stmt|;
name|stringbuf_stream_mark
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stringbuf_stream_mark
argument_list|)
argument_list|)
expr_stmt|;
name|stringbuf_stream_mark
operator|->
name|pos
operator|=
name|btn
operator|->
name|amt_read
expr_stmt|;
operator|*
name|mark
operator|=
operator|(
name|svn_stream_mark_t
operator|*
operator|)
name|stringbuf_stream_mark
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|mark
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|stringbuf_stream_mark
modifier|*
name|stringbuf_stream_mark
decl_stmt|;
name|stringbuf_stream_mark
operator|=
operator|(
specifier|const
expr|struct
name|stringbuf_stream_mark
operator|*
operator|)
name|mark
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|=
name|stringbuf_stream_mark
operator|->
name|pos
expr_stmt|;
block|}
else|else
name|btn
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|data_available_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|data_available
parameter_list|)
block|{
name|struct
name|stringbuf_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
operator|*
name|data_available
operator|=
operator|(
operator|(
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
operator|)
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_stringbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_from_stringbuf
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|struct
name|stringbuf_stream_baton
modifier|*
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|str
operator|=
name|str
expr_stmt|;
name|baton
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
name|stream
argument_list|,
name|read_handler_stringbuf
argument_list|,
name|read_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|stream
argument_list|,
name|skip_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_data_available
argument_list|(
name|stream
argument_list|,
name|data_available_handler_stringbuf
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_handler_stringbuf
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_struct
struct|struct
name|string_stream_baton
block|{
specifier|const
name|svn_string_t
modifier|*
name|str
decl_stmt|;
name|apr_size_t
name|amt_read
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* svn_stream_mark_t for streams backed by stringbufs. */
end_comment

begin_struct
struct|struct
name|string_stream_mark
block|{
name|apr_size_t
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|string_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|left_to_read
init|=
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
decl_stmt|;
operator|*
name|len
operator|=
operator|(
operator|*
name|len
operator|>
name|left_to_read
operator|)
condition|?
name|left_to_read
else|:
operator|*
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|btn
operator|->
name|str
operator|->
name|data
operator|+
name|btn
operator|->
name|amt_read
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|+=
operator|*
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|string_stream_baton
modifier|*
name|btn
decl_stmt|;
name|struct
name|string_stream_mark
modifier|*
name|marker
decl_stmt|;
name|btn
operator|=
name|baton
expr_stmt|;
name|marker
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|marker
argument_list|)
argument_list|)
expr_stmt|;
name|marker
operator|->
name|pos
operator|=
name|btn
operator|->
name|amt_read
expr_stmt|;
operator|*
name|mark
operator|=
operator|(
name|svn_stream_mark_t
operator|*
operator|)
name|marker
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
name|struct
name|string_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|mark
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|string_stream_mark
modifier|*
name|marker
decl_stmt|;
name|marker
operator|=
operator|(
specifier|const
expr|struct
name|string_stream_mark
operator|*
operator|)
name|mark
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|=
name|marker
operator|->
name|pos
expr_stmt|;
block|}
else|else
name|btn
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|struct
name|string_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|left_to_read
init|=
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
decl_stmt|;
name|len
operator|=
operator|(
name|len
operator|>
name|left_to_read
operator|)
condition|?
name|left_to_read
else|:
name|len
expr_stmt|;
name|btn
operator|->
name|amt_read
operator|+=
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|data_available_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|data_available
parameter_list|)
block|{
name|struct
name|string_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
operator|*
name|data_available
operator|=
operator|(
operator|(
name|btn
operator|->
name|str
operator|->
name|len
operator|-
name|btn
operator|->
name|amt_read
operator|)
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_handler_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_from_string
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|struct
name|string_stream_baton
modifier|*
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
return|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|str
operator|=
name|str
expr_stmt|;
name|baton
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
name|stream
argument_list|,
name|read_handler_string
argument_list|,
name|read_handler_string
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_string
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_string
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|stream
argument_list|,
name|skip_handler_string
argument_list|)
expr_stmt|;
name|svn_stream_set_data_available
argument_list|(
name|stream
argument_list|,
name|data_available_handler_string
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_handler_string
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_for_stdin
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|stdin_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_err
operator|=
name|apr_file_open_stdin
argument_list|(
operator|&
name|stdin_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't open stdin"
argument_list|)
return|;
comment|/* STDIN may or may not support positioning requests, but generally      it does not, or the behavior is implementation-specific.  Hence,      we cannot safely advertise mark(), seek() and non-default skip()      support. */
operator|*
name|in
operator|=
name|make_stream_from_apr_file
argument_list|(
name|stdin_file
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_for_stdout
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|out
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|stdout_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_err
operator|=
name|apr_file_open_stdout
argument_list|(
operator|&
name|stdout_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't open stdout"
argument_list|)
return|;
comment|/* STDOUT may or may not support positioning requests, but generally      it does not, or the behavior is implementation-specific.  Hence,      we cannot safely advertise mark(), seek() and non-default skip()      support. */
operator|*
name|out
operator|=
name|make_stream_from_apr_file
argument_list|(
name|stdout_file
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream_for_stderr
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|err
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|stderr_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_err
operator|=
name|apr_file_open_stderr
argument_list|(
operator|&
name|stderr_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't open stderr"
argument_list|)
return|;
comment|/* STDERR may or may not support positioning requests, but generally      it does not, or the behavior is implementation-specific.  Hence,      we cannot safely advertise mark(), seek() and non-default skip()      support. */
operator|*
name|err
operator|=
name|make_stream_from_apr_file
argument_list|(
name|stderr_file
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_string_from_stream
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|result
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|work
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|SVN__STREAM_CHUNK_SIZE
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|apr_size_t
name|len
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|work
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|SVN__STREAM_CHUNK_SIZE
condition|)
break|break;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|=
name|work
operator|->
name|data
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|len
operator|=
name|work
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* These are somewhat arbitrary, if we ever get good empirical data as to    actually valid values, feel free to update them. */
end_comment

begin_define
define|#
directive|define
name|BUFFER_BLOCK_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|BUFFER_MAX_SIZE
value|100000
end_define

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_buffered
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
return|return
name|svn_stream__from_spillbuf
argument_list|(
name|svn_spillbuf__create
argument_list|(
name|BUFFER_BLOCK_SIZE
argument_list|,
name|BUFFER_MAX_SIZE
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Lazyopen Streams ***/
end_comment

begin_comment
comment|/* Custom baton for lazyopen-style wrapper streams. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lazyopen_baton_t
block|{
comment|/* Callback function and baton for opening the wrapped stream. */
name|svn_stream_lazyopen_func_t
name|open_func
decl_stmt|;
name|void
modifier|*
name|open_baton
decl_stmt|;
comment|/* The wrapped stream, or NULL if the stream hasn't yet been      opened. */
name|svn_stream_t
modifier|*
name|real_stream
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Whether to open the wrapped stream on a close call. */
name|svn_boolean_t
name|open_on_close
decl_stmt|;
block|}
name|lazyopen_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Use B->open_func/baton to create and set B->real_stream iff it    isn't already set. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lazyopen_if_unopened
parameter_list|(
name|lazyopen_baton_t
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|->
name|real_stream
operator|==
name|NULL
condition|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|b
operator|->
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|b
operator|->
name|open_func
argument_list|(
operator|&
name|stream
argument_list|,
name|b
operator|->
name|open_baton
argument_list|,
name|b
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|real_stream
operator|=
name|stream
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_read_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read2
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_read_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_full_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_skip_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_skip
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_write_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_close_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|open_on_close
condition|)
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|real_stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|b
operator|->
name|real_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_mark_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_mark
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|mark
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_seek_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_seek
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|mark
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|data_available_handler_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|data_available
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|lazyopen_if_unopened
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_data_available
argument_list|(
name|b
operator|->
name|real_stream
argument_list|,
name|data_available
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream__is_buffered_fn_t */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_buffered_lazyopen
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* No lazy open as we cannot handle an open error. */
if|if
condition|(
operator|!
name|b
operator|->
name|real_stream
condition|)
return|return
name|FALSE
return|;
return|return
name|svn_stream__is_buffered
argument_list|(
name|b
operator|->
name|real_stream
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream_lazyopen_create
parameter_list|(
name|svn_stream_lazyopen_func_t
name|open_func
parameter_list|,
name|void
modifier|*
name|open_baton
parameter_list|,
name|svn_boolean_t
name|open_on_close
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|lazyopen_baton_t
modifier|*
name|lob
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lob
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|lob
operator|->
name|open_func
operator|=
name|open_func
expr_stmt|;
name|lob
operator|->
name|open_baton
operator|=
name|open_baton
expr_stmt|;
name|lob
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|lob
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|lob
operator|->
name|open_on_close
operator|=
name|open_on_close
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|lob
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
name|stream
argument_list|,
name|read_handler_lazyopen
argument_list|,
name|read_full_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_skip
argument_list|(
name|stream
argument_list|,
name|skip_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|close_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|stream
argument_list|,
name|mark_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|stream
argument_list|,
name|seek_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream_set_data_available
argument_list|(
name|stream
argument_list|,
name|data_available_handler_lazyopen
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|stream
argument_list|,
name|is_buffered_lazyopen
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_comment
comment|/* Baton for install streams */
end_comment

begin_struct
struct|struct
name|install_baton_t
block|{
name|struct
name|baton_apr
name|baton_apr
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/* Create and open a tempfile in DIRECTORY. Return its handle and path */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_tempfile
parameter_list|(
name|HANDLE
modifier|*
name|hFile
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|file_path
parameter_list|,
specifier|const
name|char
modifier|*
name|directory
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|unique_name
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|static
name|svn_atomic_t
name|tempname_counter
decl_stmt|;
name|int
name|baseNr
init|=
operator|(
name|GetTickCount
argument_list|()
operator|<<
literal|11
operator|)
operator|+
literal|13
operator|*
name|svn_atomic_inc
argument_list|(
operator|&
name|tempname_counter
argument_list|)
operator|+
name|GetCurrentProcessId
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
comment|/* Shares common idea with io.c's temp_file_create */
do|do
block|{
name|apr_uint32_t
name|unique_nr
decl_stmt|;
name|WCHAR
modifier|*
name|w_name
decl_stmt|;
comment|/* Generate a number that should be unique for this application and          usually for the entire computer to reduce the number of cycles          through this loop. (A bit of calculation is much cheaper than          disk io) */
name|unique_nr
operator|=
name|baseNr
operator|+
literal|7
operator|*
name|i
operator|++
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|unique_name
operator|=
name|svn_dirent_join
argument_list|(
name|directory
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"svn-%X"
argument_list|,
name|unique_nr
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io__utf8_to_unicode_longpath
argument_list|(
operator|&
name|w_name
argument_list|,
name|unique_name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a completely not-sharable file to avoid indexers, and other          filesystem watchers locking the file while we are still writing.           We need DELETE privileges to move the file. */
name|h
operator|=
name|CreateFileW
argument_list|(
name|w_name
argument_list|,
name|GENERIC_WRITE
operator||
name|DELETE
argument_list|,
literal|0
comment|/* share */
argument_list|,
name|NULL
argument_list|,
name|CREATE_NEW
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|apr_status_t
name|status
init|=
name|apr_get_os_error
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|1000
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED
argument_list|,
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Unable to make name in '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|directory
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|APR_STATUS_IS_EEXIST
argument_list|(
name|status
argument_list|)
operator|&&
operator|!
name|APR_STATUS_IS_EACCES
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
do|while
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
do|;
operator|*
name|hFile
operator|=
name|h
expr_stmt|;
operator|*
name|file_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|unique_name
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_close_fn_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|install_close
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|install_baton_t
modifier|*
name|ib
init|=
name|baton
decl_stmt|;
comment|/* Flush the data cached in APR, but don't close the file yet */
name|SVN_ERR
argument_list|(
name|svn_io_file_flush
argument_list|(
name|ib
operator|->
name|baton_apr
operator|.
name|file
argument_list|,
name|ib
operator|->
name|baton_apr
operator|.
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_stream__create_for_install
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|install_stream
parameter_list|,
specifier|const
name|char
modifier|*
name|tmp_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|struct
name|install_baton_t
modifier|*
name|ib
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|HANDLE
name|hInstall
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|tmp_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_tempfile
argument_list|(
operator|&
name|hInstall
argument_list|,
operator|&
name|tmp_path
argument_list|,
name|tmp_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wrap as a standard APR file to allow sharing implementation.       But do note that some file functions (such as retrieving the name)      don't work on this wrapper. */
comment|/* ### Buffered, or not? */
name|status
operator|=
name|apr_os_file_put
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|hInstall
argument_list|,
name|APR_WRITE
operator||
name|APR_BINARY
operator||
name|APR_BUFFERED
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|CloseHandle
argument_list|(
name|hInstall
argument_list|)
expr_stmt|;
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|tmp_path
operator|=
name|svn_dirent_internal_style
argument_list|(
name|tmp_path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|tmp_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|tmp_path
argument_list|,
name|tmp_abspath
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|install_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|ib
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ib
argument_list|)
argument_list|)
expr_stmt|;
name|ib
operator|->
name|baton_apr
operator|=
operator|*
operator|(
expr|struct
name|baton_apr
operator|*
operator|)
operator|(
operator|*
name|install_stream
operator|)
operator|->
name|baton
expr_stmt|;
name|assert
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ib
operator|->
name|baton_apr
operator|==
operator|(
name|void
operator|*
operator|)
name|ib
argument_list|)
expr_stmt|;
comment|/* baton pointer is the same */
operator|(
operator|*
name|install_stream
operator|)
operator|->
name|baton
operator|=
name|ib
expr_stmt|;
name|ib
operator|->
name|tmp_path
operator|=
name|tmp_path
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
comment|/* Don't close the file on stream close; flush instead */
name|svn_stream_set_close
argument_list|(
operator|*
name|install_stream
argument_list|,
name|install_close
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ### Install pool cleanup handler for tempfile? */
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream__install_stream
parameter_list|(
name|svn_stream_t
modifier|*
name|install_stream
parameter_list|,
specifier|const
name|char
modifier|*
name|final_abspath
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|install_baton_t
modifier|*
name|ib
init|=
name|install_stream
operator|->
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|final_abspath
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|err
operator|=
name|svn_io__win_rename_open_file
argument_list|(
name|ib
operator|->
name|baton_apr
operator|.
name|file
argument_list|,
name|ib
operator|->
name|tmp_path
argument_list|,
name|final_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_parents
operator|&&
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|err2
operator|=
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|final_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
argument_list|)
return|;
else|else
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io__win_rename_open_file
argument_list|(
name|ib
operator|->
name|baton_apr
operator|.
name|file
argument_list|,
name|ib
operator|->
name|tmp_path
argument_list|,
name|final_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* ### rhuijben: I wouldn't be surprised if we later find out that we                    have to fall back to close+rename on some specific                    error values here, to support some non standard NAS                    and filesystem scenarios. */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_UNSUPPORTED_FEATURE
condition|)
block|{
comment|/* Rename open files is not supported on this platform: fallback to          svn_io_file_rename2(). */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|ib
operator|->
name|baton_apr
operator|.
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|ib
operator|->
name|baton_apr
operator|.
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
name|err
operator|=
name|svn_io_file_rename
argument_list|(
name|ib
operator|->
name|tmp_path
argument_list|,
name|final_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* A missing directory is too common to not cover here. */
if|if
condition|(
name|make_parents
operator|&&
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|err2
operator|=
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|final_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
comment|/* Creating directory didn't work: Return all errors */
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
argument_list|)
return|;
else|else
comment|/* We could create a directory: retry install */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|ib
operator|->
name|tmp_path
argument_list|,
name|final_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream__install_get_info
parameter_list|(
name|apr_finfo_t
modifier|*
name|finfo
parameter_list|,
name|svn_stream_t
modifier|*
name|install_stream
parameter_list|,
name|apr_int32_t
name|wanted
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|install_baton_t
modifier|*
name|ib
init|=
name|install_stream
operator|->
name|baton
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
comment|/* On WIN32 the file is still open, so we can obtain the information      from the handle without race conditions */
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|apr_file_info_get
argument_list|(
name|finfo
argument_list|,
name|wanted
argument_list|,
name|ib
operator|->
name|baton_apr
operator|.
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
else|#
directive|else
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
name|finfo
argument_list|,
name|ib
operator|->
name|tmp_path
argument_list|,
name|wanted
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stream__install_delete
parameter_list|(
name|svn_stream_t
modifier|*
name|install_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|install_baton_t
modifier|*
name|ib
init|=
name|install_stream
operator|->
name|baton
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Mark the file as delete on close to avoid having to reopen      the file as part of the delete handling. */
name|err
operator|=
name|svn_io__win_delete_file_on_close
argument_list|(
name|ib
operator|->
name|baton_apr
operator|.
name|file
argument_list|,
name|ib
operator|->
name|tmp_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|ib
operator|->
name|baton_apr
operator|.
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* File is already gone */
block|}
comment|/* Deleting file on close may be unsupported, so ignore errors and      fallback to svn_io_remove_file2(). */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|ib
operator|->
name|baton_apr
operator|.
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|svn_error_trace
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|ib
operator|->
name|tmp_path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

