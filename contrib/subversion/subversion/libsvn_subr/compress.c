begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * compress.c:  various data compression routines  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_error_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_function
specifier|const
name|char
modifier|*
name|svn_zlib__compiled_version
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|zlib_version_str
index|[]
init|=
name|ZLIB_VERSION
decl_stmt|;
return|return
name|zlib_version_str
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_zlib__runtime_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|zlibVersion
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* The zlib compressBound function was not exported until 1.2.0. */
end_comment

begin_if
if|#
directive|if
name|ZLIB_VERNUM
operator|>=
literal|0x1200
end_if

begin_define
define|#
directive|define
name|svnCompressBound
parameter_list|(
name|LEN
parameter_list|)
value|compressBound(LEN)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|svnCompressBound
parameter_list|(
name|LEN
parameter_list|)
value|((LEN) + ((LEN)>> 12) + ((LEN)>> 14) + 11)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For svndiff1, address/instruction/new data under this size will not    be compressed using zlib as a secondary compressor.  */
end_comment

begin_define
define|#
directive|define
name|MIN_COMPRESS_SIZE
value|512
end_define

begin_function
name|unsigned
name|char
modifier|*
name|svn__encode_uint
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|apr_uint64_t
name|val
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|apr_uint64_t
name|v
decl_stmt|;
comment|/* Figure out how many bytes we'll need.  */
name|v
operator|=
name|val
operator|>>
literal|7
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|v
operator|=
name|v
operator|>>
literal|7
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
comment|/* Encode the remaining bytes; n is always the number of bytes      coming after the one we're encoding.  */
while|while
condition|(
operator|--
name|n
operator|>=
literal|1
condition|)
operator|*
name|p
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
operator|(
name|val
operator|>>
operator|(
name|n
operator|*
literal|7
operator|)
operator|)
operator||
literal|0x80
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|const
name|unsigned
name|char
modifier|*
name|svn__decode_uint
parameter_list|(
name|apr_uint64_t
modifier|*
name|val
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
block|{
name|apr_uint64_t
name|temp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|+
name|SVN__MAX_ENCODED_UINT_LEN
operator|<
name|end
condition|)
name|end
operator|=
name|p
operator|+
name|SVN__MAX_ENCODED_UINT_LEN
expr_stmt|;
comment|/* Decode bytes until we're done. */
while|while
condition|(
name|SVN__PREDICT_TRUE
argument_list|(
name|p
operator|<
name|end
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x80
condition|)
block|{
operator|*
name|val
operator|=
operator|(
name|temp
operator|<<
literal|7
operator|)
operator||
name|c
expr_stmt|;
return|return
name|p
return|;
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|temp
operator|<<
literal|7
operator|)
operator||
operator|(
name|c
operator|&
literal|0x7f
operator|)
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* If IN is a string that is>= MIN_COMPRESS_SIZE and the COMPRESSION_LEVEL    is not SVN_DELTA_COMPRESSION_LEVEL_NONE, zlib compress it and places the    result in OUT, with an integer prepended specifying the original size.    If IN is< MIN_COMPRESS_SIZE, or if the compressed version of IN was no    smaller than the original IN, OUT will be a copy of IN with the size    prepended as an integer. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|zlib_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|out
parameter_list|,
name|int
name|compression_level
parameter_list|)
block|{
name|unsigned
name|long
name|endlen
decl_stmt|;
name|apr_size_t
name|intlen
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|SVN__MAX_ENCODED_UINT_LEN
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|p
operator|=
name|svn__encode_uint
argument_list|(
name|buf
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|out
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
name|intlen
operator|=
name|out
operator|->
name|len
expr_stmt|;
comment|/* Compression initialization overhead is considered to large for      short buffers.  Also, if we don't actually want to compress data,      ZLIB will produce an output no shorter than the input.  Hence,      the DATA would directly appended to OUT, so we can do that directly      without calling ZLIB before. */
if|if
condition|(
name|len
operator|<
name|MIN_COMPRESS_SIZE
operator|||
name|compression_level
operator|==
name|SVN__COMPRESSION_NONE
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|out
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|zerr
decl_stmt|;
name|svn_stringbuf_ensure
argument_list|(
name|out
argument_list|,
name|svnCompressBound
argument_list|(
name|len
argument_list|)
operator|+
name|intlen
argument_list|)
expr_stmt|;
name|endlen
operator|=
name|out
operator|->
name|blocksize
expr_stmt|;
name|zerr
operator|=
name|compress2
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|out
operator|->
name|data
operator|+
name|intlen
argument_list|,
operator|&
name|endlen
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
name|len
argument_list|,
name|compression_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerr
operator|!=
name|Z_OK
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"compress2"
argument_list|,
name|_
argument_list|(
literal|"Compression of svndiff data failed"
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Compression didn't help :(, just append the original text */
if|if
condition|(
name|endlen
operator|>=
name|len
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|out
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|out
operator|->
name|len
operator|=
name|endlen
operator|+
name|intlen
expr_stmt|;
name|out
operator|->
name|data
index|[
name|out
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Decode the possibly-zlib compressed string of length INLEN that is in    IN, into OUT.  We expect an integer is prepended to IN that specifies    the original size, and that if encoded size == original size, that the    remaining data is not compressed.    In that case, we will simply return pointer into IN as data pointer for    OUT, COPYLESS_ALLOWED has been set.  The, the caller is expected not to    modify the contents of OUT.    An error is returned if the decoded length exceeds the given LIMIT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|zlib_decode
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|apr_size_t
name|inLen
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|out
parameter_list|,
name|apr_size_t
name|limit
parameter_list|)
block|{
name|apr_size_t
name|len
decl_stmt|;
name|apr_uint64_t
name|size
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|oldplace
init|=
name|in
decl_stmt|;
comment|/* First thing in the string is the original length.  */
name|in
operator|=
name|svn__decode_uint
argument_list|(
operator|&
name|size
argument_list|,
name|in
argument_list|,
name|in
operator|+
name|inLen
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|size
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
operator|||
name|len
operator|!=
name|size
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Decompression of zlib compressed data failed: no size"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|len
operator|>
name|limit
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Decompression of zlib compressed data failed: "
literal|"size too large"
argument_list|)
argument_list|)
return|;
comment|/* We need to subtract the size of the encoded original length off the    *      still remaining input length.  */
name|inLen
operator|-=
operator|(
name|in
operator|-
name|oldplace
operator|)
expr_stmt|;
if|if
condition|(
name|inLen
operator|==
name|len
condition|)
block|{
name|svn_stringbuf_ensure
argument_list|(
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
operator|->
name|data
argument_list|,
name|in
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|out
operator|->
name|data
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|len
operator|=
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
name|unsigned
name|long
name|zlen
init|=
name|len
decl_stmt|;
name|int
name|zerr
decl_stmt|;
name|svn_stringbuf_ensure
argument_list|(
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|zerr
operator|=
name|uncompress
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|out
operator|->
name|data
argument_list|,
operator|&
name|zlen
argument_list|,
name|in
argument_list|,
name|inLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerr
operator|!=
name|Z_OK
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error__wrap_zlib
argument_list|(
name|zerr
argument_list|,
literal|"uncompress"
argument_list|,
name|_
argument_list|(
literal|"Decompression of svndiff data failed"
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Zlib should not produce something that has a different size than the          original length we stored. */
if|if
condition|(
name|zlen
operator|!=
name|len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Size of uncompressed data "
literal|"does not match stored original length"
argument_list|)
argument_list|)
return|;
name|out
operator|->
name|data
index|[
name|zlen
index|]
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|len
operator|=
name|zlen
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn__compress
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|in
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|out
parameter_list|,
name|int
name|compression_method
parameter_list|)
block|{
if|if
condition|(
name|compression_method
operator|<
name|SVN__COMPRESSION_NONE
operator|||
name|compression_method
operator|>
name|SVN__COMPRESSION_ZLIB_MAX
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_COMPRESSION_METHOD
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported compression method %d"
argument_list|)
argument_list|,
name|compression_method
argument_list|)
return|;
return|return
name|zlib_encode
argument_list|(
name|in
operator|->
name|data
argument_list|,
name|in
operator|->
name|len
argument_list|,
name|out
argument_list|,
name|compression_method
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn__decompress
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|in
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|out
parameter_list|,
name|apr_size_t
name|limit
parameter_list|)
block|{
return|return
name|zlib_decode
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|in
operator|->
name|data
argument_list|,
name|in
operator|->
name|len
argument_list|,
name|out
argument_list|,
name|limit
argument_list|)
return|;
block|}
end_function

end_unit

