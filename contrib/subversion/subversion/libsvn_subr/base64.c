begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * base64.c:  base64 encoding and decoding functions  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_comment
comment|/* for APR_INLINE */
end_comment

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_comment
comment|/* When asked to format the base64-encoded output as multiple lines,    we put this many chars in each line (plus one new line char) unless    we run out of data.    It is vital for some of the optimizations below that this value is    a multiple of 4. */
end_comment

begin_define
define|#
directive|define
name|BASE64_LINELEN
value|76
end_define

begin_comment
comment|/* This number of bytes is encoded in a line of base64 chars. */
end_comment

begin_define
define|#
directive|define
name|BYTES_PER_LINE
value|(BASE64_LINELEN / 4 * 3)
end_define

begin_comment
comment|/* Value -> base64 char mapping table (2^6 entries) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|base64tab
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
expr|\
literal|"abcdefghijklmnopqrstuvwxyz0123456789+/"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Binary input --> base64-encoded output */
end_comment

begin_struct
struct|struct
name|encode_baton
block|{
name|svn_stream_t
modifier|*
name|output
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
comment|/* Bytes waiting to be encoded */
name|size_t
name|buflen
decl_stmt|;
comment|/* Number of bytes waiting */
name|size_t
name|linelen
decl_stmt|;
comment|/* Bytes output so far on this line */
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Base64-encode a group.  IN needs to have three bytes and OUT needs    to have room for four bytes.  The input group is treated as four    six-bit units which are treated as lookups into base64tab for the    bytes of the output group.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
name|encode_group
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
block|{
comment|/* Expand input bytes to machine word length (with zero extra cost      on x86/x64) ... */
name|apr_size_t
name|part0
init|=
name|in
index|[
literal|0
index|]
decl_stmt|;
name|apr_size_t
name|part1
init|=
name|in
index|[
literal|1
index|]
decl_stmt|;
name|apr_size_t
name|part2
init|=
name|in
index|[
literal|2
index|]
decl_stmt|;
comment|/* ... to prevent these arithmetic operations from being limited to      byte size.  This saves non-zero cost conversions of the result when      calculating the addresses within base64tab. */
name|out
index|[
literal|0
index|]
operator|=
name|base64tab
index|[
name|part0
operator|>>
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|base64tab
index|[
operator|(
operator|(
name|part0
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|part1
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|base64tab
index|[
operator|(
operator|(
name|part1
operator|&
literal|0xf
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
name|part2
operator|>>
literal|6
operator|)
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|base64tab
index|[
name|part2
operator|&
literal|0x3f
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Base64-encode a line, i.e. BYTES_PER_LINE bytes from DATA into    BASE64_LINELEN chars and append it to STR.  It does not assume that    a new line char will be appended, though.    The code in this function will simply transform the data without    performing any boundary checks.  Therefore, DATA must have at least    BYTES_PER_LINE left and space for at least another BASE64_LINELEN    chars must have been pre-allocated in STR before calling this    function. */
end_comment

begin_function
specifier|static
name|void
name|encode_line
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
comment|/* Translate directly from DATA to STR->DATA. */
specifier|const
name|unsigned
name|char
modifier|*
name|in
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|str
operator|->
name|data
operator|+
name|str
operator|->
name|len
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|out
operator|+
name|BASE64_LINELEN
decl_stmt|;
comment|/* We assume that BYTES_PER_LINE is a multiple of 3 and BASE64_LINELEN      a multiple of 4. */
for|for
control|(
init|;
name|out
operator|!=
name|end
condition|;
name|in
operator|+=
literal|3
operator|,
name|out
operator|+=
literal|4
control|)
name|encode_group
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Expand and terminate the string. */
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|len
operator|+=
name|BASE64_LINELEN
expr_stmt|;
block|}
end_function

begin_comment
comment|/* (Continue to) Base64-encode the byte string DATA (of length LEN)    into STR. Include newlines every so often if BREAK_LINES is true.    INBUF, INBUFLEN, and LINELEN are used internally; the caller shall    make INBUF have room for three characters and initialize *INBUFLEN    and *LINELEN to 0.     INBUF and *INBUFLEN carry the leftover data from call to call, and    *LINELEN carries the length of the current output line. */
end_comment

begin_function
specifier|static
name|void
name|encode_bytes
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|inbuf
parameter_list|,
name|size_t
modifier|*
name|inbuflen
parameter_list|,
name|size_t
modifier|*
name|linelen
parameter_list|,
name|svn_boolean_t
name|break_lines
parameter_list|)
block|{
name|char
name|group
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|data
decl_stmt|,
modifier|*
name|end
init|=
name|p
operator|+
name|len
decl_stmt|;
name|apr_size_t
name|buflen
decl_stmt|;
comment|/* Resize the stringbuf to make room for the (approximate) size of      output, to avoid repeated resizes later.      Please note that our optimized code relies on the fact that STR      never needs to be resized until we leave this function. */
name|buflen
operator|=
name|len
operator|*
literal|4
operator|/
literal|3
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|break_lines
condition|)
block|{
comment|/* Add an extra space for line breaks. */
name|buflen
operator|+=
name|buflen
operator|/
name|BASE64_LINELEN
expr_stmt|;
block|}
name|svn_stringbuf_ensure
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|len
operator|+
name|buflen
argument_list|)
expr_stmt|;
comment|/* Keep encoding three-byte groups until we run out.  */
while|while
condition|(
operator|*
name|inbuflen
operator|+
operator|(
name|end
operator|-
name|p
operator|)
operator|>=
literal|3
condition|)
block|{
comment|/* May we encode BYTES_PER_LINE bytes without caring about          line breaks, data in the temporary INBUF or running out          of data? */
if|if
condition|(
operator|*
name|inbuflen
operator|==
literal|0
operator|&&
operator|(
operator|*
name|linelen
operator|==
literal|0
operator|||
operator|!
name|break_lines
operator|)
operator|&&
operator|(
name|end
operator|-
name|p
operator|>=
name|BYTES_PER_LINE
operator|)
condition|)
block|{
comment|/* Yes, we can encode a whole chunk of data at once. */
name|encode_line
argument_list|(
name|str
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|BYTES_PER_LINE
expr_stmt|;
operator|*
name|linelen
operator|+=
name|BASE64_LINELEN
expr_stmt|;
block|}
else|else
block|{
comment|/* No, this is one of a number of special cases.              Encode the data byte by byte. */
name|memcpy
argument_list|(
name|inbuf
operator|+
operator|*
name|inbuflen
argument_list|,
name|p
argument_list|,
literal|3
operator|-
operator|*
name|inbuflen
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
literal|3
operator|-
operator|*
name|inbuflen
operator|)
expr_stmt|;
name|encode_group
argument_list|(
name|inbuf
argument_list|,
name|group
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|group
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|inbuflen
operator|=
literal|0
expr_stmt|;
operator|*
name|linelen
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Add line breaks as necessary. */
if|if
condition|(
name|break_lines
operator|&&
operator|*
name|linelen
operator|==
name|BASE64_LINELEN
condition|)
block|{
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
operator|*
name|linelen
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Tack any extra input onto *INBUF.  */
name|memcpy
argument_list|(
name|inbuf
operator|+
operator|*
name|inbuflen
argument_list|,
name|p
argument_list|,
name|end
operator|-
name|p
argument_list|)
expr_stmt|;
operator|*
name|inbuflen
operator|+=
operator|(
name|end
operator|-
name|p
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encode leftover data, if any, and possibly a final newline (if    there has been any data and BREAK_LINES is set), appending to STR.    LEN must be in the range 0..2.  */
end_comment

begin_function
specifier|static
name|void
name|encode_partial_group
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|extra
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
name|linelen
parameter_list|,
name|svn_boolean_t
name|break_lines
parameter_list|)
block|{
name|unsigned
name|char
name|ingroup
index|[
literal|3
index|]
decl_stmt|;
name|char
name|outgroup
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ingroup
argument_list|,
name|extra
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ingroup
operator|+
name|len
argument_list|,
literal|0
argument_list|,
literal|3
operator|-
name|len
argument_list|)
expr_stmt|;
name|encode_group
argument_list|(
name|ingroup
argument_list|,
name|outgroup
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|outgroup
operator|+
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|,
literal|'='
argument_list|,
literal|4
operator|-
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|outgroup
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|linelen
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|break_lines
operator|&&
name|linelen
operator|>
literal|0
condition|)
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write handler for svn_base64_encode.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|encode_data
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|encode_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|encoded
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|eb
operator|->
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_size_t
name|enclen
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* Encode this block of data and write it out.  */
name|encode_bytes
argument_list|(
name|encoded
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|,
name|eb
operator|->
name|buf
argument_list|,
operator|&
name|eb
operator|->
name|buflen
argument_list|,
operator|&
name|eb
operator|->
name|linelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|enclen
operator|=
name|encoded
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|enclen
operator|!=
literal|0
condition|)
name|err
operator|=
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
name|encoded
operator|->
name|data
argument_list|,
operator|&
name|enclen
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|eb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Close handler for svn_base64_encode().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|finish_encoding_data
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|encode_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|encoded
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|eb
operator|->
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_size_t
name|enclen
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* Encode a partial group at the end if necessary, and write it out.  */
name|encode_partial_group
argument_list|(
name|encoded
argument_list|,
name|eb
operator|->
name|buf
argument_list|,
name|eb
operator|->
name|buflen
argument_list|,
name|eb
operator|->
name|linelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|enclen
operator|=
name|encoded
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|enclen
operator|!=
literal|0
condition|)
name|err
operator|=
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
name|encoded
operator|->
name|data
argument_list|,
operator|&
name|enclen
argument_list|)
expr_stmt|;
comment|/* Pass on the close request and clean up the baton.  */
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
name|err
operator|=
name|svn_stream_close
argument_list|(
name|eb
operator|->
name|output
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|eb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_base64_encode
parameter_list|(
name|svn_stream_t
modifier|*
name|output
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|encode_baton
modifier|*
name|eb
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|eb
operator|->
name|output
operator|=
name|output
expr_stmt|;
name|eb
operator|->
name|buflen
operator|=
literal|0
expr_stmt|;
name|eb
operator|->
name|linelen
operator|=
literal|0
expr_stmt|;
name|eb
operator|->
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|eb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|encode_data
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|finish_encoding_data
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
specifier|const
name|svn_string_t
modifier|*
name|svn_base64_encode_string2
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str
parameter_list|,
name|svn_boolean_t
name|break_lines
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|encoded
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|ingroup
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|ingrouplen
init|=
literal|0
decl_stmt|;
name|size_t
name|linelen
init|=
literal|0
decl_stmt|;
name|encode_bytes
argument_list|(
name|encoded
argument_list|,
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|,
name|ingroup
argument_list|,
operator|&
name|ingrouplen
argument_list|,
operator|&
name|linelen
argument_list|,
name|break_lines
argument_list|)
expr_stmt|;
name|encode_partial_group
argument_list|(
name|encoded
argument_list|,
name|ingroup
argument_list|,
name|ingrouplen
argument_list|,
name|linelen
argument_list|,
name|break_lines
argument_list|)
expr_stmt|;
return|return
name|svn_stringbuf__morph_into_string
argument_list|(
name|encoded
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|svn_string_t
modifier|*
name|svn_base64_encode_string
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_base64_encode_string2
argument_list|(
name|str
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Base64-encoded input --> binary output */
end_comment

begin_struct
struct|struct
name|decode_baton
block|{
name|svn_stream_t
modifier|*
name|output
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Bytes waiting to be decoded */
name|int
name|buflen
decl_stmt|;
comment|/* Number of bytes waiting */
name|svn_boolean_t
name|done
decl_stmt|;
comment|/* True if we already saw an '=' */
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Base64-decode a group.  IN needs to have four bytes and OUT needs    to have room for three bytes.  The input bytes must already have    been decoded from base64tab into the range 0..63.  The four    six-bit values are pasted together to form three eight-bit bytes.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
name|decode_group
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|in
index|[
literal|0
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|in
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|in
index|[
literal|1
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|in
index|[
literal|2
index|]
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|in
index|[
literal|2
index|]
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
operator||
name|in
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup table for base64 characters; reverse_base64[ch] gives a    negative value if ch is not a valid base64 character, or otherwise    the value of the byte represented; 'A' => 0 etc. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|signed
name|char
name|reverse_base64
index|[
literal|256
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|62
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|63
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar to decode_group but this function also translates the    6-bit values from the IN buffer before translating them.    Return FALSE if a non-base64 char (e.g. '=' or new line)    has been encountered. */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|svn_boolean_t
name|decode_group_directly
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
block|{
comment|/* Translate the base64 chars in values [0..63, 0xff] */
name|apr_size_t
name|part0
init|=
operator|(
name|unsigned
name|char
operator|)
name|reverse_base64
index|[
operator|(
name|unsigned
name|char
operator|)
name|in
index|[
literal|0
index|]
index|]
decl_stmt|;
name|apr_size_t
name|part1
init|=
operator|(
name|unsigned
name|char
operator|)
name|reverse_base64
index|[
operator|(
name|unsigned
name|char
operator|)
name|in
index|[
literal|1
index|]
index|]
decl_stmt|;
name|apr_size_t
name|part2
init|=
operator|(
name|unsigned
name|char
operator|)
name|reverse_base64
index|[
operator|(
name|unsigned
name|char
operator|)
name|in
index|[
literal|2
index|]
index|]
decl_stmt|;
name|apr_size_t
name|part3
init|=
operator|(
name|unsigned
name|char
operator|)
name|reverse_base64
index|[
operator|(
name|unsigned
name|char
operator|)
name|in
index|[
literal|3
index|]
index|]
decl_stmt|;
comment|/* Pack 4x6 bits into 3x8.*/
name|out
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|part0
operator|<<
literal|2
operator|)
operator||
operator|(
name|part1
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|part1
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|part2
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|part2
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
operator||
name|part3
argument_list|)
expr_stmt|;
comment|/* FALSE, iff any part is 0xff. */
return|return
operator|(
name|part0
operator||
name|part1
operator||
name|part2
operator||
name|part3
operator|)
operator|!=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Base64-encode up to BASE64_LINELEN chars from *DATA and append it to    STR.  After the function returns, *DATA will point to the first char    that has not been translated, yet.  Returns TRUE if all BASE64_LINELEN    chars could be translated, i.e. no special char has been encountered    in between.    The code in this function will simply transform the data without    performing any boundary checks.  Therefore, DATA must have at least    BASE64_LINELEN left and space for at least another BYTES_PER_LINE    chars must have been pre-allocated in STR before calling this    function. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|decode_line
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|)
block|{
comment|/* Decode up to BYTES_PER_LINE bytes directly from *DATA into STR->DATA. */
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|*
operator|)
name|data
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|str
operator|->
name|data
operator|+
name|str
operator|->
name|len
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|out
operator|+
name|BYTES_PER_LINE
decl_stmt|;
comment|/* We assume that BYTES_PER_LINE is a multiple of 3 and BASE64_LINELEN      a multiple of 4.  Stop translation as soon as we encounter a special      char.  Leave the entire group untouched in that case. */
for|for
control|(
init|;
name|out
operator|<
name|end
condition|;
name|p
operator|+=
literal|4
operator|,
name|out
operator|+=
literal|3
control|)
if|if
condition|(
operator|!
name|decode_group_directly
argument_list|(
name|p
argument_list|,
name|out
argument_list|)
condition|)
break|break;
comment|/* Update string sizes and positions. */
name|str
operator|->
name|len
operator|=
name|out
operator|-
name|str
operator|->
name|data
expr_stmt|;
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|data
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
comment|/* Return FALSE, if the caller should continue the decoding process      using the slow standard method. */
return|return
name|out
operator|==
name|end
return|;
block|}
end_function

begin_comment
comment|/* (Continue to) Base64-decode the byte string DATA (of length LEN)    into STR. INBUF, INBUFLEN, and DONE are used internally; the    caller shall have room for four bytes in INBUF and initialize    *INBUFLEN to 0 and *DONE to FALSE.     INBUF and *INBUFLEN carry the leftover bytes from call to call, and    *DONE keeps track of whether we've seen an '=' which terminates the    encoded data. */
end_comment

begin_function
specifier|static
name|void
name|decode_bytes
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|inbuf
parameter_list|,
name|int
modifier|*
name|inbuflen
parameter_list|,
name|svn_boolean_t
modifier|*
name|done
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|data
decl_stmt|;
name|char
name|group
index|[
literal|3
index|]
decl_stmt|;
name|signed
name|char
name|find
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
comment|/* Resize the stringbuf to make room for the maximum size of output,      to avoid repeated resizes later.  The optimizations in      decode_line rely on no resizes being necessary!       (*inbuflen+len) is encoded data length      (*inbuflen+len)/4 is the number of complete 4-bytes sets      (*inbuflen+len)/4*3 is the number of decoded bytes      svn_stringbuf_ensure will add an additional byte for the terminating 0.   */
name|svn_stringbuf_ensure
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|len
operator|+
operator|(
operator|(
operator|*
name|inbuflen
operator|+
name|len
operator|)
operator|/
literal|4
operator|)
operator|*
literal|3
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|*
name|done
operator|&&
name|p
operator|<
name|end
condition|)
block|{
comment|/* If no data is left in temporary INBUF and there is at least          one line-sized chunk left to decode, we may use the optimized          code path. */
if|if
condition|(
operator|(
operator|*
name|inbuflen
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|+
name|BASE64_LINELEN
operator|<=
name|end
operator|)
condition|)
if|if
condition|(
name|decode_line
argument_list|(
name|str
argument_list|,
operator|&
name|p
argument_list|)
condition|)
continue|continue;
comment|/* A special case or decode_line encountered a special char. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
comment|/* We are at the end and have to decode a partial group.  */
if|if
condition|(
operator|*
name|inbuflen
operator|>=
literal|2
condition|)
block|{
name|memset
argument_list|(
name|inbuf
operator|+
operator|*
name|inbuflen
argument_list|,
literal|0
argument_list|,
literal|4
operator|-
operator|*
name|inbuflen
argument_list|)
expr_stmt|;
name|decode_group
argument_list|(
name|inbuf
argument_list|,
name|group
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|group
argument_list|,
operator|*
name|inbuflen
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|find
operator|=
name|reverse_base64
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
expr_stmt|;
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|find
operator|>=
literal|0
condition|)
name|inbuf
index|[
operator|(
operator|*
name|inbuflen
operator|)
operator|++
index|]
operator|=
name|find
expr_stmt|;
if|if
condition|(
operator|*
name|inbuflen
operator|==
literal|4
condition|)
block|{
name|decode_group
argument_list|(
name|inbuf
argument_list|,
name|group
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|group
argument_list|,
literal|3
argument_list|)
expr_stmt|;
operator|*
name|inbuflen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write handler for svn_base64_decode.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|decode_data
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|decode_baton
modifier|*
name|db
init|=
name|baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|decoded
decl_stmt|;
name|apr_size_t
name|declen
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* Decode this block of data.  */
name|decoded
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|db
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|decode_bytes
argument_list|(
name|decoded
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|,
name|db
operator|->
name|buf
argument_list|,
operator|&
name|db
operator|->
name|buflen
argument_list|,
operator|&
name|db
operator|->
name|done
argument_list|)
expr_stmt|;
comment|/* Write the output, clean up, go home.  */
name|declen
operator|=
name|decoded
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|declen
operator|!=
literal|0
condition|)
name|err
operator|=
name|svn_stream_write
argument_list|(
name|db
operator|->
name|output
argument_list|,
name|decoded
operator|->
name|data
argument_list|,
operator|&
name|declen
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|db
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Close handler for svn_base64_decode().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|finish_decoding_data
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|decode_baton
modifier|*
name|db
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Pass on the close request and clean up the baton.  */
name|err
operator|=
name|svn_stream_close
argument_list|(
name|db
operator|->
name|output
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|db
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_base64_decode
parameter_list|(
name|svn_stream_t
modifier|*
name|output
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|decode_baton
modifier|*
name|db
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|db
operator|->
name|output
operator|=
name|output
expr_stmt|;
name|db
operator|->
name|buflen
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|done
operator|=
name|FALSE
expr_stmt|;
name|db
operator|->
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|db
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|decode_data
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|finish_decoding_data
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
specifier|const
name|svn_string_t
modifier|*
name|svn_base64_decode_string
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|decoded
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|ingroup
index|[
literal|4
index|]
decl_stmt|;
name|int
name|ingrouplen
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|done
init|=
name|FALSE
decl_stmt|;
name|decode_bytes
argument_list|(
name|decoded
argument_list|,
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|,
name|ingroup
argument_list|,
operator|&
name|ingrouplen
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
return|return
name|svn_stringbuf__morph_into_string
argument_list|(
name|decoded
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a base64-encoded representation of CHECKSUM, allocated in POOL.    If CHECKSUM->kind is not recognized, return NULL.    ### That 'NULL' claim was in the header file when this was public, but    doesn't look true in the implementation.     ### This is now only used as a new implementation of svn_base64_from_md5();    it would probably be safer to revert that to its old implementation. */
end_comment

begin_function
specifier|static
name|svn_stringbuf_t
modifier|*
name|base64_from_checksum
parameter_list|(
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|checksum_str
decl_stmt|;
name|unsigned
name|char
name|ingroup
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|ingrouplen
init|=
literal|0
decl_stmt|;
name|size_t
name|linelen
init|=
literal|0
decl_stmt|;
name|checksum_str
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|encode_bytes
argument_list|(
name|checksum_str
argument_list|,
name|checksum
operator|->
name|digest
argument_list|,
name|svn_checksum_size
argument_list|(
name|checksum
argument_list|)
argument_list|,
name|ingroup
argument_list|,
operator|&
name|ingrouplen
argument_list|,
operator|&
name|linelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|encode_partial_group
argument_list|(
name|checksum_str
argument_list|,
name|ingroup
argument_list|,
name|ingrouplen
argument_list|,
name|linelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Our base64-encoding routines append a final newline if any data      was created at all, so let's hack that off. */
if|if
condition|(
name|checksum_str
operator|->
name|len
condition|)
block|{
name|checksum_str
operator|->
name|len
operator|--
expr_stmt|;
name|checksum_str
operator|->
name|data
index|[
name|checksum_str
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|checksum_str
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_base64_from_md5
parameter_list|(
name|unsigned
name|char
name|digest
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
init|=
name|svn_checksum__from_digest_md5
argument_list|(
name|digest
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|base64_from_checksum
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

end_unit

