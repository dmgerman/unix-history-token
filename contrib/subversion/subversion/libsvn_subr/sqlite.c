begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sqlite.c  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"internal_statements.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sqlite.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_token.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE3_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"private/svn_debug.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_SQLITE_INLINE
end_ifdef

begin_comment
comment|/* Import the sqlite3 API vtable from sqlite3wrapper.c */
end_comment

begin_define
define|#
directive|define
name|SQLITE_OMIT_DEPRECATED
end_define

begin_include
include|#
directive|include
file|<sqlite3ext.h>
end_include

begin_decl_stmt
specifier|extern
specifier|const
name|sqlite3_api_routines
modifier|*
specifier|const
name|svn_sqlite3__api_funcs
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern int (*const svn_sqlite3__api_initialize
end_extern

begin_expr_stmt
unit|)
operator|(
name|void
operator|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern int (*const svn_sqlite3__api_config
end_extern

begin_expr_stmt
unit|)
operator|(
name|int
operator|,
operator|...
operator|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|sqlite3_api
value|svn_sqlite3__api_funcs
end_define

begin_define
define|#
directive|define
name|sqlite3_initialize
value|svn_sqlite3__api_initialize
end_define

begin_define
define|#
directive|define
name|sqlite3_config
value|svn_sqlite3__api_config
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sqlite3.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|SQLITE_VERSION_AT_LEAST
argument_list|(
literal|3
operator|,
literal|7
operator|,
literal|12
argument_list|)
end_if

begin_error
error|#
directive|error
error|SQLite is too old -- version 3.7.12 is the minimum required version
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|char
modifier|*
name|svn_sqlite__compiled_version
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|sqlite_version
index|[]
init|=
name|SQLITE_VERSION
decl_stmt|;
return|return
name|sqlite_version
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_sqlite__runtime_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|sqlite3_libversion
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|INTERNAL_STATEMENTS_SQL_DECLARE_STATEMENTS
argument_list|(
name|internal_statements
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE3_DEBUG
end_ifdef

begin_comment
comment|/* An sqlite query execution callback. */
end_comment

begin_function
specifier|static
name|void
name|sqlite_tracer
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|sql
parameter_list|)
block|{
comment|/*  sqlite3 *db3 = data; */
name|SVN_DBG
argument_list|(
operator|(
literal|"sql=\"%s\"\n"
operator|,
name|sql
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE3_PROFILE
end_ifdef

begin_comment
comment|/* An sqlite execution timing callback. */
end_comment

begin_function
specifier|static
name|void
name|sqlite_profiler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|sql
parameter_list|,
name|sqlite3_uint64
name|duration
parameter_list|)
block|{
comment|/*  sqlite3 *db3 = data; */
name|SVN_DBG
argument_list|(
operator|(
literal|"[%.3f] sql=\"%s\"\n"
operator|,
literal|1e-9
operator|*
name|duration
operator|,
name|sql
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|svn_sqlite__db_t
block|{
name|sqlite3
modifier|*
name|db3
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|statement_strings
decl_stmt|;
name|int
name|nbr_statements
decl_stmt|;
name|svn_sqlite__stmt_t
modifier|*
modifier|*
name|prepared_stmts
decl_stmt|;
name|apr_pool_t
modifier|*
name|state_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|svn_sqlite__stmt_t
block|{
name|sqlite3_stmt
modifier|*
name|s3stmt
decl_stmt|;
name|svn_sqlite__db_t
modifier|*
name|db
decl_stmt|;
name|svn_boolean_t
name|needs_reset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|svn_sqlite__context_t
block|{
name|sqlite3_context
modifier|*
name|context
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|svn_sqlite__value_t
block|{
name|sqlite3_value
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Convert SQLite error codes to SVN. Evaluates X multiple times */
end_comment

begin_define
define|#
directive|define
name|SQLITE_ERROR_CODE
parameter_list|(
name|x
parameter_list|)
value|((x) == SQLITE_READONLY            \                               ? SVN_ERR_SQLITE_READONLY         \                               : ((x) == SQLITE_BUSY             \                                  ? SVN_ERR_SQLITE_BUSY          \                                  : ((x) == SQLITE_CONSTRAINT    \                                     ? SVN_ERR_SQLITE_CONSTRAINT \                                     : SVN_ERR_SQLITE_ERROR)))
end_define

begin_comment
comment|/* SQLITE->SVN quick error wrap, much like SVN_ERR. */
end_comment

begin_define
define|#
directive|define
name|SQLITE_ERR
parameter_list|(
name|x
parameter_list|,
name|db
parameter_list|)
value|do                                     \ {                                                                \   int sqlite_err__temp = (x);                                    \   if (sqlite_err__temp != SQLITE_OK)                             \     return svn_error_createf(SQLITE_ERROR_CODE(sqlite_err__temp), \                              NULL, "sqlite[S%d]: %s",             \                              sqlite_err__temp,                    \                              sqlite3_errmsg((db)->db3));          \ } while (0)
end_define

begin_define
define|#
directive|define
name|SQLITE_ERR_MSG
parameter_list|(
name|x
parameter_list|,
name|msg
parameter_list|)
value|do                                \ {                                                                \   int sqlite_err__temp = (x);                                    \   if (sqlite_err__temp != SQLITE_OK)                             \     return svn_error_createf(SQLITE_ERROR_CODE(sqlite_err__temp), \                              NULL, "sqlite[S%d]: %s",            \                              sqlite_err__temp, msg);             \ } while (0)
end_define

begin_comment
comment|/* Time (in milliseconds) to wait for sqlite locks before giving up. */
end_comment

begin_define
define|#
directive|define
name|BUSY_TIMEOUT
value|10000
end_define

begin_comment
comment|/* Convenience wrapper around exec_sql2(). */
end_comment

begin_define
define|#
directive|define
name|exec_sql
parameter_list|(
name|db
parameter_list|,
name|sql
parameter_list|)
value|exec_sql2((db), (sql), SQLITE_OK)
end_define

begin_comment
comment|/* Run the statement SQL on DB, ignoring SQLITE_OK and IGNORED_ERR.    (Note: the IGNORED_ERR parameter itself is not ignored.) */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|exec_sql2
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|sql
parameter_list|,
name|int
name|ignored_err
parameter_list|)
block|{
name|char
modifier|*
name|err_msg
decl_stmt|;
name|int
name|sqlite_err
init|=
name|sqlite3_exec
argument_list|(
name|db
operator|->
name|db3
argument_list|,
name|sql
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|err_msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqlite_err
operator|!=
name|SQLITE_OK
operator|&&
name|sqlite_err
operator|!=
name|ignored_err
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_createf
argument_list|(
name|SQLITE_ERROR_CODE
argument_list|(
name|sqlite_err
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"sqlite[S%d]: %s,"
literal|" executing statement '%s'"
argument_list|)
argument_list|,
name|sqlite_err
argument_list|,
name|err_msg
argument_list|,
name|sql
argument_list|)
decl_stmt|;
name|sqlite3_free
argument_list|(
name|err_msg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prepare_statement
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
modifier|*
name|stmt
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
operator|*
name|stmt
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|stmt
operator|)
operator|->
name|db
operator|=
name|db
expr_stmt|;
operator|(
operator|*
name|stmt
operator|)
operator|->
name|needs_reset
operator|=
name|FALSE
expr_stmt|;
name|SQLITE_ERR
argument_list|(
name|sqlite3_prepare_v2
argument_list|(
name|db
operator|->
name|db3
argument_list|,
name|text
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
operator|(
operator|*
name|stmt
operator|)
operator|->
name|s3stmt
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__exec_statements
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|int
name|stmt_idx
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|stmt_idx
operator|<
name|db
operator|->
name|nbr_statements
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|exec_sql
argument_list|(
name|db
argument_list|,
name|db
operator|->
name|statement_strings
index|[
name|stmt_idx
index|]
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__get_statement
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
modifier|*
name|stmt
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|int
name|stmt_idx
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|stmt_idx
operator|<
name|db
operator|->
name|nbr_statements
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|prepared_stmts
index|[
name|stmt_idx
index|]
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|prepare_statement
argument_list|(
operator|&
name|db
operator|->
name|prepared_stmts
index|[
name|stmt_idx
index|]
argument_list|,
name|db
argument_list|,
name|db
operator|->
name|statement_strings
index|[
name|stmt_idx
index|]
argument_list|,
name|db
operator|->
name|state_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stmt
operator|=
name|db
operator|->
name|prepared_stmts
index|[
name|stmt_idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|stmt
operator|)
operator|->
name|needs_reset
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__reset
argument_list|(
operator|*
name|stmt
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Like svn_sqlite__get_statement but gets an internal statement.     All internal statements that use this api are executed with step_done(),    so we don't need the fallback reset handling here or in the pool cleanup */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_internal_statement
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
modifier|*
name|stmt
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|int
name|stmt_idx
parameter_list|)
block|{
comment|/* The internal statements are stored after the registered statements */
name|int
name|prep_idx
init|=
name|db
operator|->
name|nbr_statements
operator|+
name|stmt_idx
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|stmt_idx
operator|<
name|STMT_INTERNAL_LAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|prepared_stmts
index|[
name|prep_idx
index|]
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|prepare_statement
argument_list|(
operator|&
name|db
operator|->
name|prepared_stmts
index|[
name|prep_idx
index|]
argument_list|,
name|db
argument_list|,
name|internal_statements
index|[
name|stmt_idx
index|]
argument_list|,
name|db
operator|->
name|state_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stmt
operator|=
name|db
operator|->
name|prepared_stmts
index|[
name|prep_idx
index|]
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|step_with_expectation
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|svn_boolean_t
name|expecting_row
parameter_list|)
block|{
name|svn_boolean_t
name|got_row
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|got_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|got_row
operator|&&
operator|!
name|expecting_row
operator|)
operator|||
operator|(
operator|!
name|got_row
operator|&&
name|expecting_row
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SQLITE_ERROR
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|expecting_row
condition|?
name|_
argument_list|(
literal|"sqlite: Expected database row missing"
argument_list|)
else|:
name|_
argument_list|(
literal|"sqlite: Extra database row found"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__step_done
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|step_with_expectation
argument_list|(
name|stmt
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__step_row
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|step_with_expectation
argument_list|(
name|stmt
argument_list|,
name|TRUE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__step
parameter_list|(
name|svn_boolean_t
modifier|*
name|got_row
parameter_list|,
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|)
block|{
name|int
name|sqlite_result
init|=
name|sqlite3_step
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqlite_result
operator|!=
name|SQLITE_DONE
operator|&&
name|sqlite_result
operator|!=
name|SQLITE_ROW
condition|)
block|{
name|svn_error_t
modifier|*
name|err1
decl_stmt|,
modifier|*
name|err2
decl_stmt|;
name|err1
operator|=
name|svn_error_createf
argument_list|(
name|SQLITE_ERROR_CODE
argument_list|(
name|sqlite_result
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|"sqlite[S%d]: %s"
argument_list|,
name|sqlite_result
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|stmt
operator|->
name|db
operator|->
name|db3
argument_list|)
argument_list|)
expr_stmt|;
name|err2
operator|=
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err1
argument_list|,
name|err2
argument_list|)
return|;
block|}
operator|*
name|got_row
operator|=
operator|(
name|sqlite_result
operator|==
name|SQLITE_ROW
operator|)
expr_stmt|;
name|stmt
operator|->
name|needs_reset
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__insert
parameter_list|(
name|apr_int64_t
modifier|*
name|row_id
parameter_list|,
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|)
block|{
name|svn_boolean_t
name|got_row
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|got_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_id
condition|)
operator|*
name|row_id
operator|=
name|sqlite3_last_insert_rowid
argument_list|(
name|stmt
operator|->
name|db
operator|->
name|db3
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__update
parameter_list|(
name|int
modifier|*
name|affected_rows
parameter_list|,
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|step_with_expectation
argument_list|(
name|stmt
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|affected_rows
condition|)
operator|*
name|affected_rows
operator|=
name|sqlite3_changes
argument_list|(
name|stmt
operator|->
name|db
operator|->
name|db3
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|vbindf
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|1
init|;
operator|*
name|fmt
condition|;
name|fmt
operator|++
operator|,
name|count
operator|++
control|)
block|{
specifier|const
name|void
modifier|*
name|blob
decl_stmt|;
name|apr_size_t
name|blob_size
decl_stmt|;
specifier|const
name|svn_token_map_t
modifier|*
name|map
decl_stmt|;
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'s'
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_text
argument_list|(
name|stmt
argument_list|,
name|count
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_int
argument_list|(
name|stmt
argument_list|,
name|count
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'L'
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_int64
argument_list|(
name|stmt
argument_list|,
name|count
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_int64_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|blob
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
name|blob_size
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_size_t
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_blob
argument_list|(
name|stmt
argument_list|,
name|count
argument_list|,
name|blob
argument_list|,
name|blob_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_revnum
argument_list|(
name|stmt
argument_list|,
name|count
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|svn_revnum_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|map
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|svn_token_map_t
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bind_token
argument_list|(
name|stmt
argument_list|,
name|count
argument_list|,
name|map
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Skip this column: no binding */
break|break;
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bindf
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|err
operator|=
name|vbindf
argument_list|(
name|stmt
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bind_int
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|SQLITE_ERR
argument_list|(
name|sqlite3_bind_int
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|slot
argument_list|,
name|val
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bind_int64
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|apr_int64_t
name|val
parameter_list|)
block|{
name|SQLITE_ERR
argument_list|(
name|sqlite3_bind_int64
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|slot
argument_list|,
name|val
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bind_text
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|SQLITE_ERR
argument_list|(
name|sqlite3_bind_text
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|slot
argument_list|,
name|val
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bind_blob
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|SQLITE_ERR
argument_list|(
name|sqlite3_bind_blob
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|slot
argument_list|,
name|val
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bind_token
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|svn_token_map_t
modifier|*
name|map
parameter_list|,
name|int
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|word
init|=
name|svn_token__to_word
argument_list|(
name|map
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|SQLITE_ERR
argument_list|(
name|sqlite3_bind_text
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|slot
argument_list|,
name|word
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bind_revnum
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|svn_revnum_t
name|value
parameter_list|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|value
argument_list|)
condition|)
name|SQLITE_ERR
argument_list|(
name|sqlite3_bind_int64
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|slot
argument_list|,
operator|(
name|sqlite_int64
operator|)
name|value
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
else|else
name|SQLITE_ERR
argument_list|(
name|sqlite3_bind_null
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|slot
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bind_properties
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|properties
decl_stmt|;
if|if
condition|(
name|props
operator|==
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__bind_blob
argument_list|(
name|stmt
argument_list|,
name|slot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|skel
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|properties
operator|=
name|svn_skel__unparse
argument_list|(
name|skel
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__bind_blob
argument_list|(
name|stmt
argument_list|,
name|slot
argument_list|,
name|properties
operator|->
name|data
argument_list|,
name|properties
operator|->
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bind_iprops
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|inherited_props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|properties
decl_stmt|;
if|if
condition|(
name|inherited_props
operator|==
name|NULL
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__bind_blob
argument_list|(
name|stmt
argument_list|,
name|slot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_iproplist
argument_list|(
operator|&
name|skel
argument_list|,
name|inherited_props
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|properties
operator|=
name|svn_skel__unparse
argument_list|(
name|skel
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__bind_blob
argument_list|(
name|stmt
argument_list|,
name|slot
argument_list|,
name|properties
operator|->
name|data
argument_list|,
name|properties
operator|->
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__bind_checksum
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|csum_str
decl_stmt|;
if|if
condition|(
name|checksum
operator|==
name|NULL
condition|)
name|csum_str
operator|=
name|NULL
expr_stmt|;
else|else
name|csum_str
operator|=
name|svn_checksum_serialize
argument_list|(
name|checksum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__bind_text
argument_list|(
name|stmt
argument_list|,
name|slot
argument_list|,
name|csum_str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|void
modifier|*
name|svn_sqlite__column_blob
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|val
init|=
name|sqlite3_column_blob
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
decl_stmt|;
operator|*
name|len
operator|=
name|sqlite3_column_bytes
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_pool
operator|&&
name|val
operator|!=
name|NULL
condition|)
name|val
operator|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|val
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_sqlite__column_text
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* cast from 'unsigned char' to regular 'char'  */
specifier|const
name|char
modifier|*
name|result
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
name|result_pool
operator|&&
name|result
operator|!=
name|NULL
condition|)
name|result
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|svn_revnum_t
name|svn_sqlite__column_revnum
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|)
block|{
if|if
condition|(
name|svn_sqlite__column_is_null
argument_list|(
name|stmt
argument_list|,
name|column
argument_list|)
condition|)
return|return
name|SVN_INVALID_REVNUM
return|;
return|return
operator|(
name|svn_revnum_t
operator|)
name|sqlite3_column_int64
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_sqlite__column_boolean
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|)
block|{
return|return
name|sqlite3_column_int64
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svn_sqlite__column_int
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|)
block|{
return|return
name|sqlite3_column_int
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_int64_t
name|svn_sqlite__column_int64
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|)
block|{
return|return
name|sqlite3_column_int64
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svn_sqlite__column_token
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|svn_token_map_t
modifier|*
name|map
parameter_list|)
block|{
comment|/* cast from 'unsigned char' to regular 'char'  */
specifier|const
name|char
modifier|*
name|word
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
decl_stmt|;
return|return
name|svn_token__from_word_strict
argument_list|(
name|map
argument_list|,
name|word
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svn_sqlite__column_token_null
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|svn_token_map_t
modifier|*
name|map
parameter_list|,
name|int
name|null_val
parameter_list|)
block|{
comment|/* cast from 'unsigned char' to regular 'char'  */
specifier|const
name|char
modifier|*
name|word
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|word
condition|)
return|return
name|null_val
return|;
return|return
name|svn_token__from_word_strict
argument_list|(
name|map
argument_list|,
name|word
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__column_properties
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_size_t
name|len
decl_stmt|;
specifier|const
name|void
modifier|*
name|val
decl_stmt|;
comment|/* svn_skel__parse_proplist copies everything needed to result_pool */
name|val
operator|=
name|svn_sqlite__column_blob
argument_list|(
name|stmt
argument_list|,
name|column
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
operator|*
name|props
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
name|props
argument_list|,
name|svn_skel__parse
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__column_iprops
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|iprops
parameter_list|,
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_size_t
name|len
decl_stmt|;
specifier|const
name|void
modifier|*
name|val
decl_stmt|;
comment|/* svn_skel__parse_iprops copies everything needed to result_pool */
name|val
operator|=
name|svn_sqlite__column_blob
argument_list|(
name|stmt
argument_list|,
name|column
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
operator|*
name|iprops
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_skel__parse_iprops
argument_list|(
name|iprops
argument_list|,
name|svn_skel__parse
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__column_checksum
parameter_list|(
specifier|const
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
name|column
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|digest
operator|==
name|NULL
condition|)
operator|*
name|checksum
operator|=
name|NULL
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_checksum_deserialize
argument_list|(
name|checksum
argument_list|,
name|digest
argument_list|,
name|result_pool
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_sqlite__column_is_null
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|)
block|{
return|return
name|sqlite3_column_type
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
operator|==
name|SQLITE_NULL
return|;
block|}
end_function

begin_function
name|int
name|svn_sqlite__column_bytes
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|,
name|int
name|column
parameter_list|)
block|{
return|return
name|sqlite3_column_bytes
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|,
name|column
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__finalize
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|)
block|{
name|SQLITE_ERR
argument_list|(
name|sqlite3_finalize
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__reset
parameter_list|(
name|svn_sqlite__stmt_t
modifier|*
name|stmt
parameter_list|)
block|{
name|SQLITE_ERR
argument_list|(
name|sqlite3_reset
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
name|SQLITE_ERR
argument_list|(
name|sqlite3_clear_bindings
argument_list|(
name|stmt
operator|->
name|s3stmt
argument_list|)
argument_list|,
name|stmt
operator|->
name|db
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|needs_reset
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__read_schema_version
parameter_list|(
name|int
modifier|*
name|version
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|SVN_ERR
argument_list|(
name|prepare_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|db
argument_list|,
literal|"PRAGMA user_version;"
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step_row
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|version
operator|=
name|svn_sqlite__column_int
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__finalize
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|volatile
name|svn_atomic_t
name|sqlite_init_state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If possible, verify that SQLite was compiled in a thread-safe    manner. */
end_comment

begin_comment
comment|/* Don't call this function directly!  Use svn_atomic__init_once(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_sqlite
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|sqlite3_libversion_number
argument_list|()
operator|<
name|SVN_SQLITE_MIN_VERSION_NUMBER
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_SQLITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"SQLite compiled for %s, but running with %s"
argument_list|)
argument_list|,
name|SVN_SQLITE_MIN_VERSION
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|)
return|;
block|}
if|#
directive|if
name|APR_HAS_THREADS
comment|/* SQLite 3.5 allows verification of its thread-safety at runtime.      Older versions are simply expected to have been configured with      --enable-threadsafe, which compiles with -DSQLITE_THREADSAFE=1      (or -DTHREADSAFE, for older versions). */
if|if
condition|(
operator|!
name|sqlite3_threadsafe
argument_list|()
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SQLITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"SQLite is required to be compiled and run in "
literal|"thread-safe mode"
argument_list|)
argument_list|)
return|;
comment|/* If SQLite has been already initialized, sqlite3_config() returns      SQLITE_MISUSE. */
block|{
name|int
name|err
init|=
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_MULTITHREAD
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|SQLITE_OK
operator|&&
name|err
operator|!=
name|SQLITE_MISUSE
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SQLITE_ERROR_CODE
argument_list|(
name|err
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not configure SQLite [S%d]"
argument_list|)
argument_list|,
name|err
argument_list|)
return|;
block|}
name|SQLITE_ERR_MSG
argument_list|(
name|sqlite3_initialize
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Could not initialize SQLite"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THRADS */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|internal_open
parameter_list|(
name|sqlite3
modifier|*
modifier|*
name|db3
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_sqlite__mode_t
name|mode
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|svn_sqlite__mode_readonly
condition|)
name|flags
operator|=
name|SQLITE_OPEN_READONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|svn_sqlite__mode_readwrite
condition|)
name|flags
operator|=
name|SQLITE_OPEN_READWRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|svn_sqlite__mode_rwcreate
condition|)
name|flags
operator|=
name|SQLITE_OPEN_READWRITE
operator||
name|SQLITE_OPEN_CREATE
expr_stmt|;
else|else
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* Turn off SQLite's mutexes. All svn objects are single-threaded,        so we can already guarantee that our use of the SQLite handle        will be serialized properly.         Note: in 3.6.x, we've already config'd SQLite into MULTITHREAD mode,        so this is probably redundant, but if we are running in a process where        somebody initialized SQLite before us it is needed anyway.  */
name|flags
operator||=
name|SQLITE_OPEN_NOMUTEX
expr_stmt|;
comment|/* Open the database. Note that a handle is returned, even when an error        occurs (except for out-of-memory); thus, we can safely use it to        extract an error message and construct an svn_error_t. */
block|{
comment|/* We'd like to use SQLITE_ERR here, but we can't since it would          just return an error and leave the database open.  So, we need to          do this manually. */
comment|/* ### SQLITE_CANTOPEN */
name|int
name|err_code
init|=
name|sqlite3_open_v2
argument_list|(
name|path
argument_list|,
name|db3
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|err_code
operator|!=
name|SQLITE_OK
condition|)
block|{
comment|/* Save the error message before closing the SQLite handle. */
name|char
modifier|*
name|msg
init|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|sqlite3_errmsg
argument_list|(
operator|*
name|db3
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We don't catch the error here, since we care more about the open              error than the close error at this point. */
name|sqlite3_close
argument_list|(
operator|*
name|db3
argument_list|)
expr_stmt|;
name|SQLITE_ERR_MSG
argument_list|(
name|err_code
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Retry until timeout when database is busy. */
name|SQLITE_ERR_MSG
argument_list|(
name|sqlite3_busy_timeout
argument_list|(
operator|*
name|db3
argument_list|,
name|BUSY_TIMEOUT
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
operator|*
name|db3
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* APR cleanup function used to close the database when its pool is destroyed.    DATA should be the svn_sqlite__db_t handle for the database. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|close_apr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|svn_sqlite__db_t
modifier|*
name|db
init|=
name|data
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_status_t
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check to see if we've already closed this database. */
if|if
condition|(
name|db
operator|->
name|db3
operator|==
name|NULL
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* Finalize any existing prepared statements. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|db
operator|->
name|nbr_statements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|db
operator|->
name|prepared_stmts
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|prepared_stmts
index|[
name|i
index|]
operator|->
name|needs_reset
condition|)
block|{
ifdef|#
directive|ifdef
name|SVN_DEBUG
specifier|const
name|char
modifier|*
name|stmt_text
init|=
name|db
operator|->
name|statement_strings
index|[
name|i
index|]
decl_stmt|;
name|stmt_text
operator|=
name|stmt_text
expr_stmt|;
comment|/* Provide value for debugger */
name|SVN_ERR_MALFUNCTION_NO_RETURN
argument_list|()
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|db
operator|->
name|prepared_stmts
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_sqlite__finalize
argument_list|(
name|db
operator|->
name|prepared_stmts
index|[
name|i
index|]
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And finalize any used internal statements */
for|for
control|(
init|;
name|i
operator|<
name|db
operator|->
name|nbr_statements
operator|+
name|STMT_INTERNAL_LAST
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|db
operator|->
name|prepared_stmts
index|[
name|i
index|]
condition|)
block|{
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_sqlite__finalize
argument_list|(
name|db
operator|->
name|prepared_stmts
index|[
name|i
index|]
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|sqlite3_close
argument_list|(
name|db
operator|->
name|db3
argument_list|)
expr_stmt|;
comment|/* If there's a pre-existing error, return it. */
if|if
condition|(
name|err
condition|)
block|{
name|result
operator|=
name|err
operator|->
name|apr_err
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|result
operator|!=
name|SQLITE_OK
condition|)
return|return
name|SQLITE_ERROR_CODE
argument_list|(
name|result
argument_list|)
return|;
comment|/* ### lossy */
name|db
operator|->
name|db3
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__open
parameter_list|(
name|svn_sqlite__db_t
modifier|*
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_sqlite__mode_t
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|statements
index|[]
parameter_list|,
name|int
name|unused1
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|unused2
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_atomic__init_once
argument_list|(
operator|&
name|sqlite_init_state
argument_list|,
name|init_sqlite
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|db
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|internal_open
argument_list|(
operator|&
operator|(
operator|*
name|db
operator|)
operator|->
name|db3
argument_list|,
name|path
argument_list|,
name|mode
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SQLITE3_DEBUG
name|sqlite3_trace
argument_list|(
operator|(
operator|*
name|db
operator|)
operator|->
name|db3
argument_list|,
name|sqlite_tracer
argument_list|,
operator|(
operator|*
name|db
operator|)
operator|->
name|db3
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE3_PROFILE
name|sqlite3_profile
argument_list|(
operator|(
operator|*
name|db
operator|)
operator|->
name|db3
argument_list|,
name|sqlite_profiler
argument_list|,
operator|(
operator|*
name|db
operator|)
operator|->
name|db3
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ### simplify this. remnants of some old SQLite compat code.  */
block|{
name|int
name|ignored_err
init|=
name|SQLITE_OK
decl_stmt|;
name|SVN_ERR
argument_list|(
name|exec_sql2
argument_list|(
operator|*
name|db
argument_list|,
literal|"PRAGMA case_sensitive_like=1;"
argument_list|,
name|ignored_err
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|exec_sql
argument_list|(
operator|*
name|db
argument_list|,
comment|/* Disable synchronization to disable the explicit disk flushes                  that make Sqlite up to 50 times slower; especially on small                  transactions.                   This removes some stability guarantees on specific hardware                  and power failures, but still guarantees atomic commits on                  application crashes. With our dependency on external data                  like pristine files (Wc) and revision files (repository),                  we can't keep up these additional guarantees anyway.                   ### Maybe switch to NORMAL(1) when we use larger transaction                      scopes */
literal|"PRAGMA synchronous=OFF;"
comment|/* Enable recursive triggers so that a user trigger will fire                  in the deletion phase of an INSERT OR REPLACE statement.                  Requires SQLite>= 3.6.18  */
literal|"PRAGMA recursive_triggers=ON;"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
comment|/* When running in debug mode, enable the checking of foreign key      constraints.  This has possible performance implications, so we don't      bother to do it for production...for now. */
name|SVN_ERR
argument_list|(
name|exec_sql
argument_list|(
operator|*
name|db
argument_list|,
literal|"PRAGMA foreign_keys=ON;"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Store temporary tables in RAM instead of in temporary files, but don't      fail on this if this option is disabled in the sqlite compilation by      setting SQLITE_TEMP_STORE to 0 (always to disk) */
name|svn_error_clear
argument_list|(
name|exec_sql
argument_list|(
operator|*
name|db
argument_list|,
literal|"PRAGMA temp_store = MEMORY;"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the provided statements. */
if|if
condition|(
name|statements
condition|)
block|{
operator|(
operator|*
name|db
operator|)
operator|->
name|statement_strings
operator|=
name|statements
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|nbr_statements
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|statements
operator|!=
name|NULL
condition|)
block|{
name|statements
operator|++
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|nbr_statements
operator|++
expr_stmt|;
block|}
operator|(
operator|*
name|db
operator|)
operator|->
name|prepared_stmts
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
operator|(
operator|(
operator|*
name|db
operator|)
operator|->
name|nbr_statements
operator|+
name|STMT_INTERNAL_LAST
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|svn_sqlite__stmt_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|db
operator|)
operator|->
name|nbr_statements
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|prepared_stmts
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
operator|(
literal|0
operator|+
name|STMT_INTERNAL_LAST
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|svn_sqlite__stmt_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|db
operator|)
operator|->
name|state_pool
operator|=
name|result_pool
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|result_pool
argument_list|,
operator|*
name|db
argument_list|,
name|close_apr
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__close
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|)
block|{
name|apr_status_t
name|result
init|=
name|apr_pool_cleanup_run
argument_list|(
name|db
operator|->
name|state_pool
argument_list|,
name|db
argument_list|,
name|close_apr
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|APR_SUCCESS
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_wrap_apr
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reset_all_statements
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|svn_error_t
modifier|*
name|error_to_wrap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* ### Should we reorder the errors in this specific case      ### to avoid returning the normal error as top level error? */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|error_to_wrap
argument_list|,
name|svn_error_create
argument_list|(
name|SVN_ERR_SQLITE_RESETTING_FOR_ROLLBACK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|db
operator|->
name|nbr_statements
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|db
operator|->
name|prepared_stmts
index|[
name|i
index|]
operator|&&
name|db
operator|->
name|prepared_stmts
index|[
name|i
index|]
operator|->
name|needs_reset
condition|)
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|db
operator|->
name|prepared_stmts
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__begin_transaction
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_internal_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|db
argument_list|,
name|STMT_INTERNAL_BEGIN_TRANSACTION
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__begin_immediate_transaction
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_internal_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|db
argument_list|,
name|STMT_INTERNAL_BEGIN_IMMEDIATE_TRANSACTION
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__begin_savepoint
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_internal_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|db
argument_list|,
name|STMT_INTERNAL_SAVEPOINT_SVN
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__finish_transaction
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
comment|/* Commit or rollback the sqlite transaction. */
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|err2
operator|=
name|get_internal_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|db
argument_list|,
name|STMT_INTERNAL_ROLLBACK_TRANSACTION
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err2
condition|)
name|err2
operator|=
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
operator|&&
name|err2
operator|->
name|apr_err
operator|==
name|SVN_ERR_SQLITE_BUSY
condition|)
block|{
comment|/* ### Houston, we have a problem!               We are trying to rollback but we can't because some              statements are still busy. This leaves the database              unusable for future transactions as the current transaction              is still open.               As we are returning the actual error as the most relevant              error in the chain, our caller might assume that it can              retry/compensate on this error (e.g. SVN_WC_LOCKED), while              in fact the SQLite database is unusable until the statements              started within this transaction are reset and the transaction              aborted.               We try to compensate by resetting all prepared but unreset              statements; but we leave the busy error in the chain anyway to              help diagnosing the original error and help in finding where              a reset statement is missing. */
name|err2
operator|=
name|reset_all_statements
argument_list|(
name|db
argument_list|,
name|err2
argument_list|)
expr_stmt|;
name|err2
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|err2
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|get_internal_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|db
argument_list|,
name|STMT_INTERNAL_COMMIT_TRANSACTION
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__finish_savepoint
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|err2
operator|=
name|get_internal_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|db
argument_list|,
name|STMT_INTERNAL_ROLLBACK_TO_SAVEPOINT_SVN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err2
condition|)
name|err2
operator|=
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
operator|&&
name|err2
operator|->
name|apr_err
operator|==
name|SVN_ERR_SQLITE_BUSY
condition|)
block|{
comment|/* Ok, we have a major problem. Some statement is still open, which              makes it impossible to release this savepoint.               ### See huge comment in svn_sqlite__finish_transaction for                  further details */
name|err2
operator|=
name|reset_all_statements
argument_list|(
name|db
argument_list|,
name|err2
argument_list|)
expr_stmt|;
name|err2
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|err2
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
expr_stmt|;
name|err2
operator|=
name|get_internal_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|db
argument_list|,
name|STMT_INTERNAL_RELEASE_SAVEPOINT_SVN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err2
condition|)
name|err2
operator|=
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|get_internal_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|db
argument_list|,
name|STMT_INTERNAL_RELEASE_SAVEPOINT_SVN
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__with_transaction
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|svn_sqlite__transaction_callback_t
name|cb_func
parameter_list|,
name|void
modifier|*
name|cb_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
comment|/* NULL allowed */
parameter_list|)
block|{
name|SVN_SQLITE__WITH_TXN
argument_list|(
name|cb_func
argument_list|(
name|cb_baton
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__with_immediate_transaction
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|svn_sqlite__transaction_callback_t
name|cb_func
parameter_list|,
name|void
modifier|*
name|cb_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
comment|/* NULL allowed */
parameter_list|)
block|{
name|SVN_SQLITE__WITH_IMMEDIATE_TXN
argument_list|(
name|cb_func
argument_list|(
name|cb_baton
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__with_lock
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
name|svn_sqlite__transaction_callback_t
name|cb_func
parameter_list|,
name|void
modifier|*
name|cb_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
comment|/* NULL allowed */
parameter_list|)
block|{
name|SVN_SQLITE__WITH_LOCK
argument_list|(
name|cb_func
argument_list|(
name|cb_baton
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__hotcopy
parameter_list|(
specifier|const
name|char
modifier|*
name|src_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__db_t
modifier|*
name|src_db
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__open
argument_list|(
operator|&
name|src_db
argument_list|,
name|src_path
argument_list|,
name|svn_sqlite__mode_readonly
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|svn_sqlite__db_t
modifier|*
name|dst_db
decl_stmt|;
name|sqlite3_backup
modifier|*
name|backup
decl_stmt|;
name|int
name|rc1
decl_stmt|,
name|rc2
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__open
argument_list|(
operator|&
name|dst_db
argument_list|,
name|dst_path
argument_list|,
name|svn_sqlite__mode_rwcreate
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|backup
operator|=
name|sqlite3_backup_init
argument_list|(
name|dst_db
operator|->
name|db3
argument_list|,
literal|"main"
argument_list|,
name|src_db
operator|->
name|db3
argument_list|,
literal|"main"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|backup
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_SQLITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"SQLite hotcopy failed for %s"
argument_list|)
argument_list|,
name|src_path
argument_list|)
return|;
do|do
block|{
comment|/* Pages are usually 1024 byte (SQLite docs). On my laptop            copying gets faster as the number of pages is increased up            to about 64, beyond that speed levels off.  Lets put the            number of pages an order of magnitude higher, this is still            likely to be a fraction of large databases. */
name|rc1
operator|=
name|sqlite3_backup_step
argument_list|(
name|backup
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* Should we sleep on SQLITE_OK?  That would make copying a            large database take much longer.  When we do sleep how,            long should we sleep?  Should the sleep get longer if we            keep getting BUSY/LOCKED?  I have no real reason for            choosing 25. */
if|if
condition|(
name|rc1
operator|==
name|SQLITE_BUSY
operator|||
name|rc1
operator|==
name|SQLITE_LOCKED
condition|)
name|sqlite3_sleep
argument_list|(
literal|25
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc1
operator|==
name|SQLITE_OK
operator|||
name|rc1
operator|==
name|SQLITE_BUSY
operator|||
name|rc1
operator|==
name|SQLITE_LOCKED
condition|)
do|;
name|rc2
operator|=
name|sqlite3_backup_finish
argument_list|(
name|backup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc1
operator|!=
name|SQLITE_DONE
condition|)
name|SQLITE_ERR
argument_list|(
name|rc1
argument_list|,
name|dst_db
argument_list|)
expr_stmt|;
name|SQLITE_ERR
argument_list|(
name|rc2
argument_list|,
name|dst_db
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__close
argument_list|(
name|dst_db
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__close
argument_list|(
name|src_db
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|function_wrapper_baton_t
block|{
name|svn_sqlite__func_t
name|func
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|wrapped_func
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
name|values
index|[]
parameter_list|)
block|{
name|struct
name|function_wrapper_baton_t
modifier|*
name|fwb
init|=
name|sqlite3_user_data
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|svn_sqlite__context_t
name|sctx
decl_stmt|;
name|svn_sqlite__value_t
modifier|*
modifier|*
name|local_vals
init|=
name|apr_palloc
argument_list|(
name|fwb
operator|->
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_sqlite__value_t
operator|*
argument_list|)
operator|*
name|argc
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sctx
operator|.
name|context
operator|=
name|context
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|local_vals
index|[
name|i
index|]
operator|=
name|apr_palloc
argument_list|(
name|fwb
operator|->
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|local_vals
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|local_vals
index|[
name|i
index|]
operator|->
name|value
operator|=
name|values
index|[
name|i
index|]
expr_stmt|;
block|}
name|err
operator|=
name|fwb
operator|->
name|func
argument_list|(
operator|&
name|sctx
argument_list|,
name|argc
argument_list|,
name|local_vals
argument_list|,
name|fwb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|fwb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|sqlite3_result_error
argument_list|(
name|context
argument_list|,
name|svn_err_best_message
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_sqlite__create_scalar_function
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|func_name
parameter_list|,
name|int
name|argc
parameter_list|,
name|svn_sqlite__func_t
name|func
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|function_wrapper_baton_t
modifier|*
name|fwb
init|=
name|apr_pcalloc
argument_list|(
name|db
operator|->
name|state_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwb
argument_list|)
argument_list|)
decl_stmt|;
name|fwb
operator|->
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|db
operator|->
name|state_pool
argument_list|)
expr_stmt|;
name|fwb
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|fwb
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
name|SQLITE_ERR
argument_list|(
name|sqlite3_create_function
argument_list|(
name|db
operator|->
name|db3
argument_list|,
name|func_name
argument_list|,
name|argc
argument_list|,
name|SQLITE_ANY
argument_list|,
name|fwb
argument_list|,
name|wrapped_func
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|db
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|int
name|svn_sqlite__value_type
parameter_list|(
name|svn_sqlite__value_t
modifier|*
name|val
parameter_list|)
block|{
return|return
name|sqlite3_value_type
argument_list|(
name|val
operator|->
name|value
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_sqlite__value_text
parameter_list|(
name|svn_sqlite__value_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|val
operator|->
name|value
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|svn_sqlite__result_null
parameter_list|(
name|svn_sqlite__context_t
modifier|*
name|sctx
parameter_list|)
block|{
name|sqlite3_result_null
argument_list|(
name|sctx
operator|->
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_sqlite__result_int64
parameter_list|(
name|svn_sqlite__context_t
modifier|*
name|sctx
parameter_list|,
name|apr_int64_t
name|val
parameter_list|)
block|{
name|sqlite3_result_int64
argument_list|(
name|sctx
operator|->
name|context
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

