begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * config_win.c :  parsing configuration data from the registry  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/* We must include windows.h ourselves or apr.h includes it for us with    many ignore options set. Including Winsock is required to resolve IPv6    compilation errors. APR_HAVE_IPV6 is only defined after including    apr.h, so we can't detect this case here. */
end_comment

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_comment
comment|/* winsock2.h includes windows.h */
end_comment

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<Ws2tcpip.h>
end_include

begin_include
include|#
directive|include
file|<shlobj.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"config_impl.h"
end_include

begin_function
name|svn_error_t
modifier|*
name|svn_config__win_config_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|folder
parameter_list|,
name|svn_boolean_t
name|system_path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* ### Adding CSIDL_FLAG_CREATE here, because those folders really      must exist.  I'm not too sure about the SHGFP_TYPE_CURRENT      semancics, though; maybe we should use ..._DEFAULT instead? */
specifier|const
name|int
name|csidl
init|=
operator|(
operator|(
name|system_path
condition|?
name|CSIDL_COMMON_APPDATA
else|:
name|CSIDL_APPDATA
operator|)
operator||
name|CSIDL_FLAG_CREATE
operator|)
decl_stmt|;
name|WCHAR
name|folder_ucs2
index|[
name|MAX_PATH
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|folder_utf8
decl_stmt|;
if|if
condition|(
operator|!
name|system_path
condition|)
block|{
name|HKEY
name|hkey_tmp
decl_stmt|;
comment|/* Verify if we actually have a *per user* profile to read from */
if|if
condition|(
name|ERROR_SUCCESS
operator|==
name|RegOpenCurrentUser
argument_list|(
name|KEY_SET_VALUE
argument_list|,
operator|&
name|hkey_tmp
argument_list|)
condition|)
name|RegCloseKey
argument_list|(
name|hkey_tmp
argument_list|)
expr_stmt|;
comment|/* We have a profile */
else|else
block|{
comment|/* The user is not properly logged in. (Most likely we are running              in a service process). In this case Windows will return a default              read only 'roaming profile' directory, which we assume to be              writable. We will then spend many seconds trying to create a              configuration and then fail, because we are not allowed to write              there, but the retry loop in io.c doesn't know that.               We just answer that there is no user configuration directory. */
operator|*
name|folder
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
name|S_OK
operator|!=
name|SHGetFolderPathW
argument_list|(
name|NULL
argument_list|,
name|csidl
argument_list|,
name|NULL
argument_list|,
name|SHGFP_TYPE_CURRENT
argument_list|,
name|folder_ucs2
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_FILENAME
argument_list|,
name|NULL
argument_list|,
operator|(
name|system_path
condition|?
name|_
argument_list|(
literal|"Can't determine the system config path"
argument_list|)
else|:
name|_
argument_list|(
literal|"Can't determine the user's config path"
argument_list|)
operator|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_utf__win32_utf16_to_utf8
argument_list|(
operator|&
name|folder_utf8
argument_list|,
name|folder_ucs2
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|folder
operator|=
name|svn_dirent_internal_style
argument_list|(
name|folder_utf8
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ### These constants are insanely large, but we want to avoid    reallocating strings if possible. */
end_comment

begin_define
define|#
directive|define
name|SVN_REG_DEFAULT_NAME_SIZE
value|2048
end_define

begin_define
define|#
directive|define
name|SVN_REG_DEFAULT_VALUE_SIZE
value|8192
end_define

begin_comment
comment|/* ### This function should be converted to use the unicode functions    ### instead of the ansi functions */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_section
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|HKEY
name|hkey
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|option
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|value
parameter_list|)
block|{
name|DWORD
name|option_len
decl_stmt|,
name|type
decl_stmt|,
name|index
decl_stmt|;
name|LONG
name|err
decl_stmt|;
comment|/* Start with a reasonable size for the buffers. */
name|svn_stringbuf_ensure
argument_list|(
name|option
argument_list|,
name|SVN_REG_DEFAULT_NAME_SIZE
argument_list|)
expr_stmt|;
name|svn_stringbuf_ensure
argument_list|(
name|value
argument_list|,
name|SVN_REG_DEFAULT_VALUE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
condition|;
operator|++
name|index
control|)
block|{
name|option_len
operator|=
operator|(
name|DWORD
operator|)
name|option
operator|->
name|blocksize
expr_stmt|;
name|err
operator|=
name|RegEnumValue
argument_list|(
name|hkey
argument_list|,
name|index
argument_list|,
name|option
operator|->
name|data
argument_list|,
operator|&
name|option_len
argument_list|,
name|NULL
argument_list|,
operator|&
name|type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERROR_NO_MORE_ITEMS
condition|)
break|break;
if|if
condition|(
name|err
operator|==
name|ERROR_INSUFFICIENT_BUFFER
condition|)
block|{
name|svn_stringbuf_ensure
argument_list|(
name|option
argument_list|,
name|option_len
argument_list|)
expr_stmt|;
name|err
operator|=
name|RegEnumValue
argument_list|(
name|hkey
argument_list|,
name|index
argument_list|,
name|option
operator|->
name|data
argument_list|,
operator|&
name|option_len
argument_list|,
name|NULL
argument_list|,
operator|&
name|type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|ERROR_SUCCESS
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_MALFORMED_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't enumerate registry values"
argument_list|)
argument_list|)
return|;
comment|/* Ignore option names that start with '#', see          http://subversion.tigris.org/issues/show_bug.cgi?id=671 */
if|if
condition|(
name|type
operator|==
name|REG_SZ
operator|&&
name|option
operator|->
name|data
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|DWORD
name|value_len
init|=
operator|(
name|DWORD
operator|)
name|value
operator|->
name|blocksize
decl_stmt|;
name|err
operator|=
name|RegQueryValueEx
argument_list|(
name|hkey
argument_list|,
name|option
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|LPBYTE
operator|)
name|value
operator|->
name|data
argument_list|,
operator|&
name|value_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERROR_MORE_DATA
condition|)
block|{
name|svn_stringbuf_ensure
argument_list|(
name|value
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
name|err
operator|=
name|RegQueryValueEx
argument_list|(
name|hkey
argument_list|,
name|option
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|LPBYTE
operator|)
name|value
operator|->
name|data
argument_list|,
operator|&
name|value_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|ERROR_SUCCESS
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_MALFORMED_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't read registry value data"
argument_list|)
argument_list|)
return|;
name|svn_config_set
argument_list|(
name|cfg
argument_list|,
name|section
argument_list|,
name|option
operator|->
name|data
argument_list|,
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Exported interface. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_config__parse_registry
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|section
decl_stmt|,
modifier|*
name|option
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|svn_error_t
modifier|*
name|svn_err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|HKEY
name|base_hkey
decl_stmt|,
name|hkey
decl_stmt|;
name|DWORD
name|index
decl_stmt|;
name|LONG
name|err
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|file
argument_list|,
name|SVN_REGISTRY_HKLM
argument_list|,
name|SVN_REGISTRY_HKLM_LEN
argument_list|)
condition|)
block|{
name|base_hkey
operator|=
name|HKEY_LOCAL_MACHINE
expr_stmt|;
name|file
operator|+=
name|SVN_REGISTRY_HKLM_LEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|file
argument_list|,
name|SVN_REGISTRY_HKCU
argument_list|,
name|SVN_REGISTRY_HKCU_LEN
argument_list|)
condition|)
block|{
name|base_hkey
operator|=
name|HKEY_CURRENT_USER
expr_stmt|;
name|file
operator|+=
name|SVN_REGISTRY_HKCU_LEN
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_FILENAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unrecognised registry path '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|err
operator|=
name|RegOpenKeyEx
argument_list|(
name|base_hkey
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
name|KEY_ENUMERATE_SUB_KEYS
operator||
name|KEY_QUERY_VALUE
argument_list|,
operator|&
name|hkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|apr_status_t
name|apr_err
init|=
name|APR_FROM_OS_ERROR
argument_list|(
name|err
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|is_enoent
init|=
name|APR_STATUS_IS_ENOENT
argument_list|(
name|apr_err
argument_list|)
operator|||
operator|(
name|err
operator|==
name|ERROR_INVALID_HANDLE
operator|)
decl_stmt|;
if|if
condition|(
name|must_exist
operator|||
operator|!
name|is_enoent
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_FILENAME
argument_list|,
name|is_enoent
condition|?
name|NULL
else|:
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Can't open registry key '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|section
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|option
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|value
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* The top-level values belong to the [DEFAULT] section */
name|svn_err
operator|=
name|parse_section
argument_list|(
name|cfg
argument_list|,
name|hkey
argument_list|,
name|SVN_CONFIG__DEFAULT_SECTION
argument_list|,
name|option
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Now enumerate the rest of the keys. */
name|svn_stringbuf_ensure
argument_list|(
name|section
argument_list|,
name|SVN_REG_DEFAULT_NAME_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
condition|;
operator|++
name|index
control|)
block|{
name|DWORD
name|section_len
init|=
operator|(
name|DWORD
operator|)
name|section
operator|->
name|blocksize
decl_stmt|;
name|HKEY
name|sub_hkey
decl_stmt|;
name|err
operator|=
name|RegEnumKeyEx
argument_list|(
name|hkey
argument_list|,
name|index
argument_list|,
name|section
operator|->
name|data
argument_list|,
operator|&
name|section_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERROR_NO_MORE_ITEMS
condition|)
break|break;
if|if
condition|(
name|err
operator|==
name|ERROR_MORE_DATA
condition|)
block|{
name|svn_stringbuf_ensure
argument_list|(
name|section
argument_list|,
name|section_len
argument_list|)
expr_stmt|;
name|err
operator|=
name|RegEnumKeyEx
argument_list|(
name|hkey
argument_list|,
name|index
argument_list|,
name|section
operator|->
name|data
argument_list|,
operator|&
name|section_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|svn_err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_MALFORMED_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't enumerate registry keys"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|err
operator|=
name|RegOpenKeyEx
argument_list|(
name|hkey
argument_list|,
name|section
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|KEY_ENUMERATE_SUB_KEYS
operator||
name|KEY_QUERY_VALUE
argument_list|,
operator|&
name|sub_hkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|svn_err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_MALFORMED_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't open existing subkey"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|svn_err
operator|=
name|parse_section
argument_list|(
name|cfg
argument_list|,
name|sub_hkey
argument_list|,
name|section
operator|->
name|data
argument_list|,
name|option
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|sub_hkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_err
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|RegCloseKey
argument_list|(
name|hkey
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|svn_err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

end_unit

