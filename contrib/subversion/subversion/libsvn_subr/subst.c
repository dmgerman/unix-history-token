begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * subst.c :  generic eol/keyword substitution routines  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_comment
comment|/**  * The textual elements of a detranslated special file.  One of these  * strings must appear as the first element of any special file as it  * exists in the repository or the text base.  */
end_comment

begin_define
define|#
directive|define
name|SVN_SUBST__SPECIAL_LINK_STR
value|"link"
end_define

begin_function
name|void
name|svn_subst_eol_style_from_value
parameter_list|(
name|svn_subst_eol_style_t
modifier|*
name|style
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
comment|/* property doesn't exist. */
operator|*
name|eol
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|style
condition|)
operator|*
name|style
operator|=
name|svn_subst_eol_style_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"native"
argument_list|,
name|value
argument_list|)
condition|)
block|{
operator|*
name|eol
operator|=
name|APR_EOL_STR
expr_stmt|;
comment|/* whee, a portability library! */
if|if
condition|(
name|style
condition|)
operator|*
name|style
operator|=
name|svn_subst_eol_style_native
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"LF"
argument_list|,
name|value
argument_list|)
condition|)
block|{
operator|*
name|eol
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|style
condition|)
operator|*
name|style
operator|=
name|svn_subst_eol_style_fixed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"CR"
argument_list|,
name|value
argument_list|)
condition|)
block|{
operator|*
name|eol
operator|=
literal|"\r"
expr_stmt|;
if|if
condition|(
name|style
condition|)
operator|*
name|style
operator|=
name|svn_subst_eol_style_fixed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"CRLF"
argument_list|,
name|value
argument_list|)
condition|)
block|{
operator|*
name|eol
operator|=
literal|"\r\n"
expr_stmt|;
if|if
condition|(
name|style
condition|)
operator|*
name|style
operator|=
name|svn_subst_eol_style_fixed
expr_stmt|;
block|}
else|else
block|{
operator|*
name|eol
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|style
condition|)
operator|*
name|style
operator|=
name|svn_subst_eol_style_unknown
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_subst_translation_required
parameter_list|(
name|svn_subst_eol_style_t
name|style
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|apr_hash_t
modifier|*
name|keywords
parameter_list|,
name|svn_boolean_t
name|special
parameter_list|,
name|svn_boolean_t
name|force_eol_check
parameter_list|)
block|{
return|return
operator|(
name|special
operator|||
name|keywords
operator|||
operator|(
name|style
operator|!=
name|svn_subst_eol_style_none
operator|&&
name|force_eol_check
operator|)
operator|||
operator|(
name|style
operator|==
name|svn_subst_eol_style_native
operator|&&
name|strcmp
argument_list|(
name|APR_EOL_STR
argument_list|,
name|SVN_SUBST_NATIVE_EOL_STR
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|style
operator|==
name|svn_subst_eol_style_fixed
operator|&&
name|strcmp
argument_list|(
name|APR_EOL_STR
argument_list|,
name|eol
argument_list|)
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for svn_subst_build_keywords */
end_comment

begin_comment
comment|/* Given a printf-like format string, return a string with proper  * information filled in.  *  * Important API note: This function is the core of the implementation of  * svn_subst_build_keywords (all versions), and as such must implement the  * tolerance of NULL and zero inputs that that function's documention  * stipulates.  *  * The format codes:  *  * %a author of this revision  * %b basename of the URL of this file  * %d short format of date of this revision  * %D long format of date of this revision  * %P path relative to root of repos  * %r number of this revision  * %R root url of repository  * %u URL of this file  * %_ a space  * %% a literal %  *  * The following special format codes are also recognized:  *   %H is equivalent to %P%_%r%_%d%_%a  *   %I is equivalent to %b%_%r%_%d%_%a  *  * All memory is allocated out of @a pool.  */
end_comment

begin_function
specifier|static
name|svn_string_t
modifier|*
name|keyword_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
name|apr_time_t
name|date
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|value
init|=
name|svn_stringbuf_ncreate
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|cur
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cur
operator|=
name|fmt
expr_stmt|;
while|while
condition|(
operator|*
name|cur
operator|!=
literal|'\0'
operator|&&
operator|*
name|cur
operator|!=
literal|'%'
condition|)
name|cur
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|cur
operator|-
name|fmt
operator|)
operator|>
literal|0
condition|)
comment|/* Do we have an as-is string? */
name|svn_stringbuf_appendbytes
argument_list|(
name|value
argument_list|,
name|fmt
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'\0'
condition|)
break|break;
switch|switch
condition|(
name|cur
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* author of this revision */
if|if
condition|(
name|author
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|author
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* basename of this file */
if|if
condition|(
name|url
operator|&&
operator|*
name|url
condition|)
block|{
specifier|const
name|char
modifier|*
name|base_name
init|=
name|svn_uri_basename
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|base_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* short format of date of this revision */
if|if
condition|(
name|date
condition|)
block|{
name|apr_time_exp_t
name|exploded_time
decl_stmt|;
specifier|const
name|char
modifier|*
name|human
decl_stmt|;
name|apr_time_exp_gmt
argument_list|(
operator|&
name|exploded_time
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|human
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%04d-%02d-%02d %02d:%02d:%02dZ"
argument_list|,
name|exploded_time
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|exploded_time
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|exploded_time
operator|.
name|tm_mday
argument_list|,
name|exploded_time
operator|.
name|tm_hour
argument_list|,
name|exploded_time
operator|.
name|tm_min
argument_list|,
name|exploded_time
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|human
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
comment|/* long format of date of this revision */
if|if
condition|(
name|date
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|svn_time_to_human_cstring
argument_list|(
name|date
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* relative path of this file */
if|if
condition|(
name|repos_root_url
operator|&&
operator|*
name|repos_root_url
operator|!=
literal|'\0'
operator|&&
name|url
operator|&&
operator|*
name|url
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_relpath
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
comment|/* root of repos */
if|if
condition|(
name|repos_root_url
operator|&&
operator|*
name|repos_root_url
operator|!=
literal|'\0'
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|repos_root_url
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* number of this revision */
if|if
condition|(
name|rev
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|rev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* URL of this file */
if|if
condition|(
name|url
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|url
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* '%_' => a space */
name|svn_stringbuf_appendbyte
argument_list|(
name|value
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
comment|/* '%%' => a literal % */
name|svn_stringbuf_appendbyte
argument_list|(
name|value
argument_list|,
operator|*
name|cur
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* '%' as the last character of the string. */
name|svn_stringbuf_appendbyte
argument_list|(
name|value
argument_list|,
operator|*
name|cur
argument_list|)
expr_stmt|;
comment|/* Now go back one character, since this was just a one character            * sequence, whereas all others are two characters, and we do not            * want to skip the null terminator entirely and carry on            * formatting random memory contents. */
name|cur
operator|--
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
block|{
name|svn_string_t
modifier|*
name|s
init|=
name|keyword_printf
argument_list|(
literal|"%P%_%r%_%d%_%a"
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|s
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
block|{
name|svn_string_t
modifier|*
name|s
init|=
name|keyword_printf
argument_list|(
literal|"%b%_%r%_%d%_%a"
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|value
argument_list|,
name|s
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Unrecognized code, just print it literally. */
name|svn_stringbuf_appendbytes
argument_list|(
name|value
argument_list|,
name|cur
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Format code is processed - skip it, and get ready for next chunk. */
name|fmt
operator|=
name|cur
operator|+
literal|2
expr_stmt|;
block|}
return|return
name|svn_stringbuf__morph_into_string
argument_list|(
name|value
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|build_keywords
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|kw
parameter_list|,
name|svn_boolean_t
name|expand_custom_keywords
parameter_list|,
specifier|const
name|char
modifier|*
name|keywords_val
parameter_list|,
specifier|const
name|char
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
name|apr_time_t
name|date
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|keyword_tokens
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|kw
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|keyword_tokens
operator|=
name|svn_cstring_split
argument_list|(
name|keywords_val
argument_list|,
literal|" \t\v\n\b\r\f"
argument_list|,
name|TRUE
comment|/* chop */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keyword_tokens
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|keyword
init|=
name|APR_ARRAY_IDX
argument_list|(
name|keyword_tokens
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|custom_fmt
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|expand_custom_keywords
condition|)
block|{
name|char
modifier|*
name|sep
decl_stmt|;
comment|/* Check if there is a custom keyword definition, started by '='. */
name|sep
operator|=
name|strchr
argument_list|(
name|keyword
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
block|{
operator|*
name|sep
operator|=
literal|'\0'
expr_stmt|;
comment|/* Split keyword's name from custom format. */
name|custom_fmt
operator|=
name|sep
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|custom_fmt
condition|)
block|{
name|svn_string_t
modifier|*
name|custom_val
decl_stmt|;
comment|/* Custom keywords must be allowed to match the name of an            * existing fixed keyword. This is for compatibility purposes,            * in case new fixed keywords are added to Subversion which            * happen to match a custom keyword defined somewhere.            * There is only one global namespace for keyword names. */
name|custom_val
operator|=
name|keyword_printf
argument_list|(
name|custom_fmt
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|keyword
argument_list|,
name|custom_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_REVISION_LONG
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_REVISION_MEDIUM
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|svn_cstring_casecmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_REVISION_SHORT
argument_list|)
operator|)
condition|)
block|{
name|svn_string_t
modifier|*
name|revision_val
decl_stmt|;
name|revision_val
operator|=
name|keyword_printf
argument_list|(
literal|"%r"
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_REVISION_LONG
argument_list|,
name|revision_val
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_REVISION_MEDIUM
argument_list|,
name|revision_val
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_REVISION_SHORT
argument_list|,
name|revision_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_DATE_LONG
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|svn_cstring_casecmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_DATE_SHORT
argument_list|)
operator|)
condition|)
block|{
name|svn_string_t
modifier|*
name|date_val
decl_stmt|;
name|date_val
operator|=
name|keyword_printf
argument_list|(
literal|"%D"
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_DATE_LONG
argument_list|,
name|date_val
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_DATE_SHORT
argument_list|,
name|date_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_AUTHOR_LONG
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|svn_cstring_casecmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_AUTHOR_SHORT
argument_list|)
operator|)
condition|)
block|{
name|svn_string_t
modifier|*
name|author_val
decl_stmt|;
name|author_val
operator|=
name|keyword_printf
argument_list|(
literal|"%a"
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_AUTHOR_LONG
argument_list|,
name|author_val
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_AUTHOR_SHORT
argument_list|,
name|author_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_URL_LONG
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|svn_cstring_casecmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_URL_SHORT
argument_list|)
operator|)
condition|)
block|{
name|svn_string_t
modifier|*
name|url_val
decl_stmt|;
name|url_val
operator|=
name|keyword_printf
argument_list|(
literal|"%u"
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_URL_LONG
argument_list|,
name|url_val
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_URL_SHORT
argument_list|,
name|url_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|svn_cstring_casecmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_ID
argument_list|)
operator|)
condition|)
block|{
name|svn_string_t
modifier|*
name|id_val
decl_stmt|;
name|id_val
operator|=
name|keyword_printf
argument_list|(
literal|"%b %r %d %a"
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_ID
argument_list|,
name|id_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|svn_cstring_casecmp
argument_list|(
name|keyword
argument_list|,
name|SVN_KEYWORD_HEADER
argument_list|)
operator|)
condition|)
block|{
name|svn_string_t
modifier|*
name|header_val
decl_stmt|;
name|header_val
operator|=
name|keyword_printf
argument_list|(
literal|"%u %r %d %a"
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|kw
argument_list|,
name|SVN_KEYWORD_HEADER
argument_list|,
name|header_val
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_subst_build_keywords2
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|kw
parameter_list|,
specifier|const
name|char
modifier|*
name|keywords_val
parameter_list|,
specifier|const
name|char
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_time_t
name|date
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|build_keywords
argument_list|(
name|kw
argument_list|,
name|FALSE
argument_list|,
name|keywords_val
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|NULL
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_subst_build_keywords3
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|kw
parameter_list|,
specifier|const
name|char
modifier|*
name|keywords_val
parameter_list|,
specifier|const
name|char
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
name|apr_time_t
name|date
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|build_keywords
argument_list|(
name|kw
argument_list|,
name|TRUE
argument_list|,
name|keywords_val
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Helpers for svn_subst_translate_stream2 ***/
end_comment

begin_comment
comment|/* Write out LEN bytes of BUF into STREAM. */
end_comment

begin_comment
comment|/* ### TODO: 'stream_write()' would be a better name for this. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|translate_write
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (No need to check LEN, as a short write always produces an error.) */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform the substitution of VALUE into keyword string BUF (with len    *LEN), given a pre-parsed KEYWORD (and KEYWORD_LEN), and updating    *LEN to the new size of the substituted result.  Return TRUE if all    goes well, FALSE otherwise.  If VALUE is NULL, keyword will be    contracted, else it will be expanded.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|translate_keyword_subst
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|keyword
parameter_list|,
name|apr_size_t
name|keyword_len
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|buf_ptr
decl_stmt|;
comment|/* Make sure we gotz good stuffs. */
name|assert
argument_list|(
operator|*
name|len
operator|<=
name|SVN_KEYWORD_MAX_LEN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|buf
index|[
operator|*
name|len
operator|-
literal|1
index|]
operator|==
literal|'$'
operator|)
argument_list|)
expr_stmt|;
comment|/* Need at least a keyword and two $'s. */
if|if
condition|(
operator|*
name|len
operator|<
name|keyword_len
operator|+
literal|2
condition|)
return|return
name|FALSE
return|;
comment|/* Need at least space for two $'s, two spaces and a colon, and that      leaves zero space for the value itself. */
if|if
condition|(
name|keyword_len
operator|>
name|SVN_KEYWORD_MAX_LEN
operator|-
literal|5
condition|)
return|return
name|FALSE
return|;
comment|/* The keyword needs to match what we're looking for. */
if|if
condition|(
name|strncmp
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|keyword
argument_list|,
name|keyword_len
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|buf_ptr
operator|=
name|buf
operator|+
literal|1
operator|+
name|keyword_len
expr_stmt|;
comment|/* Check for fixed-length expansion.    * The format of fixed length keyword and its data is    * Unexpanded keyword:         "$keyword::       $"    * Expanded keyword:           "$keyword:: value $"    * Expanded kw with filling:   "$keyword:: value   $"    * Truncated keyword:          "$keyword:: longval#$"    */
if|if
condition|(
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
comment|/* first char after keyword is ':' */
operator|&&
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
comment|/* second char after keyword is ':' */
operator|&&
operator|(
name|buf_ptr
index|[
literal|2
index|]
operator|==
literal|' '
operator|)
comment|/* third char after keyword is ' ' */
operator|&&
operator|(
operator|(
name|buf
index|[
operator|*
name|len
operator|-
literal|2
index|]
operator|==
literal|' '
operator|)
comment|/* has ' ' for next to last character */
operator|||
operator|(
name|buf
index|[
operator|*
name|len
operator|-
literal|2
index|]
operator|==
literal|'#'
operator|)
operator|)
comment|/* .. or has '#' for next to last                                         character */
operator|&&
operator|(
operator|(
literal|6
operator|+
name|keyword_len
operator|)
operator|<
operator|*
name|len
operator|)
condition|)
comment|/* holds "$kw:: x $" at least */
block|{
comment|/* This is fixed length keyword, so *len remains unchanged */
name|apr_size_t
name|max_value_len
init|=
operator|*
name|len
operator|-
operator|(
literal|6
operator|+
name|keyword_len
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
comment|/* no value, so unexpand */
name|buf_ptr
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|!=
literal|'$'
condition|)
operator|*
operator|(
name|buf_ptr
operator|++
operator|)
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|->
name|len
operator|<=
name|max_value_len
condition|)
block|{
comment|/* replacement not as long as template, pad with spaces */
name|strncpy
argument_list|(
name|buf_ptr
operator|+
literal|3
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|value
operator|->
name|len
argument_list|)
expr_stmt|;
name|buf_ptr
operator|+=
literal|3
operator|+
name|value
operator|->
name|len
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|!=
literal|'$'
condition|)
operator|*
operator|(
name|buf_ptr
operator|++
operator|)
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
comment|/* replacement needs truncating */
name|strncpy
argument_list|(
name|buf_ptr
operator|+
literal|3
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|max_value_len
argument_list|)
expr_stmt|;
name|buf
index|[
operator|*
name|len
operator|-
literal|2
index|]
operator|=
literal|'#'
expr_stmt|;
name|buf
index|[
operator|*
name|len
operator|-
literal|1
index|]
operator|=
literal|'$'
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
comment|/* Check for unexpanded keyword. */
elseif|else
if|if
condition|(
name|buf_ptr
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
comment|/* "$keyword$" */
block|{
comment|/* unexpanded... */
if|if
condition|(
name|value
condition|)
block|{
comment|/* ...so expand. */
name|buf_ptr
index|[
literal|0
index|]
operator|=
literal|':'
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|len
condition|)
block|{
name|apr_size_t
name|vallen
init|=
name|value
operator|->
name|len
decl_stmt|;
comment|/* "$keyword: value $" */
if|if
condition|(
name|vallen
operator|>
operator|(
name|SVN_KEYWORD_MAX_LEN
operator|-
literal|5
operator|-
name|keyword_len
operator|)
condition|)
name|vallen
operator|=
name|SVN_KEYWORD_MAX_LEN
operator|-
literal|5
operator|-
name|keyword_len
expr_stmt|;
name|strncpy
argument_list|(
name|buf_ptr
operator|+
literal|2
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
literal|2
operator|+
name|vallen
index|]
operator|=
literal|' '
expr_stmt|;
name|buf_ptr
index|[
literal|2
operator|+
name|vallen
operator|+
literal|1
index|]
operator|=
literal|'$'
expr_stmt|;
operator|*
name|len
operator|=
literal|5
operator|+
name|keyword_len
operator|+
name|vallen
expr_stmt|;
block|}
else|else
block|{
comment|/* "$keyword: $"  */
name|buf_ptr
index|[
literal|2
index|]
operator|=
literal|'$'
expr_stmt|;
operator|*
name|len
operator|=
literal|4
operator|+
name|keyword_len
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ...but do nothing. */
block|}
return|return
name|TRUE
return|;
block|}
comment|/* Check for expanded keyword. */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|len
operator|>=
literal|4
operator|+
name|keyword_len
operator|)
comment|/* holds at least "$keyword: $" */
operator|&&
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
comment|/* first char after keyword is ':' */
operator|&&
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|==
literal|' '
operator|)
comment|/* second char after keyword is ' ' */
operator|&&
operator|(
name|buf
index|[
operator|*
name|len
operator|-
literal|2
index|]
operator|==
literal|' '
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|len
operator|>=
literal|3
operator|+
name|keyword_len
operator|)
comment|/* holds at least "$keyword:$" */
operator|&&
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
comment|/* first char after keyword is ':' */
operator|&&
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|)
condition|)
comment|/* second char after keyword is '$' */
block|{
comment|/* expanded... */
if|if
condition|(
operator|!
name|value
condition|)
block|{
comment|/* ...so unexpand. */
name|buf_ptr
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
operator|*
name|len
operator|=
literal|2
operator|+
name|keyword_len
expr_stmt|;
block|}
else|else
block|{
comment|/* ...so re-expand. */
name|buf_ptr
index|[
literal|0
index|]
operator|=
literal|':'
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|len
condition|)
block|{
name|apr_size_t
name|vallen
init|=
name|value
operator|->
name|len
decl_stmt|;
comment|/* "$keyword: value $" */
if|if
condition|(
name|vallen
operator|>
operator|(
name|SVN_KEYWORD_MAX_LEN
operator|-
literal|5
operator|-
name|keyword_len
operator|)
condition|)
name|vallen
operator|=
name|SVN_KEYWORD_MAX_LEN
operator|-
literal|5
operator|-
name|keyword_len
expr_stmt|;
name|strncpy
argument_list|(
name|buf_ptr
operator|+
literal|2
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
literal|2
operator|+
name|vallen
index|]
operator|=
literal|' '
expr_stmt|;
name|buf_ptr
index|[
literal|2
operator|+
name|vallen
operator|+
literal|1
index|]
operator|=
literal|'$'
expr_stmt|;
operator|*
name|len
operator|=
literal|5
operator|+
name|keyword_len
operator|+
name|vallen
expr_stmt|;
block|}
else|else
block|{
comment|/* "$keyword: $"  */
name|buf_ptr
index|[
literal|2
index|]
operator|=
literal|'$'
expr_stmt|;
operator|*
name|len
operator|=
literal|4
operator|+
name|keyword_len
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Parse BUF (whose length is LEN, and which starts and ends with '$'),    trying to match one of the keyword names in KEYWORDS.  If such a    keyword is found, update *KEYWORD_NAME with the keyword name and    return TRUE. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|match_keyword
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|char
modifier|*
name|keyword_name
parameter_list|,
name|apr_hash_t
modifier|*
name|keywords
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
comment|/* Early return for ignored keywords */
if|if
condition|(
operator|!
name|keywords
condition|)
return|return
name|FALSE
return|;
comment|/* Extract the name of the keyword */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|-
literal|2
operator|&&
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|':'
condition|;
name|i
operator|++
control|)
name|keyword_name
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|keyword_name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|svn_hash_gets
argument_list|(
name|keywords
argument_list|,
name|keyword_name
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Try to translate keyword *KEYWORD_NAME in BUF (whose length is LEN):    optionally perform the substitution in place, update *LEN with    the new length of the translated keyword string, and return TRUE.    If this buffer doesn't contain a known keyword pattern, leave BUF    and *LEN untouched and return FALSE.     See the docstring for svn_subst_copy_and_translate for how the    EXPAND and KEYWORDS parameters work.     NOTE: It is assumed that BUF has been allocated to be at least    SVN_KEYWORD_MAX_LEN bytes longs, and that the data in BUF is less    than or equal SVN_KEYWORD_MAX_LEN in length.  Also, any expansions    which would result in a keyword string which is greater than    SVN_KEYWORD_MAX_LEN will have their values truncated in such a way    that the resultant keyword string is still valid (begins with    "$Keyword:", ends in " $" and is SVN_KEYWORD_MAX_LEN bytes long).  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|translate_keyword
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|keyword_name
parameter_list|,
name|svn_boolean_t
name|expand
parameter_list|,
name|apr_hash_t
modifier|*
name|keywords
parameter_list|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
comment|/* Make sure we gotz good stuffs. */
name|assert
argument_list|(
operator|*
name|len
operator|<=
name|SVN_KEYWORD_MAX_LEN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|buf
index|[
operator|*
name|len
operator|-
literal|1
index|]
operator|==
literal|'$'
operator|)
argument_list|)
expr_stmt|;
comment|/* Early return for ignored keywords */
if|if
condition|(
operator|!
name|keywords
condition|)
return|return
name|FALSE
return|;
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|keywords
argument_list|,
name|keyword_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
return|return
name|translate_keyword_subst
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|keyword_name
argument_list|,
name|strlen
argument_list|(
name|keyword_name
argument_list|)
argument_list|,
name|expand
condition|?
name|value
else|:
name|NULL
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* A boolean expression that evaluates to true if the first STR_LEN characters    of the string STR are one of the end-of-line strings LF, CR, or CRLF;    to false otherwise.  */
end_comment

begin_define
define|#
directive|define
name|STRING_IS_EOL
parameter_list|(
name|str
parameter_list|,
name|str_len
parameter_list|)
define|\
value|(((str_len) == 2&&  (str)[0] == '\r'&& (str)[1] == '\n') || \    ((str_len) == 1&& ((str)[0] == '\n' || (str)[0] == '\r')))
end_define

begin_comment
comment|/* A boolean expression that evaluates to true if the end-of-line string EOL1,    having length EOL1_LEN, and the end-of-line string EOL2, having length    EOL2_LEN, are different, assuming that EOL1 and EOL2 are both from the    set {"\n", "\r", "\r\n"};  to false otherwise.     Given that EOL1 and EOL2 are either "\n", "\r", or "\r\n", then if    EOL1_LEN is not the same as EOL2_LEN, then EOL1 and EOL2 are of course    different. If EOL1_LEN and EOL2_LEN are both 2 then EOL1 and EOL2 are both    "\r\n" and *EOL1 == *EOL2. Otherwise, EOL1_LEN and EOL2_LEN are both 1.    We need only check the one character for equality to determine whether    EOL1 and EOL2 are different in that case. */
end_comment

begin_define
define|#
directive|define
name|DIFFERENT_EOL_STRINGS
parameter_list|(
name|eol1
parameter_list|,
name|eol1_len
parameter_list|,
name|eol2
parameter_list|,
name|eol2_len
parameter_list|)
define|\
value|(((eol1_len) != (eol2_len)) || (*(eol1) != *(eol2)))
end_define

begin_comment
comment|/* Translate the newline string NEWLINE_BUF (of length NEWLINE_LEN) to    the newline string EOL_STR (of length EOL_STR_LEN), writing the    result (which is always EOL_STR) to the stream DST.     This function assumes that NEWLINE_BUF is either "\n", "\r", or "\r\n".     Also check for consistency of the source newline strings across    multiple calls, using SRC_FORMAT (length *SRC_FORMAT_LEN) as a cache    of the first newline found.  If the current newline is not the same    as SRC_FORMAT, look to the REPAIR parameter.  If REPAIR is TRUE,    ignore the inconsistency, else return an SVN_ERR_IO_INCONSISTENT_EOL    error.  If *SRC_FORMAT_LEN is 0, assume we are examining the first    newline in the file, and copy it to {SRC_FORMAT, *SRC_FORMAT_LEN} to    use for later consistency checks.     If TRANSLATED_EOL is not NULL, then set *TRANSLATED_EOL to TRUE if the    newline string that was written (EOL_STR) is not the same as the newline    string that was translated (NEWLINE_BUF), otherwise leave *TRANSLATED_EOL    untouched.     Note: all parameters are required even if REPAIR is TRUE.    ### We could require that REPAIR must not change across a sequence of        calls, and could then optimize by not using SRC_FORMAT at all if        REPAIR is TRUE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|translate_newline
parameter_list|(
specifier|const
name|char
modifier|*
name|eol_str
parameter_list|,
name|apr_size_t
name|eol_str_len
parameter_list|,
name|char
modifier|*
name|src_format
parameter_list|,
name|apr_size_t
modifier|*
name|src_format_len
parameter_list|,
specifier|const
name|char
modifier|*
name|newline_buf
parameter_list|,
name|apr_size_t
name|newline_len
parameter_list|,
name|svn_stream_t
modifier|*
name|dst
parameter_list|,
name|svn_boolean_t
modifier|*
name|translated_eol
parameter_list|,
name|svn_boolean_t
name|repair
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|STRING_IS_EOL
argument_list|(
name|newline_buf
argument_list|,
name|newline_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we've seen a newline before, compare it with our cache to      check for consistency, else cache it for future comparisons. */
if|if
condition|(
operator|*
name|src_format_len
condition|)
block|{
comment|/* Comparing with cache.  If we are inconsistent and          we are NOT repairing the file, generate an error! */
if|if
condition|(
operator|(
operator|!
name|repair
operator|)
operator|&&
name|DIFFERENT_EOL_STRINGS
argument_list|(
name|src_format
argument_list|,
operator|*
name|src_format_len
argument_list|,
name|newline_buf
argument_list|,
name|newline_len
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_INCONSISTENT_EOL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
else|else
block|{
comment|/* This is our first line ending, so cache it before          handling it. */
name|strncpy
argument_list|(
name|src_format
argument_list|,
name|newline_buf
argument_list|,
name|newline_len
argument_list|)
expr_stmt|;
operator|*
name|src_format_len
operator|=
name|newline_len
expr_stmt|;
block|}
comment|/* Write the desired newline */
name|SVN_ERR
argument_list|(
name|translate_write
argument_list|(
name|dst
argument_list|,
name|eol_str
argument_list|,
name|eol_str_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Report whether we translated it.  Note: Not using DIFFERENT_EOL_STRINGS()    * because EOL_STR may not be a valid EOL sequence. */
if|if
condition|(
name|translated_eol
operator|!=
name|NULL
operator|&&
operator|(
name|eol_str_len
operator|!=
name|newline_len
operator|||
name|memcmp
argument_list|(
name|eol_str
argument_list|,
name|newline_buf
argument_list|,
name|eol_str_len
argument_list|)
operator|!=
literal|0
operator|)
condition|)
operator|*
name|translated_eol
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public interfaces. ***/
end_comment

begin_function
name|svn_boolean_t
name|svn_subst_keywords_differ
parameter_list|(
specifier|const
name|svn_subst_keywords_t
modifier|*
name|a
parameter_list|,
specifier|const
name|svn_subst_keywords_t
modifier|*
name|b
parameter_list|,
name|svn_boolean_t
name|compare_values
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|a
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|==
name|NULL
operator|)
operator|)
comment|/* no A or B */
comment|/* no A, and B has no contents */
operator|||
operator|(
operator|(
name|a
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|->
name|revision
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|->
name|date
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|->
name|author
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|->
name|url
operator|==
name|NULL
operator|)
operator|)
comment|/* no B, and A has no contents */
operator|||
operator|(
operator|(
name|b
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|a
operator|->
name|revision
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|a
operator|->
name|date
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|a
operator|->
name|author
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|a
operator|->
name|url
operator|==
name|NULL
operator|)
operator|)
comment|/* neither A nor B has any contents */
operator|||
operator|(
operator|(
name|a
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|->
name|revision
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|->
name|date
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|->
name|author
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|b
operator|->
name|url
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|a
operator|->
name|revision
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|a
operator|->
name|date
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|a
operator|->
name|author
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|a
operator|->
name|url
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|a
operator|==
name|NULL
operator|)
operator|||
operator|(
name|b
operator|==
name|NULL
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* Else both A and B have some keywords. */
if|if
condition|(
operator|(
operator|!
name|a
operator|->
name|revision
operator|)
operator|!=
operator|(
operator|!
name|b
operator|->
name|revision
operator|)
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
operator|(
name|compare_values
operator|&&
operator|(
name|a
operator|->
name|revision
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|a
operator|->
name|revision
operator|->
name|data
argument_list|,
name|b
operator|->
name|revision
operator|->
name|data
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
operator|!
name|a
operator|->
name|date
operator|)
operator|!=
operator|(
operator|!
name|b
operator|->
name|date
operator|)
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
operator|(
name|compare_values
operator|&&
operator|(
name|a
operator|->
name|date
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|a
operator|->
name|date
operator|->
name|data
argument_list|,
name|b
operator|->
name|date
operator|->
name|data
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
operator|!
name|a
operator|->
name|author
operator|)
operator|!=
operator|(
operator|!
name|b
operator|->
name|author
operator|)
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
operator|(
name|compare_values
operator|&&
operator|(
name|a
operator|->
name|author
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|a
operator|->
name|author
operator|->
name|data
argument_list|,
name|b
operator|->
name|author
operator|->
name|data
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
operator|!
name|a
operator|->
name|url
operator|)
operator|!=
operator|(
operator|!
name|b
operator|->
name|url
operator|)
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
operator|(
name|compare_values
operator|&&
operator|(
name|a
operator|->
name|url
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|a
operator|->
name|url
operator|->
name|data
argument_list|,
name|b
operator|->
name|url
operator|->
name|data
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* Else we never found a difference, so they must be the same. */
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_subst_keywords_differ2
parameter_list|(
name|apr_hash_t
modifier|*
name|a
parameter_list|,
name|apr_hash_t
modifier|*
name|b
parameter_list|,
name|svn_boolean_t
name|compare_values
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|unsigned
name|int
name|a_count
decl_stmt|,
name|b_count
decl_stmt|;
comment|/* An empty hash is logically equal to a NULL,    * as far as this API is concerned. */
name|a_count
operator|=
operator|(
name|a
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|apr_hash_count
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b_count
operator|=
operator|(
name|b
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|apr_hash_count
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_count
operator|!=
name|b_count
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|a_count
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* The hashes are both non-NULL, and have the same number of items.    * We must check that every item of A is present in B. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|a
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|void
modifier|*
name|void_a_val
decl_stmt|;
name|svn_string_t
modifier|*
name|a_val
decl_stmt|,
modifier|*
name|b_val
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|void_a_val
argument_list|)
expr_stmt|;
name|a_val
operator|=
name|void_a_val
expr_stmt|;
name|b_val
operator|=
name|apr_hash_get
argument_list|(
name|b
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b_val
operator|||
operator|(
name|compare_values
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|a_val
argument_list|,
name|b_val
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Baton for translate_chunk() to store its state in. */
end_comment

begin_struct
struct|struct
name|translation_baton
block|{
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_boolean_t
modifier|*
name|translated_eol
decl_stmt|;
name|svn_boolean_t
name|repair
decl_stmt|;
name|apr_hash_t
modifier|*
name|keywords
decl_stmt|;
name|svn_boolean_t
name|expand
decl_stmt|;
comment|/* 'short boolean' array that encodes what character values      may trigger a translation action, hence are 'interesting' */
name|char
name|interesting
index|[
literal|256
index|]
decl_stmt|;
comment|/* Length of the string EOL_STR points to. */
name|apr_size_t
name|eol_str_len
decl_stmt|;
comment|/* Buffer to cache any newline state between translation chunks */
name|char
name|newline_buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* Offset (within newline_buf) of the first *unused* character */
name|apr_size_t
name|newline_off
decl_stmt|;
comment|/* Buffer to cache keyword-parsing state between translation chunks */
name|char
name|keyword_buf
index|[
name|SVN_KEYWORD_MAX_LEN
index|]
decl_stmt|;
comment|/* Offset (within keyword-buf) to the first *unused* character */
name|apr_size_t
name|keyword_off
decl_stmt|;
comment|/* EOL style used in the chunk-source */
name|char
name|src_format
index|[
literal|2
index|]
decl_stmt|;
comment|/* Length of the EOL style string found in the chunk-source,      or zero if none encountered yet */
name|apr_size_t
name|src_format_len
decl_stmt|;
comment|/* If this is svn_tristate_false, translate_newline() will be called      for every newline in the file */
name|svn_tristate_t
name|nl_translation_skippable
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate a baton for use with translate_chunk() in POOL and  * initialize it for the first iteration.  *  * The caller must assure that EOL_STR and KEYWORDS at least  * have the same life time as that of POOL.  */
end_comment

begin_function
specifier|static
name|struct
name|translation_baton
modifier|*
name|create_translation_baton
parameter_list|(
specifier|const
name|char
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|translated_eol
parameter_list|,
name|svn_boolean_t
name|repair
parameter_list|,
name|apr_hash_t
modifier|*
name|keywords
parameter_list|,
name|svn_boolean_t
name|expand
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|translation_baton
modifier|*
name|b
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For efficiency, convert an empty set of keywords to NULL. */
if|if
condition|(
name|keywords
operator|&&
operator|(
name|apr_hash_count
argument_list|(
name|keywords
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|keywords
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|eol_str
operator|=
name|eol_str
expr_stmt|;
name|b
operator|->
name|eol_str_len
operator|=
name|eol_str
condition|?
name|strlen
argument_list|(
name|eol_str
argument_list|)
else|:
literal|0
expr_stmt|;
name|b
operator|->
name|translated_eol
operator|=
name|translated_eol
expr_stmt|;
name|b
operator|->
name|repair
operator|=
name|repair
expr_stmt|;
name|b
operator|->
name|keywords
operator|=
name|keywords
expr_stmt|;
name|b
operator|->
name|expand
operator|=
name|expand
expr_stmt|;
name|b
operator|->
name|newline_off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|keyword_off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|src_format_len
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|nl_translation_skippable
operator|=
name|svn_tristate_unknown
expr_stmt|;
comment|/* Most characters don't start translation actions.    * Mark those that do depending on the parameters we got. */
name|memset
argument_list|(
name|b
operator|->
name|interesting
argument_list|,
name|FALSE
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|->
name|interesting
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keywords
condition|)
name|b
operator|->
name|interesting
index|[
literal|'$'
index|]
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eol_str
condition|)
block|{
name|b
operator|->
name|interesting
index|[
literal|'\r'
index|]
operator|=
name|TRUE
expr_stmt|;
name|b
operator|->
name|interesting
index|[
literal|'\n'
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the EOL starting at BUF matches the eol_str member of B.  * Be aware of special cases like "\n\r\n" and "\n\n\r". For sequences like  * "\n$" (an EOL followed by a keyword), the result will be FALSE since it is  * more efficient to handle that special case implicitly in the calling code  * by exiting the quick scan loop.  * The caller must ensure that buf[0] and buf[1] refer to valid memory  * locations.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|svn_boolean_t
name|eol_unchanged
parameter_list|(
name|struct
name|translation_baton
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
comment|/* If the first byte doesn't match, the whole EOL won't.    * This does also handle the (certainly invalid) case that    * eol_str would be an empty string.    */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
name|b
operator|->
name|eol_str
index|[
literal|0
index|]
condition|)
return|return
name|FALSE
return|;
comment|/* two-char EOLs must be a full match */
if|if
condition|(
name|b
operator|->
name|eol_str_len
operator|==
literal|2
condition|)
return|return
name|buf
index|[
literal|1
index|]
operator|==
name|b
operator|->
name|eol_str
index|[
literal|1
index|]
return|;
comment|/* The first char matches the required 1-byte EOL.    * But maybe, buf[] contains a 2-byte EOL?    * In that case, the second byte will be interesting    * and not be another EOL of its own.    */
return|return
operator|!
name|b
operator|->
name|interesting
index|[
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|1
index|]
index|]
operator|||
name|buf
index|[
literal|0
index|]
operator|==
name|buf
index|[
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/* Translate eols and keywords of a 'chunk' of characters BUF of size BUFLEN  * according to the settings and state stored in baton B.  *  * Write output to stream DST.  *  * To finish a series of chunk translations, flush all buffers by calling  * this routine with a NULL value for BUF.  *  * If B->translated_eol is not NULL, then set *B->translated_eol to TRUE if  * an end-of-line sequence was changed, otherwise leave it untouched.  *  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|translate_chunk
parameter_list|(
name|svn_stream_t
modifier|*
name|dst
parameter_list|,
name|struct
name|translation_baton
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|buflen
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
comment|/* precalculate some oft-used values */
specifier|const
name|char
modifier|*
name|end
init|=
name|buf
operator|+
name|buflen
decl_stmt|;
specifier|const
name|char
modifier|*
name|interesting
init|=
name|b
operator|->
name|interesting
decl_stmt|;
name|apr_size_t
name|next_sign_off
init|=
literal|0
decl_stmt|;
comment|/* At the beginning of this loop, assume that we might be in an        * interesting state, i.e. with data in the newline or keyword        * buffer.  First try to get to the boring state so we can copy        * a run of boring characters; then try to get back to the        * interesting state by processing an interesting character,        * and repeat. */
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|<
name|end
condition|;
control|)
block|{
comment|/* Try to get to the boring state, if necessary. */
if|if
condition|(
name|b
operator|->
name|newline_off
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|b
operator|->
name|newline_buf
index|[
name|b
operator|->
name|newline_off
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|translate_newline
argument_list|(
name|b
operator|->
name|eol_str
argument_list|,
name|b
operator|->
name|eol_str_len
argument_list|,
name|b
operator|->
name|src_format
argument_list|,
operator|&
name|b
operator|->
name|src_format_len
argument_list|,
name|b
operator|->
name|newline_buf
argument_list|,
name|b
operator|->
name|newline_off
argument_list|,
name|dst
argument_list|,
name|b
operator|->
name|translated_eol
argument_list|,
name|b
operator|->
name|repair
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|newline_off
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|keyword_off
operator|&&
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|svn_boolean_t
name|keyword_matches
decl_stmt|;
name|char
name|keyword_name
index|[
name|SVN_KEYWORD_MAX_LEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* If keyword is matched, but not correctly translated, try to                * look for the next ending '$'. */
name|b
operator|->
name|keyword_buf
index|[
name|b
operator|->
name|keyword_off
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|keyword_matches
operator|=
name|match_keyword
argument_list|(
name|b
operator|->
name|keyword_buf
argument_list|,
name|b
operator|->
name|keyword_off
argument_list|,
name|keyword_name
argument_list|,
name|b
operator|->
name|keywords
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keyword_matches
condition|)
block|{
comment|/* reuse the ending '$' */
name|p
operator|--
expr_stmt|;
name|b
operator|->
name|keyword_off
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keyword_matches
operator|||
name|translate_keyword
argument_list|(
name|b
operator|->
name|keyword_buf
argument_list|,
operator|&
name|b
operator|->
name|keyword_off
argument_list|,
name|keyword_name
argument_list|,
name|b
operator|->
name|expand
argument_list|,
name|b
operator|->
name|keywords
argument_list|)
operator|||
name|b
operator|->
name|keyword_off
operator|>=
name|SVN_KEYWORD_MAX_LEN
condition|)
block|{
comment|/* write out non-matching text or translated keyword */
name|SVN_ERR
argument_list|(
name|translate_write
argument_list|(
name|dst
argument_list|,
name|b
operator|->
name|keyword_buf
argument_list|,
name|b
operator|->
name|keyword_off
argument_list|)
argument_list|)
expr_stmt|;
name|next_sign_off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|keyword_off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|next_sign_off
operator|==
literal|0
condition|)
name|next_sign_off
operator|=
name|b
operator|->
name|keyword_off
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|keyword_off
operator|==
name|SVN_KEYWORD_MAX_LEN
operator|-
literal|1
operator|||
operator|(
name|b
operator|->
name|keyword_off
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|next_sign_off
operator|>
literal|0
condition|)
block|{
comment|/* rolling back, continue with next '$' in keyword_buf */
name|p
operator|-=
operator|(
name|b
operator|->
name|keyword_off
operator|-
name|next_sign_off
operator|)
expr_stmt|;
name|b
operator|->
name|keyword_off
operator|=
name|next_sign_off
expr_stmt|;
name|next_sign_off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* No closing '$' found; flush the keyword buffer. */
name|SVN_ERR
argument_list|(
name|translate_write
argument_list|(
name|dst
argument_list|,
name|b
operator|->
name|keyword_buf
argument_list|,
name|b
operator|->
name|keyword_off
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|keyword_off
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|keyword_off
condition|)
block|{
name|b
operator|->
name|keyword_buf
index|[
name|b
operator|->
name|keyword_off
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* translate_newline will modify the baton for src_format_len==0              or may return an error if b->repair is FALSE.  In all other              cases, we can skip the newline translation as long as source              EOL format and actual EOL format match.  If there is a              mismatch, translate_newline will be called regardless of              nl_translation_skippable.            */
if|if
condition|(
name|b
operator|->
name|nl_translation_skippable
operator|==
name|svn_tristate_unknown
operator|&&
name|b
operator|->
name|src_format_len
operator|>
literal|0
condition|)
block|{
comment|/* test whether translate_newline may return an error */
if|if
condition|(
name|b
operator|->
name|eol_str_len
operator|==
name|b
operator|->
name|src_format_len
operator|&&
name|strncmp
argument_list|(
name|b
operator|->
name|eol_str
argument_list|,
name|b
operator|->
name|src_format
argument_list|,
name|b
operator|->
name|eol_str_len
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|->
name|nl_translation_skippable
operator|=
name|svn_tristate_true
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|repair
condition|)
name|b
operator|->
name|nl_translation_skippable
operator|=
name|svn_tristate_true
expr_stmt|;
else|else
name|b
operator|->
name|nl_translation_skippable
operator|=
name|svn_tristate_false
expr_stmt|;
block|}
comment|/* We're in the boring state; look for interesting characters.              Offset len such that it will become 0 in the first iteration.            */
name|len
operator|=
literal|0
operator|-
name|b
operator|->
name|eol_str_len
expr_stmt|;
comment|/* Look for the next EOL (or $) that actually needs translation.              Stop there or at EOF, whichever is encountered first.            */
do|do
block|{
comment|/* skip current EOL */
name|len
operator|+=
name|b
operator|->
name|eol_str_len
expr_stmt|;
comment|/* Check 4 bytes at once to allow for efficient pipelining                  and to reduce loop condition overhead. */
while|while
condition|(
operator|(
name|p
operator|+
name|len
operator|+
literal|4
operator|)
operator|<=
name|end
condition|)
block|{
if|if
condition|(
name|interesting
index|[
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
name|len
index|]
index|]
operator|||
name|interesting
index|[
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
name|len
operator|+
literal|1
index|]
index|]
operator|||
name|interesting
index|[
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
name|len
operator|+
literal|2
index|]
index|]
operator|||
name|interesting
index|[
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
name|len
operator|+
literal|3
index|]
index|]
condition|)
break|break;
name|len
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Found an interesting char or EOF in the next 4 bytes.                   Find its exact position. */
while|while
condition|(
operator|(
name|p
operator|+
name|len
operator|)
operator|<
name|end
operator|&&
operator|!
name|interesting
index|[
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
name|len
index|]
index|]
condition|)
operator|++
name|len
expr_stmt|;
block|}
do|while
condition|(
name|b
operator|->
name|nl_translation_skippable
operator|==
name|svn_tristate_true
operator|&&
comment|/* can potentially skip EOLs */
name|p
operator|+
name|len
operator|+
literal|2
operator|<
name|end
operator|&&
comment|/* not too close to EOF */
name|eol_unchanged
argument_list|(
name|b
argument_list|,
name|p
operator|+
name|len
argument_list|)
condition|)
do|;
comment|/* EOL format already ok */
while|while
condition|(
operator|(
name|p
operator|+
name|len
operator|)
operator|<
name|end
operator|&&
operator|!
name|interesting
index|[
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
name|len
index|]
index|]
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|SVN_ERR
argument_list|(
name|translate_write
argument_list|(
name|dst
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Set up state according to the interesting character, if any. */
if|if
condition|(
name|p
operator|<
name|end
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'$'
case|:
name|b
operator|->
name|keyword_buf
index|[
name|b
operator|->
name|keyword_off
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|b
operator|->
name|newline_buf
index|[
name|b
operator|->
name|newline_off
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|b
operator|->
name|newline_buf
index|[
name|b
operator|->
name|newline_off
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|translate_newline
argument_list|(
name|b
operator|->
name|eol_str
argument_list|,
name|b
operator|->
name|eol_str_len
argument_list|,
name|b
operator|->
name|src_format
argument_list|,
operator|&
name|b
operator|->
name|src_format_len
argument_list|,
name|b
operator|->
name|newline_buf
argument_list|,
name|b
operator|->
name|newline_off
argument_list|,
name|dst
argument_list|,
name|b
operator|->
name|translated_eol
argument_list|,
name|b
operator|->
name|repair
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|newline_off
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|b
operator|->
name|newline_off
condition|)
block|{
name|SVN_ERR
argument_list|(
name|translate_newline
argument_list|(
name|b
operator|->
name|eol_str
argument_list|,
name|b
operator|->
name|eol_str_len
argument_list|,
name|b
operator|->
name|src_format
argument_list|,
operator|&
name|b
operator|->
name|src_format_len
argument_list|,
name|b
operator|->
name|newline_buf
argument_list|,
name|b
operator|->
name|newline_off
argument_list|,
name|dst
argument_list|,
name|b
operator|->
name|translated_eol
argument_list|,
name|b
operator|->
name|repair
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|newline_off
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|keyword_off
condition|)
block|{
name|SVN_ERR
argument_list|(
name|translate_write
argument_list|(
name|dst
argument_list|,
name|b
operator|->
name|keyword_buf
argument_list|,
name|b
operator|->
name|keyword_off
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|keyword_off
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for use with translated stream callbacks. */
end_comment

begin_struct
struct|struct
name|translated_stream_baton
block|{
comment|/* Stream to take input from (before translation) on read      /write output to (after translation) on write. */
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* Input/Output translation batons to make them separate chunk streams. */
name|struct
name|translation_baton
modifier|*
name|in_baton
decl_stmt|,
modifier|*
name|out_baton
decl_stmt|;
comment|/* Remembers whether any write operations have taken place;      if so, we need to flush the output chunk stream. */
name|svn_boolean_t
name|written
decl_stmt|;
comment|/* Buffer to hold translated read data. */
name|svn_stringbuf_t
modifier|*
name|readbuf
decl_stmt|;
comment|/* Offset of the first non-read character in readbuf. */
name|apr_size_t
name|readbuf_off
decl_stmt|;
comment|/* Buffer to hold read data      between svn_stream_read() and translate_chunk(). */
name|char
modifier|*
name|buf
decl_stmt|;
define|#
directive|define
name|SVN__TRANSLATION_BUF_SIZE
value|(SVN__STREAM_CHUNK_SIZE + 1)
comment|/* Pool for callback iterations */
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_read_fn_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|translated_stream_read
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|translated_stream_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|readlen
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|apr_size_t
name|unsatisfied
init|=
operator|*
name|len
decl_stmt|;
name|apr_size_t
name|off
init|=
literal|0
decl_stmt|;
comment|/* Optimization for a frequent special case. The configuration parser (and      a few others) reads the stream one byte at a time. All the memcpy, pool      clearing etc. imposes a huge overhead in that case. In most cases, we      can just take that single byte directly from the read buffer.       Since *len> 1 requires lots of code to be run anyways, we can afford      the extra overhead of checking for *len == 1.       See<http://mail-archives.apache.org/mod_mbox/subversion-dev/201003.mbox/%3C4B94011E.1070207@alice-dsl.de%3E>.   */
if|if
condition|(
name|unsatisfied
operator|==
literal|1
operator|&&
name|b
operator|->
name|readbuf_off
operator|<
name|b
operator|->
name|readbuf
operator|->
name|len
condition|)
block|{
comment|/* Just take it from the read buffer */
operator|*
name|buffer
operator|=
name|b
operator|->
name|readbuf
operator|->
name|data
index|[
name|b
operator|->
name|readbuf_off
operator|++
index|]
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Standard code path. */
while|while
condition|(
name|readlen
operator|==
name|SVN__STREAM_CHUNK_SIZE
operator|&&
name|unsatisfied
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|to_copy
decl_stmt|;
name|apr_size_t
name|buffer_remainder
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|b
operator|->
name|iterpool
argument_list|)
expr_stmt|;
comment|/* fill read buffer, if necessary */
if|if
condition|(
operator|!
operator|(
name|b
operator|->
name|readbuf_off
operator|<
name|b
operator|->
name|readbuf
operator|->
name|len
operator|)
condition|)
block|{
name|svn_stream_t
modifier|*
name|buf_stream
decl_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|b
operator|->
name|readbuf
argument_list|)
expr_stmt|;
name|b
operator|->
name|readbuf_off
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|b
operator|->
name|stream
argument_list|,
name|b
operator|->
name|buf
argument_list|,
operator|&
name|readlen
argument_list|)
argument_list|)
expr_stmt|;
name|buf_stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|b
operator|->
name|readbuf
argument_list|,
name|b
operator|->
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|translate_chunk
argument_list|(
name|buf_stream
argument_list|,
name|b
operator|->
name|in_baton
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|readlen
argument_list|,
name|b
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlen
operator|!=
name|SVN__STREAM_CHUNK_SIZE
condition|)
name|SVN_ERR
argument_list|(
name|translate_chunk
argument_list|(
name|buf_stream
argument_list|,
name|b
operator|->
name|in_baton
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|b
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|buf_stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Satisfy from the read buffer */
name|buffer_remainder
operator|=
name|b
operator|->
name|readbuf
operator|->
name|len
operator|-
name|b
operator|->
name|readbuf_off
expr_stmt|;
name|to_copy
operator|=
operator|(
name|buffer_remainder
operator|>
name|unsatisfied
operator|)
condition|?
name|unsatisfied
else|:
name|buffer_remainder
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|+
name|off
argument_list|,
name|b
operator|->
name|readbuf
operator|->
name|data
operator|+
name|b
operator|->
name|readbuf_off
argument_list|,
name|to_copy
argument_list|)
expr_stmt|;
name|off
operator|+=
name|to_copy
expr_stmt|;
name|b
operator|->
name|readbuf_off
operator|+=
name|to_copy
expr_stmt|;
name|unsatisfied
operator|-=
name|to_copy
expr_stmt|;
block|}
operator|*
name|len
operator|-=
name|unsatisfied
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_write_fn_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|translated_stream_write
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|translated_stream_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|b
operator|->
name|iterpool
argument_list|)
expr_stmt|;
name|b
operator|->
name|written
operator|=
name|TRUE
expr_stmt|;
return|return
name|translate_chunk
argument_list|(
name|b
operator|->
name|stream
argument_list|,
name|b
operator|->
name|out_baton
argument_list|,
name|buffer
argument_list|,
operator|*
name|len
argument_list|,
name|b
operator|->
name|iterpool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_close_fn_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|translated_stream_close
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|translated_stream_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|written
condition|)
name|err
operator|=
name|translate_chunk
argument_list|(
name|b
operator|->
name|stream
argument_list|,
name|b
operator|->
name|out_baton
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|b
operator|->
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_stream_close
argument_list|(
name|b
operator|->
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|b
operator|->
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* svn_stream_mark_t for translation streams. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|mark_translated_t
block|{
comment|/* Saved translation state. */
name|struct
name|translated_stream_baton
name|saved_baton
decl_stmt|;
comment|/* Mark set on the underlying stream. */
name|svn_stream_mark_t
modifier|*
name|mark
decl_stmt|;
block|}
name|mark_translated_t
typedef|;
end_typedef

begin_comment
comment|/* Implements svn_stream_mark_fn_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|translated_stream_mark
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_mark_t
modifier|*
modifier|*
name|mark
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|mark_translated_t
modifier|*
name|mt
decl_stmt|;
name|struct
name|translated_stream_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|mt
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_mark
argument_list|(
name|b
operator|->
name|stream
argument_list|,
operator|&
name|mt
operator|->
name|mark
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save translation state. */
name|mt
operator|->
name|saved_baton
operator|.
name|in_baton
operator|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|b
operator|->
name|in_baton
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mt
operator|->
name|saved_baton
operator|.
name|in_baton
argument_list|)
argument_list|)
expr_stmt|;
name|mt
operator|->
name|saved_baton
operator|.
name|out_baton
operator|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|b
operator|->
name|out_baton
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mt
operator|->
name|saved_baton
operator|.
name|out_baton
argument_list|)
argument_list|)
expr_stmt|;
name|mt
operator|->
name|saved_baton
operator|.
name|written
operator|=
name|b
operator|->
name|written
expr_stmt|;
name|mt
operator|->
name|saved_baton
operator|.
name|readbuf
operator|=
name|svn_stringbuf_dup
argument_list|(
name|b
operator|->
name|readbuf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|mt
operator|->
name|saved_baton
operator|.
name|readbuf_off
operator|=
name|b
operator|->
name|readbuf_off
expr_stmt|;
name|mt
operator|->
name|saved_baton
operator|.
name|buf
operator|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|SVN__TRANSLATION_BUF_SIZE
argument_list|)
expr_stmt|;
operator|*
name|mark
operator|=
operator|(
name|svn_stream_mark_t
operator|*
operator|)
name|mt
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream_seek_fn_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|translated_stream_seek
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_stream_mark_t
modifier|*
name|mark
parameter_list|)
block|{
name|struct
name|translated_stream_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|mark
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|mark_translated_t
modifier|*
name|mt
init|=
operator|(
specifier|const
name|mark_translated_t
operator|*
operator|)
name|mark
decl_stmt|;
comment|/* Flush output buffer if necessary. */
if|if
condition|(
name|b
operator|->
name|written
condition|)
name|SVN_ERR
argument_list|(
name|translate_chunk
argument_list|(
name|b
operator|->
name|stream
argument_list|,
name|b
operator|->
name|out_baton
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|b
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_seek
argument_list|(
name|b
operator|->
name|stream
argument_list|,
name|mt
operator|->
name|mark
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore translation state, avoiding new allocations. */
operator|*
name|b
operator|->
name|in_baton
operator|=
operator|*
name|mt
operator|->
name|saved_baton
operator|.
name|in_baton
expr_stmt|;
operator|*
name|b
operator|->
name|out_baton
operator|=
operator|*
name|mt
operator|->
name|saved_baton
operator|.
name|out_baton
expr_stmt|;
name|b
operator|->
name|written
operator|=
name|mt
operator|->
name|saved_baton
operator|.
name|written
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|b
operator|->
name|readbuf
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|b
operator|->
name|readbuf
argument_list|,
name|mt
operator|->
name|saved_baton
operator|.
name|readbuf
operator|->
name|data
argument_list|,
name|mt
operator|->
name|saved_baton
operator|.
name|readbuf
operator|->
name|len
argument_list|)
expr_stmt|;
name|b
operator|->
name|readbuf_off
operator|=
name|mt
operator|->
name|saved_baton
operator|.
name|readbuf_off
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|buf
argument_list|,
name|mt
operator|->
name|saved_baton
operator|.
name|buf
argument_list|,
name|SVN__TRANSLATION_BUF_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_reset
argument_list|(
name|b
operator|->
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|in_baton
operator|->
name|newline_off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|in_baton
operator|->
name|keyword_off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|in_baton
operator|->
name|src_format_len
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|out_baton
operator|->
name|newline_off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|out_baton
operator|->
name|keyword_off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|out_baton
operator|->
name|src_format_len
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|written
operator|=
name|FALSE
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|b
operator|->
name|readbuf
argument_list|)
expr_stmt|;
name|b
operator|->
name|readbuf_off
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_stream__is_buffered_fn_t. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|translated_stream_is_buffered
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|translated_stream_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
return|return
name|svn_stream__is_buffered
argument_list|(
name|b
operator|->
name|stream
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_subst_read_specialfile
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|svn_string_t
modifier|*
name|buf
decl_stmt|;
comment|/* First determine what type of special file we are      detranslating. */
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_MIN
operator||
name|APR_FINFO_LINK
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|finfo
operator|.
name|filetype
condition|)
block|{
case|case
name|APR_REG
case|:
comment|/* Nothing special to do here, just create stream from the original        file's contents. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
name|stream
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_LNK
case|:
comment|/* Determine the destination of the link. */
name|SVN_ERR
argument_list|(
name|svn_io_read_link
argument_list|(
operator|&
name|buf
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_string
argument_list|(
name|svn_string_createf
argument_list|(
name|result_pool
argument_list|,
literal|"link %s"
argument_list|,
name|buf
operator|->
name|data
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Same as svn_subst_stream_translated(), except for the following.  *  * If TRANSLATED_EOL is not NULL, then reading and/or writing to the stream  * will set *TRANSLATED_EOL to TRUE if an end-of-line sequence was changed,  * otherwise leave it untouched.  */
end_comment

begin_function
specifier|static
name|svn_stream_t
modifier|*
name|stream_translated
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|translated_eol
parameter_list|,
name|svn_boolean_t
name|repair
parameter_list|,
name|apr_hash_t
modifier|*
name|keywords
parameter_list|,
name|svn_boolean_t
name|expand
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|struct
name|translated_stream_baton
modifier|*
name|baton
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|s
init|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
comment|/* Make sure EOL_STR and KEYWORDS are allocated in RESULT_POOL      so they have the same lifetime as the stream. */
if|if
condition|(
name|eol_str
condition|)
name|eol_str
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|eol_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|keywords
condition|)
block|{
if|if
condition|(
name|apr_hash_count
argument_list|(
name|keywords
argument_list|)
operator|==
literal|0
condition|)
name|keywords
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* deep copy the hash to make sure it's allocated in RESULT_POOL */
name|apr_hash_t
modifier|*
name|copy
init|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|keywords
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|copy
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|key
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|val
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|keywords
operator|=
name|copy
expr_stmt|;
block|}
block|}
comment|/* Setup the baton fields */
name|baton
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|baton
operator|->
name|in_baton
operator|=
name|create_translation_baton
argument_list|(
name|eol_str
argument_list|,
name|translated_eol
argument_list|,
name|repair
argument_list|,
name|keywords
argument_list|,
name|expand
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|out_baton
operator|=
name|create_translation_baton
argument_list|(
name|eol_str
argument_list|,
name|translated_eol
argument_list|,
name|repair
argument_list|,
name|keywords
argument_list|,
name|expand
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|written
operator|=
name|FALSE
expr_stmt|;
name|baton
operator|->
name|readbuf
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|readbuf_off
operator|=
literal|0
expr_stmt|;
name|baton
operator|->
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|buf
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|SVN__TRANSLATION_BUF_SIZE
argument_list|)
expr_stmt|;
comment|/* Setup the stream methods */
name|svn_stream_set_read
argument_list|(
name|s
argument_list|,
name|translated_stream_read
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|s
argument_list|,
name|translated_stream_write
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|s
argument_list|,
name|translated_stream_close
argument_list|)
expr_stmt|;
name|svn_stream_set_mark
argument_list|(
name|s
argument_list|,
name|translated_stream_mark
argument_list|)
expr_stmt|;
name|svn_stream_set_seek
argument_list|(
name|s
argument_list|,
name|translated_stream_seek
argument_list|)
expr_stmt|;
name|svn_stream__set_is_buffered
argument_list|(
name|s
argument_list|,
name|translated_stream_is_buffered
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_subst_stream_translated
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
name|repair
parameter_list|,
name|apr_hash_t
modifier|*
name|keywords
parameter_list|,
name|svn_boolean_t
name|expand
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
return|return
name|stream_translated
argument_list|(
name|stream
argument_list|,
name|eol_str
argument_list|,
name|NULL
argument_list|,
name|repair
argument_list|,
name|keywords
argument_list|,
name|expand
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Same as svn_subst_translate_cstring2(), except for the following.  *  * If TRANSLATED_EOL is not NULL, then set *TRANSLATED_EOL to TRUE if an  * end-of-line sequence was changed, or to FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|translate_cstring
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dst
parameter_list|,
name|svn_boolean_t
modifier|*
name|translated_eol
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
name|repair
parameter_list|,
name|apr_hash_t
modifier|*
name|keywords
parameter_list|,
name|svn_boolean_t
name|expand
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|dst_stringbuf
decl_stmt|;
name|svn_stream_t
modifier|*
name|dst_stream
decl_stmt|;
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* The easy way out:  no translation needed, just copy. */
if|if
condition|(
operator|!
operator|(
name|eol_str
operator|||
operator|(
name|keywords
operator|&&
operator|(
name|apr_hash_count
argument_list|(
name|keywords
argument_list|)
operator|>
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
operator|*
name|dst
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Create a stringbuf and wrapper stream to hold the output. */
name|dst_stringbuf
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|dst_stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|dst_stringbuf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|translated_eol
condition|)
operator|*
name|translated_eol
operator|=
name|FALSE
expr_stmt|;
comment|/* Another wrapper to translate the content. */
name|dst_stream
operator|=
name|stream_translated
argument_list|(
name|dst_stream
argument_list|,
name|eol_str
argument_list|,
name|translated_eol
argument_list|,
name|repair
argument_list|,
name|keywords
argument_list|,
name|expand
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Jam the text into the destination stream (to translate it). */
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|dst_stream
argument_list|,
name|src
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close the destination stream to flush unwritten data. */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|dst_stream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|=
name|dst_stringbuf
operator|->
name|data
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_subst_translate_cstring2
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
name|repair
parameter_list|,
name|apr_hash_t
modifier|*
name|keywords
parameter_list|,
name|svn_boolean_t
name|expand
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|translate_cstring
argument_list|(
name|dst
argument_list|,
name|NULL
argument_list|,
name|src
argument_list|,
name|eol_str
argument_list|,
name|repair
argument_list|,
name|keywords
argument_list|,
name|expand
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a special file at SRC, generate a textual representation of    it in a normal file at DST.  Perform all allocations in POOL. */
end_comment

begin_comment
comment|/* ### this should be folded into svn_subst_copy_and_translate3 */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|detranslate_special_file
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dst_tmp
decl_stmt|;
name|svn_stream_t
modifier|*
name|src_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|dst_stream
decl_stmt|;
comment|/* Open a temporary destination that we will eventually atomically      rename into place. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|dst_stream
argument_list|,
operator|&
name|dst_tmp
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|dst
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_read_specialfile
argument_list|(
operator|&
name|src_stream
argument_list|,
name|src
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|src_stream
argument_list|,
name|dst_stream
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the atomic rename from our temporary location. */
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_rename
argument_list|(
name|dst_tmp
argument_list|,
name|dst
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Creates a special file DST from the "normal form" located in SOURCE.  *  * All temporary allocations will be done in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_special_file_from_stream
parameter_list|(
name|svn_stream_t
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|contents
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
specifier|const
name|char
modifier|*
name|identifier
decl_stmt|;
specifier|const
name|char
modifier|*
name|remainder
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_tmp
decl_stmt|;
name|svn_boolean_t
name|create_using_internal_representation
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|source
argument_list|,
operator|&
name|contents
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Separate off the identifier.  The first space character delimits      the identifier, after which any remaining characters are specific      to the actual special file type being created. */
name|identifier
operator|=
name|contents
operator|->
name|data
expr_stmt|;
for|for
control|(
name|remainder
operator|=
name|identifier
init|;
operator|*
name|remainder
condition|;
name|remainder
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|remainder
operator|==
literal|' '
condition|)
block|{
name|remainder
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|identifier
argument_list|,
name|SVN_SUBST__SPECIAL_LINK_STR
literal|" "
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_SUBST__SPECIAL_LINK_STR
literal|" "
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* For symlinks, the type specific data is just a filesystem          path that the symlink should reference. */
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_create_unique_link
argument_list|(
operator|&
name|dst_tmp
argument_list|,
name|dst
argument_list|,
name|remainder
argument_list|,
literal|".tmp"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* If we had an error, check to see if it was because symlinks are          not supported on the platform.  If so, fall back          to using the internal representation. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_UNSUPPORTED_FEATURE
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|create_using_internal_representation
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
return|return
name|err
return|;
block|}
block|}
else|else
block|{
comment|/* Just create a normal file using the internal special file          representation.  We don't want a commit of an unknown special          file type to DoS all the clients. */
name|create_using_internal_representation
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If nothing else worked, write out the internal representation to      a file that can be edited by the user.       ### this only writes the first line!   */
if|if
condition|(
name|create_using_internal_representation
condition|)
block|{
name|apr_file_t
modifier|*
name|new_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|new_file
argument_list|,
operator|&
name|dst_tmp
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|new_file
argument_list|,
name|contents
operator|->
name|data
argument_list|,
name|contents
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|new_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do the atomic rename from our temporary location. */
return|return
name|svn_io_file_rename
argument_list|(
name|dst_tmp
argument_list|,
name|dst
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_subst_copy_and_translate4
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
name|repair
parameter_list|,
name|apr_hash_t
modifier|*
name|keywords
parameter_list|,
name|svn_boolean_t
name|expand
parameter_list|,
name|svn_boolean_t
name|special
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|src_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|dst_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_tmp
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|path_special
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|src
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|path_special
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a 'special' file, we may need to create it or      detranslate it. */
if|if
condition|(
name|special
operator|||
name|path_special
condition|)
block|{
if|if
condition|(
name|expand
condition|)
block|{
if|if
condition|(
name|path_special
condition|)
block|{
comment|/* We are being asked to create a special file from a special                  file.  Do a temporary detranslation and work from there. */
comment|/* ### woah. this section just undoes all the work we already did                  ### to read the contents of the special file. shoot... the                  ### svn_subst_read_specialfile even checks the file type                  ### for us! */
name|SVN_ERR
argument_list|(
name|svn_subst_read_specialfile
argument_list|(
operator|&
name|src_stream
argument_list|,
name|src
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|src_stream
argument_list|,
name|src
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|create_special_file_from_stream
argument_list|(
name|src_stream
argument_list|,
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* else !expand */
return|return
name|svn_error_trace
argument_list|(
name|detranslate_special_file
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* The easy way out:  no translation needed, just copy. */
if|if
condition|(
operator|!
operator|(
name|eol_str
operator|||
operator|(
name|keywords
operator|&&
operator|(
name|apr_hash_count
argument_list|(
name|keywords
argument_list|)
operator|>
literal|0
operator|)
operator|)
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_io_copy_file
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* Open source file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|src_stream
argument_list|,
name|src
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For atomicity, we translate to a tmp file and then rename the tmp file      over the real destination. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|dst_stream
argument_list|,
operator|&
name|dst_tmp
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|dst_stream
operator|=
name|svn_subst_stream_translated
argument_list|(
name|dst_stream
argument_list|,
name|eol_str
argument_list|,
name|repair
argument_list|,
name|keywords
argument_list|,
name|expand
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* ###: use cancel func/baton in place of NULL/NULL below. */
name|err
operator|=
name|svn_stream_copy3
argument_list|(
name|src_stream
argument_list|,
name|dst_stream
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* On errors, we have a pathname available. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_IO_INCONSISTENT_EOL
condition|)
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_INCONSISTENT_EOL
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"File '%s' has inconsistent newlines"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_remove_file2
argument_list|(
name|dst_tmp
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Now that dst_tmp contains the translated data, do the atomic rename. */
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|dst_tmp
argument_list|,
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Preserve the source file's permission bits. */
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** 'Special file' stream support */
end_comment

begin_struct
struct|struct
name|special_stream_baton
block|{
name|svn_stream_t
modifier|*
name|read_stream
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|write_content
decl_stmt|;
name|svn_stream_t
modifier|*
name|write_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_special
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|special_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|read_stream
condition|)
comment|/* We actually found a file to read from */
return|return
name|svn_stream_read
argument_list|(
name|btn
operator|->
name|read_stream
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|APR_ENOENT
argument_list|,
name|NULL
argument_list|,
literal|"Can't read special file: File '%s' not found"
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|btn
operator|->
name|path
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_special
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|special_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
return|return
name|svn_stream_write
argument_list|(
name|btn
operator|->
name|write_stream
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler_special
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|special_stream_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|btn
operator|->
name|write_content
operator|->
name|len
condition|)
block|{
comment|/* yeay! we received data and need to create a special file! */
name|svn_stream_t
modifier|*
name|source
init|=
name|svn_stream_from_stringbuf
argument_list|(
name|btn
operator|->
name|write_content
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|create_special_file_from_stream
argument_list|(
name|source
argument_list|,
name|btn
operator|->
name|path
argument_list|,
name|btn
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_subst_create_specialfile
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|special_stream_baton
modifier|*
name|baton
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
decl_stmt|;
name|baton
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* SCRATCH_POOL may not exist after the function returns. */
name|baton
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|baton
operator|->
name|write_content
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|write_stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|baton
operator|->
name|write_content
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
operator|*
name|stream
argument_list|,
name|write_handler_special
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
operator|*
name|stream
argument_list|,
name|close_handler_special
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* NOTE: this function is deprecated, but we cannot move it over to    deprecated.c because it uses stuff private to this file, and it is    not easily rebuilt in terms of "new" functions. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_subst_stream_from_specialfile
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|special_stream_baton
modifier|*
name|baton
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|baton
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_subst_read_specialfile
argument_list|(
operator|&
name|baton
operator|->
name|read_stream
argument_list|,
name|path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* File might not exist because we intend to create it upon close. */
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Note: the special file is missing. the caller won't find out          until the first read. Oh well. This function is deprecated anyways,          so they can just deal with the weird behavior. */
name|baton
operator|->
name|read_stream
operator|=
name|NULL
expr_stmt|;
block|}
name|baton
operator|->
name|write_content
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|write_stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|baton
operator|->
name|write_content
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
operator|*
name|stream
argument_list|,
name|read_handler_special
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
operator|*
name|stream
argument_list|,
name|write_handler_special
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
operator|*
name|stream
argument_list|,
name|close_handler_special
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** String translation */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_subst_translate_string2
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|new_value
parameter_list|,
name|svn_boolean_t
modifier|*
name|translated_to_utf8
parameter_list|,
name|svn_boolean_t
modifier|*
name|translated_line_endings
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|svn_boolean_t
name|repair
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|val_utf8
decl_stmt|;
specifier|const
name|char
modifier|*
name|val_utf8_lf
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
operator|*
name|new_value
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|encoding
operator|&&
operator|!
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"UTF-8"
argument_list|)
condition|)
block|{
name|val_utf8
operator|=
name|value
operator|->
name|data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encoding
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8_ex2
argument_list|(
operator|&
name|val_utf8
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|encoding
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|val_utf8
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|translated_to_utf8
condition|)
operator|*
name|translated_to_utf8
operator|=
operator|(
name|strcmp
argument_list|(
name|value
operator|->
name|data
argument_list|,
name|val_utf8
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|translate_cstring
argument_list|(
operator|&
name|val_utf8_lf
argument_list|,
name|translated_line_endings
argument_list|,
name|val_utf8
argument_list|,
literal|"\n"
argument_list|,
comment|/* translate to LF */
name|repair
argument_list|,
name|NULL
argument_list|,
comment|/* no keywords */
name|FALSE
argument_list|,
comment|/* no expansion */
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_value
operator|=
name|svn_string_create
argument_list|(
name|val_utf8_lf
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_subst_detranslate_string
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|new_value
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|svn_boolean_t
name|for_output
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|val_neol
decl_stmt|;
specifier|const
name|char
modifier|*
name|val_nlocale_neol
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
operator|*
name|new_value
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|value
operator|->
name|data
argument_list|,
operator|&
name|val_neol
argument_list|,
name|APR_EOL_STR
argument_list|,
comment|/* 'native' eol */
name|FALSE
argument_list|,
comment|/* no repair */
name|NULL
argument_list|,
comment|/* no keywords */
name|FALSE
argument_list|,
comment|/* no expansion */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_output
condition|)
block|{
name|err
operator|=
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|val_nlocale_neol
argument_list|,
name|val_neol
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_EINVAL
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|val_nlocale_neol
operator|=
name|svn_cmdline_cstring_from_utf8_fuzzy
argument_list|(
name|val_neol
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
else|else
block|{
name|err
operator|=
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|val_nlocale_neol
argument_list|,
name|val_neol
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_EINVAL
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|val_nlocale_neol
operator|=
name|svn_utf_cstring_from_utf8_fuzzy
argument_list|(
name|val_neol
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
operator|*
name|new_value
operator|=
name|svn_string_create
argument_list|(
name|val_nlocale_neol
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

