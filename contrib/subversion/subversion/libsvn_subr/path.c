begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * paths.c:   a path manipulation library using svn_stringbuf_t  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* for SVN_PATH_LOCAL_SEPARATOR */
end_comment

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_comment
comment|/* for svn_io_stat() */
end_comment

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"dirent_uri.h"
end_include

begin_comment
comment|/* The canonical empty path.  Can this be changed?  Well, change the empty    test below and the path library will work, not so sure about the fs/wc    libraries. */
end_comment

begin_define
define|#
directive|define
name|SVN_EMPTY_PATH
value|""
end_define

begin_comment
comment|/* TRUE if s is the canonical empty path, FALSE otherwise */
end_comment

begin_define
define|#
directive|define
name|SVN_PATH_IS_EMPTY
parameter_list|(
name|s
parameter_list|)
value|((s)[0] == '\0')
end_define

begin_comment
comment|/* TRUE if s,n is the platform's empty path ("."), FALSE otherwise. Can    this be changed?  Well, the path library will work, not so sure about    the OS! */
end_comment

begin_define
define|#
directive|define
name|SVN_PATH_IS_PLATFORM_EMPTY
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|((n) == 1&& (s)[0] == '.')
end_define

begin_escape
end_escape

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* This function is an approximation of svn_path_is_canonical.  * It is supposed to be used in functions that do not have access  * to a pool, but still want to assert that a path is canonical.  *  * PATH with length LEN is assumed to be canonical if it isn't  * the platform's empty path (see definition of SVN_PATH_IS_PLATFORM_EMPTY),  * and does not contain "/./", and any one of the following  * conditions is also met:  *  *  1. PATH has zero length  *  2. PATH is the root directory (what exactly a root directory is  *                                depends on the platform)  *  3. PATH is not a root directory and does not end with '/'  *  * If possible, please use svn_path_is_canonical instead.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_canonical
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
return|return
operator|(
operator|!
name|SVN_PATH_IS_PLATFORM_EMPTY
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
operator|&&
name|strstr
argument_list|(
name|path
argument_list|,
literal|"/./"
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|len
operator|==
literal|0
operator|||
operator|(
name|len
operator|==
literal|1
operator|&&
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|||
name|svn_dirent_is_root
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* functionality of svn_path_is_canonical but without the deprecation */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|svn_path_is_canonical_internal
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_uri_is_canonical
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
operator|||
name|svn_dirent_is_canonical
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
operator|||
name|svn_relpath_is_canonical
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_path_is_canonical
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_path_is_canonical_internal
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* functionality of svn_path_join but without the deprecation */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|svn_path_join_internal
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|blen
init|=
name|strlen
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|apr_size_t
name|clen
init|=
name|strlen
argument_list|(
name|component
argument_list|)
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|assert
argument_list|(
name|svn_path_is_canonical_internal
argument_list|(
name|base
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_path_is_canonical_internal
argument_list|(
name|component
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the component is absolute, then return it.  */
if|if
condition|(
operator|*
name|component
operator|==
literal|'/'
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
return|;
comment|/* If either is empty return the other */
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|base
argument_list|)
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
return|;
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|component
argument_list|)
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|base
argument_list|,
name|blen
operator|+
literal|1
argument_list|)
return|;
if|if
condition|(
name|blen
operator|==
literal|1
operator|&&
name|base
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|blen
operator|=
literal|0
expr_stmt|;
comment|/* Ignore base, just return separator + component */
comment|/* Construct the new, combined path. */
name|path
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|blen
operator|+
literal|1
operator|+
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|base
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|path
index|[
name|blen
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|+
name|blen
operator|+
literal|1
argument_list|,
name|component
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_path_join
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_path_join_internal
argument_list|(
name|base
argument_list|,
name|component
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_path_join_many
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
modifier|...
parameter_list|)
block|{
define|#
directive|define
name|MAX_SAVED_LENGTHS
value|10
name|apr_size_t
name|saved_lengths
index|[
name|MAX_SAVED_LENGTHS
index|]
decl_stmt|;
name|apr_size_t
name|total_len
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|va_list
name|va
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|svn_boolean_t
name|base_is_empty
init|=
name|FALSE
decl_stmt|,
name|base_is_root
init|=
name|FALSE
decl_stmt|;
name|int
name|base_arg
init|=
literal|0
decl_stmt|;
name|total_len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_path_is_canonical_internal
argument_list|(
name|base
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_len
operator|==
literal|1
operator|&&
operator|*
name|base
operator|==
literal|'/'
condition|)
name|base_is_root
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|total_len
operator|=
sizeof|sizeof
argument_list|(
name|SVN_EMPTY_PATH
argument_list|)
operator|-
literal|1
expr_stmt|;
name|base_is_empty
operator|=
name|TRUE
expr_stmt|;
block|}
name|saved_lengths
index|[
literal|0
index|]
operator|=
name|total_len
expr_stmt|;
comment|/* Compute the length of the resulting string. */
name|nargs
operator|=
literal|0
expr_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|va_arg
argument_list|(
name|va
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|svn_path_is_canonical_internal
argument_list|(
name|s
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|s
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nargs
operator|++
operator|<
name|MAX_SAVED_LENGTHS
condition|)
name|saved_lengths
index|[
name|nargs
index|]
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
block|{
comment|/* an absolute path. skip all components to this point and reset              the total length. */
name|total_len
operator|=
name|len
expr_stmt|;
name|base_arg
operator|=
name|nargs
expr_stmt|;
name|base_is_root
operator|=
name|len
operator|==
literal|1
expr_stmt|;
name|base_is_empty
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nargs
operator|==
name|base_arg
operator|||
operator|(
name|nargs
operator|==
name|base_arg
operator|+
literal|1
operator|&&
name|base_is_root
operator|)
operator|||
name|base_is_empty
condition|)
block|{
comment|/* if we have skipped everything up to this arg, then the base              and all prior components are empty. just set the length to              this component; do not add a separator.  If the base is empty              we can now ignore it. */
if|if
condition|(
name|base_is_empty
condition|)
block|{
name|base_is_empty
operator|=
name|FALSE
expr_stmt|;
name|total_len
operator|=
literal|0
expr_stmt|;
block|}
name|total_len
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|total_len
operator|+=
literal|1
operator|+
name|len
expr_stmt|;
block|}
block|}
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
comment|/* base == "/" and no further components. just return that. */
if|if
condition|(
name|base_is_root
operator|&&
name|total_len
operator|==
literal|1
condition|)
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
literal|2
argument_list|)
return|;
comment|/* we got the total size. allocate it, with room for a NULL character. */
name|path
operator|=
name|p
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|total_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* if we aren't supposed to skip forward to an absolute component, and if      this is not an empty base that we are skipping, then copy the base      into the output. */
if|if
condition|(
name|base_arg
operator|==
literal|0
operator|&&
operator|!
operator|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|base
argument_list|)
operator|&&
operator|!
name|base_is_empty
operator|)
condition|)
block|{
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|base
argument_list|)
condition|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|SVN_EMPTY_PATH
argument_list|,
name|len
operator|=
name|saved_lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|p
argument_list|,
name|base
argument_list|,
name|len
operator|=
name|saved_lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
name|nargs
operator|=
literal|0
expr_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|va_arg
argument_list|(
name|va
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|s
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|++
name|nargs
operator|<
name|base_arg
condition|)
continue|continue;
if|if
condition|(
name|nargs
operator|<
name|MAX_SAVED_LENGTHS
condition|)
name|len
operator|=
name|saved_lengths
index|[
name|nargs
index|]
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* insert a separator if we aren't copying in the first component          (which can happen when base_arg is set). also, don't put in a slash          if the prior character is a slash (occurs when prior component          is "/"). */
if|if
condition|(
name|p
operator|!=
name|path
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* copy the new component and advance the pointer */
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
call|(
name|apr_size_t
call|)
argument_list|(
name|p
operator|-
name|path
argument_list|)
operator|==
name|total_len
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|apr_size_t
name|svn_path_component_count
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|apr_size_t
name|count
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|is_canonical
argument_list|(
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|path
condition|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
while|while
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
operator|++
name|path
expr_stmt|;
name|start
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|path
operator|&&
operator|*
name|path
operator|!=
literal|'/'
condition|)
operator|++
name|path
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|start
condition|)
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Return the length of substring necessary to encompass the entire  * previous path segment in PATH, which should be a LEN byte string.  *  * A trailing slash will not be included in the returned length except  * in the case in which PATH is absolute and there are no more  * previous segments.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|previous_segment
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|path
index|[
operator|--
name|len
index|]
operator|!=
literal|'/'
condition|)
empty_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
else|else
return|return
name|len
return|;
block|}
end_function

begin_function
name|void
name|svn_path_add_component
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|component
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|is_canonical
argument_list|(
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_canonical
argument_list|(
name|component
argument_list|,
name|strlen
argument_list|(
name|component
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Append a dir separator, but only if this path is neither empty      nor consists of a single dir separator already. */
if|if
condition|(
operator|(
operator|!
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path
operator|->
name|data
argument_list|)
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|path
operator|->
name|len
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
operator|(
name|path
operator|->
name|data
operator|)
operator|==
literal|'/'
operator|)
operator|)
operator|)
condition|)
block|{
name|char
name|dirsep
init|=
literal|'/'
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|path
argument_list|,
operator|&
name|dirsep
argument_list|,
sizeof|sizeof
argument_list|(
name|dirsep
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendbytes
argument_list|(
name|path
argument_list|,
name|component
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_path_remove_component
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|path
parameter_list|)
block|{
name|assert
argument_list|(
name|is_canonical
argument_list|(
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|->
name|len
operator|=
name|previous_segment
argument_list|(
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|)
expr_stmt|;
name|path
operator|->
name|data
index|[
name|path
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_path_remove_components
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|path
parameter_list|,
name|apr_size_t
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|svn_path_remove_component
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|svn_path_dirname
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|svn_path_is_canonical_internal
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|,
name|previous_segment
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_path_basename
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|apr_size_t
name|start
decl_stmt|;
name|assert
argument_list|(
name|svn_path_is_canonical_internal
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|start
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|start
operator|>
literal|0
operator|&&
name|path
index|[
name|start
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|start
expr_stmt|;
block|}
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|path
operator|+
name|start
argument_list|,
name|len
operator|-
name|start
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svn_path_is_empty
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|assert
argument_list|(
name|is_canonical
argument_list|(
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svn_path_compare_paths
parameter_list|(
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|)
block|{
name|apr_size_t
name|path1_len
init|=
name|strlen
argument_list|(
name|path1
argument_list|)
decl_stmt|;
name|apr_size_t
name|path2_len
init|=
name|strlen
argument_list|(
name|path2
argument_list|)
decl_stmt|;
name|apr_size_t
name|min_len
init|=
operator|(
operator|(
name|path1_len
operator|<
name|path2_len
operator|)
condition|?
name|path1_len
else|:
name|path2_len
operator|)
decl_stmt|;
name|apr_size_t
name|i
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|is_canonical
argument_list|(
name|path1
argument_list|,
name|path1_len
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_canonical
argument_list|(
name|path2
argument_list|,
name|path2_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip past common prefix. */
while|while
condition|(
name|i
operator|<
name|min_len
operator|&&
name|path1
index|[
name|i
index|]
operator|==
name|path2
index|[
name|i
index|]
condition|)
operator|++
name|i
expr_stmt|;
comment|/* Are the paths exactly the same? */
if|if
condition|(
operator|(
name|path1_len
operator|==
name|path2_len
operator|)
operator|&&
operator|(
name|i
operator|>=
name|min_len
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Children of paths are greater than their parents, but less than      greater siblings of their parents. */
if|if
condition|(
operator|(
name|path1
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|path2
index|[
name|i
index|]
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|path2
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|path1
index|[
name|i
index|]
operator|==
literal|0
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|path1
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|path2
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
comment|/* Common prefix was skipped above, next character is compared to      determine order.  We need to use an unsigned comparison, though,      so a "next character" of NULL (0x00) sorts numerically      smallest. */
return|return
operator|(
name|unsigned
name|char
operator|)
operator|(
name|path1
index|[
name|i
index|]
operator|)
operator|<
call|(
name|unsigned
name|char
call|)
argument_list|(
name|path2
index|[
name|i
index|]
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the string length of the longest common ancestor of PATH1 and PATH2.  *  * This function handles everything except the URL-handling logic  * of svn_path_get_longest_ancestor, and assumes that PATH1 and  * PATH2 are *not* URLs.  *  * If the two paths do not share a common ancestor, return 0.  *  * New strings are allocated in POOL.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|get_path_ancestor_length
parameter_list|(
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|path1_len
decl_stmt|,
name|path2_len
decl_stmt|;
name|apr_size_t
name|i
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|last_dirsep
init|=
literal|0
decl_stmt|;
name|path1_len
operator|=
name|strlen
argument_list|(
name|path1
argument_list|)
expr_stmt|;
name|path2_len
operator|=
name|strlen
argument_list|(
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path1
argument_list|)
operator|||
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path2
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|path1
index|[
name|i
index|]
operator|==
name|path2
index|[
name|i
index|]
condition|)
block|{
comment|/* Keep track of the last directory separator we hit. */
if|if
condition|(
name|path1
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|last_dirsep
operator|=
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* If we get to the end of either path, break out. */
if|if
condition|(
operator|(
name|i
operator|==
name|path1_len
operator|)
operator|||
operator|(
name|i
operator|==
name|path2_len
operator|)
condition|)
break|break;
block|}
comment|/* two special cases:      1. '/' is the longest common ancestor of '/' and '/foo'      2. '/' is the longest common ancestor of '/rif' and '/raf' */
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|path1
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|path2
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
comment|/* last_dirsep is now the offset of the last directory separator we      crossed before reaching a non-matching byte.  i is the offset of      that non-matching byte. */
if|if
condition|(
operator|(
operator|(
name|i
operator|==
name|path1_len
operator|)
operator|&&
operator|(
name|path2
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|==
name|path2_len
operator|)
operator|&&
operator|(
name|path1
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|==
name|path1_len
operator|)
operator|&&
operator|(
name|i
operator|==
name|path2_len
operator|)
operator|)
condition|)
return|return
name|i
return|;
elseif|else
if|if
condition|(
name|last_dirsep
operator|==
literal|0
operator|&&
name|path1
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|path2
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
return|return
name|last_dirsep
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_path_get_longest_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|path1_is_url
init|=
name|svn_path_is_url
argument_list|(
name|path1
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|path2_is_url
init|=
name|svn_path_is_url
argument_list|(
name|path2
argument_list|)
decl_stmt|;
comment|/* Are we messing with URLs?  If we have a mix of URLs and non-URLs,      there's nothing common between them.  */
if|if
condition|(
name|path1_is_url
operator|&&
name|path2_is_url
condition|)
block|{
return|return
name|svn_uri_get_longest_ancestor
argument_list|(
name|path1
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|path1_is_url
operator|)
operator|&&
operator|(
operator|!
name|path2_is_url
operator|)
condition|)
block|{
return|return
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|path1
argument_list|,
name|get_path_ancestor_length
argument_list|(
name|path1
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|/* A URL and a non-URL => no common prefix */
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|SVN_EMPTY_PATH
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_EMPTY_PATH
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_path_is_child
parameter_list|(
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
comment|/* assert (is_canonical (path1, strlen (path1)));  ### Expensive strlen */
comment|/* assert (is_canonical (path2, strlen (path2)));  ### Expensive strlen */
comment|/* Allow "" and "foo" to be parent/child */
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path1
argument_list|)
condition|)
comment|/* "" is the parent  */
block|{
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path2
argument_list|)
comment|/* "" not a child    */
operator|||
name|path2
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
comment|/* "/foo" not a child */
return|return
name|NULL
return|;
else|else
comment|/* everything else is child */
return|return
name|pool
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path2
argument_list|)
else|:
name|path2
return|;
block|}
comment|/* Reach the end of at least one of the paths.  How should we handle      things like path1:"foo///bar" and path2:"foo/bar/baz"?  It doesn't      appear to arise in the current Subversion code, it's not clear to me      if they should be parent/child or not. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|path1
index|[
name|i
index|]
operator|&&
name|path2
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|path1
index|[
name|i
index|]
operator|!=
name|path2
index|[
name|i
index|]
condition|)
return|return
name|NULL
return|;
comment|/* There are two cases that are parent/child           ...      path1[i] == '\0'           .../foo  path2[i] == '/'       or           /        path1[i] == '\0'           /foo     path2[i] != '/'   */
if|if
condition|(
name|path1
index|[
name|i
index|]
operator|==
literal|'\0'
operator|&&
name|path2
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|path2
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
return|return
name|pool
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path2
operator|+
name|i
operator|+
literal|1
argument_list|)
else|:
name|path2
operator|+
name|i
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|path1
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
name|pool
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path2
operator|+
literal|1
argument_list|)
else|:
name|path2
operator|+
literal|1
return|;
block|}
comment|/* Otherwise, path2 isn't a child. */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_path_is_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|)
block|{
name|apr_size_t
name|path1_len
init|=
name|strlen
argument_list|(
name|path1
argument_list|)
decl_stmt|;
comment|/* If path1 is empty and path2 is not absoulte, then path1 is an ancestor. */
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path1
argument_list|)
condition|)
return|return
operator|*
name|path2
operator|!=
literal|'/'
return|;
comment|/* If path1 is a prefix of path2, then:      - If path1 ends in a path separator,      - If the paths are of the same length      OR      - path2 starts a new path component after the common prefix,      then path1 is an ancestor. */
if|if
condition|(
name|strncmp
argument_list|(
name|path1
argument_list|,
name|path2
argument_list|,
name|path1_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|path1
index|[
name|path1_len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|path2
index|[
name|path1_len
index|]
operator|==
literal|'/'
operator|||
name|path2
index|[
name|path1_len
index|]
operator|==
literal|'\0'
operator|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|apr_array_header_t
modifier|*
name|svn_path_decompose
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|,
name|oldi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|components
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|svn_path_is_canonical_internal
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|components
return|;
comment|/* ### Should we return a "" component? */
comment|/* If PATH is absolute, store the '/' as the first component. */
name|i
operator|=
name|oldi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|path
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
name|dirsep
init|=
literal|'/'
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|components
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
operator|&
name|dirsep
argument_list|,
sizeof|sizeof
argument_list|(
name|dirsep
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|oldi
operator|++
expr_stmt|;
if|if
condition|(
name|path
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
comment|/* path is a single '/' */
return|return
name|components
return|;
block|}
do|do
block|{
if|if
condition|(
operator|(
name|path
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|path
index|[
name|i
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|SVN_PATH_IS_PLATFORM_EMPTY
argument_list|(
name|path
operator|+
name|oldi
argument_list|,
name|i
operator|-
name|oldi
argument_list|)
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|components
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_EMPTY_PATH
expr_stmt|;
else|else
name|APR_ARRAY_PUSH
argument_list|(
name|components
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|path
operator|+
name|oldi
argument_list|,
name|i
operator|-
name|oldi
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|oldi
operator|=
name|i
expr_stmt|;
comment|/* skipping past the dirsep */
continue|continue;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|path
index|[
name|i
operator|-
literal|1
index|]
condition|)
do|;
return|return
name|components
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_path_compose
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|components
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
modifier|*
name|lengths
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|components
operator|->
name|nelts
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lengths
argument_list|)
argument_list|)
decl_stmt|;
name|apr_size_t
name|max_length
init|=
name|components
operator|->
name|nelts
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the length of each component so a total length can be      calculated. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|components
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|apr_size_t
name|l
init|=
name|strlen
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|lengths
index|[
name|i
index|]
operator|=
name|l
expr_stmt|;
name|max_length
operator|+=
name|l
expr_stmt|;
block|}
name|path
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|max_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|components
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
comment|/* Append a '/' to the path.  Handle the case with an absolute          path where a '/' appears in the first component.  Only append          a '/' if the component is the second component that does not          follow a "/" first component; or it is the third or later          component. */
if|if
condition|(
name|i
operator|>
literal|1
operator|||
operator|(
name|i
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
literal|"/"
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|lengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
name|lengths
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_path_is_single_path_component
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|assert
argument_list|(
name|is_canonical
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Can't be empty or `..'  */
if|if
condition|(
name|SVN_PATH_IS_EMPTY
argument_list|(
name|name
argument_list|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Slashes are bad, m'kay... */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* It is valid.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_path_is_dotpath_present
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
comment|/* The empty string does not have a dotpath */
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
comment|/* Handle "." or a leading "./" */
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|path
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|path
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* Paths of length 1 (at this point) have no dotpath present. */
if|if
condition|(
name|path
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
comment|/* If any segment is "/./", then a dotpath is present. */
if|if
condition|(
name|strstr
argument_list|(
name|path
argument_list|,
literal|"/./"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Does the path end in "/." ? */
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|path
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_path_is_backpath_present
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
comment|/* 0 and 1-length paths do not have a backpath */
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|path
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
comment|/* Handle ".." or a leading "../" */
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|path
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|path
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
name|path
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* Paths of length 2 (at this point) have no backpath present. */
if|if
condition|(
name|path
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
comment|/* If any segment is "..", then a backpath is present. */
if|if
condition|(
name|strstr
argument_list|(
name|path
argument_list|,
literal|"/../"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Does the path end in "/.." ? */
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|path
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'/'
operator|&&
name|path
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** URI Stuff ***/
end_comment

begin_comment
comment|/* Examine PATH as a potential URI, and return a substring of PATH    that immediately follows the (scheme):// portion of the URI, or    NULL if PATH doesn't appear to be a valid URI.  The returned value    is not alloced -- it shares memory with PATH. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skip_uri_scheme
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|apr_size_t
name|j
decl_stmt|;
comment|/* A scheme is terminated by a : and cannot contain any /'s. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|path
index|[
name|j
index|]
operator|&&
name|path
index|[
name|j
index|]
operator|!=
literal|':'
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|path
index|[
name|j
index|]
operator|==
literal|'/'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|j
operator|>
literal|0
operator|&&
name|path
index|[
name|j
index|]
operator|==
literal|':'
operator|&&
name|path
index|[
name|j
operator|+
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|path
index|[
name|j
operator|+
literal|2
index|]
operator|==
literal|'/'
condition|)
return|return
name|path
operator|+
name|j
operator|+
literal|3
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_path_is_url
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
comment|/* ### This function is reaaaaaaaaaaaaaally stupid right now.      We're just going to look for:          (scheme)://(optional_stuff)       Where (scheme) has no ':' or '/' characters.       Someday it might be nice to have an actual URI parser here.   */
return|return
name|skip_uri_scheme
argument_list|(
name|path
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Here is the BNF for path components in a URI. "pchar" is a    character in a path component.        pchar       = unreserved | escaped |                     ":" | "@" | "&" | "=" | "+" | "$" | ","       unreserved  = alphanum | mark       mark        = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"     Note that "escaped" doesn't really apply to what users can put in    their paths, so that really means the set of characters is:        alphanum | mark | ":" | "@" | "&" | "=" | "+" | "$" | "," */
end_comment

begin_decl_stmt
specifier|const
name|char
name|svn_uri__char_validity
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
comment|/* 64 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 128 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 192 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|svn_boolean_t
name|svn_path_is_uri_safe
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
comment|/* Skip the URI scheme. */
name|path
operator|=
name|skip_uri_scheme
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* No scheme?  Get outta here. */
if|if
condition|(
operator|!
name|path
condition|)
return|return
name|FALSE
return|;
comment|/* Skip to the first slash that's after the URI scheme. */
name|path
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* If there's no first slash, then there's only a host portion;      therefore there couldn't be any uri-unsafe characters after the      host... so return true. */
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|path
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* Allow '%XX' (where each X is a hex digit) */
if|if
condition|(
name|path
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|svn_ctype_isxdigit
argument_list|(
name|path
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|&&
name|svn_ctype_isxdigit
argument_list|(
name|path
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|svn_uri__char_validity
index|[
operator|(
operator|(
name|unsigned
name|char
operator|)
name|path
index|[
name|i
index|]
operator|)
index|]
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* URI-encode each character c in PATH for which TABLE[c] is 0.    If no encoding was needed, return PATH, else return a new string allocated    in POOL. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|uri_escape
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
name|table
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|retstr
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|,
name|copied
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|retstr
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|path
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|path
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|table
index|[
name|c
index|]
condition|)
continue|continue;
comment|/* If we got here, we're looking at a character that isn't          supported by the (or at least, our) URI encoding scheme.  We          need to escape this character.  */
comment|/* First things first, copy all the good stuff that we haven't          yet copied into our output buffer. */
if|if
condition|(
name|i
operator|-
name|copied
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|retstr
argument_list|,
name|path
operator|+
name|copied
argument_list|,
name|i
operator|-
name|copied
argument_list|)
expr_stmt|;
comment|/* Now, write in our escaped character, consisting of the          '%' and two digits.  We cast the C to unsigned char here because          the 'X' format character will be tempted to treat it as an unsigned          int...which causes problem when messing with 0x80-0xFF chars.          We also need space for a null as apr_snprintf will write one. */
name|svn_stringbuf_ensure
argument_list|(
name|retstr
argument_list|,
name|retstr
operator|->
name|len
operator|+
literal|4
argument_list|)
expr_stmt|;
name|apr_snprintf
argument_list|(
name|retstr
operator|->
name|data
operator|+
name|retstr
operator|->
name|len
argument_list|,
literal|4
argument_list|,
literal|"%%%02X"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|retstr
operator|->
name|len
operator|+=
literal|3
expr_stmt|;
comment|/* Finally, update our copy counter. */
name|copied
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
comment|/* If we didn't encode anything, we don't need to duplicate the string. */
if|if
condition|(
name|retstr
operator|->
name|len
operator|==
literal|0
condition|)
return|return
name|path
return|;
comment|/* Anything left to copy? */
if|if
condition|(
name|i
operator|-
name|copied
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|retstr
argument_list|,
name|path
operator|+
name|copied
argument_list|,
name|i
operator|-
name|copied
argument_list|)
expr_stmt|;
comment|/* retstr is null-terminated either by apr_snprintf or the svn_stringbuf      functions. */
return|return
name|retstr
operator|->
name|data
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_path_uri_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|uri_escape
argument_list|(
name|path
argument_list|,
name|svn_uri__char_validity
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Our interface guarantees a copy. */
if|if
condition|(
name|ret
operator|==
name|path
condition|)
return|return
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
return|;
else|else
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|iri_escape_chars
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 128 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|svn_path_uri_from_iri
parameter_list|(
specifier|const
name|char
modifier|*
name|iri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|uri_escape
argument_list|(
name|iri
argument_list|,
name|iri_escape_chars
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|uri_autoescape_chars
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 64 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
comment|/* 128 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 192 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|svn_path_uri_autoescape
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|uri_escape
argument_list|(
name|uri
argument_list|,
name|uri_autoescape_chars
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_path_uri_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|retstr
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|svn_boolean_t
name|query_start
init|=
name|FALSE
decl_stmt|;
comment|/* avoid repeated realloc */
name|retstr
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|retstr
operator|->
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|path
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|path
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
comment|/* Mark the start of the query string, if it exists. */
name|query_start
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
operator|&&
name|query_start
condition|)
block|{
comment|/* Only do this if we are into the query string.            * RFC 2396, section 3.3  */
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|svn_ctype_isxdigit
argument_list|(
name|path
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|&&
name|svn_ctype_isxdigit
argument_list|(
name|path
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
condition|)
block|{
name|char
name|digitz
index|[
literal|3
index|]
decl_stmt|;
name|digitz
index|[
literal|0
index|]
operator|=
name|path
index|[
operator|++
name|i
index|]
expr_stmt|;
name|digitz
index|[
literal|1
index|]
operator|=
name|path
index|[
operator|++
name|i
index|]
expr_stmt|;
name|digitz
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
call|(
name|char
call|)
argument_list|(
name|strtol
argument_list|(
name|digitz
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retstr
operator|->
name|data
index|[
name|retstr
operator|->
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
comment|/* Null-terminate this bad-boy. */
name|retstr
operator|->
name|data
index|[
name|retstr
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|retstr
operator|->
name|data
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_path_url_add_component2
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* = svn_path_uri_encode() but without always copying */
name|component
operator|=
name|uri_escape
argument_list|(
name|component
argument_list|,
name|svn_uri__char_validity
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_path_join_internal
argument_list|(
name|url
argument_list|,
name|component
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_path_get_absolute
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pabsolute
parameter_list|,
specifier|const
name|char
modifier|*
name|relative
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|relative
argument_list|)
condition|)
block|{
operator|*
name|pabsolute
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|relative
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_dirent_get_absolute
argument_list|(
name|pabsolute
argument_list|,
name|relative
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DARWIN
argument_list|)
end_if

begin_comment
comment|/** Get APR's internal path encoding. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_path_encoding
parameter_list|(
name|svn_boolean_t
modifier|*
name|path_is_utf8
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|int
name|encoding_style
decl_stmt|;
name|apr_err
operator|=
name|apr_filepath_encoding
argument_list|(
operator|&
name|encoding_style
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't determine the native path encoding"
argument_list|)
argument_list|)
return|;
comment|/* ### What to do about APR_FILEPATH_ENCODING_UNKNOWN?      Well, for now we'll just punt to the svn_utf_ functions;      those will at least do the ASCII-subset check. */
operator|*
name|path_is_utf8
operator|=
operator|(
name|encoding_style
operator|==
name|APR_FILEPATH_ENCODING_UTF8
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|svn_error_t
modifier|*
name|svn_path_cstring_from_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path_apr
parameter_list|,
specifier|const
name|char
modifier|*
name|path_utf8
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DARWIN
argument_list|)
name|svn_boolean_t
name|path_is_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_path_encoding
argument_list|(
operator|&
name|path_is_utf8
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_is_utf8
condition|)
endif|#
directive|endif
block|{
operator|*
name|path_apr
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path_utf8
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DARWIN
argument_list|)
else|else
return|return
name|svn_utf_cstring_from_utf8
argument_list|(
name|path_apr
argument_list|,
name|path_utf8
argument_list|,
name|pool
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_path_cstring_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path_utf8
parameter_list|,
specifier|const
name|char
modifier|*
name|path_apr
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DARWIN
argument_list|)
name|svn_boolean_t
name|path_is_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_path_encoding
argument_list|(
operator|&
name|path_is_utf8
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_is_utf8
condition|)
endif|#
directive|endif
block|{
operator|*
name|path_utf8
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path_apr
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DARWIN
argument_list|)
else|else
return|return
name|svn_utf_cstring_to_utf8
argument_list|(
name|path_utf8
argument_list|,
name|path_apr
argument_list|,
name|pool
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return a copy of PATH, allocated from POOL, for which control    characters have been escaped using the form \NNN (where NNN is the    octal representation of the byte's ordinal value).  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|svn_path_illegal_path_escape
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|retstr
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|,
name|copied
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* At least one control character:       strlen - 1 (control) + \ + N + N + N + null . */
name|retstr
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|4
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|path
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|path
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|svn_ctype_iscntrl
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
comment|/* If we got here, we're looking at a character that isn't          supported by the (or at least, our) URI encoding scheme.  We          need to escape this character.  */
comment|/* First things first, copy all the good stuff that we haven't          yet copied into our output buffer. */
if|if
condition|(
name|i
operator|-
name|copied
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|retstr
argument_list|,
name|path
operator|+
name|copied
argument_list|,
name|i
operator|-
name|copied
argument_list|)
expr_stmt|;
comment|/* Make sure buffer is big enough for '\' 'N' 'N' 'N' (and NUL) */
name|svn_stringbuf_ensure
argument_list|(
name|retstr
argument_list|,
name|retstr
operator|->
name|len
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/*### The backslash separator doesn't work too great with Windows,          but it's what we'll use for consistency with invalid utf8          formatting (until someone has a better idea) */
name|apr_snprintf
argument_list|(
name|retstr
operator|->
name|data
operator|+
name|retstr
operator|->
name|len
argument_list|,
literal|5
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|retstr
operator|->
name|len
operator|+=
literal|4
expr_stmt|;
comment|/* Finally, update our copy counter. */
name|copied
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
comment|/* If we didn't encode anything, we don't need to duplicate the string. */
if|if
condition|(
name|retstr
operator|->
name|len
operator|==
literal|0
condition|)
return|return
name|path
return|;
comment|/* Anything left to copy? */
if|if
condition|(
name|i
operator|-
name|copied
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|retstr
argument_list|,
name|path
operator|+
name|copied
argument_list|,
name|i
operator|-
name|copied
argument_list|)
expr_stmt|;
comment|/* retstr is null-terminated either by apr_snprintf or the svn_stringbuf      functions. */
return|return
name|retstr
operator|->
name|data
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_path_check_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|path
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|svn_ctype_iscntrl
argument_list|(
operator|*
name|c
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PATH_SYNTAX
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid control character '0x%02x' in path '%s'"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|c
argument_list|,
name|svn_path_illegal_path_escape
argument_list|(
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_path_splitext
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path_root
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_ext
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|last_dot
decl_stmt|,
modifier|*
name|last_slash
decl_stmt|;
comment|/* Easy out -- why do all the work when there's no way to report it? */
if|if
condition|(
operator|!
operator|(
name|path_root
operator|||
name|path_ext
operator|)
condition|)
return|return;
comment|/* Do we even have a period in this thing?  And if so, is there      anything after it?  We look for the "rightmost" period in the      string. */
name|last_dot
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_dot
operator|&&
operator|(
name|last_dot
operator|+
literal|1
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* If we have a period, we need to make sure it occurs in the          final path component -- that there's no path separator          between the last period and the end of the PATH -- otherwise,          it doesn't count.  Also, we want to make sure that our period          isn't the first character of the last component. */
name|last_slash
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|last_slash
operator|&&
operator|(
name|last_dot
operator|>
operator|(
name|last_slash
operator|+
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|last_slash
operator|)
operator|&&
operator|(
name|last_dot
operator|>
name|path
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|path_root
condition|)
operator|*
name|path_root
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|,
operator|(
name|last_dot
operator|-
name|path
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_ext
condition|)
operator|*
name|path_ext
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|last_dot
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we get here, we never found a suitable separator character, so      there's no split. */
if|if
condition|(
name|path_root
condition|)
operator|*
name|path_root
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_ext
condition|)
operator|*
name|path_ext
operator|=
literal|""
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Repository relative URLs (^/). */
end_comment

begin_function
name|svn_boolean_t
name|svn_path_is_repos_relative_url
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"^/"
argument_list|,
name|path
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_path_resolve_repos_relative_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|absolute_url
parameter_list|,
specifier|const
name|char
modifier|*
name|relative_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_path_is_repos_relative_url
argument_list|(
name|relative_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Improper relative URL '%s'"
argument_list|)
argument_list|,
name|relative_url
argument_list|)
return|;
comment|/* No assumptions are made about the canonicalization of the inut    * arguments, it is presumed that the output will be canonicalized after    * this function, which will remove any duplicate path separator.    */
operator|*
name|absolute_url
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|repos_root_url
argument_list|,
name|relative_url
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

