begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sysinfo.c :  information about the running system  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_define
define|#
directive|define
name|PSAPI_VERSION
value|1
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<psapi.h>
end_include

begin_include
include|#
directive|include
file|<Ws2tcpip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_thread_proc.h>
end_include

begin_include
include|#
directive|include
file|<apr_version.h>
end_include

begin_include
include|#
directive|include
file|<apu_version.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sqlite.h"
end_include

begin_include
include|#
directive|include
file|"sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_UTSNAME_H
end_if

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_MACOS_PLIST
end_ifdef

begin_include
include|#
directive|include
file|<CoreFoundation/CoreFoundation.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_MACHO_ITERATE
end_ifdef

begin_include
include|#
directive|include
file|<mach-o/dyld.h>
end_include

begin_include
include|#
directive|include
file|<mach-o/loader.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_UNAME
end_if

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|canonical_host_from_uname
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_HAVE_MACOS_PLIST
end_ifndef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|release_name_from_uname
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|win32_canonical_host
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|win32_release_name
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|apr_array_header_t
modifier|*
name|win32_shared_libs
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_MACOS_PLIST
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|macos_release_name
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_MACHO_ITERATE
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|apr_array_header_t
modifier|*
name|macos_shared_libs
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__linux__
end_if

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|linux_release_name
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|char
modifier|*
name|svn_sysinfo__canonical_host
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WIN32
return|return
name|win32_canonical_host
argument_list|(
name|pool
argument_list|)
return|;
elif|#
directive|elif
name|HAVE_UNAME
return|return
name|canonical_host_from_uname
argument_list|(
name|pool
argument_list|)
return|;
else|#
directive|else
return|return
literal|"unknown-unknown-unknown"
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_sysinfo__release_name
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WIN32
return|return
name|win32_release_name
argument_list|(
name|pool
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|SVN_HAVE_MACOS_PLIST
argument_list|)
return|return
name|macos_release_name
argument_list|(
name|pool
argument_list|)
return|;
elif|#
directive|elif
name|__linux__
return|return
name|linux_release_name
argument_list|(
name|pool
argument_list|)
return|;
elif|#
directive|elif
name|HAVE_UNAME
return|return
name|release_name_from_uname
argument_list|(
name|pool
argument_list|)
return|;
else|#
directive|else
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|const
name|apr_array_header_t
modifier|*
name|svn_sysinfo__linked_libs
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_version_ext_linked_lib_t
modifier|*
name|lib
decl_stmt|;
name|apr_array_header_t
modifier|*
name|array
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lib
argument_list|)
argument_list|)
decl_stmt|;
name|lib
operator|=
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|array
argument_list|,
name|svn_version_ext_linked_lib_t
argument_list|)
expr_stmt|;
name|lib
operator|->
name|name
operator|=
literal|"APR"
expr_stmt|;
name|lib
operator|->
name|compiled_version
operator|=
name|APR_VERSION_STRING
expr_stmt|;
name|lib
operator|->
name|runtime_version
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|apr_version_string
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Don't list APR-Util if it isn't linked in, which it may not be if  * we're using APR 2.x+ which combined APR-Util into APR. */
ifdef|#
directive|ifdef
name|APU_VERSION_STRING
name|lib
operator|=
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|array
argument_list|,
name|svn_version_ext_linked_lib_t
argument_list|)
expr_stmt|;
name|lib
operator|->
name|name
operator|=
literal|"APR-Util"
expr_stmt|;
name|lib
operator|->
name|compiled_version
operator|=
name|APU_VERSION_STRING
expr_stmt|;
name|lib
operator|->
name|runtime_version
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|apu_version_string
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lib
operator|=
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|array
argument_list|,
name|svn_version_ext_linked_lib_t
argument_list|)
expr_stmt|;
name|lib
operator|->
name|name
operator|=
literal|"SQLite"
expr_stmt|;
name|lib
operator|->
name|compiled_version
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|svn_sqlite__compiled_version
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_SQLITE_INLINE
name|lib
operator|->
name|runtime_version
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|lib
operator|->
name|runtime_version
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|svn_sqlite__runtime_version
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|array
return|;
block|}
end_function

begin_function
specifier|const
name|apr_array_header_t
modifier|*
name|svn_sysinfo__loaded_libs
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WIN32
return|return
name|win32_shared_libs
argument_list|(
name|pool
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|SVN_HAVE_MACHO_ITERATE
argument_list|)
return|return
name|macos_shared_libs
argument_list|(
name|pool
argument_list|)
return|;
else|#
directive|else
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_UNAME
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|canonical_host_from_uname
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|machine
init|=
literal|"unknown"
decl_stmt|;
specifier|const
name|char
modifier|*
name|vendor
init|=
literal|"unknown"
decl_stmt|;
specifier|const
name|char
modifier|*
name|sysname
init|=
literal|"unknown"
decl_stmt|;
specifier|const
name|char
modifier|*
name|sysver
init|=
literal|""
decl_stmt|;
name|struct
name|utsname
name|info
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|uname
argument_list|(
operator|&
name|info
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
operator|.
name|machine
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|machine
operator|=
name|tmp
expr_stmt|;
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
operator|.
name|sysname
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|lwr
init|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|tmp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|it
init|=
name|lwr
decl_stmt|;
while|while
condition|(
operator|*
name|it
condition|)
block|{
if|if
condition|(
name|svn_ctype_isupper
argument_list|(
operator|*
name|it
argument_list|)
condition|)
operator|*
name|it
operator|=
name|apr_tolower
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|sysname
operator|=
name|lwr
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|sysname
argument_list|,
literal|"darwin"
argument_list|)
condition|)
name|vendor
operator|=
literal|"apple"
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|sysname
argument_list|,
literal|"linux"
argument_list|)
condition|)
name|sysver
operator|=
literal|"-gnu"
expr_stmt|;
else|else
block|{
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
operator|.
name|release
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
block|{
name|apr_size_t
name|n
init|=
name|strspn
argument_list|(
name|tmp
argument_list|,
literal|".0123456789"
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|ver
init|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|tmp
argument_list|)
decl_stmt|;
name|ver
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|sysver
operator|=
name|ver
expr_stmt|;
block|}
else|else
name|sysver
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s-%s-%s%s"
argument_list|,
name|machine
argument_list|,
name|vendor
argument_list|,
name|sysname
argument_list|,
name|sysver
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_HAVE_MACOS_PLIST
end_ifndef

begin_comment
comment|/* Generate a release name from the uname(3) info, effectively    returning "`uname -s` `uname -r`". */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|release_name_from_uname
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|utsname
name|info
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|uname
argument_list|(
operator|&
name|info
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|sysname
decl_stmt|;
specifier|const
name|char
modifier|*
name|sysver
decl_stmt|;
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|sysname
argument_list|,
name|info
operator|.
name|sysname
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sysname
operator|=
name|NULL
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|sysver
argument_list|,
name|info
operator|.
name|release
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|sysver
operator|=
name|NULL
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sysname
operator|||
name|sysver
condition|)
block|{
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s%s%s"
argument_list|,
operator|(
name|sysname
condition|?
name|sysname
else|:
literal|""
operator|)
argument_list|,
operator|(
name|sysver
condition|?
operator|(
name|sysname
condition|?
literal|" "
else|:
literal|""
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|sysver
condition|?
name|sysver
else|:
literal|""
operator|)
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SVN_HAVE_MACOS_PLIST */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNAME */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|__linux__
end_if

begin_comment
comment|/* Split a stringbuf into a key/value pair.    Return the key, leaving the striped value in the stringbuf. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|stringbuf_split_key
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|buffer
parameter_list|,
name|char
name|delim
parameter_list|)
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|buffer
operator|->
name|data
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
return|return
name|NULL
return|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Now we split the currently allocated buffer in two parts:       - a const char * HEAD       - the remaining stringbuf_t. */
comment|/* Create HEAD as '\0' terminated const char * */
name|key
operator|=
name|buffer
operator|->
name|data
expr_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|key
argument_list|,
name|delim
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
comment|/* And update the TAIL to be a smaller, but still valid stringbuf */
name|buffer
operator|->
name|data
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|buffer
operator|->
name|len
operator|-=
literal|1
operator|+
name|end
operator|-
name|key
expr_stmt|;
name|buffer
operator|->
name|blocksize
operator|-=
literal|1
operator|+
name|end
operator|-
name|key
expr_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/* Parse `/usr/bin/lsb_rlease --all` */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lsb_release
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|args
index|[
literal|3
index|]
init|=
block|{
literal|"/usr/bin/lsb_release"
block|,
literal|"--all"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|distributor
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|release
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|codename
init|=
name|NULL
decl_stmt|;
name|apr_proc_t
name|lsbproc
decl_stmt|;
name|svn_stream_t
modifier|*
name|lsbinfo
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Run /usr/bin/lsb_release --all< /dev/null 2>/dev/null */
block|{
name|apr_file_t
modifier|*
name|stdin_handle
decl_stmt|;
name|apr_file_t
modifier|*
name|stdout_handle
decl_stmt|;
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|stdin_handle
argument_list|,
name|SVN_NULL_DEVICE_NAME
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|stdout_handle
argument_list|,
name|SVN_NULL_DEVICE_NAME
argument_list|,
name|APR_WRITE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_io_start_cmd3
argument_list|(
operator|&
name|lsbproc
argument_list|,
name|NULL
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|stdin_handle
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|stdout_handle
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Parse the output and try to populate the  */
name|lsbinfo
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|lsbproc
operator|.
name|out
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsbinfo
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|svn_boolean_t
name|eof
init|=
name|FALSE
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|err
operator|=
name|svn_stream_readline
argument_list|(
name|lsbinfo
argument_list|,
operator|&
name|line
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|eof
condition|)
break|break;
name|key
operator|=
name|stringbuf_split_key
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
continue|continue;
if|if
condition|(
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|key
argument_list|,
literal|"Distributor ID"
argument_list|)
condition|)
name|distributor
operator|=
name|line
operator|->
name|data
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|key
argument_list|,
literal|"Description"
argument_list|)
condition|)
name|description
operator|=
name|line
operator|->
name|data
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|key
argument_list|,
literal|"Release"
argument_list|)
condition|)
name|release
operator|=
name|line
operator|->
name|data
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|key
argument_list|,
literal|"Codename"
argument_list|)
condition|)
name|codename
operator|=
name|line
operator|->
name|data
expr_stmt|;
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_stream_close
argument_list|(
name|lsbinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|apr_proc_kill
argument_list|(
operator|&
name|lsbproc
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Reap the child process */
name|err
operator|=
name|svn_io_wait_for_cmd
argument_list|(
operator|&
name|lsbproc
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|description
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|description
argument_list|,
operator|(
name|codename
condition|?
literal|" ("
else|:
literal|""
operator|)
argument_list|,
operator|(
name|codename
condition|?
name|codename
else|:
literal|""
operator|)
argument_list|,
operator|(
name|codename
condition|?
literal|")"
else|:
literal|""
operator|)
argument_list|)
return|;
if|if
condition|(
name|distributor
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s%s%s%s%s%s"
argument_list|,
name|distributor
argument_list|,
operator|(
name|release
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|release
condition|?
name|release
else|:
literal|""
operator|)
argument_list|,
operator|(
name|codename
condition|?
literal|" ("
else|:
literal|""
operator|)
argument_list|,
operator|(
name|codename
condition|?
name|codename
else|:
literal|""
operator|)
argument_list|,
operator|(
name|codename
condition|?
literal|")"
else|:
literal|""
operator|)
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Read the whole contents of a file. */
end_comment

begin_function
specifier|static
name|svn_stringbuf_t
modifier|*
name|read_file_contents
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buffer
decl_stmt|;
name|err
operator|=
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|buffer
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Strip everything but the first line from a stringbuf. */
end_comment

begin_function
specifier|static
name|void
name|stringbuf_first_line_only
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|eol
init|=
name|strchr
argument_list|(
name|buffer
operator|->
name|data
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|eol
condition|)
block|{
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
name|buffer
operator|->
name|len
operator|=
literal|1
operator|+
name|eol
operator|-
name|buffer
operator|->
name|data
expr_stmt|;
block|}
name|svn_stringbuf_strip_whitespace
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look at /etc/redhat_release to detect RHEL/Fedora/CentOS. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|redhat_release
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|buffer
init|=
name|read_file_contents
argument_list|(
literal|"/etc/redhat-release"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|stringbuf_first_line_only
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|->
name|data
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Look at /etc/SuSE-release to detect non-LSB SuSE. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|suse_release
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|release
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|codename
init|=
name|NULL
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buffer
init|=
name|read_file_contents
argument_list|(
literal|"/etc/SuSE-release"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|NULL
return|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|buffer
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|line
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|eof
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|svn_stringbuf_strip_whitespace
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|release
operator|=
name|line
operator|->
name|data
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|err
operator|=
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|line
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|eof
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
name|key
operator|=
name|stringbuf_split_key
argument_list|(
name|line
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
continue|continue;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|key
argument_list|,
literal|"CODENAME"
argument_list|,
literal|8
argument_list|)
condition|)
name|codename
operator|=
name|line
operator|->
name|data
expr_stmt|;
block|}
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|release
argument_list|,
operator|(
name|codename
condition|?
literal|" ("
else|:
literal|""
operator|)
argument_list|,
operator|(
name|codename
condition|?
name|codename
else|:
literal|""
operator|)
argument_list|,
operator|(
name|codename
condition|?
literal|")"
else|:
literal|""
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look at /etc/debian_version to detect non-LSB Debian. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|debian_release
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|buffer
init|=
name|read_file_contents
argument_list|(
literal|"/etc/debian_version"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|NULL
return|;
name|stringbuf_first_line_only
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"Debian "
argument_list|,
name|buffer
operator|->
name|data
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to find the Linux distribution name, or return info from uname. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|linux_release_name
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|uname_release
init|=
name|release_name_from_uname
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Try anything that has /usr/bin/lsb_release.      Covers, for example, Debian, Ubuntu and SuSE.  */
specifier|const
name|char
modifier|*
name|release_name
init|=
name|lsb_release
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Try RHEL/Fedora/CentOS */
if|if
condition|(
operator|!
name|release_name
condition|)
name|release_name
operator|=
name|redhat_release
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Try Non-LSB SuSE */
if|if
condition|(
operator|!
name|release_name
condition|)
name|release_name
operator|=
name|suse_release
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Try non-LSB Debian */
if|if
condition|(
operator|!
name|release_name
condition|)
name|release_name
operator|=
name|debian_release
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|release_name
condition|)
return|return
name|uname_release
return|;
if|if
condition|(
operator|!
name|uname_release
condition|)
return|return
name|release_name
return|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s [%s]"
argument_list|,
name|release_name
argument_list|,
name|uname_release
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_typedef
typedef|typedef
name|DWORD
function_decl|(
name|WINAPI
modifier|*
name|FNGETNATIVESYSTEMINFO
function_decl|)
parameter_list|(
name|LPSYSTEM_INFO
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|FNENUMPROCESSMODULES
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|HMODULE
modifier|*
parameter_list|,
name|DWORD
parameter_list|,
name|LPDWORD
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Get system and version info, and try to tell the difference    between the native system type and the runtime environment of the    current process. Populate results in SYSINFO, LOCAL_SYSINFO    (optional) and OSINFO. */
end_comment

begin_function
specifier|static
name|BOOL
name|system_info
parameter_list|(
name|SYSTEM_INFO
modifier|*
name|sysinfo
parameter_list|,
name|SYSTEM_INFO
modifier|*
name|local_sysinfo
parameter_list|,
name|OSVERSIONINFOEXW
modifier|*
name|osinfo
parameter_list|)
block|{
name|FNGETNATIVESYSTEMINFO
name|GetNativeSystemInfo_
init|=
operator|(
name|FNGETNATIVESYSTEMINFO
operator|)
name|GetProcAddress
argument_list|(
name|GetModuleHandleA
argument_list|(
literal|"kernel32.dll"
argument_list|)
argument_list|,
literal|"GetNativeSystemInfo"
argument_list|)
decl_stmt|;
name|ZeroMemory
argument_list|(
name|sysinfo
argument_list|,
sizeof|sizeof
expr|*
name|sysinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_sysinfo
condition|)
block|{
name|ZeroMemory
argument_list|(
name|local_sysinfo
argument_list|,
sizeof|sizeof
expr|*
name|local_sysinfo
argument_list|)
expr_stmt|;
name|GetSystemInfo
argument_list|(
name|local_sysinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetNativeSystemInfo_
condition|)
name|GetNativeSystemInfo_
argument_list|(
name|sysinfo
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|sysinfo
argument_list|,
name|local_sysinfo
argument_list|,
sizeof|sizeof
expr|*
name|sysinfo
argument_list|)
expr_stmt|;
block|}
else|else
name|GetSystemInfo
argument_list|(
name|sysinfo
argument_list|)
expr_stmt|;
name|ZeroMemory
argument_list|(
name|osinfo
argument_list|,
sizeof|sizeof
expr|*
name|osinfo
argument_list|)
expr_stmt|;
name|osinfo
operator|->
name|dwOSVersionInfoSize
operator|=
sizeof|sizeof
expr|*
name|osinfo
expr_stmt|;
if|if
condition|(
operator|!
name|GetVersionExW
argument_list|(
operator|(
name|LPVOID
operator|)
name|osinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Map the proccessor type from SYSINFO to a string. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|processor_name
parameter_list|(
name|SYSTEM_INFO
modifier|*
name|sysinfo
parameter_list|)
block|{
switch|switch
condition|(
name|sysinfo
operator|->
name|wProcessorArchitecture
condition|)
block|{
case|case
name|PROCESSOR_ARCHITECTURE_AMD64
case|:
return|return
literal|"x86_64"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_IA64
case|:
return|return
literal|"ia64"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_INTEL
case|:
return|return
literal|"x86"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_MIPS
case|:
return|return
literal|"mips"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_ALPHA
case|:
return|return
literal|"alpha32"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_PPC
case|:
return|return
literal|"powerpc"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_SHX
case|:
return|return
literal|"shx"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_ARM
case|:
return|return
literal|"arm"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_ALPHA64
case|:
return|return
literal|"alpha"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_MSIL
case|:
return|return
literal|"msil"
return|;
case|case
name|PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
case|:
return|return
literal|"x86_wow64"
return|;
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the Windows-specific canonical host name. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|win32_canonical_host
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SYSTEM_INFO
name|sysinfo
decl_stmt|;
name|SYSTEM_INFO
name|local_sysinfo
decl_stmt|;
name|OSVERSIONINFOEXW
name|osinfo
decl_stmt|;
if|if
condition|(
name|system_info
argument_list|(
operator|&
name|sysinfo
argument_list|,
operator|&
name|local_sysinfo
argument_list|,
operator|&
name|osinfo
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|arch
init|=
name|processor_name
argument_list|(
operator|&
name|local_sysinfo
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|machine
init|=
name|processor_name
argument_list|(
operator|&
name|sysinfo
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|vendor
init|=
literal|"microsoft"
decl_stmt|;
specifier|const
name|char
modifier|*
name|sysname
init|=
literal|"windows"
decl_stmt|;
specifier|const
name|char
modifier|*
name|sysver
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%u.%u.%u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMajorVersion
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMinorVersion
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwBuildNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|sysinfo
operator|.
name|wProcessorArchitecture
operator|==
name|local_sysinfo
operator|.
name|wProcessorArchitecture
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s-%s-%s%s"
argument_list|,
name|machine
argument_list|,
name|vendor
argument_list|,
name|sysname
argument_list|,
name|sysver
argument_list|)
return|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s/%s-%s-%s%s"
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|,
name|vendor
argument_list|,
name|sysname
argument_list|,
name|sysver
argument_list|)
return|;
block|}
return|return
literal|"unknown-microsoft-windows"
return|;
block|}
end_function

begin_comment
comment|/* Convert a Unicode string to UTF-8. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|wcs_to_utf8
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|wcs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|int
name|bufsize
init|=
name|WideCharToMultiByte
argument_list|(
name|CP_UTF8
argument_list|,
literal|0
argument_list|,
name|wcs
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufsize
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
specifier|const
name|utf8
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|bufsize
operator|+
literal|1
argument_list|)
decl_stmt|;
name|WideCharToMultiByte
argument_list|(
name|CP_UTF8
argument_list|,
literal|0
argument_list|,
name|wcs
argument_list|,
operator|-
literal|1
argument_list|,
name|utf8
argument_list|,
name|bufsize
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|utf8
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Query the value called NAME of the registry key HKEY. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|registry_value
parameter_list|(
name|HKEY
name|hkey
parameter_list|,
name|wchar_t
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|DWORD
name|size
decl_stmt|;
name|wchar_t
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|RegQueryValueExW
argument_list|(
name|hkey
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|NULL
return|;
name|value
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|size
operator|+
sizeof|sizeof
expr|*
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|RegQueryValueExW
argument_list|(
name|hkey
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|value
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|NULL
return|;
name|value
index|[
name|size
operator|/
sizeof|sizeof
expr|*
name|value
expr|]
operator|=
literal|0
expr_stmt|;
return|return
name|wcs_to_utf8
argument_list|(
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to glean the Windows release name and associated info from the    registry. Failing that, construct a release name from the version    info. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|win32_release_name
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SYSTEM_INFO
name|sysinfo
decl_stmt|;
name|OSVERSIONINFOEXW
name|osinfo
decl_stmt|;
name|HKEY
name|hkcv
decl_stmt|;
if|if
condition|(
operator|!
name|system_info
argument_list|(
operator|&
name|sysinfo
argument_list|,
name|NULL
argument_list|,
operator|&
name|osinfo
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|RegOpenKeyExW
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
literal|L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
argument_list|,
literal|0
argument_list|,
name|KEY_QUERY_VALUE
argument_list|,
operator|&
name|hkcv
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|release
init|=
name|registry_value
argument_list|(
name|hkcv
argument_list|,
literal|L"ProductName"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|spack
init|=
name|registry_value
argument_list|(
name|hkcv
argument_list|,
literal|L"CSDVersion"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|curver
init|=
name|registry_value
argument_list|(
name|hkcv
argument_list|,
literal|L"CurrentVersion"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|curtype
init|=
name|registry_value
argument_list|(
name|hkcv
argument_list|,
literal|L"CurrentType"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|install
init|=
name|registry_value
argument_list|(
name|hkcv
argument_list|,
literal|L"InstallationType"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|curbuild
init|=
name|registry_value
argument_list|(
name|hkcv
argument_list|,
literal|L"CurrentBuildNumber"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|spack
operator|&&
operator|*
name|osinfo
operator|.
name|szCSDVersion
condition|)
name|spack
operator|=
name|wcs_to_utf8
argument_list|(
name|osinfo
operator|.
name|szCSDVersion
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curbuild
condition|)
name|curbuild
operator|=
name|registry_value
argument_list|(
name|hkcv
argument_list|,
literal|L"CurrentBuild"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|release
operator|||
name|spack
operator|||
name|curver
operator|||
name|curtype
operator|||
name|curbuild
condition|)
block|{
specifier|const
name|char
modifier|*
name|bootinfo
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|curver
operator|||
name|install
operator|||
name|curtype
condition|)
block|{
name|bootinfo
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"[%s%s%s%s%s]"
argument_list|,
operator|(
name|curver
condition|?
name|curver
else|:
literal|""
operator|)
argument_list|,
operator|(
name|install
condition|?
operator|(
name|curver
condition|?
literal|" "
else|:
literal|""
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|install
condition|?
name|install
else|:
literal|""
operator|)
argument_list|,
operator|(
name|curtype
condition|?
operator|(
name|curver
operator|||
name|install
condition|?
literal|" "
else|:
literal|""
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|curtype
condition|?
name|curtype
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s%s%s%s%s%s%s"
argument_list|,
operator|(
name|release
condition|?
name|release
else|:
literal|""
operator|)
argument_list|,
operator|(
name|spack
condition|?
operator|(
name|release
condition|?
literal|", "
else|:
literal|""
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|spack
condition|?
name|spack
else|:
literal|""
operator|)
argument_list|,
operator|(
name|curbuild
condition|?
operator|(
name|release
operator|||
name|spack
condition|?
literal|", build "
else|:
literal|"build "
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|curbuild
condition|?
name|curbuild
else|:
literal|""
operator|)
argument_list|,
operator|(
name|bootinfo
condition|?
operator|(
name|release
operator|||
name|spack
operator|||
name|curbuild
condition|?
literal|" "
else|:
literal|""
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|bootinfo
condition|?
name|bootinfo
else|:
literal|""
operator|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|*
name|osinfo
operator|.
name|szCSDVersion
condition|)
block|{
specifier|const
name|char
modifier|*
name|servicepack
init|=
name|wcs_to_utf8
argument_list|(
name|osinfo
operator|.
name|szCSDVersion
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|servicepack
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"Windows NT %u.%u, %s, build %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMajorVersion
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMinorVersion
argument_list|,
name|servicepack
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwBuildNumber
argument_list|)
return|;
comment|/* Assume wServicePackMajor> 0 if szCSDVersion is not empty */
if|if
condition|(
name|osinfo
operator|.
name|wServicePackMinor
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"Windows NT %u.%u SP%u.%u, build %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMajorVersion
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMinorVersion
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|wServicePackMajor
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|wServicePackMinor
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwBuildNumber
argument_list|)
return|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"Windows NT %u.%u SP%u, build %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMajorVersion
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMinorVersion
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|wServicePackMajor
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwBuildNumber
argument_list|)
return|;
block|}
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"Windows NT %u.%u, build %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMajorVersion
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwMinorVersion
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|osinfo
operator|.
name|dwBuildNumber
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a list of handles of shared libs loaded by the current    process. Returns a NULL-terminated array alocated from POOL. */
end_comment

begin_function
specifier|static
name|HMODULE
modifier|*
name|enum_loaded_modules
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|HMODULE
name|psapi_dll
init|=
literal|0
decl_stmt|;
name|HANDLE
name|current
init|=
name|GetCurrentProcess
argument_list|()
decl_stmt|;
name|HMODULE
name|dummy
index|[
literal|1
index|]
decl_stmt|;
name|HMODULE
modifier|*
name|handles
decl_stmt|;
name|DWORD
name|size
decl_stmt|;
name|FNENUMPROCESSMODULES
name|EnumProcessModules_
decl_stmt|;
name|psapi_dll
operator|=
name|GetModuleHandleA
argument_list|(
literal|"psapi.dll"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psapi_dll
condition|)
block|{
comment|/* Load and never unload, just like static linking */
name|psapi_dll
operator|=
name|LoadLibraryA
argument_list|(
literal|"psapi.dll"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|psapi_dll
condition|)
return|return
name|NULL
return|;
name|EnumProcessModules_
operator|=
operator|(
name|FNENUMPROCESSMODULES
operator|)
name|GetProcAddress
argument_list|(
name|psapi_dll
argument_list|,
literal|"EnumProcessModules"
argument_list|)
expr_stmt|;
comment|/* Before Windows XP psapi was an optional module */
if|if
condition|(
operator|!
name|EnumProcessModules_
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|EnumProcessModules_
argument_list|(
name|current
argument_list|,
name|dummy
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|NULL
return|;
name|handles
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|size
operator|+
sizeof|sizeof
expr|*
name|handles
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EnumProcessModules_
argument_list|(
name|current
argument_list|,
name|handles
argument_list|,
name|size
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|NULL
return|;
name|handles
index|[
name|size
operator|/
sizeof|sizeof
expr|*
name|handles
expr|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handles
return|;
block|}
end_function

begin_comment
comment|/* Find the version number, if any, embedded in FILENAME. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|file_version_number
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|VS_FIXEDFILEINFO
name|info
decl_stmt|;
name|unsigned
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|micro
decl_stmt|,
name|nano
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|DWORD
name|data_size
init|=
name|GetFileVersionInfoSizeW
argument_list|(
name|filename
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|void
modifier|*
name|vinfo
decl_stmt|;
name|UINT
name|vinfo_size
decl_stmt|;
if|if
condition|(
operator|!
name|data_size
condition|)
return|return
name|NULL
return|;
name|data
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetFileVersionInfoW
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
name|data_size
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|VerQueryValueW
argument_list|(
name|data
argument_list|,
literal|L"\\"
argument_list|,
operator|&
name|vinfo
argument_list|,
operator|&
name|vinfo_size
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|vinfo_size
operator|!=
sizeof|sizeof
name|info
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
operator|&
name|info
argument_list|,
name|vinfo
argument_list|,
sizeof|sizeof
name|info
argument_list|)
expr_stmt|;
name|major
operator|=
operator|(
name|info
operator|.
name|dwFileVersionMS
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
name|minor
operator|=
name|info
operator|.
name|dwFileVersionMS
operator|&
literal|0xFFFF
expr_stmt|;
name|micro
operator|=
operator|(
name|info
operator|.
name|dwFileVersionLS
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
name|nano
operator|=
name|info
operator|.
name|dwFileVersionLS
operator|&
literal|0xFFFF
expr_stmt|;
if|if
condition|(
operator|!
name|nano
condition|)
block|{
if|if
condition|(
operator|!
name|micro
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%u.%u"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
return|;
else|else
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%u.%u.%u"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|micro
argument_list|)
return|;
block|}
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|micro
argument_list|,
name|nano
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* List the shared libraries loaded by the current process. */
end_comment

begin_function
specifier|static
specifier|const
name|apr_array_header_t
modifier|*
name|win32_shared_libs
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|array
init|=
name|NULL
decl_stmt|;
name|wchar_t
name|buffer
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
name|HMODULE
modifier|*
name|handles
init|=
name|enum_loaded_modules
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|HMODULE
modifier|*
name|module
decl_stmt|;
for|for
control|(
name|module
operator|=
name|handles
init|;
name|module
operator|&&
operator|*
name|module
condition|;
operator|++
name|module
control|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
if|if
condition|(
name|GetModuleFileNameW
argument_list|(
operator|*
name|module
argument_list|,
name|buffer
argument_list|,
name|MAX_PATH
argument_list|)
condition|)
block|{
name|buffer
index|[
name|MAX_PATH
index|]
operator|=
literal|0
expr_stmt|;
name|version
operator|=
name|file_version_number
argument_list|(
name|buffer
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|filename
operator|=
name|wcs_to_utf8
argument_list|(
name|buffer
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
condition|)
block|{
name|svn_version_ext_loaded_lib_t
modifier|*
name|lib
decl_stmt|;
if|if
condition|(
operator|!
name|array
condition|)
block|{
name|array
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|32
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lib
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lib
operator|=
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|array
argument_list|,
name|svn_version_ext_loaded_lib_t
argument_list|)
expr_stmt|;
name|lib
operator|->
name|name
operator|=
name|svn_dirent_local_style
argument_list|(
name|filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|lib
operator|->
name|version
operator|=
name|version
expr_stmt|;
block|}
block|}
block|}
return|return
name|array
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_MACOS_PLIST
end_ifdef

begin_comment
comment|/* Load the SystemVersion.plist or ServerVersion.plist file into a    property list. Set SERVER to TRUE if the file read was    ServerVersion.plist. */
end_comment

begin_function
specifier|static
name|CFDictionaryRef
name|system_version_plist
parameter_list|(
name|svn_boolean_t
modifier|*
name|server
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|UInt8
name|server_version
index|[]
init|=
literal|"/System/Library/CoreServices/ServerVersion.plist"
decl_stmt|;
specifier|static
specifier|const
name|UInt8
name|system_version
index|[]
init|=
literal|"/System/Library/CoreServices/SystemVersion.plist"
decl_stmt|;
name|CFPropertyListRef
name|plist
init|=
name|NULL
decl_stmt|;
name|CFDataRef
name|resource
init|=
name|NULL
decl_stmt|;
name|CFStringRef
name|errstr
init|=
name|NULL
decl_stmt|;
name|CFURLRef
name|url
init|=
name|NULL
decl_stmt|;
name|SInt32
name|errcode
decl_stmt|;
name|url
operator|=
name|CFURLCreateFromFileSystemRepresentation
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|server_version
argument_list|,
sizeof|sizeof
argument_list|(
name|server_version
argument_list|)
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|url
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|CFURLCreateDataAndPropertiesFromResource
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|url
argument_list|,
operator|&
name|resource
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|errcode
argument_list|)
condition|)
block|{
name|CFRelease
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|url
operator|=
name|CFURLCreateFromFileSystemRepresentation
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|system_version
argument_list|,
sizeof|sizeof
argument_list|(
name|system_version
argument_list|)
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|url
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|CFURLCreateDataAndPropertiesFromResource
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|url
argument_list|,
operator|&
name|resource
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|errcode
argument_list|)
condition|)
block|{
name|CFRelease
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|CFRelease
argument_list|(
name|url
argument_list|)
expr_stmt|;
operator|*
name|server
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|CFRelease
argument_list|(
name|url
argument_list|)
expr_stmt|;
operator|*
name|server
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* ### CFPropertyListCreateFromXMLData is obsolete, but its          replacement CFPropertyListCreateWithData is only available          from Mac OS 1.6 onward. */
name|plist
operator|=
name|CFPropertyListCreateFromXMLData
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|resource
argument_list|,
name|kCFPropertyListImmutable
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource
condition|)
name|CFRelease
argument_list|(
name|resource
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|CFRelease
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|CFDictionaryGetTypeID
argument_list|()
operator|!=
name|CFGetTypeID
argument_list|(
name|plist
argument_list|)
condition|)
block|{
comment|/* Oops ... this really should be a dict. */
name|CFRelease
argument_list|(
name|plist
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|plist
return|;
block|}
end_function

begin_comment
comment|/* Return the value for KEY from PLIST, or NULL if not available. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|value_from_dict
parameter_list|(
name|CFDictionaryRef
name|plist
parameter_list|,
name|CFStringRef
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|CFStringRef
name|valref
decl_stmt|;
name|CFIndex
name|bufsize
decl_stmt|;
specifier|const
name|void
modifier|*
name|valptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|CFDictionaryGetValueIfPresent
argument_list|(
name|plist
argument_list|,
name|key
argument_list|,
operator|&
name|valptr
argument_list|)
condition|)
return|return
name|NULL
return|;
name|valref
operator|=
name|valptr
expr_stmt|;
if|if
condition|(
name|CFStringGetTypeID
argument_list|()
operator|!=
name|CFGetTypeID
argument_list|(
name|valref
argument_list|)
condition|)
return|return
name|NULL
return|;
name|value
operator|=
name|CFStringGetCStringPtr
argument_list|(
name|valref
argument_list|,
name|kCFStringEncodingUTF8
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
return|return
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|value
argument_list|)
return|;
name|bufsize
operator|=
literal|5
operator|*
name|CFStringGetLength
argument_list|(
name|valref
argument_list|)
operator|+
literal|1
expr_stmt|;
name|value
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CFStringGetCString
argument_list|(
name|valref
argument_list|,
operator|(
name|char
operator|*
operator|)
name|value
argument_list|,
name|bufsize
argument_list|,
name|kCFStringEncodingUTF8
argument_list|)
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return the commercial name of the OS, given the version number in    a format that matches the regular expression /^10\.\d+(\..*)?$/ */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|release_name_from_version
parameter_list|(
specifier|const
name|char
modifier|*
name|osver
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|num
init|=
name|strtoul
argument_list|(
name|osver
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|end
operator|||
operator|*
name|end
operator|!=
literal|'.'
operator|||
name|num
operator|!=
literal|10
condition|)
return|return
name|NULL
return|;
name|osver
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|end
operator|=
name|NULL
expr_stmt|;
name|num
operator|=
name|strtoul
argument_list|(
name|osver
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
operator|||
operator|(
operator|*
name|end
operator|&&
operator|*
name|end
operator|!=
literal|'.'
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* See http://en.wikipedia.org/wiki/History_of_OS_X#Release_timeline */
switch|switch
condition|(
name|num
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Cheetah"
return|;
case|case
literal|1
case|:
return|return
literal|"Puma"
return|;
case|case
literal|2
case|:
return|return
literal|"Jaguar"
return|;
case|case
literal|3
case|:
return|return
literal|"Panther"
return|;
case|case
literal|4
case|:
return|return
literal|"Tiger"
return|;
case|case
literal|5
case|:
return|return
literal|"Leopard"
return|;
case|case
literal|6
case|:
return|return
literal|"Snow Leopard"
return|;
case|case
literal|7
case|:
return|return
literal|"Lion"
return|;
case|case
literal|8
case|:
return|return
literal|"Mountain Lion"
return|;
case|case
literal|9
case|:
return|return
literal|"Mavericks"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Construct the release name from information stored in the Mac OS X    "SystemVersion.plist" file (or ServerVersion.plist, for Mac Os    Server. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|macos_release_name
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|server
decl_stmt|;
name|CFDictionaryRef
name|plist
init|=
name|system_version_plist
argument_list|(
operator|&
name|server
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|plist
condition|)
block|{
specifier|const
name|char
modifier|*
name|osname
init|=
name|value_from_dict
argument_list|(
name|plist
argument_list|,
name|CFSTR
argument_list|(
literal|"ProductName"
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|osver
init|=
name|value_from_dict
argument_list|(
name|plist
argument_list|,
name|CFSTR
argument_list|(
literal|"ProductUserVisibleVersion"
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|build
init|=
name|value_from_dict
argument_list|(
name|plist
argument_list|,
name|CFSTR
argument_list|(
literal|"ProductBuildVersion"
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|release
decl_stmt|;
if|if
condition|(
operator|!
name|osver
condition|)
name|osver
operator|=
name|value_from_dict
argument_list|(
name|plist
argument_list|,
name|CFSTR
argument_list|(
literal|"ProductVersion"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|release
operator|=
name|release_name_from_version
argument_list|(
name|osver
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|plist
argument_list|)
expr_stmt|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s%s%s%s%s%s%s%s"
argument_list|,
operator|(
name|osname
condition|?
name|osname
else|:
literal|""
operator|)
argument_list|,
operator|(
name|osver
condition|?
operator|(
name|osname
condition|?
literal|" "
else|:
literal|""
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|osver
condition|?
name|osver
else|:
literal|""
operator|)
argument_list|,
operator|(
name|release
condition|?
operator|(
name|osname
operator|||
name|osver
condition|?
literal|" "
else|:
literal|""
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|release
condition|?
name|release
else|:
literal|""
operator|)
argument_list|,
operator|(
name|build
condition|?
operator|(
name|osname
operator|||
name|osver
operator|||
name|release
condition|?
literal|", "
else|:
literal|""
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|build
condition|?
operator|(
name|server
condition|?
literal|"server build "
else|:
literal|"build "
operator|)
else|:
literal|""
operator|)
argument_list|,
operator|(
name|build
condition|?
name|build
else|:
literal|""
operator|)
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_HAVE_MACOS_PLIST */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_MACHO_ITERATE
end_ifdef

begin_comment
comment|/* List the shared libraries loaded by the current process.    Ignore frameworks and system libraries, they're just clutter. */
end_comment

begin_function
specifier|static
specifier|const
name|apr_array_header_t
modifier|*
name|macos_shared_libs
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|slb_prefix
index|[]
init|=
literal|"/usr/lib/system/"
decl_stmt|;
specifier|static
specifier|const
name|char
name|fwk_prefix
index|[]
init|=
literal|"/System/Library/Frameworks/"
decl_stmt|;
specifier|static
specifier|const
name|char
name|pfk_prefix
index|[]
init|=
literal|"/System/Library/PrivateFrameworks/"
decl_stmt|;
specifier|const
name|size_t
name|slb_prefix_len
init|=
name|strlen
argument_list|(
name|slb_prefix
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|fwk_prefix_len
init|=
name|strlen
argument_list|(
name|fwk_prefix
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|pfk_prefix_len
init|=
name|strlen
argument_list|(
name|pfk_prefix
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|dylibs
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|struct
name|mach_header
modifier|*
name|header
init|=
name|_dyld_get_image_header
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|_dyld_get_image_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
name|char
modifier|*
name|truename
decl_stmt|;
name|svn_version_ext_loaded_lib_t
modifier|*
name|lib
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|header
operator|&&
name|filename
operator|)
condition|)
break|break;
switch|switch
condition|(
name|header
operator|->
name|cputype
condition|)
block|{
case|case
name|CPU_TYPE_I386
case|:
name|version
operator|=
name|_
argument_list|(
literal|"Intel"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_TYPE_X86_64
case|:
name|version
operator|=
name|_
argument_list|(
literal|"Intel 64-bit"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_TYPE_POWERPC
case|:
name|version
operator|=
name|_
argument_list|(
literal|"PowerPC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_TYPE_POWERPC64
case|:
name|version
operator|=
name|_
argument_list|(
literal|"PowerPC 64-bit"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|version
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|apr_filepath_merge
argument_list|(
operator|&
name|truename
argument_list|,
literal|""
argument_list|,
name|filename
argument_list|,
name|APR_FILEPATH_NATIVE
operator||
name|APR_FILEPATH_TRUENAME
argument_list|,
name|pool
argument_list|)
condition|)
name|filename
operator|=
name|truename
expr_stmt|;
else|else
name|filename
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|filename
argument_list|,
name|slb_prefix
argument_list|,
name|slb_prefix_len
argument_list|)
operator|||
literal|0
operator|==
name|strncmp
argument_list|(
name|filename
argument_list|,
name|fwk_prefix
argument_list|,
name|fwk_prefix_len
argument_list|)
operator|||
literal|0
operator|==
name|strncmp
argument_list|(
name|filename
argument_list|,
name|pfk_prefix
argument_list|,
name|pfk_prefix_len
argument_list|)
condition|)
block|{
comment|/* Ignore frameworks and system libraries. */
continue|continue;
block|}
if|if
condition|(
name|header
operator|->
name|filetype
operator|==
name|MH_EXECUTE
condition|)
block|{
comment|/* Make sure the program filename is first in the list */
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|result
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|32
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lib
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lib
operator|=
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|result
argument_list|,
name|svn_version_ext_loaded_lib_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dylibs
condition|)
block|{
name|dylibs
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|32
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lib
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lib
operator|=
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|dylibs
argument_list|,
name|svn_version_ext_loaded_lib_t
argument_list|)
expr_stmt|;
block|}
name|lib
operator|->
name|name
operator|=
name|filename
expr_stmt|;
name|lib
operator|->
name|version
operator|=
name|version
expr_stmt|;
block|}
comment|/* Gather results into one array. */
if|if
condition|(
name|dylibs
condition|)
block|{
if|if
condition|(
name|result
condition|)
name|apr_array_cat
argument_list|(
name|result
argument_list|,
name|dylibs
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|dylibs
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_HAVE_MACHO_ITERATE */
end_comment

end_unit

