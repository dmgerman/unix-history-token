begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * cmdline.c :  Helpers for command-line programs.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for atexit() */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* for setvbuf() */
end_comment

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_comment
comment|/* for setlocale() */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<crtdbg.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_comment
comment|/* for STDIN_FILENO */
end_comment

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_comment
comment|/* for apr_strerror */
end_comment

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_comment
comment|/* for apr_initialize/apr_terminate */
end_comment

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_comment
comment|/* for apr_snprintf */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_dso.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_nls.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_auth.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"win32_crashrpt.h"
end_include

begin_comment
comment|/* The stdin encoding. If null, it's the same as the native encoding. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_encoding
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stdout encoding. If null, it's the same as the native encoding. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|output_encoding
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|svn_cmdline_init
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
name|FILE
modifier|*
name|error_stream
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|char
name|prefix_buf
index|[
literal|64
index|]
decl_stmt|;
comment|/* 64 is probably bigger than most program names */
ifndef|#
directive|ifndef
name|WIN32
block|{
name|struct
name|stat
name|st
decl_stmt|;
comment|/* The following makes sure that file descriptors 0 (stdin), 1        (stdout) and 2 (stderr) will not be "reused", because if        e.g. file descriptor 2 would be reused when opening a file, a        write to stderr would write to that file and most likely        corrupt it. */
if|if
condition|(
operator|(
name|fstat
argument_list|(
literal|0
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDONLY
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|fstat
argument_list|(
literal|1
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|fstat
argument_list|(
literal|2
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
name|fprintf
argument_list|(
name|error_stream
argument_list|,
literal|"%s: error: cannot open '/dev/null'\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
endif|#
directive|endif
comment|/* Ignore any errors encountered while attempting to change stream      buffering, as the streams should retain their default buffering      modes. */
if|if
condition|(
name|error_stream
condition|)
name|setvbuf
argument_list|(
name|error_stream
argument_list|,
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
if|#
directive|if
name|_MSC_VER
operator|<
literal|1400
comment|/* Initialize the input and output encodings. */
block|{
specifier|static
name|char
name|input_encoding_buffer
index|[
literal|16
index|]
decl_stmt|;
specifier|static
name|char
name|output_encoding_buffer
index|[
literal|16
index|]
decl_stmt|;
name|apr_snprintf
argument_list|(
name|input_encoding_buffer
argument_list|,
sizeof|sizeof
name|input_encoding_buffer
argument_list|,
literal|"CP%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|GetConsoleCP
argument_list|()
argument_list|)
expr_stmt|;
name|input_encoding
operator|=
name|input_encoding_buffer
expr_stmt|;
name|apr_snprintf
argument_list|(
name|output_encoding_buffer
argument_list|,
sizeof|sizeof
name|output_encoding_buffer
argument_list|,
literal|"CP%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|GetConsoleOutputCP
argument_list|()
argument_list|)
expr_stmt|;
name|output_encoding
operator|=
name|output_encoding_buffer
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _MSC_VER< 1400 */
ifdef|#
directive|ifdef
name|SVN_USE_WIN32_CRASHHANDLER
comment|/* Attach (but don't load) the crash handler */
name|SetUnhandledExceptionFilter
argument_list|(
name|svn__unhandled_exception_filter
argument_list|)
expr_stmt|;
if|#
directive|if
name|_MSC_VER
operator|>=
literal|1400
comment|/* ### This should work for VC++ 2002 (=1300) and later */
comment|/* Show the abort message on STDERR instead of a dialog to allow      scripts (e.g. our testsuite) to continue after an abort without      user intervention. Allow overriding for easier debugging. */
if|if
condition|(
operator|!
name|getenv
argument_list|(
literal|"SVN_CMDLINE_USE_DIALOG_FOR_ABORT"
argument_list|)
condition|)
block|{
comment|/* In release mode: Redirect abort() errors to stderr */
name|_set_error_mode
argument_list|(
name|_OUT_TO_STDERR
argument_list|)
expr_stmt|;
comment|/* In _DEBUG mode: Redirect all debug output (E.g. assert() to stderr.          (Ignored in release builds) */
name|_CrtSetReportFile
argument_list|(
name|_CRT_WARN
argument_list|,
name|_CRTDBG_FILE_STDERR
argument_list|)
expr_stmt|;
name|_CrtSetReportFile
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_FILE_STDERR
argument_list|)
expr_stmt|;
name|_CrtSetReportFile
argument_list|(
name|_CRT_ASSERT
argument_list|,
name|_CRTDBG_FILE_STDERR
argument_list|)
expr_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_WARN
argument_list|,
name|_CRTDBG_MODE_FILE
operator||
name|_CRTDBG_MODE_DEBUG
argument_list|)
expr_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_MODE_FILE
operator||
name|_CRTDBG_MODE_DEBUG
argument_list|)
expr_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_ASSERT
argument_list|,
name|_CRTDBG_MODE_FILE
operator||
name|_CRTDBG_MODE_DEBUG
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _MSC_VER>= 1400 */
endif|#
directive|endif
comment|/* SVN_USE_WIN32_CRASHHANDLER */
endif|#
directive|endif
comment|/* WIN32 */
comment|/* C programs default to the "C" locale. But because svn is supposed      to be i18n-aware, it should inherit the default locale of its      environment.  */
if|if
condition|(
operator|!
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
operator|&&
operator|!
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
block|{
specifier|const
name|char
modifier|*
name|env_vars
index|[]
init|=
block|{
literal|"LC_ALL"
block|,
literal|"LC_CTYPE"
block|,
literal|"LANG"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|env_var
init|=
operator|&
name|env_vars
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|env_val
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|env_var
condition|)
block|{
name|env_val
operator|=
name|getenv
argument_list|(
operator|*
name|env_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_val
operator|&&
name|env_val
index|[
literal|0
index|]
condition|)
break|break;
operator|++
name|env_var
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|env_var
condition|)
block|{
comment|/* Unlikely. Can setlocale fail if no env vars are set? */
operator|--
name|env_var
expr_stmt|;
name|env_val
operator|=
literal|"not set"
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|error_stream
argument_list|,
literal|"%s: warning: cannot set LC_CTYPE locale\n"
literal|"%s: warning: environment variable %s is %s\n"
literal|"%s: warning: please check that your locale name is correct\n"
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|,
operator|*
name|env_var
argument_list|,
name|env_val
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize the APR subsystem, and register an atexit() function      to Uninitialize that subsystem at program exit. */
name|status
operator|=
name|apr_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|apr_strerror
argument_list|(
name|status
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|error_stream
argument_list|,
literal|"%s: error: cannot initialize APR: %s\n"
argument_list|,
name|progname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_FAILURE
return|;
block|}
name|strncpy
argument_list|(
name|prefix_buf
argument_list|,
name|progname
argument_list|,
sizeof|sizeof
argument_list|(
name|prefix_buf
argument_list|)
operator|-
literal|3
argument_list|)
expr_stmt|;
name|prefix_buf
index|[
sizeof|sizeof
argument_list|(
name|prefix_buf
argument_list|)
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|prefix_buf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
comment|/* DSO pool must be created before any other pools used by the      application so that pool cleanup doesn't unload DSOs too      early. See docstring of svn_dso_initialize2(). */
if|if
condition|(
operator|(
name|err
operator|=
name|svn_dso_initialize2
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|error_stream
argument_list|,
name|TRUE
argument_list|,
name|prefix_buf
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
if|if
condition|(
literal|0
operator|>
name|atexit
argument_list|(
name|apr_terminate
argument_list|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
name|fprintf
argument_list|(
name|error_stream
argument_list|,
literal|"%s: error: atexit registration failed\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
comment|/* Create a pool for use by the UTF-8 routines.  It will be cleaned      up by APR at exit time. */
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|svn_utf_initialize2
argument_list|(
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|svn_nls_init
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|error_stream
argument_list|,
name|TRUE
argument_list|,
name|prefix_buf
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_cstring_from_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|output_encoding
operator|==
name|NULL
condition|)
return|return
name|svn_utf_cstring_from_utf8
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|output_encoding
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cmdline_cstring_from_utf8_fuzzy
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_utf__cstring_from_utf8_fuzzy
argument_list|(
name|src
argument_list|,
name|pool
argument_list|,
name|svn_cmdline_cstring_from_utf8
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_cstring_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|input_encoding
operator|==
name|NULL
condition|)
return|return
name|svn_utf_cstring_to_utf8
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|svn_utf_cstring_to_utf8_ex2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|input_encoding
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_path_local_style_from_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_cmdline_cstring_from_utf8
argument_list|(
name|dest
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_printf
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
comment|/* A note about encoding issues:    * APR uses the execution character set, but here we give it UTF-8 strings,    * both the fmt argument and any other string arguments.  Since apr_pvsprintf    * only cares about and produces ASCII characters, this works under the    * assumption that all supported platforms use an execution character set    * with ASCII as a subset.    */
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_fputs
argument_list|(
name|message
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_fprintf
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
comment|/* See svn_cmdline_printf () for a note about character encoding issues. */
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_fputs
argument_list|(
name|message
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_fputs
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
name|err
operator|=
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|out
argument_list|,
name|string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|out
operator|=
name|svn_cmdline_cstring_from_utf8_fuzzy
argument_list|(
name|string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* On POSIX systems, errno will be set on an error in fputs, but this might      not be the case on other platforms.  We reset errno and only      use it if it was set by the below fputs call.  Else, we just return      a generic error. */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|out
argument_list|,
name|stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|apr_get_os_error
argument_list|()
condition|)
comment|/* is errno on POSIX */
block|{
comment|/* ### Issue #3014: Return a specific error for broken pipes,            * ### with a single element in the error chain. */
if|if
condition|(
name|SVN__APR_STATUS_IS_EPIPE
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_PIPE_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Write error"
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_fflush
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
comment|/* See comment in svn_cmdline_fputs about use of errno and stdio. */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|apr_get_os_error
argument_list|()
condition|)
comment|/* is errno on POSIX */
block|{
comment|/* ### Issue #3014: Return a specific error for broken pipes,            * ### with a single element in the error chain. */
if|if
condition|(
name|SVN__APR_STATUS_IS_EPIPE
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_PIPE_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Write error"
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cmdline_output_encoding
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|output_encoding
condition|)
return|return
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|output_encoding
argument_list|)
return|;
else|else
return|return
name|SVN_APR_LOCALE_CHARSET
return|;
block|}
end_function

begin_function
name|int
name|svn_cmdline_handle_exit_error
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
comment|/* Issue #3014:    * Don't print anything on broken pipes. The pipe was likely    * closed by the process at the other end. We expect that    * process to perform error reporting as necessary.    *    * ### This assumes that there is only one error in a chain for    * ### SVN_ERR_IO_PIPE_WRITE_ERROR. See svn_cmdline_fputs(). */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_IO_PIPE_WRITE_ERROR
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
condition|)
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_auth_ssl_server_trust_prompt_func_t'.     Don't actually prompt.  Instead, set *CRED_P to valid credentials    iff FAILURES is empty or is exactly SVN_AUTH_SSL_UNKNOWNCA.  If    there are any other failure bits, then set *CRED_P to null (that    is, reject the cert).     Ignore MAY_SAVE; we don't save certs we never prompted for.     Ignore BATON, REALM, and CERT_INFO,     Ignore any further films by George Lucas. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ssl_trust_unknown_server_cert
parameter_list|(
name|svn_auth_cred_ssl_server_trust_t
modifier|*
modifier|*
name|cred_p
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_uint32_t
name|failures
parameter_list|,
specifier|const
name|svn_auth_ssl_server_cert_info_t
modifier|*
name|cert_info
parameter_list|,
name|svn_boolean_t
name|may_save
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|cred_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|failures
operator|==
literal|0
operator|||
name|failures
operator|==
name|SVN_AUTH_SSL_UNKNOWNCA
condition|)
block|{
operator|*
name|cred_p
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|cred_p
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cred_p
operator|)
operator|->
name|may_save
operator|=
name|FALSE
expr_stmt|;
operator|(
operator|*
name|cred_p
operator|)
operator|->
name|accepted_failures
operator|=
name|failures
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_create_auth_baton
parameter_list|(
name|svn_auth_baton_t
modifier|*
modifier|*
name|ab
parameter_list|,
name|svn_boolean_t
name|non_interactive
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_username
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_password
parameter_list|,
specifier|const
name|char
modifier|*
name|config_dir
parameter_list|,
name|svn_boolean_t
name|no_auth_cache
parameter_list|,
name|svn_boolean_t
name|trust_server_cert
parameter_list|,
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|store_password_val
init|=
name|TRUE
decl_stmt|;
name|svn_boolean_t
name|store_auth_creds_val
init|=
name|TRUE
decl_stmt|;
name|svn_auth_provider_object_t
modifier|*
name|provider
decl_stmt|;
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
init|=
name|NULL
decl_stmt|;
comment|/* The whole list of registered providers */
name|apr_array_header_t
modifier|*
name|providers
decl_stmt|;
comment|/* Populate the registered providers with the platform-specific providers */
name|SVN_ERR
argument_list|(
name|svn_auth_get_platform_specific_client_providers
argument_list|(
operator|&
name|providers
argument_list|,
name|cfg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a cancellation function, cram it and the stuff it      needs into the prompt baton. */
if|if
condition|(
name|cancel_func
condition|)
block|{
name|pb
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pb
argument_list|)
argument_list|)
expr_stmt|;
name|pb
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|pb
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|pb
operator|->
name|config_dir
operator|=
name|config_dir
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|non_interactive
condition|)
block|{
comment|/* This provider doesn't prompt the user in order to get creds;          it prompts the user regarding the caching of creds. */
name|svn_auth_get_simple_provider2
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_plaintext_prompt
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_auth_get_simple_provider2
argument_list|(
operator|&
name|provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_username_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
comment|/* The windows ssl server certificate CRYPTOAPI provider. */
name|SVN_ERR
argument_list|(
name|svn_auth_get_platform_specific_provider
argument_list|(
operator|&
name|provider
argument_list|,
literal|"windows"
argument_list|,
literal|"ssl_server_trust"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|provider
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
comment|/* The windows ssl authority certificate CRYPTOAPI provider. */
name|SVN_ERR
argument_list|(
name|svn_auth_get_platform_specific_provider
argument_list|(
operator|&
name|provider
argument_list|,
literal|"windows"
argument_list|,
literal|"ssl_server_authority"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|provider
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_ssl_server_trust_file_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_ssl_client_cert_file_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
if|if
condition|(
operator|!
name|non_interactive
condition|)
block|{
comment|/* This provider doesn't prompt the user in order to get creds;          it prompts the user regarding the caching of creds. */
name|svn_auth_get_ssl_client_cert_pw_file_provider2
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_plaintext_passphrase_prompt
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_auth_get_ssl_client_cert_pw_file_provider2
argument_list|(
operator|&
name|provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
if|if
condition|(
operator|!
name|non_interactive
condition|)
block|{
name|svn_boolean_t
name|ssl_client_cert_file_prompt
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|ssl_client_cert_file_prompt
argument_list|,
name|SVN_CONFIG_SECTION_AUTH
argument_list|,
name|SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE_PROMPT
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Two basic prompt providers: username/password, and just username. */
name|svn_auth_get_simple_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_simple_prompt
argument_list|,
name|pb
argument_list|,
literal|2
argument_list|,
comment|/* retry limit */
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_username_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_username_prompt
argument_list|,
name|pb
argument_list|,
literal|2
argument_list|,
comment|/* retry limit */
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
comment|/* SSL prompt providers: server-certs and client-cert-passphrases.  */
name|svn_auth_get_ssl_server_trust_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_ssl_server_trust_prompt
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_ssl_client_cert_pw_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_ssl_client_cert_pw_prompt
argument_list|,
name|pb
argument_list|,
literal|2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
comment|/* If configuration allows, add a provider for client-cert path          prompting, too. */
if|if
condition|(
name|ssl_client_cert_file_prompt
condition|)
block|{
name|svn_auth_get_ssl_client_cert_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_ssl_client_cert_prompt
argument_list|,
name|pb
argument_list|,
literal|2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|trust_server_cert
condition|)
block|{
comment|/* Remember, only register this provider if non_interactive. */
name|svn_auth_get_ssl_server_trust_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|ssl_trust_unknown_server_cert
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
block|}
comment|/* Build an authentication baton to give to libsvn_client. */
name|svn_auth_open
argument_list|(
name|ab
argument_list|,
name|providers
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Place any default --username or --password credentials into the      auth_baton's run-time parameter hash. */
if|if
condition|(
name|auth_username
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_DEFAULT_USERNAME
argument_list|,
name|auth_username
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_password
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_DEFAULT_PASSWORD
argument_list|,
name|auth_password
argument_list|)
expr_stmt|;
comment|/* Same with the --non-interactive option. */
if|if
condition|(
name|non_interactive
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_NON_INTERACTIVE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_dir
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_CONFIG_DIR
argument_list|,
name|config_dir
argument_list|)
expr_stmt|;
comment|/* Determine whether storing passwords in any form is allowed.    * This is the deprecated location for this option, the new    * location is SVN_CONFIG_CATEGORY_SERVERS. The RA layer may    * override the value we set here. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|store_password_val
argument_list|,
name|SVN_CONFIG_SECTION_AUTH
argument_list|,
name|SVN_CONFIG_OPTION_STORE_PASSWORDS
argument_list|,
name|SVN_CONFIG_DEFAULT_OPTION_STORE_PASSWORDS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|store_password_val
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_DONT_STORE_PASSWORDS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Determine whether we are allowed to write to the auth/ area.    * This is the deprecated location for this option, the new    * location is SVN_CONFIG_CATEGORY_SERVERS. The RA layer may    * override the value we set here. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|store_auth_creds_val
argument_list|,
name|SVN_CONFIG_SECTION_AUTH
argument_list|,
name|SVN_CONFIG_OPTION_STORE_AUTH_CREDS
argument_list|,
name|SVN_CONFIG_DEFAULT_OPTION_STORE_AUTH_CREDS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_auth_cache
operator|||
operator|!
name|store_auth_creds_val
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_NO_AUTH_CACHE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_HAVE_GNOME_KEYRING
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_FUNC
argument_list|,
operator|&
name|svn_cmdline__auth_gnome_keyring_unlock_prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SVN_HAVE_GNOME_KEYRING */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__getopt_init
parameter_list|(
name|apr_getopt_t
modifier|*
modifier|*
name|os
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
init|=
name|apr_getopt_init
argument_list|(
name|os
argument_list|,
name|pool
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error initializing command line arguments"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_cmdline__print_xml_prop
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|svn_string_t
modifier|*
name|propval
parameter_list|,
name|svn_boolean_t
name|inherited_prop
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|xml_safe
decl_stmt|;
specifier|const
name|char
modifier|*
name|encoding
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|outstr
operator|==
name|NULL
condition|)
operator|*
name|outstr
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_xml_is_xml_safe
argument_list|(
name|propval
operator|->
name|data
argument_list|,
name|propval
operator|->
name|len
argument_list|)
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|xml_esc
init|=
name|NULL
decl_stmt|;
name|svn_xml_escape_cdata_string
argument_list|(
operator|&
name|xml_esc
argument_list|,
name|propval
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|xml_safe
operator|=
name|xml_esc
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|svn_string_t
modifier|*
name|base64ed
init|=
name|svn_base64_encode_string2
argument_list|(
name|propval
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|encoding
operator|=
literal|"base64"
expr_stmt|;
name|xml_safe
operator|=
name|base64ed
operator|->
name|data
expr_stmt|;
block|}
if|if
condition|(
name|encoding
condition|)
name|svn_xml_make_open_tag
argument_list|(
name|outstr
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
name|inherited_prop
condition|?
literal|"inherited_property"
else|:
literal|"property"
argument_list|,
literal|"name"
argument_list|,
name|propname
argument_list|,
literal|"encoding"
argument_list|,
name|encoding
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|svn_xml_make_open_tag
argument_list|(
name|outstr
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
name|inherited_prop
condition|?
literal|"inherited_property"
else|:
literal|"property"
argument_list|,
literal|"name"
argument_list|,
name|propname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
name|xml_safe
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
name|outstr
argument_list|,
name|pool
argument_list|,
name|inherited_prop
condition|?
literal|"inherited_property"
else|:
literal|"property"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__parse_config_option
parameter_list|(
name|apr_array_header_t
modifier|*
name|config_options
parameter_list|,
specifier|const
name|char
modifier|*
name|opt_arg
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cmdline__config_argument_t
modifier|*
name|config_option
decl_stmt|;
specifier|const
name|char
modifier|*
name|first_colon
decl_stmt|,
modifier|*
name|second_colon
decl_stmt|,
modifier|*
name|equals_sign
decl_stmt|;
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|opt_arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|first_colon
operator|=
name|strchr
argument_list|(
name|opt_arg
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
name|first_colon
operator|!=
name|opt_arg
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|second_colon
operator|=
name|strchr
argument_list|(
name|first_colon
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
name|second_colon
operator|!=
name|first_colon
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|equals_sign
operator|=
name|strchr
argument_list|(
name|second_colon
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
operator|)
operator|&&
operator|(
name|equals_sign
operator|!=
name|second_colon
operator|+
literal|1
operator|)
condition|)
block|{
name|config_option
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config_option
argument_list|)
argument_list|)
expr_stmt|;
name|config_option
operator|->
name|file
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|opt_arg
argument_list|,
name|first_colon
operator|-
name|opt_arg
argument_list|)
expr_stmt|;
name|config_option
operator|->
name|section
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|first_colon
operator|+
literal|1
argument_list|,
name|second_colon
operator|-
name|first_colon
operator|-
literal|1
argument_list|)
expr_stmt|;
name|config_option
operator|->
name|option
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|second_colon
operator|+
literal|1
argument_list|,
name|equals_sign
operator|-
name|second_colon
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|strchr
argument_list|(
name|config_option
operator|->
name|option
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
name|config_option
operator|->
name|value
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|equals_sign
operator|+
literal|1
argument_list|,
name|opt_arg
operator|+
name|len
operator|-
name|equals_sign
operator|-
literal|1
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|config_options
argument_list|,
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
operator|=
name|config_option
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
block|}
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid syntax of argument of --config-option"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__apply_config_options
parameter_list|(
name|apr_hash_t
modifier|*
name|config
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|config_options
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|argument_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config_options
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
name|svn_cmdline__config_argument_t
modifier|*
name|arg
init|=
name|APR_ARRAY_IDX
argument_list|(
name|config_options
argument_list|,
name|i
argument_list|,
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
decl_stmt|;
name|cfg
operator|=
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|arg
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
block|{
name|svn_config_set
argument_list|(
name|cfg
argument_list|,
name|arg
operator|->
name|section
argument_list|,
name|arg
operator|->
name|option
argument_list|,
name|arg
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unrecognized file in argument of %s"
argument_list|)
argument_list|,
name|argument_name
argument_list|)
decl_stmt|;
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a copy, allocated in POOL, of the next line of text from *STR  * up to and including a CR and/or an LF. Change *STR to point to the  * remainder of the string after the returned part. If there are no  * characters to be returned, return NULL; never return an empty string.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|next_line
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
comment|/* n.b. Throughout this fn, we never read any character after a '\0'. */
comment|/* Skip over all non-EOL characters, if any. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\r'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip over \r\n or \n\r or \r or \n, if any. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|&&
operator|*
name|p
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|&&
operator|*
name|p
operator|==
literal|'\r'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* Now p points after at most one '\n' and/or '\r'. */
operator|*
name|str
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|start
condition|)
return|return
name|NULL
return|;
return|return
name|svn_string_ncreate
argument_list|(
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|,
name|pool
argument_list|)
operator|->
name|data
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cmdline__indent_string
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|out
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|next_line
argument_list|(
operator|&
name|str
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|out
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|out
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
return|return
name|out
operator|->
name|data
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__print_prop_hash
parameter_list|(
name|svn_stream_t
modifier|*
name|out
parameter_list|,
name|apr_hash_t
modifier|*
name|prop_hash
parameter_list|,
name|svn_boolean_t
name|names_only
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_props
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sorted_props
operator|=
name|svn_sort__hash
argument_list|(
name|prop_hash
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_props
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname
init|=
name|item
operator|.
name|key
decl_stmt|;
name|svn_string_t
modifier|*
name|propval
init|=
name|item
operator|.
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname_stdout
decl_stmt|;
if|if
condition|(
name|svn_prop_needs_translation
argument_list|(
name|pname
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_subst_detranslate_string
argument_list|(
operator|&
name|propval
argument_list|,
name|propval
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|pname_stdout
argument_list|,
name|pname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|pname_stdout
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"  %s\n"
argument_list|,
name|pname_stdout
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|pname_stdout
argument_list|,
operator|&
name|pname_stdout
argument_list|,
name|APR_EOL_STR
argument_list|,
comment|/* 'native' eol */
name|FALSE
argument_list|,
comment|/* no repair */
name|NULL
argument_list|,
comment|/* no keywords */
name|FALSE
argument_list|,
comment|/* no expansion */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|out
argument_list|,
name|pname_stdout
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ### We leave these printfs for now, since if propval wasn't              translated above, we don't know anything about its encoding.              In fact, it might be binary data... */
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|pname_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|names_only
condition|)
block|{
comment|/* Add an extra newline to the value before indenting, so that            * every line of output has the indentation whether the value            * already ended in a newline or not. */
specifier|const
name|char
modifier|*
name|newval
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|propval
operator|->
name|data
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|indented_newval
init|=
name|svn_cmdline__indent_string
argument_list|(
name|newval
argument_list|,
literal|"    "
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|out
argument_list|,
name|indented_newval
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|indented_newval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__print_xml_prop_hash
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
name|apr_hash_t
modifier|*
name|prop_hash
parameter_list|,
name|svn_boolean_t
name|names_only
parameter_list|,
name|svn_boolean_t
name|inherited_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_props
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|outstr
operator|==
name|NULL
condition|)
operator|*
name|outstr
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|sorted_props
operator|=
name|svn_sort__hash
argument_list|(
name|prop_hash
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_props
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname
init|=
name|item
operator|.
name|key
decl_stmt|;
name|svn_string_t
modifier|*
name|propval
init|=
name|item
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|names_only
condition|)
block|{
name|svn_xml_make_open_tag
argument_list|(
name|outstr
argument_list|,
name|pool
argument_list|,
name|svn_xml_self_closing
argument_list|,
name|inherited_props
condition|?
literal|"inherited_property"
else|:
literal|"property"
argument_list|,
literal|"name"
argument_list|,
name|pname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|pname_out
decl_stmt|;
if|if
condition|(
name|svn_prop_needs_translation
argument_list|(
name|pname
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_subst_detranslate_string
argument_list|(
operator|&
name|propval
argument_list|,
name|propval
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|pname_out
argument_list|,
name|pname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_cmdline__print_xml_prop
argument_list|(
name|outstr
argument_list|,
name|pname_out
argument_list|,
name|propval
argument_list|,
name|inherited_props
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_cmdline__be_interactive
parameter_list|(
name|svn_boolean_t
name|non_interactive
parameter_list|,
name|svn_boolean_t
name|force_interactive
parameter_list|)
block|{
comment|/* If neither --non-interactive nor --force-interactive was passed,    * be interactive if stdin is a terminal.    * If --force-interactive was passed, always be interactive. */
if|if
condition|(
operator|!
name|force_interactive
operator|&&
operator|!
name|non_interactive
condition|)
block|{
ifdef|#
directive|ifdef
name|WIN32
return|return
operator|(
name|_isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|!=
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|!=
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|force_interactive
condition|)
return|return
name|TRUE
return|;
return|return
operator|!
name|non_interactive
return|;
block|}
end_function

begin_comment
comment|/* Helper for the next two functions.  Set *EDITOR to some path to an    editor binary.  Sources to search include: the EDITOR_CMD argument    (if not NULL), $SVN_EDITOR, the runtime CONFIG variable (if CONFIG    is not NULL), $VISUAL, $EDITOR.  Return    SVN_ERR_CL_NO_EXTERNAL_EDITOR if no binary can be found. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_editor_binary
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|editor
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|e
decl_stmt|;
name|struct
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
comment|/* Use the editor specified on the command line via --editor-cmd, if any. */
name|e
operator|=
name|editor_cmd
expr_stmt|;
comment|/* Otherwise look for the Subversion-specific environment variable. */
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|getenv
argument_list|(
literal|"SVN_EDITOR"
argument_list|)
expr_stmt|;
comment|/* If not found then fall back on the config file. */
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|cfg
operator|=
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|e
argument_list|,
name|SVN_CONFIG_SECTION_HELPERS
argument_list|,
name|SVN_CONFIG_OPTION_EDITOR_CMD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* If not found yet then try general purpose environment variables. */
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|getenv
argument_list|(
literal|"VISUAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_CLIENT_EDITOR
comment|/* If still not found then fall back on the hard-coded default. */
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|SVN_CLIENT_EDITOR
expr_stmt|;
endif|#
directive|endif
comment|/* Error if there is no editor specified */
if|if
condition|(
name|e
condition|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|e
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|svn_ctype_isspace
argument_list|(
operator|*
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|c
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_NO_EXTERNAL_EDITOR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The EDITOR, SVN_EDITOR or VISUAL environment variable or "
literal|"'editor-cmd' run-time configuration option is empty or "
literal|"consists solely of whitespace. Expected a shell command."
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_NO_EXTERNAL_EDITOR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"None of the environment variables SVN_EDITOR, VISUAL or EDITOR are "
literal|"set, and no 'editor-cmd' run-time configuration option was found"
argument_list|)
argument_list|)
return|;
operator|*
name|editor
operator|=
name|e
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__edit_file_externally
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|editor
decl_stmt|,
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|base_dir
decl_stmt|,
modifier|*
name|file_name
decl_stmt|,
modifier|*
name|base_dir_apr
decl_stmt|;
name|char
modifier|*
name|old_cwd
decl_stmt|;
name|int
name|sys_err
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|base_dir
argument_list|,
operator|&
name|file_name
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_editor_binary
argument_list|(
operator|&
name|editor
argument_list|,
name|editor_cmd
argument_list|,
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_get
argument_list|(
operator|&
name|old_cwd
argument_list|,
name|APR_FILEPATH_NATIVE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get working directory"
argument_list|)
argument_list|)
return|;
comment|/* APR doesn't like "" directories */
if|if
condition|(
name|base_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|base_dir_apr
operator|=
literal|"."
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|base_dir_apr
argument_list|,
name|base_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|base_dir_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't change working directory to '%s'"
argument_list|)
argument_list|,
name|base_dir
argument_list|)
return|;
name|cmd
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s %s"
argument_list|,
name|editor
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|sys_err
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|old_cwd
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
name|svn_handle_error2
argument_list|(
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't restore working directory"
argument_list|)
argument_list|)
argument_list|,
name|stderr
argument_list|,
name|TRUE
comment|/* fatal */
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_err
condition|)
comment|/* Extracting any meaning from sys_err is platform specific, so just        use the raw value. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"system('%s') returned %d"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|sys_err
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__edit_string_externally
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|edited_contents
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmpfile_left
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
specifier|const
name|char
modifier|*
name|base_dir
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|contents
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|svn_boolean_t
name|as_text
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|editor
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|apr_file_t
modifier|*
name|tmp_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpfile_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpfile_native
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpfile_apr
decl_stmt|,
modifier|*
name|base_dir_apr
decl_stmt|;
name|svn_string_t
modifier|*
name|translated_contents
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|,
name|apr_err2
decl_stmt|;
name|apr_size_t
name|written
decl_stmt|;
name|apr_finfo_t
name|finfo_before
decl_stmt|,
name|finfo_after
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|,
modifier|*
name|err2
decl_stmt|;
name|char
modifier|*
name|old_cwd
decl_stmt|;
name|int
name|sys_err
decl_stmt|;
name|svn_boolean_t
name|remove_file
init|=
name|TRUE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|find_editor_binary
argument_list|(
operator|&
name|editor
argument_list|,
name|editor_cmd
argument_list|,
name|config
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert file contents from UTF-8/LF if desired. */
if|if
condition|(
name|as_text
condition|)
block|{
specifier|const
name|char
modifier|*
name|translated
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|contents
operator|->
name|data
argument_list|,
operator|&
name|translated
argument_list|,
name|APR_EOL_STR
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|translated_contents
operator|=
name|svn_string_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
condition|)
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
name|translated_contents
operator|->
name|data
argument_list|,
name|translated
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|translated_contents
operator|->
name|data
argument_list|,
name|translated
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|translated_contents
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|translated_contents
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
else|else
name|translated_contents
operator|=
name|svn_string_dup
argument_list|(
name|contents
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Move to BASE_DIR to avoid getting characters that need quoting      into tmpfile_name */
name|apr_err
operator|=
name|apr_filepath_get
argument_list|(
operator|&
name|old_cwd
argument_list|,
name|APR_FILEPATH_NATIVE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get working directory"
argument_list|)
argument_list|)
return|;
comment|/* APR doesn't like "" directories */
if|if
condition|(
name|base_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|base_dir_apr
operator|=
literal|"."
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|base_dir_apr
argument_list|,
name|base_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|base_dir_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't change working directory to '%s'"
argument_list|)
argument_list|,
name|base_dir
argument_list|)
return|;
block|}
comment|/*** From here on, any problems that occur require us to cd back!! ***/
comment|/* Ask the working copy for a temporary file named FILENAME-something. */
name|err
operator|=
name|svn_io_open_uniquely_named
argument_list|(
operator|&
name|tmp_file
argument_list|,
operator|&
name|tmpfile_name
argument_list|,
literal|""
comment|/* dirpath */
argument_list|,
name|filename
argument_list|,
literal|".tmp"
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_EACCES
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|err
operator|->
name|apr_err
operator|==
name|EROFS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|temp_dir_apr
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_temp_dir
argument_list|(
operator|&
name|base_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|temp_dir_apr
argument_list|,
name|base_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|temp_dir_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't change working directory to '%s'"
argument_list|)
argument_list|,
name|base_dir
argument_list|)
return|;
block|}
name|err
operator|=
name|svn_io_open_uniquely_named
argument_list|(
operator|&
name|tmp_file
argument_list|,
operator|&
name|tmpfile_name
argument_list|,
literal|""
comment|/* dirpath */
argument_list|,
name|filename
argument_list|,
literal|".tmp"
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup2
goto|;
comment|/*** From here on, any problems that occur require us to cleanup        the file we just created!! ***/
comment|/* Dump initial CONTENTS to TMP_FILE. */
name|apr_err
operator|=
name|apr_file_write_full
argument_list|(
name|tmp_file
argument_list|,
name|translated_contents
operator|->
name|data
argument_list|,
name|translated_contents
operator|->
name|len
argument_list|,
operator|&
name|written
argument_list|)
expr_stmt|;
name|apr_err2
operator|=
name|apr_file_close
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apr_err
condition|)
name|apr_err
operator|=
name|apr_err2
expr_stmt|;
comment|/* Make sure the whole CONTENTS were written, else return an error. */
if|if
condition|(
name|apr_err
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't write to '%s'"
argument_list|)
argument_list|,
name|tmpfile_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|err
operator|=
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|tmpfile_apr
argument_list|,
name|tmpfile_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Get information about the temporary file before the user has      been allowed to edit its contents. */
name|apr_err
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo_before
argument_list|,
name|tmpfile_apr
argument_list|,
name|APR_FINFO_MTIME
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't stat '%s'"
argument_list|)
argument_list|,
name|tmpfile_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Backdate the file a little bit in case the editor is very fast      and doesn't change the size.  (Use two seconds, since some      filesystems have coarse granularity.)  It's OK if this call      fails, so we don't check its return value.*/
name|apr_file_mtime_set
argument_list|(
name|tmpfile_apr
argument_list|,
name|finfo_before
operator|.
name|mtime
operator|-
literal|2000
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Stat it again to get the mtime we actually set. */
name|apr_err
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo_before
argument_list|,
name|tmpfile_apr
argument_list|,
name|APR_FINFO_MTIME
operator||
name|APR_FINFO_SIZE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't stat '%s'"
argument_list|)
argument_list|,
name|tmpfile_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Prepare the editor command line.  */
name|err
operator|=
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|tmpfile_native
argument_list|,
name|tmpfile_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
name|cmd
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s %s"
argument_list|,
name|editor
argument_list|,
name|tmpfile_native
argument_list|)
expr_stmt|;
comment|/* If the caller wants us to leave the file around, return the path      of the file we'll use, and make a note not to destroy it.  */
if|if
condition|(
name|tmpfile_left
condition|)
block|{
operator|*
name|tmpfile_left
operator|=
name|svn_dirent_join
argument_list|(
name|base_dir
argument_list|,
name|tmpfile_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|remove_file
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Now, run the editor command line.  */
name|sys_err
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_err
operator|!=
literal|0
condition|)
block|{
comment|/* Extracting any meaning from sys_err is platform specific, so just          use the raw value. */
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"system('%s') returned %d"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|sys_err
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Get information about the temporary file after the assumed editing. */
name|apr_err
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo_after
argument_list|,
name|tmpfile_apr
argument_list|,
name|APR_FINFO_MTIME
operator||
name|APR_FINFO_SIZE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't stat '%s'"
argument_list|)
argument_list|,
name|tmpfile_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* If the file looks changed... */
if|if
condition|(
operator|(
name|finfo_before
operator|.
name|mtime
operator|!=
name|finfo_after
operator|.
name|mtime
operator|)
operator|||
operator|(
name|finfo_before
operator|.
name|size
operator|!=
name|finfo_after
operator|.
name|size
operator|)
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|edited_contents_s
decl_stmt|;
name|err
operator|=
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|edited_contents_s
argument_list|,
name|tmpfile_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
operator|*
name|edited_contents
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|edited_contents_s
argument_list|)
expr_stmt|;
comment|/* Translate back to UTF8/LF if desired. */
if|if
condition|(
name|as_text
condition|)
block|{
name|err
operator|=
name|svn_subst_translate_string2
argument_list|(
name|edited_contents
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|*
name|edited_contents
argument_list|,
name|encoding
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Error normalizing edited contents to internal format"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* No edits seem to have been made */
operator|*
name|edited_contents
operator|=
name|NULL
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|remove_file
condition|)
block|{
comment|/* Remove the file from disk.  */
name|err2
operator|=
name|svn_io_remove_file2
argument_list|(
name|tmpfile_name
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Only report remove error if there was no previous error. */
if|if
condition|(
operator|!
name|err
operator|&&
name|err2
condition|)
name|err
operator|=
name|err2
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|err2
argument_list|)
expr_stmt|;
block|}
name|cleanup2
label|:
comment|/* If we against all probability can't cd back, all further relative      file references would be screwed up, so we have to abort. */
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|old_cwd
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|svn_handle_error2
argument_list|(
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't restore working directory"
argument_list|)
argument_list|)
argument_list|,
name|stderr
argument_list|,
name|TRUE
comment|/* fatal */
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

end_unit

