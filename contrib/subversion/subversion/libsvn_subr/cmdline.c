begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * cmdline.c :  Helpers for command-line programs.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for atexit() */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* for setvbuf() */
end_comment

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_comment
comment|/* for setlocale() */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<crtdbg.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<conio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_comment
comment|/* for STDIN_FILENO */
end_comment

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_comment
comment|/* for apr_strerror */
end_comment

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_comment
comment|/* for apr_initialize/apr_terminate */
end_comment

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_comment
comment|/* for apr_snprintf */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_dso.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_nls.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_auth.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"win32_crashrpt.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|_MSC_VER
operator|<
literal|1400
operator|)
end_if

begin_comment
comment|/* Before Visual Studio 2005, the C runtime didn't handle encodings for the    for the stdio output handling. */
end_comment

begin_define
define|#
directive|define
name|CMDLINE_USE_CUSTOM_ENCODING
end_define

begin_comment
comment|/* The stdin encoding. If null, it's the same as the native encoding. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_encoding
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stdout encoding. If null, it's the same as the native encoding. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|output_encoding
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif

begin_comment
comment|/* For now limit this code to Visual C++, as the result is highly dependent    on the CRT implementation */
end_comment

begin_define
define|#
directive|define
name|USE_WIN32_CONSOLE_SHORTCUT
end_define

begin_comment
comment|/* When TRUE, stdout/stderr is directly connected to a console */
end_comment

begin_decl_stmt
specifier|static
name|svn_boolean_t
name|shortcut_stdout_to_console
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|svn_boolean_t
name|shortcut_stderr_to_console
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|svn_cmdline_init
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
name|FILE
modifier|*
name|error_stream
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|char
name|prefix_buf
index|[
literal|64
index|]
decl_stmt|;
comment|/* 64 is probably bigger than most program names */
ifndef|#
directive|ifndef
name|WIN32
block|{
name|struct
name|stat
name|st
decl_stmt|;
comment|/* The following makes sure that file descriptors 0 (stdin), 1        (stdout) and 2 (stderr) will not be "reused", because if        e.g. file descriptor 2 would be reused when opening a file, a        write to stderr would write to that file and most likely        corrupt it. */
if|if
condition|(
operator|(
name|fstat
argument_list|(
literal|0
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDONLY
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|fstat
argument_list|(
literal|1
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|fstat
argument_list|(
literal|2
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
name|fprintf
argument_list|(
name|error_stream
argument_list|,
literal|"%s: error: cannot open '/dev/null'\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
endif|#
directive|endif
comment|/* Ignore any errors encountered while attempting to change stream      buffering, as the streams should retain their default buffering      modes. */
if|if
condition|(
name|error_stream
condition|)
name|setvbuf
argument_list|(
name|error_stream
argument_list|,
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
ifdef|#
directive|ifdef
name|CMDLINE_USE_CUSTOM_ENCODING
comment|/* Initialize the input and output encodings. */
block|{
specifier|static
name|char
name|input_encoding_buffer
index|[
literal|16
index|]
decl_stmt|;
specifier|static
name|char
name|output_encoding_buffer
index|[
literal|16
index|]
decl_stmt|;
name|apr_snprintf
argument_list|(
name|input_encoding_buffer
argument_list|,
sizeof|sizeof
name|input_encoding_buffer
argument_list|,
literal|"CP%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|GetConsoleCP
argument_list|()
argument_list|)
expr_stmt|;
name|input_encoding
operator|=
name|input_encoding_buffer
expr_stmt|;
name|apr_snprintf
argument_list|(
name|output_encoding_buffer
argument_list|,
sizeof|sizeof
name|output_encoding_buffer
argument_list|,
literal|"CP%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|GetConsoleOutputCP
argument_list|()
argument_list|)
expr_stmt|;
name|output_encoding
operator|=
name|output_encoding_buffer
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CMDLINE_USE_CUSTOM_ENCODING */
ifdef|#
directive|ifdef
name|SVN_USE_WIN32_CRASHHANDLER
if|if
condition|(
operator|!
name|getenv
argument_list|(
literal|"SVN_CMDLINE_DISABLE_CRASH_HANDLER"
argument_list|)
condition|)
block|{
comment|/* Attach (but don't load) the crash handler */
name|SetUnhandledExceptionFilter
argument_list|(
name|svn__unhandled_exception_filter
argument_list|)
expr_stmt|;
if|#
directive|if
name|_MSC_VER
operator|>=
literal|1400
comment|/* ### This should work for VC++ 2002 (=1300) and later */
comment|/* Show the abort message on STDERR instead of a dialog to allow          scripts (e.g. our testsuite) to continue after an abort without          user intervention. Allow overriding for easier debugging. */
if|if
condition|(
operator|!
name|getenv
argument_list|(
literal|"SVN_CMDLINE_USE_DIALOG_FOR_ABORT"
argument_list|)
condition|)
block|{
comment|/* In release mode: Redirect abort() errors to stderr */
name|_set_error_mode
argument_list|(
name|_OUT_TO_STDERR
argument_list|)
expr_stmt|;
comment|/* In _DEBUG mode: Redirect all debug output (E.g. assert() to stderr.              (Ignored in release builds) */
name|_CrtSetReportFile
argument_list|(
name|_CRT_WARN
argument_list|,
name|_CRTDBG_FILE_STDERR
argument_list|)
expr_stmt|;
name|_CrtSetReportFile
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_FILE_STDERR
argument_list|)
expr_stmt|;
name|_CrtSetReportFile
argument_list|(
name|_CRT_ASSERT
argument_list|,
name|_CRTDBG_FILE_STDERR
argument_list|)
expr_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_WARN
argument_list|,
name|_CRTDBG_MODE_FILE
operator||
name|_CRTDBG_MODE_DEBUG
argument_list|)
expr_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_MODE_FILE
operator||
name|_CRTDBG_MODE_DEBUG
argument_list|)
expr_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_ASSERT
argument_list|,
name|_CRTDBG_MODE_FILE
operator||
name|_CRTDBG_MODE_DEBUG
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _MSC_VER>= 1400 */
block|}
endif|#
directive|endif
comment|/* SVN_USE_WIN32_CRASHHANDLER */
endif|#
directive|endif
comment|/* WIN32 */
comment|/* C programs default to the "C" locale. But because svn is supposed      to be i18n-aware, it should inherit the default locale of its      environment.  */
if|if
condition|(
operator|!
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
operator|&&
operator|!
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
block|{
specifier|const
name|char
modifier|*
name|env_vars
index|[]
init|=
block|{
literal|"LC_ALL"
block|,
literal|"LC_CTYPE"
block|,
literal|"LANG"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|env_var
init|=
operator|&
name|env_vars
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|env_val
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|env_var
condition|)
block|{
name|env_val
operator|=
name|getenv
argument_list|(
operator|*
name|env_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_val
operator|&&
name|env_val
index|[
literal|0
index|]
condition|)
break|break;
operator|++
name|env_var
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|env_var
condition|)
block|{
comment|/* Unlikely. Can setlocale fail if no env vars are set? */
operator|--
name|env_var
expr_stmt|;
name|env_val
operator|=
literal|"not set"
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|error_stream
argument_list|,
literal|"%s: warning: cannot set LC_CTYPE locale\n"
literal|"%s: warning: environment variable %s is %s\n"
literal|"%s: warning: please check that your locale name is correct\n"
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|,
operator|*
name|env_var
argument_list|,
name|env_val
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize the APR subsystem, and register an atexit() function      to Uninitialize that subsystem at program exit. */
name|status
operator|=
name|apr_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|apr_strerror
argument_list|(
name|status
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|error_stream
argument_list|,
literal|"%s: error: cannot initialize APR: %s\n"
argument_list|,
name|progname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_FAILURE
return|;
block|}
name|strncpy
argument_list|(
name|prefix_buf
argument_list|,
name|progname
argument_list|,
sizeof|sizeof
argument_list|(
name|prefix_buf
argument_list|)
operator|-
literal|3
argument_list|)
expr_stmt|;
name|prefix_buf
index|[
sizeof|sizeof
argument_list|(
name|prefix_buf
argument_list|)
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|prefix_buf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
comment|/* DSO pool must be created before any other pools used by the      application so that pool cleanup doesn't unload DSOs too      early. See docstring of svn_dso_initialize2(). */
if|if
condition|(
operator|(
name|err
operator|=
name|svn_dso_initialize2
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|error_stream
argument_list|,
name|TRUE
argument_list|,
name|prefix_buf
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
if|if
condition|(
literal|0
operator|>
name|atexit
argument_list|(
name|apr_terminate
argument_list|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
name|fprintf
argument_list|(
name|error_stream
argument_list|,
literal|"%s: error: atexit registration failed\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
comment|/* Create a pool for use by the UTF-8 routines.  It will be cleaned      up by APR at exit time. */
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|svn_utf_initialize2
argument_list|(
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|svn_nls_init
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|error_stream
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|error_stream
argument_list|,
name|TRUE
argument_list|,
name|prefix_buf
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
ifdef|#
directive|ifdef
name|USE_WIN32_CONSOLE_SHORTCUT
if|if
condition|(
name|_isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
block|{
name|DWORD
name|ignored
decl_stmt|;
name|HANDLE
name|stdout_handle
init|=
name|GetStdHandle
argument_list|(
name|STD_OUTPUT_HANDLE
argument_list|)
decl_stmt|;
comment|/* stdout is a char device handle, but is it the console? */
if|if
condition|(
name|GetConsoleMode
argument_list|(
name|stdout_handle
argument_list|,
operator|&
name|ignored
argument_list|)
condition|)
name|shortcut_stdout_to_console
operator|=
name|TRUE
expr_stmt|;
comment|/* Don't close stdout_handle */
block|}
if|if
condition|(
name|_isatty
argument_list|(
name|STDERR_FILENO
argument_list|)
condition|)
block|{
name|DWORD
name|ignored
decl_stmt|;
name|HANDLE
name|stderr_handle
init|=
name|GetStdHandle
argument_list|(
name|STD_ERROR_HANDLE
argument_list|)
decl_stmt|;
comment|/* stderr is a char device handle, but is it the console? */
if|if
condition|(
name|GetConsoleMode
argument_list|(
name|stderr_handle
argument_list|,
operator|&
name|ignored
argument_list|)
condition|)
name|shortcut_stderr_to_console
operator|=
name|TRUE
expr_stmt|;
comment|/* Don't close stderr_handle */
block|}
endif|#
directive|endif
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_cstring_from_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CMDLINE_USE_CUSTOM_ENCODING
if|if
condition|(
name|output_encoding
operator|!=
name|NULL
condition|)
return|return
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|output_encoding
argument_list|,
name|pool
argument_list|)
return|;
endif|#
directive|endif
return|return
name|svn_utf_cstring_from_utf8
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cmdline_cstring_from_utf8_fuzzy
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_utf__cstring_from_utf8_fuzzy
argument_list|(
name|src
argument_list|,
name|pool
argument_list|,
name|svn_cmdline_cstring_from_utf8
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_cstring_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CMDLINE_USE_CUSTOM_ENCODING
if|if
condition|(
name|input_encoding
operator|!=
name|NULL
condition|)
return|return
name|svn_utf_cstring_to_utf8_ex2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|input_encoding
argument_list|,
name|pool
argument_list|)
return|;
endif|#
directive|endif
return|return
name|svn_utf_cstring_to_utf8
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_path_local_style_from_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_cmdline_cstring_from_utf8
argument_list|(
name|dest
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_printf
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
comment|/* A note about encoding issues:    * APR uses the execution character set, but here we give it UTF-8 strings,    * both the fmt argument and any other string arguments.  Since apr_pvsprintf    * only cares about and produces ASCII characters, this works under the    * assumption that all supported platforms use an execution character set    * with ASCII as a subset.    */
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_fputs
argument_list|(
name|message
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_fprintf
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
comment|/* See svn_cmdline_printf () for a note about character encoding issues. */
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_fputs
argument_list|(
name|message
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_fputs
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WIN32_CONSOLE_SHORTCUT
comment|/* For legacy reasons the Visual C++ runtime converts output to the console      from the native 'ansi' encoding, to unicode, then back to 'ansi' and then      onwards to the console which is implemented as unicode.       For operations like 'svn status -v' this may cause about 70% of the total      processing time, with absolutely no gain.       For this specific scenario this shortcut exists. It has the nice side      effect of allowing full unicode output to the console.       Note that this shortcut is not used when the output is redirected, as in      that case the data is put on the pipe/file after the first conversion to      ansi. In this case the most expensive conversion is already avoided.    */
if|if
condition|(
operator|(
name|stream
operator|==
name|stdout
operator|&&
name|shortcut_stdout_to_console
operator|)
operator|||
operator|(
name|stream
operator|==
name|stderr
operator|&&
name|shortcut_stderr_to_console
operator|)
condition|)
block|{
name|WCHAR
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Flush existing output */
name|SVN_ERR
argument_list|(
name|svn_utf__win32_utf8_to_utf16
argument_list|(
operator|&
name|result
argument_list|,
name|string
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cputws
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|apr_get_os_error
argument_list|()
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Write error"
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
endif|#
directive|endif
name|err
operator|=
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|out
argument_list|,
name|string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|out
operator|=
name|svn_cmdline_cstring_from_utf8_fuzzy
argument_list|(
name|string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* On POSIX systems, errno will be set on an error in fputs, but this might      not be the case on other platforms.  We reset errno and only      use it if it was set by the below fputs call.  Else, we just return      a generic error. */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|out
argument_list|,
name|stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|apr_get_os_error
argument_list|()
condition|)
comment|/* is errno on POSIX */
block|{
comment|/* ### Issue #3014: Return a specific error for broken pipes,            * ### with a single element in the error chain. */
if|if
condition|(
name|SVN__APR_STATUS_IS_EPIPE
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_PIPE_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Write error"
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_fflush
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
comment|/* See comment in svn_cmdline_fputs about use of errno and stdio. */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|apr_get_os_error
argument_list|()
condition|)
comment|/* is errno on POSIX */
block|{
comment|/* ### Issue #3014: Return a specific error for broken pipes,            * ### with a single element in the error chain. */
if|if
condition|(
name|SVN__APR_STATUS_IS_EPIPE
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_PIPE_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Write error"
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cmdline_output_encoding
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CMDLINE_USE_CUSTOM_ENCODING
if|if
condition|(
name|output_encoding
condition|)
return|return
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|output_encoding
argument_list|)
return|;
endif|#
directive|endif
return|return
name|SVN_APR_LOCALE_CHARSET
return|;
block|}
end_function

begin_function
name|int
name|svn_cmdline_handle_exit_error
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
comment|/* Issue #3014:    * Don't print anything on broken pipes. The pipe was likely    * closed by the process at the other end. We expect that    * process to perform error reporting as necessary.    *    * ### This assumes that there is only one error in a chain for    * ### SVN_ERR_IO_PIPE_WRITE_ERROR. See svn_cmdline_fputs(). */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_IO_PIPE_WRITE_ERROR
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
condition|)
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
end_function

begin_struct
struct|struct
name|trust_server_cert_non_interactive_baton
block|{
name|svn_boolean_t
name|trust_server_cert_unknown_ca
decl_stmt|;
name|svn_boolean_t
name|trust_server_cert_cn_mismatch
decl_stmt|;
name|svn_boolean_t
name|trust_server_cert_expired
decl_stmt|;
name|svn_boolean_t
name|trust_server_cert_not_yet_valid
decl_stmt|;
name|svn_boolean_t
name|trust_server_cert_other_failure
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This implements 'svn_auth_ssl_server_trust_prompt_func_t'.     Don't actually prompt.  Instead, set *CRED_P to valid credentials    iff FAILURES is empty or may be accepted according to the flags    in BATON. If there are any other failure bits, then set *CRED_P    to null (that is, reject the cert).     Ignore MAY_SAVE; we don't save certs we never prompted for.     Ignore REALM and CERT_INFO,     Ignore any further films by George Lucas. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|trust_server_cert_non_interactive
parameter_list|(
name|svn_auth_cred_ssl_server_trust_t
modifier|*
modifier|*
name|cred_p
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_uint32_t
name|failures
parameter_list|,
specifier|const
name|svn_auth_ssl_server_cert_info_t
modifier|*
name|cert_info
parameter_list|,
name|svn_boolean_t
name|may_save
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|trust_server_cert_non_interactive_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_uint32_t
name|non_ignored_failures
decl_stmt|;
operator|*
name|cred_p
operator|=
name|NULL
expr_stmt|;
comment|/* Mask away bits we are instructed to ignore. */
name|non_ignored_failures
operator|=
name|failures
operator|&
operator|~
operator|(
operator|(
name|b
operator|->
name|trust_server_cert_unknown_ca
condition|?
name|SVN_AUTH_SSL_UNKNOWNCA
else|:
literal|0
operator|)
operator||
operator|(
name|b
operator|->
name|trust_server_cert_cn_mismatch
condition|?
name|SVN_AUTH_SSL_CNMISMATCH
else|:
literal|0
operator|)
operator||
operator|(
name|b
operator|->
name|trust_server_cert_expired
condition|?
name|SVN_AUTH_SSL_EXPIRED
else|:
literal|0
operator|)
operator||
operator|(
name|b
operator|->
name|trust_server_cert_not_yet_valid
condition|?
name|SVN_AUTH_SSL_NOTYETVALID
else|:
literal|0
operator|)
operator||
operator|(
name|b
operator|->
name|trust_server_cert_other_failure
condition|?
name|SVN_AUTH_SSL_OTHER
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* If no failures remain, accept the certificate. */
if|if
condition|(
name|non_ignored_failures
operator|==
literal|0
condition|)
block|{
operator|*
name|cred_p
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|cred_p
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cred_p
operator|)
operator|->
name|may_save
operator|=
name|FALSE
expr_stmt|;
operator|(
operator|*
name|cred_p
operator|)
operator|->
name|accepted_failures
operator|=
name|failures
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_create_auth_baton2
parameter_list|(
name|svn_auth_baton_t
modifier|*
modifier|*
name|ab
parameter_list|,
name|svn_boolean_t
name|non_interactive
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_username
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_password
parameter_list|,
specifier|const
name|char
modifier|*
name|config_dir
parameter_list|,
name|svn_boolean_t
name|no_auth_cache
parameter_list|,
name|svn_boolean_t
name|trust_server_cert_unknown_ca
parameter_list|,
name|svn_boolean_t
name|trust_server_cert_cn_mismatch
parameter_list|,
name|svn_boolean_t
name|trust_server_cert_expired
parameter_list|,
name|svn_boolean_t
name|trust_server_cert_not_yet_valid
parameter_list|,
name|svn_boolean_t
name|trust_server_cert_other_failure
parameter_list|,
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|store_password_val
init|=
name|TRUE
decl_stmt|;
name|svn_boolean_t
name|store_auth_creds_val
init|=
name|TRUE
decl_stmt|;
name|svn_auth_provider_object_t
modifier|*
name|provider
decl_stmt|;
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
init|=
name|NULL
decl_stmt|;
comment|/* The whole list of registered providers */
name|apr_array_header_t
modifier|*
name|providers
decl_stmt|;
comment|/* Populate the registered providers with the platform-specific providers */
name|SVN_ERR
argument_list|(
name|svn_auth_get_platform_specific_client_providers
argument_list|(
operator|&
name|providers
argument_list|,
name|cfg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a cancellation function, cram it and the stuff it      needs into the prompt baton. */
if|if
condition|(
name|cancel_func
condition|)
block|{
name|pb
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pb
argument_list|)
argument_list|)
expr_stmt|;
name|pb
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|pb
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|pb
operator|->
name|config_dir
operator|=
name|config_dir
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|non_interactive
condition|)
block|{
comment|/* This provider doesn't prompt the user in order to get creds;          it prompts the user regarding the caching of creds. */
name|svn_auth_get_simple_provider2
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_plaintext_prompt
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_auth_get_simple_provider2
argument_list|(
operator|&
name|provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_username_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_ssl_server_trust_file_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_ssl_client_cert_file_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
if|if
condition|(
operator|!
name|non_interactive
condition|)
block|{
comment|/* This provider doesn't prompt the user in order to get creds;          it prompts the user regarding the caching of creds. */
name|svn_auth_get_ssl_client_cert_pw_file_provider2
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_plaintext_passphrase_prompt
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_auth_get_ssl_client_cert_pw_file_provider2
argument_list|(
operator|&
name|provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
if|if
condition|(
operator|!
name|non_interactive
condition|)
block|{
name|svn_boolean_t
name|ssl_client_cert_file_prompt
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|ssl_client_cert_file_prompt
argument_list|,
name|SVN_CONFIG_SECTION_AUTH
argument_list|,
name|SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE_PROMPT
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Two basic prompt providers: username/password, and just username. */
name|svn_auth_get_simple_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_simple_prompt
argument_list|,
name|pb
argument_list|,
literal|2
argument_list|,
comment|/* retry limit */
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_username_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_username_prompt
argument_list|,
name|pb
argument_list|,
literal|2
argument_list|,
comment|/* retry limit */
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
comment|/* SSL prompt providers: server-certs and client-cert-passphrases.  */
name|svn_auth_get_ssl_server_trust_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_ssl_server_trust_prompt
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
name|svn_auth_get_ssl_client_cert_pw_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_ssl_client_cert_pw_prompt
argument_list|,
name|pb
argument_list|,
literal|2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
comment|/* If configuration allows, add a provider for client-cert path          prompting, too. */
if|if
condition|(
name|ssl_client_cert_file_prompt
condition|)
block|{
name|svn_auth_get_ssl_client_cert_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|svn_cmdline_auth_ssl_client_cert_prompt
argument_list|,
name|pb
argument_list|,
literal|2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|trust_server_cert_unknown_ca
operator|||
name|trust_server_cert_cn_mismatch
operator|||
name|trust_server_cert_expired
operator|||
name|trust_server_cert_not_yet_valid
operator|||
name|trust_server_cert_other_failure
condition|)
block|{
name|struct
name|trust_server_cert_non_interactive_baton
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|trust_server_cert_unknown_ca
operator|=
name|trust_server_cert_unknown_ca
expr_stmt|;
name|b
operator|->
name|trust_server_cert_cn_mismatch
operator|=
name|trust_server_cert_cn_mismatch
expr_stmt|;
name|b
operator|->
name|trust_server_cert_expired
operator|=
name|trust_server_cert_expired
expr_stmt|;
name|b
operator|->
name|trust_server_cert_not_yet_valid
operator|=
name|trust_server_cert_not_yet_valid
expr_stmt|;
name|b
operator|->
name|trust_server_cert_other_failure
operator|=
name|trust_server_cert_other_failure
expr_stmt|;
comment|/* Remember, only register this provider if non_interactive. */
name|svn_auth_get_ssl_server_trust_prompt_provider
argument_list|(
operator|&
name|provider
argument_list|,
name|trust_server_cert_non_interactive
argument_list|,
name|b
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|providers
argument_list|,
name|svn_auth_provider_object_t
operator|*
argument_list|)
operator|=
name|provider
expr_stmt|;
block|}
comment|/* Build an authentication baton to give to libsvn_client. */
name|svn_auth_open
argument_list|(
name|ab
argument_list|,
name|providers
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Place any default --username or --password credentials into the      auth_baton's run-time parameter hash. */
if|if
condition|(
name|auth_username
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_DEFAULT_USERNAME
argument_list|,
name|auth_username
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_password
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_DEFAULT_PASSWORD
argument_list|,
name|auth_password
argument_list|)
expr_stmt|;
comment|/* Same with the --non-interactive option. */
if|if
condition|(
name|non_interactive
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_NON_INTERACTIVE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_dir
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_CONFIG_DIR
argument_list|,
name|config_dir
argument_list|)
expr_stmt|;
comment|/* Determine whether storing passwords in any form is allowed.    * This is the deprecated location for this option, the new    * location is SVN_CONFIG_CATEGORY_SERVERS. The RA layer may    * override the value we set here. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|store_password_val
argument_list|,
name|SVN_CONFIG_SECTION_AUTH
argument_list|,
name|SVN_CONFIG_OPTION_STORE_PASSWORDS
argument_list|,
name|SVN_CONFIG_DEFAULT_OPTION_STORE_PASSWORDS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|store_password_val
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_DONT_STORE_PASSWORDS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Determine whether we are allowed to write to the auth/ area.    * This is the deprecated location for this option, the new    * location is SVN_CONFIG_CATEGORY_SERVERS. The RA layer may    * override the value we set here. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|store_auth_creds_val
argument_list|,
name|SVN_CONFIG_SECTION_AUTH
argument_list|,
name|SVN_CONFIG_OPTION_STORE_AUTH_CREDS
argument_list|,
name|SVN_CONFIG_DEFAULT_OPTION_STORE_AUTH_CREDS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_auth_cache
operator|||
operator|!
name|store_auth_creds_val
condition|)
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_NO_AUTH_CACHE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_HAVE_GNOME_KEYRING
name|svn_auth_set_parameter
argument_list|(
operator|*
name|ab
argument_list|,
name|SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_FUNC
argument_list|,
operator|&
name|svn_cmdline__auth_gnome_keyring_unlock_prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SVN_HAVE_GNOME_KEYRING */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__getopt_init
parameter_list|(
name|apr_getopt_t
modifier|*
modifier|*
name|os
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
init|=
name|apr_getopt_init
argument_list|(
name|os
argument_list|,
name|pool
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error initializing command line arguments"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_cmdline__print_xml_prop
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|svn_string_t
modifier|*
name|propval
parameter_list|,
name|svn_boolean_t
name|inherited_prop
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|xml_safe
decl_stmt|;
specifier|const
name|char
modifier|*
name|encoding
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|outstr
operator|==
name|NULL
condition|)
operator|*
name|outstr
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_xml_is_xml_safe
argument_list|(
name|propval
operator|->
name|data
argument_list|,
name|propval
operator|->
name|len
argument_list|)
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|xml_esc
init|=
name|NULL
decl_stmt|;
name|svn_xml_escape_cdata_string
argument_list|(
operator|&
name|xml_esc
argument_list|,
name|propval
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|xml_safe
operator|=
name|xml_esc
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|svn_string_t
modifier|*
name|base64ed
init|=
name|svn_base64_encode_string2
argument_list|(
name|propval
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|encoding
operator|=
literal|"base64"
expr_stmt|;
name|xml_safe
operator|=
name|base64ed
operator|->
name|data
expr_stmt|;
block|}
if|if
condition|(
name|encoding
condition|)
name|svn_xml_make_open_tag
argument_list|(
name|outstr
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
name|inherited_prop
condition|?
literal|"inherited_property"
else|:
literal|"property"
argument_list|,
literal|"name"
argument_list|,
name|propname
argument_list|,
literal|"encoding"
argument_list|,
name|encoding
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
else|else
name|svn_xml_make_open_tag
argument_list|(
name|outstr
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
name|inherited_prop
condition|?
literal|"inherited_property"
else|:
literal|"property"
argument_list|,
literal|"name"
argument_list|,
name|propname
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|outstr
argument_list|,
name|xml_safe
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
name|outstr
argument_list|,
name|pool
argument_list|,
name|inherited_prop
condition|?
literal|"inherited_property"
else|:
literal|"property"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Return the most similar string to NEEDLE in HAYSTACK, which contains  * HAYSTACK_LEN elements.  Return NULL if no string is sufficiently similar.  */
end_comment

begin_comment
comment|/* See svn_cl__similarity_check() for a more general solution. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|most_similar
parameter_list|(
specifier|const
name|char
modifier|*
name|needle_cstr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|haystack
parameter_list|,
name|apr_size_t
name|haystack_len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|max_similar
decl_stmt|;
name|apr_size_t
name|max_score
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|svn_membuf_t
name|membuf
decl_stmt|;
name|svn_string_t
modifier|*
name|needle_str
init|=
name|svn_string_create
argument_list|(
name|needle_cstr
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_membuf__create
argument_list|(
operator|&
name|membuf
argument_list|,
literal|64
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|haystack_len
condition|;
name|i
operator|++
control|)
block|{
name|apr_size_t
name|score
decl_stmt|;
name|svn_string_t
modifier|*
name|hay
init|=
name|svn_string_create
argument_list|(
name|haystack
index|[
name|i
index|]
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|score
operator|=
name|svn_string__similarity
argument_list|(
name|needle_str
argument_list|,
name|hay
argument_list|,
operator|&
name|membuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If you update this factor, consider updating        * svn_cl__similarity_check(). */
if|if
condition|(
name|score
operator|>=
operator|(
literal|2
operator|*
name|SVN_STRING__SIM_RANGE_MAX
operator|+
literal|1
operator|)
operator|/
literal|3
operator|&&
name|score
operator|>
name|max_score
condition|)
block|{
name|max_score
operator|=
name|score
expr_stmt|;
name|max_similar
operator|=
name|haystack
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|max_score
condition|)
return|return
name|max_similar
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Verify that NEEDLE is in HAYSTACK, which contains HAYSTACK_LEN elements. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|string_in_array
parameter_list|(
specifier|const
name|char
modifier|*
name|needle
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|haystack
parameter_list|,
name|apr_size_t
name|haystack_len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|next_of_kin
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|haystack_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|needle
argument_list|,
name|haystack
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Error. */
name|next_of_kin
operator|=
name|most_similar
argument_list|(
name|needle
argument_list|,
name|haystack
argument_list|,
name|haystack_len
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_of_kin
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Ignoring unknown value '%s'; "
literal|"did you mean '%s'?"
argument_list|)
argument_list|,
name|needle
argument_list|,
name|next_of_kin
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Ignoring unknown value '%s'"
argument_list|)
argument_list|,
name|needle
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"config_keys.inc"
end_include

begin_comment
comment|/* Validate the FILE, SECTION, and OPTION components of CONFIG_OPTION are  * known.  Warn to stderr if not.  (An unknown value may be either a typo  * or added in a newer minor version of Subversion.) */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|validate_config_option
parameter_list|(
name|svn_cmdline__config_argument_t
modifier|*
name|config_option
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|arbitrary_keys
init|=
name|FALSE
decl_stmt|;
comment|/* TODO: some day, we could also verify that OPTION is valid for SECTION;      i.e., forbid invalid combinations such as config:auth:diff-extensions. */
define|#
directive|define
name|ARRAYLEN
parameter_list|(
name|x
parameter_list|)
value|( sizeof((x)) / sizeof((x)[0]) )
name|SVN_ERR
argument_list|(
name|string_in_array
argument_list|(
name|config_option
operator|->
name|file
argument_list|,
name|svn__valid_config_files
argument_list|,
name|ARRAYLEN
argument_list|(
name|svn__valid_config_files
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|string_in_array
argument_list|(
name|config_option
operator|->
name|section
argument_list|,
name|svn__valid_config_sections
argument_list|,
name|ARRAYLEN
argument_list|(
name|svn__valid_config_sections
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't validate option names for sections such as servers[group],    * config[tunnels], and config[auto-props] that permit arbitrary options. */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAYLEN
argument_list|(
name|svn__empty_config_sections
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|config_option
operator|->
name|section
argument_list|,
name|svn__empty_config_sections
index|[
name|i
index|]
argument_list|)
condition|)
name|arbitrary_keys
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|arbitrary_keys
condition|)
name|SVN_ERR
argument_list|(
name|string_in_array
argument_list|(
name|config_option
operator|->
name|option
argument_list|,
name|svn__valid_config_options
argument_list|,
name|ARRAYLEN
argument_list|(
name|svn__valid_config_options
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ARRAYLEN
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__parse_config_option
parameter_list|(
name|apr_array_header_t
modifier|*
name|config_options
parameter_list|,
specifier|const
name|char
modifier|*
name|opt_arg
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cmdline__config_argument_t
modifier|*
name|config_option
decl_stmt|;
specifier|const
name|char
modifier|*
name|first_colon
decl_stmt|,
modifier|*
name|second_colon
decl_stmt|,
modifier|*
name|equals_sign
decl_stmt|;
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|opt_arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|first_colon
operator|=
name|strchr
argument_list|(
name|opt_arg
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
name|first_colon
operator|!=
name|opt_arg
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|second_colon
operator|=
name|strchr
argument_list|(
name|first_colon
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
name|second_colon
operator|!=
name|first_colon
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|equals_sign
operator|=
name|strchr
argument_list|(
name|second_colon
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
operator|)
operator|&&
operator|(
name|equals_sign
operator|!=
name|second_colon
operator|+
literal|1
operator|)
condition|)
block|{
name|svn_error_t
modifier|*
name|warning
decl_stmt|;
name|config_option
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config_option
argument_list|)
argument_list|)
expr_stmt|;
name|config_option
operator|->
name|file
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|opt_arg
argument_list|,
name|first_colon
operator|-
name|opt_arg
argument_list|)
expr_stmt|;
name|config_option
operator|->
name|section
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|first_colon
operator|+
literal|1
argument_list|,
name|second_colon
operator|-
name|first_colon
operator|-
literal|1
argument_list|)
expr_stmt|;
name|config_option
operator|->
name|option
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|second_colon
operator|+
literal|1
argument_list|,
name|equals_sign
operator|-
name|second_colon
operator|-
literal|1
argument_list|)
expr_stmt|;
name|warning
operator|=
name|validate_config_option
argument_list|(
name|config_option
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning
condition|)
block|{
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|warning
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|warning
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|strchr
argument_list|(
name|config_option
operator|->
name|option
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
name|config_option
operator|->
name|value
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|equals_sign
operator|+
literal|1
argument_list|,
name|opt_arg
operator|+
name|len
operator|-
name|equals_sign
operator|-
literal|1
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|config_options
argument_list|,
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
operator|=
name|config_option
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
block|}
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid syntax of argument of --config-option"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__apply_config_options
parameter_list|(
name|apr_hash_t
modifier|*
name|config
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|config_options
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|argument_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config_options
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
name|svn_cmdline__config_argument_t
modifier|*
name|arg
init|=
name|APR_ARRAY_IDX
argument_list|(
name|config_options
argument_list|,
name|i
argument_list|,
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
decl_stmt|;
name|cfg
operator|=
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|arg
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
block|{
name|svn_config_set
argument_list|(
name|cfg
argument_list|,
name|arg
operator|->
name|section
argument_list|,
name|arg
operator|->
name|option
argument_list|,
name|arg
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unrecognized file in argument of %s"
argument_list|)
argument_list|,
name|argument_name
argument_list|)
decl_stmt|;
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a copy, allocated in POOL, of the next line of text from *STR  * up to and including a CR and/or an LF. Change *STR to point to the  * remainder of the string after the returned part. If there are no  * characters to be returned, return NULL; never return an empty string.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|next_line
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
comment|/* n.b. Throughout this fn, we never read any character after a '\0'. */
comment|/* Skip over all non-EOL characters, if any. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\r'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip over \r\n or \n\r or \r or \n, if any. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|&&
operator|*
name|p
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|&&
operator|*
name|p
operator|==
literal|'\r'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* Now p points after at most one '\n' and/or '\r'. */
operator|*
name|str
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|start
condition|)
return|return
name|NULL
return|;
return|return
name|svn_string_ncreate
argument_list|(
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|,
name|pool
argument_list|)
operator|->
name|data
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cmdline__indent_string
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|out
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|next_line
argument_list|(
operator|&
name|str
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|out
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|out
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
return|return
name|out
operator|->
name|data
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__print_prop_hash
parameter_list|(
name|svn_stream_t
modifier|*
name|out
parameter_list|,
name|apr_hash_t
modifier|*
name|prop_hash
parameter_list|,
name|svn_boolean_t
name|names_only
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_props
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sorted_props
operator|=
name|svn_sort__hash
argument_list|(
name|prop_hash
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_props
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname
init|=
name|item
operator|.
name|key
decl_stmt|;
name|svn_string_t
modifier|*
name|propval
init|=
name|item
operator|.
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname_stdout
decl_stmt|;
if|if
condition|(
name|svn_prop_needs_translation
argument_list|(
name|pname
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_subst_detranslate_string
argument_list|(
operator|&
name|propval
argument_list|,
name|propval
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|pname_stdout
argument_list|,
name|pname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|pname_stdout
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"  %s\n"
argument_list|,
name|pname_stdout
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|pname_stdout
argument_list|,
operator|&
name|pname_stdout
argument_list|,
name|APR_EOL_STR
argument_list|,
comment|/* 'native' eol */
name|FALSE
argument_list|,
comment|/* no repair */
name|NULL
argument_list|,
comment|/* no keywords */
name|FALSE
argument_list|,
comment|/* no expansion */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|out
argument_list|,
name|pname_stdout
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ### We leave these printfs for now, since if propval wasn't              translated above, we don't know anything about its encoding.              In fact, it might be binary data... */
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|pname_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|names_only
condition|)
block|{
comment|/* Add an extra newline to the value before indenting, so that            * every line of output has the indentation whether the value            * already ended in a newline or not. */
specifier|const
name|char
modifier|*
name|newval
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|propval
operator|->
name|data
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|indented_newval
init|=
name|svn_cmdline__indent_string
argument_list|(
name|newval
argument_list|,
literal|"    "
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|out
argument_list|,
name|indented_newval
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|indented_newval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__print_xml_prop_hash
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|outstr
parameter_list|,
name|apr_hash_t
modifier|*
name|prop_hash
parameter_list|,
name|svn_boolean_t
name|names_only
parameter_list|,
name|svn_boolean_t
name|inherited_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_props
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|outstr
operator|==
name|NULL
condition|)
operator|*
name|outstr
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|sorted_props
operator|=
name|svn_sort__hash
argument_list|(
name|prop_hash
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_props
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname
init|=
name|item
operator|.
name|key
decl_stmt|;
name|svn_string_t
modifier|*
name|propval
init|=
name|item
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|names_only
condition|)
block|{
name|svn_xml_make_open_tag
argument_list|(
name|outstr
argument_list|,
name|pool
argument_list|,
name|svn_xml_self_closing
argument_list|,
name|inherited_props
condition|?
literal|"inherited_property"
else|:
literal|"property"
argument_list|,
literal|"name"
argument_list|,
name|pname
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|pname_out
decl_stmt|;
if|if
condition|(
name|svn_prop_needs_translation
argument_list|(
name|pname
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_subst_detranslate_string
argument_list|(
operator|&
name|propval
argument_list|,
name|propval
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|pname_out
argument_list|,
name|pname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_cmdline__print_xml_prop
argument_list|(
name|outstr
argument_list|,
name|pname_out
argument_list|,
name|propval
argument_list|,
name|inherited_props
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_cmdline__be_interactive
parameter_list|(
name|svn_boolean_t
name|non_interactive
parameter_list|,
name|svn_boolean_t
name|force_interactive
parameter_list|)
block|{
comment|/* If neither --non-interactive nor --force-interactive was passed,    * be interactive if stdin is a terminal.    * If --force-interactive was passed, always be interactive. */
if|if
condition|(
operator|!
name|force_interactive
operator|&&
operator|!
name|non_interactive
condition|)
block|{
ifdef|#
directive|ifdef
name|WIN32
return|return
operator|(
name|_isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|!=
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|!=
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|force_interactive
condition|)
return|return
name|TRUE
return|;
return|return
operator|!
name|non_interactive
return|;
block|}
end_function

begin_comment
comment|/* Helper for the next two functions.  Set *EDITOR to some path to an    editor binary.  Sources to search include: the EDITOR_CMD argument    (if not NULL), $SVN_EDITOR, the runtime CONFIG variable (if CONFIG    is not NULL), $VISUAL, $EDITOR.  Return    SVN_ERR_CL_NO_EXTERNAL_EDITOR if no binary can be found. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_editor_binary
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|editor
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|e
decl_stmt|;
name|struct
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
comment|/* Use the editor specified on the command line via --editor-cmd, if any. */
name|e
operator|=
name|editor_cmd
expr_stmt|;
comment|/* Otherwise look for the Subversion-specific environment variable. */
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|getenv
argument_list|(
literal|"SVN_EDITOR"
argument_list|)
expr_stmt|;
comment|/* If not found then fall back on the config file. */
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|cfg
operator|=
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|e
argument_list|,
name|SVN_CONFIG_SECTION_HELPERS
argument_list|,
name|SVN_CONFIG_OPTION_EDITOR_CMD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* If not found yet then try general purpose environment variables. */
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|getenv
argument_list|(
literal|"VISUAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_CLIENT_EDITOR
comment|/* If still not found then fall back on the hard-coded default. */
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|SVN_CLIENT_EDITOR
expr_stmt|;
endif|#
directive|endif
comment|/* Error if there is no editor specified */
if|if
condition|(
name|e
condition|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|e
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|svn_ctype_isspace
argument_list|(
operator|*
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|c
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_NO_EXTERNAL_EDITOR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The EDITOR, SVN_EDITOR or VISUAL environment variable or "
literal|"'editor-cmd' run-time configuration option is empty or "
literal|"consists solely of whitespace. Expected a shell command."
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_NO_EXTERNAL_EDITOR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"None of the environment variables SVN_EDITOR, VISUAL or EDITOR are "
literal|"set, and no 'editor-cmd' run-time configuration option was found"
argument_list|)
argument_list|)
return|;
operator|*
name|editor
operator|=
name|e
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__edit_file_externally
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|editor
decl_stmt|,
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|base_dir
decl_stmt|,
modifier|*
name|file_name
decl_stmt|,
modifier|*
name|base_dir_apr
decl_stmt|;
name|char
modifier|*
name|old_cwd
decl_stmt|;
name|int
name|sys_err
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|base_dir
argument_list|,
operator|&
name|file_name
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_editor_binary
argument_list|(
operator|&
name|editor
argument_list|,
name|editor_cmd
argument_list|,
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_get
argument_list|(
operator|&
name|old_cwd
argument_list|,
name|APR_FILEPATH_NATIVE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get working directory"
argument_list|)
argument_list|)
return|;
comment|/* APR doesn't like "" directories */
if|if
condition|(
name|base_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|base_dir_apr
operator|=
literal|"."
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|base_dir_apr
argument_list|,
name|base_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|base_dir_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't change working directory to '%s'"
argument_list|)
argument_list|,
name|base_dir
argument_list|)
return|;
name|cmd
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s %s"
argument_list|,
name|editor
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|sys_err
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|old_cwd
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
name|svn_handle_error2
argument_list|(
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't restore working directory"
argument_list|)
argument_list|)
argument_list|,
name|stderr
argument_list|,
name|TRUE
comment|/* fatal */
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_err
condition|)
comment|/* Extracting any meaning from sys_err is platform specific, so just        use the raw value. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"system('%s') returned %d"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|sys_err
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__edit_string_externally
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|edited_contents
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmpfile_left
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
specifier|const
name|char
modifier|*
name|base_dir
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|contents
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|svn_boolean_t
name|as_text
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|editor
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|apr_file_t
modifier|*
name|tmp_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpfile_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpfile_native
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpfile_apr
decl_stmt|,
modifier|*
name|base_dir_apr
decl_stmt|;
name|svn_string_t
modifier|*
name|translated_contents
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|,
name|apr_err2
decl_stmt|;
name|apr_size_t
name|written
decl_stmt|;
name|apr_finfo_t
name|finfo_before
decl_stmt|,
name|finfo_after
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|,
modifier|*
name|err2
decl_stmt|;
name|char
modifier|*
name|old_cwd
decl_stmt|;
name|int
name|sys_err
decl_stmt|;
name|svn_boolean_t
name|remove_file
init|=
name|TRUE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|find_editor_binary
argument_list|(
operator|&
name|editor
argument_list|,
name|editor_cmd
argument_list|,
name|config
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert file contents from UTF-8/LF if desired. */
if|if
condition|(
name|as_text
condition|)
block|{
specifier|const
name|char
modifier|*
name|translated
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|contents
operator|->
name|data
argument_list|,
operator|&
name|translated
argument_list|,
name|APR_EOL_STR
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|translated_contents
operator|=
name|svn_string_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
condition|)
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
operator|&
name|translated_contents
operator|->
name|data
argument_list|,
name|translated
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|translated_contents
operator|->
name|data
argument_list|,
name|translated
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|translated_contents
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|translated_contents
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
else|else
name|translated_contents
operator|=
name|svn_string_dup
argument_list|(
name|contents
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Move to BASE_DIR to avoid getting characters that need quoting      into tmpfile_name */
name|apr_err
operator|=
name|apr_filepath_get
argument_list|(
operator|&
name|old_cwd
argument_list|,
name|APR_FILEPATH_NATIVE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get working directory"
argument_list|)
argument_list|)
return|;
comment|/* APR doesn't like "" directories */
if|if
condition|(
name|base_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|base_dir_apr
operator|=
literal|"."
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|base_dir_apr
argument_list|,
name|base_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|base_dir_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't change working directory to '%s'"
argument_list|)
argument_list|,
name|base_dir
argument_list|)
return|;
block|}
comment|/*** From here on, any problems that occur require us to cd back!! ***/
comment|/* Ask the working copy for a temporary file named FILENAME-something. */
name|err
operator|=
name|svn_io_open_uniquely_named
argument_list|(
operator|&
name|tmp_file
argument_list|,
operator|&
name|tmpfile_name
argument_list|,
literal|""
comment|/* dirpath */
argument_list|,
name|filename
argument_list|,
literal|".tmp"
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_EACCES
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|err
operator|->
name|apr_err
operator|==
name|EROFS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|temp_dir_apr
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_temp_dir
argument_list|(
operator|&
name|base_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|temp_dir_apr
argument_list|,
name|base_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|temp_dir_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't change working directory to '%s'"
argument_list|)
argument_list|,
name|base_dir
argument_list|)
return|;
block|}
name|err
operator|=
name|svn_io_open_uniquely_named
argument_list|(
operator|&
name|tmp_file
argument_list|,
operator|&
name|tmpfile_name
argument_list|,
literal|""
comment|/* dirpath */
argument_list|,
name|filename
argument_list|,
literal|".tmp"
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup2
goto|;
comment|/*** From here on, any problems that occur require us to cleanup        the file we just created!! ***/
comment|/* Dump initial CONTENTS to TMP_FILE. */
name|apr_err
operator|=
name|apr_file_write_full
argument_list|(
name|tmp_file
argument_list|,
name|translated_contents
operator|->
name|data
argument_list|,
name|translated_contents
operator|->
name|len
argument_list|,
operator|&
name|written
argument_list|)
expr_stmt|;
name|apr_err2
operator|=
name|apr_file_close
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apr_err
condition|)
name|apr_err
operator|=
name|apr_err2
expr_stmt|;
comment|/* Make sure the whole CONTENTS were written, else return an error. */
if|if
condition|(
name|apr_err
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't write to '%s'"
argument_list|)
argument_list|,
name|tmpfile_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|err
operator|=
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|tmpfile_apr
argument_list|,
name|tmpfile_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Get information about the temporary file before the user has      been allowed to edit its contents. */
name|apr_err
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo_before
argument_list|,
name|tmpfile_apr
argument_list|,
name|APR_FINFO_MTIME
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't stat '%s'"
argument_list|)
argument_list|,
name|tmpfile_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Backdate the file a little bit in case the editor is very fast      and doesn't change the size.  (Use two seconds, since some      filesystems have coarse granularity.)  It's OK if this call      fails, so we don't check its return value.*/
name|apr_file_mtime_set
argument_list|(
name|tmpfile_apr
argument_list|,
name|finfo_before
operator|.
name|mtime
operator|-
literal|2000
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Stat it again to get the mtime we actually set. */
name|apr_err
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo_before
argument_list|,
name|tmpfile_apr
argument_list|,
name|APR_FINFO_MTIME
operator||
name|APR_FINFO_SIZE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't stat '%s'"
argument_list|)
argument_list|,
name|tmpfile_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Prepare the editor command line.  */
name|err
operator|=
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|tmpfile_native
argument_list|,
name|tmpfile_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
name|cmd
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s %s"
argument_list|,
name|editor
argument_list|,
name|tmpfile_native
argument_list|)
expr_stmt|;
comment|/* If the caller wants us to leave the file around, return the path      of the file we'll use, and make a note not to destroy it.  */
if|if
condition|(
name|tmpfile_left
condition|)
block|{
operator|*
name|tmpfile_left
operator|=
name|svn_dirent_join
argument_list|(
name|base_dir
argument_list|,
name|tmpfile_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|remove_file
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Now, run the editor command line.  */
name|sys_err
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_err
operator|!=
literal|0
condition|)
block|{
comment|/* Extracting any meaning from sys_err is platform specific, so just          use the raw value. */
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"system('%s') returned %d"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|sys_err
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Get information about the temporary file after the assumed editing. */
name|apr_err
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo_after
argument_list|,
name|tmpfile_apr
argument_list|,
name|APR_FINFO_MTIME
operator||
name|APR_FINFO_SIZE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't stat '%s'"
argument_list|)
argument_list|,
name|tmpfile_name
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* If the file looks changed... */
if|if
condition|(
operator|(
name|finfo_before
operator|.
name|mtime
operator|!=
name|finfo_after
operator|.
name|mtime
operator|)
operator|||
operator|(
name|finfo_before
operator|.
name|size
operator|!=
name|finfo_after
operator|.
name|size
operator|)
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|edited_contents_s
decl_stmt|;
name|err
operator|=
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|edited_contents_s
argument_list|,
name|tmpfile_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
operator|*
name|edited_contents
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|edited_contents_s
argument_list|)
expr_stmt|;
comment|/* Translate back to UTF8/LF if desired. */
if|if
condition|(
name|as_text
condition|)
block|{
name|err
operator|=
name|svn_subst_translate_string2
argument_list|(
name|edited_contents
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|*
name|edited_contents
argument_list|,
name|encoding
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Error normalizing edited contents to internal format"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* No edits seem to have been made */
operator|*
name|edited_contents
operator|=
name|NULL
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|remove_file
condition|)
block|{
comment|/* Remove the file from disk.  */
name|err2
operator|=
name|svn_io_remove_file2
argument_list|(
name|tmpfile_name
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Only report remove error if there was no previous error. */
if|if
condition|(
operator|!
name|err
operator|&&
name|err2
condition|)
name|err
operator|=
name|err2
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|err2
argument_list|)
expr_stmt|;
block|}
name|cleanup2
label|:
comment|/* If we against all probability can't cd back, all further relative      file references would be screwed up, so we have to abort. */
name|apr_err
operator|=
name|apr_filepath_set
argument_list|(
name|old_cwd
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|svn_handle_error2
argument_list|(
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't restore working directory"
argument_list|)
argument_list|)
argument_list|,
name|stderr
argument_list|,
name|TRUE
comment|/* fatal */
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__parse_trust_options
parameter_list|(
name|svn_boolean_t
modifier|*
name|trust_server_cert_unknown_ca
parameter_list|,
name|svn_boolean_t
modifier|*
name|trust_server_cert_cn_mismatch
parameter_list|,
name|svn_boolean_t
modifier|*
name|trust_server_cert_expired
parameter_list|,
name|svn_boolean_t
modifier|*
name|trust_server_cert_not_yet_valid
parameter_list|,
name|svn_boolean_t
modifier|*
name|trust_server_cert_other_failure
parameter_list|,
specifier|const
name|char
modifier|*
name|opt_arg
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|failures
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|trust_server_cert_unknown_ca
operator|=
name|FALSE
expr_stmt|;
operator|*
name|trust_server_cert_cn_mismatch
operator|=
name|FALSE
expr_stmt|;
operator|*
name|trust_server_cert_expired
operator|=
name|FALSE
expr_stmt|;
operator|*
name|trust_server_cert_not_yet_valid
operator|=
name|FALSE
expr_stmt|;
operator|*
name|trust_server_cert_other_failure
operator|=
name|FALSE
expr_stmt|;
name|failures
operator|=
name|svn_cstring_split
argument_list|(
name|opt_arg
argument_list|,
literal|", \n\r\t\v"
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|failures
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|APR_ARRAY_IDX
argument_list|(
name|failures
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"unknown-ca"
argument_list|)
condition|)
operator|*
name|trust_server_cert_unknown_ca
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"cn-mismatch"
argument_list|)
condition|)
operator|*
name|trust_server_cert_cn_mismatch
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"expired"
argument_list|)
condition|)
operator|*
name|trust_server_cert_expired
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"not-yet-valid"
argument_list|)
condition|)
operator|*
name|trust_server_cert_not_yet_valid
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"other"
argument_list|)
condition|)
operator|*
name|trust_server_cert_other_failure
operator|=
name|TRUE
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown value '%s' for %s.\n"
literal|"Supported values: %s"
argument_list|)
argument_list|,
name|value
argument_list|,
literal|"--trust-server-cert-failures"
argument_list|,
literal|"unknown-ca, cn-mismatch, expired, "
literal|"not-yet-valid, other"
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

