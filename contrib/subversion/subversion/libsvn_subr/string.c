begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * string.c:  routines to manipulate counted-length strings  *            (svn_stringbuf_t and svn_string_t) and C strings.  *  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* for memcpy(), memcmp(), strlen() */
end_comment

begin_include
include|#
directive|include
file|<apr_fnmatch.h>
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_comment
comment|/* loads "svn_types.h" and<apr_pools.h> */
end_comment

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Allocate the space for a memory buffer from POOL.  * Return a pointer to the new buffer in *DATA and its size in *SIZE.  * The buffer size will be at least MINIMUM_SIZE.  *  * N.B.: The stringbuf creation functions use this, but since stringbufs  *       always consume at least 1 byte for the NUL terminator, the  *       resulting data pointers will never be NULL.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
name|membuf_create
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|size
parameter_list|,
name|apr_size_t
name|minimum_size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* apr_palloc will allocate multiples of 8.    * Thus, we would waste some of that memory if we stuck to the    * smaller size. Note that this is safe even if apr_palloc would    * use some other aligment or none at all. */
name|minimum_size
operator|=
name|APR_ALIGN_DEFAULT
argument_list|(
name|minimum_size
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
operator|(
operator|!
name|minimum_size
condition|?
name|NULL
else|:
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|minimum_size
argument_list|)
operator|)
expr_stmt|;
operator|*
name|size
operator|=
name|minimum_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ensure that the size of a given memory buffer is at least MINIMUM_SIZE  * bytes. If *SIZE is already greater than or equal to MINIMUM_SIZE,  * this function does nothing.  *  * If *SIZE is 0, the allocated buffer size will be MINIMUM_SIZE  * rounded up to the nearest APR alignment boundary. Otherwse, *SIZE  * will be multiplied by a power of two such that the result is  * greater or equal to MINIMUM_SIZE. The pointer to the new buffer  * will be returned in *DATA, and its size in *SIZE.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
name|membuf_ensure
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|size
parameter_list|,
name|apr_size_t
name|minimum_size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|minimum_size
operator|>
operator|*
name|size
condition|)
block|{
name|apr_size_t
name|new_size
init|=
operator|*
name|size
decl_stmt|;
if|if
condition|(
name|new_size
operator|==
literal|0
condition|)
comment|/* APR will increase odd allocation sizes to the next          * multiple for 8, for instance. Take advantage of that          * knowledge and allow for the extra size to be used. */
name|new_size
operator|=
name|minimum_size
expr_stmt|;
else|else
while|while
condition|(
name|new_size
operator|<
name|minimum_size
condition|)
block|{
comment|/* new_size is aligned; doubling it should keep it aligned */
specifier|const
name|apr_size_t
name|prev_size
init|=
name|new_size
decl_stmt|;
name|new_size
operator|*=
literal|2
expr_stmt|;
comment|/* check for apr_size_t overflow */
if|if
condition|(
name|prev_size
operator|>
name|new_size
condition|)
block|{
name|new_size
operator|=
name|minimum_size
expr_stmt|;
break|break;
block|}
block|}
name|membuf_create
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|new_size
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|svn_membuf__create
parameter_list|(
name|svn_membuf_t
modifier|*
name|membuf
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|membuf_create
argument_list|(
operator|&
name|membuf
operator|->
name|data
argument_list|,
operator|&
name|membuf
operator|->
name|size
argument_list|,
name|size
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|membuf
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_membuf__ensure
parameter_list|(
name|svn_membuf_t
modifier|*
name|membuf
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
name|membuf_ensure
argument_list|(
operator|&
name|membuf
operator|->
name|data
argument_list|,
operator|&
name|membuf
operator|->
name|size
argument_list|,
name|size
argument_list|,
name|membuf
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_membuf__resize
parameter_list|(
name|svn_membuf_t
modifier|*
name|membuf
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
specifier|const
name|void
modifier|*
specifier|const
name|old_data
init|=
name|membuf
operator|->
name|data
decl_stmt|;
specifier|const
name|apr_size_t
name|old_size
init|=
name|membuf
operator|->
name|size
decl_stmt|;
name|membuf_ensure
argument_list|(
operator|&
name|membuf
operator|->
name|data
argument_list|,
operator|&
name|membuf
operator|->
name|size
argument_list|,
name|size
argument_list|,
name|membuf
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|membuf
operator|->
name|data
operator|&&
name|old_data
operator|&&
name|old_data
operator|!=
name|membuf
operator|->
name|data
condition|)
name|memcpy
argument_list|(
name|membuf
operator|->
name|data
argument_list|,
name|old_data
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Always provide an out-of-line implementation of svn_membuf__zero */
end_comment

begin_undef
undef|#
directive|undef
name|svn_membuf__zero
end_undef

begin_function
name|void
name|svn_membuf__zero
parameter_list|(
name|svn_membuf_t
modifier|*
name|membuf
parameter_list|)
block|{
name|SVN_MEMBUF__ZERO
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Always provide an out-of-line implementation of svn_membuf__nzero */
end_comment

begin_undef
undef|#
directive|undef
name|svn_membuf__nzero
end_undef

begin_function
name|void
name|svn_membuf__nzero
parameter_list|(
name|svn_membuf_t
modifier|*
name|membuf
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
name|SVN_MEMBUF__NZERO
argument_list|(
name|membuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
name|svn_boolean_t
name|string_compare
parameter_list|(
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|,
name|apr_size_t
name|len1
parameter_list|,
name|apr_size_t
name|len2
parameter_list|)
block|{
comment|/* easy way out :)  */
if|if
condition|(
name|len1
operator|!=
name|len2
condition|)
return|return
name|FALSE
return|;
comment|/* now the strings must have identical lenghths */
if|if
condition|(
operator|(
name|memcmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|,
name|len1
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
name|apr_size_t
name|string_first_non_whitespace
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|svn_ctype_isspace
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
return|;
block|}
comment|/* if we get here, then the string must be entirely whitespace */
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
name|apr_size_t
name|find_char_backward
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
name|apr_size_t
name|i
init|=
name|len
decl_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|str
index|[
operator|--
name|i
index|]
operator|==
name|ch
condition|)
return|return
name|i
return|;
block|}
comment|/* char was not found, return len */
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* svn_string functions */
end_comment

begin_comment
comment|/* Return a new svn_string_t object, allocated in POOL, initialized with  * DATA and SIZE.  Do not copy the contents of DATA, just store the pointer.  * SIZE is the length in bytes of DATA, excluding the required NUL  * terminator. */
end_comment

begin_function
specifier|static
name|svn_string_t
modifier|*
name|create_string
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|new_string
decl_stmt|;
name|new_string
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_string
argument_list|)
argument_list|)
expr_stmt|;
name|new_string
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|new_string
operator|->
name|len
operator|=
name|size
expr_stmt|;
return|return
name|new_string
return|;
block|}
end_function

begin_comment
comment|/* A data buffer for a zero-length string (just a null terminator).  Many  * svn_string_t instances may share this same buffer. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|empty_buffer
index|[
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_string_t
modifier|*
name|svn_string_create_empty
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|new_string
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_string
argument_list|)
argument_list|)
decl_stmt|;
name|new_string
operator|->
name|data
operator|=
name|empty_buffer
expr_stmt|;
name|new_string
operator|->
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|new_string
return|;
block|}
end_function

begin_function
name|svn_string_t
modifier|*
name|svn_string_ncreate
parameter_list|(
specifier|const
name|char
modifier|*
name|bytes
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|svn_string_t
modifier|*
name|new_string
decl_stmt|;
comment|/* Allocate memory for svn_string_t and data in one chunk. */
name|mem
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_string
argument_list|)
operator|+
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|mem
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|new_string
argument_list|)
expr_stmt|;
name|new_string
operator|=
name|mem
expr_stmt|;
name|new_string
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|new_string
operator|->
name|len
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|bytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Null termination is the convention -- even if we suspect the data      to be binary, it's not up to us to decide, it's the caller's      call.  Heck, that's why they call it the caller! */
name|data
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|new_string
return|;
block|}
end_function

begin_function
name|svn_string_t
modifier|*
name|svn_string_create
parameter_list|(
specifier|const
name|char
modifier|*
name|cstring
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_string_ncreate
argument_list|(
name|cstring
argument_list|,
name|strlen
argument_list|(
name|cstring
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_string_t
modifier|*
name|svn_string_create_from_buf
parameter_list|(
specifier|const
name|svn_stringbuf_t
modifier|*
name|strbuf
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_string_ncreate
argument_list|(
name|strbuf
operator|->
name|data
argument_list|,
name|strbuf
operator|->
name|len
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_string_t
modifier|*
name|svn_string_createv
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|char
modifier|*
name|data
init|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
decl_stmt|;
comment|/* wrap an svn_string_t around the new data */
return|return
name|create_string
argument_list|(
name|data
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_string_t
modifier|*
name|svn_string_createf
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|str
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_string_createv
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_string_isempty
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str
parameter_list|)
block|{
return|return
operator|(
name|str
operator|->
name|len
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|svn_string_t
modifier|*
name|svn_string_dup
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|original_string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|svn_string_ncreate
argument_list|(
name|original_string
operator|->
name|data
argument_list|,
name|original_string
operator|->
name|len
argument_list|,
name|pool
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_string_compare
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str1
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|str2
parameter_list|)
block|{
return|return
name|string_compare
argument_list|(
name|str1
operator|->
name|data
argument_list|,
name|str2
operator|->
name|data
argument_list|,
name|str1
operator|->
name|len
argument_list|,
name|str2
operator|->
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_string_first_non_whitespace
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str
parameter_list|)
block|{
return|return
name|string_first_non_whitespace
argument_list|(
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_string_find_char_backward
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
return|return
name|find_char_backward
argument_list|(
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|,
name|ch
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_string_t
modifier|*
name|svn_stringbuf__morph_into_string
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|strbuf
parameter_list|)
block|{
comment|/* In debug mode, detect attempts to modify the original STRBUF object.    */
ifdef|#
directive|ifdef
name|SVN_DEBUG
name|strbuf
operator|->
name|pool
operator|=
name|NULL
expr_stmt|;
name|strbuf
operator|->
name|blocksize
operator|=
name|strbuf
operator|->
name|len
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Both, svn_string_t and svn_stringbuf_t are public API structures    * since the svn epoch. Thus, we can rely on their precise layout not    * to change.    *    * It just so happens that svn_string_t is structurally equivalent    * to the (data, len) sub-set of svn_stringbuf_t. There is also no    * difference in alignment and padding. So, we can just re-interpret    * that part of STRBUF as a svn_string_t.    *    * However, since svn_string_t does not know about the blocksize    * member in svn_stringbuf_t, any attempt to re-size the returned    * svn_string_t might invalidate the STRBUF struct. Hence, we consider    * the source STRBUF "consumed".    *    * Modifying the string character content is fine, though.    */
return|return
operator|(
name|svn_string_t
operator|*
operator|)
operator|&
name|strbuf
operator|->
name|data
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* svn_stringbuf functions */
end_comment

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_stringbuf_create_empty
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_stringbuf_create_ensure
argument_list|(
literal|0
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_stringbuf_create_ensure
parameter_list|(
name|apr_size_t
name|blocksize
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|new_string
decl_stmt|;
operator|++
name|blocksize
expr_stmt|;
comment|/* + space for '\0' */
comment|/* Allocate memory for svn_string_t and data in one chunk. */
name|membuf_create
argument_list|(
operator|&
name|mem
argument_list|,
operator|&
name|blocksize
argument_list|,
name|blocksize
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|new_string
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Initialize header and string */
name|new_string
operator|=
name|mem
expr_stmt|;
name|new_string
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|mem
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|new_string
argument_list|)
expr_stmt|;
name|new_string
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new_string
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|new_string
operator|->
name|blocksize
operator|=
name|blocksize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|new_string
argument_list|)
expr_stmt|;
name|new_string
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|new_string
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_stringbuf_ncreate
parameter_list|(
specifier|const
name|char
modifier|*
name|bytes
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|strbuf
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|size
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|strbuf
operator|->
name|data
argument_list|,
name|bytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Null termination is the convention -- even if we suspect the data      to be binary, it's not up to us to decide, it's the caller's      call.  Heck, that's why they call it the caller! */
name|strbuf
operator|->
name|data
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strbuf
operator|->
name|len
operator|=
name|size
expr_stmt|;
return|return
name|strbuf
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_stringbuf_create
parameter_list|(
specifier|const
name|char
modifier|*
name|cstring
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_stringbuf_ncreate
argument_list|(
name|cstring
argument_list|,
name|strlen
argument_list|(
name|cstring
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_stringbuf_create_from_string
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_stringbuf_ncreate
argument_list|(
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_stringbuf_createv
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|char
modifier|*
name|data
init|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|apr_size_t
name|size
init|=
name|strlen
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|new_string
decl_stmt|;
name|new_string
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_string
argument_list|)
argument_list|)
expr_stmt|;
name|new_string
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|new_string
operator|->
name|len
operator|=
name|size
expr_stmt|;
name|new_string
operator|->
name|blocksize
operator|=
name|size
operator|+
literal|1
expr_stmt|;
name|new_string
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|new_string
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_stringbuf_createf
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|str
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_stringbuf_createv
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
name|void
name|svn_stringbuf_fillchar
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|unsigned
name|char
name|c
parameter_list|)
block|{
name|memset
argument_list|(
name|str
operator|->
name|data
argument_list|,
name|c
argument_list|,
name|str
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stringbuf_set
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|apr_size_t
name|amt
init|=
name|strlen
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|svn_stringbuf_ensure
argument_list|(
name|str
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|->
name|data
argument_list|,
name|value
argument_list|,
name|amt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|str
operator|->
name|len
operator|=
name|amt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stringbuf_setempty
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|->
name|len
operator|>
literal|0
condition|)
name|str
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stringbuf_chop
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|nbytes
parameter_list|)
block|{
if|if
condition|(
name|nbytes
operator|>
name|str
operator|->
name|len
condition|)
name|str
operator|->
name|len
operator|=
literal|0
expr_stmt|;
else|else
name|str
operator|->
name|len
operator|-=
name|nbytes
expr_stmt|;
name|str
operator|->
name|data
index|[
name|str
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_stringbuf_isempty
parameter_list|(
specifier|const
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|)
block|{
return|return
operator|(
name|str
operator|->
name|len
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|svn_stringbuf_ensure
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|minimum_size
parameter_list|)
block|{
name|void
modifier|*
name|mem
init|=
name|NULL
decl_stmt|;
operator|++
name|minimum_size
expr_stmt|;
comment|/* + space for '\0' */
name|membuf_ensure
argument_list|(
operator|&
name|mem
argument_list|,
operator|&
name|str
operator|->
name|blocksize
argument_list|,
name|minimum_size
argument_list|,
name|str
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|&&
name|mem
operator|!=
name|str
operator|->
name|data
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|data
condition|)
name|memcpy
argument_list|(
name|mem
argument_list|,
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|str
operator|->
name|data
operator|=
name|mem
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* WARNING - Optimized code ahead!  * This function has been hand-tuned for performance. Please read  * the comments below before modifying the code.  */
end_comment

begin_function
name|void
name|svn_stringbuf_appendbyte
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|char
modifier|*
name|dest
decl_stmt|;
name|apr_size_t
name|old_len
init|=
name|str
operator|->
name|len
decl_stmt|;
comment|/* In most cases, there will be pre-allocated memory left    * to just write the new byte at the end of the used section    * and terminate the string properly.    */
if|if
condition|(
name|str
operator|->
name|blocksize
operator|>
name|old_len
operator|+
literal|1
condition|)
block|{
comment|/* The following read does not depend this write, so we        * can issue the write first to minimize register pressure:        * The value of old_len+1 is no longer needed; on most processors,        * dest[old_len+1] will be calculated implicitly as part of        * the addressing scheme.        */
name|str
operator|->
name|len
operator|=
name|old_len
operator|+
literal|1
expr_stmt|;
comment|/* Since the compiler cannot be sure that *src->data and *src        * don't overlap, we read src->data *once* before writing        * to *src->data. Replacing dest with str->data would force        * the compiler to read it again after the first byte.        */
name|dest
operator|=
name|str
operator|->
name|data
expr_stmt|;
comment|/* If not already available in a register as per ABI, load        * "byte" into the register (e.g. the one freed from old_len+1),        * then write it to the string buffer and terminate it properly.        *        * Including the "byte" fetch, all operations so far could be        * issued at once and be scheduled at the CPU's descression.        * Most likely, no-one will soon depend on the data that will be        * written in this function. So, no stalls there, either.        */
name|dest
index|[
name|old_len
index|]
operator|=
name|byte
expr_stmt|;
name|dest
index|[
name|old_len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* we need to re-allocate the string buffer        * -> let the more generic implementation take care of that part        */
comment|/* Depending on the ABI, "byte" is a register value. If we were        * to take its address directly, the compiler might decide to        * put in on the stack *unconditionally*, even if that would        * only be necessary for this block.        */
name|char
name|b
init|=
name|byte
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|svn_stringbuf_appendbytes
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|bytes
parameter_list|,
name|apr_size_t
name|count
parameter_list|)
block|{
name|apr_size_t
name|total_len
decl_stmt|;
name|void
modifier|*
name|start_address
decl_stmt|;
name|total_len
operator|=
name|str
operator|->
name|len
operator|+
name|count
expr_stmt|;
comment|/* total size needed */
comment|/* svn_stringbuf_ensure adds 1 for null terminator. */
name|svn_stringbuf_ensure
argument_list|(
name|str
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
comment|/* get address 1 byte beyond end of original bytestring */
name|start_address
operator|=
operator|(
name|str
operator|->
name|data
operator|+
name|str
operator|->
name|len
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|start_address
argument_list|,
name|bytes
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|str
operator|->
name|len
operator|=
name|total_len
expr_stmt|;
name|str
operator|->
name|data
index|[
name|str
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We don't know if this is binary                                   data or not, but convention is                                   to null-terminate. */
block|}
end_function

begin_function
name|void
name|svn_stringbuf_appendstr
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|targetstr
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|appendstr
parameter_list|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|targetstr
argument_list|,
name|appendstr
operator|->
name|data
argument_list|,
name|appendstr
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stringbuf_appendcstr
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|targetstr
parameter_list|,
specifier|const
name|char
modifier|*
name|cstr
parameter_list|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|targetstr
argument_list|,
name|cstr
argument_list|,
name|strlen
argument_list|(
name|cstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stringbuf_insert
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|pos
parameter_list|,
specifier|const
name|char
modifier|*
name|bytes
parameter_list|,
name|apr_size_t
name|count
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|+
name|count
operator|>
name|str
operator|->
name|data
operator|&&
name|bytes
operator|<
name|str
operator|->
name|data
operator|+
name|str
operator|->
name|blocksize
condition|)
block|{
comment|/* special case: BYTES overlaps with this string -> copy the source */
specifier|const
name|char
modifier|*
name|temp
init|=
name|apr_pstrndup
argument_list|(
name|str
operator|->
name|pool
argument_list|,
name|bytes
argument_list|,
name|count
argument_list|)
decl_stmt|;
name|svn_stringbuf_insert
argument_list|(
name|str
argument_list|,
name|pos
argument_list|,
name|temp
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pos
operator|>
name|str
operator|->
name|len
condition|)
name|pos
operator|=
name|str
operator|->
name|len
expr_stmt|;
name|svn_stringbuf_ensure
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|len
operator|+
name|count
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|str
operator|->
name|data
operator|+
name|pos
operator|+
name|count
argument_list|,
name|str
operator|->
name|data
operator|+
name|pos
argument_list|,
name|str
operator|->
name|len
operator|-
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|->
name|data
operator|+
name|pos
argument_list|,
name|bytes
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|str
operator|->
name|len
operator|+=
name|count
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|svn_stringbuf_remove
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|pos
parameter_list|,
name|apr_size_t
name|count
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>
name|str
operator|->
name|len
condition|)
name|pos
operator|=
name|str
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|pos
operator|+
name|count
operator|>
name|str
operator|->
name|len
condition|)
name|count
operator|=
name|str
operator|->
name|len
operator|-
name|pos
expr_stmt|;
name|memmove
argument_list|(
name|str
operator|->
name|data
operator|+
name|pos
argument_list|,
name|str
operator|->
name|data
operator|+
name|pos
operator|+
name|count
argument_list|,
name|str
operator|->
name|len
operator|-
name|pos
operator|-
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|str
operator|->
name|len
operator|-=
name|count
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_stringbuf_replace
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|pos
parameter_list|,
name|apr_size_t
name|old_count
parameter_list|,
specifier|const
name|char
modifier|*
name|bytes
parameter_list|,
name|apr_size_t
name|new_count
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|+
name|new_count
operator|>
name|str
operator|->
name|data
operator|&&
name|bytes
operator|<
name|str
operator|->
name|data
operator|+
name|str
operator|->
name|blocksize
condition|)
block|{
comment|/* special case: BYTES overlaps with this string -> copy the source */
specifier|const
name|char
modifier|*
name|temp
init|=
name|apr_pstrndup
argument_list|(
name|str
operator|->
name|pool
argument_list|,
name|bytes
argument_list|,
name|new_count
argument_list|)
decl_stmt|;
name|svn_stringbuf_replace
argument_list|(
name|str
argument_list|,
name|pos
argument_list|,
name|old_count
argument_list|,
name|temp
argument_list|,
name|new_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pos
operator|>
name|str
operator|->
name|len
condition|)
name|pos
operator|=
name|str
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|pos
operator|+
name|old_count
operator|>
name|str
operator|->
name|len
condition|)
name|old_count
operator|=
name|str
operator|->
name|len
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|old_count
operator|<
name|new_count
condition|)
block|{
name|apr_size_t
name|delta
init|=
name|new_count
operator|-
name|old_count
decl_stmt|;
name|svn_stringbuf_ensure
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|len
operator|+
name|delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_count
operator|!=
name|new_count
condition|)
name|memmove
argument_list|(
name|str
operator|->
name|data
operator|+
name|pos
operator|+
name|new_count
argument_list|,
name|str
operator|->
name|data
operator|+
name|pos
operator|+
name|old_count
argument_list|,
name|str
operator|->
name|len
operator|-
name|pos
operator|-
name|old_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|->
name|data
operator|+
name|pos
argument_list|,
name|bytes
argument_list|,
name|new_count
argument_list|)
expr_stmt|;
name|str
operator|->
name|len
operator|+=
name|new_count
operator|-
name|old_count
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_stringbuf_dup
parameter_list|(
specifier|const
name|svn_stringbuf_t
modifier|*
name|original_string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|svn_stringbuf_ncreate
argument_list|(
name|original_string
operator|->
name|data
argument_list|,
name|original_string
operator|->
name|len
argument_list|,
name|pool
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_stringbuf_compare
parameter_list|(
specifier|const
name|svn_stringbuf_t
modifier|*
name|str1
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|str2
parameter_list|)
block|{
return|return
name|string_compare
argument_list|(
name|str1
operator|->
name|data
argument_list|,
name|str2
operator|->
name|data
argument_list|,
name|str1
operator|->
name|len
argument_list|,
name|str2
operator|->
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_stringbuf_first_non_whitespace
parameter_list|(
specifier|const
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|)
block|{
return|return
name|string_first_non_whitespace
argument_list|(
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|svn_stringbuf_strip_whitespace
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|)
block|{
comment|/* Find first non-whitespace character */
name|apr_size_t
name|offset
init|=
name|svn_stringbuf_first_non_whitespace
argument_list|(
name|str
argument_list|)
decl_stmt|;
comment|/* Go ahead!  Waste some RAM, we've got pools! :)  */
name|str
operator|->
name|data
operator|+=
name|offset
expr_stmt|;
name|str
operator|->
name|len
operator|-=
name|offset
expr_stmt|;
name|str
operator|->
name|blocksize
operator|-=
name|offset
expr_stmt|;
comment|/* Now that we've trimmed the front, trim the end, wasting more RAM. */
while|while
condition|(
operator|(
name|str
operator|->
name|len
operator|>
literal|0
operator|)
operator|&&
name|svn_ctype_isspace
argument_list|(
name|str
operator|->
name|data
index|[
name|str
operator|->
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|str
operator|->
name|len
operator|--
expr_stmt|;
name|str
operator|->
name|data
index|[
name|str
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_stringbuf_find_char_backward
parameter_list|(
specifier|const
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
return|return
name|find_char_backward
argument_list|(
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|,
name|ch
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_string_compare_stringbuf
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|str1
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|str2
parameter_list|)
block|{
return|return
name|string_compare
argument_list|(
name|str1
operator|->
name|data
argument_list|,
name|str2
operator|->
name|data
argument_list|,
name|str1
operator|->
name|len
argument_list|,
name|str2
operator|->
name|len
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** C string stuff. ***/
end_comment

begin_function
name|void
name|svn_cstring_split_append
parameter_list|(
name|apr_array_header_t
modifier|*
name|array
parameter_list|,
specifier|const
name|char
modifier|*
name|input
parameter_list|,
specifier|const
name|char
modifier|*
name|sep_chars
parameter_list|,
name|svn_boolean_t
name|chop_whitespace
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|pats
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|pats
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|input
argument_list|)
expr_stmt|;
comment|/* strtok wants non-const data */
name|p
operator|=
name|svn_cstring_tokenize
argument_list|(
name|sep_chars
argument_list|,
operator|&
name|pats
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|chop_whitespace
condition|)
block|{
while|while
condition|(
name|svn_ctype_isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|{
name|char
modifier|*
name|e
init|=
name|p
operator|+
operator|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|>=
name|p
operator|)
operator|&&
operator|(
name|svn_ctype_isspace
argument_list|(
operator|*
name|e
argument_list|)
operator|)
condition|)
name|e
operator|--
expr_stmt|;
operator|*
operator|(
operator|++
name|e
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|array
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|svn_cstring_tokenize
argument_list|(
name|sep_chars
argument_list|,
operator|&
name|pats
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|apr_array_header_t
modifier|*
name|svn_cstring_split
parameter_list|(
specifier|const
name|char
modifier|*
name|input
parameter_list|,
specifier|const
name|char
modifier|*
name|sep_chars
parameter_list|,
name|svn_boolean_t
name|chop_whitespace
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|a
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|5
argument_list|,
sizeof|sizeof
argument_list|(
name|input
argument_list|)
argument_list|)
decl_stmt|;
name|svn_cstring_split_append
argument_list|(
name|a
argument_list|,
name|input
argument_list|,
name|sep_chars
argument_list|,
name|chop_whitespace
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_cstring_match_glob_list
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|this_pattern
init|=
name|APR_ARRAY_IDX
argument_list|(
name|list
argument_list|,
name|i
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_fnmatch
argument_list|(
name|this_pattern
argument_list|,
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_cstring_match_list
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|this_str
init|=
name|APR_ARRAY_IDX
argument_list|(
name|list
argument_list|,
name|i
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|this_str
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_cstring_tokenize
parameter_list|(
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|char
name|csep
decl_stmt|;
comment|/* check parameters */
if|if
condition|(
operator|(
name|sep
operator|==
name|NULL
operator|)
operator|||
operator|(
name|str
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|str
operator|==
name|NULL
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* let APR handle edge cases and multiple separators */
name|csep
operator|=
operator|*
name|sep
expr_stmt|;
if|if
condition|(
name|csep
operator|==
literal|'\0'
operator|||
name|sep
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|apr_strtok
argument_list|(
name|NULL
argument_list|,
name|sep
argument_list|,
name|str
argument_list|)
return|;
comment|/* skip characters in sep (will terminate at '\0') */
name|token
operator|=
operator|*
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|token
operator|==
name|csep
condition|)
operator|++
name|token
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|token
condition|)
comment|/* no more tokens */
return|return
name|NULL
return|;
comment|/* skip valid token characters to terminate token and      * prepare for the next call (will terminate at '\0)      */
name|next
operator|=
name|strchr
argument_list|(
name|token
argument_list|,
name|csep
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
operator|*
name|str
operator|=
name|token
operator|+
name|strlen
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|char
operator|*
operator|)
name|next
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|next
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function

begin_function
name|int
name|svn_cstring_count_newlines
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|msg
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\r'
condition|)
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\r'
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn_cstring_join
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|strings
parameter_list|,
specifier|const
name|char
modifier|*
name|separator
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|new_str
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|size_t
name|sep_len
init|=
name|strlen
argument_list|(
name|separator
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strings
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|APR_ARRAY_IDX
argument_list|(
name|strings
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|new_str
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|new_str
argument_list|,
name|separator
argument_list|,
name|sep_len
argument_list|)
expr_stmt|;
block|}
return|return
name|new_str
operator|->
name|data
return|;
block|}
end_function

begin_function
name|int
name|svn_cstring_casecmp
parameter_list|(
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|int
name|a
init|=
operator|*
name|str1
operator|++
decl_stmt|;
specifier|const
name|int
name|b
init|=
operator|*
name|str2
operator|++
decl_stmt|;
specifier|const
name|int
name|cmp
init|=
name|svn_ctype_casecmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|||
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return
name|cmp
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cstring_strtoui64
parameter_list|(
name|apr_uint64_t
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_uint64_t
name|minval
parameter_list|,
name|apr_uint64_t
name|maxval
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
comment|/* We assume errno is thread-safe. */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* APR-0.9 doesn't always set errno */
comment|/* ### We're throwing away half the number range here.    * ### APR needs a apr_strtoui64() function. */
name|val
operator|=
name|apr_strtoi64
argument_list|(
name|str
argument_list|,
operator|&
name|endptr
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINVAL
operator|||
name|endptr
operator|==
name|str
operator|||
name|str
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not convert '%s' into a number"
argument_list|)
argument_list|,
name|str
argument_list|)
return|;
if|if
condition|(
operator|(
name|errno
operator|==
name|ERANGE
operator|&&
operator|(
name|val
operator|==
name|APR_INT64_MIN
operator|||
name|val
operator|==
name|APR_INT64_MAX
operator|)
operator|)
operator|||
name|val
operator|<
literal|0
operator|||
operator|(
name|apr_uint64_t
operator|)
name|val
operator|<
name|minval
operator|||
operator|(
name|apr_uint64_t
operator|)
name|val
operator|>
name|maxval
condition|)
comment|/* ### Mark this for translation when gettext doesn't choke on macros. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"Number '%s' is out of range "
literal|"'[%"
name|APR_UINT64_T_FMT
literal|", %"
name|APR_UINT64_T_FMT
literal|"]'"
argument_list|,
name|str
argument_list|,
name|minval
argument_list|,
name|maxval
argument_list|)
return|;
operator|*
name|n
operator|=
name|val
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cstring_atoui64
parameter_list|(
name|apr_uint64_t
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_cstring_strtoui64
argument_list|(
name|n
argument_list|,
name|str
argument_list|,
literal|0
argument_list|,
name|APR_UINT64_MAX
argument_list|,
literal|10
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cstring_atoui
parameter_list|(
name|unsigned
name|int
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|apr_uint64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_strtoui64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|,
literal|0
argument_list|,
name|APR_UINT32_MAX
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
operator|(
name|unsigned
name|int
operator|)
name|val
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cstring_strtoi64
parameter_list|(
name|apr_int64_t
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_int64_t
name|minval
parameter_list|,
name|apr_int64_t
name|maxval
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
comment|/* We assume errno is thread-safe. */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* APR-0.9 doesn't always set errno */
name|val
operator|=
name|apr_strtoi64
argument_list|(
name|str
argument_list|,
operator|&
name|endptr
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINVAL
operator|||
name|endptr
operator|==
name|str
operator|||
name|str
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not convert '%s' into a number"
argument_list|)
argument_list|,
name|str
argument_list|)
return|;
if|if
condition|(
operator|(
name|errno
operator|==
name|ERANGE
operator|&&
operator|(
name|val
operator|==
name|APR_INT64_MIN
operator|||
name|val
operator|==
name|APR_INT64_MAX
operator|)
operator|)
operator|||
name|val
operator|<
name|minval
operator|||
name|val
operator|>
name|maxval
condition|)
comment|/* ### Mark this for translation when gettext doesn't choke on macros. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"Number '%s' is out of range "
literal|"'[%"
name|APR_INT64_T_FMT
literal|", %"
name|APR_INT64_T_FMT
literal|"]'"
argument_list|,
name|str
argument_list|,
name|minval
argument_list|,
name|maxval
argument_list|)
return|;
operator|*
name|n
operator|=
name|val
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cstring_atoi64
parameter_list|(
name|apr_int64_t
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_cstring_strtoi64
argument_list|(
name|n
argument_list|,
name|str
argument_list|,
name|APR_INT64_MIN
argument_list|,
name|APR_INT64_MAX
argument_list|,
literal|10
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cstring_atoi
parameter_list|(
name|int
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_strtoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|,
name|APR_INT32_MIN
argument_list|,
name|APR_INT32_MAX
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|apr_status_t
name|svn__strtoff
parameter_list|(
name|apr_off_t
modifier|*
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|,
name|int
name|base
parameter_list|)
block|{
if|#
directive|if
operator|!
name|APR_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|0
operator|,
literal|0
argument_list|)
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
name|end
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|APR_FROM_OS_ERROR
argument_list|(
name|errno
argument_list|)
return|;
else|#
directive|else
return|return
name|apr_strtoff
argument_list|(
name|offset
argument_list|,
name|buf
argument_list|,
name|end
argument_list|,
name|base
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* "Precalculated" itoa values for 2 places (including leading zeros).  * For maximum performance, make sure all table entries are word-aligned.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|decimal_table
index|[
literal|100
index|]
index|[
literal|4
index|]
init|=
block|{
literal|"00"
block|,
literal|"01"
block|,
literal|"02"
block|,
literal|"03"
block|,
literal|"04"
block|,
literal|"05"
block|,
literal|"06"
block|,
literal|"07"
block|,
literal|"08"
block|,
literal|"09"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"32"
block|,
literal|"33"
block|,
literal|"34"
block|,
literal|"35"
block|,
literal|"36"
block|,
literal|"37"
block|,
literal|"38"
block|,
literal|"39"
block|,
literal|"40"
block|,
literal|"41"
block|,
literal|"42"
block|,
literal|"43"
block|,
literal|"44"
block|,
literal|"45"
block|,
literal|"46"
block|,
literal|"47"
block|,
literal|"48"
block|,
literal|"49"
block|,
literal|"50"
block|,
literal|"51"
block|,
literal|"52"
block|,
literal|"53"
block|,
literal|"54"
block|,
literal|"55"
block|,
literal|"56"
block|,
literal|"57"
block|,
literal|"58"
block|,
literal|"59"
block|,
literal|"60"
block|,
literal|"61"
block|,
literal|"62"
block|,
literal|"63"
block|,
literal|"64"
block|,
literal|"65"
block|,
literal|"66"
block|,
literal|"67"
block|,
literal|"68"
block|,
literal|"69"
block|,
literal|"70"
block|,
literal|"71"
block|,
literal|"72"
block|,
literal|"73"
block|,
literal|"74"
block|,
literal|"75"
block|,
literal|"76"
block|,
literal|"77"
block|,
literal|"78"
block|,
literal|"79"
block|,
literal|"80"
block|,
literal|"81"
block|,
literal|"82"
block|,
literal|"83"
block|,
literal|"84"
block|,
literal|"85"
block|,
literal|"86"
block|,
literal|"87"
block|,
literal|"88"
block|,
literal|"89"
block|,
literal|"90"
block|,
literal|"91"
block|,
literal|"92"
block|,
literal|"93"
block|,
literal|"94"
block|,
literal|"95"
block|,
literal|"96"
block|,
literal|"97"
block|,
literal|"98"
block|,
literal|"99"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy the two bytes at SOURCE[0] and SOURCE[1] to DEST[0] and DEST[1] */
end_comment

begin_define
define|#
directive|define
name|COPY_TWO_BYTES
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|)
define|\
value|memcpy((dest), (source), 2)
end_define

begin_function
name|apr_size_t
name|svn__ui64toa
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|apr_uint64_t
name|number
parameter_list|)
block|{
name|char
name|buffer
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
name|apr_uint32_t
name|reduced
decl_stmt|;
comment|/* used for 32 bit DIV */
name|char
modifier|*
name|target
decl_stmt|;
comment|/* Small numbers are by far the most common case.    * Therefore, we use special code.    */
if|if
condition|(
name|number
operator|<
literal|100
condition|)
block|{
if|if
condition|(
name|number
operator|<
literal|10
condition|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|'0'
operator|+
name|number
argument_list|)
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|COPY_TWO_BYTES
argument_list|(
name|dest
argument_list|,
name|decimal_table
index|[
operator|(
name|apr_size_t
operator|)
name|number
index|]
argument_list|)
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
comment|/* Standard code. Write string in pairs of chars back-to-front */
name|buffer
index|[
name|SVN_INT64_BUFFER_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|target
operator|=
operator|&
name|buffer
index|[
name|SVN_INT64_BUFFER_SIZE
operator|-
literal|3
index|]
expr_stmt|;
comment|/* Loop may be executed 0 .. 2 times. */
while|while
condition|(
name|number
operator|>=
literal|100000000
condition|)
block|{
comment|/* Number is larger than 100^4, i.e. we can write 4x2 chars.        * Also, use 32 bit DIVs as these are about twice as fast.        */
name|reduced
operator|=
call|(
name|apr_uint32_t
call|)
argument_list|(
name|number
operator|%
literal|100000000
argument_list|)
expr_stmt|;
name|number
operator|/=
literal|100000000
expr_stmt|;
name|COPY_TWO_BYTES
argument_list|(
name|target
operator|-
literal|0
argument_list|,
name|decimal_table
index|[
name|reduced
operator|%
literal|100
index|]
argument_list|)
expr_stmt|;
name|reduced
operator|/=
literal|100
expr_stmt|;
name|COPY_TWO_BYTES
argument_list|(
name|target
operator|-
literal|2
argument_list|,
name|decimal_table
index|[
name|reduced
operator|%
literal|100
index|]
argument_list|)
expr_stmt|;
name|reduced
operator|/=
literal|100
expr_stmt|;
name|COPY_TWO_BYTES
argument_list|(
name|target
operator|-
literal|4
argument_list|,
name|decimal_table
index|[
name|reduced
operator|%
literal|100
index|]
argument_list|)
expr_stmt|;
name|reduced
operator|/=
literal|100
expr_stmt|;
name|COPY_TWO_BYTES
argument_list|(
name|target
operator|-
literal|6
argument_list|,
name|decimal_table
index|[
name|reduced
operator|%
literal|100
index|]
argument_list|)
expr_stmt|;
name|target
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Now, the number fits into 32 bits, but may still be larger than 99 */
name|reduced
operator|=
call|(
name|apr_uint32_t
call|)
argument_list|(
name|number
argument_list|)
expr_stmt|;
while|while
condition|(
name|reduced
operator|>=
literal|100
condition|)
block|{
name|COPY_TWO_BYTES
argument_list|(
name|target
argument_list|,
name|decimal_table
index|[
name|reduced
operator|%
literal|100
index|]
argument_list|)
expr_stmt|;
name|reduced
operator|/=
literal|100
expr_stmt|;
name|target
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* The number is now smaller than 100 but larger than 1 */
name|COPY_TWO_BYTES
argument_list|(
name|target
argument_list|,
name|decimal_table
index|[
name|reduced
index|]
argument_list|)
expr_stmt|;
comment|/* Correction for uneven count of places. */
if|if
condition|(
name|reduced
operator|<
literal|10
condition|)
operator|++
name|target
expr_stmt|;
comment|/* Copy to target */
name|memcpy
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
operator|&
name|buffer
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
operator|-
name|target
argument_list|)
expr_stmt|;
return|return
operator|&
name|buffer
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
operator|-
name|target
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn__i64toa
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|apr_int64_t
name|number
parameter_list|)
block|{
if|if
condition|(
name|number
operator|>=
literal|0
condition|)
return|return
name|svn__ui64toa
argument_list|(
name|dest
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|number
argument_list|)
return|;
operator|*
name|dest
operator|=
literal|'-'
expr_stmt|;
return|return
name|svn__ui64toa
argument_list|(
name|dest
operator|+
literal|1
argument_list|,
call|(
name|apr_uint64_t
call|)
argument_list|(
literal|0
operator|-
name|number
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ui64toa_sep
parameter_list|(
name|apr_uint64_t
name|number
parameter_list|,
name|char
name|seperator
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|apr_size_t
name|length
init|=
name|svn__ui64toa
argument_list|(
name|buffer
argument_list|,
name|number
argument_list|)
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|length
init|;
name|i
operator|>
literal|3
condition|;
name|i
operator|-=
literal|3
control|)
block|{
name|memmove
argument_list|(
operator|&
name|buffer
index|[
name|i
operator|-
literal|2
index|]
argument_list|,
operator|&
name|buffer
index|[
name|i
operator|-
literal|3
index|]
argument_list|,
name|length
operator|-
name|i
operator|+
literal|3
argument_list|)
expr_stmt|;
name|buffer
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|seperator
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
name|buffer
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn__ui64toa_sep
parameter_list|(
name|apr_uint64_t
name|number
parameter_list|,
name|char
name|seperator
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
name|ui64toa_sep
argument_list|(
name|number
argument_list|,
name|seperator
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buffer
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|svn__i64toa_sep
parameter_list|(
name|apr_int64_t
name|number
parameter_list|,
name|char
name|seperator
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|number
operator|<
literal|0
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|ui64toa_sep
argument_list|(
call|(
name|apr_uint64_t
call|)
argument_list|(
operator|-
name|number
argument_list|)
argument_list|,
name|seperator
argument_list|,
operator|&
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|ui64toa_sep
argument_list|(
call|(
name|apr_uint64_t
call|)
argument_list|(
name|number
argument_list|)
argument_list|,
name|seperator
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buffer
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|svn_cstring__similarity
parameter_list|(
specifier|const
name|char
modifier|*
name|stra
parameter_list|,
specifier|const
name|char
modifier|*
name|strb
parameter_list|,
name|svn_membuf_t
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|rlcs
parameter_list|)
block|{
name|svn_string_t
name|stringa
decl_stmt|,
name|stringb
decl_stmt|;
name|stringa
operator|.
name|data
operator|=
name|stra
expr_stmt|;
name|stringa
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|stra
argument_list|)
expr_stmt|;
name|stringb
operator|.
name|data
operator|=
name|strb
expr_stmt|;
name|stringb
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|strb
argument_list|)
expr_stmt|;
return|return
name|svn_string__similarity
argument_list|(
operator|&
name|stringa
argument_list|,
operator|&
name|stringb
argument_list|,
name|buffer
argument_list|,
name|rlcs
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|svn_string__similarity
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|stringa
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|stringb
parameter_list|,
name|svn_membuf_t
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|rlcs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|stra
init|=
name|stringa
operator|->
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|strb
init|=
name|stringb
operator|->
name|data
decl_stmt|;
specifier|const
name|apr_size_t
name|lena
init|=
name|stringa
operator|->
name|len
decl_stmt|;
specifier|const
name|apr_size_t
name|lenb
init|=
name|stringb
operator|->
name|len
decl_stmt|;
specifier|const
name|apr_size_t
name|total
init|=
name|lena
operator|+
name|lenb
decl_stmt|;
specifier|const
name|char
modifier|*
name|enda
init|=
name|stra
operator|+
name|lena
decl_stmt|;
specifier|const
name|char
modifier|*
name|endb
init|=
name|strb
operator|+
name|lenb
decl_stmt|;
name|apr_size_t
name|lcs
init|=
literal|0
decl_stmt|;
comment|/* Skip the common prefix ... */
while|while
condition|(
name|stra
operator|<
name|enda
operator|&&
name|strb
operator|<
name|endb
operator|&&
operator|*
name|stra
operator|==
operator|*
name|strb
condition|)
block|{
operator|++
name|stra
expr_stmt|;
operator|++
name|strb
expr_stmt|;
operator|++
name|lcs
expr_stmt|;
block|}
comment|/* ... and the common suffix */
while|while
condition|(
name|stra
operator|<
name|enda
operator|&&
name|strb
operator|<
name|endb
condition|)
block|{
operator|--
name|enda
expr_stmt|;
operator|--
name|endb
expr_stmt|;
if|if
condition|(
operator|*
name|enda
operator|!=
operator|*
name|endb
condition|)
block|{
operator|++
name|enda
expr_stmt|;
operator|++
name|endb
expr_stmt|;
break|break;
block|}
operator|++
name|lcs
expr_stmt|;
block|}
if|if
condition|(
name|stra
operator|<
name|enda
operator|&&
name|strb
operator|<
name|endb
condition|)
block|{
specifier|const
name|apr_size_t
name|resta
init|=
name|enda
operator|-
name|stra
decl_stmt|;
specifier|const
name|apr_size_t
name|restb
init|=
name|endb
operator|-
name|strb
decl_stmt|;
specifier|const
name|apr_size_t
name|slots
init|=
operator|(
name|resta
operator|>
name|restb
condition|?
name|restb
else|:
name|resta
operator|)
decl_stmt|;
name|apr_size_t
modifier|*
name|curr
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
specifier|const
name|char
modifier|*
name|pstr
decl_stmt|;
comment|/* The outer loop must iterate on the longer string. */
if|if
condition|(
name|resta
operator|<
name|restb
condition|)
block|{
name|pstr
operator|=
name|stra
expr_stmt|;
name|stra
operator|=
name|strb
expr_stmt|;
name|strb
operator|=
name|pstr
expr_stmt|;
name|pstr
operator|=
name|enda
expr_stmt|;
name|enda
operator|=
name|endb
expr_stmt|;
name|endb
operator|=
name|pstr
expr_stmt|;
block|}
comment|/* Allocate two columns in the LCS matrix          ### Optimize this to (slots + 2) instesd of 2 * (slots + 1) */
name|svn_membuf__ensure
argument_list|(
name|buffer
argument_list|,
literal|2
operator|*
operator|(
name|slots
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|apr_size_t
argument_list|)
argument_list|)
expr_stmt|;
name|svn_membuf__nzero
argument_list|(
name|buffer
argument_list|,
operator|(
name|slots
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|apr_size_t
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|buffer
operator|->
name|data
expr_stmt|;
name|curr
operator|=
name|prev
operator|+
name|slots
operator|+
literal|1
expr_stmt|;
comment|/* Calculate LCS length of the remainder */
for|for
control|(
name|pstr
operator|=
name|stra
init|;
name|pstr
operator|<
name|enda
condition|;
operator|++
name|pstr
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|slots
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
name|pstr
operator|==
name|strb
index|[
name|i
operator|-
literal|1
index|]
condition|)
name|curr
index|[
name|i
index|]
operator|=
name|prev
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
else|else
name|curr
index|[
name|i
index|]
operator|=
operator|(
name|curr
index|[
name|i
operator|-
literal|1
index|]
operator|>
name|prev
index|[
name|i
index|]
condition|?
name|curr
index|[
name|i
operator|-
literal|1
index|]
else|:
name|prev
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
comment|/* Swap the buffers, making the previous one current */
block|{
name|apr_size_t
modifier|*
specifier|const
name|temp
init|=
name|prev
decl_stmt|;
name|prev
operator|=
name|curr
expr_stmt|;
name|curr
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|lcs
operator|+=
name|prev
index|[
name|slots
index|]
expr_stmt|;
block|}
if|if
condition|(
name|rlcs
condition|)
operator|*
name|rlcs
operator|=
name|lcs
expr_stmt|;
comment|/* Return similarity ratio rounded to 4 significant digits */
if|if
condition|(
name|total
condition|)
return|return
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
literal|2000
operator|*
name|lcs
operator|+
name|total
operator|/
literal|2
operator|)
operator|/
name|total
argument_list|)
return|;
else|else
return|return
literal|1000
return|;
block|}
end_function

end_unit

