begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* date.c:  date parsing for Subversion  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_token.h"
end_include

begin_comment
comment|/* Valid rule actions */
end_comment

begin_enum
enum|enum
name|rule_action
block|{
name|ACCUM
block|,
comment|/* Accumulate a decimal value */
name|MICRO
block|,
comment|/* Accumulate microseconds */
name|TZIND
block|,
comment|/* Handle +, -, Z */
name|NOOP
block|,
comment|/* Do nothing */
name|SKIPFROM
block|,
comment|/* If at end-of-value, accept the match.  Otherwise,                if the next template character matches the current                value character, continue processing as normal.                Otherwise, attempt to complete matching starting                immediately after the first subsequent occurrance of                ']' in the template. */
name|SKIP
block|,
comment|/* Ignore this template character */
name|ACCEPT
comment|/* Accept the value */
block|}
enum|;
end_enum

begin_comment
comment|/* How to handle a particular character in a template */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rule
block|{
name|char
name|key
decl_stmt|;
comment|/* The template char that this rule matches */
specifier|const
name|char
modifier|*
name|valid
decl_stmt|;
comment|/* String of valid chars for this rule */
name|enum
name|rule_action
name|action
decl_stmt|;
comment|/* What action to take when the rule is matched */
name|int
name|offset
decl_stmt|;
comment|/* Where to store the any results of the action,                               expressed in terms of bytes relative to the                               base of a match_state object. */
block|}
name|rule
typedef|;
end_typedef

begin_comment
comment|/* The parsed values, before localtime/gmt processing */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|match_state
block|{
name|apr_time_exp_t
name|base
decl_stmt|;
name|apr_int32_t
name|offhours
decl_stmt|;
name|apr_int32_t
name|offminutes
decl_stmt|;
block|}
name|match_state
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DIGITS
value|"0123456789"
end_define

begin_comment
comment|/* A declarative specification of how each template character    should be processed, using a rule for each valid symbol. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|rule
name|rules
index|[]
init|=
block|{
block|{
literal|'Y'
block|,
name|DIGITS
block|,
name|ACCUM
block|,
name|APR_OFFSETOF
argument_list|(
argument|match_state
argument_list|,
argument|base.tm_year
argument_list|)
block|}
block|,
block|{
literal|'M'
block|,
name|DIGITS
block|,
name|ACCUM
block|,
name|APR_OFFSETOF
argument_list|(
argument|match_state
argument_list|,
argument|base.tm_mon
argument_list|)
block|}
block|,
block|{
literal|'D'
block|,
name|DIGITS
block|,
name|ACCUM
block|,
name|APR_OFFSETOF
argument_list|(
argument|match_state
argument_list|,
argument|base.tm_mday
argument_list|)
block|}
block|,
block|{
literal|'h'
block|,
name|DIGITS
block|,
name|ACCUM
block|,
name|APR_OFFSETOF
argument_list|(
argument|match_state
argument_list|,
argument|base.tm_hour
argument_list|)
block|}
block|,
block|{
literal|'m'
block|,
name|DIGITS
block|,
name|ACCUM
block|,
name|APR_OFFSETOF
argument_list|(
argument|match_state
argument_list|,
argument|base.tm_min
argument_list|)
block|}
block|,
block|{
literal|'s'
block|,
name|DIGITS
block|,
name|ACCUM
block|,
name|APR_OFFSETOF
argument_list|(
argument|match_state
argument_list|,
argument|base.tm_sec
argument_list|)
block|}
block|,
block|{
literal|'u'
block|,
name|DIGITS
block|,
name|MICRO
block|,
name|APR_OFFSETOF
argument_list|(
argument|match_state
argument_list|,
argument|base.tm_usec
argument_list|)
block|}
block|,
block|{
literal|'O'
block|,
name|DIGITS
block|,
name|ACCUM
block|,
name|APR_OFFSETOF
argument_list|(
argument|match_state
argument_list|,
argument|offhours
argument_list|)
block|}
block|,
block|{
literal|'o'
block|,
name|DIGITS
block|,
name|ACCUM
block|,
name|APR_OFFSETOF
argument_list|(
argument|match_state
argument_list|,
argument|offminutes
argument_list|)
block|}
block|,
block|{
literal|'+'
block|,
literal|"-+"
block|,
name|TZIND
block|,
literal|0
block|}
block|,
block|{
literal|'Z'
block|,
literal|"Z"
block|,
name|TZIND
block|,
literal|0
block|}
block|,
block|{
literal|':'
block|,
literal|":"
block|,
name|NOOP
block|,
literal|0
block|}
block|,
block|{
literal|'-'
block|,
literal|"-"
block|,
name|NOOP
block|,
literal|0
block|}
block|,
block|{
literal|'T'
block|,
literal|"T"
block|,
name|NOOP
block|,
literal|0
block|}
block|,
block|{
literal|' '
block|,
literal|" "
block|,
name|NOOP
block|,
literal|0
block|}
block|,
block|{
literal|'.'
block|,
literal|".,"
block|,
name|NOOP
block|,
literal|0
block|}
block|,
block|{
literal|'['
block|,
name|NULL
block|,
name|SKIPFROM
block|,
literal|0
block|}
block|,
block|{
literal|']'
block|,
name|NULL
block|,
name|SKIP
block|,
literal|0
block|}
block|,
block|{
literal|'\0'
block|,
name|NULL
block|,
name|ACCEPT
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the rule associated with TCHAR, or NULL if there    is no such rule. */
end_comment

begin_function
specifier|static
specifier|const
name|rule
modifier|*
name|find_rule
parameter_list|(
name|char
name|tchar
parameter_list|)
block|{
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
name|rules
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rules
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
if|if
condition|(
name|rules
index|[
name|i
index|]
operator|.
name|key
operator|==
name|tchar
condition|)
return|return
operator|&
name|rules
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Attempt to match the date-string in VALUE to the provided TEMPLATE,    using the rules defined above.  Return TRUE on successful match,    FALSE otherwise.  On successful match, fill in *EXP with the    matched values and set *LOCALTZ to TRUE if the local time zone    should be used to interpret the match (i.e. if no time zone    information was provided), or FALSE if not. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|template_match
parameter_list|(
name|apr_time_exp_t
modifier|*
name|expt
parameter_list|,
name|svn_boolean_t
modifier|*
name|localtz
parameter_list|,
specifier|const
name|char
modifier|*
name|template
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|multiplier
init|=
literal|100000
decl_stmt|;
name|int
name|tzind
init|=
literal|0
decl_stmt|;
name|match_state
name|ms
decl_stmt|;
name|char
modifier|*
name|base
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ms
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ms
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ms
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|rule
modifier|*
name|match
init|=
name|find_rule
argument_list|(
operator|*
name|template
operator|++
argument_list|)
decl_stmt|;
name|char
name|vchar
init|=
operator|*
name|value
operator|++
decl_stmt|;
name|apr_int32_t
modifier|*
name|place
decl_stmt|;
if|if
condition|(
operator|!
name|match
operator|||
operator|(
name|match
operator|->
name|valid
operator|&&
operator|(
operator|!
name|vchar
operator|||
operator|!
name|strchr
argument_list|(
name|match
operator|->
name|valid
argument_list|,
name|vchar
argument_list|)
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Compute the address of memory location affected by this          rule by adding match->offset bytes to the address of ms.          Because this is a byte-quantity, it is necessary to cast&ms to char *. */
name|place
operator|=
operator|(
name|apr_int32_t
operator|*
operator|)
operator|(
name|base
operator|+
name|match
operator|->
name|offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|match
operator|->
name|action
condition|)
block|{
case|case
name|ACCUM
case|:
operator|*
name|place
operator|=
operator|*
name|place
operator|*
literal|10
operator|+
name|vchar
operator|-
literal|'0'
expr_stmt|;
continue|continue;
case|case
name|MICRO
case|:
operator|*
name|place
operator|+=
operator|(
name|vchar
operator|-
literal|'0'
operator|)
operator|*
name|multiplier
expr_stmt|;
name|multiplier
operator|/=
literal|10
expr_stmt|;
continue|continue;
case|case
name|TZIND
case|:
name|tzind
operator|=
name|vchar
expr_stmt|;
continue|continue;
case|case
name|SKIP
case|:
name|value
operator|--
expr_stmt|;
continue|continue;
case|case
name|NOOP
case|:
continue|continue;
case|case
name|SKIPFROM
case|:
if|if
condition|(
operator|!
name|vchar
condition|)
break|break;
name|match
operator|=
name|find_rule
argument_list|(
operator|*
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|match
operator|->
name|valid
argument_list|,
name|vchar
argument_list|)
condition|)
name|template
operator|=
name|strchr
argument_list|(
name|template
argument_list|,
literal|']'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|value
operator|--
expr_stmt|;
continue|continue;
case|case
name|ACCEPT
case|:
if|if
condition|(
name|vchar
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
break|break;
block|}
comment|/* Validate gmt offset here, since we can't reliably do it later. */
if|if
condition|(
name|ms
operator|.
name|offhours
operator|>
literal|23
operator|||
name|ms
operator|.
name|offminutes
operator|>
literal|59
condition|)
return|return
name|FALSE
return|;
comment|/* tzind will be '+' or '-' for an explicit time zone, 'Z' to      indicate UTC, or 0 to indicate local time. */
switch|switch
condition|(
name|tzind
condition|)
block|{
case|case
literal|'+'
case|:
name|ms
operator|.
name|base
operator|.
name|tm_gmtoff
operator|=
name|ms
operator|.
name|offhours
operator|*
literal|3600
operator|+
name|ms
operator|.
name|offminutes
operator|*
literal|60
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|ms
operator|.
name|base
operator|.
name|tm_gmtoff
operator|=
operator|-
operator|(
name|ms
operator|.
name|offhours
operator|*
literal|3600
operator|+
name|ms
operator|.
name|offminutes
operator|*
literal|60
operator|)
expr_stmt|;
break|break;
block|}
operator|*
name|expt
operator|=
name|ms
operator|.
name|base
expr_stmt|;
operator|*
name|localtz
operator|=
operator|(
name|tzind
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|unit_words_table
block|{
specifier|const
name|char
modifier|*
name|word
decl_stmt|;
name|apr_time_t
name|value
decl_stmt|;
block|}
name|unit_words_table
index|[]
init|=
block|{
comment|/* Word matching does not concern itself with exact days of the month    * or leap years so these amounts are always fixed. */
block|{
literal|"years"
block|,
name|apr_time_from_sec
argument_list|(
literal|60
argument|*
literal|60
argument|*
literal|24
argument|*
literal|365
argument_list|)
block|}
block|,
block|{
literal|"months"
block|,
name|apr_time_from_sec
argument_list|(
literal|60
argument|*
literal|60
argument|*
literal|24
argument|*
literal|30
argument_list|)
block|}
block|,
block|{
literal|"weeks"
block|,
name|apr_time_from_sec
argument_list|(
literal|60
argument|*
literal|60
argument|*
literal|24
argument|*
literal|7
argument_list|)
block|}
block|,
block|{
literal|"days"
block|,
name|apr_time_from_sec
argument_list|(
literal|60
argument|*
literal|60
argument|*
literal|24
argument_list|)
block|}
block|,
block|{
literal|"hours"
block|,
name|apr_time_from_sec
argument_list|(
literal|60
argument|*
literal|60
argument_list|)
block|}
block|,
block|{
literal|"minutes"
block|,
name|apr_time_from_sec
argument_list|(
literal|60
argument_list|)
block|}
block|,
block|{
literal|"mins"
block|,
name|apr_time_from_sec
argument_list|(
literal|60
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|svn_token_map_t
name|number_words_map
index|[]
init|=
block|{
block|{
literal|"zero"
block|,
literal|0
block|}
block|,
block|{
literal|"one"
block|,
literal|1
block|}
block|,
block|{
literal|"two"
block|,
literal|2
block|}
block|,
block|{
literal|"three"
block|,
literal|3
block|}
block|,
block|{
literal|"four"
block|,
literal|4
block|}
block|,
block|{
literal|"five"
block|,
literal|5
block|}
block|,
block|{
literal|"six"
block|,
literal|6
block|}
block|,
block|{
literal|"seven"
block|,
literal|7
block|}
block|,
block|{
literal|"eight"
block|,
literal|8
block|}
block|,
block|{
literal|"nine"
block|,
literal|9
block|}
block|,
block|{
literal|"ten"
block|,
literal|10
block|}
block|,
block|{
literal|"eleven"
block|,
literal|11
block|}
block|,
block|{
literal|"twelve"
block|,
literal|12
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Attempt to match the date-string in TEXT according to the following rules:  *  * "N years|months|weeks|days|hours|minutes ago" resolve to the most recent  * revision prior to the specified time. N may either be a word from  * NUMBER_WORDS_TABLE defined above, or a non-negative digit.  *  * Return TRUE on successful match, FALSE otherwise. On successful match,  * fill in *EXP with the matched value and set *LOCALTZ to TRUE (this  * function always uses local time). Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|words_match
parameter_list|(
name|apr_time_exp_t
modifier|*
name|expt
parameter_list|,
name|svn_boolean_t
modifier|*
name|localtz
parameter_list|,
name|apr_time_t
name|now
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_time_t
name|t
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|word
decl_stmt|;
name|apr_array_header_t
modifier|*
name|words
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|unit_str
decl_stmt|;
name|words
operator|=
name|svn_cstring_split
argument_list|(
name|text
argument_list|,
literal|" "
argument_list|,
name|TRUE
comment|/* chop_whitespace */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|->
name|nelts
operator|!=
literal|3
condition|)
return|return
name|FALSE
return|;
name|word
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|words
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* Try to parse a number word. */
name|n
operator|=
name|svn_token__from_word
argument_list|(
name|number_words_map
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|SVN_TOKEN_UNKNOWN
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Try to parse a digit. */
name|err
operator|=
name|svn_cstring_atoi
argument_list|(
operator|&
name|n
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Try to parse a unit. */
name|word
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|words
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit_str
operator|=
name|unit_words_table
index|[
name|i
index|]
operator|.
name|word
init|;
name|unit_str
operator|=
name|unit_words_table
index|[
name|i
index|]
operator|.
name|word
operator|,
name|unit_str
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
comment|/* Tolerate missing trailing 's' from unit. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|word
argument_list|,
name|unit_str
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
name|unit_str
argument_list|,
name|strlen
argument_list|(
name|unit_str
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|t
operator|=
name|now
operator|-
operator|(
name|n
operator|*
name|unit_words_table
index|[
name|i
index|]
operator|.
name|value
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|t
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Require trailing "ago". */
name|word
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|words
argument_list|,
literal|2
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"ago"
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|apr_time_exp_lt
argument_list|(
name|expt
argument_list|,
name|t
argument_list|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|FALSE
return|;
operator|*
name|localtz
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|valid_days_by_month
index|[]
init|=
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_parse_date
parameter_list|(
name|svn_boolean_t
modifier|*
name|matched
parameter_list|,
name|apr_time_t
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|apr_time_t
name|now
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_time_exp_t
name|expt
decl_stmt|,
name|expnow
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|svn_boolean_t
name|localtz
decl_stmt|;
operator|*
name|matched
operator|=
name|FALSE
expr_stmt|;
name|apr_err
operator|=
name|apr_time_exp_lt
argument_list|(
operator|&
name|expnow
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't manipulate current date"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|template_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
comment|/* ISO-8601 extended, date only */
literal|"YYYY-M[M]-D[D]"
argument_list|,
name|text
argument_list|)
operator|||
name|template_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
comment|/* ISO-8601 extended, UTC */
literal|"YYYY-M[M]-D[D]Th[h]:mm[:ss[.u[u[u[u[u[u][Z]"
argument_list|,
name|text
argument_list|)
operator|||
name|template_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
comment|/* ISO-8601 extended, with offset */
literal|"YYYY-M[M]-D[D]Th[h]:mm[:ss[.u[u[u[u[u[u]+OO[:oo]"
argument_list|,
name|text
argument_list|)
operator|||
name|template_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
comment|/* ISO-8601 basic, date only */
literal|"YYYYMMDD"
argument_list|,
name|text
argument_list|)
operator|||
name|template_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
comment|/* ISO-8601 basic, UTC */
literal|"YYYYMMDDThhmm[ss[.u[u[u[u[u[u][Z]"
argument_list|,
name|text
argument_list|)
operator|||
name|template_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
comment|/* ISO-8601 basic, with offset */
literal|"YYYYMMDDThhmm[ss[.u[u[u[u[u[u]+OO[oo]"
argument_list|,
name|text
argument_list|)
operator|||
name|template_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
comment|/* "svn log" format */
literal|"YYYY-M[M]-D[D] h[h]:mm[:ss[.u[u[u[u[u[u][ +OO[oo]"
argument_list|,
name|text
argument_list|)
operator|||
name|template_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
comment|/* GNU date's iso-8601 */
literal|"YYYY-M[M]-D[D]Th[h]:mm[:ss[.u[u[u[u[u[u]+OO[oo]"
argument_list|,
name|text
argument_list|)
condition|)
block|{
name|expt
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|expt
operator|.
name|tm_mon
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|template_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
comment|/* Just a time */
literal|"h[h]:mm[:ss[.u[u[u[u[u[u]"
argument_list|,
name|text
argument_list|)
condition|)
block|{
name|expt
operator|.
name|tm_year
operator|=
name|expnow
operator|.
name|tm_year
expr_stmt|;
name|expt
operator|.
name|tm_mon
operator|=
name|expnow
operator|.
name|tm_mon
expr_stmt|;
name|expt
operator|.
name|tm_mday
operator|=
name|expnow
operator|.
name|tm_mday
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|words_match
argument_list|(
operator|&
name|expt
argument_list|,
operator|&
name|localtz
argument_list|,
name|now
argument_list|,
name|text
argument_list|,
name|pool
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Range validation, allowing for leap seconds */
if|if
condition|(
name|expt
operator|.
name|tm_mon
operator|<
literal|0
operator|||
name|expt
operator|.
name|tm_mon
operator|>
literal|11
operator|||
name|expt
operator|.
name|tm_mday
operator|>
name|valid_days_by_month
index|[
name|expt
operator|.
name|tm_mon
index|]
operator|||
name|expt
operator|.
name|tm_mday
operator|<
literal|1
operator|||
name|expt
operator|.
name|tm_hour
operator|>
literal|23
operator|||
name|expt
operator|.
name|tm_min
operator|>
literal|59
operator|||
name|expt
operator|.
name|tm_sec
operator|>
literal|60
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* february/leap-year day checking.  tm_year is bias-1900, so centuries      that equal 100 (mod 400) are multiples of 400. */
if|if
condition|(
name|expt
operator|.
name|tm_mon
operator|==
literal|1
operator|&&
name|expt
operator|.
name|tm_mday
operator|==
literal|29
operator|&&
operator|(
name|expt
operator|.
name|tm_year
operator|%
literal|4
operator|!=
literal|0
operator|||
operator|(
name|expt
operator|.
name|tm_year
operator|%
literal|100
operator|==
literal|0
operator|&&
name|expt
operator|.
name|tm_year
operator|%
literal|400
operator|!=
literal|100
operator|)
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|localtz
condition|)
block|{
name|apr_time_t
name|candidate
decl_stmt|;
name|apr_time_exp_t
name|expthen
decl_stmt|;
comment|/* We need to know the GMT offset of the requested time, not the          current time.  In some cases, that quantity is ambiguous,          since at the end of daylight saving's time, an hour's worth          of local time happens twice.  For those cases, we should          prefer DST if we are currently in DST, and standard time if          not.  So, calculate the time value using the current time's          GMT offset and use the GMT offset of the resulting time. */
name|expt
operator|.
name|tm_gmtoff
operator|=
name|expnow
operator|.
name|tm_gmtoff
expr_stmt|;
name|apr_err
operator|=
name|apr_time_exp_gmt_get
argument_list|(
operator|&
name|candidate
argument_list|,
operator|&
name|expt
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't calculate requested date"
argument_list|)
argument_list|)
return|;
name|apr_err
operator|=
name|apr_time_exp_lt
argument_list|(
operator|&
name|expthen
argument_list|,
name|candidate
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't expand time"
argument_list|)
argument_list|)
return|;
name|expt
operator|.
name|tm_gmtoff
operator|=
name|expthen
operator|.
name|tm_gmtoff
expr_stmt|;
block|}
name|apr_err
operator|=
name|apr_time_exp_gmt_get
argument_list|(
name|result
argument_list|,
operator|&
name|expt
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't calculate requested date"
argument_list|)
argument_list|)
return|;
operator|*
name|matched
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

