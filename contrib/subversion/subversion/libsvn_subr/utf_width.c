begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This is an implementation of wcwidth() and wcswidth() (defined in  * IEEE Std 1002.1-2001) for Unicode.  *  * http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html  * http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html  *  * In fixed-width output devices, Latin characters all occupy a single  * "cell" position of equal width, whereas ideographic CJK characters  * occupy two such cells. Interoperability between terminal-line  * applications and (teletype-style) character terminals using the  * UTF-8 encoding requires agreement on which character should advance  * the cursor by how many cell positions. No established formal  * standards exist at present on which Unicode character shall occupy  * how many cell positions on character terminals. These routines are  * a first attempt of defining such behavior based on simple rules  * applied to data provided by the Unicode Consortium.  *  * For some graphical characters, the Unicode standard explicitly  * defines a character-cell width via the definition of the East Asian  * FullWidth (F), Wide (W), Half-width (H), and Narrow (Na) classes.  * In all these cases, there is no ambiguity about which width a  * terminal shall use. For characters in the East Asian Ambiguous (A)  * class, the width choice depends purely on a preference of backward  * compatibility with either historic CJK or Western practice.  * Choosing single-width for these characters is easy to justify as  * the appropriate long-term solution, as the CJK practice of  * displaying these characters as double-width comes from historic  * implementation simplicity (8-bit encoded characters were displayed  * single-width and 16-bit ones double-width, even for Greek,  * Cyrillic, etc.) and not any typographic considerations.  *  * Much less clear is the choice of width for the Not East Asian  * (Neutral) class. Existing practice does not dictate a width for any  * of these characters. It would nevertheless make sense  * typographically to allocate two character cells to characters such  * as for instance EM SPACE or VOLUME INTEGRAL, which cannot be  * represented adequately with a single-width glyph. The following  * routines at present merely assign a single-cell width to all  * neutral characters, in the interest of simplicity. This is not  * entirely satisfactory and should be reconsidered before  * establishing a formal standard in this area. At the moment, the  * decision which Not East Asian (Neutral) characters should be  * represented by double-width glyphs cannot yet be answered by  * applying a simple rule from the Unicode database content. Setting  * up a proper standard for the behavior of UTF-8 character terminals  * will require a careful analysis not only of each Unicode character,  * but also of each presentation form, something the author of these  * routines has avoided to do so far.  *  * http://www.unicode.org/unicode/reports/tr11/  *  * Markus Kuhn -- 2007-05-26 (Unicode 5.0)  *  * Permission to use, copy, modify, and distribute this software  * for any purpose and without fee is hereby granted. The author  * disclaims all warranties with regard to this software.  *  * Latest version: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c  */
end_comment

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_struct
struct|struct
name|interval
block|{
name|apr_uint32_t
name|first
decl_stmt|;
name|apr_uint32_t
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* auxiliary function for binary search in interval table */
end_comment

begin_function
specifier|static
name|int
name|bisearch
parameter_list|(
name|apr_uint32_t
name|ucs
parameter_list|,
specifier|const
name|struct
name|interval
modifier|*
name|table
parameter_list|,
name|apr_uint32_t
name|max
parameter_list|)
block|{
name|apr_uint32_t
name|min
init|=
literal|0
decl_stmt|;
name|apr_uint32_t
name|mid
decl_stmt|;
if|if
condition|(
name|ucs
operator|<
name|table
index|[
literal|0
index|]
operator|.
name|first
operator|||
name|ucs
operator|>
name|table
index|[
name|max
index|]
operator|.
name|last
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|max
operator|>=
name|min
condition|)
block|{
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|ucs
operator|>
name|table
index|[
name|mid
index|]
operator|.
name|last
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ucs
operator|<
name|table
index|[
name|mid
index|]
operator|.
name|first
condition|)
name|max
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
comment|/* this is safe because ucs>= table[0].first */
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The following two functions define the column width of an ISO 10646  * character as follows:  *  *    - The null character (U+0000) has a column width of 0.  *  *    - Other C0/C1 control characters and DEL will lead to a return  *      value of -1.  *  *    - Non-spacing and enclosing combining characters (general  *      category code Mn or Me in the Unicode database) have a  *      column width of 0.  *  *    - SOFT HYPHEN (U+00AD) has a column width of 1.  *  *    - Other format characters (general category code Cf in the Unicode  *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.  *  *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)  *      have a column width of 0.  *  *    - Spacing characters in the East Asian Wide (W) or East Asian  *      Full-width (F) category as defined in Unicode Technical  *      Report #11 have a column width of 2.  *  *    - All remaining characters (including all printable  *      ISO 8859-1 and WGL4 characters, Unicode control characters,  *      etc.) have a column width of 1.  *  * This implementation assumes that wchar_t characters are encoded  * in ISO 10646.  */
end_comment

begin_function
specifier|static
name|int
name|mk_wcwidth
parameter_list|(
name|apr_uint32_t
name|ucs
parameter_list|)
block|{
comment|/* sorted list of non-overlapping intervals of non-spacing characters */
comment|/* generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c" */
specifier|static
specifier|const
name|struct
name|interval
name|combining
index|[]
init|=
block|{
block|{
literal|0x0300
block|,
literal|0x036F
block|}
block|,
block|{
literal|0x0483
block|,
literal|0x0486
block|}
block|,
block|{
literal|0x0488
block|,
literal|0x0489
block|}
block|,
block|{
literal|0x0591
block|,
literal|0x05BD
block|}
block|,
block|{
literal|0x05BF
block|,
literal|0x05BF
block|}
block|,
block|{
literal|0x05C1
block|,
literal|0x05C2
block|}
block|,
block|{
literal|0x05C4
block|,
literal|0x05C5
block|}
block|,
block|{
literal|0x05C7
block|,
literal|0x05C7
block|}
block|,
block|{
literal|0x0600
block|,
literal|0x0603
block|}
block|,
block|{
literal|0x0610
block|,
literal|0x0615
block|}
block|,
block|{
literal|0x064B
block|,
literal|0x065E
block|}
block|,
block|{
literal|0x0670
block|,
literal|0x0670
block|}
block|,
block|{
literal|0x06D6
block|,
literal|0x06E4
block|}
block|,
block|{
literal|0x06E7
block|,
literal|0x06E8
block|}
block|,
block|{
literal|0x06EA
block|,
literal|0x06ED
block|}
block|,
block|{
literal|0x070F
block|,
literal|0x070F
block|}
block|,
block|{
literal|0x0711
block|,
literal|0x0711
block|}
block|,
block|{
literal|0x0730
block|,
literal|0x074A
block|}
block|,
block|{
literal|0x07A6
block|,
literal|0x07B0
block|}
block|,
block|{
literal|0x07EB
block|,
literal|0x07F3
block|}
block|,
block|{
literal|0x0901
block|,
literal|0x0902
block|}
block|,
block|{
literal|0x093C
block|,
literal|0x093C
block|}
block|,
block|{
literal|0x0941
block|,
literal|0x0948
block|}
block|,
block|{
literal|0x094D
block|,
literal|0x094D
block|}
block|,
block|{
literal|0x0951
block|,
literal|0x0954
block|}
block|,
block|{
literal|0x0962
block|,
literal|0x0963
block|}
block|,
block|{
literal|0x0981
block|,
literal|0x0981
block|}
block|,
block|{
literal|0x09BC
block|,
literal|0x09BC
block|}
block|,
block|{
literal|0x09C1
block|,
literal|0x09C4
block|}
block|,
block|{
literal|0x09CD
block|,
literal|0x09CD
block|}
block|,
block|{
literal|0x09E2
block|,
literal|0x09E3
block|}
block|,
block|{
literal|0x0A01
block|,
literal|0x0A02
block|}
block|,
block|{
literal|0x0A3C
block|,
literal|0x0A3C
block|}
block|,
block|{
literal|0x0A41
block|,
literal|0x0A42
block|}
block|,
block|{
literal|0x0A47
block|,
literal|0x0A48
block|}
block|,
block|{
literal|0x0A4B
block|,
literal|0x0A4D
block|}
block|,
block|{
literal|0x0A70
block|,
literal|0x0A71
block|}
block|,
block|{
literal|0x0A81
block|,
literal|0x0A82
block|}
block|,
block|{
literal|0x0ABC
block|,
literal|0x0ABC
block|}
block|,
block|{
literal|0x0AC1
block|,
literal|0x0AC5
block|}
block|,
block|{
literal|0x0AC7
block|,
literal|0x0AC8
block|}
block|,
block|{
literal|0x0ACD
block|,
literal|0x0ACD
block|}
block|,
block|{
literal|0x0AE2
block|,
literal|0x0AE3
block|}
block|,
block|{
literal|0x0B01
block|,
literal|0x0B01
block|}
block|,
block|{
literal|0x0B3C
block|,
literal|0x0B3C
block|}
block|,
block|{
literal|0x0B3F
block|,
literal|0x0B3F
block|}
block|,
block|{
literal|0x0B41
block|,
literal|0x0B43
block|}
block|,
block|{
literal|0x0B4D
block|,
literal|0x0B4D
block|}
block|,
block|{
literal|0x0B56
block|,
literal|0x0B56
block|}
block|,
block|{
literal|0x0B82
block|,
literal|0x0B82
block|}
block|,
block|{
literal|0x0BC0
block|,
literal|0x0BC0
block|}
block|,
block|{
literal|0x0BCD
block|,
literal|0x0BCD
block|}
block|,
block|{
literal|0x0C3E
block|,
literal|0x0C40
block|}
block|,
block|{
literal|0x0C46
block|,
literal|0x0C48
block|}
block|,
block|{
literal|0x0C4A
block|,
literal|0x0C4D
block|}
block|,
block|{
literal|0x0C55
block|,
literal|0x0C56
block|}
block|,
block|{
literal|0x0CBC
block|,
literal|0x0CBC
block|}
block|,
block|{
literal|0x0CBF
block|,
literal|0x0CBF
block|}
block|,
block|{
literal|0x0CC6
block|,
literal|0x0CC6
block|}
block|,
block|{
literal|0x0CCC
block|,
literal|0x0CCD
block|}
block|,
block|{
literal|0x0CE2
block|,
literal|0x0CE3
block|}
block|,
block|{
literal|0x0D41
block|,
literal|0x0D43
block|}
block|,
block|{
literal|0x0D4D
block|,
literal|0x0D4D
block|}
block|,
block|{
literal|0x0DCA
block|,
literal|0x0DCA
block|}
block|,
block|{
literal|0x0DD2
block|,
literal|0x0DD4
block|}
block|,
block|{
literal|0x0DD6
block|,
literal|0x0DD6
block|}
block|,
block|{
literal|0x0E31
block|,
literal|0x0E31
block|}
block|,
block|{
literal|0x0E34
block|,
literal|0x0E3A
block|}
block|,
block|{
literal|0x0E47
block|,
literal|0x0E4E
block|}
block|,
block|{
literal|0x0EB1
block|,
literal|0x0EB1
block|}
block|,
block|{
literal|0x0EB4
block|,
literal|0x0EB9
block|}
block|,
block|{
literal|0x0EBB
block|,
literal|0x0EBC
block|}
block|,
block|{
literal|0x0EC8
block|,
literal|0x0ECD
block|}
block|,
block|{
literal|0x0F18
block|,
literal|0x0F19
block|}
block|,
block|{
literal|0x0F35
block|,
literal|0x0F35
block|}
block|,
block|{
literal|0x0F37
block|,
literal|0x0F37
block|}
block|,
block|{
literal|0x0F39
block|,
literal|0x0F39
block|}
block|,
block|{
literal|0x0F71
block|,
literal|0x0F7E
block|}
block|,
block|{
literal|0x0F80
block|,
literal|0x0F84
block|}
block|,
block|{
literal|0x0F86
block|,
literal|0x0F87
block|}
block|,
block|{
literal|0x0F90
block|,
literal|0x0F97
block|}
block|,
block|{
literal|0x0F99
block|,
literal|0x0FBC
block|}
block|,
block|{
literal|0x0FC6
block|,
literal|0x0FC6
block|}
block|,
block|{
literal|0x102D
block|,
literal|0x1030
block|}
block|,
block|{
literal|0x1032
block|,
literal|0x1032
block|}
block|,
block|{
literal|0x1036
block|,
literal|0x1037
block|}
block|,
block|{
literal|0x1039
block|,
literal|0x1039
block|}
block|,
block|{
literal|0x1058
block|,
literal|0x1059
block|}
block|,
block|{
literal|0x1160
block|,
literal|0x11FF
block|}
block|,
block|{
literal|0x135F
block|,
literal|0x135F
block|}
block|,
block|{
literal|0x1712
block|,
literal|0x1714
block|}
block|,
block|{
literal|0x1732
block|,
literal|0x1734
block|}
block|,
block|{
literal|0x1752
block|,
literal|0x1753
block|}
block|,
block|{
literal|0x1772
block|,
literal|0x1773
block|}
block|,
block|{
literal|0x17B4
block|,
literal|0x17B5
block|}
block|,
block|{
literal|0x17B7
block|,
literal|0x17BD
block|}
block|,
block|{
literal|0x17C6
block|,
literal|0x17C6
block|}
block|,
block|{
literal|0x17C9
block|,
literal|0x17D3
block|}
block|,
block|{
literal|0x17DD
block|,
literal|0x17DD
block|}
block|,
block|{
literal|0x180B
block|,
literal|0x180D
block|}
block|,
block|{
literal|0x18A9
block|,
literal|0x18A9
block|}
block|,
block|{
literal|0x1920
block|,
literal|0x1922
block|}
block|,
block|{
literal|0x1927
block|,
literal|0x1928
block|}
block|,
block|{
literal|0x1932
block|,
literal|0x1932
block|}
block|,
block|{
literal|0x1939
block|,
literal|0x193B
block|}
block|,
block|{
literal|0x1A17
block|,
literal|0x1A18
block|}
block|,
block|{
literal|0x1B00
block|,
literal|0x1B03
block|}
block|,
block|{
literal|0x1B34
block|,
literal|0x1B34
block|}
block|,
block|{
literal|0x1B36
block|,
literal|0x1B3A
block|}
block|,
block|{
literal|0x1B3C
block|,
literal|0x1B3C
block|}
block|,
block|{
literal|0x1B42
block|,
literal|0x1B42
block|}
block|,
block|{
literal|0x1B6B
block|,
literal|0x1B73
block|}
block|,
block|{
literal|0x1DC0
block|,
literal|0x1DCA
block|}
block|,
block|{
literal|0x1DFE
block|,
literal|0x1DFF
block|}
block|,
block|{
literal|0x200B
block|,
literal|0x200F
block|}
block|,
block|{
literal|0x202A
block|,
literal|0x202E
block|}
block|,
block|{
literal|0x2060
block|,
literal|0x2063
block|}
block|,
block|{
literal|0x206A
block|,
literal|0x206F
block|}
block|,
block|{
literal|0x20D0
block|,
literal|0x20EF
block|}
block|,
block|{
literal|0x302A
block|,
literal|0x302F
block|}
block|,
block|{
literal|0x3099
block|,
literal|0x309A
block|}
block|,
block|{
literal|0xA806
block|,
literal|0xA806
block|}
block|,
block|{
literal|0xA80B
block|,
literal|0xA80B
block|}
block|,
block|{
literal|0xA825
block|,
literal|0xA826
block|}
block|,
block|{
literal|0xFB1E
block|,
literal|0xFB1E
block|}
block|,
block|{
literal|0xFE00
block|,
literal|0xFE0F
block|}
block|,
block|{
literal|0xFE20
block|,
literal|0xFE23
block|}
block|,
block|{
literal|0xFEFF
block|,
literal|0xFEFF
block|}
block|,
block|{
literal|0xFFF9
block|,
literal|0xFFFB
block|}
block|,
block|{
literal|0x10A01
block|,
literal|0x10A03
block|}
block|,
block|{
literal|0x10A05
block|,
literal|0x10A06
block|}
block|,
block|{
literal|0x10A0C
block|,
literal|0x10A0F
block|}
block|,
block|{
literal|0x10A38
block|,
literal|0x10A3A
block|}
block|,
block|{
literal|0x10A3F
block|,
literal|0x10A3F
block|}
block|,
block|{
literal|0x1D167
block|,
literal|0x1D169
block|}
block|,
block|{
literal|0x1D173
block|,
literal|0x1D182
block|}
block|,
block|{
literal|0x1D185
block|,
literal|0x1D18B
block|}
block|,
block|{
literal|0x1D1AA
block|,
literal|0x1D1AD
block|}
block|,
block|{
literal|0x1D242
block|,
literal|0x1D244
block|}
block|,
block|{
literal|0xE0001
block|,
literal|0xE0001
block|}
block|,
block|{
literal|0xE0020
block|,
literal|0xE007F
block|}
block|,
block|{
literal|0xE0100
block|,
literal|0xE01EF
block|}
block|}
decl_stmt|;
comment|/* test for 8-bit control characters */
if|if
condition|(
name|ucs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ucs
operator|<
literal|32
operator|||
operator|(
name|ucs
operator|>=
literal|0x7f
operator|&&
name|ucs
operator|<
literal|0xa0
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* binary search in table of non-spacing characters */
if|if
condition|(
name|bisearch
argument_list|(
name|ucs
argument_list|,
name|combining
argument_list|,
sizeof|sizeof
argument_list|(
name|combining
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|interval
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* if we arrive here, ucs is not a combining or C0/C1 control character */
return|return
literal|1
operator|+
operator|(
name|ucs
operator|>=
literal|0x1100
operator|&&
operator|(
name|ucs
operator|<=
literal|0x115f
operator|||
comment|/* Hangul Jamo init. consonants */
name|ucs
operator|==
literal|0x2329
operator|||
name|ucs
operator|==
literal|0x232a
operator|||
operator|(
name|ucs
operator|>=
literal|0x2e80
operator|&&
name|ucs
operator|<=
literal|0xa4cf
operator|&&
name|ucs
operator|!=
literal|0x303f
operator|)
operator|||
comment|/* CJK ... Yi */
operator|(
name|ucs
operator|>=
literal|0xac00
operator|&&
name|ucs
operator|<=
literal|0xd7a3
operator|)
operator|||
comment|/* Hangul Syllables */
operator|(
name|ucs
operator|>=
literal|0xf900
operator|&&
name|ucs
operator|<=
literal|0xfaff
operator|)
operator|||
comment|/* CJK Compatibility Ideographs */
operator|(
name|ucs
operator|>=
literal|0xfe10
operator|&&
name|ucs
operator|<=
literal|0xfe19
operator|)
operator|||
comment|/* Vertical forms */
operator|(
name|ucs
operator|>=
literal|0xfe30
operator|&&
name|ucs
operator|<=
literal|0xfe6f
operator|)
operator|||
comment|/* CJK Compatibility Forms */
operator|(
name|ucs
operator|>=
literal|0xff00
operator|&&
name|ucs
operator|<=
literal|0xff60
operator|)
operator|||
comment|/* Fullwidth Forms */
operator|(
name|ucs
operator|>=
literal|0xffe0
operator|&&
name|ucs
operator|<=
literal|0xffe6
operator|)
operator|||
operator|(
name|ucs
operator|>=
literal|0x20000
operator|&&
name|ucs
operator|<=
literal|0x2fffd
operator|)
operator|||
operator|(
name|ucs
operator|>=
literal|0x30000
operator|&&
name|ucs
operator|<=
literal|0x3fffd
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|svn_utf_cstring_utf8_width
parameter_list|(
specifier|const
name|char
modifier|*
name|cstr
parameter_list|)
block|{
name|int
name|width
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|cstr
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Ensure the conversion below doesn't fail because of encoding errors. */
if|if
condition|(
operator|!
name|svn_utf__cstring_is_valid
argument_list|(
name|cstr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Convert the UTF-8 string to UTF-32 (UCS4) which is the format    * mk_wcwidth() expects, and get the width of each character.    * We don't need much error checking since the input is valid UTF-8. */
while|while
condition|(
operator|*
name|cstr
condition|)
block|{
name|apr_uint32_t
name|ucs
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|int
name|lead_mask
decl_stmt|;
name|int
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|cstr
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|nbytes
operator|=
literal|1
expr_stmt|;
name|lead_mask
operator|=
literal|0x7f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|cstr
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
name|nbytes
operator|=
literal|2
expr_stmt|;
name|lead_mask
operator|=
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|cstr
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
name|nbytes
operator|=
literal|3
expr_stmt|;
name|lead_mask
operator|=
literal|0x0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|cstr
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
name|nbytes
operator|=
literal|4
expr_stmt|;
name|lead_mask
operator|=
literal|0x07
expr_stmt|;
block|}
else|else
block|{
comment|/* RFC 3629 restricts UTF-8 to max 4 bytes per character. */
return|return
operator|-
literal|1
return|;
block|}
comment|/* Parse character data from leading byte. */
name|ucs
operator|=
call|(
name|apr_uint32_t
call|)
argument_list|(
operator|*
name|cstr
operator|&
name|lead_mask
argument_list|)
expr_stmt|;
comment|/* Parse character data from continuation bytes. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
block|{
name|ucs
operator|<<=
literal|6
expr_stmt|;
name|ucs
operator||=
operator|(
name|cstr
index|[
name|i
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
name|cstr
operator|+=
name|nbytes
expr_stmt|;
comment|/* Determine the width of this character and add it to the total. */
name|w
operator|=
name|mk_wcwidth
argument_list|(
name|ucs
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|width
operator|+=
name|w
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function

end_unit

