begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * win32_xlate.c : Windows xlate stuff.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* prevent "empty compilation unit" warning on e.g. UNIX */
end_comment

begin_typedef
typedef|typedef
name|int
name|win32_xlate__dummy
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/* Define _WIN32_DCOM for CoInitializeEx(). */
end_comment

begin_define
define|#
directive|define
name|_WIN32_DCOM
end_define

begin_comment
comment|/* We must include windows.h ourselves or apr.h includes it for us with    many ignore options set. Including Winsock is required to resolve IPv6    compilation errors. APR_HAVE_IPV6 is only defined after including    apr.h, so we can't detect this case here. */
end_comment

begin_comment
comment|/* winsock2.h includes windows.h */
end_comment

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<Ws2tcpip.h>
end_include

begin_include
include|#
directive|include
file|<mlang.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_include
include|#
directive|include
file|<apr_portable.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"win32_xlate.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_decl_stmt
specifier|static
name|svn_atomic_t
name|com_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initializes COM and keeps COM available until process exit.    Implements svn_atomic__init_once init_func */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|initialize_com
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Try to initialize for apartment-threaded object concurrency. */
name|HRESULT
name|hr
init|=
name|CoInitializeEx
argument_list|(
name|NULL
argument_list|,
name|COINIT_APARTMENTTHREADED
argument_list|)
decl_stmt|;
if|if
condition|(
name|hr
operator|==
name|RPC_E_CHANGED_MODE
condition|)
block|{
comment|/* COM already initalized for multi-threaded object concurrency. We are          neutral to object concurrency so try to initalize it in the same way          for us, to keep an handle open. */
name|hr
operator|=
name|CoInitializeEx
argument_list|(
name|NULL
argument_list|,
name|COINIT_MULTITHREADED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|hr
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|svn_subr__win32_xlate_t
block|{
name|UINT
name|from_page_id
decl_stmt|;
name|UINT
name|to_page_id
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|apr_status_t
name|get_page_id_from_name
parameter_list|(
name|UINT
modifier|*
name|page_id_p
parameter_list|,
specifier|const
name|char
modifier|*
name|page_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|IMultiLanguage
modifier|*
name|mlang
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|hr
decl_stmt|;
name|MIMECSETINFO
name|page_info
decl_stmt|;
name|WCHAR
name|ucs2_page_name
index|[
literal|128
index|]
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|page_name
operator|==
name|SVN_APR_DEFAULT_CHARSET
condition|)
block|{
operator|*
name|page_id_p
operator|=
name|CP_ACP
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|page_name
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
block|{
operator|*
name|page_id_p
operator|=
name|CP_THREAD_ACP
expr_stmt|;
comment|/* Valid on Windows 2000+ */
return|return
name|APR_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|page_name
argument_list|,
literal|"UTF-8"
argument_list|)
condition|)
block|{
operator|*
name|page_id_p
operator|=
name|CP_UTF8
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* Use codepage identifier nnn if the codepage name is in the form      of "CPnnn".      We need this code since apr_os_locale_encoding() and svn_cmdline_init()      generates such codepage names even if they are not valid IANA charset      name. */
if|if
condition|(
operator|(
name|page_name
index|[
literal|0
index|]
operator|==
literal|'c'
operator|||
name|page_name
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
operator|&&
operator|(
name|page_name
index|[
literal|1
index|]
operator|==
literal|'p'
operator|||
name|page_name
index|[
literal|1
index|]
operator|==
literal|'P'
operator|)
condition|)
block|{
name|int
name|page_id
decl_stmt|;
name|err
operator|=
name|svn_cstring_atoi
argument_list|(
operator|&
name|page_id
argument_list|,
name|page_name
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|apr_status_t
name|saved
init|=
name|err
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|saved
return|;
block|}
operator|*
name|page_id_p
operator|=
name|page_id
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
name|err
operator|=
name|svn_atomic__init_once
argument_list|(
operator|&
name|com_initialized
argument_list|,
name|initialize_com
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|apr_status_t
name|saved
init|=
name|err
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|saved
return|;
comment|/* probably SVN_ERR_ATOMIC_INIT_FAILURE */
block|}
name|hr
operator|=
name|CoCreateInstance
argument_list|(
operator|&
name|CLSID_CMultiLanguage
argument_list|,
name|NULL
argument_list|,
name|CLSCTX_INPROC_SERVER
argument_list|,
operator|&
name|IID_IMultiLanguage
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mlang
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|hr
argument_list|)
condition|)
return|return
name|APR_EGENERAL
return|;
comment|/* Convert page name to wide string. */
name|MultiByteToWideChar
argument_list|(
name|CP_UTF8
argument_list|,
literal|0
argument_list|,
name|page_name
argument_list|,
operator|-
literal|1
argument_list|,
name|ucs2_page_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ucs2_page_name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ucs2_page_name
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|page_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|page_info
argument_list|)
argument_list|)
expr_stmt|;
name|hr
operator|=
name|mlang
operator|->
name|lpVtbl
operator|->
name|GetCharsetInfo
argument_list|(
name|mlang
argument_list|,
name|ucs2_page_name
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|hr
argument_list|)
condition|)
block|{
name|mlang
operator|->
name|lpVtbl
operator|->
name|Release
argument_list|(
name|mlang
argument_list|)
expr_stmt|;
return|return
name|APR_EINVAL
return|;
block|}
if|if
condition|(
name|page_info
operator|.
name|uiInternetEncoding
condition|)
operator|*
name|page_id_p
operator|=
name|page_info
operator|.
name|uiInternetEncoding
expr_stmt|;
else|else
operator|*
name|page_id_p
operator|=
name|page_info
operator|.
name|uiCodePage
expr_stmt|;
name|mlang
operator|->
name|lpVtbl
operator|->
name|Release
argument_list|(
name|mlang
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|svn_subr__win32_xlate_open
parameter_list|(
name|svn_subr__win32_xlate_t
modifier|*
modifier|*
name|xlate_p
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|UINT
name|from_page_id
decl_stmt|,
name|to_page_id
decl_stmt|;
name|apr_status_t
name|apr_err
init|=
name|APR_SUCCESS
decl_stmt|;
name|svn_subr__win32_xlate_t
modifier|*
name|xlate
decl_stmt|;
name|apr_err
operator|=
name|get_page_id_from_name
argument_list|(
operator|&
name|to_page_id
argument_list|,
name|topage
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|==
name|APR_SUCCESS
condition|)
name|apr_err
operator|=
name|get_page_id_from_name
argument_list|(
operator|&
name|from_page_id
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|==
name|APR_SUCCESS
condition|)
block|{
name|xlate
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xlate
argument_list|)
argument_list|)
expr_stmt|;
name|xlate
operator|->
name|from_page_id
operator|=
name|from_page_id
expr_stmt|;
name|xlate
operator|->
name|to_page_id
operator|=
name|to_page_id
expr_stmt|;
operator|*
name|xlate_p
operator|=
name|xlate
expr_stmt|;
block|}
return|return
name|apr_err
return|;
block|}
end_function

begin_function
name|apr_status_t
name|svn_subr__win32_xlate_to_stringbuf
parameter_list|(
name|svn_subr__win32_xlate_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|src_data
parameter_list|,
name|apr_size_t
name|src_length
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|dest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|WCHAR
modifier|*
name|wide_str
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|wide_size
decl_stmt|;
if|if
condition|(
name|src_length
operator|==
literal|0
condition|)
block|{
operator|*
name|dest
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
name|retval
operator|=
name|MultiByteToWideChar
argument_list|(
name|handle
operator|->
name|from_page_id
argument_list|,
literal|0
argument_list|,
name|src_data
argument_list|,
name|src_length
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
name|apr_get_os_error
argument_list|()
return|;
name|wide_size
operator|=
name|retval
expr_stmt|;
comment|/* Allocate temporary buffer for small strings on stack instead of heap. */
if|if
condition|(
name|wide_size
operator|<=
name|MAX_PATH
condition|)
block|{
name|wide_str
operator|=
name|alloca
argument_list|(
name|wide_size
operator|*
sizeof|sizeof
argument_list|(
name|WCHAR
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wide_str
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|wide_size
operator|*
sizeof|sizeof
argument_list|(
name|WCHAR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|MultiByteToWideChar
argument_list|(
name|handle
operator|->
name|from_page_id
argument_list|,
literal|0
argument_list|,
name|src_data
argument_list|,
name|src_length
argument_list|,
name|wide_str
argument_list|,
name|wide_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
name|apr_get_os_error
argument_list|()
return|;
name|retval
operator|=
name|WideCharToMultiByte
argument_list|(
name|handle
operator|->
name|to_page_id
argument_list|,
literal|0
argument_list|,
name|wide_str
argument_list|,
name|wide_size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
name|apr_get_os_error
argument_list|()
return|;
comment|/* Ensure that buffer is enough to hold result string and termination      character. */
operator|*
name|dest
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|retval
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
operator|=
name|retval
expr_stmt|;
name|retval
operator|=
name|WideCharToMultiByte
argument_list|(
name|handle
operator|->
name|to_page_id
argument_list|,
literal|0
argument_list|,
name|wide_str
argument_list|,
name|wide_size
argument_list|,
operator|(
operator|*
name|dest
operator|)
operator|->
name|data
argument_list|,
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
name|apr_get_os_error
argument_list|()
return|;
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
operator|=
name|retval
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

end_unit

