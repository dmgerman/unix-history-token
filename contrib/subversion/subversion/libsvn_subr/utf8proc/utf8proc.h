begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 2009 Public Software Group e. V., Berlin, Germany  *  *  Permission is hereby granted, free of charge, to any person obtaining a  *  copy of this software and associated documentation files (the "Software"),  *  to deal in the Software without restriction, including without limitation  *  the rights to use, copy, modify, merge, publish, distribute, sublicense,  *  and/or sell copies of the Software, and to permit persons to whom the  *  Software is furnished to do so, subject to the following conditions:  *  *  The above copyright notice and this permission notice shall be included in  *  all copies or substantial portions of the Software.  *  *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  *  DEALINGS IN THE SOFTWARE.  */
end_comment

begin_comment
comment|/*  *  File name:    utf8proc.h  *  *  Description:  *  Header files for libutf8proc, which is a mapping tool for UTF-8 strings  *  with following features:  *  - decomposing and composing of strings  *  - replacing compatibility characters with their equivalents  *  - stripping of "default ignorable characters"  *    like SOFT-HYPHEN or ZERO-WIDTH-SPACE  *  - folding of certain characters for string comparison  *    (e.g. HYPHEN U+2010 and MINUS U+2212 to ASCII "-")  *    (see "LUMP" option)  *  - optional rejection of strings containing non-assigned code points  *  - stripping of control characters  *  - stripping of character marks (accents, etc.)  *  - transformation of LF, CRLF, CR and NEL to line-feed (LF)  *    or to the unicode chararacters for paragraph separation (PS)  *    or line separation (LS).  *  - unicode case folding (for case insensitive string comparisons)  *  - rejection of illegal UTF-8 data  *    (i.e. UTF-8 encoded UTF-16 surrogates)  *  - support for korean hangul characters  *  Unicode Version 5.0.0 is supported.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UTF8PROC_H
end_ifndef

begin_define
define|#
directive|define
name|UTF8PROC_H
end_define

begin_comment
comment|/** @name API version  *    * The utf8proc API version MAJOR.MINOR.PATCH, following  * semantic-versioning rules (http://semver.org) based on API  * compatibility.  *  * This is also returned at runtime by @ref utf8proc_version; however, the  * runtime version may append a string like "-dev" to the version number  * for prerelease versions.  *  * @note The shared-library version number in the Makefile may be different,  *       being based on ABI compatibility rather than API compatibility.  */
end_comment

begin_comment
comment|/** @{ */
end_comment

begin_comment
comment|/** The MAJOR version number (increased when backwards API compatibility is broken). */
end_comment

begin_define
define|#
directive|define
name|UTF8PROC_VERSION_MAJOR
value|1
end_define

begin_comment
comment|/** The MINOR version number (increased when new functionality is added in a backwards-compatible manner). */
end_comment

begin_define
define|#
directive|define
name|UTF8PROC_VERSION_MINOR
value|1
end_define

begin_comment
comment|/** The PATCH version (increased for fixes that do not change the API). */
end_comment

begin_define
define|#
directive|define
name|UTF8PROC_VERSION_PATCH
value|5
end_define

begin_comment
comment|/** @} */
end_comment

begin_comment
comment|/*  * Define UTF8PROC_INLINE and include utf8proc.c to embed a static  * version of utf8proc in your program or library without exporting  * any of its symbols.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UTF8PROC_INLINE
end_ifdef

begin_define
define|#
directive|define
name|UTF8PROC_API
value|static
end_define

begin_undef
undef|#
directive|undef
name|UTF8PROC_DATA_EXPORT
end_undef

begin_define
define|#
directive|define
name|UTF8PROC_DATA
value|static
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UTF8PROC_API
end_define

begin_define
define|#
directive|define
name|UTF8PROC_DATA_EXPORT
end_define

begin_define
define|#
directive|define
name|UTF8PROC_DATA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_if
if|#
directive|if
name|_MSC_VER
operator|>=
literal|1900
end_if

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|signed
name|char
name|int8_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|uint8_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|short
name|int16_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|uint16_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|int32_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|bool
typedef|;
end_typedef

begin_enum
enum|enum
block|{
name|false
block|,
name|true
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN64
end_ifdef

begin_define
define|#
directive|define
name|ssize_t
value|__int64
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ssize_t
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STDBOOL_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_INTTYPES_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_typedef
typedef|typedef
name|uint8_t
name|bool
typedef|;
end_typedef

begin_enum
enum|enum
block|{
name|false
block|,
name|true
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SSIZE_MAX
define|#
directive|define
name|SSIZE_MAX
value|((size_t)SIZE_MAX/2)
endif|#
directive|endif
define|#
directive|define
name|UTF8PROC_NULLTERM
value|(1<<0)
define|#
directive|define
name|UTF8PROC_STABLE
value|(1<<1)
define|#
directive|define
name|UTF8PROC_COMPAT
value|(1<<2)
define|#
directive|define
name|UTF8PROC_COMPOSE
value|(1<<3)
define|#
directive|define
name|UTF8PROC_DECOMPOSE
value|(1<<4)
define|#
directive|define
name|UTF8PROC_IGNORE
value|(1<<5)
define|#
directive|define
name|UTF8PROC_REJECTNA
value|(1<<6)
define|#
directive|define
name|UTF8PROC_NLF2LS
value|(1<<7)
define|#
directive|define
name|UTF8PROC_NLF2PS
value|(1<<8)
define|#
directive|define
name|UTF8PROC_NLF2LF
value|(UTF8PROC_NLF2LS | UTF8PROC_NLF2PS)
define|#
directive|define
name|UTF8PROC_STRIPCC
value|(1<<9)
define|#
directive|define
name|UTF8PROC_CASEFOLD
value|(1<<10)
define|#
directive|define
name|UTF8PROC_CHARBOUND
value|(1<<11)
define|#
directive|define
name|UTF8PROC_LUMP
value|(1<<12)
define|#
directive|define
name|UTF8PROC_STRIPMARK
value|(1<<13)
comment|/*  *  Flags being regarded by several functions in the library:  *  NULLTERM:  The given UTF-8 input is NULL terminated.  *  STABLE:    Unicode Versioning Stability has to be respected.  *  COMPAT:    Compatiblity decomposition  *             (i.e. formatting information is lost)  *  COMPOSE:   Return a result with composed characters.  *  DECOMPOSE: Return a result with decomposed characters.  *  IGNORE:    Strip "default ignorable characters"  *  REJECTNA:  Return an error, if the input contains unassigned  *             code points.  *  NLF2LS:    Indicating that NLF-sequences (LF, CRLF, CR, NEL) are  *             representing a line break, and should be converted to the  *             unicode character for line separation (LS).  *  NLF2PS:    Indicating that NLF-sequences are representing a paragraph  *             break, and should be converted to the unicode character for  *             paragraph separation (PS).  *  NLF2LF:    Indicating that the meaning of NLF-sequences is unknown.  *  STRIPCC:   Strips and/or convers control characters.  *             NLF-sequences are transformed into space, except if one of  *             the NLF2LS/PS/LF options is given.  *             HorizontalTab (HT) and FormFeed (FF) are treated as a  *             NLF-sequence in this case.  *             All other control characters are simply removed.  *  CASEFOLD:  Performs unicode case folding, to be able to do a  *             case-insensitive string comparison.  *  CHARBOUND: Inserts 0xFF bytes at the beginning of each sequence which  *             is representing a single grapheme cluster (see UAX#29).  *  LUMP:      Lumps certain characters together  *             (e.g. HYPHEN U+2010 and MINUS U+2212 to ASCII "-").  *             (See lump.txt for details.)  *             If NLF2LF is set, this includes a transformation of  *             paragraph and line separators to ASCII line-feed (LF).  *  STRIPMARK: Strips all character markings  *             (non-spacing, spacing and enclosing) (i.e. accents)  *             NOTE: this option works only with COMPOSE or DECOMPOSE  */
define|#
directive|define
name|UTF8PROC_ERROR_NOMEM
value|-1
define|#
directive|define
name|UTF8PROC_ERROR_OVERFLOW
value|-2
define|#
directive|define
name|UTF8PROC_ERROR_INVALIDUTF8
value|-3
define|#
directive|define
name|UTF8PROC_ERROR_NOTASSIGNED
value|-4
define|#
directive|define
name|UTF8PROC_ERROR_INVALIDOPTS
value|-5
comment|/*  *  Error codes being returned by almost all functions:  *  ERROR_NOMEM:       Memory could not be allocated.  *  ERROR_OVERFLOW:    The given string is too long to be processed.  *  ERROR_INVALIDUTF8: The given string is not a legal UTF-8 string.  *  ERROR_NOTASSIGNED: The REJECTNA flag was set,  *                     and an unassigned code point was found.  *  ERROR_INVALIDOPTS: Invalid options have been used.  */
typedef|typedef
name|int16_t
name|utf8proc_propval_t
typedef|;
typedef|typedef
struct|struct
name|utf8proc_property_struct
block|{
name|utf8proc_propval_t
name|category
decl_stmt|;
name|utf8proc_propval_t
name|combining_class
decl_stmt|;
name|utf8proc_propval_t
name|bidi_class
decl_stmt|;
name|utf8proc_propval_t
name|decomp_type
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|decomp_mapping
decl_stmt|;
name|unsigned
name|bidi_mirrored
range|:
literal|1
decl_stmt|;
name|int32_t
name|uppercase_mapping
decl_stmt|;
name|int32_t
name|lowercase_mapping
decl_stmt|;
name|int32_t
name|titlecase_mapping
decl_stmt|;
name|int32_t
name|comb1st_index
decl_stmt|;
name|int32_t
name|comb2nd_index
decl_stmt|;
name|unsigned
name|comp_exclusion
range|:
literal|1
decl_stmt|;
name|unsigned
name|ignorable
range|:
literal|1
decl_stmt|;
name|unsigned
name|control_boundary
range|:
literal|1
decl_stmt|;
name|unsigned
name|extend
range|:
literal|1
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|casefold_mapping
decl_stmt|;
block|}
name|utf8proc_property_t
typedef|;
define|#
directive|define
name|UTF8PROC_CATEGORY_LU
value|1
define|#
directive|define
name|UTF8PROC_CATEGORY_LL
value|2
define|#
directive|define
name|UTF8PROC_CATEGORY_LT
value|3
define|#
directive|define
name|UTF8PROC_CATEGORY_LM
value|4
define|#
directive|define
name|UTF8PROC_CATEGORY_LO
value|5
define|#
directive|define
name|UTF8PROC_CATEGORY_MN
value|6
define|#
directive|define
name|UTF8PROC_CATEGORY_MC
value|7
define|#
directive|define
name|UTF8PROC_CATEGORY_ME
value|8
define|#
directive|define
name|UTF8PROC_CATEGORY_ND
value|9
define|#
directive|define
name|UTF8PROC_CATEGORY_NL
value|10
define|#
directive|define
name|UTF8PROC_CATEGORY_NO
value|11
define|#
directive|define
name|UTF8PROC_CATEGORY_PC
value|12
define|#
directive|define
name|UTF8PROC_CATEGORY_PD
value|13
define|#
directive|define
name|UTF8PROC_CATEGORY_PS
value|14
define|#
directive|define
name|UTF8PROC_CATEGORY_PE
value|15
define|#
directive|define
name|UTF8PROC_CATEGORY_PI
value|16
define|#
directive|define
name|UTF8PROC_CATEGORY_PF
value|17
define|#
directive|define
name|UTF8PROC_CATEGORY_PO
value|18
define|#
directive|define
name|UTF8PROC_CATEGORY_SM
value|19
define|#
directive|define
name|UTF8PROC_CATEGORY_SC
value|20
define|#
directive|define
name|UTF8PROC_CATEGORY_SK
value|21
define|#
directive|define
name|UTF8PROC_CATEGORY_SO
value|22
define|#
directive|define
name|UTF8PROC_CATEGORY_ZS
value|23
define|#
directive|define
name|UTF8PROC_CATEGORY_ZL
value|24
define|#
directive|define
name|UTF8PROC_CATEGORY_ZP
value|25
define|#
directive|define
name|UTF8PROC_CATEGORY_CC
value|26
define|#
directive|define
name|UTF8PROC_CATEGORY_CF
value|27
define|#
directive|define
name|UTF8PROC_CATEGORY_CS
value|28
define|#
directive|define
name|UTF8PROC_CATEGORY_CO
value|29
define|#
directive|define
name|UTF8PROC_CATEGORY_CN
value|30
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_L
value|1
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_LRE
value|2
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_LRO
value|3
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_R
value|4
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_AL
value|5
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_RLE
value|6
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_RLO
value|7
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_PDF
value|8
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_EN
value|9
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_ES
value|10
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_ET
value|11
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_AN
value|12
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_CS
value|13
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_NSM
value|14
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_BN
value|15
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_B
value|16
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_S
value|17
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_WS
value|18
define|#
directive|define
name|UTF8PROC_BIDI_CLASS_ON
value|19
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_FONT
value|1
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_NOBREAK
value|2
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_INITIAL
value|3
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_MEDIAL
value|4
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_FINAL
value|5
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_ISOLATED
value|6
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_CIRCLE
value|7
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_SUPER
value|8
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_SUB
value|9
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_VERTICAL
value|10
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_WIDE
value|11
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_NARROW
value|12
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_SMALL
value|13
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_SQUARE
value|14
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_FRACTION
value|15
define|#
directive|define
name|UTF8PROC_DECOMP_TYPE_COMPAT
value|16
ifdef|#
directive|ifdef
name|UTF8PROC_DATA_EXPORT
specifier|extern
specifier|const
name|int8_t
name|utf8proc_utf8class
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
name|UTF8PROC_API
specifier|const
name|char
modifier|*
name|utf8proc_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|UTF8PROC_API
specifier|const
name|char
modifier|*
name|utf8proc_errmsg
parameter_list|(
name|ssize_t
name|errcode
parameter_list|)
function_decl|;
comment|/*  *  Returns a static error string for the given error code.  */
name|UTF8PROC_API
name|ssize_t
name|utf8proc_iterate
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|str
parameter_list|,
name|ssize_t
name|strlen
parameter_list|,
name|int32_t
modifier|*
name|dst
parameter_list|)
function_decl|;
comment|/*  *  Reads a single char from the UTF-8 sequence being pointed to by 'str'.  *  The maximum number of bytes read is 'strlen', unless 'strlen' is  *  negative.  *  If a valid unicode char could be read, it is stored in the variable  *  being pointed to by 'dst', otherwise that variable will be set to -1.  *  In case of success the number of bytes read is returned, otherwise a  *  negative error code is returned.  */
name|UTF8PROC_API
name|bool
name|utf8proc_codepoint_valid
parameter_list|(
name|int32_t
name|uc
parameter_list|)
function_decl|;
comment|/*  *  Returns 1, if the given unicode code-point is valid, otherwise 0.  */
name|UTF8PROC_API
name|ssize_t
name|utf8proc_encode_char
parameter_list|(
name|int32_t
name|uc
parameter_list|,
name|uint8_t
modifier|*
name|dst
parameter_list|)
function_decl|;
comment|/*  *  Encodes the unicode char with the code point 'uc' as an UTF-8 string in  *  the byte array being pointed to by 'dst'. This array has to be at least  *  4 bytes long.  *  In case of success the number of bytes written is returned,  *  otherwise 0.  *  This function does not check if 'uc' is a valid unicode code point.  */
name|UTF8PROC_API
specifier|const
name|utf8proc_property_t
modifier|*
name|utf8proc_get_property
parameter_list|(
name|int32_t
name|uc
parameter_list|)
function_decl|;
comment|/*  *  Returns a pointer to a (constant) struct containing information about  *  the unicode char with the given code point 'uc'.  *  If the character is not existent a pointer to a special struct is  *  returned, where 'category' is a NULL pointer.  *  WARNING: The parameter 'uc' has to be in the range of 0x0000 to  *           0x10FFFF, otherwise the program might crash!  */
name|UTF8PROC_API
name|ssize_t
name|utf8proc_decompose_char
parameter_list|(
name|int32_t
name|uc
parameter_list|,
name|int32_t
modifier|*
name|dst
parameter_list|,
name|ssize_t
name|bufsize
parameter_list|,
name|int
name|options
parameter_list|,
name|int
modifier|*
name|last_boundclass
parameter_list|)
function_decl|;
comment|/*  *  Writes a decomposition of the unicode char 'uc' into the array being  *  pointed to by 'dst'.  *  Following flags in the 'options' field are regarded:  *  REJECTNA:  an unassigned unicode code point leads to an error  *  IGNORE:    "default ignorable" chars are stripped  *  CASEFOLD:  unicode casefolding is applied  *  COMPAT:    replace certain characters with their  *             compatibility decomposition  *  CHARBOUND: Inserts 0xFF bytes before each grapheme cluster  *  LUMP:      lumps certain different characters together  *  STRIPMARK: removes all character marks  *  The pointer 'last_boundclass' has to point to an integer variable which  *  is storing the last character boundary class, if the CHARBOUND option  *  is used.  *  In case of success the number of chars written is returned,  *  in case of an error, a negative error code is returned.  *  If the number of written chars would be bigger than 'bufsize',  *  the buffer (up to 'bufsize') has inpredictable data, and the needed  *  buffer size is returned.  *  WARNING: The parameter 'uc' has to be in the range of 0x0000 to  *           0x10FFFF, otherwise the program might crash!  */
name|UTF8PROC_API
name|ssize_t
name|utf8proc_decompose
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|str
parameter_list|,
name|ssize_t
name|strlen
parameter_list|,
name|int32_t
modifier|*
name|buffer
parameter_list|,
name|ssize_t
name|bufsize
parameter_list|,
name|int
name|options
parameter_list|)
function_decl|;
comment|/*  *  Does the same as 'utf8proc_decompose_char', but acts on a whole UTF-8  *  string, and orders the decomposed sequences correctly.  *  If the NULLTERM flag in 'options' is set, processing will be stopped,  *  when a NULL byte is encounted, otherwise 'strlen' bytes are processed.  *  The result in form of unicode code points is written into the buffer  *  being pointed to by 'buffer', having the length of 'bufsize' entries.  *  In case of success the number of chars written is returned,  *  in case of an error, a negative error code is returned.  *  If the number of written chars would be bigger than 'bufsize',  *  the buffer (up to 'bufsize') has inpredictable data, and the needed  *  buffer size is returned.  */
name|UTF8PROC_API
name|ssize_t
name|utf8proc_reencode
parameter_list|(
name|int32_t
modifier|*
name|buffer
parameter_list|,
name|ssize_t
name|length
parameter_list|,
name|int
name|options
parameter_list|)
function_decl|;
comment|/*  *  Reencodes the sequence of unicode characters given by the pointer  *  'buffer' and 'length' as UTF-8.  *  The result is stored in the same memory area where the data is read.  *  Following flags in the 'options' field are regarded:  *  NLF2LS:  converts LF, CRLF, CR and NEL into LS  *  NLF2PS:  converts LF, CRLF, CR and NEL into PS  *  NLF2LF:  converts LF, CRLF, CR and NEL into LF  *  STRIPCC: strips or converts all non-affected control characters  *  COMPOSE: tries to combine decomposed characters into composite  *           characters  *  STABLE:  prohibits combining characters which would violate  *           the unicode versioning stability  *  In case of success the length of the resulting UTF-8 string is  *  returned, otherwise a negative error code is returned.  *  WARNING: The amount of free space being pointed to by 'buffer', has to  *           exceed the amount of the input data by one byte, and the  *           entries of the array pointed to by 'str' have to be in the  *           range of 0x0000 to 0x10FFFF, otherwise the program might  *           crash!  */
name|UTF8PROC_API
name|ssize_t
name|utf8proc_map
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|str
parameter_list|,
name|ssize_t
name|strlen
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|dstptr
parameter_list|,
name|int
name|options
parameter_list|)
function_decl|;
comment|/*  *  Maps the given UTF-8 string being pointed to by 'str' to a new UTF-8  *  string, which is allocated dynamically, and afterwards pointed to by  *  the pointer being pointed to by 'dstptr'.  *  If the NULLTERM flag in the 'options' field is set, the length is  *  determined by a NULL terminator, otherwise the parameter 'strlen' is  *  evaluated to determine the string length, but in any case the result  *  will be NULL terminated (though it might contain NULL characters  *  before). Other flags in the 'options' field are passed to the functions  *  defined above, and regarded as described.  *  In case of success the length of the new string is returned,  *  otherwise a negative error code is returned.  *  NOTICE: The memory of the new UTF-8 string will have been allocated with  *          'malloc', and has theirfore to be freed with 'free'.  */
name|UTF8PROC_API
name|uint8_t
modifier|*
name|utf8proc_NFD
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|str
parameter_list|)
function_decl|;
name|UTF8PROC_API
name|uint8_t
modifier|*
name|utf8proc_NFC
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|str
parameter_list|)
function_decl|;
name|UTF8PROC_API
name|uint8_t
modifier|*
name|utf8proc_NFKD
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|str
parameter_list|)
function_decl|;
name|UTF8PROC_API
name|uint8_t
modifier|*
name|utf8proc_NFKC
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|str
parameter_list|)
function_decl|;
comment|/*  *  Returns a pointer to newly allocated memory of a NFD, NFC, NFKD or NFKC  *  normalized version of the null-terminated string 'str'.  */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

