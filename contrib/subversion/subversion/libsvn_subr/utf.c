begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * utf.c:  UTF-8 conversion routines  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_xlate.h>
end_include

begin_include
include|#
directive|include
file|<apr_atomic.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"win32_xlate.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mutex.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Use these static strings to maximize performance on standard conversions.  * Any strings on other locations are still valid, however.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|SVN_UTF_NTOU_XLATE_HANDLE
init|=
literal|"svn-utf-ntou-xlate-handle"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|SVN_UTF_UTON_XLATE_HANDLE
init|=
literal|"svn-utf-uton-xlate-handle"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|SVN_APR_UTF8_CHARSET
init|=
literal|"UTF-8"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|svn_mutex__t
modifier|*
name|xlate_handle_mutex
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|svn_boolean_t
name|assume_native_charset_is_utf8
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_typedef
typedef|typedef
name|svn_subr__win32_xlate_t
name|xlate_handle_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|apr_xlate_t
name|xlate_handle_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The xlate handle cache is a global hash table with linked lists of xlate  * handles.  In multi-threaded environments, a thread "borrows" an xlate  * handle from the cache during a translation and puts it back afterwards.  * This avoids holding a global lock for all translations.  * If there is no handle for a particular key when needed, a new is  * handle is created and put in the cache after use.  * This means that there will be at most N handles open for a key, where N  * is the number of simultanous handles in use for that key. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xlate_handle_node_t
block|{
name|xlate_handle_t
modifier|*
name|handle
decl_stmt|;
comment|/* FALSE if the handle is not valid, since its pool is being      destroyed. */
name|svn_boolean_t
name|valid
decl_stmt|;
comment|/* The name of a char encoding or APR_LOCALE_CHARSET. */
specifier|const
name|char
modifier|*
name|frompage
decl_stmt|,
modifier|*
name|topage
decl_stmt|;
name|struct
name|xlate_handle_node_t
modifier|*
name|next
decl_stmt|;
block|}
name|xlate_handle_node_t
typedef|;
end_typedef

begin_comment
comment|/* This maps const char * userdata_key strings to xlate_handle_node_t **    handles to the first entry in the linked list of xlate handles.  We don't    store the pointer to the list head directly in the hash table, since we    remove/insert entries at the head in the list in the code below, and    we can't use apr_hash_set() in each character translation because that    function allocates memory in each call where the value is non-NULL.    Since these allocations take place in a global pool, this would be a    memory leak. */
end_comment

begin_decl_stmt
specifier|static
name|apr_hash_t
modifier|*
name|xlate_handle_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "1st level cache" to standard conversion maps. We may access these  * using atomic xchange ops, i.e. without further thread synchronization.  * If the respective item is NULL, fallback to hash lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
specifier|volatile
name|xlat_ntou_static_handle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
specifier|volatile
name|xlat_uton_static_handle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clean up the xlate handle cache. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|xlate_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* We set the cache variables to NULL so that translation works in other      cleanup functions, even if it isn't cached then. */
name|xlate_handle_hash
operator|=
name|NULL
expr_stmt|;
comment|/* ensure no stale objects get accessed */
name|xlat_ntou_static_handle
operator|=
name|NULL
expr_stmt|;
name|xlat_uton_static_handle
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Set the handle of ARG to NULL. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|xlate_handle_node_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
init|=
name|arg
decl_stmt|;
name|node
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|svn_utf_initialize2
parameter_list|(
name|svn_boolean_t
name|assume_native_utf8
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xlate_handle_hash
condition|)
block|{
comment|/* We create our own subpool, which we protect with the mutex.          We can't use the pool passed to us by the caller, since we will          use it for xlate handle allocations, possibly in multiple threads,          and pool allocation is not thread-safe. */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_mutex__t
modifier|*
name|mutex
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_mutex__init
argument_list|(
operator|&
name|mutex
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
name|xlate_handle_mutex
operator|=
name|mutex
expr_stmt|;
name|xlate_handle_hash
operator|=
name|apr_hash_make
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|subpool
argument_list|,
name|NULL
argument_list|,
name|xlate_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|assume_native_charset_is_utf8
condition|)
name|assume_native_charset_is_utf8
operator|=
name|assume_native_utf8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a unique string key based on TOPAGE and FROMPAGE.  TOPAGE and  * FROMPAGE can be any valid arguments of the same name to  * apr_xlate_open().  Allocate the returned string in POOL. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_xlate_key
parameter_list|(
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* In the cases of SVN_APR_LOCALE_CHARSET and SVN_APR_DEFAULT_CHARSET    * topage/frompage is really an int, not a valid string.  So generate a    * unique key accordingly. */
if|if
condition|(
name|frompage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|frompage
operator|=
literal|"APR_LOCALE_CHARSET"
expr_stmt|;
elseif|else
if|if
condition|(
name|frompage
operator|==
name|SVN_APR_DEFAULT_CHARSET
condition|)
name|frompage
operator|=
literal|"APR_DEFAULT_CHARSET"
expr_stmt|;
if|if
condition|(
name|topage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|topage
operator|=
literal|"APR_LOCALE_CHARSET"
expr_stmt|;
elseif|else
if|if
condition|(
name|topage
operator|==
name|SVN_APR_DEFAULT_CHARSET
condition|)
name|topage
operator|=
literal|"APR_DEFAULT_CHARSET"
expr_stmt|;
return|return
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"svn-utf-"
argument_list|,
name|frompage
argument_list|,
literal|"to"
argument_list|,
name|topage
argument_list|,
literal|"-xlate-handle"
argument_list|,
name|SVN_VA_NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Atomically replace the content in *MEM with NEW_VALUE and return  * the previous content of *MEM. If atomicy cannot be guaranteed,  * *MEM will not be modified and NEW_VALUE is simply returned to  * the caller.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
modifier|*
name|atomic_swap
parameter_list|(
name|void
modifier|*
specifier|volatile
modifier|*
name|mem
parameter_list|,
name|void
modifier|*
name|new_value
parameter_list|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
comment|/* Cast is necessary because of APR bug:      https://issues.apache.org/bugzilla/show_bug.cgi?id=50731 */
return|return
name|apr_atomic_xchgptr
argument_list|(
operator|(
specifier|volatile
name|void
operator|*
operator|*
operator|)
name|mem
argument_list|,
name|new_value
argument_list|)
return|;
else|#
directive|else
comment|/* no threads - no sync. necessary */
name|void
modifier|*
name|old_value
init|=
operator|(
name|void
operator|*
operator|)
operator|*
name|mem
decl_stmt|;
operator|*
name|mem
operator|=
name|new_value
expr_stmt|;
return|return
name|old_value
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Set *RET to a newly created handle node for converting from FROMPAGE    to TOPAGE, If apr_xlate_open() returns APR_EINVAL or APR_ENOTIMPL, set    (*RET)->handle to NULL.  If fail for any other reason, return the error.    Allocate *RET and its xlate handle in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|xlate_alloc_handle
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|xlate_handle_t
modifier|*
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The error handling doesn't support the following cases, since we don't      use them currently.  Catch this here. */
name|SVN_ERR_ASSERT
argument_list|(
name|frompage
operator|!=
name|SVN_APR_DEFAULT_CHARSET
operator|&&
name|topage
operator|!=
name|SVN_APR_DEFAULT_CHARSET
operator|&&
operator|(
name|frompage
operator|!=
name|SVN_APR_LOCALE_CHARSET
operator|||
name|topage
operator|!=
name|SVN_APR_LOCALE_CHARSET
operator|)
argument_list|)
expr_stmt|;
comment|/* Try to create a handle. */
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
name|apr_err
operator|=
name|svn_subr__win32_xlate_open
argument_list|(
operator|&
name|handle
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"win32-xlate: "
expr_stmt|;
else|#
directive|else
name|apr_err
operator|=
name|apr_xlate_open
argument_list|(
operator|&
name|handle
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"APR: "
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|APR_STATUS_IS_EINVAL
argument_list|(
name|apr_err
argument_list|)
operator|||
name|APR_STATUS_IS_ENOTIMPL
argument_list|(
name|apr_err
argument_list|)
condition|)
name|handle
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|apr_strerr
index|[
literal|512
index|]
decl_stmt|;
comment|/* Can't use svn_error_wrap_apr here because it calls functions in          this file, leading to infinite recursion. */
if|if
condition|(
name|frompage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't create a character converter from "
literal|"native encoding to '%s'"
argument_list|)
argument_list|,
name|topage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|topage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't create a character converter from "
literal|"'%s' to native encoding"
argument_list|)
argument_list|,
name|frompage
argument_list|)
expr_stmt|;
else|else
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't create a character converter from "
literal|"'%s' to '%s'"
argument_list|)
argument_list|,
name|frompage
argument_list|,
name|topage
argument_list|)
expr_stmt|;
comment|/* Just put the error on the stack, since svn_error_create duplicates it          later.  APR_STRERR will be in the local encoding, not in UTF-8, though.        */
name|svn_strerror
argument_list|(
name|apr_err
argument_list|,
name|apr_strerr
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_strerr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_PLUGIN_LOAD_FAILURE
argument_list|,
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|apr_strerr
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|name
argument_list|,
name|errstr
argument_list|)
return|;
block|}
comment|/* Allocate and initialize the node. */
operator|*
name|ret
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|xlate_handle_node_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|frompage
operator|=
operator|(
operator|(
name|frompage
operator|!=
name|SVN_APR_LOCALE_CHARSET
operator|)
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|frompage
argument_list|)
else|:
name|frompage
operator|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|topage
operator|=
operator|(
operator|(
name|topage
operator|!=
name|SVN_APR_LOCALE_CHARSET
operator|)
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|topage
argument_list|)
else|:
name|topage
operator|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* If we are called from inside a pool cleanup handler, the just created      xlate handle will be closed when that handler returns by a newly      registered cleanup handler, however, the handle is still cached by us.      To prevent this, we register a cleanup handler that will reset the valid      flag of our node, so we don't use an invalid handle. */
if|if
condition|(
name|handle
condition|)
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|*
name|ret
argument_list|,
name|xlate_handle_node_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Extend xlate_alloc_handle by using USERDATA_KEY as a key in our    global hash map, if available.     Allocate *RET and its xlate handle in POOL if svn_utf_initialize()    hasn't been called or USERDATA_KEY is NULL.  Else, allocate them    in the pool of xlate_handle_hash.     Note: this function is not thread-safe. Call get_xlate_handle_node    instead. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_xlate_handle_node_internal
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
specifier|const
name|char
modifier|*
name|userdata_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* If we already have a handle, just return it. */
if|if
condition|(
name|userdata_key
operator|&&
name|xlate_handle_hash
condition|)
block|{
name|xlate_handle_node_t
modifier|*
name|old_node
init|=
name|NULL
decl_stmt|;
comment|/* 2nd level: hash lookup */
name|xlate_handle_node_t
modifier|*
modifier|*
name|old_node_p
init|=
name|svn_hash_gets
argument_list|(
name|xlate_handle_hash
argument_list|,
name|userdata_key
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_node_p
condition|)
name|old_node
operator|=
operator|*
name|old_node_p
expr_stmt|;
if|if
condition|(
name|old_node
condition|)
block|{
comment|/* Ensure that the handle is still valid. */
if|if
condition|(
name|old_node
operator|->
name|valid
condition|)
block|{
comment|/* Remove from the list. */
operator|*
name|old_node_p
operator|=
name|old_node
operator|->
name|next
expr_stmt|;
name|old_node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|ret
operator|=
name|old_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
comment|/* Note that we still have the mutex locked (if it is initialized), so we      can use the global pool for creating the new xlate handle. */
comment|/* Use the correct pool for creating the handle. */
name|pool
operator|=
name|apr_hash_pool_get
argument_list|(
name|xlate_handle_hash
argument_list|)
expr_stmt|;
return|return
name|xlate_alloc_handle
argument_list|(
name|ret
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *RET to a handle node for converting from FROMPAGE to TOPAGE,    creating the handle node if it doesn't exist in USERDATA_KEY.    If a node is not cached and apr_xlate_open() returns APR_EINVAL or    APR_ENOTIMPL, set (*RET)->handle to NULL.  If fail for any other    reason, return the error.     Allocate *RET and its xlate handle in POOL if svn_utf_initialize()    hasn't been called or USERDATA_KEY is NULL.  Else, allocate them    in the pool of xlate_handle_hash. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_xlate_handle_node
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
specifier|const
name|char
modifier|*
name|userdata_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|old_node
init|=
name|NULL
decl_stmt|;
comment|/* If we already have a handle, just return it. */
if|if
condition|(
name|userdata_key
condition|)
block|{
if|if
condition|(
name|xlate_handle_hash
condition|)
block|{
comment|/* 1st level: global, static items */
if|if
condition|(
name|userdata_key
operator|==
name|SVN_UTF_NTOU_XLATE_HANDLE
condition|)
name|old_node
operator|=
name|atomic_swap
argument_list|(
operator|&
name|xlat_ntou_static_handle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|userdata_key
operator|==
name|SVN_UTF_UTON_XLATE_HANDLE
condition|)
name|old_node
operator|=
name|atomic_swap
argument_list|(
operator|&
name|xlat_uton_static_handle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_node
operator|&&
name|old_node
operator|->
name|valid
condition|)
block|{
operator|*
name|ret
operator|=
name|old_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* We fall back on a per-pool cache instead. */
name|apr_pool_userdata_get
argument_list|(
operator|&
name|p
argument_list|,
name|userdata_key
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|old_node
operator|=
name|p
expr_stmt|;
comment|/* Ensure that the handle is still valid. */
if|if
condition|(
name|old_node
operator|&&
name|old_node
operator|->
name|valid
condition|)
block|{
operator|*
name|ret
operator|=
name|old_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|xlate_alloc_handle
argument_list|(
name|ret
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
return|;
block|}
block|}
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|xlate_handle_mutex
argument_list|,
name|get_xlate_handle_node_internal
argument_list|(
name|ret
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|userdata_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Put back NODE into the xlate handle cache for use by other calls.     Note: this function is not thread-safe. Call put_xlate_handle_node    instead. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|put_xlate_handle_node_internal
parameter_list|(
name|xlate_handle_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|userdata_key
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
modifier|*
name|node_p
init|=
name|svn_hash_gets
argument_list|(
name|xlate_handle_hash
argument_list|,
name|userdata_key
argument_list|)
decl_stmt|;
if|if
condition|(
name|node_p
operator|==
name|NULL
condition|)
block|{
name|userdata_key
operator|=
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|xlate_handle_hash
argument_list|)
argument_list|,
name|userdata_key
argument_list|)
expr_stmt|;
name|node_p
operator|=
name|apr_palloc
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|xlate_handle_hash
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node_p
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|node_p
operator|=
name|NULL
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|xlate_handle_hash
argument_list|,
name|userdata_key
argument_list|,
name|node_p
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|next
operator|=
operator|*
name|node_p
expr_stmt|;
operator|*
name|node_p
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Put back NODE into the xlate handle cache for use by other calls.    If there is no global cache, store the handle in POOL.    Ignore errors related to locking/unlocking the mutex. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|put_xlate_handle_node
parameter_list|(
name|xlate_handle_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|userdata_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|assert
argument_list|(
name|node
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|userdata_key
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* push previous global node to the hash */
if|if
condition|(
name|xlate_handle_hash
condition|)
block|{
comment|/* 1st level: global, static items */
if|if
condition|(
name|userdata_key
operator|==
name|SVN_UTF_NTOU_XLATE_HANDLE
condition|)
name|node
operator|=
name|atomic_swap
argument_list|(
operator|&
name|xlat_ntou_static_handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|userdata_key
operator|==
name|SVN_UTF_UTON_XLATE_HANDLE
condition|)
name|node
operator|=
name|atomic_swap
argument_list|(
operator|&
name|xlat_uton_static_handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|xlate_handle_mutex
argument_list|,
name|put_xlate_handle_node_internal
argument_list|(
name|node
argument_list|,
name|userdata_key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Store it in the per-pool cache. */
name|apr_pool_userdata_set
argument_list|(
name|node
argument_list|,
name|userdata_key
argument_list|,
name|apr_pool_cleanup_null
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the apr_xlate handle for converting native characters to UTF-8. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_ntou_xlate_handle_node
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|get_xlate_handle_node
argument_list|(
name|ret
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|assume_native_charset_is_utf8
condition|?
name|SVN_APR_UTF8_CHARSET
else|:
name|SVN_APR_LOCALE_CHARSET
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the apr_xlate handle for converting UTF-8 to native characters.    Create one if it doesn't exist.  If unable to find a handle, or    unable to create one because apr_xlate_open returned APR_EINVAL, then    set *RET to null and return SVN_NO_ERROR; if fail for some other    reason, return error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_uton_xlate_handle_node
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|get_xlate_handle_node
argument_list|(
name|ret
argument_list|,
name|assume_native_charset_is_utf8
condition|?
name|SVN_APR_UTF8_CHARSET
else|:
name|SVN_APR_LOCALE_CHARSET
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert SRC_LENGTH bytes of SRC_DATA in NODE->handle, store the result    in *DEST, which is allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|convert_to_stringbuf
parameter_list|(
name|xlate_handle_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|src_data
parameter_list|,
name|apr_size_t
name|src_length
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|dest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WIN32
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_err
operator|=
name|svn_subr__win32_xlate_to_stringbuf
argument_list|(
name|node
operator|->
name|handle
argument_list|,
name|src_data
argument_list|,
name|src_length
argument_list|,
name|dest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|apr_size_t
name|buflen
init|=
name|src_length
operator|*
literal|2
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_size_t
name|srclen
init|=
name|src_length
decl_stmt|;
name|apr_size_t
name|destlen
init|=
name|buflen
decl_stmt|;
comment|/* Initialize *DEST to an empty stringbuf.      A 1:2 ratio of input bytes to output bytes (as assigned above)      should be enough for most translations, and if it turns out not      to be enough, we'll grow the buffer again, sizing it based on a      1:3 ratio of the remainder of the string. */
operator|*
name|dest
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|buflen
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Not only does it not make sense to convert an empty string, but      apr-iconv is quite unreasonable about not allowing that. */
if|if
condition|(
name|src_length
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
do|do
block|{
comment|/* Set up state variables for xlate. */
name|destlen
operator|=
name|buflen
operator|-
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
expr_stmt|;
comment|/* Attempt the conversion. */
name|apr_err
operator|=
name|apr_xlate_conv_buffer
argument_list|(
name|node
operator|->
name|handle
argument_list|,
name|src_data
operator|+
operator|(
name|src_length
operator|-
name|srclen
operator|)
argument_list|,
operator|&
name|srclen
argument_list|,
operator|(
operator|*
name|dest
operator|)
operator|->
name|data
operator|+
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
argument_list|,
operator|&
name|destlen
argument_list|)
expr_stmt|;
comment|/* Now, update the *DEST->len to track the amount of output data          churned out so far from this loop. */
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
operator|+=
operator|(
operator|(
name|buflen
operator|-
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
operator|)
operator|-
name|destlen
operator|)
expr_stmt|;
name|buflen
operator|+=
name|srclen
operator|*
literal|3
expr_stmt|;
comment|/* 3 is middle ground, 2 wasn't enough                                for all characters in the buffer, 4 is                                maximum character size (currently) */
block|}
do|while
condition|(
name|apr_err
operator|==
name|APR_SUCCESS
operator|&&
name|srclen
operator|!=
literal|0
condition|)
do|;
endif|#
directive|endif
comment|/* If we exited the loop with an error, return the error. */
if|if
condition|(
name|apr_err
condition|)
block|{
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Can't use svn_error_wrap_apr here because it calls functions in          this file, leading to infinite recursion. */
if|if
condition|(
name|node
operator|->
name|frompage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't convert string from native encoding to '%s':"
argument_list|)
argument_list|,
name|node
operator|->
name|topage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|topage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't convert string from '%s' to native encoding:"
argument_list|)
argument_list|,
name|node
operator|->
name|frompage
argument_list|)
expr_stmt|;
else|else
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't convert string from '%s' to '%s':"
argument_list|)
argument_list|,
name|node
operator|->
name|frompage
argument_list|,
name|node
operator|->
name|topage
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|svn_utf__fuzzy_escape
argument_list|(
name|src_data
argument_list|,
name|src_length
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|err
argument_list|,
name|errstr
argument_list|)
return|;
block|}
comment|/* Else, exited due to success.  Trim the result buffer down to the      right length. */
operator|(
operator|*
name|dest
operator|)
operator|->
name|data
index|[
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return APR_EINVAL if the first LEN bytes of DATA contain anything    other than seven-bit, non-control (except for whitespace) ASCII    characters, finding the error pool from POOL.  Otherwise, return    SVN_NO_ERROR. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_non_ascii
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|data_start
init|=
name|data
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
name|data
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|svn_ctype_isascii
argument_list|(
operator|*
name|data
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|svn_ctype_isspace
argument_list|(
operator|*
name|data
argument_list|)
operator|)
operator|&&
name|svn_ctype_iscntrl
argument_list|(
operator|*
name|data
argument_list|)
operator|)
condition|)
block|{
comment|/* Show the printable part of the data, followed by the              decimal code of the questionable character.  Because if a              user ever gets this error, she's going to have to spend              time tracking down the non-ASCII data, so we want to help              as much as possible.  And yes, we just call the unsafe              data "non-ASCII", even though the actual constraint is              somewhat more complex than that. */
if|if
condition|(
name|data
operator|-
name|data_start
condition|)
block|{
specifier|const
name|char
modifier|*
name|error_data
init|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|data_start
argument_list|,
operator|(
name|data
operator|-
name|data_start
operator|)
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Safe data '%s' was followed by non-ASCII byte %d: "
literal|"unable to convert to/from UTF-8"
argument_list|)
argument_list|,
name|error_data
argument_list|,
operator|*
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
operator|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Non-ASCII character (code %d) detected, "
literal|"and unable to convert to/from UTF-8"
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
operator|)
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Construct an error with code APR_EINVAL and with a suitable message  * to describe the invalid UTF-8 sequence DATA of length LEN (which  * may have embedded NULLs).  We can't simply print the data, almost  * by definition we don't really know how it is encoded.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|invalid_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|last
init|=
name|svn_utf__last_valid
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|valid_txt
init|=
literal|""
decl_stmt|,
modifier|*
name|invalid_txt
init|=
literal|""
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|size_t
name|valid
decl_stmt|,
name|invalid
decl_stmt|;
comment|/* We will display at most 24 valid octets (this may split a leading      multi-byte character) as that should fit on one 80 character line. */
name|valid
operator|=
name|last
operator|-
name|data
expr_stmt|;
if|if
condition|(
name|valid
operator|>
literal|24
condition|)
name|valid
operator|=
literal|24
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|valid
condition|;
operator|++
name|i
control|)
name|valid_txt
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|valid_txt
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|" %02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|last
index|[
name|i
operator|-
name|valid
index|]
argument_list|)
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
comment|/* 4 invalid octets will guarantee that the faulty octet is displayed */
name|invalid
operator|=
name|data
operator|+
name|len
operator|-
name|last
expr_stmt|;
if|if
condition|(
name|invalid
operator|>
literal|4
condition|)
name|invalid
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|invalid
condition|;
operator|++
name|i
control|)
name|invalid_txt
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|invalid_txt
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|" %02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|last
index|[
name|i
index|]
argument_list|)
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Valid UTF-8 data\n(hex:%s)\n"
literal|"followed by invalid UTF-8 sequence\n(hex:%s)"
argument_list|)
argument_list|,
name|valid_txt
argument_list|,
name|invalid_txt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the sequence DATA of length LEN is valid UTF-8.    If it is not, return an error with code APR_EINVAL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_utf__is_valid
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|invalid_utf8
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that the NULL terminated sequence DATA is valid UTF-8.    If it is not, return an error with code APR_EINVAL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_cstring_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_utf__cstring_is_valid
argument_list|(
name|data
argument_list|)
condition|)
return|return
name|invalid_utf8
argument_list|(
name|data
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_stringbuf_to_utf8
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_ntou_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|dest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|check_utf8
argument_list|(
operator|(
operator|*
name|dest
operator|)
operator|->
name|data
argument_list|,
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_stringbuf_dup
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_string_to_utf8
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|destbuf
decl_stmt|;
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_ntou_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
operator|&
name|destbuf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|check_utf8
argument_list|(
name|destbuf
operator|->
name|data
argument_list|,
name|destbuf
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|destbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_string_dup
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Common implementation for svn_utf_cstring_to_utf8,    svn_utf_cstring_to_utf8_ex, svn_utf_cstring_from_utf8 and    svn_utf_cstring_from_utf8_ex. Convert SRC to DEST using NODE->handle as    the translator and allocating from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|convert_cstring
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|xlate_handle_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|destbuf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
argument_list|,
name|strlen
argument_list|(
name|src
argument_list|)
argument_list|,
operator|&
name|destbuf
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|destbuf
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_non_ascii
argument_list|(
name|src
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_ntou_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|convert_cstring
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|check_cstring_utf8
argument_list|(
operator|*
name|dest
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_to_utf8_ex2
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|convset_key
init|=
name|get_xlate_key
argument_list|(
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|frompage
argument_list|,
name|convset_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|convert_cstring
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|check_cstring_utf8
argument_list|(
operator|*
name|dest
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_to_utf8_ex
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
specifier|const
name|char
modifier|*
name|convset_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_utf_cstring_to_utf8_ex2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_stringbuf_from_utf8
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_uton_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|check_utf8
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|dest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_stringbuf_dup
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_string_from_utf8
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|dbuf
decl_stmt|;
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_uton_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|check_utf8
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
operator|&
name|dbuf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_string_dup
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_from_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cstring_utf8
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_uton_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|convert_cstring
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_from_utf8_ex2
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|convset_key
init|=
name|get_xlate_key
argument_list|(
name|topage
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cstring_utf8
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|topage
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|convset_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|convert_cstring
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|convset_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_utf__cstring_from_utf8_fuzzy
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|convert_from_utf8
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|)
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|escaped
decl_stmt|,
modifier|*
name|converted
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|escaped
operator|=
name|svn_utf__fuzzy_escape
argument_list|(
name|src
argument_list|,
name|strlen
argument_list|(
name|src
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Okay, now we have a *new* UTF-8 string, one that's guaranteed to      contain only 7-bit bytes :-).  Recode to native... */
name|err
operator|=
name|convert_from_utf8
argument_list|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|converted
operator|)
argument_list|,
name|escaped
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|escaped
return|;
block|}
else|else
return|return
name|converted
return|;
comment|/* ### Check the client locale, maybe we can avoid that second    * conversion!  See Ulrich Drepper's patch at    * http://subversion.tigris.org/issues/show_bug.cgi?id=807.    */
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_utf_cstring_from_utf8_fuzzy
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_utf__cstring_from_utf8_fuzzy
argument_list|(
name|src
argument_list|,
name|pool
argument_list|,
name|svn_utf_cstring_from_utf8
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_from_utf8_stringbuf
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|destbuf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_stringbuf_from_utf8
argument_list|(
operator|&
name|destbuf
argument_list|,
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|destbuf
operator|->
name|data
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_from_utf8_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|dbuf
decl_stmt|;
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_uton_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|check_utf8
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
operator|&
name|dbuf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|dbuf
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Insert the given UCS-4 VALUE into BUF at the given OFFSET. */
end_comment

begin_function
specifier|static
name|void
name|membuf_insert_ucs4
parameter_list|(
name|svn_membuf_t
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|offset
parameter_list|,
name|apr_int32_t
name|value
parameter_list|)
block|{
name|svn_membuf__resize
argument_list|(
name|buf
argument_list|,
operator|(
name|offset
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|apr_int32_t
operator|*
operator|)
name|buf
operator|->
name|data
operator|)
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TODO: Use compiler intrinsics for byte swaps. */
end_comment

begin_define
define|#
directive|define
name|SWAP_SHORT
parameter_list|(
name|x
parameter_list|)
value|((((x)& 0xff)<< 8) | (((x)>> 8)& 0xff))
end_define

begin_define
define|#
directive|define
name|SWAP_LONG
parameter_list|(
name|x
parameter_list|)
value|((((x)& 0xff)<< 24) | (((x)& 0xff00)<< 8)    \                         | (((x)>> 8)& 0xff00) | (((x)>> 24)& 0xff))
end_define

begin_define
define|#
directive|define
name|IS_UTF16_LEAD_SURROGATE
parameter_list|(
name|c
parameter_list|)
value|((c)>= 0xd800&& (c)<= 0xdbff)
end_define

begin_define
define|#
directive|define
name|IS_UTF16_TRAIL_SURROGATE
parameter_list|(
name|c
parameter_list|)
value|((c)>= 0xdc00&& (c)<= 0xdfff)
end_define

begin_function
name|svn_error_t
modifier|*
name|svn_utf__utf16_to_utf8
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|apr_uint16_t
modifier|*
name|utf16str
parameter_list|,
name|apr_size_t
name|utf16len
parameter_list|,
name|svn_boolean_t
name|big_endian
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|static
specifier|const
name|apr_uint16_t
name|endiancheck
init|=
literal|0xa55a
decl_stmt|;
specifier|const
name|svn_boolean_t
name|arch_big_endian
init|=
operator|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|endiancheck
operator|)
index|[
sizeof|sizeof
argument_list|(
name|endiancheck
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\x5a'
operator|)
decl_stmt|;
specifier|const
name|svn_boolean_t
name|swap_order
init|=
operator|(
operator|!
name|big_endian
operator|!=
operator|!
name|arch_big_endian
operator|)
decl_stmt|;
name|apr_uint16_t
name|lead_surrogate
decl_stmt|;
name|apr_size_t
name|length
decl_stmt|;
name|apr_size_t
name|offset
decl_stmt|;
name|svn_membuf_t
name|ucs4buf
decl_stmt|;
name|svn_membuf_t
name|resultbuf
decl_stmt|;
name|svn_string_t
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|utf16len
operator|==
name|SVN_UTF__UNKNOWN_LENGTH
condition|)
block|{
specifier|const
name|apr_uint16_t
modifier|*
name|endp
init|=
name|utf16str
decl_stmt|;
while|while
condition|(
operator|*
name|endp
operator|++
condition|)
empty_stmt|;
name|utf16len
operator|=
operator|(
name|endp
operator|-
name|utf16str
operator|)
expr_stmt|;
block|}
name|svn_membuf__create
argument_list|(
operator|&
name|ucs4buf
argument_list|,
name|utf16len
operator|*
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|lead_surrogate
operator|=
literal|0
operator|,
name|length
operator|=
literal|0
operator|,
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|utf16len
condition|;
operator|++
name|offset
control|)
block|{
specifier|const
name|apr_uint16_t
name|code
init|=
operator|(
name|swap_order
condition|?
name|SWAP_SHORT
argument_list|(
name|utf16str
index|[
name|offset
index|]
argument_list|)
else|:
name|utf16str
index|[
name|offset
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|lead_surrogate
condition|)
block|{
if|if
condition|(
name|IS_UTF16_TRAIL_SURROGATE
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|/* Combine the lead and trail currogates into a 32-bit code. */
name|membuf_insert_ucs4
argument_list|(
operator|&
name|ucs4buf
argument_list|,
name|length
operator|++
argument_list|,
operator|(
literal|0x010000
operator|+
operator|(
operator|(
operator|(
name|lead_surrogate
operator|&
literal|0x03ff
operator|)
operator|<<
literal|10
operator|)
operator||
operator|(
name|code
operator|&
literal|0x03ff
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|lead_surrogate
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* If we didn't find a surrogate pair, just dump the                  lead surrogate into the stream. */
name|membuf_insert_ucs4
argument_list|(
operator|&
name|ucs4buf
argument_list|,
name|length
operator|++
argument_list|,
name|lead_surrogate
argument_list|)
expr_stmt|;
name|lead_surrogate
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|offset
operator|+
literal|1
operator|)
operator|<
name|utf16len
operator|&&
name|IS_UTF16_LEAD_SURROGATE
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|/* Store a lead surrogate that is followed by at least one              code for the next iteration. */
name|lead_surrogate
operator|=
name|code
expr_stmt|;
continue|continue;
block|}
else|else
name|membuf_insert_ucs4
argument_list|(
operator|&
name|ucs4buf
argument_list|,
name|length
operator|++
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the UCS-4 buffer to UTF-8, assuming an average of 2 bytes      per code point for encoding. The buffer will grow as      necessary. */
name|svn_membuf__create
argument_list|(
operator|&
name|resultbuf
argument_list|,
name|length
operator|*
literal|2
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf__encode_ucs4_string
argument_list|(
operator|&
name|resultbuf
argument_list|,
name|ucs4buf
operator|.
name|data
argument_list|,
name|length
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|data
operator|=
name|resultbuf
operator|.
name|data
expr_stmt|;
name|res
operator|->
name|len
operator|=
name|length
expr_stmt|;
operator|*
name|result
operator|=
name|res
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf__utf32_to_utf8
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|apr_int32_t
modifier|*
name|utf32str
parameter_list|,
name|apr_size_t
name|utf32len
parameter_list|,
name|svn_boolean_t
name|big_endian
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|static
specifier|const
name|apr_int32_t
name|endiancheck
init|=
literal|0xa5cbbc5a
decl_stmt|;
specifier|const
name|svn_boolean_t
name|arch_big_endian
init|=
operator|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|endiancheck
operator|)
index|[
sizeof|sizeof
argument_list|(
name|endiancheck
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\x5a'
operator|)
decl_stmt|;
specifier|const
name|svn_boolean_t
name|swap_order
init|=
operator|(
operator|!
name|big_endian
operator|!=
operator|!
name|arch_big_endian
operator|)
decl_stmt|;
name|apr_size_t
name|length
decl_stmt|;
name|svn_membuf_t
name|resultbuf
decl_stmt|;
name|svn_string_t
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|utf32len
operator|==
name|SVN_UTF__UNKNOWN_LENGTH
condition|)
block|{
specifier|const
name|apr_int32_t
modifier|*
name|endp
init|=
name|utf32str
decl_stmt|;
while|while
condition|(
operator|*
name|endp
operator|++
condition|)
empty_stmt|;
name|utf32len
operator|=
operator|(
name|endp
operator|-
name|utf32str
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_order
condition|)
block|{
name|apr_size_t
name|offset
decl_stmt|;
name|svn_membuf_t
name|ucs4buf
decl_stmt|;
name|svn_membuf__create
argument_list|(
operator|&
name|ucs4buf
argument_list|,
name|utf32len
operator|*
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|utf32len
condition|;
operator|++
name|offset
control|)
block|{
specifier|const
name|apr_int32_t
name|code
init|=
name|SWAP_LONG
argument_list|(
name|utf32str
index|[
name|offset
index|]
argument_list|)
decl_stmt|;
name|membuf_insert_ucs4
argument_list|(
operator|&
name|ucs4buf
argument_list|,
name|offset
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|utf32str
operator|=
name|ucs4buf
operator|.
name|data
expr_stmt|;
block|}
comment|/* Convert the UCS-4 buffer to UTF-8, assuming an average of 2 bytes      per code point for encoding. The buffer will grow as      necessary. */
name|svn_membuf__create
argument_list|(
operator|&
name|resultbuf
argument_list|,
name|utf32len
operator|*
literal|2
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf__encode_ucs4_string
argument_list|(
operator|&
name|resultbuf
argument_list|,
name|utf32str
argument_list|,
name|utf32len
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|data
operator|=
name|resultbuf
operator|.
name|data
expr_stmt|;
name|res
operator|->
name|len
operator|=
name|length
expr_stmt|;
operator|*
name|result
operator|=
name|res
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_function
name|svn_error_t
modifier|*
name|svn_utf__win32_utf8_to_utf16
parameter_list|(
specifier|const
name|WCHAR
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|WCHAR
modifier|*
name|prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|int
name|utf8_count
init|=
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|const
name|int
name|prefix_len
init|=
operator|(
name|prefix
condition|?
name|lstrlenW
argument_list|(
name|prefix
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|WCHAR
modifier|*
name|wide_str
decl_stmt|;
name|int
name|wide_count
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|prefix_len
operator|+
name|utf8_count
condition|)
block|{
operator|*
name|result
operator|=
literal|L""
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|wide_count
operator|=
name|MultiByteToWideChar
argument_list|(
name|CP_UTF8
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|utf8_count
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide_count
operator|==
literal|0
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Conversion to UTF-16 failed"
argument_list|)
argument_list|)
return|;
name|wide_str
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
operator|(
name|prefix_len
operator|+
name|wide_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|wide_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_len
condition|)
name|memcpy
argument_list|(
name|wide_str
argument_list|,
name|prefix
argument_list|,
name|prefix_len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|wide_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|MultiByteToWideChar
argument_list|(
name|CP_UTF8
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|utf8_count
argument_list|,
name|wide_str
operator|+
name|prefix_len
argument_list|,
name|wide_count
argument_list|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Conversion to UTF-16 failed"
argument_list|)
argument_list|)
return|;
name|wide_str
index|[
name|prefix_len
operator|+
name|wide_count
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|result
operator|=
name|wide_str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf__win32_utf16_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|WCHAR
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|int
name|wide_count
init|=
name|lstrlenW
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|const
name|int
name|prefix_len
init|=
operator|(
name|prefix
condition|?
name|strlen
argument_list|(
name|prefix
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|char
modifier|*
name|utf8_str
decl_stmt|;
name|int
name|utf8_count
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|prefix_len
operator|+
name|wide_count
condition|)
block|{
operator|*
name|result
operator|=
literal|""
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|utf8_count
operator|=
name|WideCharToMultiByte
argument_list|(
name|CP_UTF8
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|wide_count
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|utf8_count
operator|==
literal|0
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Conversion from UTF-16 failed"
argument_list|)
argument_list|)
return|;
name|utf8_str
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
operator|(
name|prefix_len
operator|+
name|utf8_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|utf8_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_len
condition|)
name|memcpy
argument_list|(
name|utf8_str
argument_list|,
name|prefix
argument_list|,
name|prefix_len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|utf8_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|WideCharToMultiByte
argument_list|(
name|CP_UTF8
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|wide_count
argument_list|,
name|utf8_str
operator|+
name|prefix_len
argument_list|,
name|utf8_count
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Conversion from UTF-16 failed"
argument_list|)
argument_list|)
return|;
name|utf8_str
index|[
name|prefix_len
operator|+
name|utf8_count
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|result
operator|=
name|utf8_str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

end_unit

