begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * utf.c:  UTF-8 conversion routines  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_xlate.h>
end_include

begin_include
include|#
directive|include
file|<apr_atomic.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"win32_xlate.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mutex.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Use these static strings to maximize performance on standard conversions.  * Any strings on other locations are still valid, however.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|SVN_UTF_NTOU_XLATE_HANDLE
init|=
literal|"svn-utf-ntou-xlate-handle"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|SVN_UTF_UTON_XLATE_HANDLE
init|=
literal|"svn-utf-uton-xlate-handle"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|SVN_APR_UTF8_CHARSET
init|=
literal|"UTF-8"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|svn_mutex__t
modifier|*
name|xlate_handle_mutex
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|svn_boolean_t
name|assume_native_charset_is_utf8
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The xlate handle cache is a global hash table with linked lists of xlate  * handles.  In multi-threaded environments, a thread "borrows" an xlate  * handle from the cache during a translation and puts it back afterwards.  * This avoids holding a global lock for all translations.  * If there is no handle for a particular key when needed, a new is  * handle is created and put in the cache after use.  * This means that there will be at most N handles open for a key, where N  * is the number of simultanous handles in use for that key. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xlate_handle_node_t
block|{
name|apr_xlate_t
modifier|*
name|handle
decl_stmt|;
comment|/* FALSE if the handle is not valid, since its pool is being      destroyed. */
name|svn_boolean_t
name|valid
decl_stmt|;
comment|/* The name of a char encoding or APR_LOCALE_CHARSET. */
specifier|const
name|char
modifier|*
name|frompage
decl_stmt|,
modifier|*
name|topage
decl_stmt|;
name|struct
name|xlate_handle_node_t
modifier|*
name|next
decl_stmt|;
block|}
name|xlate_handle_node_t
typedef|;
end_typedef

begin_comment
comment|/* This maps const char * userdata_key strings to xlate_handle_node_t **    handles to the first entry in the linked list of xlate handles.  We don't    store the pointer to the list head directly in the hash table, since we    remove/insert entries at the head in the list in the code below, and    we can't use apr_hash_set() in each character translation because that    function allocates memory in each call where the value is non-NULL.    Since these allocations take place in a global pool, this would be a    memory leak. */
end_comment

begin_decl_stmt
specifier|static
name|apr_hash_t
modifier|*
name|xlate_handle_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "1st level cache" to standard conversion maps. We may access these  * using atomic xchange ops, i.e. without further thread synchronization.  * If the respective item is NULL, fallback to hash lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
specifier|volatile
name|xlat_ntou_static_handle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
specifier|volatile
name|xlat_uton_static_handle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clean up the xlate handle cache. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|xlate_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* We set the cache variables to NULL so that translation works in other      cleanup functions, even if it isn't cached then. */
name|xlate_handle_hash
operator|=
name|NULL
expr_stmt|;
comment|/* ensure no stale objects get accessed */
name|xlat_ntou_static_handle
operator|=
name|NULL
expr_stmt|;
name|xlat_uton_static_handle
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Set the handle of ARG to NULL. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|xlate_handle_node_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
init|=
name|arg
decl_stmt|;
name|node
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|svn_utf_initialize2
parameter_list|(
name|svn_boolean_t
name|assume_native_utf8
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xlate_handle_hash
condition|)
block|{
comment|/* We create our own subpool, which we protect with the mutex.          We can't use the pool passed to us by the caller, since we will          use it for xlate handle allocations, possibly in multiple threads,          and pool allocation is not thread-safe. */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_mutex__t
modifier|*
name|mutex
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_mutex__init
argument_list|(
operator|&
name|mutex
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
name|xlate_handle_mutex
operator|=
name|mutex
expr_stmt|;
name|xlate_handle_hash
operator|=
name|apr_hash_make
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|subpool
argument_list|,
name|NULL
argument_list|,
name|xlate_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|assume_native_charset_is_utf8
condition|)
name|assume_native_charset_is_utf8
operator|=
name|assume_native_utf8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a unique string key based on TOPAGE and FROMPAGE.  TOPAGE and  * FROMPAGE can be any valid arguments of the same name to  * apr_xlate_open().  Allocate the returned string in POOL. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_xlate_key
parameter_list|(
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* In the cases of SVN_APR_LOCALE_CHARSET and SVN_APR_DEFAULT_CHARSET    * topage/frompage is really an int, not a valid string.  So generate a    * unique key accordingly. */
if|if
condition|(
name|frompage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|frompage
operator|=
literal|"APR_LOCALE_CHARSET"
expr_stmt|;
elseif|else
if|if
condition|(
name|frompage
operator|==
name|SVN_APR_DEFAULT_CHARSET
condition|)
name|frompage
operator|=
literal|"APR_DEFAULT_CHARSET"
expr_stmt|;
if|if
condition|(
name|topage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|topage
operator|=
literal|"APR_LOCALE_CHARSET"
expr_stmt|;
elseif|else
if|if
condition|(
name|topage
operator|==
name|SVN_APR_DEFAULT_CHARSET
condition|)
name|topage
operator|=
literal|"APR_DEFAULT_CHARSET"
expr_stmt|;
return|return
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"svn-utf-"
argument_list|,
name|frompage
argument_list|,
literal|"to"
argument_list|,
name|topage
argument_list|,
literal|"-xlate-handle"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Atomically replace the content in *MEM with NEW_VALUE and return  * the previous content of *MEM. If atomicy cannot be guaranteed,  * *MEM will not be modified and NEW_VALUE is simply returned to  * the caller.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
modifier|*
name|atomic_swap
parameter_list|(
name|void
modifier|*
specifier|volatile
modifier|*
name|mem
parameter_list|,
name|void
modifier|*
name|new_value
parameter_list|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
if|#
directive|if
name|APR_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|3
operator|,
literal|0
argument_list|)
comment|/* Cast is necessary because of APR bug:      https://issues.apache.org/bugzilla/show_bug.cgi?id=50731 */
return|return
name|apr_atomic_xchgptr
argument_list|(
operator|(
specifier|volatile
name|void
operator|*
operator|*
operator|)
name|mem
argument_list|,
name|new_value
argument_list|)
return|;
else|#
directive|else
comment|/* old APRs don't support atomic swaps. Simply return the     * input to the caller for further proccessing. */
return|return
name|new_value
return|;
endif|#
directive|endif
else|#
directive|else
comment|/* no threads - no sync. necessary */
name|void
modifier|*
name|old_value
init|=
operator|(
name|void
operator|*
operator|)
operator|*
name|mem
decl_stmt|;
operator|*
name|mem
operator|=
name|new_value
expr_stmt|;
return|return
name|old_value
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Set *RET to a newly created handle node for converting from FROMPAGE    to TOPAGE, If apr_xlate_open() returns APR_EINVAL or APR_ENOTIMPL, set    (*RET)->handle to NULL.  If fail for any other reason, return the error.    Allocate *RET and its xlate handle in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|xlate_alloc_handle
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_xlate_t
modifier|*
name|handle
decl_stmt|;
comment|/* The error handling doesn't support the following cases, since we don't      use them currently.  Catch this here. */
name|SVN_ERR_ASSERT
argument_list|(
name|frompage
operator|!=
name|SVN_APR_DEFAULT_CHARSET
operator|&&
name|topage
operator|!=
name|SVN_APR_DEFAULT_CHARSET
operator|&&
operator|(
name|frompage
operator|!=
name|SVN_APR_LOCALE_CHARSET
operator|||
name|topage
operator|!=
name|SVN_APR_LOCALE_CHARSET
operator|)
argument_list|)
expr_stmt|;
comment|/* Try to create a handle. */
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
name|apr_err
operator|=
name|svn_subr__win32_xlate_open
argument_list|(
operator|(
name|win32_xlate_t
operator|*
operator|*
operator|)
operator|&
name|handle
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|apr_err
operator|=
name|apr_xlate_open
argument_list|(
operator|&
name|handle
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|APR_STATUS_IS_EINVAL
argument_list|(
name|apr_err
argument_list|)
operator|||
name|APR_STATUS_IS_ENOTIMPL
argument_list|(
name|apr_err
argument_list|)
condition|)
name|handle
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
comment|/* Can't use svn_error_wrap_apr here because it calls functions in          this file, leading to infinite recursion. */
if|if
condition|(
name|frompage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't create a character converter from "
literal|"native encoding to '%s'"
argument_list|)
argument_list|,
name|topage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|topage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't create a character converter from "
literal|"'%s' to native encoding"
argument_list|)
argument_list|,
name|frompage
argument_list|)
expr_stmt|;
else|else
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't create a character converter from "
literal|"'%s' to '%s'"
argument_list|)
argument_list|,
name|frompage
argument_list|,
name|topage
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
return|;
block|}
comment|/* Allocate and initialize the node. */
operator|*
name|ret
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|xlate_handle_node_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|frompage
operator|=
operator|(
operator|(
name|frompage
operator|!=
name|SVN_APR_LOCALE_CHARSET
operator|)
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|frompage
argument_list|)
else|:
name|frompage
operator|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|topage
operator|=
operator|(
operator|(
name|topage
operator|!=
name|SVN_APR_LOCALE_CHARSET
operator|)
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|topage
argument_list|)
else|:
name|topage
operator|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* If we are called from inside a pool cleanup handler, the just created      xlate handle will be closed when that handler returns by a newly      registered cleanup handler, however, the handle is still cached by us.      To prevent this, we register a cleanup handler that will reset the valid      flag of our node, so we don't use an invalid handle. */
if|if
condition|(
name|handle
condition|)
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|*
name|ret
argument_list|,
name|xlate_handle_node_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Extend xlate_alloc_handle by using USERDATA_KEY as a key in our    global hash map, if available.     Allocate *RET and its xlate handle in POOL if svn_utf_initialize()    hasn't been called or USERDATA_KEY is NULL.  Else, allocate them    in the pool of xlate_handle_hash.     Note: this function is not thread-safe. Call get_xlate_handle_node    instead. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_xlate_handle_node_internal
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
specifier|const
name|char
modifier|*
name|userdata_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* If we already have a handle, just return it. */
if|if
condition|(
name|userdata_key
operator|&&
name|xlate_handle_hash
condition|)
block|{
name|xlate_handle_node_t
modifier|*
name|old_node
init|=
name|NULL
decl_stmt|;
comment|/* 2nd level: hash lookup */
name|xlate_handle_node_t
modifier|*
modifier|*
name|old_node_p
init|=
name|svn_hash_gets
argument_list|(
name|xlate_handle_hash
argument_list|,
name|userdata_key
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_node_p
condition|)
name|old_node
operator|=
operator|*
name|old_node_p
expr_stmt|;
if|if
condition|(
name|old_node
condition|)
block|{
comment|/* Ensure that the handle is still valid. */
if|if
condition|(
name|old_node
operator|->
name|valid
condition|)
block|{
comment|/* Remove from the list. */
operator|*
name|old_node_p
operator|=
name|old_node
operator|->
name|next
expr_stmt|;
name|old_node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|ret
operator|=
name|old_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
comment|/* Note that we still have the mutex locked (if it is initialized), so we      can use the global pool for creating the new xlate handle. */
comment|/* Use the correct pool for creating the handle. */
name|pool
operator|=
name|apr_hash_pool_get
argument_list|(
name|xlate_handle_hash
argument_list|)
expr_stmt|;
return|return
name|xlate_alloc_handle
argument_list|(
name|ret
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *RET to a handle node for converting from FROMPAGE to TOPAGE,    creating the handle node if it doesn't exist in USERDATA_KEY.    If a node is not cached and apr_xlate_open() returns APR_EINVAL or    APR_ENOTIMPL, set (*RET)->handle to NULL.  If fail for any other    reason, return the error.     Allocate *RET and its xlate handle in POOL if svn_utf_initialize()    hasn't been called or USERDATA_KEY is NULL.  Else, allocate them    in the pool of xlate_handle_hash. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_xlate_handle_node
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
specifier|const
name|char
modifier|*
name|userdata_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|old_node
init|=
name|NULL
decl_stmt|;
comment|/* If we already have a handle, just return it. */
if|if
condition|(
name|userdata_key
condition|)
block|{
if|if
condition|(
name|xlate_handle_hash
condition|)
block|{
comment|/* 1st level: global, static items */
if|if
condition|(
name|userdata_key
operator|==
name|SVN_UTF_NTOU_XLATE_HANDLE
condition|)
name|old_node
operator|=
name|atomic_swap
argument_list|(
operator|&
name|xlat_ntou_static_handle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|userdata_key
operator|==
name|SVN_UTF_UTON_XLATE_HANDLE
condition|)
name|old_node
operator|=
name|atomic_swap
argument_list|(
operator|&
name|xlat_uton_static_handle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_node
operator|&&
name|old_node
operator|->
name|valid
condition|)
block|{
operator|*
name|ret
operator|=
name|old_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* We fall back on a per-pool cache instead. */
name|apr_pool_userdata_get
argument_list|(
operator|&
name|p
argument_list|,
name|userdata_key
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|old_node
operator|=
name|p
expr_stmt|;
comment|/* Ensure that the handle is still valid. */
if|if
condition|(
name|old_node
operator|&&
name|old_node
operator|->
name|valid
condition|)
block|{
operator|*
name|ret
operator|=
name|old_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|xlate_alloc_handle
argument_list|(
name|ret
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
return|;
block|}
block|}
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|xlate_handle_mutex
argument_list|,
name|get_xlate_handle_node_internal
argument_list|(
name|ret
argument_list|,
name|topage
argument_list|,
name|frompage
argument_list|,
name|userdata_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Put back NODE into the xlate handle cache for use by other calls.     Note: this function is not thread-safe. Call put_xlate_handle_node    instead. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|put_xlate_handle_node_internal
parameter_list|(
name|xlate_handle_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|userdata_key
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
modifier|*
name|node_p
init|=
name|svn_hash_gets
argument_list|(
name|xlate_handle_hash
argument_list|,
name|userdata_key
argument_list|)
decl_stmt|;
if|if
condition|(
name|node_p
operator|==
name|NULL
condition|)
block|{
name|userdata_key
operator|=
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|xlate_handle_hash
argument_list|)
argument_list|,
name|userdata_key
argument_list|)
expr_stmt|;
name|node_p
operator|=
name|apr_palloc
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|xlate_handle_hash
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node_p
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|node_p
operator|=
name|NULL
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|xlate_handle_hash
argument_list|,
name|userdata_key
argument_list|,
name|node_p
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|next
operator|=
operator|*
name|node_p
expr_stmt|;
operator|*
name|node_p
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Put back NODE into the xlate handle cache for use by other calls.    If there is no global cache, store the handle in POOL.    Ignore errors related to locking/unlocking the mutex. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|put_xlate_handle_node
parameter_list|(
name|xlate_handle_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|userdata_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|assert
argument_list|(
name|node
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|userdata_key
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* push previous global node to the hash */
if|if
condition|(
name|xlate_handle_hash
condition|)
block|{
comment|/* 1st level: global, static items */
if|if
condition|(
name|userdata_key
operator|==
name|SVN_UTF_NTOU_XLATE_HANDLE
condition|)
name|node
operator|=
name|atomic_swap
argument_list|(
operator|&
name|xlat_ntou_static_handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|userdata_key
operator|==
name|SVN_UTF_UTON_XLATE_HANDLE
condition|)
name|node
operator|=
name|atomic_swap
argument_list|(
operator|&
name|xlat_uton_static_handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|xlate_handle_mutex
argument_list|,
name|put_xlate_handle_node_internal
argument_list|(
name|node
argument_list|,
name|userdata_key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Store it in the per-pool cache. */
name|apr_pool_userdata_set
argument_list|(
name|node
argument_list|,
name|userdata_key
argument_list|,
name|apr_pool_cleanup_null
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the apr_xlate handle for converting native characters to UTF-8. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_ntou_xlate_handle_node
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|get_xlate_handle_node
argument_list|(
name|ret
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|assume_native_charset_is_utf8
condition|?
name|SVN_APR_UTF8_CHARSET
else|:
name|SVN_APR_LOCALE_CHARSET
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the apr_xlate handle for converting UTF-8 to native characters.    Create one if it doesn't exist.  If unable to find a handle, or    unable to create one because apr_xlate_open returned APR_EINVAL, then    set *RET to null and return SVN_NO_ERROR; if fail for some other    reason, return error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_uton_xlate_handle_node
parameter_list|(
name|xlate_handle_node_t
modifier|*
modifier|*
name|ret
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|get_xlate_handle_node
argument_list|(
name|ret
argument_list|,
name|assume_native_charset_is_utf8
condition|?
name|SVN_APR_UTF8_CHARSET
else|:
name|SVN_APR_LOCALE_CHARSET
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of SRC, converting non-ASCII and zero bytes to ?\nnn    sequences, allocating the result in POOL. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fuzzy_escape
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|src_orig
init|=
name|src
decl_stmt|,
modifier|*
name|src_end
init|=
name|src
operator|+
name|len
decl_stmt|;
name|apr_size_t
name|new_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_orig
decl_stmt|;
comment|/* First count how big a dest string we'll need. */
while|while
condition|(
name|src
operator|<
name|src_end
condition|)
block|{
if|if
condition|(
operator|!
name|svn_ctype_isascii
argument_list|(
operator|*
name|src
argument_list|)
operator|||
operator|*
name|src
operator|==
literal|'\0'
condition|)
name|new_len
operator|+=
literal|5
expr_stmt|;
comment|/* 5 slots, for "?\XXX" */
else|else
name|new_len
operator|+=
literal|1
expr_stmt|;
comment|/* one slot for the 7-bit char */
name|src
operator|++
expr_stmt|;
block|}
comment|/* Allocate that amount, plus one slot for '\0' character. */
name|new
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|new_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_orig
operator|=
name|new
expr_stmt|;
comment|/* And fill it up. */
while|while
condition|(
name|src_orig
operator|<
name|src_end
condition|)
block|{
if|if
condition|(
operator|!
name|svn_ctype_isascii
argument_list|(
operator|*
name|src_orig
argument_list|)
operator|||
name|src_orig
operator|==
literal|'\0'
condition|)
block|{
comment|/* This is the same format as svn_xml_fuzzy_escape uses, but that              function escapes different characters.  Please keep in sync!              ### If we add another fuzzy escape somewhere, we should abstract              ### this out to a common function. */
name|apr_snprintf
argument_list|(
name|new
argument_list|,
literal|6
argument_list|,
literal|"?\\%03u"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src_orig
argument_list|)
expr_stmt|;
name|new
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
operator|*
name|new
operator|=
operator|*
name|src_orig
expr_stmt|;
name|new
operator|+=
literal|1
expr_stmt|;
block|}
name|src_orig
operator|++
expr_stmt|;
block|}
operator|*
name|new
operator|=
literal|'\0'
expr_stmt|;
return|return
name|new_orig
return|;
block|}
end_function

begin_comment
comment|/* Convert SRC_LENGTH bytes of SRC_DATA in NODE->handle, store the result    in *DEST, which is allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|convert_to_stringbuf
parameter_list|(
name|xlate_handle_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|src_data
parameter_list|,
name|apr_size_t
name|src_length
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|dest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WIN32
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_err
operator|=
name|svn_subr__win32_xlate_to_stringbuf
argument_list|(
operator|(
name|win32_xlate_t
operator|*
operator|)
name|node
operator|->
name|handle
argument_list|,
name|src_data
argument_list|,
name|src_length
argument_list|,
name|dest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|apr_size_t
name|buflen
init|=
name|src_length
operator|*
literal|2
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_size_t
name|srclen
init|=
name|src_length
decl_stmt|;
name|apr_size_t
name|destlen
init|=
name|buflen
decl_stmt|;
comment|/* Initialize *DEST to an empty stringbuf.      A 1:2 ratio of input bytes to output bytes (as assigned above)      should be enough for most translations, and if it turns out not      to be enough, we'll grow the buffer again, sizing it based on a      1:3 ratio of the remainder of the string. */
operator|*
name|dest
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|buflen
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Not only does it not make sense to convert an empty string, but      apr-iconv is quite unreasonable about not allowing that. */
if|if
condition|(
name|src_length
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
do|do
block|{
comment|/* Set up state variables for xlate. */
name|destlen
operator|=
name|buflen
operator|-
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
expr_stmt|;
comment|/* Attempt the conversion. */
name|apr_err
operator|=
name|apr_xlate_conv_buffer
argument_list|(
name|node
operator|->
name|handle
argument_list|,
name|src_data
operator|+
operator|(
name|src_length
operator|-
name|srclen
operator|)
argument_list|,
operator|&
name|srclen
argument_list|,
operator|(
operator|*
name|dest
operator|)
operator|->
name|data
operator|+
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
argument_list|,
operator|&
name|destlen
argument_list|)
expr_stmt|;
comment|/* Now, update the *DEST->len to track the amount of output data          churned out so far from this loop. */
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
operator|+=
operator|(
operator|(
name|buflen
operator|-
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
operator|)
operator|-
name|destlen
operator|)
expr_stmt|;
name|buflen
operator|+=
name|srclen
operator|*
literal|3
expr_stmt|;
comment|/* 3 is middle ground, 2 wasn't enough                                for all characters in the buffer, 4 is                                maximum character size (currently) */
block|}
do|while
condition|(
name|apr_err
operator|==
name|APR_SUCCESS
operator|&&
name|srclen
operator|!=
literal|0
condition|)
do|;
endif|#
directive|endif
comment|/* If we exited the loop with an error, return the error. */
if|if
condition|(
name|apr_err
condition|)
block|{
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Can't use svn_error_wrap_apr here because it calls functions in          this file, leading to infinite recursion. */
if|if
condition|(
name|node
operator|->
name|frompage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't convert string from native encoding to '%s':"
argument_list|)
argument_list|,
name|node
operator|->
name|topage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|topage
operator|==
name|SVN_APR_LOCALE_CHARSET
condition|)
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't convert string from '%s' to native encoding:"
argument_list|)
argument_list|,
name|node
operator|->
name|frompage
argument_list|)
expr_stmt|;
else|else
name|errstr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't convert string from '%s' to '%s':"
argument_list|)
argument_list|,
name|node
operator|->
name|frompage
argument_list|,
name|node
operator|->
name|topage
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|fuzzy_escape
argument_list|(
name|src_data
argument_list|,
name|src_length
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|err
argument_list|,
name|errstr
argument_list|)
return|;
block|}
comment|/* Else, exited due to success.  Trim the result buffer down to the      right length. */
operator|(
operator|*
name|dest
operator|)
operator|->
name|data
index|[
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return APR_EINVAL if the first LEN bytes of DATA contain anything    other than seven-bit, non-control (except for whitespace) ASCII    characters, finding the error pool from POOL.  Otherwise, return    SVN_NO_ERROR. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_non_ascii
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|data_start
init|=
name|data
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
name|data
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|svn_ctype_isascii
argument_list|(
operator|*
name|data
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|svn_ctype_isspace
argument_list|(
operator|*
name|data
argument_list|)
operator|)
operator|&&
name|svn_ctype_iscntrl
argument_list|(
operator|*
name|data
argument_list|)
operator|)
condition|)
block|{
comment|/* Show the printable part of the data, followed by the              decimal code of the questionable character.  Because if a              user ever gets this error, she's going to have to spend              time tracking down the non-ASCII data, so we want to help              as much as possible.  And yes, we just call the unsafe              data "non-ASCII", even though the actual constraint is              somewhat more complex than that. */
if|if
condition|(
name|data
operator|-
name|data_start
condition|)
block|{
specifier|const
name|char
modifier|*
name|error_data
init|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|data_start
argument_list|,
operator|(
name|data
operator|-
name|data_start
operator|)
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Safe data '%s' was followed by non-ASCII byte %d: "
literal|"unable to convert to/from UTF-8"
argument_list|)
argument_list|,
name|error_data
argument_list|,
operator|*
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
operator|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Non-ASCII character (code %d) detected, "
literal|"and unable to convert to/from UTF-8"
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
operator|)
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Construct an error with code APR_EINVAL and with a suitable message  * to describe the invalid UTF-8 sequence DATA of length LEN (which  * may have embedded NULLs).  We can't simply print the data, almost  * by definition we don't really know how it is encoded.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|invalid_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|last
init|=
name|svn_utf__last_valid
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|valid_txt
init|=
literal|""
decl_stmt|,
modifier|*
name|invalid_txt
init|=
literal|""
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|size_t
name|valid
decl_stmt|,
name|invalid
decl_stmt|;
comment|/* We will display at most 24 valid octets (this may split a leading      multi-byte character) as that should fit on one 80 character line. */
name|valid
operator|=
name|last
operator|-
name|data
expr_stmt|;
if|if
condition|(
name|valid
operator|>
literal|24
condition|)
name|valid
operator|=
literal|24
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|valid
condition|;
operator|++
name|i
control|)
name|valid_txt
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|valid_txt
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|" %02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|last
index|[
name|i
operator|-
name|valid
index|]
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 4 invalid octets will guarantee that the faulty octet is displayed */
name|invalid
operator|=
name|data
operator|+
name|len
operator|-
name|last
expr_stmt|;
if|if
condition|(
name|invalid
operator|>
literal|4
condition|)
name|invalid
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|invalid
condition|;
operator|++
name|i
control|)
name|invalid_txt
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|invalid_txt
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|" %02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|last
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Valid UTF-8 data\n(hex:%s)\n"
literal|"followed by invalid UTF-8 sequence\n(hex:%s)"
argument_list|)
argument_list|,
name|valid_txt
argument_list|,
name|invalid_txt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the sequence DATA of length LEN is valid UTF-8.    If it is not, return an error with code APR_EINVAL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_utf__is_valid
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|invalid_utf8
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that the NULL terminated sequence DATA is valid UTF-8.    If it is not, return an error with code APR_EINVAL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_cstring_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_utf__cstring_is_valid
argument_list|(
name|data
argument_list|)
condition|)
return|return
name|invalid_utf8
argument_list|(
name|data
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_stringbuf_to_utf8
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_ntou_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|dest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|check_utf8
argument_list|(
operator|(
operator|*
name|dest
operator|)
operator|->
name|data
argument_list|,
operator|(
operator|*
name|dest
operator|)
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_stringbuf_dup
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_string_to_utf8
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|destbuf
decl_stmt|;
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_ntou_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
operator|&
name|destbuf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|check_utf8
argument_list|(
name|destbuf
operator|->
name|data
argument_list|,
name|destbuf
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|destbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_string_dup
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Common implementation for svn_utf_cstring_to_utf8,    svn_utf_cstring_to_utf8_ex, svn_utf_cstring_from_utf8 and    svn_utf_cstring_from_utf8_ex. Convert SRC to DEST using NODE->handle as    the translator and allocating from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|convert_cstring
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|xlate_handle_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|destbuf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
argument_list|,
name|strlen
argument_list|(
name|src
argument_list|)
argument_list|,
operator|&
name|destbuf
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|destbuf
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_non_ascii
argument_list|(
name|src
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_ntou_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|convert_cstring
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|check_cstring_utf8
argument_list|(
operator|*
name|dest
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_to_utf8_ex2
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|convset_key
init|=
name|get_xlate_key
argument_list|(
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|frompage
argument_list|,
name|convset_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|convert_cstring
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_NTOU_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|check_cstring_utf8
argument_list|(
operator|*
name|dest
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_to_utf8_ex
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|frompage
parameter_list|,
specifier|const
name|char
modifier|*
name|convset_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_utf_cstring_to_utf8_ex2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|frompage
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_stringbuf_from_utf8
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_uton_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|check_utf8
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|dest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_stringbuf_dup
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_string_from_utf8
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|dbuf
decl_stmt|;
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_uton_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|check_utf8
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
operator|&
name|dbuf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|svn_string_dup
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_from_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cstring_utf8
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_uton_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|convert_cstring
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_from_utf8_ex2
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|convset_key
init|=
name|get_xlate_key
argument_list|(
name|topage
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cstring_utf8
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|topage
argument_list|,
name|SVN_APR_UTF8_CHARSET
argument_list|,
name|convset_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|convert_cstring
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|convset_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_from_utf8_ex
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|topage
parameter_list|,
specifier|const
name|char
modifier|*
name|convset_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_utf_cstring_from_utf8_ex2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|topage
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_utf__cstring_from_utf8_fuzzy
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|convert_from_utf8
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|)
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|escaped
decl_stmt|,
modifier|*
name|converted
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|escaped
operator|=
name|fuzzy_escape
argument_list|(
name|src
argument_list|,
name|strlen
argument_list|(
name|src
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Okay, now we have a *new* UTF-8 string, one that's guaranteed to      contain only 7-bit bytes :-).  Recode to native... */
name|err
operator|=
name|convert_from_utf8
argument_list|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|converted
operator|)
argument_list|,
name|escaped
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|escaped
return|;
block|}
else|else
return|return
name|converted
return|;
comment|/* ### Check the client locale, maybe we can avoid that second    * conversion!  See Ulrich Drepper's patch at    * http://subversion.tigris.org/issues/show_bug.cgi?id=807.    */
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_utf_cstring_from_utf8_fuzzy
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_utf__cstring_from_utf8_fuzzy
argument_list|(
name|src
argument_list|,
name|pool
argument_list|,
name|svn_utf_cstring_from_utf8
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_from_utf8_stringbuf
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_stringbuf_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|destbuf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_stringbuf_from_utf8
argument_list|(
operator|&
name|destbuf
argument_list|,
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|destbuf
operator|->
name|data
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf_cstring_from_utf8_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|dbuf
decl_stmt|;
name|xlate_handle_node_t
modifier|*
name|node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_uton_xlate_handle_node
argument_list|(
operator|&
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|handle
condition|)
block|{
name|err
operator|=
name|check_utf8
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|convert_to_stringbuf
argument_list|(
name|node
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
operator|&
name|dbuf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|dbuf
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|check_non_ascii
argument_list|(
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|dest
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|src
operator|->
name|data
argument_list|,
name|src
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|put_xlate_handle_node
argument_list|(
name|node
argument_list|,
name|SVN_UTF_UTON_XLATE_HANDLE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

