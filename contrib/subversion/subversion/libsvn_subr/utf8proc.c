begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * utf8proc.c:  Wrappers for the utf8proc library  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr_fnmatch.h>
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_define
define|#
directive|define
name|UTF8PROC_INLINE
end_define

begin_comment
comment|/* Somehow utf8proc thinks it is nice to use strlen as an argument name,    while this function is already defined via apr.h */
end_comment

begin_define
define|#
directive|define
name|strlen
value|svn__strlen_var
end_define

begin_include
include|#
directive|include
file|"utf8proc/utf8proc.c"
end_include

begin_undef
undef|#
directive|undef
name|strlen
end_undef

begin_escape
end_escape

begin_function
specifier|const
name|char
modifier|*
name|svn_utf__utf8proc_compiled_version
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|utf8proc_version
index|[]
init|=
name|APR_STRINGIFY
argument_list|(
name|UTF8PROC_VERSION_MAJOR
argument_list|)
literal|"."
name|APR_STRINGIFY
argument_list|(
name|UTF8PROC_VERSION_MINOR
argument_list|)
literal|"."
name|APR_STRINGIFY
argument_list|(
name|UTF8PROC_VERSION_PATCH
argument_list|)
decl_stmt|;
return|return
name|utf8proc_version
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_utf__utf8proc_runtime_version
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Unused static function warning removal hack. */
name|SVN_UNUSED
argument_list|(
name|utf8proc_NFD
argument_list|)
expr_stmt|;
name|SVN_UNUSED
argument_list|(
name|utf8proc_NFC
argument_list|)
expr_stmt|;
name|SVN_UNUSED
argument_list|(
name|utf8proc_NFKD
argument_list|)
expr_stmt|;
name|SVN_UNUSED
argument_list|(
name|utf8proc_NFKC
argument_list|)
expr_stmt|;
return|return
name|utf8proc_version
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Fill the given BUFFER with decomposed UCS-4 representation of the  * UTF-8 STRING. If LENGTH is SVN_UTF__UNKNOWN_LENGTH, assume STRING  * is NUL-terminated; otherwise look only at the first LENGTH bytes in  * STRING. Upon return, BUFFER->data points at an array of UCS-4  * characters, and return the length of the array. TRANSFORM_FLAGS  * define exactly how the decomposition is performed.  *  * A negative return value is an utf8proc error code and may indicate  * that STRING contains invalid UTF-8 or was so long that an overflow  * occurred.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|unicode_decomposition
parameter_list|(
name|int
name|transform_flags
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_size_t
name|length
parameter_list|,
name|svn_membuf_t
modifier|*
name|buffer
parameter_list|)
block|{
specifier|const
name|int
name|nullterm
init|=
operator|(
name|length
operator|==
name|SVN_UTF__UNKNOWN_LENGTH
condition|?
name|UTF8PROC_NULLTERM
else|:
literal|0
operator|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|apr_int32_t
modifier|*
specifier|const
name|ucs4buf
init|=
name|buffer
operator|->
name|data
decl_stmt|;
specifier|const
name|ssize_t
name|ucs4len
init|=
name|buffer
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|ucs4buf
argument_list|)
decl_stmt|;
specifier|const
name|ssize_t
name|result
init|=
name|utf8proc_decompose
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
name|string
argument_list|,
name|length
argument_list|,
name|ucs4buf
argument_list|,
name|ucs4len
argument_list|,
name|UTF8PROC_DECOMPOSE
operator||
name|UTF8PROC_STABLE
operator||
name|transform_flags
operator||
name|nullterm
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
operator|||
name|result
operator|<=
name|ucs4len
condition|)
return|return
name|result
return|;
comment|/* Increase the decomposition buffer size and retry */
name|svn_membuf__ensure
argument_list|(
name|buffer
argument_list|,
name|result
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ucs4buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill the given BUFFER with an NFD UCS-4 representation of the UTF-8  * STRING. If LENGTH is SVN_UTF__UNKNOWN_LENGTH, assume STRING is  * NUL-terminated; otherwise look only at the first LENGTH bytes in  * STRING. Upon return, BUFFER->data points at an array of UCS-4  * characters and *RESULT_LENGTH contains the length of the array.  *  * A returned error may indicate that STRING contains invalid UTF-8 or  * invalid Unicode codepoints. Any error message comes from utf8proc.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|decompose_normalized
parameter_list|(
name|apr_size_t
modifier|*
name|result_length
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_size_t
name|length
parameter_list|,
name|svn_membuf_t
modifier|*
name|buffer
parameter_list|)
block|{
name|ssize_t
name|result
init|=
name|unicode_decomposition
argument_list|(
literal|0
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UTF8PROC_ERROR
argument_list|,
name|NULL
argument_list|,
name|gettext
argument_list|(
name|utf8proc_errmsg
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
return|;
operator|*
name|result_length
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fill the given BUFFER with an NFC UTF-8 representation of the UTF-8  * STRING. If LENGTH is SVN_UTF__UNKNOWN_LENGTH, assume STRING is  * NUL-terminated; otherwise look only at the first LENGTH bytes in  * STRING. Upon return, BUFFER->data points at a NUL-terminated string  * of UTF-8 characters.  *  * A returned error may indicate that STRING contains invalid UTF-8 or  * invalid Unicode codepoints. Any error message comes from utf8proc.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|normalize_cstring
parameter_list|(
name|apr_size_t
modifier|*
name|result_length
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_size_t
name|length
parameter_list|,
name|svn_membuf_t
modifier|*
name|buffer
parameter_list|)
block|{
name|ssize_t
name|result
init|=
name|unicode_decomposition
argument_list|(
literal|0
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
block|{
name|svn_membuf__resize
argument_list|(
name|buffer
argument_list|,
name|result
operator|*
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|utf8proc_reencode
argument_list|(
name|buffer
operator|->
name|data
argument_list|,
name|result
argument_list|,
name|UTF8PROC_COMPOSE
operator||
name|UTF8PROC_STABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UTF8PROC_ERROR
argument_list|,
name|NULL
argument_list|,
name|gettext
argument_list|(
name|utf8proc_errmsg
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
return|;
operator|*
name|result_length
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compare two arrays of UCS-4 codes, BUFA of length LENA and BUFB of  * length LENB. Return 0 if they're equal, a negative value if BUFA is  * less than BUFB, otherwise a positive value.  *  * Yes, this is strcmp for known-length UCS-4 strings.  */
end_comment

begin_function
specifier|static
name|int
name|ucs4cmp
parameter_list|(
specifier|const
name|apr_int32_t
modifier|*
name|bufa
parameter_list|,
name|apr_size_t
name|lena
parameter_list|,
specifier|const
name|apr_int32_t
modifier|*
name|bufb
parameter_list|,
name|apr_size_t
name|lenb
parameter_list|)
block|{
specifier|const
name|apr_size_t
name|len
init|=
operator|(
name|lena
operator|<
name|lenb
condition|?
name|lena
else|:
name|lenb
operator|)
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|diff
init|=
name|bufa
index|[
name|i
index|]
operator|-
name|bufb
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
block|}
return|return
operator|(
name|lena
operator|==
name|lenb
condition|?
literal|0
else|:
operator|(
name|lena
operator|<
name|lenb
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf__normcmp
parameter_list|(
name|int
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
name|apr_size_t
name|len1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|,
name|apr_size_t
name|len2
parameter_list|,
name|svn_membuf_t
modifier|*
name|buf1
parameter_list|,
name|svn_membuf_t
modifier|*
name|buf2
parameter_list|)
block|{
name|apr_size_t
name|buflen1
decl_stmt|;
name|apr_size_t
name|buflen2
decl_stmt|;
comment|/* Shortcut-circuit the decision if at least one of the strings is empty. */
specifier|const
name|svn_boolean_t
name|empty1
init|=
operator|(
literal|0
operator|==
name|len1
operator|||
operator|(
name|len1
operator|==
name|SVN_UTF__UNKNOWN_LENGTH
operator|&&
operator|!
operator|*
name|str1
operator|)
operator|)
decl_stmt|;
specifier|const
name|svn_boolean_t
name|empty2
init|=
operator|(
literal|0
operator|==
name|len2
operator|||
operator|(
name|len2
operator|==
name|SVN_UTF__UNKNOWN_LENGTH
operator|&&
operator|!
operator|*
name|str2
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|empty1
operator|||
name|empty2
condition|)
block|{
operator|*
name|result
operator|=
operator|(
name|empty1
operator|==
name|empty2
condition|?
literal|0
else|:
operator|(
name|empty1
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|decompose_normalized
argument_list|(
operator|&
name|buflen1
argument_list|,
name|str1
argument_list|,
name|len1
argument_list|,
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|decompose_normalized
argument_list|(
operator|&
name|buflen2
argument_list|,
name|str2
argument_list|,
name|len2
argument_list|,
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|ucs4cmp
argument_list|(
name|buf1
operator|->
name|data
argument_list|,
name|buflen1
argument_list|,
name|buf2
operator|->
name|data
argument_list|,
name|buflen2
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf__normalize
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_membuf_t
modifier|*
name|buf
parameter_list|)
block|{
name|apr_size_t
name|result_length
decl_stmt|;
name|SVN_ERR
argument_list|(
name|normalize_cstring
argument_list|(
operator|&
name|result_length
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|buf
operator|->
name|data
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Decode a single UCS-4 code point to UTF-8, appending the result to BUFFER.  * Assume BUFFER is already filled to *LENGTH and return the new size there.  * This function does *not* nul-terminate the stringbuf!  *  * A returned error indicates that the codepoint is invalid.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|encode_ucs4
parameter_list|(
name|svn_membuf_t
modifier|*
name|buffer
parameter_list|,
name|apr_int32_t
name|ucs4chr
parameter_list|,
name|apr_size_t
modifier|*
name|length
parameter_list|)
block|{
name|apr_size_t
name|utf8len
decl_stmt|;
if|if
condition|(
name|buffer
operator|->
name|size
operator|-
operator|*
name|length
operator|<
literal|4
condition|)
name|svn_membuf__resize
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|size
operator|+
literal|4
argument_list|)
expr_stmt|;
name|utf8len
operator|=
name|utf8proc_encode_char
argument_list|(
name|ucs4chr
argument_list|,
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|buffer
operator|->
name|data
operator|+
operator|*
name|length
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|utf8len
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UTF8PROC_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid Unicode character U+%04lX"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|ucs4chr
argument_list|)
return|;
operator|*
name|length
operator|+=
name|utf8len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf__encode_ucs4_string
parameter_list|(
name|svn_membuf_t
modifier|*
name|buffer
parameter_list|,
specifier|const
name|apr_int32_t
modifier|*
name|ucs4str
parameter_list|,
name|apr_size_t
name|length
parameter_list|,
name|apr_size_t
modifier|*
name|result_length
parameter_list|)
block|{
operator|*
name|result_length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|encode_ucs4
argument_list|(
name|buffer
argument_list|,
operator|*
name|ucs4str
operator|++
argument_list|,
name|result_length
argument_list|)
argument_list|)
expr_stmt|;
name|svn_membuf__resize
argument_list|(
name|buffer
argument_list|,
operator|*
name|result_length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|->
name|data
operator|)
index|[
operator|*
name|result_length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_utf__glob
parameter_list|(
name|svn_boolean_t
modifier|*
name|match
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|apr_size_t
name|pattern_len
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_size_t
name|string_len
parameter_list|,
specifier|const
name|char
modifier|*
name|escape
parameter_list|,
name|apr_size_t
name|escape_len
parameter_list|,
name|svn_boolean_t
name|sql_like
parameter_list|,
name|svn_membuf_t
modifier|*
name|pattern_buf
parameter_list|,
name|svn_membuf_t
modifier|*
name|string_buf
parameter_list|,
name|svn_membuf_t
modifier|*
name|temp_buf
parameter_list|)
block|{
name|apr_size_t
name|patternbuf_len
decl_stmt|;
name|apr_size_t
name|tempbuf_len
decl_stmt|;
comment|/* If we're in GLOB mode, we don't do custom escape chars. */
if|if
condition|(
name|escape
operator|&&
operator|!
name|sql_like
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UTF8_GLOB
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot use a custom escape token"
literal|" in glob matching mode"
argument_list|)
argument_list|)
return|;
comment|/* Convert the patern to NFD UTF-8. We can't use the UCS-4 result      because apr_fnmatch can't handle it.*/
name|SVN_ERR
argument_list|(
name|decompose_normalized
argument_list|(
operator|&
name|tempbuf_len
argument_list|,
name|pattern
argument_list|,
name|pattern_len
argument_list|,
name|temp_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sql_like
condition|)
name|SVN_ERR
argument_list|(
name|svn_utf__encode_ucs4_string
argument_list|(
name|pattern_buf
argument_list|,
name|temp_buf
operator|->
name|data
argument_list|,
name|tempbuf_len
argument_list|,
operator|&
name|patternbuf_len
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Convert a LIKE pattern to a GLOB pattern that apr_fnmatch can use. */
specifier|const
name|apr_int32_t
modifier|*
name|like
init|=
name|temp_buf
operator|->
name|data
decl_stmt|;
name|apr_int32_t
name|ucs4esc
decl_stmt|;
name|svn_boolean_t
name|escaped
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|escape
condition|)
name|ucs4esc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Definitely an invalid UCS-4 character. */
else|else
block|{
specifier|const
name|int
name|nullterm
init|=
operator|(
name|escape_len
operator|==
name|SVN_UTF__UNKNOWN_LENGTH
condition|?
name|UTF8PROC_NULLTERM
else|:
literal|0
operator|)
decl_stmt|;
name|ssize_t
name|result
init|=
name|utf8proc_decompose
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
name|escape
argument_list|,
name|escape_len
argument_list|,
operator|&
name|ucs4esc
argument_list|,
literal|1
argument_list|,
name|UTF8PROC_DECOMPOSE
operator||
name|UTF8PROC_STABLE
operator||
name|nullterm
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UTF8PROC_ERROR
argument_list|,
name|NULL
argument_list|,
name|gettext
argument_list|(
name|utf8proc_errmsg
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|result
operator|==
literal|0
operator|||
name|result
operator|>
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UTF8_GLOB
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Escape token must be one character"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|ucs4esc
operator|&
literal|0xFF
operator|)
operator|!=
name|ucs4esc
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UTF8_GLOB
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid escape character U+%04lX"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|ucs4esc
argument_list|)
return|;
block|}
name|patternbuf_len
operator|=
literal|0
expr_stmt|;
name|svn_membuf__ensure
argument_list|(
name|pattern_buf
argument_list|,
name|tempbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|escaped
operator|=
name|FALSE
init|;
name|i
operator|<
name|tempbuf_len
condition|;
operator|++
name|i
operator|,
operator|++
name|like
control|)
block|{
if|if
condition|(
operator|*
name|like
operator|==
name|ucs4esc
operator|&&
operator|!
name|escaped
condition|)
block|{
name|svn_membuf__resize
argument_list|(
name|pattern_buf
argument_list|,
name|patternbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|pattern_buf
operator|->
name|data
operator|)
index|[
name|patternbuf_len
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|escaped
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|escaped
condition|)
block|{
name|SVN_ERR
argument_list|(
name|encode_ucs4
argument_list|(
name|pattern_buf
argument_list|,
operator|*
name|like
argument_list|,
operator|&
name|patternbuf_len
argument_list|)
argument_list|)
expr_stmt|;
name|escaped
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|like
operator|==
literal|'['
operator|||
operator|*
name|like
operator|==
literal|'\\'
operator|)
operator|&&
operator|!
name|escaped
condition|)
block|{
comment|/* Escape brackets and backslashes which are always                      literals in LIKE patterns. */
name|svn_membuf__resize
argument_list|(
name|pattern_buf
argument_list|,
name|patternbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|pattern_buf
operator|->
name|data
operator|)
index|[
name|patternbuf_len
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|escaped
operator|=
name|TRUE
expr_stmt|;
operator|--
name|i
expr_stmt|;
operator|--
name|like
expr_stmt|;
continue|continue;
block|}
comment|/* Replace LIKE wildcards with their GLOB equivalents. */
if|if
condition|(
operator|*
name|like
operator|==
literal|'%'
operator|||
operator|*
name|like
operator|==
literal|'_'
condition|)
block|{
specifier|const
name|char
name|wildcard
init|=
operator|(
operator|*
name|like
operator|==
literal|'%'
condition|?
literal|'*'
else|:
literal|'?'
operator|)
decl_stmt|;
name|svn_membuf__resize
argument_list|(
name|pattern_buf
argument_list|,
name|patternbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|pattern_buf
operator|->
name|data
operator|)
index|[
name|patternbuf_len
operator|++
index|]
operator|=
name|wildcard
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|encode_ucs4
argument_list|(
name|pattern_buf
argument_list|,
operator|*
name|like
argument_list|,
operator|&
name|patternbuf_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_membuf__resize
argument_list|(
name|pattern_buf
argument_list|,
name|patternbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|pattern_buf
operator|->
name|data
operator|)
index|[
name|patternbuf_len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Now normalize the string */
name|SVN_ERR
argument_list|(
name|decompose_normalized
argument_list|(
operator|&
name|tempbuf_len
argument_list|,
name|string
argument_list|,
name|string_len
argument_list|,
name|temp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf__encode_ucs4_string
argument_list|(
name|string_buf
argument_list|,
name|temp_buf
operator|->
name|data
argument_list|,
name|tempbuf_len
argument_list|,
operator|&
name|tempbuf_len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|match
operator|=
operator|!
name|apr_fnmatch
argument_list|(
name|pattern_buf
operator|->
name|data
argument_list|,
name|string_buf
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_utf__is_normalized
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_membuf_t
name|buffer
decl_stmt|;
name|apr_size_t
name|result_length
decl_stmt|;
specifier|const
name|apr_size_t
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|svn_membuf__create
argument_list|(
operator|&
name|buffer
argument_list|,
name|length
operator|*
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|normalize_cstring
argument_list|(
operator|&
name|result_length
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
operator|(
name|length
operator|==
name|result_length
operator|&&
literal|0
operator|==
name|strcmp
argument_list|(
name|string
argument_list|,
name|buffer
operator|.
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_utf__fuzzy_escape
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_size_t
name|length
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Hexadecimal digits for code conversion. */
specifier|static
specifier|const
name|char
name|digits
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
comment|/* Flags used for Unicode decomposition. */
specifier|static
specifier|const
name|int
name|decomp_flags
init|=
operator|(
name|UTF8PROC_COMPAT
operator||
name|UTF8PROC_STABLE
operator||
name|UTF8PROC_LUMP
operator||
name|UTF8PROC_NLF2LF
operator||
name|UTF8PROC_STRIPCC
operator||
name|UTF8PROC_STRIPMARK
operator|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|result
decl_stmt|;
name|svn_membuf_t
name|buffer
decl_stmt|;
name|ssize_t
name|decomp_length
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
comment|/* Decompose to a non-reversible compatibility format. */
name|svn_membuf__create
argument_list|(
operator|&
name|buffer
argument_list|,
name|length
operator|*
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|decomp_length
operator|=
name|unicode_decomposition
argument_list|(
name|decomp_flags
argument_list|,
name|src
argument_list|,
name|length
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|decomp_length
operator|<
literal|0
condition|)
block|{
name|svn_membuf_t
name|part
decl_stmt|;
name|apr_size_t
name|done
decl_stmt|,
name|prev
decl_stmt|;
comment|/* The only other error we can receive here indicates an integer          overflow due to the length of the input string. Not very          likely, but we certainly shouldn't continue in that case. */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|decomp_length
operator|==
name|UTF8PROC_ERROR_INVALIDUTF8
argument_list|)
expr_stmt|;
comment|/* Break the decomposition into parts that are valid UTF-8, and          bytes that are not. Represent the invalid bytes in the target          erray by their negative value. This works because utf8proc          will not generate Unicode code points with values larger than          U+10FFFF. */
name|svn_membuf__create
argument_list|(
operator|&
name|part
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|decomp_length
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|prev
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|done
operator|<
name|length
condition|)
block|{
name|apr_int32_t
name|uc
decl_stmt|;
while|while
condition|(
name|done
operator|<
name|length
condition|)
block|{
name|len
operator|=
name|utf8proc_iterate
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|src
operator|+
name|done
argument_list|,
name|length
operator|-
name|done
argument_list|,
operator|&
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
break|break;
name|done
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Decompose the valid part */
if|if
condition|(
name|done
operator|>
name|prev
condition|)
block|{
name|len
operator|=
name|unicode_decomposition
argument_list|(
name|decomp_flags
argument_list|,
name|src
operator|+
name|prev
argument_list|,
name|done
operator|-
name|prev
argument_list|,
operator|&
name|part
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|svn_membuf__resize
argument_list|(
operator|&
name|buffer
argument_list|,
operator|(
name|decomp_length
operator|+
name|len
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|apr_int32_t
operator|*
operator|)
name|buffer
operator|.
name|data
operator|+
name|decomp_length
argument_list|,
name|part
operator|.
name|data
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|decomp_length
operator|+=
name|len
expr_stmt|;
name|prev
operator|=
name|done
expr_stmt|;
block|}
comment|/* What follows could be a valid UTF-8 sequence, but not              a valid Unicode character. */
if|if
condition|(
name|done
operator|<
name|length
condition|)
block|{
specifier|const
name|char
modifier|*
name|last
decl_stmt|;
comment|/* Determine the length of the UTF-8 sequence */
specifier|const
name|char
modifier|*
specifier|const
name|p
init|=
name|src
operator|+
name|done
decl_stmt|;
name|len
operator|=
name|utf8proc_utf8class
index|[
operator|(
name|uint8_t
operator|)
operator|*
name|p
index|]
expr_stmt|;
comment|/* Check if the multi-byte sequence is valid UTF-8. */
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|len
operator|<=
call|(
name|apr_ssize_t
call|)
argument_list|(
name|length
operator|-
name|done
argument_list|)
condition|)
name|last
operator|=
name|svn_utf__last_valid
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|last
operator|=
name|NULL
expr_stmt|;
comment|/* Might not be a valid UTF-8 sequence at all */
if|if
condition|(
operator|!
name|last
operator|||
operator|(
name|last
operator|&&
name|last
operator|-
name|p
operator|<
name|len
operator|)
condition|)
block|{
name|uc
operator|=
operator|-
operator|(
call|(
name|apr_int32_t
call|)
argument_list|(
operator|*
name|p
operator|&
literal|0xff
argument_list|)
operator|)
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|len
condition|)
block|{
comment|/* Decode the UTF-8 sequence without validation. */
case|case
literal|2
case|:
name|uc
operator|=
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
operator|<<
literal|6
operator|)
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|uc
operator|=
operator|(
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x0f
operator|)
operator|<<
literal|12
operator|)
operator|+
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator|+
operator|(
name|p
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|uc
operator|=
operator|(
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|<<
literal|18
operator|)
operator|+
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|12
operator|)
operator|+
operator|(
operator|(
name|p
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator|+
operator|(
name|p
index|[
literal|3
index|]
operator|&
literal|0x3f
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
operator|!
literal|"Unexpected invalid UTF-8 byte"
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_membuf__resize
argument_list|(
operator|&
name|buffer
argument_list|,
operator|(
name|decomp_length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|apr_int32_t
operator|*
operator|)
name|buffer
operator|.
name|data
operator|)
index|[
name|decomp_length
operator|++
index|]
operator|=
name|uc
expr_stmt|;
name|done
operator|+=
name|len
expr_stmt|;
name|prev
operator|=
name|done
expr_stmt|;
block|}
block|}
block|}
comment|/* Scan the result and deleting any combining diacriticals and      inserting placeholders where any non-ascii characters remain.  */
name|result
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|decomp_length
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|decomp_length
condition|;
operator|++
name|len
control|)
block|{
specifier|const
name|apr_int32_t
name|cp
init|=
operator|(
operator|(
name|apr_int32_t
operator|*
operator|)
name|buffer
operator|.
name|data
operator|)
index|[
name|len
index|]
decl_stmt|;
if|if
condition|(
name|cp
operator|>
literal|0
operator|&&
name|cp
operator|<
literal|127
condition|)
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
operator|(
name|char
operator|)
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|result
argument_list|,
literal|"\\0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|<
literal|0
condition|)
block|{
specifier|const
name|apr_int32_t
name|rcp
init|=
operator|(
operator|(
operator|-
name|cp
operator|)
operator|&
literal|0xff
operator|)
decl_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|result
argument_list|,
literal|"?\\"
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
name|digits
index|[
operator|(
name|rcp
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
name|digits
index|[
operator|(
name|rcp
operator|&
literal|0x000f
operator|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|utf8proc_codepoint_valid
argument_list|(
name|cp
argument_list|)
condition|)
block|{
specifier|const
name|utf8proc_property_t
modifier|*
name|prop
init|=
name|utf8proc_get_property
argument_list|(
name|cp
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|->
name|combining_class
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Combining mark; ignore */
name|svn_stringbuf_appendcstr
argument_list|(
name|result
argument_list|,
literal|"{U+"
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_stringbuf_appendcstr
argument_list|(
name|result
argument_list|,
literal|"{U?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>
literal|0xffff
condition|)
block|{
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
name|digits
index|[
operator|(
name|cp
operator|&
literal|0xf00000
operator|)
operator|>>
literal|20
index|]
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
name|digits
index|[
operator|(
name|cp
operator|&
literal|0x0f0000
operator|)
operator|>>
literal|16
index|]
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
name|digits
index|[
operator|(
name|cp
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
index|]
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
name|digits
index|[
operator|(
name|cp
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
index|]
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
name|digits
index|[
operator|(
name|cp
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
name|digits
index|[
operator|(
name|cp
operator|&
literal|0x000f
operator|)
index|]
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|result
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|->
name|data
return|;
block|}
end_function

end_unit

