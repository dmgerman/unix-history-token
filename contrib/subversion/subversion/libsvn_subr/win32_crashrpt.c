begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * win32_crashrpt.c : provides information after a crash  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* prevent "empty compilation unit" warning on e.g. UNIX */
end_comment

begin_typedef
typedef|typedef
name|int
name|win32_crashrpt__dummy
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_USE_WIN32_CRASHHANDLER
end_ifdef

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<dbghelp.h>
end_include

begin_include
include|#
directive|include
file|<direct.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"win32_crashrpt.h"
end_include

begin_include
include|#
directive|include
file|"win32_crashrpt_dll.h"
end_include

begin_comment
comment|/*** Global variables ***/
end_comment

begin_decl_stmt
name|HANDLE
name|dbghelp_dll
init|=
name|INVALID_HANDLE_VALUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Email address where the crash reports should be sent too. */
end_comment

begin_define
define|#
directive|define
name|CRASHREPORT_EMAIL
value|"users@subversion.apache.org"
end_define

begin_define
define|#
directive|define
name|DBGHELP_DLL
value|"dbghelp.dll"
end_define

begin_define
define|#
directive|define
name|LOGFILE_PREFIX
value|"svn-crash-log"
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
end_if

begin_define
define|#
directive|define
name|FORMAT_PTR
value|"0x%08x"
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_M_X64
argument_list|)
end_elif

begin_define
define|#
directive|define
name|FORMAT_PTR
value|"0x%016I64x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Convert a wide-character string to the current windows locale, suitable  * for directly using stdio. This function will create a buffer large  * enough to hold the result string, the caller should free this buffer.  * If the string can't be converted, NULL is returned.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|convert_wbcs_to_ansi
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|str
parameter_list|)
block|{
name|size_t
name|len
init|=
name|wcslen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|utf8_str
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|*
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|len
operator|=
name|wcstombs
argument_list|(
name|utf8_str
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|utf8_str
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|utf8_str
return|;
block|}
end_function

begin_comment
comment|/* Convert the exception code to a string */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|exception_string
parameter_list|(
name|int
name|exception
parameter_list|)
block|{
define|#
directive|define
name|EXCEPTION
parameter_list|(
name|x
parameter_list|)
value|case EXCEPTION_##x: return (#x);
switch|switch
condition|(
name|exception
condition|)
block|{
name|EXCEPTION
argument_list|(
argument|ACCESS_VIOLATION
argument_list|)
name|EXCEPTION
argument_list|(
argument|DATATYPE_MISALIGNMENT
argument_list|)
name|EXCEPTION
argument_list|(
argument|BREAKPOINT
argument_list|)
name|EXCEPTION
argument_list|(
argument|SINGLE_STEP
argument_list|)
name|EXCEPTION
argument_list|(
argument|ARRAY_BOUNDS_EXCEEDED
argument_list|)
name|EXCEPTION
argument_list|(
argument|FLT_DENORMAL_OPERAND
argument_list|)
name|EXCEPTION
argument_list|(
argument|FLT_DIVIDE_BY_ZERO
argument_list|)
name|EXCEPTION
argument_list|(
argument|FLT_INEXACT_RESULT
argument_list|)
name|EXCEPTION
argument_list|(
argument|FLT_INVALID_OPERATION
argument_list|)
name|EXCEPTION
argument_list|(
argument|FLT_OVERFLOW
argument_list|)
name|EXCEPTION
argument_list|(
argument|FLT_STACK_CHECK
argument_list|)
name|EXCEPTION
argument_list|(
argument|FLT_UNDERFLOW
argument_list|)
name|EXCEPTION
argument_list|(
argument|INT_DIVIDE_BY_ZERO
argument_list|)
name|EXCEPTION
argument_list|(
argument|INT_OVERFLOW
argument_list|)
name|EXCEPTION
argument_list|(
argument|PRIV_INSTRUCTION
argument_list|)
name|EXCEPTION
argument_list|(
argument|IN_PAGE_ERROR
argument_list|)
name|EXCEPTION
argument_list|(
argument|ILLEGAL_INSTRUCTION
argument_list|)
name|EXCEPTION
argument_list|(
argument|NONCONTINUABLE_EXCEPTION
argument_list|)
name|EXCEPTION
argument_list|(
argument|STACK_OVERFLOW
argument_list|)
name|EXCEPTION
argument_list|(
argument|INVALID_DISPOSITION
argument_list|)
name|EXCEPTION
argument_list|(
argument|GUARD_PAGE
argument_list|)
name|EXCEPTION
argument_list|(
argument|INVALID_HANDLE
argument_list|)
default|default:
return|return
literal|"UNKNOWN_ERROR"
return|;
block|}
undef|#
directive|undef
name|EXCEPTION
block|}
end_function

begin_comment
comment|/* Write the minidump to file. The callback function will at the same time    write the list of modules to the log file. */
end_comment

begin_function
specifier|static
name|BOOL
name|write_minidump_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|PEXCEPTION_POINTERS
name|ptrs
parameter_list|,
name|MINIDUMP_CALLBACK_ROUTINE
name|module_callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* open minidump file */
name|HANDLE
name|minidump_file
init|=
name|CreateFile
argument_list|(
name|file
argument_list|,
name|GENERIC_WRITE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CREATE_ALWAYS
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|minidump_file
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|MINIDUMP_EXCEPTION_INFORMATION
name|expt_info
decl_stmt|;
name|MINIDUMP_CALLBACK_INFORMATION
name|dump_cb_info
decl_stmt|;
name|expt_info
operator|.
name|ThreadId
operator|=
name|GetCurrentThreadId
argument_list|()
expr_stmt|;
name|expt_info
operator|.
name|ExceptionPointers
operator|=
name|ptrs
expr_stmt|;
name|expt_info
operator|.
name|ClientPointers
operator|=
name|FALSE
expr_stmt|;
name|dump_cb_info
operator|.
name|CallbackRoutine
operator|=
name|module_callback
expr_stmt|;
name|dump_cb_info
operator|.
name|CallbackParam
operator|=
name|data
expr_stmt|;
name|MiniDumpWriteDump_
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|GetCurrentProcessId
argument_list|()
argument_list|,
name|minidump_file
argument_list|,
name|MiniDumpNormal
argument_list|,
name|ptrs
condition|?
operator|&
name|expt_info
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dump_cb_info
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|minidump_file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Write module information to the log file */
end_comment

begin_function
specifier|static
name|BOOL
name|CALLBACK
name|write_module_info_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|CONST
name|PMINIDUMP_CALLBACK_INPUT
name|callback_input
parameter_list|,
name|PMINIDUMP_CALLBACK_OUTPUT
name|callback_output
parameter_list|)
block|{
if|if
condition|(
name|data
operator|!=
name|NULL
operator|&&
name|callback_input
operator|!=
name|NULL
operator|&&
name|callback_input
operator|->
name|CallbackType
operator|==
name|ModuleCallback
condition|)
block|{
name|FILE
modifier|*
name|log_file
init|=
operator|(
name|FILE
operator|*
operator|)
name|data
decl_stmt|;
name|MINIDUMP_MODULE_CALLBACK
name|module
init|=
name|callback_input
operator|->
name|Module
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|convert_wbcs_to_ansi
argument_list|(
name|module
operator|.
name|FullPath
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
name|FORMAT_PTR
argument_list|,
name|module
operator|.
name|BaseOfImage
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"  %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|" (%d.%d.%d.%d, %d bytes)\n"
argument_list|,
name|HIWORD
argument_list|(
name|module
operator|.
name|VersionInfo
operator|.
name|dwFileVersionMS
argument_list|)
argument_list|,
name|LOWORD
argument_list|(
name|module
operator|.
name|VersionInfo
operator|.
name|dwFileVersionMS
argument_list|)
argument_list|,
name|HIWORD
argument_list|(
name|module
operator|.
name|VersionInfo
operator|.
name|dwFileVersionLS
argument_list|)
argument_list|,
name|LOWORD
argument_list|(
name|module
operator|.
name|VersionInfo
operator|.
name|dwFileVersionLS
argument_list|)
argument_list|,
name|module
operator|.
name|SizeOfImage
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write details about the current process, platform and the exception */
end_comment

begin_function
specifier|static
name|void
name|write_process_info
parameter_list|(
name|EXCEPTION_RECORD
modifier|*
name|exception
parameter_list|,
name|CONTEXT
modifier|*
name|context
parameter_list|,
name|FILE
modifier|*
name|log_file
parameter_list|)
block|{
name|OSVERSIONINFOEXW
name|oi
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd_line
decl_stmt|;
name|char
name|workingdir
index|[
literal|8192
index|]
decl_stmt|;
comment|/* write the command line */
name|cmd_line
operator|=
name|GetCommandLine
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"Cmd line: %s\n"
argument_list|,
name|cmd_line
argument_list|)
expr_stmt|;
name|_getcwd
argument_list|(
name|workingdir
argument_list|,
sizeof|sizeof
argument_list|(
name|workingdir
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"Working Dir: %s\n"
argument_list|,
name|workingdir
argument_list|)
expr_stmt|;
comment|/* write the svn version number info. */
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"Version:  %s, compiled %s, %s\n"
argument_list|,
name|SVN_VERSION
argument_list|,
name|__DATE__
argument_list|,
name|__TIME__
argument_list|)
expr_stmt|;
comment|/* write information about the OS */
if|if
condition|(
name|svn_sysinfo___fill_windows_version
argument_list|(
operator|&
name|oi
argument_list|)
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"Platform: Windows OS version %d.%d build %d %S\n\n"
argument_list|,
name|oi
operator|.
name|dwMajorVersion
argument_list|,
name|oi
operator|.
name|dwMinorVersion
argument_list|,
name|oi
operator|.
name|dwBuildNumber
argument_list|,
name|oi
operator|.
name|szCSDVersion
argument_list|)
expr_stmt|;
comment|/* write the exception code */
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"Exception: %s\n\n"
argument_list|,
name|exception_string
argument_list|(
name|exception
operator|->
name|ExceptionCode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the register info. */
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"Registers:\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n"
argument_list|,
name|context
operator|->
name|Eax
argument_list|,
name|context
operator|->
name|Ebx
argument_list|,
name|context
operator|->
name|Ecx
argument_list|,
name|context
operator|->
name|Edx
argument_list|,
name|context
operator|->
name|Esi
argument_list|,
name|context
operator|->
name|Edi
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"eip=%08x esp=%08x ebp=%08x efl=%08x\n"
argument_list|,
name|context
operator|->
name|Eip
argument_list|,
name|context
operator|->
name|Esp
argument_list|,
name|context
operator|->
name|Ebp
argument_list|,
name|context
operator|->
name|EFlags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x\n"
argument_list|,
name|context
operator|->
name|SegCs
argument_list|,
name|context
operator|->
name|SegSs
argument_list|,
name|context
operator|->
name|SegDs
argument_list|,
name|context
operator|->
name|SegEs
argument_list|,
name|context
operator|->
name|SegFs
argument_list|,
name|context
operator|->
name|SegGs
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_M_X64
argument_list|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"Rax=%016I64x Rcx=%016I64x Rdx=%016I64x Rbx=%016I64x\n"
argument_list|,
name|context
operator|->
name|Rax
argument_list|,
name|context
operator|->
name|Rcx
argument_list|,
name|context
operator|->
name|Rdx
argument_list|,
name|context
operator|->
name|Rbx
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"Rsp=%016I64x Rbp=%016I64x Rsi=%016I64x Rdi=%016I64x\n"
argument_list|,
name|context
operator|->
name|Rsp
argument_list|,
name|context
operator|->
name|Rbp
argument_list|,
name|context
operator|->
name|Rsi
argument_list|,
name|context
operator|->
name|Rdi
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"R8= %016I64x R9= %016I64x R10=%016I64x R11=%016I64x\n"
argument_list|,
name|context
operator|->
name|R8
argument_list|,
name|context
operator|->
name|R9
argument_list|,
name|context
operator|->
name|R10
argument_list|,
name|context
operator|->
name|R11
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"R12=%016I64x R13=%016I64x R14=%016I64x R15=%016I64x\n"
argument_list|,
name|context
operator|->
name|R12
argument_list|,
name|context
operator|->
name|R13
argument_list|,
name|context
operator|->
name|R14
argument_list|,
name|context
operator|->
name|R15
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x\n"
argument_list|,
name|context
operator|->
name|SegCs
argument_list|,
name|context
operator|->
name|SegSs
argument_list|,
name|context
operator|->
name|SegDs
argument_list|,
name|context
operator|->
name|SegEs
argument_list|,
name|context
operator|->
name|SegFs
argument_list|,
name|context
operator|->
name|SegGs
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Unknown processortype, please disable SVN_USE_WIN32_CRASHHANDLER
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Formats the value at address based on the specified basic type  * (char, int, long ...). */
end_comment

begin_function
specifier|static
name|void
name|format_basic_type
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|DWORD
name|basic_type
parameter_list|,
name|DWORD64
name|length
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
block|{
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|1
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%02x"
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%04x"
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
switch|switch
condition|(
name|basic_type
condition|)
block|{
case|case
literal|2
case|:
comment|/* btChar */
block|{
if|if
condition|(
operator|!
name|IsBadStringPtr
argument_list|(
operator|*
operator|(
name|PSTR
operator|*
operator|)
name|address
argument_list|,
literal|32
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%.31s\""
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FORMAT_PTR
argument_list|,
operator|*
operator|(
name|DWORD_PTR
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
block|}
case|case
literal|6
case|:
comment|/* btInt */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* btFloat */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%f"
argument_list|,
operator|*
operator|(
name|float
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FORMAT_PTR
argument_list|,
operator|*
operator|(
name|DWORD_PTR
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|basic_type
operator|==
literal|8
condition|)
comment|/* btFloat */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lf"
argument_list|,
operator|*
operator|(
name|double
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%016I64X"
argument_list|,
operator|*
operator|(
name|unsigned
name|__int64
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[unhandled type 0x%08x of length "
name|FORMAT_PTR
literal|"]"
argument_list|,
name|basic_type
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Formats the value at address based on the type (pointer, user defined,  * basic type). */
end_comment

begin_function
specifier|static
name|void
name|format_value
parameter_list|(
name|char
modifier|*
name|value_str
parameter_list|,
name|DWORD64
name|mod_base
parameter_list|,
name|DWORD
name|type
parameter_list|,
name|void
modifier|*
name|value_addr
parameter_list|)
block|{
name|DWORD
name|tag
init|=
literal|0
decl_stmt|;
name|int
name|ptr
init|=
literal|0
decl_stmt|;
name|HANDLE
name|proc
init|=
name|GetCurrentProcess
argument_list|()
decl_stmt|;
while|while
condition|(
name|SymGetTypeInfo_
argument_list|(
name|proc
argument_list|,
name|mod_base
argument_list|,
name|type
argument_list|,
name|TI_GET_SYMTAG
argument_list|,
operator|&
name|tag
argument_list|)
condition|)
block|{
comment|/* SymTagPointerType */
if|if
condition|(
name|tag
operator|==
literal|14
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
name|SymGetTypeInfo_
argument_list|(
name|proc
argument_list|,
name|mod_base
argument_list|,
name|type
argument_list|,
name|TI_GET_TYPE
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
literal|11
case|:
comment|/* SymTagUDT */
block|{
name|WCHAR
modifier|*
name|type_name_wbcs
decl_stmt|;
if|if
condition|(
name|SymGetTypeInfo_
argument_list|(
name|proc
argument_list|,
name|mod_base
argument_list|,
name|type
argument_list|,
name|TI_GET_SYMNAME
argument_list|,
operator|&
name|type_name_wbcs
argument_list|)
condition|)
block|{
name|char
modifier|*
name|type_name
init|=
name|convert_wbcs_to_ansi
argument_list|(
name|type_name_wbcs
argument_list|)
decl_stmt|;
name|LocalFree
argument_list|(
name|type_name_wbcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|value_str
argument_list|,
literal|"(%s) "
name|FORMAT_PTR
argument_list|,
name|type_name
argument_list|,
operator|(
name|DWORD_PTR
operator|*
operator|)
name|value_addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ptr
operator|==
literal|1
condition|)
name|sprintf
argument_list|(
name|value_str
argument_list|,
literal|"(%s *) "
name|FORMAT_PTR
argument_list|,
name|type_name
argument_list|,
operator|*
operator|(
name|DWORD_PTR
operator|*
operator|)
name|value_addr
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|value_str
argument_list|,
literal|"(%s **) "
name|FORMAT_PTR
argument_list|,
name|type_name
argument_list|,
operator|*
operator|(
name|DWORD_PTR
operator|*
operator|)
name|value_addr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|type_name
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|value_str
argument_list|,
literal|"[no symbol tag]"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
comment|/* SymTagBaseType */
block|{
name|DWORD
name|bt
decl_stmt|;
name|ULONG64
name|length
decl_stmt|;
name|SymGetTypeInfo_
argument_list|(
name|proc
argument_list|,
name|mod_base
argument_list|,
name|type
argument_list|,
name|TI_GET_LENGTH
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/* print a char * as a string */
if|if
condition|(
name|ptr
operator|==
literal|1
operator|&&
name|length
operator|==
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|value_str
argument_list|,
name|FORMAT_PTR
literal|" \"%s\""
argument_list|,
operator|*
operator|(
name|DWORD_PTR
operator|*
operator|)
name|value_addr
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|value_addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|>=
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|value_str
argument_list|,
name|FORMAT_PTR
argument_list|,
operator|*
operator|(
name|DWORD_PTR
operator|*
operator|)
name|value_addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SymGetTypeInfo_
argument_list|(
name|proc
argument_list|,
name|mod_base
argument_list|,
name|type
argument_list|,
name|TI_GET_BASETYPE
argument_list|,
operator|&
name|bt
argument_list|)
condition|)
block|{
name|format_basic_type
argument_list|(
name|value_str
argument_list|,
name|bt
argument_list|,
name|length
argument_list|,
name|value_addr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|12
case|:
comment|/* SymTagEnum */
name|sprintf
argument_list|(
name|value_str
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
name|DWORD_PTR
operator|*
operator|)
name|value_addr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* SymTagFunctionType */
name|sprintf
argument_list|(
name|value_str
argument_list|,
name|FORMAT_PTR
argument_list|,
operator|*
operator|(
name|DWORD_PTR
operator|*
operator|)
name|value_addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|value_str
argument_list|,
literal|"[unhandled tag: %d]"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Internal structure used to pass some data to the enumerate symbols  * callback */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|symbols_baton_t
block|{
name|STACKFRAME64
modifier|*
name|stack_frame
decl_stmt|;
name|FILE
modifier|*
name|log_file
decl_stmt|;
name|int
name|nr_of_frame
decl_stmt|;
name|BOOL
name|log_params
decl_stmt|;
block|}
name|symbols_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Write the details of one parameter or local variable to the log file */
end_comment

begin_function
specifier|static
name|BOOL
name|WINAPI
name|write_var_values
parameter_list|(
name|PSYMBOL_INFO
name|sym_info
parameter_list|,
name|ULONG
name|sym_size
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
specifier|static
name|int
name|last_nr_of_frame
init|=
literal|0
decl_stmt|;
name|DWORD_PTR
name|var_data
init|=
literal|0
decl_stmt|;
comment|/* Will point to the variable's data in memory */
name|STACKFRAME64
modifier|*
name|stack_frame
init|=
operator|(
operator|(
name|symbols_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|stack_frame
decl_stmt|;
name|FILE
modifier|*
name|log_file
init|=
operator|(
operator|(
name|symbols_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|log_file
decl_stmt|;
name|int
name|nr_of_frame
init|=
operator|(
operator|(
name|symbols_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|nr_of_frame
decl_stmt|;
name|BOOL
name|log_params
init|=
operator|(
operator|(
name|symbols_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|log_params
decl_stmt|;
name|char
name|value_str
index|[
literal|256
index|]
init|=
literal|""
decl_stmt|;
comment|/* get the variable's data */
if|if
condition|(
name|sym_info
operator|->
name|Flags
operator|&
name|SYMFLAG_REGREL
condition|)
block|{
name|var_data
operator|=
operator|(
name|DWORD_PTR
operator|)
name|stack_frame
operator|->
name|AddrFrame
operator|.
name|Offset
expr_stmt|;
name|var_data
operator|+=
operator|(
name|DWORD_PTR
operator|)
name|sym_info
operator|->
name|Address
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|log_params
operator|&&
name|sym_info
operator|->
name|Flags
operator|&
name|SYMFLAG_PARAMETER
condition|)
block|{
if|if
condition|(
name|last_nr_of_frame
operator|==
name|nr_of_frame
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|", "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|last_nr_of_frame
operator|=
name|nr_of_frame
expr_stmt|;
name|format_value
argument_list|(
name|value_str
argument_list|,
name|sym_info
operator|->
name|ModBase
argument_list|,
name|sym_info
operator|->
name|TypeIndex
argument_list|,
operator|(
name|void
operator|*
operator|)
name|var_data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"%.*s=%s"
argument_list|,
operator|(
name|int
operator|)
name|sym_info
operator|->
name|NameLen
argument_list|,
name|sym_info
operator|->
name|Name
argument_list|,
name|value_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|log_params
operator|&&
name|sym_info
operator|->
name|Flags
operator|&
name|SYMFLAG_LOCAL
condition|)
block|{
name|format_value
argument_list|(
name|value_str
argument_list|,
name|sym_info
operator|->
name|ModBase
argument_list|,
name|sym_info
operator|->
name|TypeIndex
argument_list|,
operator|(
name|void
operator|*
operator|)
name|var_data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"        %.*s = %s\n"
argument_list|,
operator|(
name|int
operator|)
name|sym_info
operator|->
name|NameLen
argument_list|,
name|sym_info
operator|->
name|Name
argument_list|,
name|value_str
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write the details of one function to the log file */
end_comment

begin_function
specifier|static
name|void
name|write_function_detail
parameter_list|(
name|STACKFRAME64
name|stack_frame
parameter_list|,
name|int
name|nr_of_frame
parameter_list|,
name|FILE
modifier|*
name|log_file
parameter_list|)
block|{
name|ULONG64
name|symbolBuffer
index|[
operator|(
sizeof|sizeof
argument_list|(
name|SYMBOL_INFO
argument_list|)
operator|+
name|MAX_SYM_NAME
operator|+
sizeof|sizeof
argument_list|(
name|ULONG64
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|ULONG64
argument_list|)
index|]
decl_stmt|;
name|PSYMBOL_INFO
name|pIHS
init|=
operator|(
name|PSYMBOL_INFO
operator|)
name|symbolBuffer
decl_stmt|;
name|DWORD64
name|func_disp
init|=
literal|0
decl_stmt|;
name|IMAGEHLP_STACK_FRAME
name|ih_stack_frame
decl_stmt|;
name|IMAGEHLP_LINE64
name|ih_line
decl_stmt|;
name|DWORD
name|line_disp
init|=
literal|0
decl_stmt|;
name|HANDLE
name|proc
init|=
name|GetCurrentProcess
argument_list|()
decl_stmt|;
name|symbols_baton_t
name|ensym
decl_stmt|;
name|nr_of_frame
operator|++
expr_stmt|;
comment|/* We need a 1 based index here */
comment|/* log the function name */
name|pIHS
operator|->
name|SizeOfStruct
operator|=
sizeof|sizeof
argument_list|(
name|SYMBOL_INFO
argument_list|)
expr_stmt|;
name|pIHS
operator|->
name|MaxNameLen
operator|=
name|MAX_SYM_NAME
expr_stmt|;
if|if
condition|(
name|SymFromAddr_
argument_list|(
name|proc
argument_list|,
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Offset
argument_list|,
operator|&
name|func_disp
argument_list|,
name|pIHS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"#%d  0x%08I64x in %.*s("
argument_list|,
name|nr_of_frame
argument_list|,
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Offset
argument_list|,
name|pIHS
operator|->
name|NameLen
operator|>
literal|200
condition|?
literal|200
else|:
operator|(
name|int
operator|)
name|pIHS
operator|->
name|NameLen
argument_list|,
name|pIHS
operator|->
name|Name
argument_list|)
expr_stmt|;
comment|/* restrict symbol enumeration to this frame only */
name|ih_stack_frame
operator|.
name|InstructionOffset
operator|=
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Offset
expr_stmt|;
name|SymSetContext_
argument_list|(
name|proc
argument_list|,
operator|&
name|ih_stack_frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ensym
operator|.
name|log_file
operator|=
name|log_file
expr_stmt|;
name|ensym
operator|.
name|stack_frame
operator|=
operator|&
name|stack_frame
expr_stmt|;
name|ensym
operator|.
name|nr_of_frame
operator|=
name|nr_of_frame
expr_stmt|;
comment|/* log all function parameters */
name|ensym
operator|.
name|log_params
operator|=
name|TRUE
expr_stmt|;
name|SymEnumSymbols_
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|write_var_values
argument_list|,
operator|&
name|ensym
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"#%d  0x%08I64x in (unknown function)"
argument_list|,
name|nr_of_frame
argument_list|,
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Offset
argument_list|)
expr_stmt|;
block|}
comment|/* find the source line for this function. */
name|ih_line
operator|.
name|SizeOfStruct
operator|=
sizeof|sizeof
argument_list|(
name|IMAGEHLP_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|SymGetLineFromAddr64_
argument_list|(
name|proc
argument_list|,
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Offset
argument_list|,
operator|&
name|line_disp
argument_list|,
operator|&
name|ih_line
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|" at %s:%d\n"
argument_list|,
name|ih_line
operator|.
name|FileName
argument_list|,
name|ih_line
operator|.
name|LineNumber
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* log all function local variables */
name|ensym
operator|.
name|log_params
operator|=
name|FALSE
expr_stmt|;
name|SymEnumSymbols_
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|write_var_values
argument_list|,
operator|&
name|ensym
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk over the stack and log all relevant information to the log file */
end_comment

begin_function
specifier|static
name|void
name|write_stacktrace
parameter_list|(
name|CONTEXT
modifier|*
name|context
parameter_list|,
name|FILE
modifier|*
name|log_file
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_IA64
argument_list|)
name|HANDLE
name|proc
init|=
name|GetCurrentProcess
argument_list|()
decl_stmt|;
name|STACKFRAME64
name|stack_frame
decl_stmt|;
name|DWORD
name|machine
decl_stmt|;
name|CONTEXT
name|ctx
decl_stmt|;
name|int
name|skip
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
comment|/* The thread information - if not supplied. */
if|if
condition|(
name|context
operator|==
name|NULL
condition|)
block|{
comment|/* If no context is supplied, skip 1 frame */
name|skip
operator|=
literal|1
expr_stmt|;
name|ctx
operator|.
name|ContextFlags
operator|=
name|CONTEXT_FULL
expr_stmt|;
if|if
condition|(
operator|!
name|GetThreadContext
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
operator|&
name|ctx
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
name|ctx
operator|=
operator|*
name|context
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|==
name|NULL
condition|)
return|return;
comment|/* Write the stack trace */
name|ZeroMemory
argument_list|(
operator|&
name|stack_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|STACKFRAME64
argument_list|)
argument_list|)
expr_stmt|;
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Mode
operator|=
name|AddrModeFlat
expr_stmt|;
name|stack_frame
operator|.
name|AddrStack
operator|.
name|Mode
operator|=
name|AddrModeFlat
expr_stmt|;
name|stack_frame
operator|.
name|AddrFrame
operator|.
name|Mode
operator|=
name|AddrModeFlat
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
name|machine
operator|=
name|IMAGE_FILE_MACHINE_I386
expr_stmt|;
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Offset
operator|=
name|context
operator|->
name|Eip
expr_stmt|;
name|stack_frame
operator|.
name|AddrStack
operator|.
name|Offset
operator|=
name|context
operator|->
name|Esp
expr_stmt|;
name|stack_frame
operator|.
name|AddrFrame
operator|.
name|Offset
operator|=
name|context
operator|->
name|Ebp
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_M_X64
argument_list|)
name|machine
operator|=
name|IMAGE_FILE_MACHINE_AMD64
expr_stmt|;
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Offset
operator|=
name|context
operator|->
name|Rip
expr_stmt|;
name|stack_frame
operator|.
name|AddrStack
operator|.
name|Offset
operator|=
name|context
operator|->
name|Rsp
expr_stmt|;
name|stack_frame
operator|.
name|AddrFrame
operator|.
name|Offset
operator|=
name|context
operator|->
name|Rbp
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_M_IA64
argument_list|)
name|machine
operator|=
name|IMAGE_FILE_MACHINE_IA64
expr_stmt|;
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Offset
operator|=
name|context
operator|->
name|StIIP
expr_stmt|;
name|stack_frame
operator|.
name|AddrStack
operator|.
name|Offset
operator|=
name|context
operator|->
name|SP
expr_stmt|;
name|stack_frame
operator|.
name|AddrBStore
operator|.
name|Mode
operator|=
name|AddrModeFlat
expr_stmt|;
name|stack_frame
operator|.
name|AddrBStore
operator|.
name|Offset
operator|=
name|context
operator|->
name|RsBSP
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Unknown processortype, please disable SVN_USE_WIN32_CRASHHANDLER
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|StackWalk64_
argument_list|(
name|machine
argument_list|,
name|proc
argument_list|,
name|GetCurrentThread
argument_list|()
argument_list|,
operator|&
name|stack_frame
argument_list|,
operator|&
name|ctx
argument_list|,
name|NULL
argument_list|,
name|SymFunctionTableAccess64_
argument_list|,
name|SymGetModuleBase64_
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|skip
condition|)
block|{
comment|/* Try to include symbolic information.              Also check that the address is not zero. Sometimes StackWalk              returns TRUE with a frame of zero. */
if|if
condition|(
name|stack_frame
operator|.
name|AddrPC
operator|.
name|Offset
operator|!=
literal|0
condition|)
block|{
name|write_function_detail
argument_list|(
name|stack_frame
argument_list|,
name|i
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
error|Unknown processortype, please disable SVN_USE_WIN32_CRASHHANDLER
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Check if a debugger is attached to this process */
end_comment

begin_function
specifier|static
name|BOOL
name|is_debugger_present
parameter_list|()
block|{
name|HANDLE
name|kernel32_dll
init|=
name|LoadLibrary
argument_list|(
literal|"kernel32.dll"
argument_list|)
decl_stmt|;
name|BOOL
name|result
decl_stmt|;
name|ISDEBUGGERPRESENT
name|IsDebuggerPresent_
init|=
operator|(
name|ISDEBUGGERPRESENT
operator|)
name|GetProcAddress
argument_list|(
name|kernel32_dll
argument_list|,
literal|"IsDebuggerPresent"
argument_list|)
decl_stmt|;
if|if
condition|(
name|IsDebuggerPresent_
operator|&&
name|IsDebuggerPresent_
argument_list|()
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
else|else
name|result
operator|=
name|FALSE
expr_stmt|;
name|FreeLibrary
argument_list|(
name|kernel32_dll
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Load the dbghelp.dll file, try to find a version that matches our    requirements. */
end_comment

begin_function
specifier|static
name|BOOL
name|load_dbghelp_dll
parameter_list|()
block|{
name|dbghelp_dll
operator|=
name|LoadLibrary
argument_list|(
name|DBGHELP_DLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbghelp_dll
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|DWORD
name|opts
decl_stmt|;
comment|/* load the functions */
name|MiniDumpWriteDump_
operator|=
operator|(
name|MINIDUMPWRITEDUMP
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"MiniDumpWriteDump"
argument_list|)
expr_stmt|;
name|SymInitialize_
operator|=
operator|(
name|SYMINITIALIZE
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymInitialize"
argument_list|)
expr_stmt|;
name|SymSetOptions_
operator|=
operator|(
name|SYMSETOPTIONS
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymSetOptions"
argument_list|)
expr_stmt|;
name|SymGetOptions_
operator|=
operator|(
name|SYMGETOPTIONS
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymGetOptions"
argument_list|)
expr_stmt|;
name|SymCleanup_
operator|=
operator|(
name|SYMCLEANUP
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymCleanup"
argument_list|)
expr_stmt|;
name|SymGetTypeInfo_
operator|=
operator|(
name|SYMGETTYPEINFO
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymGetTypeInfo"
argument_list|)
expr_stmt|;
name|SymGetLineFromAddr64_
operator|=
operator|(
name|SYMGETLINEFROMADDR64
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymGetLineFromAddr64"
argument_list|)
expr_stmt|;
name|SymEnumSymbols_
operator|=
operator|(
name|SYMENUMSYMBOLS
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymEnumSymbols"
argument_list|)
expr_stmt|;
name|SymSetContext_
operator|=
operator|(
name|SYMSETCONTEXT
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymSetContext"
argument_list|)
expr_stmt|;
name|SymFromAddr_
operator|=
operator|(
name|SYMFROMADDR
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymFromAddr"
argument_list|)
expr_stmt|;
name|StackWalk64_
operator|=
operator|(
name|STACKWALK64
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"StackWalk64"
argument_list|)
expr_stmt|;
name|SymFunctionTableAccess64_
operator|=
operator|(
name|SYMFUNCTIONTABLEACCESS64
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymFunctionTableAccess64"
argument_list|)
expr_stmt|;
name|SymGetModuleBase64_
operator|=
operator|(
name|SYMGETMODULEBASE64
operator|)
name|GetProcAddress
argument_list|(
name|dbghelp_dll
argument_list|,
literal|"SymGetModuleBase64"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|MiniDumpWriteDump_
operator|&&
name|SymInitialize_
operator|&&
name|SymSetOptions_
operator|&&
name|SymGetOptions_
operator|&&
name|SymCleanup_
operator|&&
name|SymGetTypeInfo_
operator|&&
name|SymGetLineFromAddr64_
operator|&&
name|SymEnumSymbols_
operator|&&
name|SymSetContext_
operator|&&
name|SymFromAddr_
operator|&&
name|SymGetModuleBase64_
operator|&&
name|StackWalk64_
operator|&&
name|SymFunctionTableAccess64_
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* initialize the symbol loading code */
name|opts
operator|=
name|SymGetOptions_
argument_list|()
expr_stmt|;
comment|/* Set the 'load lines' option to retrieve line number information;          set the Deferred Loads option to map the debug info in memory only          when needed. */
name|SymSetOptions_
argument_list|(
name|opts
operator||
name|SYMOPT_LOAD_LINES
operator||
name|SYMOPT_DEFERRED_LOADS
argument_list|)
expr_stmt|;
comment|/* Initialize the debughlp DLL with the default path and automatic          module enumeration (and loading of symbol tables) for this process.        */
name|SymInitialize_
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|cleanup
label|:
if|if
condition|(
name|dbghelp_dll
condition|)
name|FreeLibrary
argument_list|(
name|dbghelp_dll
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Cleanup the dbghelp.dll library */
end_comment

begin_function
specifier|static
name|void
name|cleanup_debughlp
parameter_list|()
block|{
name|SymCleanup_
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|)
expr_stmt|;
name|FreeLibrary
argument_list|(
name|dbghelp_dll
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a filename based on a prefix, the timestamp and an extension.    check if the filename was already taken, retry 3 times. */
end_comment

begin_function
name|BOOL
name|get_temp_filename
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|char
name|temp_dir
index|[
name|MAX_PATH
operator|-
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|GetTempPath
argument_list|(
name|MAX_PATH
operator|-
literal|64
argument_list|,
name|temp_dir
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|HANDLE
name|file
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
name|time_str
index|[
literal|64
index|]
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|time_str
argument_list|,
literal|64
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s%s%s.%s"
argument_list|,
name|temp_dir
argument_list|,
name|prefix
argument_list|,
name|time_str
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|file
operator|=
name|CreateFile
argument_list|(
name|filename
argument_list|,
name|GENERIC_WRITE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CREATE_NEW
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|CloseHandle
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
name|filename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Unhandled exception callback set with SetUnhandledExceptionFilter() */
end_comment

begin_function
name|LONG
name|WINAPI
name|svn__unhandled_exception_filter
parameter_list|(
name|PEXCEPTION_POINTERS
name|ptrs
parameter_list|)
block|{
name|char
name|dmp_filename
index|[
name|MAX_PATH
index|]
decl_stmt|;
name|char
name|log_filename
index|[
name|MAX_PATH
index|]
decl_stmt|;
name|FILE
modifier|*
name|log_file
decl_stmt|;
comment|/* Check if the crash handler was already loaded (crash while handling the      crash) */
if|if
condition|(
name|dbghelp_dll
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
return|return
name|EXCEPTION_CONTINUE_SEARCH
return|;
comment|/* don't log anything if we're running inside a debugger ... */
if|if
condition|(
name|is_debugger_present
argument_list|()
condition|)
return|return
name|EXCEPTION_CONTINUE_SEARCH
return|;
comment|/* ... or if we can't create the log files ... */
if|if
condition|(
operator|!
name|get_temp_filename
argument_list|(
name|dmp_filename
argument_list|,
name|LOGFILE_PREFIX
argument_list|,
literal|"dmp"
argument_list|)
operator|||
operator|!
name|get_temp_filename
argument_list|(
name|log_filename
argument_list|,
name|LOGFILE_PREFIX
argument_list|,
literal|"log"
argument_list|)
condition|)
return|return
name|EXCEPTION_CONTINUE_SEARCH
return|;
comment|/* If we can't load a recent version of the dbghelp.dll, pass on this      exception */
if|if
condition|(
operator|!
name|load_dbghelp_dll
argument_list|()
condition|)
return|return
name|EXCEPTION_CONTINUE_SEARCH
return|;
comment|/* open log file */
name|log_file
operator|=
name|fopen
argument_list|(
name|log_filename
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
comment|/* write information about the process */
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nProcess info:\n"
argument_list|)
expr_stmt|;
name|write_process_info
argument_list|(
name|ptrs
condition|?
name|ptrs
operator|->
name|ExceptionRecord
else|:
name|NULL
argument_list|,
name|ptrs
condition|?
name|ptrs
operator|->
name|ContextRecord
else|:
name|NULL
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
comment|/* write the stacktrace, if available */
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nStacktrace:\n"
argument_list|)
expr_stmt|;
name|write_stacktrace
argument_list|(
name|ptrs
condition|?
name|ptrs
operator|->
name|ContextRecord
else|:
name|NULL
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
comment|/* write the minidump file and use the callback to write the list of modules      to the log file */
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\n\nLoaded modules:\n"
argument_list|)
expr_stmt|;
name|write_minidump_file
argument_list|(
name|dmp_filename
argument_list|,
name|ptrs
argument_list|,
name|write_module_info_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
name|log_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
comment|/* inform the user */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"This application has halted due to an unexpected error.\n"
literal|"A crash report and minidump file were saved to disk, you"
literal|" can find them here:\n"
literal|"%s\n%s\n"
literal|"Please send the log file to %s to help us analyze\nand "
literal|"solve this problem.\n\n"
literal|"NOTE: The crash report and minidump files can contain some"
literal|" sensitive information\n(filenames, partial file content, "
literal|"usernames and passwords etc.)\n"
argument_list|,
name|log_filename
argument_list|,
name|dmp_filename
argument_list|,
name|CRASHREPORT_EMAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"SVN_DBG_STACKTRACES_TO_STDERR"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nProcess info:\n"
argument_list|)
expr_stmt|;
name|write_process_info
argument_list|(
name|ptrs
condition|?
name|ptrs
operator|->
name|ExceptionRecord
else|:
name|NULL
argument_list|,
name|ptrs
condition|?
name|ptrs
operator|->
name|ContextRecord
else|:
name|NULL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nStacktrace:\n"
argument_list|)
expr_stmt|;
name|write_stacktrace
argument_list|(
name|ptrs
condition|?
name|ptrs
operator|->
name|ContextRecord
else|:
name|NULL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|cleanup_debughlp
argument_list|()
expr_stmt|;
comment|/* terminate the application */
return|return
name|EXCEPTION_EXECUTE_HANDLER
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_USE_WIN32_CRASHHANDLER */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

end_unit

