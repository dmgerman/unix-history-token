begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * prompt.c -- ask the user for authentication information.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_poll.h>
end_include

begin_include
include|#
directive|include
file|<apr_portable.h>
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_auth.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_include
include|#
directive|include
file|<conio.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Descriptor of an open terminal */
end_comment

begin_typedef
typedef|typedef
name|struct
name|terminal_handle_t
name|terminal_handle_t
typedef|;
end_typedef

begin_struct
struct|struct
name|terminal_handle_t
block|{
name|apr_file_t
modifier|*
name|infd
decl_stmt|;
comment|/* input file handle */
name|apr_file_t
modifier|*
name|outfd
decl_stmt|;
comment|/* output file handle */
name|svn_boolean_t
name|noecho
decl_stmt|;
comment|/* terminal echo was turned off */
name|svn_boolean_t
name|close_handles
decl_stmt|;
comment|/* close handles when closing the terminal */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* pool associated with the file handles */
ifdef|#
directive|ifdef
name|HAVE_TERMIOS_H
name|svn_boolean_t
name|restore_state
decl_stmt|;
comment|/* terminal state was changed */
name|apr_os_file_t
name|osinfd
decl_stmt|;
comment|/* OS-specific handle for infd */
name|struct
name|termios
name|attr
decl_stmt|;
comment|/* saved terminal attributes */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize safe state of terminal_handle_t. */
end_comment

begin_function
specifier|static
name|void
name|terminal_handle_init
parameter_list|(
name|terminal_handle_t
modifier|*
name|terminal
parameter_list|,
name|apr_file_t
modifier|*
name|infd
parameter_list|,
name|apr_file_t
modifier|*
name|outfd
parameter_list|,
name|svn_boolean_t
name|noecho
parameter_list|,
name|svn_boolean_t
name|close_handles
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|memset
argument_list|(
name|terminal
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|terminal
argument_list|)
argument_list|)
expr_stmt|;
name|terminal
operator|->
name|infd
operator|=
name|infd
expr_stmt|;
name|terminal
operator|->
name|outfd
operator|=
name|outfd
expr_stmt|;
name|terminal
operator|->
name|noecho
operator|=
name|noecho
expr_stmt|;
name|terminal
operator|->
name|close_handles
operator|=
name|close_handles
expr_stmt|;
name|terminal
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common pool cleanup handler for terminal_handle_t. Closes TERMINAL.  * If CLOSE_HANDLES is TRUE, close the terminal file handles.  * If RESTORE_STATE is TRUE, restores the TERMIOS flags of the terminal.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|terminal_cleanup_handler
parameter_list|(
name|terminal_handle_t
modifier|*
name|terminal
parameter_list|,
name|svn_boolean_t
name|close_handles
parameter_list|,
name|svn_boolean_t
name|restore_state
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS_H
comment|/* Restore terminal state flags. */
if|if
condition|(
name|restore_state
operator|&&
name|terminal
operator|->
name|restore_state
condition|)
name|tcsetattr
argument_list|(
name|terminal
operator|->
name|osinfd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|terminal
operator|->
name|attr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Close terminal handles. */
if|if
condition|(
name|close_handles
operator|&&
name|terminal
operator|->
name|close_handles
condition|)
block|{
name|apr_file_t
modifier|*
specifier|const
name|infd
init|=
name|terminal
operator|->
name|infd
decl_stmt|;
name|apr_file_t
modifier|*
specifier|const
name|outfd
init|=
name|terminal
operator|->
name|outfd
decl_stmt|;
if|if
condition|(
name|infd
condition|)
block|{
name|terminal
operator|->
name|infd
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|apr_file_close
argument_list|(
name|infd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|status
operator|&&
name|outfd
operator|&&
name|outfd
operator|!=
name|infd
condition|)
block|{
name|terminal
operator|->
name|outfd
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|apr_file_close
argument_list|(
name|terminal
operator|->
name|outfd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Normal pool cleanup for a terminal. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|terminal_plain_cleanup
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|terminal_cleanup_handler
argument_list|(
name|baton
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Child pool cleanup for a terminal -- does not restore echo state. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|terminal_child_cleanup
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
name|terminal_cleanup_handler
argument_list|(
name|baton
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Explicitly close the terminal, removing its cleanup handlers. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|terminal_close
parameter_list|(
name|terminal_handle_t
modifier|*
name|terminal
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
comment|/* apr_pool_cleanup_kill() removes both normal and child cleanup */
name|apr_pool_cleanup_kill
argument_list|(
name|terminal
operator|->
name|pool
argument_list|,
name|terminal
argument_list|,
name|terminal_plain_cleanup
argument_list|)
expr_stmt|;
name|status
operator|=
name|terminal_cleanup_handler
argument_list|(
name|terminal
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_create
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't close terminal"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate and open *TERMINAL. If NOECHO is TRUE, try to turn off    terminal echo.  Use POOL for all allocations.*/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|terminal_open
parameter_list|(
name|terminal_handle_t
modifier|*
modifier|*
name|terminal
parameter_list|,
name|svn_boolean_t
name|noecho
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
comment|/* On Windows, we'll use the console API directly if the process has      a console attached; otherwise we'll just use stdin and stderr. */
specifier|const
name|HANDLE
name|conin
init|=
name|CreateFileW
argument_list|(
literal|L"CONIN$"
argument_list|,
name|GENERIC_READ
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
operator|*
name|terminal
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|terminal_handle_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conin
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
comment|/* The process has a console. */
name|CloseHandle
argument_list|(
name|conin
argument_list|)
expr_stmt|;
name|terminal_handle_init
argument_list|(
operator|*
name|terminal
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|noecho
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|#
directive|else
comment|/* !WIN32 */
comment|/* Without evidence to the contrary, we'll assume this is *nix and      try to open /dev/tty. If that fails, we'll use stdin for input      and stderr for prompting. */
name|apr_file_t
modifier|*
name|tmpfd
decl_stmt|;
name|status
operator|=
name|apr_file_open
argument_list|(
operator|&
name|tmpfd
argument_list|,
literal|"/dev/tty"
argument_list|,
name|APR_FOPEN_READ
operator||
name|APR_FOPEN_WRITE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|terminal
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|terminal_handle_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
comment|/* We have a terminal handle that we can use for input and output. */
name|terminal_handle_init
argument_list|(
operator|*
name|terminal
argument_list|,
name|tmpfd
argument_list|,
name|tmpfd
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !WIN32 */
else|else
block|{
comment|/* There is no terminal. Sigh. */
name|apr_file_t
modifier|*
name|infd
decl_stmt|;
name|apr_file_t
modifier|*
name|outfd
decl_stmt|;
name|status
operator|=
name|apr_file_open_stdin
argument_list|(
operator|&
name|infd
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't open stdin"
argument_list|)
argument_list|)
return|;
name|status
operator|=
name|apr_file_open_stderr
argument_list|(
operator|&
name|outfd
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't open stderr"
argument_list|)
argument_list|)
return|;
name|terminal_handle_init
argument_list|(
operator|*
name|terminal
argument_list|,
name|infd
argument_list|,
name|outfd
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_TERMIOS_H
comment|/* Set terminal state */
if|if
condition|(
literal|0
operator|==
name|apr_os_file_get
argument_list|(
operator|&
operator|(
operator|*
name|terminal
operator|)
operator|->
name|osinfd
argument_list|,
operator|(
operator|*
name|terminal
operator|)
operator|->
name|infd
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|tcgetattr
argument_list|(
operator|(
operator|*
name|terminal
operator|)
operator|->
name|osinfd
argument_list|,
operator|&
operator|(
operator|*
name|terminal
operator|)
operator|->
name|attr
argument_list|)
condition|)
block|{
name|struct
name|termios
name|attr
init|=
operator|(
operator|*
name|terminal
operator|)
operator|->
name|attr
decl_stmt|;
comment|/* Turn off signal handling and canonical input mode */
name|attr
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ISIG
operator||
name|ICANON
operator|)
expr_stmt|;
name|attr
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Read one byte at a time */
name|attr
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
comment|/* No timeout, wait indefinitely */
name|attr
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator|)
expr_stmt|;
comment|/* Turn off echo */
if|if
condition|(
literal|0
operator|==
name|tcsetattr
argument_list|(
operator|(
operator|*
name|terminal
operator|)
operator|->
name|osinfd
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|attr
argument_list|)
condition|)
block|{
operator|(
operator|*
name|terminal
operator|)
operator|->
name|noecho
operator|=
name|noecho
expr_stmt|;
operator|(
operator|*
name|terminal
operator|)
operator|->
name|restore_state
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS_H */
comment|/* Register pool cleanup to close handles and restore echo state. */
name|apr_pool_cleanup_register
argument_list|(
operator|(
operator|*
name|terminal
operator|)
operator|->
name|pool
argument_list|,
operator|*
name|terminal
argument_list|,
name|terminal_plain_cleanup
argument_list|,
name|terminal_child_cleanup
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write a null-terminated STRING to TERMINAL.    Use POOL for allocations related to converting STRING from UTF-8. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|terminal_puts
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|terminal_handle_t
modifier|*
name|terminal
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|converted
decl_stmt|;
name|err
operator|=
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|converted
argument_list|,
name|string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|converted
operator|=
name|svn_cmdline_cstring_from_utf8_fuzzy
argument_list|(
name|string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WIN32
if|if
condition|(
operator|!
name|terminal
operator|->
name|outfd
condition|)
block|{
comment|/* See terminal_open; we're using Console I/O. */
name|_cputs
argument_list|(
name|converted
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|terminal
operator|->
name|outfd
argument_list|,
name|converted
argument_list|,
name|strlen
argument_list|(
name|converted
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_flush
argument_list|(
name|terminal
operator|->
name|outfd
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These codes can be returned from terminal_getc instead of a character. */
end_comment

begin_define
define|#
directive|define
name|TERMINAL_NONE
value|0x80000
end_define

begin_comment
comment|/* no character read, retry */
end_comment

begin_define
define|#
directive|define
name|TERMINAL_DEL
value|(TERMINAL_NONE + 1)
end_define

begin_comment
comment|/* the input was a deleteion */
end_comment

begin_define
define|#
directive|define
name|TERMINAL_EOL
value|(TERMINAL_NONE + 2)
end_define

begin_comment
comment|/* end of input/end of line */
end_comment

begin_define
define|#
directive|define
name|TERMINAL_EOF
value|(TERMINAL_NONE + 3)
end_define

begin_comment
comment|/* end of file during input */
end_comment

begin_comment
comment|/* Helper for terminal_getc: writes CH to OUTFD as a control char. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_function
specifier|static
name|void
name|echo_control_char
parameter_list|(
name|char
name|ch
parameter_list|,
name|apr_file_t
modifier|*
name|outfd
parameter_list|)
block|{
if|if
condition|(
name|svn_ctype_iscntrl
argument_list|(
name|ch
argument_list|)
condition|)
block|{
specifier|const
name|char
name|substitute
init|=
operator|(
name|ch
operator|<
literal|32
condition|?
literal|'@'
operator|+
name|ch
else|:
literal|'?'
operator|)
decl_stmt|;
name|apr_file_putc
argument_list|(
literal|'^'
argument_list|,
name|outfd
argument_list|)
expr_stmt|;
name|apr_file_putc
argument_list|(
name|substitute
argument_list|,
name|outfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svn_ctype_isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* Pass printable characters unchanged. */
name|apr_file_putc
argument_list|(
name|ch
argument_list|,
name|outfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Everything else is strange. */
name|apr_file_putc
argument_list|(
literal|'^'
argument_list|,
name|outfd
argument_list|)
expr_stmt|;
name|apr_file_putc
argument_list|(
literal|'!'
argument_list|,
name|outfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_comment
comment|/* Read one character or control code from TERMINAL, returning it in CODE.    if CAN_ERASE and the input was a deletion, emit codes to erase the    last character displayed on the terminal.    Use POOL for all allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|terminal_getc
parameter_list|(
name|int
modifier|*
name|code
parameter_list|,
name|terminal_handle_t
modifier|*
name|terminal
parameter_list|,
name|svn_boolean_t
name|can_erase
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_boolean_t
name|echo
init|=
operator|!
name|terminal
operator|->
name|noecho
decl_stmt|;
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
name|char
name|ch
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
if|if
condition|(
operator|!
name|terminal
operator|->
name|infd
condition|)
block|{
comment|/* See terminal_open; we're using Console I/O. */
comment|/*  The following was hoisted from APR's getpass for Windows. */
name|int
name|concode
init|=
name|_getch
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|concode
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* end-of-line */
operator|*
name|code
operator|=
name|TERMINAL_EOL
expr_stmt|;
if|if
condition|(
name|echo
condition|)
name|_cputs
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOF
case|:
comment|/* end-of-file */
case|case
literal|26
case|:
comment|/* Ctrl+Z */
operator|*
name|code
operator|=
name|TERMINAL_EOF
expr_stmt|;
if|if
condition|(
name|echo
condition|)
name|_cputs
argument_list|(
operator|(
name|concode
operator|==
name|EOF
condition|?
literal|"[EOF]\r\n"
else|:
literal|"^Z\r\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Ctrl+C, Ctrl+Break */
comment|/* _getch() bypasses Ctrl+C but not Ctrl+Break detection! */
if|if
condition|(
name|echo
condition|)
name|_cputs
argument_list|(
literal|"^C\r\n"
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CANCELLED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|0
case|:
comment|/* Function code prefix */
case|case
literal|0xE0
case|:
name|concode
operator|=
operator|(
name|concode
operator|<<
literal|4
operator|)
operator||
name|_getch
argument_list|()
expr_stmt|;
comment|/* Catch {DELETE}, {<--}, Num{DEL} and Num{<--} */
if|if
condition|(
name|concode
operator|==
literal|0xE53
operator|||
name|concode
operator|==
literal|0xE4B
operator|||
name|concode
operator|==
literal|0x053
operator|||
name|concode
operator|==
literal|0x04B
condition|)
block|{
operator|*
name|code
operator|=
name|TERMINAL_DEL
expr_stmt|;
if|if
condition|(
name|can_erase
condition|)
name|_cputs
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|code
operator|=
name|TERMINAL_NONE
expr_stmt|;
name|_putch
argument_list|(
literal|'\a'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\b'
case|:
comment|/* BS */
case|case
literal|127
case|:
comment|/* DEL */
operator|*
name|code
operator|=
name|TERMINAL_DEL
expr_stmt|;
if|if
condition|(
name|can_erase
condition|)
name|_cputs
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|apr_iscntrl
argument_list|(
name|concode
argument_list|)
condition|)
block|{
operator|*
name|code
operator|=
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|concode
expr_stmt|;
name|_putch
argument_list|(
name|echo
condition|?
name|concode
else|:
literal|'*'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|code
operator|=
name|TERMINAL_NONE
expr_stmt|;
name|_putch
argument_list|(
literal|'\a'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
if|if
condition|(
name|terminal
operator|->
name|restore_state
condition|)
block|{
comment|/* We're using a bytewise-immediate termios input */
specifier|const
name|struct
name|termios
modifier|*
specifier|const
name|attr
init|=
operator|&
name|terminal
operator|->
name|attr
decl_stmt|;
name|status
operator|=
name|apr_file_getc
argument_list|(
operator|&
name|ch
argument_list|,
name|terminal
operator|->
name|infd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't read from terminal"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ch
operator|==
name|attr
operator|->
name|c_cc
index|[
name|VINTR
index|]
operator|||
name|ch
operator|==
name|attr
operator|->
name|c_cc
index|[
name|VQUIT
index|]
condition|)
block|{
comment|/* Break */
name|echo_control_char
argument_list|(
name|ch
argument_list|,
name|terminal
operator|->
name|outfd
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CANCELLED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
name|attr
operator|->
name|c_cc
index|[
name|VEOL
index|]
condition|)
block|{
comment|/* Newline */
operator|*
name|code
operator|=
name|TERMINAL_EOL
expr_stmt|;
name|apr_file_putc
argument_list|(
literal|'\n'
argument_list|,
name|terminal
operator|->
name|outfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\b'
operator|||
name|ch
operator|==
name|attr
operator|->
name|c_cc
index|[
name|VERASE
index|]
condition|)
block|{
comment|/* Delete */
operator|*
name|code
operator|=
name|TERMINAL_DEL
expr_stmt|;
if|if
condition|(
name|can_erase
condition|)
block|{
name|apr_file_putc
argument_list|(
literal|'\b'
argument_list|,
name|terminal
operator|->
name|outfd
argument_list|)
expr_stmt|;
name|apr_file_putc
argument_list|(
literal|' '
argument_list|,
name|terminal
operator|->
name|outfd
argument_list|)
expr_stmt|;
name|apr_file_putc
argument_list|(
literal|'\b'
argument_list|,
name|terminal
operator|->
name|outfd
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|attr
operator|->
name|c_cc
index|[
name|VEOF
index|]
condition|)
block|{
comment|/* End of input */
operator|*
name|code
operator|=
name|TERMINAL_EOF
expr_stmt|;
name|echo_control_char
argument_list|(
name|ch
argument_list|,
name|terminal
operator|->
name|outfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|attr
operator|->
name|c_cc
index|[
name|VSUSP
index|]
condition|)
block|{
comment|/* Suspend */
operator|*
name|code
operator|=
name|TERMINAL_NONE
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apr_iscntrl
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* Normal character */
operator|*
name|code
operator|=
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|ch
expr_stmt|;
name|apr_file_putc
argument_list|(
operator|(
name|echo
condition|?
name|ch
else|:
literal|'*'
operator|)
argument_list|,
name|terminal
operator|->
name|outfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ignored character */
operator|*
name|code
operator|=
name|TERMINAL_NONE
expr_stmt|;
name|apr_file_putc
argument_list|(
literal|'\a'
argument_list|,
name|terminal
operator|->
name|outfd
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS_H */
comment|/* Fall back to plain stream-based I/O. */
ifndef|#
directive|ifndef
name|WIN32
comment|/* Wait for input on termin. This code is based on      apr_wait_for_io_or_timeout().      Note that this will return an EINTR on a signal. */
block|{
name|apr_pollfd_t
name|pollset
decl_stmt|;
name|int
name|n
decl_stmt|;
name|pollset
operator|.
name|desc_type
operator|=
name|APR_POLL_FILE
expr_stmt|;
name|pollset
operator|.
name|desc
operator|.
name|f
operator|=
name|terminal
operator|->
name|infd
expr_stmt|;
name|pollset
operator|.
name|p
operator|=
name|pool
expr_stmt|;
name|pollset
operator|.
name|reqevents
operator|=
name|APR_POLLIN
expr_stmt|;
name|status
operator|=
name|apr_poll
argument_list|(
operator|&
name|pollset
argument_list|,
literal|1
argument_list|,
operator|&
name|n
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|pollset
operator|.
name|rtnevents
operator|&
name|APR_POLLIN
condition|)
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !WIN32 */
if|if
condition|(
operator|!
name|status
condition|)
name|status
operator|=
name|apr_file_getc
argument_list|(
operator|&
name|ch
argument_list|,
name|terminal
operator|->
name|infd
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EINTR
argument_list|(
name|status
argument_list|)
condition|)
block|{
operator|*
name|code
operator|=
name|TERMINAL_NONE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
operator|*
name|code
operator|=
name|TERMINAL_EOF
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't read from terminal"
argument_list|)
argument_list|)
return|;
operator|*
name|code
operator|=
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|ch
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set @a *result to the result of prompting the user with @a  * prompt_msg.  Use @ *pb to get the cancel_func and cancel_baton.  * Do not call the cancel_func if @a *pb is NULL.  * Allocate @a *result in @a pool.  *  * If @a hide is true, then try to avoid displaying the user's input.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prompt
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt_msg
parameter_list|,
name|svn_boolean_t
name|hide
parameter_list|,
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* XXX: If this functions ever starts using members of *pb    * which were not included in svn_cmdline_prompt_baton_t,    * we need to update svn_cmdline_prompt_user2 and its callers. */
name|svn_boolean_t
name|saw_first_half_of_eol
init|=
name|FALSE
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|strbuf
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|terminal_handle_t
modifier|*
name|terminal
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|terminal_open
argument_list|(
operator|&
name|terminal
argument_list|,
name|hide
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|terminal_puts
argument_list|(
name|prompt_msg
argument_list|,
name|terminal
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|terminal_getc
argument_list|(
operator|&
name|code
argument_list|,
name|terminal
argument_list|,
operator|(
name|strbuf
operator|->
name|len
operator|>
literal|0
operator|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for cancellation after a character has been read, some          input processing modes may eat ^C and we'll only notice a          cancellation signal after characters have been read --          sometimes even after a newline. */
if|if
condition|(
name|pb
condition|)
name|SVN_ERR
argument_list|(
name|pb
operator|->
name|cancel_func
argument_list|(
name|pb
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TERMINAL_NONE
case|:
comment|/* Nothing useful happened; retry. */
continue|continue;
case|case
name|TERMINAL_DEL
case|:
comment|/* Delete the last input character. terminal_getc takes care              of erasing the feedback from the terminal, if applicable. */
name|svn_stringbuf_chop
argument_list|(
name|strbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TERMINAL_EOL
case|:
comment|/* End-of-line means end of input. Trick the EOL-detection code              below to stop reading. */
name|saw_first_half_of_eol
operator|=
name|TRUE
expr_stmt|;
name|c
operator|=
name|APR_EOL_STR
index|[
literal|1
index|]
expr_stmt|;
comment|/* Could be \0 but still stops reading. */
break|break;
case|case
name|TERMINAL_EOF
case|:
return|return
name|svn_error_create
argument_list|(
name|APR_EOF
argument_list|,
name|terminal_close
argument_list|(
name|terminal
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"End of file while reading from terminal"
argument_list|)
argument_list|)
return|;
default|default:
comment|/* Convert the returned code back to the character. */
name|c
operator|=
operator|(
name|char
operator|)
name|code
expr_stmt|;
block|}
if|if
condition|(
name|saw_first_half_of_eol
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|APR_EOL_STR
index|[
literal|1
index|]
condition|)
break|break;
else|else
name|saw_first_half_of_eol
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|APR_EOL_STR
index|[
literal|0
index|]
condition|)
block|{
comment|/* GCC might complain here: "warning: will never be executed"            * That's fine. This is a compile-time check for "\r\n\0" */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|APR_EOL_STR
argument_list|)
operator|==
literal|3
condition|)
block|{
name|saw_first_half_of_eol
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|APR_EOL_STR
argument_list|)
operator|==
literal|2
condition|)
break|break;
else|else
comment|/* ### APR_EOL_STR holds more than two chars?  Who                ever heard of such a thing? */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
name|svn_stringbuf_appendbyte
argument_list|(
name|strbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|terminal
operator|->
name|noecho
condition|)
block|{
comment|/* If terminal echo was turned off, make sure future output          to the terminal starts on a new line, as expected. */
name|SVN_ERR
argument_list|(
name|terminal_puts
argument_list|(
name|APR_EOL_STR
argument_list|,
name|terminal
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|terminal_close
argument_list|(
name|terminal
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_cstring_to_utf8
argument_list|(
name|result
argument_list|,
name|strbuf
operator|->
name|data
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Prompt functions for auth providers. **/
end_comment

begin_comment
comment|/* Helper function for auth provider prompters: mention the  * authentication @a realm on stderr, in a manner appropriate for  * preceding a prompt; or if @a realm is null, then do nothing.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_print_realm
parameter_list|(
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|realm
condition|)
block|{
name|terminal_handle_t
modifier|*
name|terminal
decl_stmt|;
name|SVN_ERR
argument_list|(
name|terminal_open
argument_list|(
operator|&
name|terminal
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|terminal_puts
argument_list|(
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Authentication realm: %s\n"
argument_list|)
argument_list|,
name|realm
argument_list|)
argument_list|,
name|terminal
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|terminal_close
argument_list|(
name|terminal
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_auth_simple_prompt_func_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_auth_simple_prompt
parameter_list|(
name|svn_auth_cred_simple_t
modifier|*
modifier|*
name|cred_p
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
name|svn_boolean_t
name|may_save
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_auth_cred_simple_t
modifier|*
name|ret
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|pass_prompt
decl_stmt|;
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|maybe_print_realm
argument_list|(
name|realm
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|username
condition|)
name|ret
operator|->
name|username
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|username
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|prompt
argument_list|(
operator|&
operator|(
name|ret
operator|->
name|username
operator|)
argument_list|,
name|_
argument_list|(
literal|"Username: "
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pass_prompt
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Password for '%s': "
argument_list|)
argument_list|,
name|ret
operator|->
name|username
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prompt
argument_list|(
operator|&
operator|(
name|ret
operator|->
name|password
operator|)
argument_list|,
name|pass_prompt
argument_list|,
name|TRUE
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|may_save
operator|=
name|may_save
expr_stmt|;
operator|*
name|cred_p
operator|=
name|ret
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_auth_username_prompt_func_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_auth_username_prompt
parameter_list|(
name|svn_auth_cred_username_t
modifier|*
modifier|*
name|cred_p
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|svn_boolean_t
name|may_save
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_auth_cred_username_t
modifier|*
name|ret
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
decl_stmt|;
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|maybe_print_realm
argument_list|(
name|realm
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prompt
argument_list|(
operator|&
operator|(
name|ret
operator|->
name|username
operator|)
argument_list|,
name|_
argument_list|(
literal|"Username: "
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|may_save
operator|=
name|may_save
expr_stmt|;
operator|*
name|cred_p
operator|=
name|ret
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_auth_ssl_server_trust_prompt_func_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_auth_ssl_server_trust_prompt
parameter_list|(
name|svn_auth_cred_ssl_server_trust_t
modifier|*
modifier|*
name|cred_p
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_uint32_t
name|failures
parameter_list|,
specifier|const
name|svn_auth_ssl_server_cert_info_t
modifier|*
name|cert_info
parameter_list|,
name|svn_boolean_t
name|may_save
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|choice
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|msg
decl_stmt|;
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|svn_stringbuf_createf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Error validating server certificate for '%s':\n"
argument_list|)
argument_list|,
name|realm
argument_list|)
decl_stmt|;
if|if
condition|(
name|failures
operator|&
name|SVN_AUTH_SSL_UNKNOWNCA
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|" - The certificate is not issued by a trusted authority. Use the\n"
literal|"   fingerprint to validate the certificate manually!\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failures
operator|&
name|SVN_AUTH_SSL_CNMISMATCH
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|" - The certificate hostname does not match.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failures
operator|&
name|SVN_AUTH_SSL_NOTYETVALID
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|" - The certificate is not yet valid.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failures
operator|&
name|SVN_AUTH_SSL_EXPIRED
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|" - The certificate has expired.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failures
operator|&
name|SVN_AUTH_SSL_OTHER
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|" - The certificate has an unknown error.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|msg
operator|=
name|svn_stringbuf_createf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Certificate information:\n"
literal|" - Hostname: %s\n"
literal|" - Valid: from %s until %s\n"
literal|" - Issuer: %s\n"
literal|" - Fingerprint: %s\n"
argument_list|)
argument_list|,
name|cert_info
operator|->
name|hostname
argument_list|,
name|cert_info
operator|->
name|valid_from
argument_list|,
name|cert_info
operator|->
name|valid_until
argument_list|,
name|cert_info
operator|->
name|issuer_dname
argument_list|,
name|cert_info
operator|->
name|fingerprint
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendstr
argument_list|(
name|buf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_save
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"(R)eject, accept (t)emporarily or accept (p)ermanently? "
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"(R)eject or accept (t)emporarily? "
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|prompt
argument_list|(
operator|&
name|choice
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|FALSE
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|choice
index|[
literal|0
index|]
operator|==
literal|'t'
operator|||
name|choice
index|[
literal|0
index|]
operator|==
literal|'T'
condition|)
block|{
operator|*
name|cred_p
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|cred_p
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cred_p
operator|)
operator|->
name|may_save
operator|=
name|FALSE
expr_stmt|;
operator|(
operator|*
name|cred_p
operator|)
operator|->
name|accepted_failures
operator|=
name|failures
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|may_save
operator|&&
operator|(
name|choice
index|[
literal|0
index|]
operator|==
literal|'p'
operator|||
name|choice
index|[
literal|0
index|]
operator|==
literal|'P'
operator|)
condition|)
block|{
operator|*
name|cred_p
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|cred_p
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cred_p
operator|)
operator|->
name|may_save
operator|=
name|TRUE
expr_stmt|;
operator|(
operator|*
name|cred_p
operator|)
operator|->
name|accepted_failures
operator|=
name|failures
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cred_p
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_auth_ssl_client_cert_prompt_func_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_auth_ssl_client_cert_prompt
parameter_list|(
name|svn_auth_cred_ssl_client_cert_t
modifier|*
modifier|*
name|cred_p
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|svn_boolean_t
name|may_save
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_auth_cred_ssl_client_cert_t
modifier|*
name|cred
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|cert_file
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_cert_file
init|=
name|NULL
decl_stmt|;
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|maybe_print_realm
argument_list|(
name|realm
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prompt
argument_list|(
operator|&
name|cert_file
argument_list|,
name|_
argument_list|(
literal|"Client certificate filename: "
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|abs_cert_file
argument_list|,
name|cert_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|cred
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cred
argument_list|)
argument_list|)
expr_stmt|;
name|cred
operator|->
name|cert_file
operator|=
name|abs_cert_file
expr_stmt|;
name|cred
operator|->
name|may_save
operator|=
name|may_save
expr_stmt|;
operator|*
name|cred_p
operator|=
name|cred
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_auth_ssl_client_cert_pw_prompt_func_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_auth_ssl_client_cert_pw_prompt
parameter_list|(
name|svn_auth_cred_ssl_client_cert_pw_t
modifier|*
modifier|*
name|cred_p
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|svn_boolean_t
name|may_save
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_auth_cred_ssl_client_cert_pw_t
modifier|*
name|cred
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Passphrase for '%s': "
argument_list|)
argument_list|,
name|realm
argument_list|)
decl_stmt|;
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|prompt
argument_list|(
operator|&
name|result
argument_list|,
name|text
argument_list|,
name|TRUE
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|cred
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cred
argument_list|)
argument_list|)
expr_stmt|;
name|cred
operator|->
name|password
operator|=
name|result
expr_stmt|;
name|cred
operator|->
name|may_save
operator|=
name|may_save
expr_stmt|;
operator|*
name|cred_p
operator|=
name|cred
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is a helper for plaintext prompt functions. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|plaintext_prompt_helper
parameter_list|(
name|svn_boolean_t
modifier|*
name|may_save_plaintext
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt_string
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt_text
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|answer
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|answered
init|=
name|FALSE
decl_stmt|;
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_path
init|=
name|NULL
decl_stmt|;
name|terminal_handle_t
modifier|*
name|terminal
decl_stmt|;
if|if
condition|(
name|pb
condition|)
name|SVN_ERR
argument_list|(
name|svn_config_get_user_config_path
argument_list|(
operator|&
name|config_path
argument_list|,
name|pb
operator|->
name|config_dir
argument_list|,
name|SVN_CONFIG_CATEGORY_SERVERS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|terminal_open
argument_list|(
operator|&
name|terminal
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|terminal_puts
argument_list|(
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|prompt_text
argument_list|,
name|realmstring
argument_list|,
name|config_path
argument_list|)
argument_list|,
name|terminal
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|terminal_close
argument_list|(
name|terminal
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|prompt
argument_list|(
operator|&
name|answer
argument_list|,
name|prompt_string
argument_list|,
name|FALSE
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CANCELLED
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|may_save_plaintext
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
return|return
name|err
return|;
block|}
if|if
condition|(
name|apr_strnatcasecmp
argument_list|(
name|answer
argument_list|,
name|_
argument_list|(
literal|"yes"
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|apr_strnatcasecmp
argument_list|(
name|answer
argument_list|,
name|_
argument_list|(
literal|"y"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|may_save_plaintext
operator|=
name|TRUE
expr_stmt|;
name|answered
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_strnatcasecmp
argument_list|(
name|answer
argument_list|,
name|_
argument_list|(
literal|"no"
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|apr_strnatcasecmp
argument_list|(
name|answer
argument_list|,
name|_
argument_list|(
literal|"n"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|may_save_plaintext
operator|=
name|FALSE
expr_stmt|;
name|answered
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|prompt_string
operator|=
name|_
argument_list|(
literal|"Please type 'yes' or 'no': "
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|answered
condition|)
do|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_auth_plaintext_prompt_func_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_auth_plaintext_prompt
parameter_list|(
name|svn_boolean_t
modifier|*
name|may_save_plaintext
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prompt_string
init|=
name|_
argument_list|(
literal|"Store password unencrypted (yes/no)? "
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|prompt_text
init|=
name|_
argument_list|(
literal|"\n-----------------------------------------------------------------------"
literal|"\nATTENTION!  Your password for authentication realm:\n"
literal|"\n"
literal|"   %s\n"
literal|"\n"
literal|"can only be stored to disk unencrypted!  You are advised to configure\n"
literal|"your system so that Subversion can store passwords encrypted, if\n"
literal|"possible.  See the documentation for details.\n"
literal|"\n"
literal|"You can avoid future appearances of this warning by setting the value\n"
literal|"of the 'store-plaintext-passwords' option to either 'yes' or 'no' in\n"
literal|"'%s'.\n"
literal|"-----------------------------------------------------------------------\n"
argument_list|)
decl_stmt|;
return|return
name|plaintext_prompt_helper
argument_list|(
name|may_save_plaintext
argument_list|,
name|realmstring
argument_list|,
name|prompt_string
argument_list|,
name|prompt_text
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_auth_plaintext_passphrase_prompt_func_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_auth_plaintext_passphrase_prompt
parameter_list|(
name|svn_boolean_t
modifier|*
name|may_save_plaintext
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prompt_string
init|=
name|_
argument_list|(
literal|"Store passphrase unencrypted (yes/no)? "
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|prompt_text
init|=
name|_
argument_list|(
literal|"\n-----------------------------------------------------------------------\n"
literal|"ATTENTION!  Your passphrase for client certificate:\n"
literal|"\n"
literal|"   %s\n"
literal|"\n"
literal|"can only be stored to disk unencrypted!  You are advised to configure\n"
literal|"your system so that Subversion can store passphrase encrypted, if\n"
literal|"possible.  See the documentation for details.\n"
literal|"\n"
literal|"You can avoid future appearances of this warning by setting the value\n"
literal|"of the 'store-ssl-client-cert-pp-plaintext' option to either 'yes' or\n"
literal|"'no' in '%s'.\n"
literal|"-----------------------------------------------------------------------\n"
argument_list|)
decl_stmt|;
return|return
name|plaintext_prompt_helper
argument_list|(
name|may_save_plaintext
argument_list|,
name|realmstring
argument_list|,
name|prompt_string
argument_list|,
name|prompt_text
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Generic prompting. **/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline_prompt_user2
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt_str
parameter_list|,
name|svn_cmdline_prompt_baton_t
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* XXX: We know prompt doesn't use the new members    * of svn_cmdline_prompt_baton2_t. */
return|return
name|prompt
argument_list|(
name|result
argument_list|,
name|prompt_str
argument_list|,
name|FALSE
comment|/* don't hide input */
argument_list|,
operator|(
name|svn_cmdline_prompt_baton2_t
operator|*
operator|)
name|baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_auth_gnome_keyring_unlock_prompt_func_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cmdline__auth_gnome_keyring_unlock_prompt
parameter_list|(
name|char
modifier|*
modifier|*
name|keyring_password
parameter_list|,
specifier|const
name|char
modifier|*
name|keyring_name
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
specifier|const
name|char
modifier|*
name|pass_prompt
decl_stmt|;
name|svn_cmdline_prompt_baton2_t
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|pass_prompt
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Password for '%s' GNOME keyring: "
argument_list|)
argument_list|,
name|keyring_name
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prompt
argument_list|(
operator|&
name|password
argument_list|,
name|pass_prompt
argument_list|,
name|TRUE
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|keyring_password
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|password
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

