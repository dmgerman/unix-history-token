begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * mergeinfo.c:  Mergeinfo parsing and handling  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_comment
comment|/* Attempt to combine two ranges, IN1 and IN2. If they are adjacent or    overlapping, and their inheritability allows them to be combined, put    the result in OUTPUT and return TRUE, otherwise return FALSE.     CONSIDER_INHERITANCE determines how to account for the inheritability    of IN1 and IN2 when trying to combine ranges.  If ranges with different    inheritability are combined (CONSIDER_INHERITANCE must be FALSE for this    to happen) the result is inheritable.  If both ranges are inheritable the    result is inheritable.  And only if both ranges are non-inheritable    the result is non-inheritable.     Range overlapping detection algorithm from    http://c2.com/cgi-bin/wiki/fullSearch?TestIfDateRangesOverlap */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|combine_ranges
parameter_list|(
name|svn_merge_range_t
modifier|*
name|output
parameter_list|,
specifier|const
name|svn_merge_range_t
modifier|*
name|in1
parameter_list|,
specifier|const
name|svn_merge_range_t
modifier|*
name|in2
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|)
block|{
if|if
condition|(
name|in1
operator|->
name|start
operator|<=
name|in2
operator|->
name|end
operator|&&
name|in2
operator|->
name|start
operator|<=
name|in1
operator|->
name|end
condition|)
block|{
if|if
condition|(
operator|!
name|consider_inheritance
operator|||
operator|(
name|consider_inheritance
operator|&&
operator|(
name|in1
operator|->
name|inheritable
operator|==
name|in2
operator|->
name|inheritable
operator|)
operator|)
condition|)
block|{
name|output
operator|->
name|start
operator|=
name|MIN
argument_list|(
name|in1
operator|->
name|start
argument_list|,
name|in2
operator|->
name|start
argument_list|)
expr_stmt|;
name|output
operator|->
name|end
operator|=
name|MAX
argument_list|(
name|in1
operator|->
name|end
argument_list|,
name|in2
operator|->
name|end
argument_list|)
expr_stmt|;
name|output
operator|->
name|inheritable
operator|=
operator|(
name|in1
operator|->
name|inheritable
operator|||
name|in2
operator|->
name|inheritable
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* pathname -> PATHNAME */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_pathname
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|input
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pathname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|curr
init|=
operator|*
name|input
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_colon
init|=
name|NULL
decl_stmt|;
comment|/* A pathname may contain colons, so find the last colon before END      or newline.  We'll consider this the divider between the pathname      and the revisionlist. */
while|while
condition|(
name|curr
operator|<
name|end
operator|&&
operator|*
name|curr
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|curr
operator|==
literal|':'
condition|)
name|last_colon
operator|=
name|curr
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|last_colon
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Pathname not terminated by ':'"
argument_list|)
argument_list|)
return|;
comment|/* Tolerate relative repository paths, but convert them to absolute.      ### Efficiency?  1 string duplication here, 2 in canonicalize. */
operator|*
name|pathname
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
operator|*
name|input
argument_list|,
name|last_colon
operator|-
operator|*
name|input
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|input
operator|=
name|last_colon
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff (svn_merge_range_t *) RANGE describes a valid, forward  * revision range.  *  * Note: The smallest valid value of RANGE->start is 0 because it is an  * exclusive endpoint, being one less than the revision number of the first  * change described by the range, and the oldest possible change is "r1" as  * there cannot be a change "r0". */
end_comment

begin_define
define|#
directive|define
name|IS_VALID_FORWARD_RANGE
parameter_list|(
name|range
parameter_list|)
define|\
value|(SVN_IS_VALID_REVNUM((range)->start)&& ((range)->start< (range)->end))
end_define

begin_comment
comment|/* Ways in which two svn_merge_range_t can intersect or adjoin, if at all. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|intersection_type_t
block|{
comment|/* Ranges don't intersect and don't adjoin. */
name|svn__no_intersection
block|,
comment|/* Ranges are equal. */
name|svn__equal_intersection
block|,
comment|/* Ranges adjoin but don't overlap. */
name|svn__adjoining_intersection
block|,
comment|/* Ranges overlap but neither is a subset of the other. */
name|svn__overlapping_intersection
block|,
comment|/* One range is a proper subset of the other. */
name|svn__proper_subset_intersection
block|}
name|intersection_type_t
typedef|;
end_typedef

begin_comment
comment|/* Given ranges R1 and R2, both of which must be forward merge ranges,    set *INTERSECTION_TYPE to describe how the ranges intersect, if they    do at all.  The inheritance type of the ranges is not considered. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_type_of_intersection
parameter_list|(
specifier|const
name|svn_merge_range_t
modifier|*
name|r1
parameter_list|,
specifier|const
name|svn_merge_range_t
modifier|*
name|r2
parameter_list|,
name|intersection_type_t
modifier|*
name|intersection_type
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|r1
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|r2
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|IS_VALID_FORWARD_RANGE
argument_list|(
name|r1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|IS_VALID_FORWARD_RANGE
argument_list|(
name|r2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r1
operator|->
name|start
operator|<=
name|r2
operator|->
name|end
operator|&&
name|r2
operator|->
name|start
operator|<=
name|r1
operator|->
name|end
operator|)
condition|)
operator|*
name|intersection_type
operator|=
name|svn__no_intersection
expr_stmt|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|start
operator|==
name|r2
operator|->
name|start
operator|&&
name|r1
operator|->
name|end
operator|==
name|r2
operator|->
name|end
condition|)
operator|*
name|intersection_type
operator|=
name|svn__equal_intersection
expr_stmt|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|end
operator|==
name|r2
operator|->
name|start
operator|||
name|r2
operator|->
name|end
operator|==
name|r1
operator|->
name|start
condition|)
operator|*
name|intersection_type
operator|=
name|svn__adjoining_intersection
expr_stmt|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|start
operator|<=
name|r2
operator|->
name|start
operator|&&
name|r1
operator|->
name|end
operator|>=
name|r2
operator|->
name|end
condition|)
operator|*
name|intersection_type
operator|=
name|svn__proper_subset_intersection
expr_stmt|;
elseif|else
if|if
condition|(
name|r2
operator|->
name|start
operator|<=
name|r1
operator|->
name|start
operator|&&
name|r2
operator|->
name|end
operator|>=
name|r1
operator|->
name|end
condition|)
operator|*
name|intersection_type
operator|=
name|svn__proper_subset_intersection
expr_stmt|;
else|else
operator|*
name|intersection_type
operator|=
name|svn__overlapping_intersection
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Modify or extend RANGELIST (a list of merge ranges) to incorporate    NEW_RANGE. RANGELIST is a "rangelist" as defined in svn_mergeinfo.h.     OVERVIEW     Determine the minimal set of non-overlapping merge ranges required to    represent the combination of RANGELIST and NEW_RANGE. The result depends    on whether and how NEW_RANGE overlaps any merge range[*] in RANGELIST,    and also on any differences in the inheritability of each range,    according to the rules described below. Modify RANGELIST to represent    this result, by adjusting the last range in it and/or appending one or    two more ranges.     ([*] Due to the simplifying assumption below, only the last range in    RANGELIST is considered.)     DETAILS     If RANGELIST is not empty assume NEW_RANGE does not intersect with any    range before the last one in RANGELIST.     If RANGELIST is empty or NEW_RANGE does not intersect with the lastrange    in RANGELIST, then append a copy of NEW_RANGE, allocated in RESULT_POOL,    to RANGELIST.     If NEW_RANGE intersects with the last range in RANGELIST then combine    these two ranges as described below:     If the intersecting ranges have the same inheritability then simply    combine the ranges in place.  Otherwise, if the ranges intersect but    differ in inheritability, then merge the ranges as dictated by    CONSIDER_INHERITANCE:     If CONSIDER_INHERITANCE is false then intersecting ranges are combined    into a single range.  The inheritability of the resulting range is    non-inheritable *only* if both ranges are non-inheritable, otherwise the    combined range is inheritable, e.g.:       Last range in        NEW_RANGE        RESULTING RANGES      RANGELIST      -------------        ---------        ----------------      4-10*                6-13             4-13      4-10                 6-13*            4-13      4-10*                6-13*            4-13*     If CONSIDER_INHERITANCE is true, then only the intersection between the    two ranges is combined, with the inheritability of the resulting range    non-inheritable only if both ranges were non-inheritable.  The    non-intersecting portions are added as separate ranges allocated in    RESULT_POOL, e.g.:       Last range in        NEW_RANGE        RESULTING RANGES      RANGELIST      -------------        ---------        ----------------      4-10*                6                4-5*, 6, 7-10*      4-10*                6-12             4-5*, 6-12     Note that the standard rules for rangelists still apply and overlapping    ranges are not allowed.  So if the above would result in overlapping    ranges of the same inheritance, the overlapping ranges are merged into a    single range, e.g.:       Last range in        NEW_RANGE        RESULTING RANGES      RANGELIST      -------------        ---------        ----------------      4-10                 6*               4-10 (Not 4-5, 6, 7-10)     When replacing the last range in RANGELIST, either allocate a new range in    RESULT_POOL or modify the existing range in place.  Any new ranges added    to RANGELIST are allocated in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|combine_with_lastrange
parameter_list|(
specifier|const
name|svn_merge_range_t
modifier|*
name|new_range
parameter_list|,
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_merge_range_t
modifier|*
name|lastrange
decl_stmt|;
name|svn_merge_range_t
name|combined_range
decl_stmt|;
comment|/* We don't accept a NULL RANGELIST. */
name|SVN_ERR_ASSERT
argument_list|(
name|rangelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangelist
operator|->
name|nelts
operator|>
literal|0
condition|)
name|lastrange
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|rangelist
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
else|else
name|lastrange
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|lastrange
condition|)
block|{
comment|/* No *LASTRANGE so push NEW_RANGE onto RANGELIST and we are done. */
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|svn_merge_range_dup
argument_list|(
name|new_range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|consider_inheritance
condition|)
block|{
comment|/* We are not considering inheritance so we can merge intersecting          ranges of different inheritability.  Of course if the ranges          don't intersect at all we simply push NEW_RANGE onto RANGELIST. */
if|if
condition|(
name|combine_ranges
argument_list|(
operator|&
name|combined_range
argument_list|,
name|lastrange
argument_list|,
name|new_range
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
operator|*
name|lastrange
operator|=
name|combined_range
expr_stmt|;
block|}
else|else
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|svn_merge_range_dup
argument_list|(
name|new_range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Considering inheritance */
block|{
if|if
condition|(
name|combine_ranges
argument_list|(
operator|&
name|combined_range
argument_list|,
name|lastrange
argument_list|,
name|new_range
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* Even when considering inheritance two intersection ranges              of the same inheritability can simply be combined. */
operator|*
name|lastrange
operator|=
name|combined_range
expr_stmt|;
block|}
else|else
block|{
comment|/* If we are here then the ranges either don't intersect or do              intersect but have differing inheritability.  Check for the              first case as that is easy to handle. */
name|intersection_type_t
name|intersection_type
decl_stmt|;
name|svn_boolean_t
name|sorted
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_type_of_intersection
argument_list|(
name|new_range
argument_list|,
name|lastrange
argument_list|,
operator|&
name|intersection_type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intersection_type
condition|)
block|{
case|case
name|svn__no_intersection
case|:
comment|/* NEW_RANGE and *LASTRANGE *really* don't intersect so                    just push NEW_RANGE onto RANGELIST. */
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|svn_merge_range_dup
argument_list|(
name|new_range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|sorted
operator|=
operator|(
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|lastrange
argument_list|,
operator|&
name|new_range
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|svn__equal_intersection
case|:
comment|/* They range are equal so all we do is force the                    inheritability of lastrange to true. */
name|lastrange
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|sorted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn__adjoining_intersection
case|:
comment|/* They adjoin but don't overlap so just push NEW_RANGE                    onto RANGELIST. */
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|svn_merge_range_dup
argument_list|(
name|new_range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|sorted
operator|=
operator|(
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|lastrange
argument_list|,
operator|&
name|new_range
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|svn__overlapping_intersection
case|:
comment|/* They ranges overlap but neither is a proper subset of                    the other.  We'll end up pusing two new ranges onto                    RANGELIST, the intersecting part and the part unique to                    NEW_RANGE.*/
block|{
name|svn_merge_range_t
modifier|*
name|r1
init|=
name|svn_merge_range_dup
argument_list|(
name|lastrange
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|r2
init|=
name|svn_merge_range_dup
argument_list|(
name|new_range
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
comment|/* Pop off *LASTRANGE to make our manipulations                      easier. */
name|apr_array_pop
argument_list|(
name|rangelist
argument_list|)
expr_stmt|;
comment|/* Ensure R1 is the older range. */
if|if
condition|(
name|r2
operator|->
name|start
operator|<
name|r1
operator|->
name|start
condition|)
block|{
comment|/* Swap R1 and R2. */
operator|*
name|r2
operator|=
operator|*
name|r1
expr_stmt|;
operator|*
name|r1
operator|=
operator|*
name|new_range
expr_stmt|;
block|}
comment|/* Absorb the intersecting ranges into the                      inheritable range. */
if|if
condition|(
name|r1
operator|->
name|inheritable
condition|)
name|r2
operator|->
name|start
operator|=
name|r1
operator|->
name|end
expr_stmt|;
else|else
name|r1
operator|->
name|end
operator|=
name|r2
operator|->
name|start
expr_stmt|;
comment|/* Push everything back onto RANGELIST. */
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|r1
expr_stmt|;
name|sorted
operator|=
operator|(
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|lastrange
argument_list|,
operator|&
name|r1
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|r2
expr_stmt|;
if|if
condition|(
name|sorted
condition|)
name|sorted
operator|=
operator|(
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* svn__proper_subset_intersection */
block|{
comment|/* One range is a proper subset of the other. */
name|svn_merge_range_t
modifier|*
name|r1
init|=
name|svn_merge_range_dup
argument_list|(
name|lastrange
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|r2
init|=
name|svn_merge_range_dup
argument_list|(
name|new_range
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|r3
init|=
name|NULL
decl_stmt|;
comment|/* Pop off *LASTRANGE to make our manipulations                      easier. */
name|apr_array_pop
argument_list|(
name|rangelist
argument_list|)
expr_stmt|;
comment|/* Ensure R1 is the superset. */
if|if
condition|(
name|r2
operator|->
name|start
operator|<
name|r1
operator|->
name|start
operator|||
name|r2
operator|->
name|end
operator|>
name|r1
operator|->
name|end
condition|)
block|{
comment|/* Swap R1 and R2. */
operator|*
name|r2
operator|=
operator|*
name|r1
expr_stmt|;
operator|*
name|r1
operator|=
operator|*
name|new_range
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|->
name|inheritable
condition|)
block|{
comment|/* The simple case: The superset is inheritable, so                          just combine r1 and r2. */
name|r1
operator|->
name|start
operator|=
name|MIN
argument_list|(
name|r1
operator|->
name|start
argument_list|,
name|r2
operator|->
name|start
argument_list|)
expr_stmt|;
name|r1
operator|->
name|end
operator|=
name|MAX
argument_list|(
name|r1
operator|->
name|end
argument_list|,
name|r2
operator|->
name|end
argument_list|)
expr_stmt|;
name|r2
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|start
operator|==
name|r2
operator|->
name|start
condition|)
block|{
name|svn_revnum_t
name|tmp_revnum
decl_stmt|;
comment|/* *LASTRANGE and NEW_RANGE share an end point. */
name|tmp_revnum
operator|=
name|r1
operator|->
name|end
expr_stmt|;
name|r1
operator|->
name|end
operator|=
name|r2
operator|->
name|end
expr_stmt|;
name|r2
operator|->
name|inheritable
operator|=
name|r1
operator|->
name|inheritable
expr_stmt|;
name|r1
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|r2
operator|->
name|start
operator|=
name|r1
operator|->
name|end
expr_stmt|;
name|r2
operator|->
name|end
operator|=
name|tmp_revnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|end
operator|==
name|r2
operator|->
name|end
condition|)
block|{
comment|/* *LASTRANGE and NEW_RANGE share an end point. */
name|r1
operator|->
name|end
operator|=
name|r2
operator|->
name|start
expr_stmt|;
name|r2
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* NEW_RANGE and *LASTRANGE share neither start                          nor end points. */
name|r3
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r3
argument_list|)
argument_list|)
expr_stmt|;
name|r3
operator|->
name|start
operator|=
name|r2
operator|->
name|end
expr_stmt|;
name|r3
operator|->
name|end
operator|=
name|r1
operator|->
name|end
expr_stmt|;
name|r3
operator|->
name|inheritable
operator|=
name|r1
operator|->
name|inheritable
expr_stmt|;
name|r2
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|r1
operator|->
name|end
operator|=
name|r2
operator|->
name|start
expr_stmt|;
block|}
comment|/* Push everything back onto RANGELIST. */
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|r1
expr_stmt|;
name|sorted
operator|=
operator|(
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|lastrange
argument_list|,
operator|&
name|r1
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|r2
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|r2
expr_stmt|;
if|if
condition|(
name|sorted
condition|)
name|sorted
operator|=
operator|(
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|r3
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|r3
expr_stmt|;
if|if
condition|(
name|sorted
condition|)
block|{
if|if
condition|(
name|r2
condition|)
name|sorted
operator|=
operator|(
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|r2
argument_list|,
operator|&
name|r3
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
else|else
name|sorted
operator|=
operator|(
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|r1
argument_list|,
operator|&
name|r3
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/* Some of the above cases might have put *RANGELIST out of              order, so re-sort.*/
if|if
condition|(
operator|!
name|sorted
condition|)
name|svn_sort__array
argument_list|(
name|rangelist
argument_list|,
name|svn_sort_compare_ranges
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Convert a single svn_merge_range_t *RANGE back into a string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|range_to_string
parameter_list|(
specifier|const
name|svn_merge_range_t
modifier|*
name|range
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mark
init|=
name|range
operator|->
name|inheritable
condition|?
literal|""
else|:
name|SVN_MERGEINFO_NONINHERITABLE_STR
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|start
operator|==
name|range
operator|->
name|end
operator|-
literal|1
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld%s"
argument_list|,
name|range
operator|->
name|end
argument_list|,
name|mark
argument_list|)
return|;
elseif|else
if|if
condition|(
name|range
operator|->
name|start
operator|-
literal|1
operator|==
name|range
operator|->
name|end
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"-%ld%s"
argument_list|,
name|range
operator|->
name|start
argument_list|,
name|mark
argument_list|)
return|;
elseif|else
if|if
condition|(
name|range
operator|->
name|start
operator|<
name|range
operator|->
name|end
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld-%ld%s"
argument_list|,
name|range
operator|->
name|start
operator|+
literal|1
argument_list|,
name|range
operator|->
name|end
argument_list|,
name|mark
argument_list|)
return|;
else|else
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld-%ld%s"
argument_list|,
name|range
operator|->
name|start
argument_list|,
name|range
operator|->
name|end
operator|+
literal|1
argument_list|,
name|mark
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper for svn_mergeinfo_parse()    Append revision ranges onto the array RANGELIST to represent the range    descriptions found in the string *INPUT.  Read only as far as a newline    or the position END, whichever comes first.  Set *INPUT to the position    after the last character of INPUT that was used.     revisionlist -> (revisionelement)(COMMA revisionelement)*    revisionrange -> REVISION "-" REVISION("*")    revisionelement -> revisionrange | REVISION("*") */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_rangelist
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|input
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|curr
init|=
operator|*
name|input
decl_stmt|;
comment|/* Eat any leading horizontal white-space before the rangelist. */
while|while
condition|(
name|curr
operator|<
name|end
operator|&&
operator|*
name|curr
operator|!=
literal|'\n'
operator|&&
name|isspace
argument_list|(
operator|*
name|curr
argument_list|)
condition|)
name|curr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|curr
operator|==
literal|'\n'
operator|||
name|curr
operator|==
name|end
condition|)
block|{
comment|/* Empty range list. */
operator|*
name|input
operator|=
name|curr
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
while|while
condition|(
name|curr
operator|<
name|end
operator|&&
operator|*
name|curr
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Parse individual revisions or revision ranges. */
name|svn_merge_range_t
modifier|*
name|mrange
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mrange
argument_list|)
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|firstrev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_revnum_parse
argument_list|(
operator|&
name|firstrev
argument_list|,
name|curr
argument_list|,
operator|&
name|curr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|curr
operator|!=
literal|'-'
operator|&&
operator|*
name|curr
operator|!=
literal|'\n'
operator|&&
operator|*
name|curr
operator|!=
literal|','
operator|&&
operator|*
name|curr
operator|!=
literal|'*'
operator|&&
name|curr
operator|!=
name|end
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid character '%c' found in revision "
literal|"list"
argument_list|)
argument_list|,
operator|*
name|curr
argument_list|)
return|;
name|mrange
operator|->
name|start
operator|=
name|firstrev
operator|-
literal|1
expr_stmt|;
name|mrange
operator|->
name|end
operator|=
name|firstrev
expr_stmt|;
name|mrange
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|firstrev
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision number '0' found in "
literal|"range list"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|*
name|curr
operator|==
literal|'-'
condition|)
block|{
name|svn_revnum_t
name|secondrev
decl_stmt|;
name|curr
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_revnum_parse
argument_list|(
operator|&
name|secondrev
argument_list|,
name|curr
argument_list|,
operator|&
name|curr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstrev
operator|>
name|secondrev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to parse reversed revision "
literal|"range '%ld-%ld'"
argument_list|)
argument_list|,
name|firstrev
argument_list|,
name|secondrev
argument_list|)
return|;
elseif|else
if|if
condition|(
name|firstrev
operator|==
name|secondrev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to parse revision range "
literal|"'%ld-%ld' with same start and end "
literal|"revisions"
argument_list|)
argument_list|,
name|firstrev
argument_list|,
name|secondrev
argument_list|)
return|;
name|mrange
operator|->
name|end
operator|=
name|secondrev
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|curr
operator|==
literal|'\n'
operator|||
name|curr
operator|==
name|end
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|mrange
expr_stmt|;
operator|*
name|input
operator|=
name|curr
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|curr
operator|==
literal|','
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|mrange
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|curr
operator|==
literal|'*'
condition|)
block|{
name|mrange
operator|->
name|inheritable
operator|=
name|FALSE
expr_stmt|;
name|curr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|curr
operator|==
literal|','
operator|||
operator|*
name|curr
operator|==
literal|'\n'
operator|||
name|curr
operator|==
name|end
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|mrange
expr_stmt|;
if|if
condition|(
operator|*
name|curr
operator|==
literal|','
condition|)
block|{
name|curr
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|input
operator|=
name|curr
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid character '%c' found in "
literal|"range list"
argument_list|)
argument_list|,
operator|*
name|curr
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid character '%c' found in "
literal|"range list"
argument_list|)
argument_list|,
operator|*
name|curr
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|*
name|curr
operator|!=
literal|'\n'
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Range list parsing ended before hitting "
literal|"newline"
argument_list|)
argument_list|)
return|;
operator|*
name|input
operator|=
name|curr
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist__parse
parameter_list|(
name|svn_rangelist_t
modifier|*
modifier|*
name|rangelist
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|str
decl_stmt|;
operator|*
name|rangelist
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_rangelist
argument_list|(
operator|&
name|s
argument_list|,
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
operator|*
name|rangelist
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE, if all ranges in RANGELIST are in ascending order and do  * not overlap and are not adjacent.  *  * ### Can yield false negatives: ranges of differing inheritance are  * allowed to be adjacent.  *  * If this returns FALSE, you probaly want to qsort() the  * ranges and then call svn_rangelist__combine_adjacent_ranges().  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_rangelist_normalized
parameter_list|(
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_merge_range_t
modifier|*
modifier|*
name|ranges
init|=
operator|(
name|svn_merge_range_t
operator|*
operator|*
operator|)
name|rangelist
operator|->
name|elts
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
operator|-
literal|1
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ranges
index|[
name|i
index|]
operator|->
name|end
operator|>=
name|ranges
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|start
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist__canonicalize
parameter_list|(
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_rangelist_normalized
argument_list|(
name|rangelist
argument_list|)
condition|)
block|{
name|svn_sort__array
argument_list|(
name|rangelist
argument_list|,
name|svn_sort_compare_ranges
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist__combine_adjacent_ranges
argument_list|(
name|rangelist
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist__combine_adjacent_ranges
parameter_list|(
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
decl_stmt|,
modifier|*
name|lastrange
decl_stmt|;
name|lastrange
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastrange
operator|->
name|start
operator|<=
name|range
operator|->
name|end
operator|&&
name|range
operator|->
name|start
operator|<=
name|lastrange
operator|->
name|end
condition|)
block|{
comment|/* The ranges are adjacent or intersect. */
comment|/* svn_mergeinfo_parse promises to combine overlapping              ranges as long as their inheritability is the same. */
if|if
condition|(
name|range
operator|->
name|start
operator|<
name|lastrange
operator|->
name|end
operator|&&
name|range
operator|->
name|inheritable
operator|!=
name|lastrange
operator|->
name|inheritable
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to parse overlapping "
literal|"revision ranges '%s' and '%s' "
literal|"with different inheritance "
literal|"types"
argument_list|)
argument_list|,
name|range_to_string
argument_list|(
name|lastrange
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|range_to_string
argument_list|(
name|range
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Combine overlapping or adjacent ranges with the              same inheritability. */
if|if
condition|(
name|lastrange
operator|->
name|inheritable
operator|==
name|range
operator|->
name|inheritable
condition|)
block|{
name|lastrange
operator|->
name|end
operator|=
name|MAX
argument_list|(
name|range
operator|->
name|end
argument_list|,
name|lastrange
operator|->
name|end
argument_list|)
expr_stmt|;
name|svn_sort__array_delete
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
name|lastrange
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* revisionline -> PATHNAME COLON revisionlist  *  * Parse one line of mergeinfo starting at INPUT, not reading beyond END,  * into HASH. Allocate the new entry in HASH deeply from HASH's pool.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_revision_line
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|input
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|svn_mergeinfo_t
name|hash
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pathname
init|=
literal|""
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|existing_rangelist
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|parse_pathname
argument_list|(
name|input
argument_list|,
name|end
argument_list|,
operator|&
name|pathname
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
name|input
operator|)
operator|!=
literal|':'
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Pathname not terminated by ':'"
argument_list|)
argument_list|)
return|;
operator|*
name|input
operator|=
operator|*
name|input
operator|+
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_rangelist
argument_list|(
name|input
argument_list|,
name|end
argument_list|,
name|rangelist
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangelist
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Mergeinfo for '%s' maps to an "
literal|"empty revision range"
argument_list|)
argument_list|,
name|pathname
argument_list|)
return|;
if|if
condition|(
operator|*
name|input
operator|!=
name|end
operator|&&
operator|*
operator|(
operator|*
name|input
operator|)
operator|!=
literal|'\n'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not find end of line in range list line "
literal|"in '%s'"
argument_list|)
argument_list|,
operator|*
name|input
argument_list|)
return|;
if|if
condition|(
operator|*
name|input
operator|!=
name|end
condition|)
operator|*
name|input
operator|=
operator|*
name|input
operator|+
literal|1
expr_stmt|;
comment|/* Sort the rangelist, combine adjacent ranges into single ranges, and      make sure there are no overlapping ranges.  Luckily, most data in      svn:mergeinfo will already be in normalized form and this will be quick.    */
name|SVN_ERR
argument_list|(
name|svn_rangelist__canonicalize
argument_list|(
name|rangelist
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle any funky mergeinfo with relative merge source paths that      might exist due to issue #3547.  It's possible that this issue allowed      the creation of mergeinfo with path keys that differ only by a      leading slash, e.g. "trunk:4033\n/trunk:4039-4995".  In the event      we encounter this we merge the rangelists together under a single      absolute path key. */
name|klen
operator|=
name|strlen
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|existing_rangelist
operator|=
name|apr_hash_get
argument_list|(
name|hash
argument_list|,
name|pathname
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
name|existing_rangelist
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|rangelist
argument_list|,
name|existing_rangelist
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|hash
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|hash
argument_list|)
argument_list|,
name|pathname
argument_list|,
name|klen
argument_list|)
argument_list|,
name|klen
argument_list|,
name|svn_rangelist_dup
argument_list|(
name|rangelist
argument_list|,
name|apr_hash_pool_get
argument_list|(
name|hash
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* top -> revisionline (NEWLINE revisionline)*  *  * Parse mergeinfo starting at INPUT, not reading beyond END, into HASH.  * Allocate all the new entries in HASH deeply from HASH's pool.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_top
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|input
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|svn_mergeinfo_t
name|hash
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|input
operator|<
name|end
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_revision_line
argument_list|(
name|input
argument_list|,
name|end
argument_list|,
name|hash
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo_parse
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|input
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
operator|*
name|mergeinfo
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|parse_top
argument_list|(
operator|&
name|input
argument_list|,
name|input
operator|+
name|strlen
argument_list|(
name|input
argument_list|)
argument_list|,
operator|*
name|mergeinfo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Always return SVN_ERR_MERGEINFO_PARSE_ERROR as the topmost error. */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Could not parse mergeinfo string '%s'"
argument_list|)
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Cleanup after svn_rangelist_merge2 when it modifies the ending range of    a single rangelist element in-place.     If *RANGE_INDEX is not a valid element in RANGELIST do nothing.  Otherwise    ensure that RANGELIST[*RANGE_INDEX]->END does not adjoin or overlap any    subsequent ranges in RANGELIST.     If overlap is found, then remove, modify, and/or add elements to RANGELIST    as per the invariants for rangelists documented in svn_mergeinfo.h.  If    RANGELIST[*RANGE_INDEX]->END adjoins a subsequent element then combine the    elements if their inheritability permits -- The inheritance of intersecting    and adjoining ranges is handled as per svn_mergeinfo_merge2.  Upon return    set *RANGE_INDEX to the index of the youngest element modified, added, or    adjoined to RANGELIST[*RANGE_INDEX].     Note: Adjoining rangelist elements are those where the end rev of the older    element is equal to the start rev of the younger element.     Any new elements inserted into RANGELIST are allocated in  RESULT_POOL.*/
end_comment

begin_function
specifier|static
name|void
name|adjust_remaining_ranges
parameter_list|(
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|int
modifier|*
name|range_index
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|starting_index
decl_stmt|;
name|int
name|elements_to_delete
init|=
literal|0
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|modified_range
decl_stmt|;
if|if
condition|(
operator|*
name|range_index
operator|>=
name|rangelist
operator|->
name|nelts
condition|)
return|return;
name|starting_index
operator|=
operator|*
name|range_index
operator|+
literal|1
expr_stmt|;
name|modified_range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
operator|*
name|range_index
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|range_index
operator|+
literal|1
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|next_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
comment|/* If MODIFIED_RANGE doesn't adjoin or overlap the next range in          RANGELIST then we are finished. */
if|if
condition|(
name|modified_range
operator|->
name|end
operator|<
name|next_range
operator|->
name|start
condition|)
break|break;
comment|/* Does MODIFIED_RANGE adjoin NEXT_RANGE? */
if|if
condition|(
name|modified_range
operator|->
name|end
operator|==
name|next_range
operator|->
name|start
condition|)
block|{
if|if
condition|(
name|modified_range
operator|->
name|inheritable
operator|==
name|next_range
operator|->
name|inheritable
condition|)
block|{
comment|/* Combine adjoining ranges with the same inheritability. */
name|modified_range
operator|->
name|end
operator|=
name|next_range
operator|->
name|end
expr_stmt|;
name|elements_to_delete
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Cannot join because inheritance differs. */
operator|(
operator|*
name|range_index
operator|)
operator|++
expr_stmt|;
block|}
break|break;
block|}
comment|/* Alright, we know MODIFIED_RANGE overlaps NEXT_RANGE, but how? */
if|if
condition|(
name|modified_range
operator|->
name|end
operator|>
name|next_range
operator|->
name|end
condition|)
block|{
comment|/* NEXT_RANGE is a proper subset of MODIFIED_RANGE and the two              don't share the same end range. */
if|if
condition|(
name|modified_range
operator|->
name|inheritable
operator|||
operator|(
name|modified_range
operator|->
name|inheritable
operator|==
name|next_range
operator|->
name|inheritable
operator|)
condition|)
block|{
comment|/* MODIFIED_RANGE absorbs NEXT_RANGE. */
name|elements_to_delete
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* NEXT_RANGE is a proper subset MODIFIED_RANGE but                  MODIFIED_RANGE is non-inheritable and NEXT_RANGE is                  inheritable.  This means MODIFIED_RANGE is truncated,                  NEXT_RANGE remains, and the portion of MODIFIED_RANGE                  younger than NEXT_RANGE is added as a separate range:                   ______________________________________________                  |                                              |                  M                 MODIFIED_RANGE               N                  |                 (!inheritable)               |                  |______________________________________________|                                   |              |                                   O  NEXT_RANGE  P                                   | (inheritable)|                                   |______________|                                          |                                          V                   _______________________________________________                  |                |              |               |                  M MODIFIED_RANGE O  NEXT_RANGE  P   NEW_RANGE   N                  | (!inheritable) | (inheritable)| (!inheritable)|                  |________________|______________|_______________|               */
name|svn_merge_range_t
modifier|*
name|new_modified_range
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_modified_range
argument_list|)
argument_list|)
decl_stmt|;
name|new_modified_range
operator|->
name|start
operator|=
name|next_range
operator|->
name|end
expr_stmt|;
name|new_modified_range
operator|->
name|end
operator|=
name|modified_range
operator|->
name|end
expr_stmt|;
name|new_modified_range
operator|->
name|inheritable
operator|=
name|FALSE
expr_stmt|;
name|modified_range
operator|->
name|end
operator|=
name|next_range
operator|->
name|start
expr_stmt|;
operator|(
operator|*
name|range_index
operator|)
operator|+=
literal|2
expr_stmt|;
name|svn_sort__array_insert
argument_list|(
name|rangelist
argument_list|,
operator|&
name|new_modified_range
argument_list|,
operator|*
name|range_index
argument_list|)
expr_stmt|;
comment|/* Recurse with the new range. */
name|adjust_remaining_ranges
argument_list|(
name|rangelist
argument_list|,
name|range_index
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|modified_range
operator|->
name|end
operator|==
name|next_range
operator|->
name|end
condition|)
block|{
comment|/* NEXT_RANGE is a proper subset MODIFIED_RANGE and share              the same end range. */
if|if
condition|(
name|modified_range
operator|->
name|inheritable
operator|||
operator|(
name|modified_range
operator|->
name|inheritable
operator|==
name|next_range
operator|->
name|inheritable
operator|)
condition|)
block|{
comment|/* MODIFIED_RANGE absorbs NEXT_RANGE. */
name|elements_to_delete
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* The intersection between MODIFIED_RANGE and NEXT_RANGE is                  absorbed by the latter. */
name|modified_range
operator|->
name|end
operator|=
name|next_range
operator|->
name|start
expr_stmt|;
operator|(
operator|*
name|range_index
operator|)
operator|++
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* NEXT_RANGE and MODIFIED_RANGE intersect but NEXT_RANGE is not              a proper subset of MODIFIED_RANGE, nor do the two share the              same end revision, i.e. they overlap. */
if|if
condition|(
name|modified_range
operator|->
name|inheritable
operator|==
name|next_range
operator|->
name|inheritable
condition|)
block|{
comment|/* Combine overlapping ranges with the same inheritability. */
name|modified_range
operator|->
name|end
operator|=
name|next_range
operator|->
name|end
expr_stmt|;
name|elements_to_delete
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modified_range
operator|->
name|inheritable
condition|)
block|{
comment|/* MODIFIED_RANGE absorbs the portion of NEXT_RANGE it overlaps                  and NEXT_RANGE is truncated. */
name|next_range
operator|->
name|start
operator|=
name|modified_range
operator|->
name|end
expr_stmt|;
operator|(
operator|*
name|range_index
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* NEXT_RANGE absorbs the portion of MODIFIED_RANGE it overlaps                  and MODIFIED_RANGE is truncated. */
name|modified_range
operator|->
name|end
operator|=
name|next_range
operator|->
name|start
expr_stmt|;
operator|(
operator|*
name|range_index
operator|)
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|elements_to_delete
condition|)
name|svn_sort__array_delete
argument_list|(
name|rangelist
argument_list|,
name|starting_index
argument_list|,
name|elements_to_delete
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist_merge2
parameter_list|(
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|changes
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
comment|/* We may modify CHANGES, so make a copy in SCRATCH_POOL. */
name|changes
operator|=
name|svn_rangelist_dup
argument_list|(
name|changes
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|rangelist
operator|->
name|nelts
operator|&&
name|j
operator|<
name|changes
operator|->
name|nelts
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|change
init|=
name|APR_ARRAY_IDX
argument_list|(
name|changes
argument_list|,
name|j
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|int
name|res
init|=
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|range
argument_list|,
operator|&
name|change
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
comment|/* Only when merging two non-inheritable ranges is the result also              non-inheritable.  In all other cases ensure an inheritable              result. */
if|if
condition|(
name|range
operator|->
name|inheritable
operator|||
name|change
operator|->
name|inheritable
condition|)
name|range
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|<
literal|0
condition|)
comment|/* CHANGE is younger than RANGE */
block|{
if|if
condition|(
name|range
operator|->
name|end
operator|<
name|change
operator|->
name|start
condition|)
block|{
comment|/* RANGE is older than CHANGE and the two do not                  adjoin or overlap */
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|range
operator|->
name|end
operator|==
name|change
operator|->
name|start
condition|)
block|{
comment|/* RANGE and CHANGE adjoin */
if|if
condition|(
name|range
operator|->
name|inheritable
operator|==
name|change
operator|->
name|inheritable
condition|)
block|{
comment|/* RANGE and CHANGE have the same inheritability so                      RANGE expands to absord CHANGE. */
name|range
operator|->
name|end
operator|=
name|change
operator|->
name|end
expr_stmt|;
name|adjust_remaining_ranges
argument_list|(
name|rangelist
argument_list|,
operator|&
name|i
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* RANGE and CHANGE adjoin, but have different                      inheritability.  Since RANGE is older, just                      move on to the next RANGE. */
name|i
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* RANGE and CHANGE overlap, but how? */
if|if
condition|(
operator|(
name|range
operator|->
name|inheritable
operator|==
name|change
operator|->
name|inheritable
operator|)
operator|||
name|range
operator|->
name|inheritable
condition|)
block|{
comment|/* If CHANGE is a proper subset of RANGE, it absorbs RANGE                       with no adjustment otherwise only the intersection is                       absorbed and CHANGE is truncated. */
if|if
condition|(
name|range
operator|->
name|end
operator|>=
name|change
operator|->
name|end
condition|)
name|j
operator|++
expr_stmt|;
else|else
name|change
operator|->
name|start
operator|=
name|range
operator|->
name|end
expr_stmt|;
block|}
else|else
block|{
comment|/* RANGE is non-inheritable and CHANGE is inheritable. */
if|if
condition|(
name|range
operator|->
name|start
operator|<
name|change
operator|->
name|start
condition|)
block|{
comment|/* CHANGE absorbs intersection with RANGE and RANGE                          is truncated. */
name|svn_merge_range_t
modifier|*
name|range_copy
init|=
name|svn_merge_range_dup
argument_list|(
name|range
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|range_copy
operator|->
name|end
operator|=
name|change
operator|->
name|start
expr_stmt|;
name|range
operator|->
name|start
operator|=
name|change
operator|->
name|start
expr_stmt|;
name|svn_sort__array_insert
argument_list|(
name|rangelist
argument_list|,
operator|&
name|range_copy
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CHANGE and RANGE share the same start rev, but                          RANGE is considered older because its end rev                          is older. */
name|range
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|change
operator|->
name|start
operator|=
name|range
operator|->
name|end
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
comment|/* res> 0, CHANGE is older than RANGE */
block|{
if|if
condition|(
name|change
operator|->
name|end
operator|<
name|range
operator|->
name|start
condition|)
block|{
comment|/* CHANGE is older than RANGE and the two do not                  adjoin or overlap, so insert a copy of CHANGE                  into RANGELIST. */
name|svn_merge_range_t
modifier|*
name|change_copy
init|=
name|svn_merge_range_dup
argument_list|(
name|change
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|svn_sort__array_insert
argument_list|(
name|rangelist
argument_list|,
operator|&
name|change_copy
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|change
operator|->
name|end
operator|==
name|range
operator|->
name|start
condition|)
block|{
comment|/* RANGE and CHANGE adjoin */
if|if
condition|(
name|range
operator|->
name|inheritable
operator|==
name|change
operator|->
name|inheritable
condition|)
block|{
comment|/* RANGE and CHANGE have the same inheritability so we                      can simply combine the two in place. */
name|range
operator|->
name|start
operator|=
name|change
operator|->
name|start
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* RANGE and CHANGE have different inheritability so insert                      a copy of CHANGE into RANGELIST. */
name|svn_merge_range_t
modifier|*
name|change_copy
init|=
name|svn_merge_range_dup
argument_list|(
name|change
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|svn_sort__array_insert
argument_list|(
name|rangelist
argument_list|,
operator|&
name|change_copy
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* RANGE and CHANGE overlap. */
if|if
condition|(
name|range
operator|->
name|inheritable
operator|==
name|change
operator|->
name|inheritable
condition|)
block|{
comment|/* RANGE and CHANGE have the same inheritability so we                      can simply combine the two in place... */
name|range
operator|->
name|start
operator|=
name|change
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|end
operator|<
name|change
operator|->
name|end
condition|)
block|{
comment|/* ...but if RANGE is expanded ensure that we don't                          violate any rangelist invariants. */
name|range
operator|->
name|end
operator|=
name|change
operator|->
name|end
expr_stmt|;
name|adjust_remaining_ranges
argument_list|(
name|rangelist
argument_list|,
operator|&
name|i
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|range
operator|->
name|inheritable
condition|)
block|{
if|if
condition|(
name|change
operator|->
name|start
operator|<
name|range
operator|->
name|start
condition|)
block|{
comment|/* RANGE is inheritable so absorbs any part of CHANGE                          it overlaps.  CHANGE is truncated and the remainder                          inserted into RANGELIST. */
name|svn_merge_range_t
modifier|*
name|change_copy
init|=
name|svn_merge_range_dup
argument_list|(
name|change
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|change_copy
operator|->
name|end
operator|=
name|range
operator|->
name|start
expr_stmt|;
name|change
operator|->
name|start
operator|=
name|range
operator|->
name|start
expr_stmt|;
name|svn_sort__array_insert
argument_list|(
name|rangelist
argument_list|,
operator|&
name|change_copy
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CHANGE and RANGE share the same start rev, but                          CHANGE is considered older because CHANGE->END is                          older than RANGE->END. */
name|j
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* RANGE is non-inheritable and CHANGE is inheritable. */
if|if
condition|(
name|change
operator|->
name|start
operator|<
name|range
operator|->
name|start
condition|)
block|{
if|if
condition|(
name|change
operator|->
name|end
operator|==
name|range
operator|->
name|end
condition|)
block|{
comment|/* RANGE is a proper subset of CHANGE and share the                              same end revision, so set RANGE equal to CHANGE. */
name|range
operator|->
name|start
operator|=
name|change
operator|->
name|start
expr_stmt|;
name|range
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|change
operator|->
name|end
operator|>
name|range
operator|->
name|end
condition|)
block|{
comment|/* RANGE is a proper subset of CHANGE and CHANGE has                              a younger end revision, so set RANGE equal to its                              intersection with CHANGE and truncate CHANGE. */
name|range
operator|->
name|start
operator|=
name|change
operator|->
name|start
expr_stmt|;
name|range
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|change
operator|->
name|start
operator|=
name|range
operator|->
name|end
expr_stmt|;
block|}
else|else
block|{
comment|/* CHANGE and RANGE overlap. Set RANGE equal to its                              intersection with CHANGE and take the remainder                              of RANGE and insert it into RANGELIST. */
name|svn_merge_range_t
modifier|*
name|range_copy
init|=
name|svn_merge_range_dup
argument_list|(
name|range
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|range_copy
operator|->
name|start
operator|=
name|change
operator|->
name|end
expr_stmt|;
name|range
operator|->
name|start
operator|=
name|change
operator|->
name|start
expr_stmt|;
name|range
operator|->
name|end
operator|=
name|change
operator|->
name|end
expr_stmt|;
name|range
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|svn_sort__array_insert
argument_list|(
name|rangelist
argument_list|,
operator|&
name|range_copy
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* CHANGE and RANGE share the same start rev, but                          CHANGE is considered older because its end rev                          is older.                           Insert the intersection of RANGE and CHANGE into                          RANGELIST and then set RANGE to the non-intersecting                          portion of RANGE. */
name|svn_merge_range_t
modifier|*
name|range_copy
init|=
name|svn_merge_range_dup
argument_list|(
name|range
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|range_copy
operator|->
name|end
operator|=
name|change
operator|->
name|end
expr_stmt|;
name|range_copy
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|range
operator|->
name|start
operator|=
name|change
operator|->
name|end
expr_stmt|;
name|svn_sort__array_insert
argument_list|(
name|rangelist
argument_list|,
operator|&
name|range_copy
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Copy any remaining elements in CHANGES into RANGELIST. */
for|for
control|(
init|;
name|j
operator|<
operator|(
name|changes
operator|)
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|change
init|=
name|APR_ARRAY_IDX
argument_list|(
name|changes
argument_list|,
name|j
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|change_copy
init|=
name|svn_merge_range_dup
argument_list|(
name|change
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|svn_sort__array_insert
argument_list|(
name|rangelist
argument_list|,
operator|&
name|change_copy
argument_list|,
name|rangelist
operator|->
name|nelts
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff the forward revision ranges FIRST and SECOND overlap and  * (if CONSIDER_INHERITANCE is TRUE) have the same inheritability. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|range_intersect
parameter_list|(
specifier|const
name|svn_merge_range_t
modifier|*
name|first
parameter_list|,
specifier|const
name|svn_merge_range_t
modifier|*
name|second
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|)
block|{
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|IS_VALID_FORWARD_RANGE
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|IS_VALID_FORWARD_RANGE
argument_list|(
name|second
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|->
name|start
operator|+
literal|1
operator|<=
name|second
operator|->
name|end
operator|)
operator|&&
operator|(
name|second
operator|->
name|start
operator|+
literal|1
operator|<=
name|first
operator|->
name|end
operator|)
operator|&&
operator|(
operator|!
name|consider_inheritance
operator|||
operator|(
operator|!
operator|(
name|first
operator|->
name|inheritable
operator|)
operator|==
operator|!
operator|(
name|second
operator|->
name|inheritable
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff the forward revision range FIRST wholly contains the  * forward revision range SECOND and (if CONSIDER_INHERITANCE is TRUE) has  * the same inheritability. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|range_contains
parameter_list|(
specifier|const
name|svn_merge_range_t
modifier|*
name|first
parameter_list|,
specifier|const
name|svn_merge_range_t
modifier|*
name|second
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|)
block|{
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|IS_VALID_FORWARD_RANGE
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|IS_VALID_FORWARD_RANGE
argument_list|(
name|second
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|->
name|start
operator|<=
name|second
operator|->
name|start
operator|)
operator|&&
operator|(
name|second
operator|->
name|end
operator|<=
name|first
operator|->
name|end
operator|)
operator|&&
operator|(
operator|!
name|consider_inheritance
operator|||
operator|(
operator|!
operator|(
name|first
operator|->
name|inheritable
operator|)
operator|==
operator|!
operator|(
name|second
operator|->
name|inheritable
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Swap start and end fields of RANGE. */
end_comment

begin_function
specifier|static
name|void
name|range_swap_endpoints
parameter_list|(
name|svn_merge_range_t
modifier|*
name|range
parameter_list|)
block|{
name|svn_revnum_t
name|swap
init|=
name|range
operator|->
name|start
decl_stmt|;
name|range
operator|->
name|start
operator|=
name|range
operator|->
name|end
expr_stmt|;
name|range
operator|->
name|end
operator|=
name|swap
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist_reverse
parameter_list|(
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_sort__array_reverse
argument_list|(
name|rangelist
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|range_swap_endpoints
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_rangelist__set_inheritance
parameter_list|(
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|svn_boolean_t
name|inheritable
parameter_list|)
block|{
if|if
condition|(
name|rangelist
condition|)
block|{
name|int
name|i
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
name|range
operator|->
name|inheritable
operator|=
name|inheritable
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|void
name|svn_mergeinfo__set_inheritance
parameter_list|(
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|svn_boolean_t
name|inheritable
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|mergeinfo
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangelist
condition|)
name|svn_rangelist__set_inheritance
argument_list|(
name|rangelist
argument_list|,
name|inheritable
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* If DO_REMOVE is true, then remove any overlapping ranges described by    RANGELIST1 from RANGELIST2 and place the results in *OUTPUT.  When    DO_REMOVE is true, RANGELIST1 is effectively the "eraser" and RANGELIST2    the "whiteboard".     If DO_REMOVE is false, then capture the intersection between RANGELIST1    and RANGELIST2 and place the results in *OUTPUT.  The ordering of    RANGELIST1 and RANGELIST2 doesn't matter when DO_REMOVE is false.     If CONSIDER_INHERITANCE is true, then take the inheritance of the    ranges in RANGELIST1 and RANGELIST2 into account when comparing them    for intersection, see the doc string for svn_rangelist_intersect().     If CONSIDER_INHERITANCE is false, then ranges with differing inheritance    may intersect, but the resulting intersection is non-inheritable only    if both ranges were non-inheritable, e.g.:     RANGELIST1  RANGELIST2  CONSIDER     DO_REMOVE  *OUTPUT                            INHERITANCE    ----------  ------      -----------  ---------  -------     90-420*     1-100       TRUE         FALSE      Empty Rangelist    90-420      1-100*      TRUE         FALSE      Empty Rangelist    90-420      1-100       TRUE         FALSE      90-100    90-420*     1-100*      TRUE         FALSE      90-100*     90-420*     1-100       FALSE        FALSE      90-100    90-420      1-100*      FALSE        FALSE      90-100    90-420      1-100       FALSE        FALSE      90-100    90-420*     1-100*      FALSE        FALSE      90-100*     Allocate the contents of *OUTPUT in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rangelist_intersect_or_remove
parameter_list|(
name|svn_rangelist_t
modifier|*
modifier|*
name|output
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist1
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist2
parameter_list|,
name|svn_boolean_t
name|do_remove
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|lasti2
decl_stmt|;
name|svn_merge_range_t
name|working_elt2
decl_stmt|;
operator|*
name|output
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i1
operator|=
literal|0
expr_stmt|;
name|i2
operator|=
literal|0
expr_stmt|;
name|lasti2
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Initialized to a value that "i2" will never be. */
while|while
condition|(
name|i1
operator|<
name|rangelist1
operator|->
name|nelts
operator|&&
name|i2
operator|<
name|rangelist2
operator|->
name|nelts
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|elt1
decl_stmt|,
modifier|*
name|elt2
decl_stmt|;
name|elt1
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist1
argument_list|,
name|i1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Instead of making a copy of the entire array of rangelist2          elements, we just keep a copy of the current rangelist2 element          that needs to be used, and modify our copy if necessary. */
if|if
condition|(
name|i2
operator|!=
name|lasti2
condition|)
block|{
name|working_elt2
operator|=
operator|*
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|rangelist2
argument_list|,
name|i2
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|)
expr_stmt|;
name|lasti2
operator|=
name|i2
expr_stmt|;
block|}
name|elt2
operator|=
operator|&
name|working_elt2
expr_stmt|;
comment|/* If the rangelist2 range is contained completely in the          rangelist1, we increment the rangelist2.          If the ranges intersect, and match exactly, we increment both          rangelist1 and rangelist2.          Otherwise, we have to generate a range for the left part of          the removal of rangelist1 from rangelist2, and possibly change          the rangelist2 to the remaining portion of the right part of          the removal, to test against. */
if|if
condition|(
name|range_contains
argument_list|(
name|elt1
argument_list|,
name|elt2
argument_list|,
name|consider_inheritance
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|do_remove
condition|)
block|{
name|svn_merge_range_t
name|tmp_range
decl_stmt|;
name|tmp_range
operator|.
name|start
operator|=
name|elt2
operator|->
name|start
expr_stmt|;
name|tmp_range
operator|.
name|end
operator|=
name|elt2
operator|->
name|end
expr_stmt|;
comment|/* The intersection of two ranges is non-inheritable only                  if both ranges are non-inheritable. */
name|tmp_range
operator|.
name|inheritable
operator|=
operator|(
name|elt2
operator|->
name|inheritable
operator|||
name|elt1
operator|->
name|inheritable
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|combine_with_lastrange
argument_list|(
operator|&
name|tmp_range
argument_list|,
operator|*
name|output
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i2
operator|++
expr_stmt|;
if|if
condition|(
name|elt2
operator|->
name|start
operator|==
name|elt1
operator|->
name|start
operator|&&
name|elt2
operator|->
name|end
operator|==
name|elt1
operator|->
name|end
condition|)
name|i1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|range_intersect
argument_list|(
name|elt1
argument_list|,
name|elt2
argument_list|,
name|consider_inheritance
argument_list|)
condition|)
block|{
if|if
condition|(
name|elt2
operator|->
name|start
operator|<
name|elt1
operator|->
name|start
condition|)
block|{
comment|/* The rangelist2 range starts before the rangelist1 range. */
name|svn_merge_range_t
name|tmp_range
decl_stmt|;
if|if
condition|(
name|do_remove
condition|)
block|{
comment|/* Retain the range that falls before the rangelist1                      start. */
name|tmp_range
operator|.
name|start
operator|=
name|elt2
operator|->
name|start
expr_stmt|;
name|tmp_range
operator|.
name|end
operator|=
name|elt1
operator|->
name|start
expr_stmt|;
name|tmp_range
operator|.
name|inheritable
operator|=
name|elt2
operator|->
name|inheritable
expr_stmt|;
block|}
else|else
block|{
comment|/* Retain the range that falls between the rangelist1                      start and rangelist2 end. */
name|tmp_range
operator|.
name|start
operator|=
name|elt1
operator|->
name|start
expr_stmt|;
name|tmp_range
operator|.
name|end
operator|=
name|MIN
argument_list|(
name|elt2
operator|->
name|end
argument_list|,
name|elt1
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* The intersection of two ranges is non-inheritable only                      if both ranges are non-inheritable. */
name|tmp_range
operator|.
name|inheritable
operator|=
operator|(
name|elt2
operator|->
name|inheritable
operator|||
name|elt1
operator|->
name|inheritable
operator|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|combine_with_lastrange
argument_list|(
operator|&
name|tmp_range
argument_list|,
operator|*
name|output
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the rest of the rangelist2 range for further              processing.  */
if|if
condition|(
name|elt2
operator|->
name|end
operator|>
name|elt1
operator|->
name|end
condition|)
block|{
comment|/* The rangelist2 range ends after the rangelist1 range. */
if|if
condition|(
operator|!
name|do_remove
condition|)
block|{
comment|/* Partial overlap. */
name|svn_merge_range_t
name|tmp_range
decl_stmt|;
name|tmp_range
operator|.
name|start
operator|=
name|MAX
argument_list|(
name|elt2
operator|->
name|start
argument_list|,
name|elt1
operator|->
name|start
argument_list|)
expr_stmt|;
name|tmp_range
operator|.
name|end
operator|=
name|elt1
operator|->
name|end
expr_stmt|;
comment|/* The intersection of two ranges is non-inheritable only                      if both ranges are non-inheritable. */
name|tmp_range
operator|.
name|inheritable
operator|=
operator|(
name|elt2
operator|->
name|inheritable
operator|||
name|elt1
operator|->
name|inheritable
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|combine_with_lastrange
argument_list|(
operator|&
name|tmp_range
argument_list|,
operator|*
name|output
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|working_elt2
operator|.
name|start
operator|=
name|elt1
operator|->
name|end
expr_stmt|;
name|working_elt2
operator|.
name|end
operator|=
name|elt2
operator|->
name|end
expr_stmt|;
block|}
else|else
name|i2
operator|++
expr_stmt|;
block|}
else|else
comment|/* ranges don't intersect */
block|{
comment|/* See which side of the rangelist2 the rangelist1 is on.  If it              is on the left side, we need to move the rangelist1.               If it is on past the rangelist2 on the right side, we              need to output the rangelist2 and increment the              rangelist2.  */
if|if
condition|(
name|svn_sort_compare_ranges
argument_list|(
operator|&
name|elt1
argument_list|,
operator|&
name|elt2
argument_list|)
operator|<
literal|0
condition|)
name|i1
operator|++
expr_stmt|;
else|else
block|{
name|svn_merge_range_t
modifier|*
name|lastrange
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|output
operator|)
operator|->
name|nelts
operator|>
literal|0
condition|)
name|lastrange
operator|=
name|APR_ARRAY_IDX
argument_list|(
operator|*
name|output
argument_list|,
operator|(
operator|*
name|output
operator|)
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
else|else
name|lastrange
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|do_remove
operator|&&
operator|!
operator|(
name|lastrange
operator|&&
name|combine_ranges
argument_list|(
name|lastrange
argument_list|,
name|lastrange
argument_list|,
name|elt2
argument_list|,
name|consider_inheritance
argument_list|)
operator|)
condition|)
block|{
name|lastrange
operator|=
name|svn_merge_range_dup
argument_list|(
name|elt2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|output
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|lastrange
expr_stmt|;
block|}
name|i2
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|do_remove
condition|)
block|{
comment|/* Copy the current rangelist2 element if we didn't hit the end          of the rangelist2, and we still had it around.  This element          may have been touched, so we can't just walk the rangelist2          array, we have to use our copy.  This case only happens when          we ran out of rangelist1 before rangelist2, *and* we had changed          the rangelist2 element. */
if|if
condition|(
name|i2
operator|==
name|lasti2
operator|&&
name|i2
operator|<
name|rangelist2
operator|->
name|nelts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|combine_with_lastrange
argument_list|(
operator|&
name|working_elt2
argument_list|,
operator|*
name|output
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|i2
operator|++
expr_stmt|;
block|}
comment|/* Copy any other remaining untouched rangelist2 elements.  */
for|for
control|(
init|;
name|i2
operator|<
name|rangelist2
operator|->
name|nelts
condition|;
name|i2
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist2
argument_list|,
name|i2
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|combine_with_lastrange
argument_list|(
name|elt
argument_list|,
operator|*
name|output
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist_intersect
parameter_list|(
name|svn_rangelist_t
modifier|*
modifier|*
name|output
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist1
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist2
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|rangelist_intersect_or_remove
argument_list|(
name|output
argument_list|,
name|rangelist1
argument_list|,
name|rangelist2
argument_list|,
name|FALSE
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist_remove
parameter_list|(
name|svn_rangelist_t
modifier|*
modifier|*
name|output
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|eraser
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|whiteboard
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|rangelist_intersect_or_remove
argument_list|(
name|output
argument_list|,
name|eraser
argument_list|,
name|whiteboard
argument_list|,
name|TRUE
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist_diff
parameter_list|(
name|svn_rangelist_t
modifier|*
modifier|*
name|deleted
parameter_list|,
name|svn_rangelist_t
modifier|*
modifier|*
name|added
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|from
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|to
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* The following diagrams illustrate some common range delta scenarios:       (from)           deleted      r0<===========(=========)============[=========]===========> rHEAD      [to]                                    added       (from)           deleted                deleted      r0<===========(=========[============]=========)===========> rHEAD      [to]       (from)           deleted      r0<===========(=========[============)=========]===========> rHEAD      [to]                                    added       (from)                                  deleted      r0<===========[=========(============]=========)===========> rHEAD      [to]             added       (from)      r0<===========[=========(============)=========]===========> rHEAD      [to]             added                  added       (from)  d                                  d             d      r0<===(=[=)=]=[==]=[=(=)=]=[=]=[=(===|===(=)==|=|==[=(=]=)=> rHEAD      [to]        a   a    a   a   a   a                   a   */
comment|/* The items that are present in from, but not in to, must have been      deleted. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
name|deleted
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The items that are present in to, but not in from, must have been      added.  */
return|return
name|svn_rangelist_remove
argument_list|(
name|added
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|mergeinfo_diff_baton
block|{
name|svn_mergeinfo_t
name|from
decl_stmt|;
name|svn_mergeinfo_t
name|to
decl_stmt|;
name|svn_mergeinfo_t
name|deleted
decl_stmt|;
name|svn_mergeinfo_t
name|added
decl_stmt|;
name|svn_boolean_t
name|consider_inheritance
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This implements the 'svn_hash_diff_func_t' interface.    BATON is of type 'struct mergeinfo_diff_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mergeinfo_hash_diff_cb
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|enum
name|svn_hash_diff_key_status
name|status
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
comment|/* hash_a is FROM mergeinfo,      hash_b is TO mergeinfo. */
name|struct
name|mergeinfo_diff_baton
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|from_rangelist
decl_stmt|,
modifier|*
name|to_rangelist
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|key
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|svn_hash_diff_key_both
condition|)
block|{
comment|/* Record any deltas (additions or deletions). */
name|svn_rangelist_t
modifier|*
name|deleted_rangelist
decl_stmt|,
modifier|*
name|added_rangelist
decl_stmt|;
name|from_rangelist
operator|=
name|apr_hash_get
argument_list|(
name|cb
operator|->
name|from
argument_list|,
name|path
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|to_rangelist
operator|=
name|apr_hash_get
argument_list|(
name|cb
operator|->
name|to
argument_list|,
name|path
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_diff
argument_list|(
operator|&
name|deleted_rangelist
argument_list|,
operator|&
name|added_rangelist
argument_list|,
name|from_rangelist
argument_list|,
name|to_rangelist
argument_list|,
name|cb
operator|->
name|consider_inheritance
argument_list|,
name|cb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|deleted
operator|&&
name|deleted_rangelist
operator|->
name|nelts
operator|>
literal|0
condition|)
name|apr_hash_set
argument_list|(
name|cb
operator|->
name|deleted
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|cb
operator|->
name|pool
argument_list|,
name|path
argument_list|,
name|klen
argument_list|)
argument_list|,
name|klen
argument_list|,
name|deleted_rangelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|added
operator|&&
name|added_rangelist
operator|->
name|nelts
operator|>
literal|0
condition|)
name|apr_hash_set
argument_list|(
name|cb
operator|->
name|added
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|cb
operator|->
name|pool
argument_list|,
name|path
argument_list|,
name|klen
argument_list|)
argument_list|,
name|klen
argument_list|,
name|added_rangelist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|==
name|svn_hash_diff_key_a
operator|)
operator|&&
name|cb
operator|->
name|deleted
condition|)
block|{
name|from_rangelist
operator|=
name|apr_hash_get
argument_list|(
name|cb
operator|->
name|from
argument_list|,
name|path
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|cb
operator|->
name|deleted
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|cb
operator|->
name|pool
argument_list|,
name|path
argument_list|,
name|klen
argument_list|)
argument_list|,
name|klen
argument_list|,
name|svn_rangelist_dup
argument_list|(
name|from_rangelist
argument_list|,
name|cb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|==
name|svn_hash_diff_key_b
operator|)
operator|&&
name|cb
operator|->
name|added
condition|)
block|{
name|to_rangelist
operator|=
name|apr_hash_get
argument_list|(
name|cb
operator|->
name|to
argument_list|,
name|path
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|cb
operator|->
name|added
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|cb
operator|->
name|pool
argument_list|,
name|path
argument_list|,
name|klen
argument_list|)
argument_list|,
name|klen
argument_list|,
name|svn_rangelist_dup
argument_list|(
name|to_rangelist
argument_list|,
name|cb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Record deletions and additions of entire range lists (by path    presence), and delegate to svn_rangelist_diff() for delta    calculations on a specific path.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|walk_mergeinfo_hash_for_diff
parameter_list|(
name|svn_mergeinfo_t
name|from
parameter_list|,
name|svn_mergeinfo_t
name|to
parameter_list|,
name|svn_mergeinfo_t
name|deleted
parameter_list|,
name|svn_mergeinfo_t
name|added
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|mergeinfo_diff_baton
name|mdb
decl_stmt|;
name|mdb
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|mdb
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|mdb
operator|.
name|deleted
operator|=
name|deleted
expr_stmt|;
name|mdb
operator|.
name|added
operator|=
name|added
expr_stmt|;
name|mdb
operator|.
name|consider_inheritance
operator|=
name|consider_inheritance
expr_stmt|;
name|mdb
operator|.
name|pool
operator|=
name|result_pool
expr_stmt|;
return|return
name|svn_hash_diff
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|mergeinfo_hash_diff_cb
argument_list|,
operator|&
name|mdb
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo_diff2
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|deleted
parameter_list|,
name|svn_mergeinfo_t
modifier|*
name|added
parameter_list|,
name|svn_mergeinfo_t
name|from
parameter_list|,
name|svn_mergeinfo_t
name|to
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|from
operator|&&
name|to
operator|==
name|NULL
condition|)
block|{
operator|*
name|deleted
operator|=
name|svn_mergeinfo_dup
argument_list|(
name|from
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|added
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from
operator|==
name|NULL
operator|&&
name|to
condition|)
block|{
operator|*
name|deleted
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|added
operator|=
name|svn_mergeinfo_dup
argument_list|(
name|to
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|deleted
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|added
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|&&
name|to
condition|)
block|{
name|SVN_ERR
argument_list|(
name|walk_mergeinfo_hash_for_diff
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
operator|*
name|deleted
argument_list|,
operator|*
name|added
argument_list|,
name|consider_inheritance
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__equals
parameter_list|(
name|svn_boolean_t
modifier|*
name|is_equal
parameter_list|,
name|svn_mergeinfo_t
name|info1
parameter_list|,
name|svn_mergeinfo_t
name|info2
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
operator|*
name|is_equal
operator|=
name|FALSE
expr_stmt|;
comment|/* special cases: at least one side has no merge info */
if|if
condition|(
name|info1
operator|==
name|NULL
operator|&&
name|info2
operator|==
name|NULL
condition|)
block|{
operator|*
name|is_equal
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|info1
operator|==
name|NULL
operator|||
name|info2
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* trivial case: different number of paths -> unequal */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|info1
argument_list|)
operator|!=
name|apr_hash_count
argument_list|(
name|info2
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* compare range lists for all paths */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|info1
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|apr_ssize_t
name|key_length
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|lhs
decl_stmt|,
modifier|*
name|rhs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|deleted
decl_stmt|,
modifier|*
name|added
decl_stmt|;
comment|/* get both path lists */
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|key
argument_list|,
operator|&
name|key_length
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|lhs
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|apr_hash_get
argument_list|(
name|info2
argument_list|,
name|key
argument_list|,
name|key_length
argument_list|)
expr_stmt|;
comment|/* missing on one side? */
if|if
condition|(
name|rhs
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* quick compare: the range lists will often be a perfect match */
if|if
condition|(
name|lhs
operator|->
name|nelts
operator|==
name|rhs
operator|->
name|nelts
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lhs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_merge_range_t
modifier|*
name|lrange
init|=
name|APR_ARRAY_IDX
argument_list|(
name|lhs
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|rrange
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rhs
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
comment|/* range mismatch? -> needs detailed comparison */
if|if
condition|(
name|lrange
operator|->
name|start
operator|!=
name|rrange
operator|->
name|start
operator|||
name|lrange
operator|->
name|end
operator|!=
name|rrange
operator|->
name|end
condition|)
break|break;
comment|/* inheritance mismatch? -> merge info differs */
if|if
condition|(
name|consider_inheritance
operator|&&
name|lrange
operator|->
name|inheritable
operator|!=
name|rrange
operator|->
name|inheritable
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* all ranges found to match -> next path */
if|if
condition|(
name|i
operator|==
name|lhs
operator|->
name|nelts
condition|)
continue|continue;
block|}
comment|/* range lists differ but there are many ways to sort and aggregate          revisions into ranges. Do a full diff on them. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_diff
argument_list|(
operator|&
name|deleted
argument_list|,
operator|&
name|added
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|consider_inheritance
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleted
operator|->
name|nelts
operator|||
name|added
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* no mismatch found */
operator|*
name|is_equal
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo_merge2
parameter_list|(
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|changes
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
if|if
condition|(
operator|!
name|apr_hash_count
argument_list|(
name|changes
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|to_insert
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|target
decl_stmt|;
comment|/* get ranges to insert and the target ranges list of that insertion */
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|to_insert
argument_list|)
expr_stmt|;
name|target
operator|=
name|apr_hash_get
argument_list|(
name|mergeinfo
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
comment|/* if range list exists, just expand on it.        * Otherwise, add new hash entry. */
if|if
condition|(
name|target
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|target
argument_list|,
name|to_insert
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
name|apr_hash_set
argument_list|(
name|mergeinfo
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|to_insert
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo_catalog_merge
parameter_list|(
name|svn_mergeinfo_catalog_t
name|mergeinfo_cat
parameter_list|,
name|svn_mergeinfo_catalog_t
name|changes_cat
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_cat
init|=
name|svn_sort__hash
argument_list|(
name|mergeinfo_cat
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_changes
init|=
name|svn_sort__hash
argument_list|(
name|changes_cat
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|sorted_cat
operator|->
name|nelts
operator|&&
name|j
operator|<
name|sorted_changes
operator|->
name|nelts
condition|)
block|{
name|svn_sort__item_t
name|cat_elt
decl_stmt|,
name|change_elt
decl_stmt|;
name|int
name|res
decl_stmt|;
name|cat_elt
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_cat
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
expr_stmt|;
name|change_elt
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_changes
argument_list|,
name|j
argument_list|,
name|svn_sort__item_t
argument_list|)
expr_stmt|;
name|res
operator|=
name|svn_sort_compare_items_as_paths
argument_list|(
operator|&
name|cat_elt
argument_list|,
operator|&
name|change_elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
comment|/* Both catalogs have mergeinfo for a given path. */
block|{
name|svn_mergeinfo_t
name|mergeinfo
init|=
name|cat_elt
operator|.
name|value
decl_stmt|;
name|svn_mergeinfo_t
name|changes_mergeinfo
init|=
name|change_elt
operator|.
name|value
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|mergeinfo
argument_list|,
name|changes_mergeinfo
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|mergeinfo_cat
argument_list|,
name|cat_elt
operator|.
name|key
argument_list|,
name|cat_elt
operator|.
name|klen
argument_list|,
name|mergeinfo
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|<
literal|0
condition|)
comment|/* Only MERGEINFO_CAT has mergeinfo for this path. */
block|{
name|i
operator|++
expr_stmt|;
block|}
else|else
comment|/* Only CHANGES_CAT has mergeinfo for this path. */
block|{
name|apr_hash_set
argument_list|(
name|mergeinfo_cat
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|change_elt
operator|.
name|key
argument_list|)
argument_list|,
name|change_elt
operator|.
name|klen
argument_list|,
name|svn_mergeinfo_dup
argument_list|(
name|change_elt
operator|.
name|value
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
comment|/* Copy back any remaining elements from the CHANGES_CAT catalog. */
for|for
control|(
init|;
name|j
operator|<
name|sorted_changes
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_sort__item_t
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_changes
argument_list|,
name|j
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
name|apr_hash_set
argument_list|(
name|mergeinfo_cat
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|elt
operator|.
name|key
argument_list|)
argument_list|,
name|elt
operator|.
name|klen
argument_list|,
name|svn_mergeinfo_dup
argument_list|(
name|elt
operator|.
name|value
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo_intersect2
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo1
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo2
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
operator|*
name|mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* ### TODO(reint): Do we care about the case when a path in one      ### mergeinfo hash has inheritable mergeinfo, and in the other      ### has non-inheritable mergeinfo?  It seems like that path      ### itself should really be an intersection, while child paths      ### should not be... */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo1
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist1
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist2
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|rangelist2
operator|=
name|svn_hash_gets
argument_list|(
name|mergeinfo2
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangelist2
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|rangelist2
argument_list|,
name|rangelist1
argument_list|,
name|rangelist2
argument_list|,
name|consider_inheritance
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangelist2
operator|->
name|nelts
operator|>
literal|0
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|mergeinfo
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|path
argument_list|)
argument_list|,
name|svn_rangelist_dup
argument_list|(
name|rangelist2
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo_remove2
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|eraser
parameter_list|,
name|svn_mergeinfo_t
name|whiteboard
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|walk_mergeinfo_hash_for_diff
argument_list|(
name|whiteboard
argument_list|,
name|eraser
argument_list|,
operator|*
name|mergeinfo
argument_list|,
name|NULL
argument_list|,
name|consider_inheritance
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist_to_string
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|output
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangelist
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
decl_stmt|;
comment|/* Handle the elements that need commas at the end.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|range_to_string
argument_list|(
name|range
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
comment|/* Now handle the last element, which needs no comma.  */
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|range_to_string
argument_list|(
name|range
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|output
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Converts a mergeinfo INPUT to an unparsed mergeinfo in OUTPUT.  If PREFIX    is not NULL then prepend PREFIX to each line in OUTPUT.  If INPUT contains    no elements, return the empty string.  If INPUT contains any merge source    path keys that are relative then convert these to absolute paths in    *OUTPUT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mergeinfo_to_stringbuf
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|output
parameter_list|,
name|svn_mergeinfo_t
name|input
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|output
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|input
argument_list|)
operator|>
literal|0
condition|)
block|{
name|apr_array_header_t
modifier|*
name|sorted
init|=
name|svn_sort__hash
argument_list|(
name|input
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|revlist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_to_string
argument_list|(
operator|&
name|revlist
argument_list|,
name|elt
operator|.
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|output
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s%s%s:%s"
argument_list|,
name|prefix
condition|?
name|prefix
else|:
literal|""
argument_list|,
operator|*
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|elt
operator|.
name|key
operator|)
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|elt
operator|.
name|key
argument_list|,
name|revlist
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|sorted
operator|->
name|nelts
operator|-
literal|1
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
operator|*
name|output
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo_to_string
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|output
parameter_list|,
name|svn_mergeinfo_t
name|input
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|mergeinfo_buf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|mergeinfo_to_stringbuf
argument_list|(
operator|&
name|mergeinfo_buf
argument_list|,
name|input
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|mergeinfo_buf
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo_sort
parameter_list|(
name|svn_mergeinfo_t
name|input
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|input
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|apr_array_header_t
modifier|*
name|rl
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_sort__array
argument_list|(
name|rl
argument_list|,
name|svn_sort_compare_ranges
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__canonicalize_ranges
parameter_list|(
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|apr_array_header_t
modifier|*
name|rl
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist__canonicalize
argument_list|(
name|rl
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_mergeinfo_catalog_t
name|svn_mergeinfo_catalog_dup
parameter_list|(
name|svn_mergeinfo_catalog_t
name|mergeinfo_catalog
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|new_mergeinfo_catalog
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo_catalog
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|val
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|new_mergeinfo_catalog
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|key
argument_list|)
argument_list|,
name|svn_mergeinfo_dup
argument_list|(
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|new_mergeinfo_catalog
return|;
block|}
end_function

begin_function
name|svn_mergeinfo_t
name|svn_mergeinfo_dup
parameter_list|(
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|new_mergeinfo
init|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|pathlen
init|=
name|apr_hash_this_key_len
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_hash_set
argument_list|(
name|new_mergeinfo
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|,
name|pathlen
argument_list|)
argument_list|,
name|pathlen
argument_list|,
name|svn_rangelist_dup
argument_list|(
name|rangelist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|new_mergeinfo
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo_inheritable2
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|output
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|inheritable
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_mergeinfo_t
name|inheritable_mergeinfo
init|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|keylen
init|=
name|apr_hash_this_key_len
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|inheritable_rangelist
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|||
name|svn_path_compare_paths
argument_list|(
name|path
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_inheritable2
argument_list|(
operator|&
name|inheritable_rangelist
argument_list|,
name|rangelist
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|inheritable
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|inheritable_rangelist
operator|=
name|svn_rangelist_dup
argument_list|(
name|rangelist
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Only add this rangelist if some ranges remain.  A rangelist with          a path mapped to an empty rangelist is not syntactically valid */
if|if
condition|(
name|inheritable_rangelist
operator|->
name|nelts
condition|)
name|apr_hash_set
argument_list|(
name|inheritable_mergeinfo
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
argument_list|,
name|keylen
argument_list|,
name|inheritable_rangelist
argument_list|)
expr_stmt|;
block|}
operator|*
name|output
operator|=
name|inheritable_mergeinfo
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist_inheritable2
parameter_list|(
name|svn_rangelist_t
modifier|*
modifier|*
name|inheritable_rangelist
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|inheritable
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|inheritable_rangelist
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangelist
operator|->
name|nelts
condition|)
block|{
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start
argument_list|)
operator|||
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end
argument_list|)
operator|||
name|end
operator|<
name|start
condition|)
block|{
comment|/* We want all (non-inheritable or inheritable) ranges removed. */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|inheritable
operator|==
name|inheritable
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|inheritable_rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|svn_merge_range_dup
argument_list|(
name|range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We want only the (non-inheritable or inheritable) ranges              bound by START and END removed. */
name|svn_rangelist_t
modifier|*
name|ranges_inheritable
init|=
name|svn_rangelist__initialize
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|inheritable
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangelist
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
name|inheritable_rangelist
argument_list|,
name|ranges_inheritable
argument_list|,
name|rangelist
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_mergeinfo__remove_empty_rangelists
parameter_list|(
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|removed_some_ranges
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|mergeinfo
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangelist
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|mergeinfo
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|removed_some_ranges
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
return|return
name|removed_some_ranges
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__remove_prefix_from_catalog
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|out_catalog
parameter_list|,
name|svn_mergeinfo_catalog_t
name|in_catalog
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|prefix_path
index|[
literal|0
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|out_catalog
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|in_catalog
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|original_path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|value
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_path
decl_stmt|;
name|new_path
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|prefix_path
argument_list|,
name|original_path
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|new_path
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|out_catalog
argument_list|,
name|new_path
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__add_prefix_to_catalog
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|out_catalog
parameter_list|,
name|svn_mergeinfo_catalog_t
name|in_catalog
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix_path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
operator|*
name|out_catalog
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|in_catalog
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|original_path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|value
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|original_path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|original_path
operator|++
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|out_catalog
argument_list|,
name|svn_dirent_join
argument_list|(
name|prefix_path
argument_list|,
name|original_path
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__add_suffix_to_mergeinfo
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|out_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|suffix_relpath
operator|&&
name|svn_relpath_is_canonical
argument_list|(
name|suffix_relpath
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|out_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|fspath
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|out_mergeinfo
argument_list|,
name|svn_fspath__join
argument_list|(
name|fspath
argument_list|,
name|suffix_relpath
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|rangelist
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Deep-copy an array of pointers to simple objects.  *  * Return a duplicate in POOL of the array ARRAY of pointers to objects  * of size OBJECT_SIZE bytes. Duplicate each object bytewise.  */
end_comment

begin_function
specifier|static
name|apr_array_header_t
modifier|*
name|ptr_array_dup
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|array
parameter_list|,
name|size_t
name|object_size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|new_array
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|array
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* allocate target range buffer with a single operation */
name|char
modifier|*
name|copy
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|object_size
operator|*
name|array
operator|->
name|nelts
argument_list|)
decl_stmt|;
comment|/* for efficiency, directly address source and target reference buffers */
name|void
modifier|*
modifier|*
name|source
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|array
operator|->
name|elts
operator|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|target
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|new_array
operator|->
name|elts
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* copy ranges iteratively and link them into the target range list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|target
index|[
name|i
index|]
operator|=
operator|&
name|copy
index|[
name|i
operator|*
name|object_size
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|target
index|[
name|i
index|]
argument_list|,
name|source
index|[
name|i
index|]
argument_list|,
name|object_size
argument_list|)
expr_stmt|;
block|}
name|new_array
operator|->
name|nelts
operator|=
name|array
operator|->
name|nelts
expr_stmt|;
return|return
name|new_array
return|;
block|}
end_function

begin_function
name|svn_rangelist_t
modifier|*
name|svn_rangelist_dup
parameter_list|(
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|ptr_array_dup
argument_list|(
name|rangelist
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_merge_range_t
modifier|*
name|svn_merge_range_dup
parameter_list|(
specifier|const
name|svn_merge_range_t
modifier|*
name|range
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_merge_range_t
modifier|*
name|new_range
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_range
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new_range
argument_list|,
name|range
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_range
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_range
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_merge_range_contains_rev
parameter_list|(
specifier|const
name|svn_merge_range_t
modifier|*
name|range
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|)
block|{
name|assert
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|range
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|range
operator|->
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|range
operator|->
name|start
operator|!=
name|range
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|start
operator|<
name|range
operator|->
name|end
condition|)
return|return
name|rev
operator|>
name|range
operator|->
name|start
operator|&&
name|rev
operator|<=
name|range
operator|->
name|end
return|;
else|else
return|return
name|rev
operator|>
name|range
operator|->
name|end
operator|&&
name|rev
operator|<=
name|range
operator|->
name|start
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__catalog_to_formatted_string
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|output
parameter_list|,
name|svn_mergeinfo_catalog_t
name|catalog
parameter_list|,
specifier|const
name|char
modifier|*
name|key_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|val_prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|output_buf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|catalog
operator|&&
name|apr_hash_count
argument_list|(
name|catalog
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_catalog
init|=
name|svn_sort__hash
argument_list|(
name|catalog
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|output_buf
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_catalog
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_catalog
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path1
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|mergeinfo_output_buf
decl_stmt|;
name|path1
operator|=
name|elt
operator|.
name|key
expr_stmt|;
name|mergeinfo
operator|=
name|elt
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|key_prefix
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|output_buf
argument_list|,
name|key_prefix
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|output_buf
argument_list|,
name|path1
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|output_buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mergeinfo_to_stringbuf
argument_list|(
operator|&
name|mergeinfo_output_buf
argument_list|,
name|mergeinfo
argument_list|,
name|val_prefix
condition|?
name|val_prefix
else|:
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendstr
argument_list|(
name|output_buf
argument_list|,
name|mergeinfo_output_buf
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|output_buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|SVN_DEBUG
elseif|else
if|if
condition|(
operator|!
name|catalog
condition|)
block|{
name|output_buf
operator|=
name|svn_stringbuf_create
argument_list|(
name|key_prefix
condition|?
name|key_prefix
else|:
literal|""
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|output_buf
argument_list|,
name|_
argument_list|(
literal|"NULL mergeinfo catalog\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_hash_count
argument_list|(
name|catalog
argument_list|)
operator|==
literal|0
condition|)
block|{
name|output_buf
operator|=
name|svn_stringbuf_create
argument_list|(
name|key_prefix
condition|?
name|key_prefix
else|:
literal|""
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|output_buf
argument_list|,
name|_
argument_list|(
literal|"empty mergeinfo catalog\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we have an output_buf, convert it to an svn_string_t;      otherwise, return a new string containing only a newline      character.  */
if|if
condition|(
name|output_buf
condition|)
operator|*
name|output
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|output_buf
argument_list|)
expr_stmt|;
else|else
operator|*
name|output
operator|=
name|svn_string_create
argument_list|(
literal|"\n"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__get_range_endpoints
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_rev
parameter_list|,
name|svn_revnum_t
modifier|*
name|oldest_rev
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|youngest_rev
operator|=
operator|*
name|oldest_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|mergeinfo
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangelist
operator|->
name|nelts
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|rangelist
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|youngest_rev
argument_list|)
operator|||
operator|(
name|range
operator|->
name|end
operator|>
operator|*
name|youngest_rev
operator|)
condition|)
operator|*
name|youngest_rev
operator|=
name|range
operator|->
name|end
expr_stmt|;
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|oldest_rev
argument_list|)
operator|||
operator|(
name|range
operator|->
name|start
operator|<
operator|*
name|oldest_rev
operator|)
condition|)
operator|*
name|oldest_rev
operator|=
name|range
operator|->
name|start
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__filter_catalog_by_ranges
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|filtered_cat
parameter_list|,
name|svn_mergeinfo_catalog_t
name|catalog
parameter_list|,
name|svn_revnum_t
name|youngest_rev
parameter_list|,
name|svn_revnum_t
name|oldest_rev
parameter_list|,
name|svn_boolean_t
name|include_range
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
operator|*
name|filtered_cat
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|catalog
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|filtered_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|filtered_mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|youngest_rev
argument_list|,
name|oldest_rev
argument_list|,
name|include_range
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|filtered_mergeinfo
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|filtered_cat
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|path
argument_list|)
argument_list|,
name|filtered_mergeinfo
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__filter_mergeinfo_by_ranges
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|filtered_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|svn_revnum_t
name|youngest_rev
parameter_list|,
name|svn_revnum_t
name|oldest_rev
parameter_list|,
name|svn_boolean_t
name|include_range
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|youngest_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|oldest_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|oldest_rev
operator|<
name|youngest_rev
argument_list|)
expr_stmt|;
operator|*
name|filtered_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergeinfo
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|filter_rangelist
init|=
name|svn_rangelist__initialize
argument_list|(
name|oldest_rev
argument_list|,
name|youngest_rev
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangelist
operator|->
name|nelts
condition|)
block|{
name|svn_rangelist_t
modifier|*
name|new_rangelist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|rangelist_intersect_or_remove
argument_list|(
operator|&
name|new_rangelist
argument_list|,
name|filter_rangelist
argument_list|,
name|rangelist
argument_list|,
operator|!
name|include_range
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rangelist
operator|->
name|nelts
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|filtered_mergeinfo
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|path
argument_list|)
argument_list|,
name|new_rangelist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__adjust_mergeinfo_rangelists
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|adjusted_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|svn_revnum_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
operator|*
name|adjusted_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergeinfo
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|adjusted_rangelist
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|rangelist
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|start
operator|+
name|offset
operator|>
literal|0
operator|&&
name|range
operator|->
name|end
operator|+
name|offset
operator|>
literal|0
condition|)
block|{
name|range
operator|->
name|start
operator|=
name|range
operator|->
name|start
operator|+
name|offset
expr_stmt|;
name|range
operator|->
name|end
operator|=
name|range
operator|->
name|end
operator|+
name|offset
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|adjusted_rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|range
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adjusted_rangelist
operator|->
name|nelts
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|adjusted_mergeinfo
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|path
argument_list|)
argument_list|,
name|adjusted_rangelist
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_mergeinfo__is_noninheritable
parameter_list|(
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|mergeinfo
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|range
operator|->
name|inheritable
condition|)
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_rangelist_t
modifier|*
name|svn_rangelist__initialize
parameter_list|(
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|inheritable
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|range
argument_list|)
argument_list|)
decl_stmt|;
name|range
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|range
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|range
operator|->
name|inheritable
operator|=
name|inheritable
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|range
expr_stmt|;
return|return
name|rangelist
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_mergeinfo__mergeinfo_from_segments
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo_p
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|segments
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|mergeinfo
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Translate location segments into merge sources and ranges. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|segments
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_location_segment_t
modifier|*
name|segment
init|=
name|APR_ARRAY_IDX
argument_list|(
name|segments
argument_list|,
name|i
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|path_ranges
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_path
decl_stmt|;
comment|/* No path segment?  Skip it. */
if|if
condition|(
operator|!
name|segment
operator|->
name|path
condition|)
continue|continue;
comment|/* Prepend a leading slash to our path. */
name|source_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|segment
operator|->
name|path
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
comment|/* See if we already stored ranges for this path.  If not, make          a new list.  */
name|path_ranges
operator|=
name|svn_hash_gets
argument_list|(
name|mergeinfo
argument_list|,
name|source_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path_ranges
condition|)
name|path_ranges
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|range
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A svn_location_segment_t may have legitimately describe only          revision 0, but there is no corresponding representation for          this in a svn_merge_range_t. */
if|if
condition|(
name|segment
operator|->
name|range_start
operator|==
literal|0
operator|&&
name|segment
operator|->
name|range_end
operator|==
literal|0
condition|)
continue|continue;
comment|/* Build a merge range, push it onto the list of ranges, and for          good measure, (re)store it in the hash. */
name|range
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|range
argument_list|)
argument_list|)
expr_stmt|;
name|range
operator|->
name|start
operator|=
name|MAX
argument_list|(
name|segment
operator|->
name|range_start
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|range
operator|->
name|end
operator|=
name|segment
operator|->
name|range_end
expr_stmt|;
name|range
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|path_ranges
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|range
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|mergeinfo
argument_list|,
name|source_path
argument_list|,
name|path_ranges
argument_list|)
expr_stmt|;
block|}
operator|*
name|mergeinfo_p
operator|=
name|mergeinfo
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_rangelist__merge_many
parameter_list|(
name|svn_rangelist_t
modifier|*
name|merged_rangelist
parameter_list|,
name|svn_mergeinfo_t
name|merge_history
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|apr_hash_count
argument_list|(
name|merge_history
argument_list|)
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|merge_history
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_rangelist_t
modifier|*
name|subtree_rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|merged_rangelist
argument_list|,
name|subtree_rangelist
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_inheritance_to_word
parameter_list|(
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|)
block|{
switch|switch
condition|(
name|inherit
condition|)
block|{
case|case
name|svn_mergeinfo_inherited
case|:
return|return
literal|"inherited"
return|;
case|case
name|svn_mergeinfo_nearest_ancestor
case|:
return|return
literal|"nearest-ancestor"
return|;
default|default:
return|return
literal|"explicit"
return|;
block|}
block|}
end_function

begin_function
name|svn_mergeinfo_inheritance_t
name|svn_inheritance_from_word
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"inherited"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_mergeinfo_inherited
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"nearest-ancestor"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_mergeinfo_nearest_ancestor
return|;
return|return
name|svn_mergeinfo_explicit
return|;
block|}
end_function

end_unit

