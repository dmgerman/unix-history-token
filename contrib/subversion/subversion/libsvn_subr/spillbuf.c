begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * spillbuf.c : an in-memory buffer that can spill to disk  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_struct
struct|struct
name|memblock_t
block|{
name|apr_size_t
name|size
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|struct
name|memblock_t
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|svn_spillbuf_t
block|{
comment|/* Pool for allocating blocks and the spill file.  */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Size of in-memory blocks.  */
name|apr_size_t
name|blocksize
decl_stmt|;
comment|/* Maximum in-memory size; start spilling when we reach this size.  */
name|apr_size_t
name|maxsize
decl_stmt|;
comment|/* The amount of content in memory.  */
name|apr_size_t
name|memory_size
decl_stmt|;
comment|/* HEAD points to the first block of the linked list of buffers.      TAIL points to the last block, for quickly appending more blocks      to the overall list.  */
name|struct
name|memblock_t
modifier|*
name|head
decl_stmt|;
name|struct
name|memblock_t
modifier|*
name|tail
decl_stmt|;
comment|/* Available blocks for storing pending data. These were allocated      previously, then the data consumed and returned to this list.  */
name|struct
name|memblock_t
modifier|*
name|avail
decl_stmt|;
comment|/* When a block is borrowed for reading, it is listed here.  */
name|struct
name|memblock_t
modifier|*
name|out_for_reading
decl_stmt|;
comment|/* Once MEMORY_SIZE exceeds SPILL_SIZE, then arriving content will be      appended to the (temporary) file indicated by SPILL.  */
name|apr_file_t
modifier|*
name|spill
decl_stmt|;
comment|/* As we consume content from SPILL, this value indicates where we      will begin reading.  */
name|apr_off_t
name|spill_start
decl_stmt|;
comment|/* How much content remains in SPILL.  */
name|svn_filesize_t
name|spill_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|svn_spillbuf_reader_t
block|{
comment|/* Embed the spill-buffer within the reader.  */
name|struct
name|svn_spillbuf_t
name|buf
decl_stmt|;
comment|/* When we read content from the underlying spillbuf, these fields store      the ptr/len pair. The ptr will be incremented as we "read" out of this      buffer since we don't have to retain the original pointer (it is      managed inside of the spillbuf).  */
specifier|const
name|char
modifier|*
name|sb_ptr
decl_stmt|;
name|apr_size_t
name|sb_len
decl_stmt|;
comment|/* If a write comes in, then we may need to save content from our      borrowed buffer (since that buffer may be destroyed by our call into      the spillbuf code). Note that we retain the original pointer since      this buffer is allocated by the reader code and re-used. The SAVE_POS      field indicates the current position within this save buffer. The      SAVE_LEN field describes how much content is present.  */
name|char
modifier|*
name|save_ptr
decl_stmt|;
name|apr_size_t
name|save_len
decl_stmt|;
name|apr_size_t
name|save_pos
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|svn_spillbuf_t
modifier|*
name|svn_spillbuf__create
parameter_list|(
name|apr_size_t
name|blocksize
parameter_list|,
name|apr_size_t
name|maxsize
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_spillbuf_t
modifier|*
name|buf
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|buf
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|buf
operator|->
name|blocksize
operator|=
name|blocksize
expr_stmt|;
name|buf
operator|->
name|maxsize
operator|=
name|maxsize
expr_stmt|;
comment|/* Note: changes here should also go into svn_spillbuf__reader_create() */
return|return
name|buf
return|;
block|}
end_function

begin_function
name|svn_filesize_t
name|svn_spillbuf__get_size
parameter_list|(
specifier|const
name|svn_spillbuf_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|buf
operator|->
name|memory_size
operator|+
name|buf
operator|->
name|spill_size
return|;
block|}
end_function

begin_comment
comment|/* Get a memblock from the spill-buffer. It will be the block that we    passed out for reading, come from the free list, or allocated.  */
end_comment

begin_function
specifier|static
name|struct
name|memblock_t
modifier|*
name|get_buffer
parameter_list|(
name|svn_spillbuf_t
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|memblock_t
modifier|*
name|mem
init|=
name|buf
operator|->
name|out_for_reading
decl_stmt|;
if|if
condition|(
name|mem
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|->
name|out_for_reading
operator|=
name|NULL
expr_stmt|;
return|return
name|mem
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|avail
operator|==
name|NULL
condition|)
block|{
name|mem
operator|=
name|apr_palloc
argument_list|(
name|buf
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|->
name|data
operator|=
name|apr_palloc
argument_list|(
name|buf
operator|->
name|pool
argument_list|,
name|buf
operator|->
name|blocksize
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
name|mem
operator|=
name|buf
operator|->
name|avail
expr_stmt|;
name|buf
operator|->
name|avail
operator|=
name|mem
operator|->
name|next
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* Return MEM to the list of available buffers in BUF.  */
end_comment

begin_function
specifier|static
name|void
name|return_buffer
parameter_list|(
name|svn_spillbuf_t
modifier|*
name|buf
parameter_list|,
name|struct
name|memblock_t
modifier|*
name|mem
parameter_list|)
block|{
name|mem
operator|->
name|next
operator|=
name|buf
operator|->
name|avail
expr_stmt|;
name|buf
operator|->
name|avail
operator|=
name|mem
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_spillbuf__write
parameter_list|(
name|svn_spillbuf_t
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|memblock_t
modifier|*
name|mem
decl_stmt|;
comment|/* We do not (yet) have a spill file, but the amount stored in memory      will grow too large. Create the file and place the pending data into      the temporary file.  */
if|if
condition|(
name|buf
operator|->
name|spill
operator|==
name|NULL
operator|&&
operator|(
name|buf
operator|->
name|memory_size
operator|+
name|len
operator|)
operator|>
name|buf
operator|->
name|maxsize
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|buf
operator|->
name|spill
argument_list|,
name|NULL
comment|/* temp_path */
argument_list|,
name|NULL
comment|/* dirpath */
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|buf
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Once a spill file has been constructed, then we need to put all      arriving data into the file. We will no longer attempt to hold it      in memory.  */
if|if
condition|(
name|buf
operator|->
name|spill
operator|!=
name|NULL
condition|)
block|{
name|apr_off_t
name|output_unused
init|=
literal|0
decl_stmt|;
comment|/* ### stupid API  */
comment|/* Seek to the end of the spill file. We don't know if a read has          occurred since our last write, and moved the file position.  */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|buf
operator|->
name|spill
argument_list|,
name|APR_END
argument_list|,
operator|&
name|output_unused
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|buf
operator|->
name|spill
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|spill_size
operator|+=
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|amt
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|tail
operator|==
name|NULL
operator|||
name|buf
operator|->
name|tail
operator|->
name|size
operator|==
name|buf
operator|->
name|blocksize
condition|)
block|{
comment|/* There is no existing memblock (that may have space), or the              tail memblock has no space, so we need a new memblock.  */
name|mem
operator|=
name|get_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|mem
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mem
operator|=
name|buf
operator|->
name|tail
expr_stmt|;
block|}
comment|/* Compute how much to write into the memblock.  */
name|amt
operator|=
name|buf
operator|->
name|blocksize
operator|-
name|mem
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|amt
operator|>
name|len
condition|)
name|amt
operator|=
name|len
expr_stmt|;
comment|/* Copy some data into this memblock.  */
name|memcpy
argument_list|(
operator|&
name|mem
operator|->
name|data
index|[
name|mem
operator|->
name|size
index|]
argument_list|,
name|data
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|mem
operator|->
name|size
operator|+=
name|amt
expr_stmt|;
name|data
operator|+=
name|amt
expr_stmt|;
name|len
operator|-=
name|amt
expr_stmt|;
comment|/* We need to record how much is buffered in memory. Once we reach          buf->maxsize (or thereabouts, it doesn't have to be precise), then          we'll switch to putting the content into a file.  */
name|buf
operator|->
name|memory_size
operator|+=
name|amt
expr_stmt|;
comment|/* Start a list of buffers, or (if we're not writing into the tail)          append to the end of the linked list of buffers.  */
if|if
condition|(
name|buf
operator|->
name|tail
operator|==
name|NULL
condition|)
block|{
name|buf
operator|->
name|head
operator|=
name|mem
expr_stmt|;
name|buf
operator|->
name|tail
operator|=
name|mem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mem
operator|!=
name|buf
operator|->
name|tail
condition|)
block|{
name|buf
operator|->
name|tail
operator|->
name|next
operator|=
name|mem
expr_stmt|;
name|buf
operator|->
name|tail
operator|=
name|mem
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a memblock of content, if any is available. *mem will be NULL if    no further content is available. The memblock should eventually be    passed to return_buffer() (or stored into buf->out_for_reading which    will grab that block at the next get_buffer() call). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_data
parameter_list|(
name|struct
name|memblock_t
modifier|*
modifier|*
name|mem
parameter_list|,
name|svn_spillbuf_t
modifier|*
name|buf
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* If we have some in-memory blocks, then return one.  */
if|if
condition|(
name|buf
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mem
operator|=
name|buf
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|tail
operator|==
operator|*
name|mem
condition|)
name|buf
operator|->
name|head
operator|=
name|buf
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
else|else
name|buf
operator|->
name|head
operator|=
operator|(
operator|*
name|mem
operator|)
operator|->
name|next
expr_stmt|;
comment|/* We're using less memory now. If we haven't hit the spill file,          then we may be able to keep using memory.  */
name|buf
operator|->
name|memory_size
operator|-=
operator|(
operator|*
name|mem
operator|)
operator|->
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* No file? Done.  */
if|if
condition|(
name|buf
operator|->
name|spill
operator|==
name|NULL
condition|)
block|{
operator|*
name|mem
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Assume that the caller has seeked the spill file to the correct pos.  */
comment|/* Get a buffer that we can read content into.  */
operator|*
name|mem
operator|=
name|get_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* NOTE: mem's size/next are uninitialized.  */
if|if
condition|(
operator|(
name|apr_uint64_t
operator|)
name|buf
operator|->
name|spill_size
operator|<
operator|(
name|apr_uint64_t
operator|)
name|buf
operator|->
name|blocksize
condition|)
operator|(
operator|*
name|mem
operator|)
operator|->
name|size
operator|=
operator|(
name|apr_size_t
operator|)
name|buf
operator|->
name|spill_size
expr_stmt|;
else|else
operator|(
operator|*
name|mem
operator|)
operator|->
name|size
operator|=
name|buf
operator|->
name|blocksize
expr_stmt|;
comment|/* The size of (*mem)->data  */
operator|(
operator|*
name|mem
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Read some data from the spill file into the memblock.  */
name|err
operator|=
name|svn_io_file_read
argument_list|(
name|buf
operator|->
name|spill
argument_list|,
operator|(
operator|*
name|mem
operator|)
operator|->
name|data
argument_list|,
operator|&
operator|(
operator|*
name|mem
operator|)
operator|->
name|size
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|return_buffer
argument_list|(
name|buf
argument_list|,
operator|*
name|mem
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* Mark the data that we consumed from the spill file.  */
name|buf
operator|->
name|spill_start
operator|+=
operator|(
operator|*
name|mem
operator|)
operator|->
name|size
expr_stmt|;
comment|/* Did we consume all the data from the spill file?  */
if|if
condition|(
operator|(
name|buf
operator|->
name|spill_size
operator|-=
operator|(
operator|*
name|mem
operator|)
operator|->
name|size
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Close and reset our spill file information.  */
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|buf
operator|->
name|spill
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|spill
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|spill_start
operator|=
literal|0
expr_stmt|;
block|}
comment|/* *mem has been initialized. Done.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If the next read would consume data from the file, then seek to the    correct position.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_seek
parameter_list|(
name|svn_boolean_t
modifier|*
name|seeked
parameter_list|,
specifier|const
name|svn_spillbuf_t
modifier|*
name|buf
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|->
name|head
operator|==
name|NULL
operator|&&
name|buf
operator|->
name|spill
operator|!=
name|NULL
condition|)
block|{
name|apr_off_t
name|output_unused
decl_stmt|;
comment|/* Seek to where we left off reading.  */
name|output_unused
operator|=
name|buf
operator|->
name|spill_start
expr_stmt|;
comment|/* ### stupid API  */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|buf
operator|->
name|spill
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|output_unused
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seeked
operator|!=
name|NULL
condition|)
operator|*
name|seeked
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seeked
operator|!=
name|NULL
condition|)
block|{
operator|*
name|seeked
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_spillbuf__read
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|svn_spillbuf_t
modifier|*
name|buf
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|memblock_t
modifier|*
name|mem
decl_stmt|;
comment|/* Possibly seek... */
name|SVN_ERR
argument_list|(
name|maybe_seek
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_data
argument_list|(
operator|&
name|mem
argument_list|,
name|buf
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
operator|*
name|data
operator|=
name|NULL
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|data
operator|=
name|mem
operator|->
name|data
expr_stmt|;
operator|*
name|len
operator|=
name|mem
operator|->
name|size
expr_stmt|;
comment|/* If a block was out for reading, then return it.  */
if|if
condition|(
name|buf
operator|->
name|out_for_reading
operator|!=
name|NULL
condition|)
name|return_buffer
argument_list|(
name|buf
argument_list|,
name|buf
operator|->
name|out_for_reading
argument_list|)
expr_stmt|;
comment|/* Remember that we've passed this block out for reading.  */
name|buf
operator|->
name|out_for_reading
operator|=
name|mem
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_spillbuf__process
parameter_list|(
name|svn_boolean_t
modifier|*
name|exhausted
parameter_list|,
name|svn_spillbuf_t
modifier|*
name|buf
parameter_list|,
name|svn_spillbuf_read_t
name|read_func
parameter_list|,
name|void
modifier|*
name|read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|has_seeked
init|=
name|FALSE
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
operator|*
name|exhausted
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|struct
name|memblock_t
modifier|*
name|mem
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|stop
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If this call to read_data() will read from the spill file, and we          have not seek'd the file... then do it now.  */
if|if
condition|(
operator|!
name|has_seeked
condition|)
name|SVN_ERR
argument_list|(
name|maybe_seek
argument_list|(
operator|&
name|has_seeked
argument_list|,
name|buf
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get some content to pass to the read callback.  */
name|SVN_ERR
argument_list|(
name|read_data
argument_list|(
operator|&
name|mem
argument_list|,
name|buf
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
operator|*
name|exhausted
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|read_func
argument_list|(
operator|&
name|stop
argument_list|,
name|read_baton
argument_list|,
name|mem
operator|->
name|data
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|return_buffer
argument_list|(
name|buf
argument_list|,
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* If the callbacks told us to stop, then we're done for now.  */
if|if
condition|(
name|stop
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_spillbuf_reader_t
modifier|*
name|svn_spillbuf__reader_create
parameter_list|(
name|apr_size_t
name|blocksize
parameter_list|,
name|apr_size_t
name|maxsize
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_spillbuf_reader_t
modifier|*
name|sbr
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sbr
argument_list|)
argument_list|)
decl_stmt|;
comment|/* See svn_spillbuf__create()  */
name|sbr
operator|->
name|buf
operator|.
name|pool
operator|=
name|result_pool
expr_stmt|;
name|sbr
operator|->
name|buf
operator|.
name|blocksize
operator|=
name|blocksize
expr_stmt|;
name|sbr
operator|->
name|buf
operator|.
name|maxsize
operator|=
name|maxsize
expr_stmt|;
return|return
name|sbr
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_spillbuf__reader_read
parameter_list|(
name|apr_size_t
modifier|*
name|amt
parameter_list|,
name|svn_spillbuf_reader_t
modifier|*
name|reader
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
operator|*
name|amt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|copy_amt
decl_stmt|;
if|if
condition|(
name|reader
operator|->
name|save_len
operator|>
literal|0
condition|)
block|{
comment|/* We have some saved content, so use this first.  */
if|if
condition|(
name|len
operator|<
name|reader
operator|->
name|save_len
condition|)
name|copy_amt
operator|=
name|len
expr_stmt|;
else|else
name|copy_amt
operator|=
name|reader
operator|->
name|save_len
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|reader
operator|->
name|save_ptr
operator|+
name|reader
operator|->
name|save_pos
argument_list|,
name|copy_amt
argument_list|)
expr_stmt|;
name|reader
operator|->
name|save_pos
operator|+=
name|copy_amt
expr_stmt|;
name|reader
operator|->
name|save_len
operator|-=
name|copy_amt
expr_stmt|;
block|}
else|else
block|{
comment|/* No saved content. We should now copy from spillbuf-provided              buffers of content.  */
comment|/* We may need more content from the spillbuf.  */
if|if
condition|(
name|reader
operator|->
name|sb_len
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_spillbuf__read
argument_list|(
operator|&
name|reader
operator|->
name|sb_ptr
argument_list|,
operator|&
name|reader
operator|->
name|sb_len
argument_list|,
operator|&
name|reader
operator|->
name|buf
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We've run out of content, so return with whatever has                  been copied into DATA and stored into AMT.  */
if|if
condition|(
name|reader
operator|->
name|sb_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* For safety, read() may not have set SB_LEN. We use it                      as an indicator, so it needs to be cleared.  */
name|reader
operator|->
name|sb_len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|reader
operator|->
name|sb_len
condition|)
name|copy_amt
operator|=
name|len
expr_stmt|;
else|else
name|copy_amt
operator|=
name|reader
operator|->
name|sb_len
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|reader
operator|->
name|sb_ptr
argument_list|,
name|copy_amt
argument_list|)
expr_stmt|;
name|reader
operator|->
name|sb_ptr
operator|+=
name|copy_amt
expr_stmt|;
name|reader
operator|->
name|sb_len
operator|-=
name|copy_amt
expr_stmt|;
block|}
name|data
operator|+=
name|copy_amt
expr_stmt|;
name|len
operator|-=
name|copy_amt
expr_stmt|;
operator|(
operator|*
name|amt
operator|)
operator|+=
name|copy_amt
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_spillbuf__reader_getc
parameter_list|(
name|char
modifier|*
name|c
parameter_list|,
name|svn_spillbuf_reader_t
modifier|*
name|reader
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_size_t
name|amt
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_read
argument_list|(
operator|&
name|amt
argument_list|,
name|reader
argument_list|,
name|c
argument_list|,
literal|1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_UNEXPECTED_EOF
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_spillbuf__reader_write
parameter_list|(
name|svn_spillbuf_reader_t
modifier|*
name|reader
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* If we have a buffer of content from the spillbuf, then we need to      move that content to a safe place.  */
if|if
condition|(
name|reader
operator|->
name|sb_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|reader
operator|->
name|save_ptr
operator|==
name|NULL
condition|)
name|reader
operator|->
name|save_ptr
operator|=
name|apr_palloc
argument_list|(
name|reader
operator|->
name|buf
operator|.
name|pool
argument_list|,
name|reader
operator|->
name|buf
operator|.
name|blocksize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|reader
operator|->
name|save_ptr
argument_list|,
name|reader
operator|->
name|sb_ptr
argument_list|,
name|reader
operator|->
name|sb_len
argument_list|)
expr_stmt|;
name|reader
operator|->
name|save_len
operator|=
name|reader
operator|->
name|sb_len
expr_stmt|;
name|reader
operator|->
name|save_pos
operator|=
literal|0
expr_stmt|;
comment|/* No more content in the spillbuf-borrowed buffer.  */
name|reader
operator|->
name|sb_len
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|svn_spillbuf__write
argument_list|(
operator|&
name|reader
operator|->
name|buf
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|spillbuf_baton
block|{
name|svn_spillbuf_reader_t
modifier|*
name|reader
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_spillbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|spillbuf_baton
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_read
argument_list|(
name|len
argument_list|,
name|sb
operator|->
name|reader
argument_list|,
name|buffer
argument_list|,
operator|*
name|len
argument_list|,
name|sb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|sb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler_spillbuf
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|spillbuf_baton
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_write
argument_list|(
name|sb
operator|->
name|reader
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|,
name|sb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|sb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_stream__from_spillbuf
parameter_list|(
name|apr_size_t
name|blocksize
parameter_list|,
name|apr_size_t
name|maxsize
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|struct
name|spillbuf_baton
modifier|*
name|sb
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
argument_list|)
decl_stmt|;
name|sb
operator|->
name|reader
operator|=
name|svn_spillbuf__reader_create
argument_list|(
name|blocksize
argument_list|,
name|maxsize
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|sb
operator|->
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|sb
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|stream
argument_list|,
name|read_handler_spillbuf
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler_spillbuf
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

end_unit

