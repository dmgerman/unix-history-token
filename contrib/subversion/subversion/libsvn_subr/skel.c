begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* skel.c --- parsing and unparsing skeletons  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Parsing skeletons.  */
end_comment

begin_enum
enum|enum
name|char_type
block|{
name|type_nothing
init|=
literal|0
block|,
name|type_space
init|=
literal|1
block|,
name|type_digit
init|=
literal|2
block|,
name|type_paren
init|=
literal|3
block|,
name|type_name
init|=
literal|4
block|}
enum|;
end_enum

begin_comment
comment|/* We can't use the<ctype.h> macros here, because they are locale-    dependent.  The syntax of a skel is specified directly in terms of    byte values, and is independent of locale.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|char_type
name|skel_char_type
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 64 */
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 128 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 192 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* ### WTF? since when is number conversion LOCALE DEPENDENT? */
end_comment

begin_comment
comment|/* stsp: In C99, various numerical string properties such as decimal point,  * thousands separator, and the plus/minus sign are locale dependent. */
end_comment

begin_comment
comment|/* Converting text to numbers.  */
end_comment

begin_comment
comment|/* Return the value of the string of digits at DATA as an ASCII    decimal number.  The string is at most LEN bytes long.  The value    of the number is at most MAX.  Set *END to the address of the first    byte after the number, or zero if an error occurred while    converting the number (overflow, for example).     We would like to use strtoul, but that family of functions is    locale-dependent, whereas we're trying to parse data in a    locale-independent format.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|getsize
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endptr
parameter_list|,
name|apr_size_t
name|max
parameter_list|)
block|{
comment|/* We can't detect overflow by simply comparing value against max,      since multiplying value by ten can overflow in strange ways if      max is close to the limits of apr_size_t.  For example, suppose      that max is 54, and apr_size_t is six bits long; its range is      0..63.  If we're parsing the number "502", then value will be 50      after parsing the first two digits.  50 * 10 = 500.  But 500      doesn't fit in an apr_size_t, so it'll be truncated to 500 mod 64      = 52, which is less than max, so we'd fail to recognize the      overflow.  Furthermore, it *is* greater than 50, so you can't      detect overflow by checking whether value actually increased      after each multiplication --- sometimes it does increase, but      it's still wrong.       So we do the check for overflow before we multiply value and add      in the new digit.  */
name|apr_size_t
name|max_prefix
init|=
name|max
operator|/
literal|10
decl_stmt|;
name|apr_size_t
name|max_digit
init|=
name|max
operator|%
literal|10
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|apr_size_t
name|value
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|&&
literal|'0'
operator|<=
name|data
index|[
name|i
index|]
operator|&&
name|data
index|[
name|i
index|]
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
block|{
name|apr_size_t
name|digit
init|=
name|data
index|[
name|i
index|]
operator|-
literal|'0'
decl_stmt|;
comment|/* Check for overflow.  */
if|if
condition|(
name|value
operator|>
name|max_prefix
operator|||
operator|(
name|value
operator|==
name|max_prefix
operator|&&
name|digit
operator|>
name|max_digit
operator|)
condition|)
block|{
operator|*
name|endptr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|value
operator|=
operator|(
name|value
operator|*
literal|10
operator|)
operator|+
name|digit
expr_stmt|;
block|}
comment|/* There must be at least one digit there.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|*
name|endptr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
operator|*
name|endptr
operator|=
name|data
operator|+
name|i
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Checking validity of skels. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skel_err
parameter_list|(
specifier|const
name|char
modifier|*
name|skel_type
parameter_list|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_MALFORMED_SKEL
argument_list|,
name|NULL
argument_list|,
literal|"Malformed%s%s skeleton"
argument_list|,
name|skel_type
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|skel_type
condition|?
name|skel_type
else|:
literal|""
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_proplist_skel
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
name|int
name|len
init|=
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|len
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|svn_skel_t
modifier|*
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|skel
operator|->
name|children
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|elt
operator|->
name|is_atom
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_iproplist_skel
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
name|int
name|len
init|=
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|len
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|svn_skel_t
modifier|*
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|skel
operator|->
name|children
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|elt
operator|->
name|is_atom
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|elt
operator|->
name|next
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|is_valid_proplist_skel
argument_list|(
name|elt
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|svn_skel_t
modifier|*
name|parse
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_skel_t
modifier|*
name|list
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_skel_t
modifier|*
name|implicit_atom
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_skel_t
modifier|*
name|explicit_atom
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|svn_skel_t
modifier|*
name|svn_skel__parse
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|parse
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse any kind of skel object --- atom, or list.  */
end_comment

begin_function
specifier|static
name|svn_skel_t
modifier|*
name|parse
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
comment|/* The empty string isn't a valid skel.  */
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|c
operator|=
operator|*
name|data
expr_stmt|;
comment|/* Is it a list, or an atom?  */
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
return|return
name|list
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
return|;
comment|/* Is it a string with an implicit length?  */
if|if
condition|(
name|skel_char_type
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
operator|==
name|type_name
condition|)
return|return
name|implicit_atom
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
return|;
comment|/* Otherwise, we assume it's a string with an explicit length;      svn_skel__getsize will catch the error.  */
else|else
return|return
name|explicit_atom
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_skel_t
modifier|*
name|list
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|list_start
decl_stmt|;
comment|/* Verify that the list starts with an opening paren.  At the      moment, all callers have checked this already, but it's more      robust this way.  */
if|if
condition|(
name|data
operator|>=
name|end
operator|||
operator|*
name|data
operator|!=
literal|'('
condition|)
return|return
name|NULL
return|;
comment|/* Mark where the list starts.  */
name|list_start
operator|=
name|data
expr_stmt|;
comment|/* Skip the opening paren.  */
name|data
operator|++
expr_stmt|;
comment|/* Parse the children.  */
block|{
name|svn_skel_t
modifier|*
name|children
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
modifier|*
name|tail
init|=
operator|&
name|children
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|svn_skel_t
modifier|*
name|element
decl_stmt|;
comment|/* Skip any whitespace.  */
while|while
condition|(
name|data
operator|<
name|end
operator|&&
name|skel_char_type
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|data
index|]
operator|==
name|type_space
condition|)
name|data
operator|++
expr_stmt|;
comment|/* End of data, but no closing paren?  */
if|if
condition|(
name|data
operator|>=
name|end
condition|)
return|return
name|NULL
return|;
comment|/* End of list?  */
if|if
condition|(
operator|*
name|data
operator|==
literal|')'
condition|)
block|{
name|data
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Parse the next element in the list.  */
name|element
operator|=
name|parse
argument_list|(
name|data
argument_list|,
name|end
operator|-
name|data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|element
condition|)
return|return
name|NULL
return|;
comment|/* Link that element into our list.  */
name|element
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|tail
operator|=
name|element
expr_stmt|;
name|tail
operator|=
operator|&
name|element
operator|->
name|next
expr_stmt|;
comment|/* Advance past that element.  */
name|data
operator|=
name|element
operator|->
name|data
operator|+
name|element
operator|->
name|len
expr_stmt|;
block|}
comment|/* Construct the return value.  */
block|{
name|svn_skel_t
modifier|*
name|s
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|->
name|is_atom
operator|=
name|FALSE
expr_stmt|;
name|s
operator|->
name|data
operator|=
name|list_start
expr_stmt|;
name|s
operator|->
name|len
operator|=
name|data
operator|-
name|list_start
expr_stmt|;
name|s
operator|->
name|children
operator|=
name|children
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse an atom with implicit length --- one that starts with a name    character, terminated by whitespace, '(', ')', or end-of-data.  */
end_comment

begin_function
specifier|static
name|svn_skel_t
modifier|*
name|implicit_atom
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
name|svn_skel_t
modifier|*
name|s
decl_stmt|;
comment|/* Verify that the atom starts with a name character.  At the      moment, all callers have checked this already, but it's more      robust this way.  */
if|if
condition|(
name|data
operator|>=
name|end
operator|||
name|skel_char_type
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|data
index|]
operator|!=
name|type_name
condition|)
return|return
name|NULL
return|;
comment|/* Find the end of the string.  */
while|while
condition|(
operator|++
name|data
operator|<
name|end
operator|&&
name|skel_char_type
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|data
index|]
operator|!=
name|type_space
operator|&&
name|skel_char_type
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|data
index|]
operator|!=
name|type_paren
condition|)
empty_stmt|;
comment|/* Allocate the skel representing this string.  */
name|s
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|is_atom
operator|=
name|TRUE
expr_stmt|;
name|s
operator|->
name|data
operator|=
name|start
expr_stmt|;
name|s
operator|->
name|len
operator|=
name|data
operator|-
name|start
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Parse an atom with explicit length --- one that starts with a byte    length, as a decimal ASCII number.  */
end_comment

begin_function
specifier|static
name|svn_skel_t
modifier|*
name|explicit_atom
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
name|svn_skel_t
modifier|*
name|s
decl_stmt|;
comment|/* Parse the length.  */
name|size
operator|=
name|getsize
argument_list|(
name|data
argument_list|,
name|end
operator|-
name|data
argument_list|,
operator|&
name|next
argument_list|,
name|end
operator|-
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|next
expr_stmt|;
comment|/* Exit if we overflowed, or there wasn't a valid number there.  */
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|NULL
return|;
comment|/* Skip the whitespace character after the length.  */
if|if
condition|(
name|data
operator|>=
name|end
operator|||
name|skel_char_type
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|data
index|]
operator|!=
name|type_space
condition|)
return|return
name|NULL
return|;
name|data
operator|++
expr_stmt|;
comment|/* Check the length.  */
if|if
condition|(
name|data
operator|+
name|size
operator|>
name|end
condition|)
return|return
name|NULL
return|;
comment|/* Allocate the skel representing this string.  */
name|s
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|is_atom
operator|=
name|TRUE
expr_stmt|;
name|s
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|s
operator|->
name|len
operator|=
name|size
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unparsing skeletons.  */
end_comment

begin_function_decl
specifier|static
name|apr_size_t
name|estimate_unparsed_size
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_stringbuf_t
modifier|*
name|unparse
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_skel__unparse
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|str
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|estimate_unparsed_size
argument_list|(
name|skel
argument_list|)
operator|+
literal|200
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|unparse
argument_list|(
name|skel
argument_list|,
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an estimate of the number of bytes that the external    representation of SKEL will occupy.  Since reallocing is expensive    in pools, it's worth trying to get the buffer size right the first    time.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|estimate_unparsed_size
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
if|if
condition|(
name|skel
operator|->
name|is_atom
condition|)
block|{
if|if
condition|(
name|skel
operator|->
name|len
operator|<
literal|100
condition|)
comment|/* If we have to use the explicit-length form, that'll be            two bytes for the length, one byte for the space, and            the contents.  */
return|return
name|skel
operator|->
name|len
operator|+
literal|3
return|;
else|else
return|return
name|skel
operator|->
name|len
operator|+
literal|30
return|;
block|}
else|else
block|{
name|apr_size_t
name|total_len
decl_stmt|;
name|svn_skel_t
modifier|*
name|child
decl_stmt|;
comment|/* Allow space for opening and closing parens, and a space          between each pair of elements.  */
name|total_len
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|child
operator|=
name|skel
operator|->
name|children
init|;
name|child
condition|;
name|child
operator|=
name|child
operator|->
name|next
control|)
name|total_len
operator|+=
name|estimate_unparsed_size
argument_list|(
name|child
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|total_len
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero iff we should use the implicit-length form for SKEL.    Assume that SKEL is an atom.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|use_implicit
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
comment|/* If it's null, or long, we should use explicit-length form.  */
if|if
condition|(
name|skel
operator|->
name|len
operator|==
literal|0
operator|||
name|skel
operator|->
name|len
operator|>=
literal|100
condition|)
return|return
name|FALSE
return|;
comment|/* If it doesn't start with a name character, we must use      explicit-length form.  */
if|if
condition|(
name|skel_char_type
index|[
operator|(
name|unsigned
name|char
operator|)
name|skel
operator|->
name|data
index|[
literal|0
index|]
index|]
operator|!=
name|type_name
condition|)
return|return
name|FALSE
return|;
comment|/* If it contains any whitespace or parens, then we must use      explicit-length form.  */
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|skel
operator|->
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|skel_char_type
index|[
operator|(
name|unsigned
name|char
operator|)
name|skel
operator|->
name|data
index|[
name|i
index|]
index|]
operator|==
name|type_space
operator|||
name|skel_char_type
index|[
operator|(
name|unsigned
name|char
operator|)
name|skel
operator|->
name|data
index|[
name|i
index|]
index|]
operator|==
name|type_paren
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If we can't reject it for any of the above reasons, then we can      use implicit-length form.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Append the concrete representation of SKEL to the string STR. */
end_comment

begin_function
specifier|static
name|svn_stringbuf_t
modifier|*
name|unparse
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|skel
operator|->
name|is_atom
condition|)
block|{
comment|/* Append an atom to STR.  */
if|if
condition|(
name|use_implicit
argument_list|(
name|skel
argument_list|)
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|skel
operator|->
name|data
argument_list|,
name|skel
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Append the length to STR.  Ensure enough space for at least            * one 64 bit int. */
name|char
name|buf
index|[
literal|200
operator|+
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|length_len
decl_stmt|;
name|length_len
operator|=
name|svn__ui64toa
argument_list|(
name|buf
argument_list|,
name|skel
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|length_len
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure we have room for the length, the space, and the              atom's contents.  */
name|svn_stringbuf_ensure
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|len
operator|+
name|length_len
operator|+
literal|1
operator|+
name|skel
operator|->
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
name|length_len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|skel
operator|->
name|data
argument_list|,
name|skel
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Append a list to STR: an opening parenthesis, the list elements        * separated by a space, and a closing parenthesis.  */
name|svn_skel_t
modifier|*
name|child
decl_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|child
operator|=
name|skel
operator|->
name|children
init|;
name|child
condition|;
name|child
operator|=
name|child
operator|->
name|next
control|)
block|{
name|unparse
argument_list|(
name|child
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|next
condition|)
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Building skels.  */
end_comment

begin_function
name|svn_skel_t
modifier|*
name|svn_skel__str_atom
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|skel
argument_list|)
argument_list|)
decl_stmt|;
name|skel
operator|->
name|is_atom
operator|=
name|TRUE
expr_stmt|;
name|skel
operator|->
name|data
operator|=
name|str
expr_stmt|;
name|skel
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|skel
return|;
block|}
end_function

begin_function
name|svn_skel_t
modifier|*
name|svn_skel__mem_atom
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|skel
argument_list|)
argument_list|)
decl_stmt|;
name|skel
operator|->
name|is_atom
operator|=
name|TRUE
expr_stmt|;
name|skel
operator|->
name|data
operator|=
name|addr
expr_stmt|;
name|skel
operator|->
name|len
operator|=
name|len
expr_stmt|;
return|return
name|skel
return|;
block|}
end_function

begin_function
name|svn_skel_t
modifier|*
name|svn_skel__make_empty_list
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|skel
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|skel
return|;
block|}
end_function

begin_function
name|svn_skel_t
modifier|*
name|svn_skel__dup
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|src_skel
parameter_list|,
name|svn_boolean_t
name|dup_data
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
init|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|src_skel
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_skel_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dup_data
operator|&&
name|skel
operator|->
name|data
condition|)
block|{
if|if
condition|(
name|skel
operator|->
name|is_atom
condition|)
name|skel
operator|->
name|data
operator|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|skel
operator|->
name|data
argument_list|,
name|skel
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* When creating a skel this would be NULL, 0 for a list.              When parsing a string to a skel this might point to real data              delimiting the sublist. We don't copy that from here. */
name|skel
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|skel
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skel
operator|->
name|children
condition|)
name|skel
operator|->
name|children
operator|=
name|svn_skel__dup
argument_list|(
name|skel
operator|->
name|children
argument_list|,
name|dup_data
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|skel
operator|->
name|next
condition|)
name|skel
operator|->
name|next
operator|=
name|svn_skel__dup
argument_list|(
name|skel
operator|->
name|next
argument_list|,
name|dup_data
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|skel
return|;
block|}
end_function

begin_function
name|void
name|svn_skel__prepend
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|svn_skel_t
modifier|*
name|list_skel
parameter_list|)
block|{
comment|/* If list_skel isn't even a list, somebody's not using this      function properly. */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
operator|!
name|list_skel
operator|->
name|is_atom
argument_list|)
expr_stmt|;
name|skel
operator|->
name|next
operator|=
name|list_skel
operator|->
name|children
expr_stmt|;
name|list_skel
operator|->
name|children
operator|=
name|skel
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_skel__prepend_int
parameter_list|(
name|apr_int64_t
name|value
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|char
modifier|*
name|val_string
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|SVN_INT64_BUFFER_SIZE
argument_list|)
decl_stmt|;
name|svn__i64toa
argument_list|(
name|val_string
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|val_string
argument_list|,
name|skel
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_skel__prepend_str
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|atom
init|=
name|svn_skel__str_atom
argument_list|(
name|value
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|svn_skel__prepend
argument_list|(
name|atom
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_skel__append
parameter_list|(
name|svn_skel_t
modifier|*
name|list_skel
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|list_skel
operator|!=
name|NULL
operator|&&
operator|!
name|list_skel
operator|->
name|is_atom
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_skel
operator|->
name|children
operator|==
name|NULL
condition|)
block|{
name|list_skel
operator|->
name|children
operator|=
name|skel
expr_stmt|;
block|}
else|else
block|{
name|list_skel
operator|=
name|list_skel
operator|->
name|children
expr_stmt|;
while|while
condition|(
name|list_skel
operator|->
name|next
operator|!=
name|NULL
condition|)
name|list_skel
operator|=
name|list_skel
operator|->
name|next
expr_stmt|;
name|list_skel
operator|->
name|next
operator|=
name|skel
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Examining skels.  */
end_comment

begin_function
name|svn_boolean_t
name|svn_skel__matches_atom
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|skel
operator|&&
name|skel
operator|->
name|is_atom
condition|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
return|return
operator|(
name|skel
operator|->
name|len
operator|==
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|skel
operator|->
name|data
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|svn_skel__list_length
parameter_list|(
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|child
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|skel
operator|)
operator|||
name|skel
operator|->
name|is_atom
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|child
operator|=
name|skel
operator|->
name|children
init|;
name|child
condition|;
name|child
operator|=
name|child
operator|->
name|next
control|)
name|len
operator|++
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parsing and unparsing into high-level types. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_skel__parse_int
parameter_list|(
name|apr_int64_t
modifier|*
name|n
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
comment|/* We need to duplicate the SKEL contents in order to get a NUL-terminated      version of it. The SKEL may not have valid memory at DATA[LEN].  */
name|str
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|skel
operator|->
name|data
argument_list|,
name|skel
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_cstring_atoi64
argument_list|(
name|n
argument_list|,
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_skel__parse_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* result_pool */
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|proplist
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|elt
decl_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_proplist_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"proplist"
argument_list|)
return|;
comment|/* Create the returned structure */
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
name|skel
operator|->
name|children
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next
operator|->
name|next
control|)
block|{
name|svn_string_t
modifier|*
name|value
init|=
name|svn_string_ncreate
argument_list|(
name|elt
operator|->
name|next
operator|->
name|data
argument_list|,
name|elt
operator|->
name|next
operator|->
name|len
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_set
argument_list|(
name|proplist
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|elt
operator|->
name|data
argument_list|,
name|elt
operator|->
name|len
argument_list|)
argument_list|,
name|elt
operator|->
name|len
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Return the structure. */
operator|*
name|proplist_p
operator|=
name|proplist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_skel__parse_iprops
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|iprops
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|elt
decl_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_iproplist_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"iprops"
argument_list|)
return|;
comment|/* Create the returned structure */
operator|*
name|iprops
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_inherited_item_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
name|skel
operator|->
name|children
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next
operator|->
name|next
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|new_iprop
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_iprop
argument_list|)
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|repos_parent
init|=
name|svn_string_ncreate
argument_list|(
name|elt
operator|->
name|data
argument_list|,
name|elt
operator|->
name|len
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
operator|&
operator|(
name|new_iprop
operator|->
name|prop_hash
operator|)
argument_list|,
name|elt
operator|->
name|next
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_iprop
operator|->
name|path_or_url
operator|=
name|repos_parent
operator|->
name|data
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|iprops
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
operator|=
name|new_iprop
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_skel__parse_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|propval
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
comment|/* result_pool */
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|elt
decl_stmt|;
operator|*
name|propval
operator|=
name|NULL
expr_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_proplist_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"proplist"
argument_list|)
return|;
comment|/* Look for PROPNAME in SKEL. */
for|for
control|(
name|elt
operator|=
name|skel
operator|->
name|children
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next
operator|->
name|next
control|)
block|{
if|if
condition|(
name|elt
operator|->
name|len
operator|==
name|strlen
argument_list|(
name|propname
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|propname
argument_list|,
name|elt
operator|->
name|data
argument_list|,
name|elt
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|propval
operator|=
name|svn_string_ncreate
argument_list|(
name|elt
operator|->
name|next
operator|->
name|data
argument_list|,
name|elt
operator|->
name|next
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
continue|continue;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_skel__unparse_proplist
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Create the skel. */
if|if
condition|(
name|proplist
condition|)
block|{
comment|/* Loop over hash entries */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
operator|(
name|apr_hash_t
operator|*
operator|)
name|proplist
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|value
operator|=
name|val
expr_stmt|;
comment|/* VALUE */
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|value
operator|->
name|data
argument_list|,
name|value
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* NAME */
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Validate and return the skel. */
if|if
condition|(
operator|!
name|is_valid_proplist_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"proplist"
argument_list|)
return|;
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_skel__unparse_iproplist
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|inherited_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
comment|/* Create the skel. */
if|if
condition|(
name|inherited_props
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inherited_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|iprop
init|=
name|APR_ARRAY_IDX
argument_list|(
name|inherited_props
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|skel_list
init|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|skel_atom
decl_stmt|;
comment|/* Loop over hash entries */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|iprop
operator|->
name|prop_hash
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|value
operator|=
name|val
expr_stmt|;
comment|/* VALUE */
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|value
operator|->
name|data
argument_list|,
name|value
operator|->
name|len
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|skel_list
argument_list|)
expr_stmt|;
comment|/* NAME */
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|skel_list
argument_list|)
expr_stmt|;
block|}
name|skel_atom
operator|=
name|svn_skel__str_atom
argument_list|(
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|iprop
operator|->
name|path_or_url
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__append
argument_list|(
name|skel
argument_list|,
name|skel_atom
argument_list|)
expr_stmt|;
name|svn_skel__append
argument_list|(
name|skel
argument_list|,
name|skel_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Validate and return the skel. */
if|if
condition|(
operator|!
name|is_valid_iproplist_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"iproplist"
argument_list|)
return|;
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

