begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * config.c :  reading configuration information  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_define
define|#
directive|define
name|APR_WANT_MEMFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"config_impl.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Section table entries. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cfg_section_t
name|cfg_section_t
typedef|;
end_typedef

begin_struct
struct|struct
name|cfg_section_t
block|{
comment|/* The section name. */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Table of cfg_option_t's. */
name|apr_hash_t
modifier|*
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Option table entries. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cfg_option_t
name|cfg_option_t
typedef|;
end_typedef

begin_struct
struct|struct
name|cfg_option_t
block|{
comment|/* The option name. */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The option name, converted into a hash key. */
specifier|const
name|char
modifier|*
name|hash_key
decl_stmt|;
comment|/* The unexpanded option value. */
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
comment|/* The expanded option value. */
specifier|const
name|char
modifier|*
name|x_value
decl_stmt|;
comment|/* Expansion flag. If this is TRUE, this value has already been expanded.      In this case, if x_value is NULL, no expansions were necessary,      and value should be used directly. */
name|svn_boolean_t
name|expanded
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_function
name|svn_error_t
modifier|*
name|svn_config_create2
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfgp
parameter_list|,
name|svn_boolean_t
name|section_names_case_sensitive
parameter_list|,
name|svn_boolean_t
name|option_names_case_sensitive
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|cfg
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cfg
argument_list|)
argument_list|)
decl_stmt|;
name|cfg
operator|->
name|sections
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|cfg
operator|->
name|x_pool
operator|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|x_values
operator|=
name|FALSE
expr_stmt|;
name|cfg
operator|->
name|tmp_key
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|tmp_value
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|section_names_case_sensitive
operator|=
name|section_names_case_sensitive
expr_stmt|;
name|cfg
operator|->
name|option_names_case_sensitive
operator|=
name|option_names_case_sensitive
expr_stmt|;
operator|*
name|cfgp
operator|=
name|cfg
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_read3
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfgp
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|,
name|svn_boolean_t
name|section_names_case_sensitive
parameter_list|,
name|svn_boolean_t
name|option_names_case_sensitive
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_create2
argument_list|(
operator|&
name|cfg
argument_list|,
name|section_names_case_sensitive
argument_list|,
name|option_names_case_sensitive
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Yes, this is platform-specific code in Subversion, but there's no      practical way to migrate it into APR, as it's simultaneously      Subversion-specific and Windows-specific.  Even if we eventually      want to have APR offer a generic config-reading interface, it      makes sense to test it here first and migrate it later. */
ifdef|#
directive|ifdef
name|WIN32
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|file
argument_list|,
name|SVN_REGISTRY_PREFIX
argument_list|,
name|SVN_REGISTRY_PREFIX_LEN
argument_list|)
condition|)
name|err
operator|=
name|svn_config__parse_registry
argument_list|(
name|cfg
argument_list|,
name|file
operator|+
name|SVN_REGISTRY_PREFIX_LEN
argument_list|,
name|must_exist
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* WIN32 */
name|err
operator|=
name|svn_config__parse_file
argument_list|(
name|cfg
argument_list|,
name|file
argument_list|,
name|must_exist
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|SVN_NO_ERROR
condition|)
return|return
name|err
return|;
else|else
operator|*
name|cfgp
operator|=
name|cfg
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_parse
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfgp
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_boolean_t
name|section_names_case_sensitive
parameter_list|,
name|svn_boolean_t
name|option_names_case_sensitive
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|err
operator|=
name|svn_config_create2
argument_list|(
operator|&
name|cfg
argument_list|,
name|section_names_case_sensitive
argument_list|,
name|option_names_case_sensitive
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
name|err
operator|=
name|svn_config__parse_stream
argument_list|(
name|cfg
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
operator|*
name|cfgp
operator|=
name|cfg
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Read various configuration sources into *CFGP, in this order, with  * later reads overriding the results of earlier ones:  *  *    1. SYS_REGISTRY_PATH   (only on Win32, but ignored if NULL)  *  *    2. SYS_FILE_PATH       (everywhere, but ignored if NULL)  *  *    3. USR_REGISTRY_PATH   (only on Win32, but ignored if NULL)  *  *    4. USR_FILE_PATH       (everywhere, but ignored if NULL)  *  * Allocate *CFGP in POOL.  Even if no configurations are read,  * allocate an empty *CFGP.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_all
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfgp
parameter_list|,
specifier|const
name|char
modifier|*
name|sys_registry_path
parameter_list|,
specifier|const
name|char
modifier|*
name|usr_registry_path
parameter_list|,
specifier|const
name|char
modifier|*
name|sys_file_path
parameter_list|,
specifier|const
name|char
modifier|*
name|usr_file_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|red_config
init|=
name|FALSE
decl_stmt|;
comment|/* "red" is the past tense of "read" */
comment|/*** Read system-wide configurations first... ***/
ifdef|#
directive|ifdef
name|WIN32
if|if
condition|(
name|sys_registry_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_read2
argument_list|(
name|cfgp
argument_list|,
name|sys_registry_path
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|red_config
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WIN32 */
if|if
condition|(
name|sys_file_path
condition|)
block|{
if|if
condition|(
name|red_config
condition|)
name|SVN_ERR
argument_list|(
name|svn_config_merge
argument_list|(
operator|*
name|cfgp
argument_list|,
name|sys_file_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
name|cfgp
argument_list|,
name|sys_file_path
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|red_config
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/*** ...followed by per-user configurations. ***/
ifdef|#
directive|ifdef
name|WIN32
if|if
condition|(
name|usr_registry_path
condition|)
block|{
if|if
condition|(
name|red_config
condition|)
name|SVN_ERR
argument_list|(
name|svn_config_merge
argument_list|(
operator|*
name|cfgp
argument_list|,
name|usr_registry_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_config_read2
argument_list|(
name|cfgp
argument_list|,
name|usr_registry_path
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|red_config
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* WIN32 */
if|if
condition|(
name|usr_file_path
condition|)
block|{
if|if
condition|(
name|red_config
condition|)
name|SVN_ERR
argument_list|(
name|svn_config_merge
argument_list|(
operator|*
name|cfgp
argument_list|,
name|usr_file_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
name|cfgp
argument_list|,
name|usr_file_path
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|red_config
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|red_config
condition|)
name|SVN_ERR
argument_list|(
name|svn_config_create2
argument_list|(
name|cfgp
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* CONFIG_DIR provides an override for the default behavior of reading    the default set of overlay files described by read_all()'s doc    string. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_category_config
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|config_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|category
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|usr_reg_path
init|=
name|NULL
decl_stmt|,
modifier|*
name|sys_reg_path
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|usr_cfg_path
decl_stmt|,
modifier|*
name|sys_cfg_path
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
operator|*
name|cfg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|config_dir
condition|)
block|{
ifdef|#
directive|ifdef
name|WIN32
name|sys_reg_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|SVN_REGISTRY_SYS_CONFIG_PATH
argument_list|,
name|category
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|usr_reg_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|SVN_REGISTRY_USR_CONFIG_PATH
argument_list|,
name|category
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WIN32 */
name|err
operator|=
name|svn_config__sys_config_path
argument_list|(
operator|&
name|sys_cfg_path
argument_list|,
name|category
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|)
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_BAD_FILENAME
operator|)
condition|)
block|{
name|sys_cfg_path
operator|=
name|NULL
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
else|else
name|sys_cfg_path
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_user_config_path
argument_list|(
operator|&
name|usr_cfg_path
argument_list|,
name|config_dir
argument_list|,
name|category
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|read_all
argument_list|(
name|cfg
argument_list|,
name|sys_reg_path
argument_list|,
name|usr_reg_path
argument_list|,
name|sys_cfg_path
argument_list|,
name|usr_cfg_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_get_config
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|cfg_hash
parameter_list|,
specifier|const
name|char
modifier|*
name|config_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
operator|*
name|cfg_hash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
define|#
directive|define
name|CATLEN
value|(sizeof(SVN_CONFIG_CATEGORY_SERVERS) - 1)
name|SVN_ERR
argument_list|(
name|get_category_config
argument_list|(
operator|&
name|cfg
argument_list|,
name|config_dir
argument_list|,
name|SVN_CONFIG_CATEGORY_SERVERS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
name|apr_hash_set
argument_list|(
operator|*
name|cfg_hash
argument_list|,
name|SVN_CONFIG_CATEGORY_SERVERS
argument_list|,
name|CATLEN
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CATLEN
define|#
directive|define
name|CATLEN
value|(sizeof(SVN_CONFIG_CATEGORY_CONFIG) - 1)
name|SVN_ERR
argument_list|(
name|get_category_config
argument_list|(
operator|&
name|cfg
argument_list|,
name|config_dir
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
name|apr_hash_set
argument_list|(
operator|*
name|cfg_hash
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|,
name|CATLEN
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CATLEN
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Iterate through CFG, passing BATON to CALLBACK for every (SECTION, OPTION)    pair.  Stop if CALLBACK returns TRUE.  Allocate from POOL. */
end_comment

begin_function
specifier|static
name|void
name|for_each_option
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_boolean_t
name|callback
parameter_list|(
name|void
modifier|*
name|same_baton
parameter_list|,
name|cfg_section_t
modifier|*
name|section
parameter_list|,
name|cfg_option_t
modifier|*
name|option
parameter_list|)
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|sec_ndx
decl_stmt|;
for|for
control|(
name|sec_ndx
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|cfg
operator|->
name|sections
argument_list|)
init|;
name|sec_ndx
operator|!=
name|NULL
condition|;
name|sec_ndx
operator|=
name|apr_hash_next
argument_list|(
name|sec_ndx
argument_list|)
control|)
block|{
name|void
modifier|*
name|sec_ptr
decl_stmt|;
name|cfg_section_t
modifier|*
name|sec
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|opt_ndx
decl_stmt|;
name|apr_hash_this
argument_list|(
name|sec_ndx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sec_ptr
argument_list|)
expr_stmt|;
name|sec
operator|=
name|sec_ptr
expr_stmt|;
for|for
control|(
name|opt_ndx
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|sec
operator|->
name|options
argument_list|)
init|;
name|opt_ndx
operator|!=
name|NULL
condition|;
name|opt_ndx
operator|=
name|apr_hash_next
argument_list|(
name|opt_ndx
argument_list|)
control|)
block|{
name|void
modifier|*
name|opt_ptr
decl_stmt|;
name|cfg_option_t
modifier|*
name|opt
decl_stmt|;
name|apr_hash_this
argument_list|(
name|opt_ndx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|opt_ptr
argument_list|)
expr_stmt|;
name|opt
operator|=
name|opt_ptr
expr_stmt|;
if|if
condition|(
name|callback
argument_list|(
name|baton
argument_list|,
name|sec
argument_list|,
name|opt
argument_list|)
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|svn_boolean_t
name|merge_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|cfg_section_t
modifier|*
name|section
parameter_list|,
name|cfg_option_t
modifier|*
name|option
parameter_list|)
block|{
name|svn_config_set
argument_list|(
name|baton
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|option
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_merge
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|)
block|{
comment|/* The original config hash shouldn't change if there's an error      while reading the confguration, so read into a temporary table.      ### We could use a tmp subpool for this, since merge_cfg is going      to be tossed afterwards.  Premature optimization, though? */
name|svn_config_t
modifier|*
name|merge_cfg
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
operator|&
name|merge_cfg
argument_list|,
name|file
argument_list|,
name|must_exist
argument_list|,
name|cfg
operator|->
name|section_names_case_sensitive
argument_list|,
name|cfg
operator|->
name|option_names_case_sensitive
argument_list|,
name|cfg
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy the new options into the original table. */
name|for_each_option
argument_list|(
name|merge_cfg
argument_list|,
name|cfg
argument_list|,
name|merge_cfg
operator|->
name|pool
argument_list|,
name|merge_callback
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove variable expansions from CFG.  Walk through the options tree,    killing all expanded values, then clear the expanded value pool. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|rmex_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|cfg_section_t
modifier|*
name|section
parameter_list|,
name|cfg_option_t
modifier|*
name|option
parameter_list|)
block|{
comment|/* Only clear the `expanded' flag if the value actually contains      variable expansions. */
if|if
condition|(
name|option
operator|->
name|expanded
operator|&&
name|option
operator|->
name|x_value
operator|!=
name|NULL
condition|)
block|{
name|option
operator|->
name|x_value
operator|=
name|NULL
expr_stmt|;
name|option
operator|->
name|expanded
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_expansions
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg
operator|->
name|x_values
condition|)
return|return;
name|for_each_option
argument_list|(
name|cfg
argument_list|,
name|NULL
argument_list|,
name|cfg
operator|->
name|x_pool
argument_list|,
name|rmex_callback
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|cfg
operator|->
name|x_pool
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|x_values
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Canonicalize a string for hashing.  Modifies KEY in place. */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|char
modifier|*
name|make_hash_key
parameter_list|(
name|char
modifier|*
name|key
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|key
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
operator|++
name|p
control|)
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|apr_tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to an option in CFG, or NULL if it doesn't exist.    if SECTIONP is non-null, return a pointer to the option's section.    OPTION may be NULL. */
end_comment

begin_function
specifier|static
name|cfg_option_t
modifier|*
name|find_option
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|cfg_section_t
modifier|*
modifier|*
name|sectionp
parameter_list|)
block|{
name|void
modifier|*
name|sec_ptr
decl_stmt|;
comment|/* Canonicalize the hash key */
name|svn_stringbuf_set
argument_list|(
name|cfg
operator|->
name|tmp_key
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|section_names_case_sensitive
condition|)
name|make_hash_key
argument_list|(
name|cfg
operator|->
name|tmp_key
operator|->
name|data
argument_list|)
expr_stmt|;
name|sec_ptr
operator|=
name|apr_hash_get
argument_list|(
name|cfg
operator|->
name|sections
argument_list|,
name|cfg
operator|->
name|tmp_key
operator|->
name|data
argument_list|,
name|cfg
operator|->
name|tmp_key
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sectionp
operator|!=
name|NULL
condition|)
operator|*
name|sectionp
operator|=
name|sec_ptr
expr_stmt|;
if|if
condition|(
name|sec_ptr
operator|!=
name|NULL
operator|&&
name|option
operator|!=
name|NULL
condition|)
block|{
name|cfg_section_t
modifier|*
name|sec
init|=
name|sec_ptr
decl_stmt|;
name|cfg_option_t
modifier|*
name|opt
decl_stmt|;
comment|/* Canonicalize the option key */
name|svn_stringbuf_set
argument_list|(
name|cfg
operator|->
name|tmp_key
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|option_names_case_sensitive
condition|)
name|make_hash_key
argument_list|(
name|cfg
operator|->
name|tmp_key
operator|->
name|data
argument_list|)
expr_stmt|;
name|opt
operator|=
name|apr_hash_get
argument_list|(
name|sec
operator|->
name|options
argument_list|,
name|cfg
operator|->
name|tmp_key
operator|->
name|data
argument_list|,
name|cfg
operator|->
name|tmp_key
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* NOTE: ConfigParser's sections are case sensitive. */
if|if
condition|(
name|opt
operator|==
name|NULL
operator|&&
name|apr_strnatcasecmp
argument_list|(
name|section
argument_list|,
name|SVN_CONFIG__DEFAULT_SECTION
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Options which aren't found in the requested section are            also sought after in the default section. */
name|opt
operator|=
name|find_option
argument_list|(
name|cfg
argument_list|,
name|SVN_CONFIG__DEFAULT_SECTION
argument_list|,
name|option
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
return|return
name|opt
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Has a bi-directional dependency with make_string_from_option(). */
end_comment

begin_function_decl
specifier|static
name|void
name|expand_option_value
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|cfg_section_t
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|opt_value
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|opt_x_valuep
parameter_list|,
name|apr_pool_t
modifier|*
name|x_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set *VALUEP according to the OPT's value.  A value for X_POOL must    only ever be passed into this function by expand_option_value(). */
end_comment

begin_function
specifier|static
name|void
name|make_string_from_option
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|valuep
parameter_list|,
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|cfg_section_t
modifier|*
name|section
parameter_list|,
name|cfg_option_t
modifier|*
name|opt
parameter_list|,
name|apr_pool_t
modifier|*
name|x_pool
parameter_list|)
block|{
comment|/* Expand the option value if necessary. */
if|if
condition|(
operator|!
name|opt
operator|->
name|expanded
condition|)
block|{
comment|/* before attempting to expand an option, check for the placeholder.        * If none is there, there is no point in calling expand_option_value.        */
if|if
condition|(
name|opt
operator|->
name|value
operator|&&
name|strchr
argument_list|(
name|opt
operator|->
name|value
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
name|apr_pool_t
modifier|*
name|tmp_pool
init|=
operator|(
name|x_pool
condition|?
name|x_pool
else|:
name|svn_pool_create
argument_list|(
name|cfg
operator|->
name|x_pool
argument_list|)
operator|)
decl_stmt|;
name|expand_option_value
argument_list|(
name|cfg
argument_list|,
name|section
argument_list|,
name|opt
operator|->
name|value
argument_list|,
operator|&
name|opt
operator|->
name|x_value
argument_list|,
name|tmp_pool
argument_list|)
expr_stmt|;
name|opt
operator|->
name|expanded
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|x_pool
condition|)
block|{
comment|/* Grab the fully expanded value from tmp_pool before its                  disappearing act. */
if|if
condition|(
name|opt
operator|->
name|x_value
condition|)
name|opt
operator|->
name|x_value
operator|=
name|apr_pstrmemdup
argument_list|(
name|cfg
operator|->
name|x_pool
argument_list|,
name|opt
operator|->
name|x_value
argument_list|,
name|strlen
argument_list|(
name|opt
operator|->
name|x_value
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|tmp_pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|opt
operator|->
name|expanded
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opt
operator|->
name|x_value
condition|)
operator|*
name|valuep
operator|=
name|opt
operator|->
name|x_value
expr_stmt|;
else|else
operator|*
name|valuep
operator|=
name|opt
operator|->
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start of variable-replacement placeholder */
end_comment

begin_define
define|#
directive|define
name|FMT_START
value|"%("
end_define

begin_define
define|#
directive|define
name|FMT_START_LEN
value|(sizeof(FMT_START) - 1)
end_define

begin_comment
comment|/* End of variable-replacement placeholder */
end_comment

begin_define
define|#
directive|define
name|FMT_END
value|")s"
end_define

begin_define
define|#
directive|define
name|FMT_END_LEN
value|(sizeof(FMT_END) - 1)
end_define

begin_comment
comment|/* Expand OPT_VALUE (which may be NULL) in SECTION into *OPT_X_VALUEP.    If no variable replacements are done, set *OPT_X_VALUEP to    NULL. Allocate from X_POOL. */
end_comment

begin_function
specifier|static
name|void
name|expand_option_value
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|cfg_section_t
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|opt_value
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|opt_x_valuep
parameter_list|,
name|apr_pool_t
modifier|*
name|x_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|parse_from
init|=
name|opt_value
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_from
init|=
name|parse_from
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_start
decl_stmt|,
modifier|*
name|name_end
decl_stmt|;
while|while
condition|(
name|parse_from
operator|!=
name|NULL
operator|&&
operator|*
name|parse_from
operator|!=
literal|'\0'
operator|&&
operator|(
name|name_start
operator|=
name|strstr
argument_list|(
name|parse_from
argument_list|,
name|FMT_START
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|name_start
operator|+=
name|FMT_START_LEN
expr_stmt|;
if|if
condition|(
operator|*
name|name_start
operator|==
literal|'\0'
condition|)
comment|/* FMT_START at end of opt_value. */
break|break;
name|name_end
operator|=
name|strstr
argument_list|(
name|name_start
argument_list|,
name|FMT_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_end
operator|!=
name|NULL
condition|)
block|{
name|cfg_option_t
modifier|*
name|x_opt
decl_stmt|;
name|apr_size_t
name|len
init|=
name|name_end
operator|-
name|name_start
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|apr_pstrmemdup
argument_list|(
name|x_pool
argument_list|,
name|name_start
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|x_opt
operator|=
name|find_option
argument_list|(
name|cfg
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_opt
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|cstring
decl_stmt|;
comment|/* Pass back the sub-pool originally provided by                  make_string_from_option() as an indication of when it                  should terminate. */
name|make_string_from_option
argument_list|(
operator|&
name|cstring
argument_list|,
name|cfg
argument_list|,
name|section
argument_list|,
name|x_opt
argument_list|,
name|x_pool
argument_list|)
expr_stmt|;
comment|/* Append the plain text preceding the expansion. */
name|len
operator|=
name|name_start
operator|-
name|FMT_START_LEN
operator|-
name|copy_from
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|copy_from
argument_list|,
name|len
argument_list|,
name|x_pool
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|x_values
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|svn_stringbuf_appendbytes
argument_list|(
name|buf
argument_list|,
name|copy_from
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Append the expansion and adjust parse pointers. */
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|cstring
argument_list|)
expr_stmt|;
name|parse_from
operator|=
name|name_end
operator|+
name|FMT_END_LEN
expr_stmt|;
name|copy_from
operator|=
name|parse_from
expr_stmt|;
block|}
else|else
comment|/* Though ConfigParser considers the failure to resolve                the requested expansion an exception condition, we                consider it to be plain text, and look for the start of                the next one. */
name|parse_from
operator|=
name|name_end
operator|+
name|FMT_END_LEN
expr_stmt|;
block|}
else|else
comment|/* Though ConfigParser treats unterminated format specifiers            as an exception condition, we consider them to be plain            text.  The fact that there are no more format specifier            endings means we're done parsing. */
name|parse_from
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
comment|/* Copy the remainder of the plain text. */
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|copy_from
argument_list|)
expr_stmt|;
operator|*
name|opt_x_valuep
operator|=
name|buf
operator|->
name|data
expr_stmt|;
block|}
else|else
operator|*
name|opt_x_valuep
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cfg_section_t
modifier|*
name|svn_config_addsection
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|)
block|{
name|cfg_section_t
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|hash_key
decl_stmt|;
name|s
operator|=
name|apr_palloc
argument_list|(
name|cfg
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_section_t
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|cfg
operator|->
name|pool
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|section_names_case_sensitive
condition|)
name|hash_key
operator|=
name|s
operator|->
name|name
expr_stmt|;
else|else
name|hash_key
operator|=
name|make_hash_key
argument_list|(
name|apr_pstrdup
argument_list|(
name|cfg
operator|->
name|pool
argument_list|,
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|options
operator|=
name|apr_hash_make
argument_list|(
name|cfg
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|cfg
operator|->
name|sections
argument_list|,
name|hash_key
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svn_config_create_option
parameter_list|(
name|cfg_option_t
modifier|*
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|svn_boolean_t
name|option_names_case_sensitive
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|cfg_option_t
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_option_t
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_names_case_sensitive
condition|)
name|o
operator|->
name|hash_key
operator|=
name|o
operator|->
name|name
expr_stmt|;
else|else
name|o
operator|->
name|hash_key
operator|=
name|make_hash_key
argument_list|(
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|value
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|o
operator|->
name|x_value
operator|=
name|NULL
expr_stmt|;
name|o
operator|->
name|expanded
operator|=
name|FALSE
expr_stmt|;
operator|*
name|opt
operator|=
name|o
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|svn_config_get
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|valuep
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|default_value
parameter_list|)
block|{
operator|*
name|valuep
operator|=
name|default_value
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
block|{
name|cfg_section_t
modifier|*
name|sec
decl_stmt|;
name|cfg_option_t
modifier|*
name|opt
init|=
name|find_option
argument_list|(
name|cfg
argument_list|,
name|section
argument_list|,
name|option
argument_list|,
operator|&
name|sec
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|!=
name|NULL
condition|)
block|{
name|make_string_from_option
argument_list|(
name|valuep
argument_list|,
name|cfg
argument_list|,
name|sec
argument_list|,
name|opt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* before attempting to expand an option, check for the placeholder.          * If none is there, there is no point in calling expand_option_value.          */
if|if
condition|(
name|default_value
operator|&&
name|strchr
argument_list|(
name|default_value
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
name|apr_pool_t
modifier|*
name|tmp_pool
init|=
name|svn_pool_create
argument_list|(
name|cfg
operator|->
name|x_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|x_default
decl_stmt|;
name|expand_option_value
argument_list|(
name|cfg
argument_list|,
name|sec
argument_list|,
name|default_value
argument_list|,
operator|&
name|x_default
argument_list|,
name|tmp_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_default
condition|)
block|{
name|svn_stringbuf_set
argument_list|(
name|cfg
operator|->
name|tmp_value
argument_list|,
name|x_default
argument_list|)
expr_stmt|;
operator|*
name|valuep
operator|=
name|cfg
operator|->
name|tmp_value
operator|->
name|data
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|tmp_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|svn_config_set
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|cfg_section_t
modifier|*
name|sec
decl_stmt|;
name|cfg_option_t
modifier|*
name|opt
decl_stmt|;
name|remove_expansions
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|opt
operator|=
name|find_option
argument_list|(
name|cfg
argument_list|,
name|section
argument_list|,
name|option
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|NULL
condition|)
block|{
comment|/* Replace the option's value. */
name|opt
operator|->
name|value
operator|=
name|apr_pstrdup
argument_list|(
name|cfg
operator|->
name|pool
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|opt
operator|->
name|expanded
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
comment|/* Create a new option */
name|svn_config_create_option
argument_list|(
operator|&
name|opt
argument_list|,
name|option
argument_list|,
name|value
argument_list|,
name|cfg
operator|->
name|option_names_case_sensitive
argument_list|,
name|cfg
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
comment|/* Even the section doesn't exist. Create it. */
name|sec
operator|=
name|svn_config_addsection
argument_list|(
name|cfg
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|sec
operator|->
name|options
argument_list|,
name|opt
operator|->
name|hash_key
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set *BOOLP to true or false depending (case-insensitively) on INPUT.    If INPUT is null, set *BOOLP to DEFAULT_VALUE.     INPUT is a string indicating truth or falsehood in any of the usual    ways: "true"/"yes"/"on"/etc, "false"/"no"/"off"/etc.     If INPUT is neither NULL nor a recognized string, return an error    with code SVN_ERR_BAD_CONFIG_VALUE; use SECTION and OPTION in    constructing the error string. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_bool
parameter_list|(
name|svn_boolean_t
modifier|*
name|boolp
parameter_list|,
specifier|const
name|char
modifier|*
name|input
parameter_list|,
name|svn_boolean_t
name|default_value
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|)
block|{
name|svn_tristate_t
name|value
init|=
name|svn_tristate__from_word
argument_list|(
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|svn_tristate_true
condition|)
operator|*
name|boolp
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|svn_tristate_false
condition|)
operator|*
name|boolp
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
comment|/* no value provided */
operator|*
name|boolp
operator|=
name|default_value
expr_stmt|;
elseif|else
if|if
condition|(
name|section
condition|)
comment|/* unrecognized value */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Config error: invalid boolean "
literal|"value '%s' for '[%s] %s'"
argument_list|)
argument_list|,
name|input
argument_list|,
name|section
argument_list|,
name|option
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Config error: invalid boolean "
literal|"value '%s' for '%s'"
argument_list|)
argument_list|,
name|input
argument_list|,
name|option
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_get_bool
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|svn_boolean_t
modifier|*
name|valuep
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|svn_boolean_t
name|default_value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp_value
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|tmp_value
argument_list|,
name|section
argument_list|,
name|option
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|get_bool
argument_list|(
name|valuep
argument_list|,
name|tmp_value
argument_list|,
name|default_value
argument_list|,
name|section
argument_list|,
name|option
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|svn_config_set_bool
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|svn_boolean_t
name|value
parameter_list|)
block|{
name|svn_config_set
argument_list|(
name|cfg
argument_list|,
name|section
argument_list|,
name|option
argument_list|,
operator|(
name|value
condition|?
name|SVN_CONFIG_TRUE
else|:
name|SVN_CONFIG_FALSE
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_get_int64
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|apr_int64_t
modifier|*
name|valuep
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|apr_int64_t
name|default_value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp_value
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|tmp_value
argument_list|,
name|section
argument_list|,
name|option
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_value
condition|)
return|return
name|svn_cstring_strtoi64
argument_list|(
name|valuep
argument_list|,
name|tmp_value
argument_list|,
name|APR_INT64_MIN
argument_list|,
name|APR_INT64_MAX
argument_list|,
literal|10
argument_list|)
return|;
operator|*
name|valuep
operator|=
name|default_value
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_config_set_int64
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|apr_int64_t
name|value
parameter_list|)
block|{
name|svn_config_set
argument_list|(
name|cfg
argument_list|,
name|section
argument_list|,
name|option
argument_list|,
name|apr_psprintf
argument_list|(
name|cfg
operator|->
name|pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_get_yes_no_ask
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|valuep
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|default_value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp_value
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|tmp_value
argument_list|,
name|section
argument_list|,
name|option
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_value
condition|)
name|tmp_value
operator|=
name|default_value
expr_stmt|;
if|if
condition|(
name|tmp_value
operator|&&
operator|(
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|tmp_value
argument_list|,
name|SVN_CONFIG_ASK
argument_list|)
operator|)
condition|)
block|{
operator|*
name|valuep
operator|=
name|SVN_CONFIG_ASK
expr_stmt|;
block|}
else|else
block|{
name|svn_boolean_t
name|bool_val
decl_stmt|;
comment|/* We already incorporated default_value into tmp_value if          necessary, so the FALSE below will be ignored unless the          caller is doing something it shouldn't be doing. */
name|SVN_ERR
argument_list|(
name|get_bool
argument_list|(
operator|&
name|bool_val
argument_list|,
name|tmp_value
argument_list|,
name|FALSE
argument_list|,
name|section
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|valuep
operator|=
name|bool_val
condition|?
name|SVN_CONFIG_TRUE
else|:
name|SVN_CONFIG_FALSE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_get_tristate
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|svn_tristate_t
modifier|*
name|valuep
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|unknown_value
parameter_list|,
name|svn_tristate_t
name|default_value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp_value
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|tmp_value
argument_list|,
name|section
argument_list|,
name|option
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_value
condition|)
block|{
operator|*
name|valuep
operator|=
name|default_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|tmp_value
argument_list|,
name|unknown_value
argument_list|)
condition|)
block|{
operator|*
name|valuep
operator|=
name|svn_tristate_unknown
expr_stmt|;
block|}
else|else
block|{
name|svn_boolean_t
name|bool_val
decl_stmt|;
comment|/* We already incorporated default_value into tmp_value if          necessary, so the FALSE below will be ignored unless the          caller is doing something it shouldn't be doing. */
name|SVN_ERR
argument_list|(
name|get_bool
argument_list|(
operator|&
name|bool_val
argument_list|,
name|tmp_value
argument_list|,
name|FALSE
argument_list|,
name|section
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|valuep
operator|=
name|bool_val
condition|?
name|svn_tristate_true
else|:
name|svn_tristate_false
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|svn_config_enumerate_sections
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|svn_config_section_enumerator_t
name|callback
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|sec_ndx
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|cfg
operator|->
name|x_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|sec_ndx
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|cfg
operator|->
name|sections
argument_list|)
init|;
name|sec_ndx
operator|!=
name|NULL
condition|;
name|sec_ndx
operator|=
name|apr_hash_next
argument_list|(
name|sec_ndx
argument_list|)
control|)
block|{
name|void
modifier|*
name|sec_ptr
decl_stmt|;
name|cfg_section_t
modifier|*
name|sec
decl_stmt|;
name|apr_hash_this
argument_list|(
name|sec_ndx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sec_ptr
argument_list|)
expr_stmt|;
name|sec
operator|=
name|sec_ptr
expr_stmt|;
operator|++
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|callback
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|baton
argument_list|)
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
name|int
name|svn_config_enumerate_sections2
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|svn_config_section_enumerator2_t
name|callback
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|sec_ndx
decl_stmt|;
name|apr_pool_t
modifier|*
name|iteration_pool
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|iteration_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|sec_ndx
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|cfg
operator|->
name|sections
argument_list|)
init|;
name|sec_ndx
operator|!=
name|NULL
condition|;
name|sec_ndx
operator|=
name|apr_hash_next
argument_list|(
name|sec_ndx
argument_list|)
control|)
block|{
name|void
modifier|*
name|sec_ptr
decl_stmt|;
name|cfg_section_t
modifier|*
name|sec
decl_stmt|;
name|apr_hash_this
argument_list|(
name|sec_ndx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sec_ptr
argument_list|)
expr_stmt|;
name|sec
operator|=
name|sec_ptr
expr_stmt|;
operator|++
name|count
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iteration_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callback
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|baton
argument_list|,
name|iteration_pool
argument_list|)
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|iteration_pool
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|svn_config_enumerate
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|svn_config_enumerator_t
name|callback
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|cfg_section_t
modifier|*
name|sec
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|opt_ndx
decl_stmt|;
name|int
name|count
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|find_option
argument_list|(
name|cfg
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|cfg
operator|->
name|x_pool
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opt_ndx
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|sec
operator|->
name|options
argument_list|)
init|;
name|opt_ndx
operator|!=
name|NULL
condition|;
name|opt_ndx
operator|=
name|apr_hash_next
argument_list|(
name|opt_ndx
argument_list|)
control|)
block|{
name|void
modifier|*
name|opt_ptr
decl_stmt|;
name|cfg_option_t
modifier|*
name|opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_value
decl_stmt|;
name|apr_hash_this
argument_list|(
name|opt_ndx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|opt_ptr
argument_list|)
expr_stmt|;
name|opt
operator|=
name|opt_ptr
expr_stmt|;
operator|++
name|count
expr_stmt|;
name|make_string_from_option
argument_list|(
operator|&
name|temp_value
argument_list|,
name|cfg
argument_list|,
name|sec
argument_list|,
name|opt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callback
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|temp_value
argument_list|,
name|baton
argument_list|)
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
name|int
name|svn_config_enumerate2
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|svn_config_enumerator2_t
name|callback
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|cfg_section_t
modifier|*
name|sec
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|opt_ndx
decl_stmt|;
name|apr_pool_t
modifier|*
name|iteration_pool
decl_stmt|;
name|int
name|count
decl_stmt|;
name|find_option
argument_list|(
name|cfg
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|iteration_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opt_ndx
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|sec
operator|->
name|options
argument_list|)
init|;
name|opt_ndx
operator|!=
name|NULL
condition|;
name|opt_ndx
operator|=
name|apr_hash_next
argument_list|(
name|opt_ndx
argument_list|)
control|)
block|{
name|void
modifier|*
name|opt_ptr
decl_stmt|;
name|cfg_option_t
modifier|*
name|opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_value
decl_stmt|;
name|apr_hash_this
argument_list|(
name|opt_ndx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|opt_ptr
argument_list|)
expr_stmt|;
name|opt
operator|=
name|opt_ptr
expr_stmt|;
operator|++
name|count
expr_stmt|;
name|make_string_from_option
argument_list|(
operator|&
name|temp_value
argument_list|,
name|cfg
argument_list|,
name|sec
argument_list|,
name|opt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iteration_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callback
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|temp_value
argument_list|,
name|baton
argument_list|,
name|iteration_pool
argument_list|)
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|iteration_pool
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Baton for search_groups() */
end_comment

begin_struct
struct|struct
name|search_groups_baton
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Provided by caller of svn_config_find_group */
specifier|const
name|char
modifier|*
name|match
decl_stmt|;
comment|/* Filled in by search_groups */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is an `svn_config_enumerator_t' function, and BATON is a  * `struct search_groups_baton *'.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|search_groups
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|search_groups_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|svn_cstring_split
argument_list|(
name|value
argument_list|,
literal|","
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_cstring_match_glob_list
argument_list|(
name|b
operator|->
name|key
argument_list|,
name|list
argument_list|)
condition|)
block|{
comment|/* Fill in the match and return false, to stop enumerating. */
name|b
operator|->
name|match
operator|=
name|apr_pstrdup
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_config_find_group
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|master_section
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|search_groups_baton
name|gb
decl_stmt|;
name|gb
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|gb
operator|.
name|match
operator|=
name|NULL
expr_stmt|;
name|gb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
operator|(
name|void
operator|)
name|svn_config_enumerate2
argument_list|(
name|cfg
argument_list|,
name|master_section
argument_list|,
name|search_groups
argument_list|,
operator|&
name|gb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|gb
operator|.
name|match
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|const
name|char
modifier|*
name|svn_config_get_server_setting
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|server_group
parameter_list|,
specifier|const
name|char
modifier|*
name|option_name
parameter_list|,
specifier|const
name|char
modifier|*
name|default_value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|retval
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|option_name
argument_list|,
name|default_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_group
condition|)
block|{
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|retval
argument_list|,
name|server_group
argument_list|,
name|option_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_dup
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfgp
parameter_list|,
name|svn_config_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|sectidx
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|optidx
decl_stmt|;
operator|*
name|cfgp
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_create2
argument_list|(
name|cfgp
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cfgp
operator|)
operator|->
name|x_values
operator|=
name|src
operator|->
name|x_values
expr_stmt|;
operator|(
operator|*
name|cfgp
operator|)
operator|->
name|section_names_case_sensitive
operator|=
name|src
operator|->
name|section_names_case_sensitive
expr_stmt|;
operator|(
operator|*
name|cfgp
operator|)
operator|->
name|option_names_case_sensitive
operator|=
name|src
operator|->
name|option_names_case_sensitive
expr_stmt|;
for|for
control|(
name|sectidx
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|src
operator|->
name|sections
argument_list|)
init|;
name|sectidx
operator|!=
name|NULL
condition|;
name|sectidx
operator|=
name|apr_hash_next
argument_list|(
name|sectidx
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|sectkey
decl_stmt|;
name|void
modifier|*
name|sectval
decl_stmt|;
name|apr_ssize_t
name|sectkeyLength
decl_stmt|;
name|cfg_section_t
modifier|*
name|srcsect
decl_stmt|;
name|cfg_section_t
modifier|*
name|destsec
decl_stmt|;
name|apr_hash_this
argument_list|(
name|sectidx
argument_list|,
operator|&
name|sectkey
argument_list|,
operator|&
name|sectkeyLength
argument_list|,
operator|&
name|sectval
argument_list|)
expr_stmt|;
name|srcsect
operator|=
name|sectval
expr_stmt|;
name|destsec
operator|=
name|svn_config_addsection
argument_list|(
operator|*
name|cfgp
argument_list|,
name|srcsect
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|optidx
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|srcsect
operator|->
name|options
argument_list|)
init|;
name|optidx
operator|!=
name|NULL
condition|;
name|optidx
operator|=
name|apr_hash_next
argument_list|(
name|optidx
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|optkey
decl_stmt|;
name|void
modifier|*
name|optval
decl_stmt|;
name|apr_ssize_t
name|optkeyLength
decl_stmt|;
name|cfg_option_t
modifier|*
name|srcopt
decl_stmt|;
name|cfg_option_t
modifier|*
name|destopt
decl_stmt|;
name|apr_hash_this
argument_list|(
name|optidx
argument_list|,
operator|&
name|optkey
argument_list|,
operator|&
name|optkeyLength
argument_list|,
operator|&
name|optval
argument_list|)
expr_stmt|;
name|srcopt
operator|=
name|optval
expr_stmt|;
name|svn_config_create_option
argument_list|(
operator|&
name|destopt
argument_list|,
name|srcopt
operator|->
name|name
argument_list|,
name|srcopt
operator|->
name|value
argument_list|,
operator|(
operator|*
name|cfgp
operator|)
operator|->
name|option_names_case_sensitive
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|destopt
operator|->
name|value
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|srcopt
operator|->
name|value
argument_list|)
expr_stmt|;
name|destopt
operator|->
name|x_value
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|srcopt
operator|->
name|x_value
argument_list|)
expr_stmt|;
name|destopt
operator|->
name|expanded
operator|=
name|srcopt
operator|->
name|expanded
expr_stmt|;
name|apr_hash_set
argument_list|(
name|destsec
operator|->
name|options
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|optkey
argument_list|)
argument_list|,
name|optkeyLength
argument_list|,
name|destopt
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_copy_config
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|cfg_hash
parameter_list|,
name|apr_hash_t
modifier|*
name|src_hash
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|cidx
decl_stmt|;
operator|*
name|cfg_hash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|cidx
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|src_hash
argument_list|)
init|;
name|cidx
operator|!=
name|NULL
condition|;
name|cidx
operator|=
name|apr_hash_next
argument_list|(
name|cidx
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|ckey
decl_stmt|;
name|void
modifier|*
name|cval
decl_stmt|;
name|apr_ssize_t
name|ckeyLength
decl_stmt|;
name|svn_config_t
modifier|*
name|srcconfig
decl_stmt|;
name|svn_config_t
modifier|*
name|destconfig
decl_stmt|;
name|apr_hash_this
argument_list|(
name|cidx
argument_list|,
operator|&
name|ckey
argument_list|,
operator|&
name|ckeyLength
argument_list|,
operator|&
name|cval
argument_list|)
expr_stmt|;
name|srcconfig
operator|=
name|cval
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_dup
argument_list|(
operator|&
name|destconfig
argument_list|,
name|srcconfig
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
operator|*
name|cfg_hash
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ckey
argument_list|)
argument_list|,
name|ckeyLength
argument_list|,
name|destconfig
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_get_server_setting_int
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|server_group
parameter_list|,
specifier|const
name|char
modifier|*
name|option_name
parameter_list|,
name|apr_int64_t
name|default_value
parameter_list|,
name|apr_int64_t
modifier|*
name|result_value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp_value
decl_stmt|;
name|char
modifier|*
name|end_pos
decl_stmt|;
name|tmp_value
operator|=
name|svn_config_get_server_setting
argument_list|(
name|cfg
argument_list|,
name|server_group
argument_list|,
name|option_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_value
operator|==
name|NULL
condition|)
operator|*
name|result_value
operator|=
name|default_value
expr_stmt|;
else|else
block|{
comment|/* read tmp_value as an int now */
operator|*
name|result_value
operator|=
name|apr_strtoi64
argument_list|(
name|tmp_value
argument_list|,
operator|&
name|end_pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end_pos
operator|!=
literal|0
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Config error: invalid integer value '%s'"
argument_list|)
argument_list|,
name|tmp_value
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_config_get_server_setting_bool
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
name|svn_boolean_t
modifier|*
name|valuep
parameter_list|,
specifier|const
name|char
modifier|*
name|server_group
parameter_list|,
specifier|const
name|char
modifier|*
name|option_name
parameter_list|,
name|svn_boolean_t
name|default_value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp_value
decl_stmt|;
name|tmp_value
operator|=
name|svn_config_get_server_setting
argument_list|(
name|cfg
argument_list|,
name|server_group
argument_list|,
name|option_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|get_bool
argument_list|(
name|valuep
argument_list|,
name|tmp_value
argument_list|,
name|default_value
argument_list|,
name|server_group
argument_list|,
name|option_name
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_config_has_section
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|)
block|{
name|cfg_section_t
modifier|*
name|sec
decl_stmt|;
comment|/* Canonicalize the hash key */
name|svn_stringbuf_set
argument_list|(
name|cfg
operator|->
name|tmp_key
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|section_names_case_sensitive
condition|)
name|make_hash_key
argument_list|(
name|cfg
operator|->
name|tmp_key
operator|->
name|data
argument_list|)
expr_stmt|;
name|sec
operator|=
name|svn_hash_gets
argument_list|(
name|cfg
operator|->
name|sections
argument_list|,
name|cfg
operator|->
name|tmp_key
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|sec
operator|!=
name|NULL
return|;
block|}
end_function

end_unit

