begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * gpg_agent.c: GPG Agent provider for SVN_AUTH_CRED_*  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_comment
comment|/* This auth provider stores a plaintext password in memory managed by  * a running gpg-agent. In contrast to other password store providers  * it does not save the password to disk.  *  * Prompting is performed by the gpg-agent using a "pinentry" program  * which needs to be installed separately. There are several pinentry  * implementations with different front-ends (e.g. qt, gtk, ncurses).  *  * The gpg-agent will let the password time out after a while,  * or immediately when it receives the SIGHUP signal.  * When the password has timed out it will automatically prompt the  * user for the password again. This is transparent to Subversion.  *  * SECURITY CONSIDERATIONS:  *  * Communication to the agent happens over a UNIX socket, which is located  * in a directory which only the user running Subversion can access.  * However, any program the user runs could access this socket and get  * the Subversion password if the program knows the "cache ID" Subversion  * uses for the password.  * The cache ID is very easy to obtain for programs running as the same user.  * Subversion uses the MD5 of the realmstring as cache ID, and these checksums  * are also used as filenames within ~/.subversion/auth/svn.simple.  * Unlike GNOME Keyring or KDE Wallet, the user is not prompted for  * permission if another program attempts to access the password.  *  * Therefore, while the gpg-agent is running and has the password cached,  * this provider is no more secure than a file storing the password in  * plaintext.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_auth.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_user.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_auth_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_GPG_AGENT
end_ifdef

begin_define
define|#
directive|define
name|BUFFER_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|ATTEMPT_PARAMETER
value|"svn.simple.gpg_agent.attempt"
end_define

begin_comment
comment|/* Modify STR in-place such that blanks are escaped as required by the  * gpg-agent protocol. Return a pointer to STR. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|escape_blanks
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|str
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|*
name|s
operator|=
literal|'+'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_define
define|#
directive|define
name|is_hex
parameter_list|(
name|c
parameter_list|)
value|(((c)>= '0'&& (c)<= '9') || ((c)>= 'A'&& (c)<= 'F'))
end_define

begin_define
define|#
directive|define
name|hex_to_int
parameter_list|(
name|c
parameter_list|)
value|((c)< '9' ? (c) - '0' : (c) - 'A' + 10)
end_define

begin_comment
comment|/* Modify STR in-place.  '%', CR and LF are always percent escaped,    other characters may be percent escaped, always using uppercase    hex, see https://www.gnupg.org/documentation/manuals/assuan.pdf */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|unescape_assuan
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|str
decl_stmt|;
while|while
condition|(
name|s
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|is_hex
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|is_hex
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s2
init|=
name|s
decl_stmt|;
name|char
name|val
init|=
name|hex_to_int
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|+
name|hex_to_int
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|s2
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
operator|++
name|s2
expr_stmt|;
while|while
condition|(
name|s2
index|[
literal|2
index|]
condition|)
block|{
name|s2
index|[
literal|0
index|]
operator|=
name|s2
index|[
literal|2
index|]
expr_stmt|;
operator|++
name|s2
expr_stmt|;
block|}
name|s2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Generate the string CACHE_ID_P based on the REALMSTRING allocated in  * RESULT_POOL using SCRATCH_POOL for temporary allocations.  This is similar  * to other password caching mechanisms. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cache_id
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|cache_id_p
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cache_id
init|=
name|NULL
decl_stmt|;
name|svn_checksum_t
modifier|*
name|digest
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|digest
argument_list|,
name|svn_checksum_md5
argument_list|,
name|realmstring
argument_list|,
name|strlen
argument_list|(
name|realmstring
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cache_id
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|digest
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|cache_id_p
operator|=
name|cache_id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Attempt to read a gpg-agent response message from the socket SD into  * buffer BUF. Buf is assumed to be N bytes large. Return TRUE if a response  * message could be read that fits into the buffer. Else return FALSE.  * If a message could be read it will always be NUL-terminated and the  * trailing newline is retained. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|receive_from_gpg_agent
parameter_list|(
name|int
name|sd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|size_t
name|recvd
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Clear existing buffer content before reading response. */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
comment|/* Require the message to fit into the buffer and be terminated    * with a newline. */
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|recvd
operator|=
name|read
argument_list|(
name|sd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvd
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Using socket SD, send the option OPTION with the specified VALUE  * to the gpg agent. Store the response in BUF, assumed to be N bytes  * in size, and evaluate the response. Return TRUE if the agent liked  * the smell of the option, if there is such a thing, and doesn't feel  * saturated by it. Else return FALSE.  * Do temporary allocations in scratch_pool. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|send_option
parameter_list|(
name|int
name|sd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"OPTION %s=%s\n"
argument_list|,
name|option
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|strlen
argument_list|(
name|request
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"OK"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Send the BYE command and disconnect from the gpg-agent.  Doing this avoids  * gpg-agent emitting a "Connection reset by peer" log message with some  * versions of gpg-agent. */
end_comment

begin_function
specifier|static
name|void
name|bye_gpg_agent
parameter_list|(
name|int
name|sd
parameter_list|)
block|{
comment|/* don't bother to check the result of the write, it either worked or it    * didn't, but either way we're closing. */
name|write
argument_list|(
name|sd
argument_list|,
literal|"BYE\n"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locate a running GPG Agent, and return an open file descriptor  * for communication with the agent in *NEW_SD. If no running agent  * can be found, set *NEW_SD to -1. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_running_gpg_agent
parameter_list|(
name|int
modifier|*
name|new_sd
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|gpg_agent_info
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|socket_name
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|request
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|int
name|sd
decl_stmt|;
operator|*
name|new_sd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This implements the method of finding the socket as described in    * the gpg-agent man page under the --use-standard-socket option.    * The manage page misleadingly says the standard socket is    * "named 'S.gpg-agent' located in the home directory."  The standard    * socket path is actually in the .gnupg directory in the home directory,    * i.e. ~/.gnupg/S.gpg-agent */
name|gpg_agent_info
operator|=
name|getenv
argument_list|(
literal|"GPG_AGENT_INFO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpg_agent_info
operator|!=
name|NULL
condition|)
block|{
name|apr_array_header_t
modifier|*
name|socket_details
decl_stmt|;
comment|/* For reference GPG_AGENT_INFO consists of 3 : separated fields.        * The path to the socket, the pid of the gpg-agent process and        * finally the version of the protocol the agent talks. */
name|socket_details
operator|=
name|svn_cstring_split
argument_list|(
name|gpg_agent_info
argument_list|,
literal|":"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|socket_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|socket_details
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|homedir
init|=
name|svn_user_get_homedir
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|homedir
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|homedir
operator|=
name|svn_dirent_canonicalize
argument_list|(
name|homedir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|socket_name
operator|=
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|homedir
argument_list|,
literal|".gnupg"
argument_list|,
literal|"S.gpg-agent"
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|socket_name
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sockaddr_un
name|addr
decl_stmt|;
name|addr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strncpy
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|,
name|socket_name
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sun_path
index|[
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sd
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
operator|-
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|connect
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
return|return
name|SVN_NO_ERROR
return|;
comment|/* Receive the connection status from the gpg-agent daemon. */
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"OK"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The GPG-Agent documentation says:    *  "Clients should deny to access an agent with a socket name which does    *   not match its own configuration". */
name|request
operator|=
literal|"GETINFO socket_name\n"
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|strlen
argument_list|(
name|request
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"D"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|=
operator|&
name|buffer
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|ep
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|socket_name
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The agent will terminate its response with "OK". */
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"OK"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
name|new_sd
operator|=
name|sd
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|send_options
parameter_list|(
name|int
name|sd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tty_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|tty_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|lc_ctype
decl_stmt|;
specifier|const
name|char
modifier|*
name|display
decl_stmt|;
comment|/* Send TTY_NAME to the gpg-agent daemon. */
name|tty_name
operator|=
name|getenv
argument_list|(
literal|"GPG_TTY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|send_option
argument_list|(
name|sd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|,
literal|"ttyname"
argument_list|,
name|tty_name
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Send TTY_TYPE to the gpg-agent daemon. */
name|tty_type
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_type
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|send_option
argument_list|(
name|sd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|,
literal|"ttytype"
argument_list|,
name|tty_type
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Compute LC_CTYPE. */
name|lc_ctype
operator|=
name|getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc_ctype
operator|==
name|NULL
condition|)
name|lc_ctype
operator|=
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc_ctype
operator|==
name|NULL
condition|)
name|lc_ctype
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
comment|/* Send LC_CTYPE to the gpg-agent daemon. */
if|if
condition|(
name|lc_ctype
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|send_option
argument_list|(
name|sd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|,
literal|"lc-ctype"
argument_list|,
name|lc_ctype
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Send DISPLAY to the gpg-agent daemon. */
name|display
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|display
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|send_option
argument_list|(
name|sd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|,
literal|"display"
argument_list|,
name|display
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Implementation of svn_auth__password_get_t that retrieves the password    from gpg-agent */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|password_get_gpg_agent
parameter_list|(
name|svn_boolean_t
modifier|*
name|done
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|password
parameter_list|,
name|apr_hash_t
modifier|*
name|creds
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
name|apr_hash_t
modifier|*
name|parameters
parameter_list|,
name|svn_boolean_t
name|non_interactive
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|sd
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|request
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|cache_id
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|password_prompt
decl_stmt|;
name|char
modifier|*
name|realm_prompt
decl_stmt|;
name|char
modifier|*
name|error_prompt
decl_stmt|;
name|int
modifier|*
name|attempt
decl_stmt|;
operator|*
name|done
operator|=
name|FALSE
expr_stmt|;
name|attempt
operator|=
name|svn_hash_gets
argument_list|(
name|parameters
argument_list|,
name|ATTEMPT_PARAMETER
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_running_gpg_agent
argument_list|(
operator|&
name|sd
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
operator|-
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|send_options
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|,
name|pool
argument_list|)
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|get_cache_id
argument_list|(
operator|&
name|cache_id
argument_list|,
name|realmstring
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|password_prompt
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Password for '%s': "
argument_list|)
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|realm_prompt
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Enter your Subversion password for %s"
argument_list|)
argument_list|,
name|realmstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|attempt
operator|==
literal|1
condition|)
comment|/* X means no error to the gpg-agent protocol */
name|error_prompt
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
else|else
name|error_prompt
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Authentication failed"
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"GET_PASSPHRASE --data %s"
literal|"%s %s %s %s\n"
argument_list|,
name|non_interactive
condition|?
literal|"--no-ask "
else|:
literal|""
argument_list|,
name|cache_id
argument_list|,
name|escape_blanks
argument_list|(
name|error_prompt
argument_list|)
argument_list|,
name|escape_blanks
argument_list|(
name|password_prompt
argument_list|)
argument_list|,
name|escape_blanks
argument_list|(
name|realm_prompt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|strlen
argument_list|(
name|request
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"ERR"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"D"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|=
operator|&
name|buffer
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|ep
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|password
operator|=
name|unescape_assuan
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|done
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implementation of svn_auth__password_set_t that would store the    password in GPG Agent if that's how this particular integration    worked.  But it isn't.  GPG Agent stores the password provided by    the user via the pinentry program immediately upon its provision    (and regardless of its accuracy as passwords go), so we just need    to check if a running GPG Agent exists. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|password_set_gpg_agent
parameter_list|(
name|svn_boolean_t
modifier|*
name|done
parameter_list|,
name|apr_hash_t
modifier|*
name|creds
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|,
name|apr_hash_t
modifier|*
name|parameters
parameter_list|,
name|svn_boolean_t
name|non_interactive
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|sd
decl_stmt|;
operator|*
name|done
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_running_gpg_agent
argument_list|(
operator|&
name|sd
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
operator|-
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
operator|*
name|done
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An implementation of svn_auth_provider_t::first_credentials() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|simple_gpg_agent_first_creds
parameter_list|(
name|void
modifier|*
modifier|*
name|credentials
parameter_list|,
name|void
modifier|*
modifier|*
name|iter_baton
parameter_list|,
name|void
modifier|*
name|provider_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|parameters
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
modifier|*
name|attempt
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|attempt
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|attempt
operator|=
literal|1
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|parameters
argument_list|,
name|ATTEMPT_PARAMETER
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_auth__simple_creds_cache_get
argument_list|(
name|credentials
argument_list|,
name|iter_baton
argument_list|,
name|provider_baton
argument_list|,
name|parameters
argument_list|,
name|realmstring
argument_list|,
name|password_get_gpg_agent
argument_list|,
name|SVN_AUTH__GPG_AGENT_PASSWORD_TYPE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|iter_baton
operator|=
name|attempt
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* An implementation of svn_auth_provider_t::next_credentials() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|simple_gpg_agent_next_creds
parameter_list|(
name|void
modifier|*
modifier|*
name|credentials
parameter_list|,
name|void
modifier|*
name|iter_baton
parameter_list|,
name|void
modifier|*
name|provider_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|parameters
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
modifier|*
name|attempt
init|=
operator|(
name|int
operator|*
operator|)
name|iter_baton
decl_stmt|;
name|int
name|sd
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|cache_id
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|request
init|=
name|NULL
decl_stmt|;
operator|*
name|credentials
operator|=
name|NULL
expr_stmt|;
comment|/* The users previous credentials failed so first remove the cached entry,    * before trying to retrieve them again.  Because gpg-agent stores cached    * credentials immediately upon retrieving them, this gives us the    * opportunity to remove the invalid credentials and prompt the    * user again.  While it's possible that server side issues could trigger    * this, this cache is ephemeral so at worst we're just speeding up    * when the user would need to re-enter their password. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|parameters
argument_list|,
name|SVN_AUTH_PARAM_NON_INTERACTIVE
argument_list|)
condition|)
block|{
comment|/* In this case since we're running non-interactively we do not        * want to clear the cache since the user was never prompted by        * gpg-agent to set a password. */
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
name|attempt
operator|=
operator|*
name|attempt
operator|+
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_running_gpg_agent
argument_list|(
operator|&
name|sd
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
operator|-
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|send_options
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|,
name|pool
argument_list|)
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|get_cache_id
argument_list|(
operator|&
name|cache_id
argument_list|,
name|realmstring
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"CLEAR_PASSPHRASE %s\n"
argument_list|,
name|cache_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|strlen
argument_list|(
name|request
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"OK\n"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bye_gpg_agent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* TODO: This attempt limit hard codes it at 3 attempts (or 2 retries)    * which matches svn command line client's retry_limit as set in    * svn_cmdline_create_auth_baton().  It would be nice to have that    * limit reflected here but that violates the boundry between the    * prompt provider and the cache provider.  gpg-agent is acting as    * both here due to the peculiarties of their design so we'll have to    * live with this for now.  Note that when these failures get exceeded    * it'll eventually fall back on the retry limits of whatever prompt    * provider is in effect, so this effectively doubles the limit. */
if|if
condition|(
operator|*
name|attempt
operator|<
literal|4
condition|)
return|return
name|svn_auth__simple_creds_cache_get
argument_list|(
name|credentials
argument_list|,
operator|&
name|iter_baton
argument_list|,
name|provider_baton
argument_list|,
name|parameters
argument_list|,
name|realmstring
argument_list|,
name|password_get_gpg_agent
argument_list|,
name|SVN_AUTH__GPG_AGENT_PASSWORD_TYPE
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An implementation of svn_auth_provider_t::save_credentials() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|simple_gpg_agent_save_creds
parameter_list|(
name|svn_boolean_t
modifier|*
name|saved
parameter_list|,
name|void
modifier|*
name|credentials
parameter_list|,
name|void
modifier|*
name|provider_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|parameters
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_auth__simple_creds_cache_set
argument_list|(
name|saved
argument_list|,
name|credentials
argument_list|,
name|provider_baton
argument_list|,
name|parameters
argument_list|,
name|realmstring
argument_list|,
name|password_set_gpg_agent
argument_list|,
name|SVN_AUTH__GPG_AGENT_PASSWORD_TYPE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_auth_provider_t
name|gpg_agent_simple_provider
init|=
block|{
name|SVN_AUTH_CRED_SIMPLE
block|,
name|simple_gpg_agent_first_creds
block|,
name|simple_gpg_agent_next_creds
block|,
name|simple_gpg_agent_save_creds
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Public API */
end_comment

begin_function
name|void
name|svn_auth__get_gpg_agent_simple_provider
parameter_list|(
name|svn_auth_provider_object_t
modifier|*
modifier|*
name|provider
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_auth_provider_object_t
modifier|*
name|po
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|po
argument_list|)
argument_list|)
decl_stmt|;
name|po
operator|->
name|vtable
operator|=
operator|&
name|gpg_agent_simple_provider
expr_stmt|;
operator|*
name|provider
operator|=
name|po
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_HAVE_GPG_AGENT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !WIN32 */
end_comment

end_unit

