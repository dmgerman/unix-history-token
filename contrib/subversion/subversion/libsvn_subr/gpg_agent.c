begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * gpg_agent.c: GPG Agent provider for SVN_AUTH_CRED_*  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_comment
comment|/* This auth provider stores a plaintext password in memory managed by  * a running gpg-agent. In contrast to other password store providers  * it does not save the password to disk.  *  * Prompting is performed by the gpg-agent using a "pinentry" program  * which needs to be installed separately. There are several pinentry  * implementations with different front-ends (e.g. qt, gtk, ncurses).  *  * The gpg-agent will let the password time out after a while,  * or immediately when it receives the SIGHUP signal.  * When the password has timed out it will automatically prompt the  * user for the password again. This is transparent to Subversion.  *  * SECURITY CONSIDERATIONS:  *  * Communication to the agent happens over a UNIX socket, which is located  * in a directory which only the user running Subversion can access.  * However, any program the user runs could access this socket and get  * the Subversion password if the program knows the "cache ID" Subversion  * uses for the password.  * The cache ID is very easy to obtain for programs running as the same user.  * Subversion uses the MD5 of the realmstring as cache ID, and these checksums  * are also used as filenames within ~/.subversion/auth/svn.simple.  * Unlike GNOME Keyring or KDE Wallet, the user is not prompted for  * permission if another program attempts to access the password.  *  * Therefore, while the gpg-agent is running and has the password cached,  * this provider is no more secure than a file storing the password in  * plaintext.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_auth.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_auth_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_GPG_AGENT
end_ifdef

begin_define
define|#
directive|define
name|BUFFER_SIZE
value|1024
end_define

begin_comment
comment|/* Modify STR in-place such that blanks are escaped as required by the  * gpg-agent protocol. Return a pointer to STR. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|escape_blanks
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|str
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|*
name|s
operator|=
literal|'+'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Attempt to read a gpg-agent response message from the socket SD into  * buffer BUF. Buf is assumed to be N bytes large. Return TRUE if a response  * message could be read that fits into the buffer. Else return FALSE.  * If a message could be read it will always be NUL-terminated and the  * trailing newline is retained. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|receive_from_gpg_agent
parameter_list|(
name|int
name|sd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|size_t
name|recvd
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Clear existing buffer content before reading response. */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
comment|/* Require the message to fit into the buffer and be terminated    * with a newline. */
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|recvd
operator|=
name|read
argument_list|(
name|sd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvd
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Using socket SD, send the option OPTION with the specified VALUE  * to the gpg agent. Store the response in BUF, assumed to be N bytes  * in size, and evaluate the response. Return TRUE if the agent liked  * the smell of the option, if there is such a thing, and doesn't feel  * saturated by it. Else return FALSE.  * Do temporary allocations in scratch_pool. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|send_option
parameter_list|(
name|int
name|sd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"OPTION %s=%s\n"
argument_list|,
name|option
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|strlen
argument_list|(
name|request
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"OK"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Locate a running GPG Agent, and return an open file descriptor  * for communication with the agent in *NEW_SD. If no running agent  * can be found, set *NEW_SD to -1. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_running_gpg_agent
parameter_list|(
name|int
modifier|*
name|new_sd
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|gpg_agent_info
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|socket_name
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|request
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|int
name|sd
decl_stmt|;
operator|*
name|new_sd
operator|=
operator|-
literal|1
expr_stmt|;
name|gpg_agent_info
operator|=
name|getenv
argument_list|(
literal|"GPG_AGENT_INFO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpg_agent_info
operator|!=
name|NULL
condition|)
block|{
name|apr_array_header_t
modifier|*
name|socket_details
decl_stmt|;
name|socket_details
operator|=
name|svn_cstring_split
argument_list|(
name|gpg_agent_info
argument_list|,
literal|":"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|socket_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|socket_details
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|socket_name
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sockaddr_un
name|addr
decl_stmt|;
name|addr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strncpy
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|,
name|socket_name
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sun_path
index|[
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sd
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
operator|-
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|connect
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
return|return
name|SVN_NO_ERROR
return|;
comment|/* Receive the connection status from the gpg-agent daemon. */
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"OK"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The GPG-Agent documentation says:    *  "Clients should deny to access an agent with a socket name which does    *   not match its own configuration". */
name|request
operator|=
literal|"GETINFO socket_name\n"
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|strlen
argument_list|(
name|request
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"D"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|=
operator|&
name|buffer
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|ep
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|socket_name
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The agent will terminate its response with "OK". */
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"OK"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
name|new_sd
operator|=
name|sd
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implementation of svn_auth__password_get_t that retrieves the password    from gpg-agent */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|password_get_gpg_agent
parameter_list|(
name|svn_boolean_t
modifier|*
name|done
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|password
parameter_list|,
name|apr_hash_t
modifier|*
name|creds
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
name|apr_hash_t
modifier|*
name|parameters
parameter_list|,
name|svn_boolean_t
name|non_interactive
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|sd
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|request
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|cache_id
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|tty_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|tty_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|lc_ctype
decl_stmt|;
specifier|const
name|char
modifier|*
name|display
decl_stmt|;
name|svn_checksum_t
modifier|*
name|digest
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|password_prompt
decl_stmt|;
name|char
modifier|*
name|realm_prompt
decl_stmt|;
operator|*
name|done
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_running_gpg_agent
argument_list|(
operator|&
name|sd
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
operator|-
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|/* Send TTY_NAME to the gpg-agent daemon. */
name|tty_name
operator|=
name|getenv
argument_list|(
literal|"GPG_TTY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|send_option
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|,
literal|"ttyname"
argument_list|,
name|tty_name
argument_list|,
name|pool
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Send TTY_TYPE to the gpg-agent daemon. */
name|tty_type
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_type
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|send_option
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|,
literal|"ttytype"
argument_list|,
name|tty_type
argument_list|,
name|pool
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Compute LC_CTYPE. */
name|lc_ctype
operator|=
name|getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc_ctype
operator|==
name|NULL
condition|)
name|lc_ctype
operator|=
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc_ctype
operator|==
name|NULL
condition|)
name|lc_ctype
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
comment|/* Send LC_CTYPE to the gpg-agent daemon. */
if|if
condition|(
name|lc_ctype
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|send_option
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|,
literal|"lc-ctype"
argument_list|,
name|lc_ctype
argument_list|,
name|pool
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Send DISPLAY to the gpg-agent daemon. */
name|display
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|display
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|send_option
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|,
literal|"display"
argument_list|,
name|display
argument_list|,
name|pool
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Create the CACHE_ID which will be generated based on REALMSTRING similar      to other password caching mechanisms. */
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|digest
argument_list|,
name|svn_checksum_md5
argument_list|,
name|realmstring
argument_list|,
name|strlen
argument_list|(
name|realmstring
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|cache_id
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|digest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|password_prompt
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Password for '%s': "
argument_list|)
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|realm_prompt
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Enter your Subversion password for %s"
argument_list|)
argument_list|,
name|realmstring
argument_list|)
expr_stmt|;
name|request
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"GET_PASSPHRASE --data %s--repeat=1 "
literal|"%s X %s %s\n"
argument_list|,
name|non_interactive
condition|?
literal|"--no-ask "
else|:
literal|""
argument_list|,
name|cache_id
argument_list|,
name|escape_blanks
argument_list|(
name|password_prompt
argument_list|)
argument_list|,
name|escape_blanks
argument_list|(
name|realm_prompt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|strlen
argument_list|(
name|request
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|receive_from_gpg_agent
argument_list|(
name|sd
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"ERR"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"D"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|=
operator|&
name|buffer
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|ep
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|password
operator|=
name|p
expr_stmt|;
operator|*
name|done
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implementation of svn_auth__password_set_t that would store the    password in GPG Agent if that's how this particular integration    worked.  But it isn't.  GPG Agent stores the password provided by    the user via the pinentry program immediately upon its provision    (and regardless of its accuracy as passwords go), so we just need    to check if a running GPG Agent exists. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|password_set_gpg_agent
parameter_list|(
name|svn_boolean_t
modifier|*
name|done
parameter_list|,
name|apr_hash_t
modifier|*
name|creds
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|,
name|apr_hash_t
modifier|*
name|parameters
parameter_list|,
name|svn_boolean_t
name|non_interactive
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|sd
decl_stmt|;
operator|*
name|done
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_running_gpg_agent
argument_list|(
operator|&
name|sd
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
operator|-
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
operator|*
name|done
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An implementation of svn_auth_provider_t::first_credentials() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|simple_gpg_agent_first_creds
parameter_list|(
name|void
modifier|*
modifier|*
name|credentials
parameter_list|,
name|void
modifier|*
modifier|*
name|iter_baton
parameter_list|,
name|void
modifier|*
name|provider_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|parameters
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_auth__simple_creds_cache_get
argument_list|(
name|credentials
argument_list|,
name|iter_baton
argument_list|,
name|provider_baton
argument_list|,
name|parameters
argument_list|,
name|realmstring
argument_list|,
name|password_get_gpg_agent
argument_list|,
name|SVN_AUTH__GPG_AGENT_PASSWORD_TYPE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An implementation of svn_auth_provider_t::save_credentials() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|simple_gpg_agent_save_creds
parameter_list|(
name|svn_boolean_t
modifier|*
name|saved
parameter_list|,
name|void
modifier|*
name|credentials
parameter_list|,
name|void
modifier|*
name|provider_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|parameters
parameter_list|,
specifier|const
name|char
modifier|*
name|realmstring
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_auth__simple_creds_cache_set
argument_list|(
name|saved
argument_list|,
name|credentials
argument_list|,
name|provider_baton
argument_list|,
name|parameters
argument_list|,
name|realmstring
argument_list|,
name|password_set_gpg_agent
argument_list|,
name|SVN_AUTH__GPG_AGENT_PASSWORD_TYPE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_auth_provider_t
name|gpg_agent_simple_provider
init|=
block|{
name|SVN_AUTH_CRED_SIMPLE
block|,
name|simple_gpg_agent_first_creds
block|,
name|NULL
block|,
name|simple_gpg_agent_save_creds
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Public API */
end_comment

begin_function
name|void
name|svn_auth_get_gpg_agent_simple_provider
parameter_list|(
name|svn_auth_provider_object_t
modifier|*
modifier|*
name|provider
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_auth_provider_object_t
modifier|*
name|po
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|po
argument_list|)
argument_list|)
decl_stmt|;
name|po
operator|->
name|vtable
operator|=
operator|&
name|gpg_agent_simple_provider
expr_stmt|;
operator|*
name|provider
operator|=
name|po
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_HAVE_GPG_AGENT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !WIN32 */
end_comment

end_unit

