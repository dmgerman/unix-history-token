begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* error.c:  common exception handling for Subversion  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_ERR__TRACING
end_ifndef

begin_define
define|#
directive|define
name|SVN_ERR__TRACING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_DEBUG
end_ifdef

begin_comment
comment|/* XXX FIXME: These should be protected by a thread mutex.    svn_error__locate and make_error_internal should cooperate    in locking and unlocking it. */
end_comment

begin_comment
comment|/* XXX TODO: Define mutex here #if APR_HAS_THREADS */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|volatile
name|error_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
specifier|volatile
name|error_line
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file_line for the non-debug case. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|SVN_FILE_LINE_UNDEFINED
index|[]
init|=
literal|"svn:<undefined>"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_DEBUG */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_error_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * Undefine the helpers for creating errors.  *  * *NOTE*: Any use of these functions in any other function may need  * to call svn_error__locate() because the macro that would otherwise  * do this is being undefined and the filename and line number will  * not be properly set in the static error_file and error_line  * variables.  */
end_comment

begin_undef
undef|#
directive|undef
name|svn_error_create
end_undef

begin_undef
undef|#
directive|undef
name|svn_error_createf
end_undef

begin_undef
undef|#
directive|undef
name|svn_error_quick_wrap
end_undef

begin_undef
undef|#
directive|undef
name|svn_error_wrap_apr
end_undef

begin_comment
comment|/* Note: Although this is a "__" function, it was historically in the  * public ABI, so we can never change it or remove its signature, even  * though it is now only used in SVN_DEBUG mode. */
end_comment

begin_function
name|void
name|svn_error__locate
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|long
name|line
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
comment|/* XXX TODO: Lock mutex here */
name|error_file
operator|=
name|file
expr_stmt|;
name|error_line
operator|=
name|line
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Cleanup function for errors.  svn_error_clear () removes this so    errors that are properly handled *don't* hit this code. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
end_if

begin_function
specifier|static
name|apr_status_t
name|err_abort
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|data
decl_stmt|;
comment|/* For easy viewing in a debugger */
name|err
operator|=
name|err
expr_stmt|;
comment|/* Fake a use for the variable to avoid compiler warnings */
if|if
condition|(
operator|!
name|getenv
argument_list|(
literal|"SVN_DBG_NO_ABORT_ON_ERROR_LEAK"
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_error_internal
parameter_list|(
name|apr_status_t
name|apr_err
parameter_list|,
name|svn_error_t
modifier|*
name|child
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_error_t
modifier|*
name|new_error
decl_stmt|;
comment|/* Reuse the child's pool, or create our own. */
if|if
condition|(
name|child
condition|)
name|pool
operator|=
name|child
operator|->
name|pool
expr_stmt|;
else|else
block|{
if|if
condition|(
name|apr_pool_create
argument_list|(
operator|&
name|pool
argument_list|,
name|NULL
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Create the new error structure */
name|new_error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_error
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill 'er up. */
name|new_error
operator|->
name|apr_err
operator|=
name|apr_err
expr_stmt|;
name|new_error
operator|->
name|child
operator|=
name|child
expr_stmt|;
name|new_error
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
name|new_error
operator|->
name|file
operator|=
name|error_file
expr_stmt|;
name|new_error
operator|->
name|line
operator|=
name|error_line
expr_stmt|;
comment|/* XXX TODO: Unlock mutex here */
if|if
condition|(
operator|!
name|child
condition|)
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|new_error
argument_list|,
name|err_abort
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|new_error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Creating and destroying errors. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_error_create
parameter_list|(
name|apr_status_t
name|apr_err
parameter_list|,
name|svn_error_t
modifier|*
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|make_error_internal
argument_list|(
name|apr_err
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|err
operator|->
name|message
operator|=
name|apr_pstrdup
argument_list|(
name|err
operator|->
name|pool
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_error_createf
parameter_list|(
name|apr_status_t
name|apr_err
parameter_list|,
name|svn_error_t
modifier|*
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|err
operator|=
name|make_error_internal
argument_list|(
name|apr_err
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|err
operator|->
name|message
operator|=
name|apr_pvsprintf
argument_list|(
name|err
operator|->
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_error_wrap_apr
parameter_list|(
name|apr_status_t
name|status
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|utf8_err
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
name|errbuf
index|[
literal|255
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg_apr
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|err
operator|=
name|make_error_internal
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
condition|)
block|{
comment|/* Grab the APR error message. */
name|apr_strerror
argument_list|(
name|status
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
name|utf8_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|msg_apr
argument_list|,
name|errbuf
argument_list|,
name|err
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|utf8_err
condition|)
name|msg_apr
operator|=
name|NULL
expr_stmt|;
name|svn_error_clear
argument_list|(
name|utf8_err
argument_list|)
expr_stmt|;
comment|/* Append it to the formatted message. */
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|msg
operator|=
name|apr_pvsprintf
argument_list|(
name|err
operator|->
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_apr
condition|)
block|{
name|err
operator|->
name|message
operator|=
name|apr_pstrcat
argument_list|(
name|err
operator|->
name|pool
argument_list|,
name|msg
argument_list|,
literal|": "
argument_list|,
name|msg_apr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|->
name|message
operator|=
name|msg
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_error_quick_wrap
parameter_list|(
name|svn_error_t
modifier|*
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|new_msg
parameter_list|)
block|{
if|if
condition|(
name|child
operator|==
name|SVN_NO_ERROR
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_create
argument_list|(
name|child
operator|->
name|apr_err
argument_list|,
name|child
argument_list|,
name|new_msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Messages in tracing errors all point to this static string. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|error_tracing_link
index|[]
init|=
literal|"traced call"
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_error__trace
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|long
name|line
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SVN_DEBUG
comment|/* We shouldn't even be here, but whatever. Just return the error as-is.  */
return|return
name|err
return|;
else|#
directive|else
comment|/* Only do the work when an error occurs.  */
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_t
modifier|*
name|trace
decl_stmt|;
name|svn_error__locate
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|trace
operator|=
name|make_error_internal
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|trace
operator|->
name|message
operator|=
name|error_tracing_link
expr_stmt|;
return|return
name|trace
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_error_compose_create
parameter_list|(
name|svn_error_t
modifier|*
name|err1
parameter_list|,
name|svn_error_t
modifier|*
name|err2
parameter_list|)
block|{
if|if
condition|(
name|err1
operator|&&
name|err2
condition|)
block|{
name|svn_error_compose
argument_list|(
name|err1
argument_list|,
name|svn_error_quick_wrap
argument_list|(
name|err2
argument_list|,
name|_
argument_list|(
literal|"Additional errors:"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err1
return|;
block|}
return|return
name|err1
condition|?
name|err1
else|:
name|err2
return|;
block|}
end_function

begin_function
name|void
name|svn_error_compose
parameter_list|(
name|svn_error_t
modifier|*
name|chain
parameter_list|,
name|svn_error_t
modifier|*
name|new_err
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|chain
operator|->
name|pool
decl_stmt|;
name|apr_pool_t
modifier|*
name|oldpool
init|=
name|new_err
operator|->
name|pool
decl_stmt|;
while|while
condition|(
name|chain
operator|->
name|child
condition|)
name|chain
operator|=
name|chain
operator|->
name|child
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
comment|/* Kill existing handler since the end of the chain is going to change */
name|apr_pool_cleanup_kill
argument_list|(
name|pool
argument_list|,
name|chain
argument_list|,
name|err_abort
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Copy the new error chain into the old chain's pool. */
while|while
condition|(
name|new_err
condition|)
block|{
name|chain
operator|->
name|child
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chain
operator|->
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|child
expr_stmt|;
operator|*
name|chain
operator|=
operator|*
name|new_err
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|message
condition|)
name|chain
operator|->
name|message
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|new_err
operator|->
name|message
argument_list|)
expr_stmt|;
name|chain
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
if|if
condition|(
operator|!
name|new_err
operator|->
name|child
condition|)
name|apr_pool_cleanup_kill
argument_list|(
name|oldpool
argument_list|,
name|new_err
argument_list|,
name|err_abort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|new_err
operator|=
name|new_err
operator|->
name|child
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|chain
argument_list|,
name|err_abort
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Destroy the new error chain. */
name|svn_pool_destroy
argument_list|(
name|oldpool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_error_root_cause
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
while|while
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|child
condition|)
name|err
operator|=
name|err
operator|->
name|child
expr_stmt|;
else|else
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_error_find_cause
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|apr_status_t
name|apr_err
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|child
decl_stmt|;
for|for
control|(
name|child
operator|=
name|err
init|;
name|child
condition|;
name|child
operator|=
name|child
operator|->
name|child
control|)
if|if
condition|(
name|child
operator|->
name|apr_err
operator|==
name|apr_err
condition|)
return|return
name|child
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_error_dup
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_error_t
modifier|*
name|new_err
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp_err
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|apr_pool_create
argument_list|(
operator|&
name|pool
argument_list|,
name|NULL
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|err
condition|;
name|err
operator|=
name|err
operator|->
name|child
control|)
block|{
if|if
condition|(
operator|!
name|new_err
condition|)
block|{
name|new_err
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_err
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_err
operator|=
name|new_err
expr_stmt|;
block|}
else|else
block|{
name|tmp_err
operator|->
name|child
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp_err
operator|->
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_err
operator|=
name|tmp_err
operator|->
name|child
expr_stmt|;
block|}
operator|*
name|tmp_err
operator|=
operator|*
name|err
expr_stmt|;
name|tmp_err
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
if|if
condition|(
name|tmp_err
operator|->
name|message
condition|)
name|tmp_err
operator|->
name|message
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|tmp_err
operator|->
name|message
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|tmp_err
argument_list|,
name|err_abort
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|new_err
return|;
block|}
end_function

begin_function
name|void
name|svn_error_clear
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
name|err
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SVN_DEBUG
argument_list|)
while|while
condition|(
name|err
operator|->
name|child
condition|)
name|err
operator|=
name|err
operator|->
name|child
expr_stmt|;
name|apr_pool_cleanup_kill
argument_list|(
name|err
operator|->
name|pool
argument_list|,
name|err
argument_list|,
name|err_abort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|svn_pool_destroy
argument_list|(
name|err
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_error__is_tracing_link
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_ERR__TRACING
comment|/* ### A strcmp()?  Really?  I think it's the best we can do unless      ### we add a boolean field to svn_error_t that's set only for      ### these "placeholder error chain" items.  Not such a bad idea,      ### really...  */
return|return
operator|(
name|err
operator|&&
name|err
operator|->
name|message
operator|&&
operator|!
name|strcmp
argument_list|(
name|err
operator|->
name|message
argument_list|,
name|error_tracing_link
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_error_purge_tracing
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_ERR__TRACING
name|svn_error_t
modifier|*
name|new_err
init|=
name|NULL
decl_stmt|,
modifier|*
name|new_err_leaf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|SVN_NO_ERROR
return|;
do|do
block|{
name|svn_error_t
modifier|*
name|tmp_err
decl_stmt|;
comment|/* Skip over any trace-only links. */
while|while
condition|(
name|err
operator|&&
name|svn_error__is_tracing_link
argument_list|(
name|err
argument_list|)
condition|)
name|err
operator|=
name|err
operator|->
name|child
expr_stmt|;
comment|/* The link must be a real link in the error chain, otherwise an          error chain with trace only links would map into SVN_NO_ERROR. */
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ASSERTION_ONLY_TRACING_LINKS
argument_list|,
name|svn_error_compose_create
argument_list|(
name|svn_error__malfunction
argument_list|(
name|TRUE
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|NULL
comment|/* ### say something? */
argument_list|)
argument_list|,
name|err
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Copy the current error except for its child error pointer          into the new error.  Share any message and source filename          strings from the error. */
name|tmp_err
operator|=
name|apr_palloc
argument_list|(
name|err
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp_err
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tmp_err
operator|=
operator|*
name|err
expr_stmt|;
name|tmp_err
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
comment|/* Add a new link to the new chain (creating the chain if necessary). */
if|if
condition|(
operator|!
name|new_err
condition|)
block|{
name|new_err
operator|=
name|tmp_err
expr_stmt|;
name|new_err_leaf
operator|=
name|tmp_err
expr_stmt|;
block|}
else|else
block|{
name|new_err_leaf
operator|->
name|child
operator|=
name|tmp_err
expr_stmt|;
name|new_err_leaf
operator|=
name|tmp_err
expr_stmt|;
block|}
comment|/* Advance to the next link in the original chain. */
name|err
operator|=
name|err
operator|->
name|child
expr_stmt|;
block|}
do|while
condition|(
name|err
condition|)
do|;
return|return
name|new_err
return|;
else|#
directive|else
comment|/* SVN_ERR__TRACING */
return|return
name|err
return|;
endif|#
directive|endif
comment|/* SVN_ERR__TRACING */
block|}
end_function

begin_comment
comment|/* ### The logic around omitting (sic) apr_err= in maintainer mode is tightly    ### coupled to the current sole caller.*/
end_comment

begin_function
specifier|static
name|void
name|print_error
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|err_string
decl_stmt|;
name|svn_error_t
modifier|*
name|temp_err
init|=
name|NULL
decl_stmt|;
comment|/* ensure initialized even if                                     err->file == NULL */
comment|/* Pretty-print the error */
comment|/* Note: we can also log errors here someday. */
ifdef|#
directive|ifdef
name|SVN_DEBUG
comment|/* Note: err->file is _not_ in UTF-8, because it's expanded from            the __FILE__ preprocessor macro. */
specifier|const
name|char
modifier|*
name|file_utf8
decl_stmt|;
if|if
condition|(
name|err
operator|->
name|file
operator|&&
operator|!
operator|(
name|temp_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|file_utf8
argument_list|,
name|err
operator|->
name|file
argument_list|,
name|err
operator|->
name|pool
argument_list|)
operator|)
condition|)
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|err
operator|->
name|pool
argument_list|,
literal|"%s:%ld"
argument_list|,
name|err
operator|->
name|file
argument_list|,
name|err
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|SVN_FILE_LINE_UNDEFINED
argument_list|,
name|stream
argument_list|,
name|err
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|temp_err
argument_list|)
expr_stmt|;
block|}
block|{
specifier|const
name|char
modifier|*
name|symbolic_name
decl_stmt|;
if|if
condition|(
name|svn_error__is_tracing_link
argument_list|(
name|err
argument_list|)
condition|)
comment|/* Skip it; the error code will be printed by the real link. */
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|err
operator|->
name|pool
argument_list|,
literal|",\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|symbolic_name
operator|=
name|svn_error_symbolic_name
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|err
operator|->
name|pool
argument_list|,
literal|": (apr_err=%s)\n"
argument_list|,
name|symbolic_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|err
operator|->
name|pool
argument_list|,
literal|": (apr_err=%d)\n"
argument_list|,
name|err
operator|->
name|apr_err
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SVN_DEBUG */
comment|/* "traced call" */
if|if
condition|(
name|svn_error__is_tracing_link
argument_list|(
name|err
argument_list|)
condition|)
block|{
comment|/* Skip it.  We already printed the file-line coordinates. */
block|}
comment|/* Only print the same APR error string once. */
elseif|else
if|if
condition|(
name|err
operator|->
name|message
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|err
operator|->
name|pool
argument_list|,
literal|"%sE%06d: %s\n"
argument_list|,
name|prefix
argument_list|,
name|err
operator|->
name|apr_err
argument_list|,
name|err
operator|->
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Is this a Subversion-specific error code? */
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|>
name|APR_OS_START_USEERR
operator|)
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|<=
name|APR_OS_START_CANONERR
operator|)
condition|)
name|err_string
operator|=
name|svn_strerror
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Otherwise, this must be an APR error code. */
elseif|else
if|if
condition|(
operator|(
name|temp_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|err_string
argument_list|,
name|apr_strerror
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|)
argument_list|,
name|err
operator|->
name|pool
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|temp_err
argument_list|)
expr_stmt|;
name|err_string
operator|=
name|_
argument_list|(
literal|"Can't recode error string from APR"
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|err
operator|->
name|pool
argument_list|,
literal|"%sE%06d: %s\n"
argument_list|,
name|prefix
argument_list|,
name|err
operator|->
name|apr_err
argument_list|,
name|err_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|svn_handle_error
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|svn_boolean_t
name|fatal
parameter_list|)
block|{
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stream
argument_list|,
name|fatal
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_handle_error2
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|svn_boolean_t
name|fatal
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
comment|/* In a long error chain, there may be multiple errors with the same      error code and no custom message.  We only want to print the      default message for that code once; printing it multiple times      would add no useful information.  The 'empties' array below      remembers the codes of empty errors already seen in the chain.       We could allocate it in err->pool, but there's no telling how      long err will live or how many times it will get handled.  So we      use a subpool. */
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|apr_array_header_t
modifier|*
name|empties
decl_stmt|;
name|svn_error_t
modifier|*
name|tmp_err
decl_stmt|;
comment|/* ### The rest of this file carefully avoids using svn_pool_*(),      preferring apr_pool_*() instead.  I can't remember why -- it may      be an artifact of r843793, or it may be for some deeper reason --      but I'm playing it safe and using apr_pool_*() here too. */
name|apr_pool_create
argument_list|(
operator|&
name|subpool
argument_list|,
name|err
operator|->
name|pool
argument_list|)
expr_stmt|;
name|empties
operator|=
name|apr_array_make
argument_list|(
name|subpool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_status_t
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_err
operator|=
name|err
expr_stmt|;
while|while
condition|(
name|tmp_err
condition|)
block|{
name|svn_boolean_t
name|printed_already
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|tmp_err
operator|->
name|message
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|empties
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tmp_err
operator|->
name|apr_err
operator|==
name|APR_ARRAY_IDX
argument_list|(
name|empties
argument_list|,
name|i
argument_list|,
name|apr_status_t
argument_list|)
condition|)
block|{
name|printed_already
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|printed_already
condition|)
block|{
name|print_error
argument_list|(
name|tmp_err
argument_list|,
name|stream
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_err
operator|->
name|message
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|empties
argument_list|,
name|apr_status_t
argument_list|)
operator|=
name|tmp_err
operator|->
name|apr_err
expr_stmt|;
block|}
block|}
name|tmp_err
operator|=
name|tmp_err
operator|->
name|child
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
block|{
comment|/* Avoid abort()s in maintainer mode. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We exit(1) here instead of abort()ing so that atexit handlers          get called. */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|svn_handle_warning
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
name|svn_handle_warning2
argument_list|(
name|stream
argument_list|,
name|err
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_handle_warning2
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|err
operator|->
name|pool
argument_list|,
name|_
argument_list|(
literal|"%swarning: W%06d: %s\n"
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|err
operator|->
name|apr_err
argument_list|,
name|svn_err_best_message
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_err_best_message
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|)
block|{
comment|/* Skip over any trace records.  */
while|while
condition|(
name|svn_error__is_tracing_link
argument_list|(
name|err
argument_list|)
condition|)
name|err
operator|=
name|err
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|err
operator|->
name|message
condition|)
return|return
name|err
operator|->
name|message
return|;
else|else
return|return
name|svn_strerror
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* svn_strerror() and helpers */
end_comment

begin_comment
comment|/* Duplicate of the same typedef in tests/libsvn_subr/error-code-test.c */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|err_defn
block|{
name|svn_errno_t
name|errcode
decl_stmt|;
comment|/* 160004 */
specifier|const
name|char
modifier|*
name|errname
decl_stmt|;
comment|/* SVN_ERR_FS_CORRUPT */
specifier|const
name|char
modifier|*
name|errdesc
decl_stmt|;
comment|/* default message */
block|}
name|err_defn
typedef|;
end_typedef

begin_comment
comment|/* To understand what is going on here, read svn_error_codes.h. */
end_comment

begin_define
define|#
directive|define
name|SVN_ERROR_BUILD_ARRAY
end_define

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_function
name|char
modifier|*
name|svn_strerror
parameter_list|(
name|apr_status_t
name|statcode
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|)
block|{
specifier|const
name|err_defn
modifier|*
name|defn
decl_stmt|;
for|for
control|(
name|defn
operator|=
name|error_table
init|;
name|defn
operator|->
name|errdesc
operator|!=
name|NULL
condition|;
operator|++
name|defn
control|)
if|if
condition|(
name|defn
operator|->
name|errcode
operator|==
operator|(
name|svn_errno_t
operator|)
name|statcode
condition|)
block|{
name|apr_cpystrn
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
name|defn
operator|->
name|errdesc
argument_list|)
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|apr_strerror
argument_list|(
name|statcode
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_error_symbolic_name
parameter_list|(
name|apr_status_t
name|statcode
parameter_list|)
block|{
specifier|const
name|err_defn
modifier|*
name|defn
decl_stmt|;
for|for
control|(
name|defn
operator|=
name|error_table
init|;
name|defn
operator|->
name|errdesc
operator|!=
name|NULL
condition|;
operator|++
name|defn
control|)
if|if
condition|(
name|defn
operator|->
name|errcode
operator|==
operator|(
name|svn_errno_t
operator|)
name|statcode
condition|)
return|return
name|defn
operator|->
name|errname
return|;
comment|/* "No error" is not in error_table. */
if|if
condition|(
name|statcode
operator|==
name|SVN_NO_ERROR
condition|)
return|return
literal|"SVN_NO_ERROR"
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Malfunctions. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_error_raise_on_malfunction
parameter_list|(
name|svn_boolean_t
name|can_return
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|can_return
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Nothing else we can do as a library */
comment|/* The filename and line number of the error source needs to be set      here because svn_error_createf() is not the macro defined in      svn_error.h but the real function. */
name|svn_error__locate
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ASSERTION_FAIL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"In file '%s' line %d: assertion failed (%s)"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|expr
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ASSERTION_FAIL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"In file '%s' line %d: internal malfunction"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_error_abort_on_malfunction
parameter_list|(
name|svn_boolean_t
name|can_return
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|expr
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_raise_on_malfunction
argument_list|(
name|TRUE
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|expr
argument_list|)
decl_stmt|;
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|err
return|;
comment|/* Not reached. */
block|}
end_function

begin_comment
comment|/* The current handler for reporting malfunctions, and its default setting. */
end_comment

begin_decl_stmt
specifier|static
name|svn_error_malfunction_handler_t
name|malfunction_handler
init|=
name|svn_error_abort_on_malfunction
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_malfunction_handler_t
name|svn_error_set_malfunction_handler
parameter_list|(
name|svn_error_malfunction_handler_t
name|func
parameter_list|)
block|{
name|svn_error_malfunction_handler_t
name|old_malfunction_handler
init|=
name|malfunction_handler
decl_stmt|;
name|malfunction_handler
operator|=
name|func
expr_stmt|;
return|return
name|old_malfunction_handler
return|;
block|}
end_function

begin_comment
comment|/* Note: Although this is a "__" function, it is in the public ABI, so  * we can never remove it or change its signature. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_error__malfunction
parameter_list|(
name|svn_boolean_t
name|can_return
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|expr
parameter_list|)
block|{
return|return
name|malfunction_handler
argument_list|(
name|can_return
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Misc. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_error__wrap_zlib
parameter_list|(
name|int
name|zerr
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmsg
decl_stmt|;
if|if
condition|(
name|zerr
operator|==
name|Z_OK
condition|)
return|return
name|SVN_NO_ERROR
return|;
switch|switch
condition|(
name|zerr
condition|)
block|{
case|case
name|Z_STREAM_ERROR
case|:
name|status
operator|=
name|SVN_ERR_STREAM_MALFORMED_DATA
expr_stmt|;
name|zmsg
operator|=
name|_
argument_list|(
literal|"stream error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|status
operator|=
name|APR_ENOMEM
expr_stmt|;
name|zmsg
operator|=
name|_
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_BUF_ERROR
case|:
name|status
operator|=
name|APR_ENOMEM
expr_stmt|;
name|zmsg
operator|=
name|_
argument_list|(
literal|"buffer error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_VERSION_ERROR
case|:
name|status
operator|=
name|SVN_ERR_STREAM_UNRECOGNIZED_DATA
expr_stmt|;
name|zmsg
operator|=
name|_
argument_list|(
literal|"version error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_DATA_ERROR
case|:
name|status
operator|=
name|SVN_ERR_STREAM_MALFORMED_DATA
expr_stmt|;
name|zmsg
operator|=
name|_
argument_list|(
literal|"corrupt data"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|SVN_ERR_STREAM_UNRECOGNIZED_DATA
expr_stmt|;
name|zmsg
operator|=
name|_
argument_list|(
literal|"unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|,
literal|"zlib (%s): %s: %s"
argument_list|,
name|function
argument_list|,
name|zmsg
argument_list|,
name|message
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|,
literal|"zlib (%s): %s"
argument_list|,
name|function
argument_list|,
name|zmsg
argument_list|)
return|;
block|}
end_function

end_unit

