begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * editor.c:  Editor for modifying FS transactions  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_editor.h"
end_include

begin_struct
struct|struct
name|edit_baton
block|{
comment|/* The transaction associated with this editor.  */
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
comment|/* Has this editor been completed?  */
name|svn_boolean_t
name|completed
decl_stmt|;
comment|/* We sometimes need the cancellation beyond what svn_editor_t provides  */
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
comment|/* The pool that the txn lives within. When we create a ROOT, it will      be allocated within a subpool of this. The root will be closed in      complete/abort and that subpool will be destroyed.       This pool SHOULD NOT be used for any allocations.  */
name|apr_pool_t
modifier|*
name|txn_pool
decl_stmt|;
comment|/* This is the root from the txn. Use get_root() to fetch/create this      member as appropriate.  */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FSPATH
parameter_list|(
name|relpath
parameter_list|,
name|pool
parameter_list|)
value|apr_pstrcat(pool, "/", relpath, NULL)
end_define

begin_define
define|#
directive|define
name|UNUSED
parameter_list|(
name|x
parameter_list|)
value|((void)(x))
end_define

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|)
block|{
if|if
condition|(
name|eb
operator|->
name|root
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_txn_root
argument_list|(
operator|&
name|eb
operator|->
name|root
argument_list|,
name|eb
operator|->
name|txn
argument_list|,
name|eb
operator|->
name|txn_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root
operator|=
name|eb
operator|->
name|root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Apply each property in PROPS to the node at FSPATH in ROOT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_new_props
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* ### it would be nice to have svn_fs_set_node_props(). but since we      ### don't... add each property to the node. this is a new node, so      ### we don't need to worry about deleting props. just adding.  */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_change_node_prop
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_props
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|propdiffs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|old_props
argument_list|,
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|propdiffs
argument_list|,
name|props
argument_list|,
name|old_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|propdiffs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|propdiffs
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Add, change, or delete properties.  */
name|SVN_ERR
argument_list|(
name|svn_fs_change_node_prop
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_text
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|svn_stream_t
modifier|*
name|contents
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|fs_contents
decl_stmt|;
comment|/* ### We probably don't have an MD5 checksum, so no digest is available      ### for svn_fs_apply_text() to validate. It would be nice to have an      ### FS API that takes our CHECKSUM/CONTENTS pair (and PROPS!).  */
name|SVN_ERR
argument_list|(
name|svn_fs_apply_text
argument_list|(
operator|&
name|fs_contents
argument_list|,
name|root
argument_list|,
name|fspath
argument_list|,
name|NULL
comment|/* result_checksum */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|fs_contents
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The caller wants to modify REVISION of FSPATH. Is that allowed?  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|can_modify
parameter_list|(
name|svn_fs_root_t
modifier|*
name|txn_root
parameter_list|,
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_revnum_t
name|created_rev
decl_stmt|;
comment|/* Out-of-dateness check:  compare the created-rev of the node      in the txn against the created-rev of FSPATH.  */
name|SVN_ERR
argument_list|(
name|svn_fs_node_created_rev
argument_list|(
operator|&
name|created_rev
argument_list|,
name|txn_root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Uncommitted nodes (eg. a descendent of a copy/move/rotate destination)      have no (committed) revision number. Let the caller go ahead and      modify these nodes.       Note: strictly speaking, they might be performing an "illegal" edit      in certain cases, but let's just assume they're Good Little Boys.       If CREATED_REV is invalid, that means it's already mutable in the      txn, which means it has already passed this out-of-dateness check.      (Usually, this happens when looking at a parent directory of an      already-modified node)  */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|created_rev
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the node is immutable (has a revision), then the caller should      have supplied a valid revision number [that they expect to change].      The checks further below will determine the out-of-dateness of the      specified revision.  */
comment|/* ### ugh. descendents of copy/move/rotate destinations carry along      ### their original immutable state and (thus) a valid CREATED_REV.      ### but they are logically uncommitted, so the caller will pass      ### SVN_INVALID_REVNUM. (technically, the caller could provide      ### ORIGINAL_REV, but that is semantically incorrect for the Ev2      ### API).      ###      ### for now, we will assume the caller knows what they are doing      ### and an invalid revision implies such a descendent. in the      ### future, we could examine the ancestor chain looking for a      ### copy/move/rotate-here node and allow the modification (and the      ### converse: if no such ancestor, the caller must specify the      ### correct/intended revision to modify).   */
if|#
directive|if
literal|1
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
comment|/* ### use a custom error code?  */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision for modifying '%s' is required"
argument_list|)
argument_list|,
name|fspath
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|revision
operator|<
name|created_rev
condition|)
block|{
comment|/* We asked to change a node that is *older* than what we found          in the transaction. The client is out of date.  */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is out of date; try updating"
argument_list|)
argument_list|,
name|fspath
argument_list|)
return|;
block|}
if|if
condition|(
name|revision
operator|>
name|created_rev
condition|)
block|{
comment|/* We asked to change a node that is *newer* than what we found          in the transaction. Given that the transaction was based off          of 'youngest', then either:          - the caller asked to modify a future node          - the caller has committed more revisions since this txn          was constructed, and is asking to modify a node in one          of those new revisions.          In either case, the node may not have changed in those new          revisions; use the node's ID to determine this case.  */
specifier|const
name|svn_fs_id_t
modifier|*
name|txn_noderev_id
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|rev_root
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|new_noderev_id
decl_stmt|;
comment|/* The ID of the node that we would be modifying in the txn  */
name|SVN_ERR
argument_list|(
name|svn_fs_node_id
argument_list|(
operator|&
name|txn_noderev_id
argument_list|,
name|txn_root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the ID from the future/new revision.  */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|rev_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|txn_root
argument_list|)
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_id
argument_list|(
operator|&
name|new_noderev_id
argument_list|,
name|rev_root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_close_root
argument_list|(
name|rev_root
argument_list|)
expr_stmt|;
comment|/* Has the target node changed in the future?  */
if|if
condition|(
name|svn_fs_compare_ids
argument_list|(
name|txn_noderev_id
argument_list|,
name|new_noderev_id
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Restarting the commit will base the txn on the future/new              revision, allowing the modification at REVISION.  */
comment|/* ### use a custom error code  */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' has been modified since the "
literal|"commit began (restart the commit)"
argument_list|)
argument_list|,
name|fspath
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Can we create a node at FSPATH in TXN_ROOT? If something already exists    at that path, then the client MAY be out of date. We then have to see if    the path was created/modified in this transaction. IOW, it is new and    can be replaced without problem.     Note: the editor protocol disallows double-modifications. This is to    ensure somebody does not accidentally overwrite another file due to    being out-of-date.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|can_create
parameter_list|(
name|svn_fs_root_t
modifier|*
name|txn_root
parameter_list|,
specifier|const
name|char
modifier|*
name|fspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|cur_fspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|txn_root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* ### I'm not sure if this works perfectly. We might have an ancestor      ### that was modified as a result of a change on a cousin. We might      ### misinterpret that as a *-here node which brought along this      ### child. Need to write a test to verify. We may also be able to      ### test the ancestor to determine if it has been *-here in this      ### txn, or just a simple modification.  */
comment|/* Are any of the parents copied/moved/rotated-here?  */
for|for
control|(
name|cur_fspath
operator|=
name|fspath
init|;
name|strlen
argument_list|(
name|cur_fspath
argument_list|)
operator|>
literal|1
condition|;
comment|/* not the root  */
name|cur_fspath
operator|=
name|svn_fspath__dirname
argument_list|(
name|cur_fspath
argument_list|,
name|scratch_pool
argument_list|)
control|)
block|{
name|svn_revnum_t
name|created_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_created_rev
argument_list|(
operator|&
name|created_rev
argument_list|,
name|txn_root
argument_list|,
name|cur_fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|created_rev
argument_list|)
condition|)
block|{
comment|/* The node has no created revision, meaning it is uncommitted.              Thus, it was created in this transaction, or it has already              been modified in some way (implying it has already passed a              modification check.  */
comment|/* ### verify the node has been *-here ??  */
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' already exists, so may be out"
literal|" of date; try updating"
argument_list|)
argument_list|,
name|fspath
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_directory_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|children
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|fspath
init|=
name|FSPATH
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
comment|/* Note: we ignore CHILDREN. We have no "incomplete" state to worry about,      so we don't need to be aware of what children will be created.  */
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|eb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|replaces_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|can_modify
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|replaces_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_delete
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|can_create
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_make_dir
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_new_props
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_file_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|svn_stream_t
modifier|*
name|contents
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|fspath
init|=
name|FSPATH
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|eb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|replaces_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|can_modify
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|replaces_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_delete
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|can_create
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_make_file
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|set_text
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|checksum
argument_list|,
name|contents
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_new_props
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_symlink_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_symlink_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|fspath
init|=
name|FSPATH
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|eb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|replaces_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|can_modify
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|replaces_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_delete
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|can_create
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### we probably need to construct a file with specific contents      ### (until the FS grows some symlink APIs)  */
if|#
directive|if
literal|0
block|SVN_ERR(svn_fs_make_file(root, fspath, scratch_pool));   SVN_ERR(svn_fs_apply_text(&fs_contents, root, fspath,                             NULL
comment|/* result_checksum */
block|,                             scratch_pool));
comment|/* ### SVN_ERR(svn_stream_printf(fs_contents, ..., scratch_pool));  */
block|apr_hash_set(props, SVN_PROP_SPECIAL, APR_HASH_KEY_STRING,                SVN_PROP_SPECIAL_VALUE);    SVN_ERR(add_new_props(root, fspath, props, scratch_pool));
endif|#
directive|endif
name|SVN__NOT_IMPLEMENTED
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_absent_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_absent_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* This is a programming error. Code should not attempt to create these      kinds of nodes within the FS.  */
comment|/* ### use a custom error code  */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The filesystem does not support 'absent' nodes"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_alter_directory_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_directory_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|children
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|fspath
init|=
name|FSPATH
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
comment|/* Note: we ignore CHILDREN. We have no "incomplete" state to worry about,      so we don't need to be aware of what children will be created.  */
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|can_modify
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
condition|)
name|SVN_ERR
argument_list|(
name|alter_props
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_alter_file_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_file_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|svn_stream_t
modifier|*
name|contents
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|fspath
init|=
name|FSPATH
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|can_modify
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|checksum
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|set_text
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|checksum
argument_list|,
name|contents
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|alter_props
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_alter_symlink_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_symlink_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|UNUSED
argument_list|(
name|eb
argument_list|)
expr_stmt|;
name|SVN__NOT_IMPLEMENTED
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_delete_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|fspath
init|=
name|FSPATH
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|can_modify
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_delete
argument_list|(
name|root
argument_list|,
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_copy_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
name|svn_revnum_t
name|src_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_fspath
init|=
name|FSPATH
argument_list|(
name|src_relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_fspath
init|=
name|FSPATH
argument_list|(
name|dst_relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|src_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|eb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if we can we replace the maybe-specified destination (revision).  */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|replaces_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|can_modify
argument_list|(
name|root
argument_list|,
name|dst_fspath
argument_list|,
name|replaces_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_delete
argument_list|(
name|root
argument_list|,
name|dst_fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|can_create
argument_list|(
name|root
argument_list|,
name|dst_fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|src_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
argument_list|,
name|src_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_copy
argument_list|(
name|src_root
argument_list|,
name|src_fspath
argument_list|,
name|root
argument_list|,
name|dst_fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_close_root
argument_list|(
name|src_root
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_move_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|move_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
name|svn_revnum_t
name|src_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_fspath
init|=
name|FSPATH
argument_list|(
name|src_relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_fspath
init|=
name|FSPATH
argument_list|(
name|dst_relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|src_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|eb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if we delete the specified source (revision), and can we replace      the maybe-specified destination (revision).  */
name|SVN_ERR
argument_list|(
name|can_modify
argument_list|(
name|root
argument_list|,
name|src_fspath
argument_list|,
name|src_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|replaces_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|can_modify
argument_list|(
name|root
argument_list|,
name|dst_fspath
argument_list|,
name|replaces_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_delete
argument_list|(
name|root
argument_list|,
name|dst_fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|can_create
argument_list|(
name|root
argument_list|,
name|dst_fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### would be nice to have svn_fs_move()  */
comment|/* Copy the src to the dst. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|src_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
argument_list|,
name|src_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_copy
argument_list|(
name|src_root
argument_list|,
name|src_fspath
argument_list|,
name|root
argument_list|,
name|dst_fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_close_root
argument_list|(
name|src_root
argument_list|)
expr_stmt|;
comment|/* Notice: we're deleting the src repos path from the dst root. */
name|SVN_ERR
argument_list|(
name|svn_fs_delete
argument_list|(
name|root
argument_list|,
name|src_fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_rotate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rotate_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|relpaths
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revisions
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|UNUSED
argument_list|(
name|eb
argument_list|)
expr_stmt|;
name|SVN__NOT_IMPLEMENTED
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_complete_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|complete_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
comment|/* Watch out for a following call to svn_fs_editor_commit(). Note that      we are likely here because svn_fs_editor_commit() was called, and it      invoked svn_editor_complete().  */
name|eb
operator|->
name|completed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|root
operator|!=
name|NULL
condition|)
block|{
name|svn_fs_close_root
argument_list|(
name|eb
operator|->
name|root
argument_list|)
expr_stmt|;
name|eb
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_abort_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Don't allow a following call to svn_fs_editor_commit().  */
name|eb
operator|->
name|completed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|root
operator|!=
name|NULL
condition|)
block|{
name|svn_fs_close_root
argument_list|(
name|eb
operator|->
name|root
argument_list|)
expr_stmt|;
name|eb
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* ### should we examine the error and attempt svn_fs_purge_txn() ?  */
name|err
operator|=
name|svn_fs_abort_txn
argument_list|(
name|eb
operator|->
name|txn
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* For safety, clear the now-useless txn.  */
name|eb
operator|->
name|txn
operator|=
name|NULL
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_editor
parameter_list|(
name|svn_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_editor_cb_many_t
name|editor_cbs
init|=
block|{
name|add_directory_cb
block|,
name|add_file_cb
block|,
name|add_symlink_cb
block|,
name|add_absent_cb
block|,
name|alter_directory_cb
block|,
name|alter_file_cb
block|,
name|alter_symlink_cb
block|,
name|delete_cb
block|,
name|copy_cb
block|,
name|move_cb
block|,
name|rotate_cb
block|,
name|complete_cb
block|,
name|abort_cb
block|}
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
name|eb
operator|->
name|txn
operator|=
name|txn
expr_stmt|;
name|eb
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|eb
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|eb
operator|->
name|txn_pool
operator|=
name|result_pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_create
argument_list|(
name|editor
argument_list|,
name|eb
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_setcb_many
argument_list|(
operator|*
name|editor
argument_list|,
operator|&
name|editor_cbs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs__editor_create
parameter_list|(
name|svn_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|txn_name
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|revision
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_begin_txn2
argument_list|(
operator|&
name|txn
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|flags
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_txn_name
argument_list|(
name|txn_name
argument_list|,
name|txn
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|make_editor
argument_list|(
name|editor
argument_list|,
name|txn
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs__editor_create_for
parameter_list|(
name|svn_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_name
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_open_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|fs
argument_list|,
name|txn_name
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|make_editor
argument_list|(
name|editor
argument_list|,
name|txn
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs__editor_commit
parameter_list|(
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_error_t
modifier|*
modifier|*
name|post_commit_err
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|conflict_path
parameter_list|,
name|svn_editor_t
modifier|*
name|editor
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|svn_editor_get_baton
argument_list|(
name|editor
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|inner_conflict_path
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
comment|/* make sure people are using the correct sequencing.  */
if|if
condition|(
name|eb
operator|->
name|completed
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INCORRECT_EDITOR_COMPLETION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
operator|*
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
operator|*
name|post_commit_err
operator|=
name|NULL
expr_stmt|;
operator|*
name|conflict_path
operator|=
name|NULL
expr_stmt|;
comment|/* Clean up internal resources (eg. eb->root). This also allows the      editor infrastructure to know this editor is "complete".  */
name|err
operator|=
name|svn_editor_complete
argument_list|(
name|editor
argument_list|)
expr_stmt|;
comment|/* Note: docco for svn_fs_commit_txn() states that CONFLICT_PATH will      be allocated in the txn's pool. But it lies. Regardless, we want      it placed into RESULT_POOL.  */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_fs_commit_txn
argument_list|(
operator|&
name|inner_conflict_path
argument_list|,
name|revision
argument_list|,
name|eb
operator|->
name|txn
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|revision
argument_list|)
condition|)
block|{
if|if
condition|(
name|err
condition|)
block|{
comment|/* Case 3. ERR is a post-commit (cleanup) error.  */
comment|/* Pass responsibility via POST_COMMIT_ERR.  */
operator|*
name|post_commit_err
operator|=
name|err
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
comment|/* else: Case 1.  */
block|}
else|else
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|err
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CONFLICT
condition|)
block|{
comment|/* Case 2.  */
comment|/* Copy this into the correct pool (see note above).  */
operator|*
name|conflict_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|inner_conflict_path
argument_list|)
expr_stmt|;
comment|/* Return sucess. The caller should inspect CONFLICT_PATH to              determine this particular case.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
comment|/* else: Case 4.  */
comment|/* Abort the TXN. Nobody wants to use it.  */
comment|/* ### should we examine the error and attempt svn_fs_purge_txn() ?  */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_fs_abort_txn
argument_list|(
name|eb
operator|->
name|txn
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For safety, clear the now-useless txn.  */
name|eb
operator|->
name|txn
operator|=
name|NULL
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

end_unit

