begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* commit.c --- editor for committing changes to a filesystem.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_compat.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_editor.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Editor batons. ***/
end_comment

begin_struct
struct|struct
name|edit_baton
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/** Supplied when the editor is created: **/
comment|/* Revision properties to set for this commit. */
name|apr_hash_t
modifier|*
name|revprop_table
decl_stmt|;
comment|/* Callback to run when the commit is done. */
name|svn_commit_callback2_t
name|commit_callback
decl_stmt|;
name|void
modifier|*
name|commit_callback_baton
decl_stmt|;
comment|/* Callback to check authorizations on paths. */
name|svn_repos_authz_callback_t
name|authz_callback
decl_stmt|;
name|void
modifier|*
name|authz_baton
decl_stmt|;
comment|/* The already-open svn repository to commit to. */
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
comment|/* URL to the root of the open repository. */
specifier|const
name|char
modifier|*
name|repos_url
decl_stmt|;
comment|/* The name of the repository (here for convenience). */
specifier|const
name|char
modifier|*
name|repos_name
decl_stmt|;
comment|/* The filesystem associated with the REPOS above (here for      convenience). */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* Location in fs where the edit will begin. */
specifier|const
name|char
modifier|*
name|base_path
decl_stmt|;
comment|/* Does this set of interfaces 'own' the commit transaction? */
name|svn_boolean_t
name|txn_owner
decl_stmt|;
comment|/* svn transaction associated with this edit (created in      open_root, or supplied by the public API caller). */
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
comment|/** Filled in during open_root: **/
comment|/* The name of the transaction. */
specifier|const
name|char
modifier|*
name|txn_name
decl_stmt|;
comment|/* The object representing the root directory of the svn txn. */
name|svn_fs_root_t
modifier|*
name|txn_root
decl_stmt|;
comment|/* Avoid aborting an fs transaction more than once */
name|svn_boolean_t
name|txn_aborted
decl_stmt|;
comment|/** Filled in when the edit is closed: **/
comment|/* The new revision created by this commit. */
name|svn_revnum_t
modifier|*
name|new_rev
decl_stmt|;
comment|/* The date (according to the repository) of this commit. */
specifier|const
name|char
modifier|*
modifier|*
name|committed_date
decl_stmt|;
comment|/* The author (also according to the repository) of this commit. */
specifier|const
name|char
modifier|*
modifier|*
name|committed_author
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dir_baton
block|{
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* the -absolute- path to this dir in the fs */
name|svn_revnum_t
name|base_rev
decl_stmt|;
comment|/* the revision I'm based on  */
name|svn_boolean_t
name|was_copied
decl_stmt|;
comment|/* was this directory added with history? */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* my personal pool, in which I am allocated. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|file_baton
block|{
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* the -absolute- path to this file in the fs */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ev2_baton
block|{
comment|/* The repository we are editing.  */
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
comment|/* The authz baton for checks; NULL to skip authz.  */
name|svn_authz_t
modifier|*
name|authz
decl_stmt|;
comment|/* The repository name and user for performing authz checks.  */
specifier|const
name|char
modifier|*
name|authz_repos_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|authz_user
decl_stmt|;
comment|/* Callback to provide info about the committed revision.  */
name|svn_commit_callback2_t
name|commit_cb
decl_stmt|;
name|void
modifier|*
name|commit_baton
decl_stmt|;
comment|/* The FS txn editor  */
name|svn_editor_t
modifier|*
name|inner
decl_stmt|;
comment|/* The name of the open transaction (so we know what to commit)  */
specifier|const
name|char
modifier|*
name|txn_name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Create and return a generic out-of-dateness error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|out_of_date
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_TXN_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
operator|(
name|kind
operator|==
name|svn_node_dir
condition|?
name|_
argument_list|(
literal|"Directory '%s' is out of date"
argument_list|)
else|:
name|kind
operator|==
name|svn_node_file
condition|?
name|_
argument_list|(
literal|"File '%s' is out of date"
argument_list|)
else|:
name|_
argument_list|(
literal|"'%s' is out of date"
argument_list|)
operator|)
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|invoke_commit_cb
parameter_list|(
name|svn_commit_callback2_t
name|commit_cb
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|post_commit_errstr
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* FS interface returns non-const values.  */
comment|/* const */
name|svn_string_t
modifier|*
name|date
decl_stmt|;
comment|/* const */
name|svn_string_t
modifier|*
name|author
decl_stmt|;
name|svn_commit_info_t
modifier|*
name|commit_info
decl_stmt|;
if|if
condition|(
name|commit_cb
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_prop
argument_list|(
operator|&
name|date
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_prop
argument_list|(
operator|&
name|author
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|commit_info
operator|=
name|svn_create_commit_info
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* fill up the svn_commit_info structure */
name|commit_info
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|commit_info
operator|->
name|date
operator|=
name|date
condition|?
name|date
operator|->
name|data
else|:
name|NULL
expr_stmt|;
name|commit_info
operator|->
name|author
operator|=
name|author
condition|?
name|author
operator|->
name|data
else|:
name|NULL
expr_stmt|;
name|commit_info
operator|->
name|post_commit_err
operator|=
name|post_commit_errstr
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|commit_cb
argument_list|(
name|commit_info
argument_list|,
name|commit_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If EDITOR_BATON contains a valid authz callback, verify that the    REQUIRED access to PATH in ROOT is authorized.  Return an error    appropriate for throwing out of the commit editor with SVN_ERR.  If    no authz callback is present in EDITOR_BATON, then authorize all    paths.  Use POOL for temporary allocation only. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_authz
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|editor_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|svn_repos_authz_access_t
name|required
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|editor_baton
operator|->
name|authz_callback
condition|)
block|{
name|svn_boolean_t
name|allowed
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor_baton
operator|->
name|authz_callback
argument_list|(
name|required
argument_list|,
operator|&
name|allowed
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|editor_baton
operator|->
name|authz_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
condition|)
return|return
name|svn_error_create
argument_list|(
name|required
operator|&
name|svn_authz_write
condition|?
name|SVN_ERR_AUTHZ_UNWRITABLE
else|:
name|SVN_ERR_AUTHZ_UNREADABLE
argument_list|,
name|NULL
argument_list|,
literal|"Access denied"
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a directory baton allocated in POOL which represents    FULL_PATH, which is the immediate directory child of the directory    represented by PARENT_BATON.  EDIT_BATON is the commit editor    baton.  WAS_COPIED reveals whether or not this directory is the    result of a copy operation.  BASE_REVISION is the base revision of    the directory. */
end_comment

begin_function
specifier|static
name|struct
name|dir_baton
modifier|*
name|make_dir_baton
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|edit_baton
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|full_path
parameter_list|,
name|svn_boolean_t
name|was_copied
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|db
operator|->
name|parent
operator|=
name|parent_baton
expr_stmt|;
name|db
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|db
operator|->
name|path
operator|=
name|full_path
expr_stmt|;
name|db
operator|->
name|was_copied
operator|=
name|was_copied
expr_stmt|;
name|db
operator|->
name|base_rev
operator|=
name|base_revision
expr_stmt|;
return|return
name|db
return|;
block|}
end_function

begin_comment
comment|/* This function is the shared guts of add_file() and add_directory(),    which see for the meanings of the parameters.  The only extra    parameter here is IS_DIR, which is TRUE when adding a directory,    and FALSE when adding a file.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file_or_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_path
parameter_list|,
name|svn_revnum_t
name|copy_revision
parameter_list|,
name|svn_boolean_t
name|is_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|return_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|was_copied
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
comment|/* Reject paths which contain control characters (related to issue #4340). */
name|SVN_ERR
argument_list|(
name|svn_path_check_valid
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|eb
operator|->
name|base_path
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|copy_path
operator|&&
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copy_revision
argument_list|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Got source path but no source revision for '%s'"
argument_list|)
argument_list|,
name|full_path
argument_list|)
return|;
if|if
condition|(
name|copy_path
condition|)
block|{
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copy_root
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|size_t
name|repos_url_len
decl_stmt|;
name|svn_repos_authz_access_t
name|required
decl_stmt|;
comment|/* Copy requires recursive write access to the destination path          and write access to the parent path. */
name|required
operator|=
name|svn_authz_write
operator||
operator|(
name|is_dir
condition|?
name|svn_authz_recursive
else|:
literal|0
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|full_path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|required
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|pb
operator|->
name|path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|svn_authz_write
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check PATH in our transaction.  Make sure it does not exist          unless its parent directory was copied (in which case, the          thing might have been copied in as well), else return an          out-of-dateness error. */
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|full_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kind
operator|!=
name|svn_node_none
operator|)
operator|&&
operator|(
operator|!
name|pb
operator|->
name|was_copied
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|out_of_date
argument_list|(
name|full_path
argument_list|,
name|kind
argument_list|)
argument_list|)
return|;
comment|/* For now, require that the url come from the same repository          that this commit is operating on. */
name|copy_path
operator|=
name|svn_path_uri_decode
argument_list|(
name|copy_path
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|repos_url_len
operator|=
name|strlen
argument_list|(
name|eb
operator|->
name|repos_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|copy_path
argument_list|,
name|eb
operator|->
name|repos_url
argument_list|,
name|repos_url_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Source url '%s' is from different repository"
argument_list|)
argument_list|,
name|copy_path
argument_list|)
return|;
name|fs_path
operator|=
name|apr_pstrdup
argument_list|(
name|subpool
argument_list|,
name|copy_path
operator|+
name|repos_url_len
argument_list|)
expr_stmt|;
comment|/* Now use the "fs_path" as an absolute path within the          repository to make the copy from. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|copy_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|copy_revision
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy also requires (recursive) read access to the source */
name|required
operator|=
name|svn_authz_read
operator||
operator|(
name|is_dir
condition|?
name|svn_authz_recursive
else|:
literal|0
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|fs_path
argument_list|,
name|copy_root
argument_list|,
name|required
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_copy
argument_list|(
name|copy_root
argument_list|,
name|fs_path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|full_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|was_copied
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* No ancestry given, just make a new directory or empty file.          Note that we don't perform an existence check here like the          copy-from case does -- that's because svn_fs_make_*()          already errors out if the file already exists.  Verify write          access to the full path and to the parent. */
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|full_path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|svn_authz_write
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|pb
operator|->
name|path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|svn_authz_write
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_make_dir
argument_list|(
name|eb
operator|->
name|txn_root
argument_list|,
name|full_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_make_file
argument_list|(
name|eb
operator|->
name|txn_root
argument_list|,
name|full_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup our temporary subpool. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Build a new child baton. */
if|if
condition|(
name|is_dir
condition|)
block|{
operator|*
name|return_baton
operator|=
name|make_dir_baton
argument_list|(
name|eb
argument_list|,
name|pb
argument_list|,
name|full_path
argument_list|,
name|was_copied
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|file_baton
modifier|*
name|new_fb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_fb
argument_list|)
argument_list|)
decl_stmt|;
name|new_fb
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
name|new_fb
operator|->
name|path
operator|=
name|full_path
expr_stmt|;
operator|*
name|return_baton
operator|=
name|new_fb
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Editor functions ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|dirb
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
comment|/* Ignore BASE_REVISION.  We always build our transaction against      HEAD.  However, we will keep it in our dir baton for out of      dateness checks.  */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless we've been instructed to use a specific transaction, we'll      make our own. */
if|if
condition|(
name|eb
operator|->
name|txn_owner
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_repos_fs_begin_txn_for_commit2
argument_list|(
operator|&
operator|(
name|eb
operator|->
name|txn
operator|)
argument_list|,
name|eb
operator|->
name|repos
argument_list|,
name|youngest
argument_list|,
name|eb
operator|->
name|revprop_table
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Even if we aren't the owner of the transaction, we might           have been instructed to set some properties. */
block|{
name|apr_array_header_t
modifier|*
name|props
init|=
name|svn_prop_hash_to_array
argument_list|(
name|eb
operator|->
name|revprop_table
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_fs_change_txn_props
argument_list|(
name|eb
operator|->
name|txn
argument_list|,
name|props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_txn_name
argument_list|(
operator|&
operator|(
name|eb
operator|->
name|txn_name
operator|)
argument_list|,
name|eb
operator|->
name|txn
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_txn_root
argument_list|(
operator|&
operator|(
name|eb
operator|->
name|txn_root
operator|)
argument_list|,
name|eb
operator|->
name|txn
argument_list|,
name|eb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a root dir baton.  The `base_path' field is an -absolute-      path in the filesystem, upon which all further editor paths are      based. */
name|dirb
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dirb
argument_list|)
argument_list|)
expr_stmt|;
name|dirb
operator|->
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|dirb
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|dirb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|dirb
operator|->
name|was_copied
operator|=
name|FALSE
expr_stmt|;
name|dirb
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|eb
operator|->
name|base_path
argument_list|)
expr_stmt|;
name|dirb
operator|->
name|base_rev
operator|=
name|base_revision
expr_stmt|;
operator|*
name|root_baton
operator|=
name|dirb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|parent
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|parent
operator|->
name|edit_baton
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_revnum_t
name|cr_rev
decl_stmt|;
name|svn_repos_authz_access_t
name|required
init|=
name|svn_authz_write
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|eb
operator|->
name|base_path
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check PATH in our transaction.  */
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Deletion requires a recursive write access, as well as write      access to the parent directory. */
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|required
operator||=
name|svn_authz_recursive
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|full_path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|required
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|parent
operator|->
name|path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|svn_authz_write
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If PATH doesn't exist in the txn, the working copy is out of date. */
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_trace
argument_list|(
name|out_of_date
argument_list|(
name|full_path
argument_list|,
name|kind
argument_list|)
argument_list|)
return|;
comment|/* Now, make sure we're deleting the node we *think* we're      deleting, else return an out-of-dateness error. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_created_rev
argument_list|(
operator|&
name|cr_rev
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
operator|&&
operator|(
name|revision
operator|<
name|cr_rev
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|out_of_date
argument_list|(
name|full_path
argument_list|,
name|kind
argument_list|)
argument_list|)
return|;
comment|/* This routine is a mindless wrapper.  We call svn_fs_delete()      because that will delete files and recursively delete      directories.  */
return|return
name|svn_fs_delete
argument_list|(
name|eb
operator|->
name|txn_root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_path
parameter_list|,
name|svn_revnum_t
name|copy_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
return|return
name|add_file_or_directory
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|copy_path
argument_list|,
name|copy_revision
argument_list|,
name|TRUE
comment|/* is_dir */
argument_list|,
name|pool
argument_list|,
name|child_baton
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|eb
operator|->
name|base_path
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check PATH in our transaction.  If it does not exist,      return a 'Path not present' error. */
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' not present"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
comment|/* Build a new dir baton for this directory. */
operator|*
name|child_baton
operator|=
name|make_dir_baton
argument_list|(
name|eb
argument_list|,
name|pb
argument_list|,
name|full_path
argument_list|,
name|pb
operator|->
name|was_copied
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
comment|/* Check for write authorization. */
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|fb
operator|->
name|edit_baton
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|fb
operator|->
name|edit_baton
operator|->
name|txn_root
argument_list|,
name|svn_authz_write
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_apply_textdelta
argument_list|(
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|fb
operator|->
name|edit_baton
operator|->
name|txn_root
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|base_checksum
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_path
parameter_list|,
name|svn_revnum_t
name|copy_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
return|return
name|add_file_or_directory
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|copy_path
argument_list|,
name|copy_revision
argument_list|,
name|FALSE
comment|/* is_dir */
argument_list|,
name|pool
argument_list|,
name|file_baton
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|new_fb
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|svn_revnum_t
name|cr_rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|eb
operator|->
name|base_path
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check for read authorization. */
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|full_path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|svn_authz_read
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get this node's creation revision (doubles as an existence check). */
name|SVN_ERR
argument_list|(
name|svn_fs_node_created_rev
argument_list|(
operator|&
name|cr_rev
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|full_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the node our caller has is an older revision number than the      one in our transaction, return an out-of-dateness error. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
operator|&&
operator|(
name|base_revision
operator|<
name|cr_rev
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|out_of_date
argument_list|(
name|full_path
argument_list|,
name|svn_node_file
argument_list|)
argument_list|)
return|;
comment|/* Build a new file baton */
name|new_fb
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_fb
argument_list|)
argument_list|)
expr_stmt|;
name|new_fb
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
name|new_fb
operator|->
name|path
operator|=
name|full_path
expr_stmt|;
operator|*
name|file_baton
operator|=
name|new_fb
expr_stmt|;
comment|/* Destory the work subpool. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
comment|/* Check for write authorization. */
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|svn_authz_write
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_repos_fs_change_node_prop
argument_list|(
name|eb
operator|->
name|txn_root
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
if|if
condition|(
name|text_digest
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|text_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|fb
operator|->
name|edit_baton
operator|->
name|txn_root
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|text_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|text_digest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|text_checksum
argument_list|,
name|checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|text_checksum
argument_list|,
name|checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for resulting fulltext\n(%s)"
argument_list|)
argument_list|,
name|fb
operator|->
name|path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
comment|/* Check for write authorization. */
name|SVN_ERR
argument_list|(
name|check_authz
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|svn_authz_write
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|db
operator|->
name|base_rev
argument_list|)
condition|)
block|{
comment|/* Subversion rule:  propchanges can only happen on a directory          which is up-to-date. */
name|svn_revnum_t
name|created_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_created_rev
argument_list|(
operator|&
name|created_rev
argument_list|,
name|eb
operator|->
name|txn_root
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|base_rev
operator|<
name|created_rev
condition|)
return|return
name|svn_error_trace
argument_list|(
name|out_of_date
argument_list|(
name|db
operator|->
name|path
argument_list|,
name|svn_node_dir
argument_list|)
argument_list|)
return|;
block|}
return|return
name|svn_repos_fs_change_node_prop
argument_list|(
name|eb
operator|->
name|txn_root
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_repos__post_commit_error_str
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|hook_err1
decl_stmt|,
modifier|*
name|hook_err2
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|_
argument_list|(
literal|"(no error)"
argument_list|)
return|;
name|err
operator|=
name|svn_error_purge_tracing
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* hook_err1 is the SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED wrapped      error from the post-commit script, if any, and hook_err2 should      be the original error, but be defensive and handle a case where      SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED doesn't wrap an error. */
name|hook_err1
operator|=
name|svn_error_find_cause
argument_list|(
name|err
argument_list|,
name|SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook_err1
operator|&&
name|hook_err1
operator|->
name|child
condition|)
name|hook_err2
operator|=
name|hook_err1
operator|->
name|child
expr_stmt|;
else|else
name|hook_err2
operator|=
name|hook_err1
expr_stmt|;
comment|/* This implementation counts on svn_repos_fs_commit_txn() and      libsvn_repos/commit.c:complete_cb() returning      svn_fs_commit_txn() as the parent error with a child      SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED error.  If the parent error      is SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED then there was no error      in svn_fs_commit_txn().       The post-commit hook error message is already self describing, so      it can be dropped into an error message without any additional      text. */
if|if
condition|(
name|hook_err1
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|hook_err1
condition|)
block|{
if|if
condition|(
name|hook_err2
operator|->
name|message
condition|)
name|msg
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|hook_err2
operator|->
name|message
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"post-commit hook failed with no error message."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|hook_err2
operator|->
name|message
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|hook_err2
operator|->
name|message
argument_list|)
else|:
name|_
argument_list|(
literal|"post-commit hook failed with no error message."
argument_list|)
expr_stmt|;
name|msg
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"post commit FS processing had error:\n%s\n%s"
argument_list|)
argument_list|,
name|err
operator|->
name|message
condition|?
name|err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"(no error message)"
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|msg
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"post commit FS processing had error:\n%s"
argument_list|)
argument_list|,
name|err
operator|->
name|message
condition|?
name|err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"(no error message)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|svn_revnum_t
name|new_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict
decl_stmt|;
specifier|const
name|char
modifier|*
name|post_commit_err
init|=
name|NULL
decl_stmt|;
comment|/* If no transaction has been created (ie. if open_root wasn't      called before close_edit), abort the operation here with an      error. */
if|if
condition|(
operator|!
name|eb
operator|->
name|txn
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
literal|"No valid transaction supplied to close_edit"
argument_list|)
return|;
comment|/* Commit. */
name|err
operator|=
name|svn_repos_fs_commit_txn
argument_list|(
operator|&
name|conflict
argument_list|,
name|eb
operator|->
name|repos
argument_list|,
operator|&
name|new_revision
argument_list|,
name|eb
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|new_revision
argument_list|)
condition|)
block|{
comment|/* The actual commit succeeded, i.e. the transaction does no longer          exist and we can't use txn_root for conflict resolution etc.           Since close_edit is supposed to release resources, do it now. */
if|if
condition|(
name|eb
operator|->
name|txn_root
condition|)
name|svn_fs_close_root
argument_list|(
name|eb
operator|->
name|txn_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* If the error was in post-commit, then the commit itself              succeeded.  In which case, save the post-commit warning              (to be reported back to the client, who will probably              display it as a warning) and clear the error. */
name|post_commit_err
operator|=
name|svn_repos__post_commit_error_str
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ### todo: we should check whether it really was a conflict,          and return the conflict info if so? */
comment|/* If the commit failed, it's *probably* due to a conflict --          that is, the txn being out-of-date.  The filesystem gives us          the ability to continue diddling the transaction and try          again; but let's face it: that's not how the cvs or svn works          from a user interface standpoint.  Thus we don't make use of          this fs feature (for now, at least.)           So, in a nutshell: svn commits are an all-or-nothing deal.          Each commit creates a new fs txn which either succeeds or is          aborted completely.  No second chances;  the user simply          needs to update and commit again  :) */
name|eb
operator|->
name|txn_aborted
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_fs_abort_txn
argument_list|(
name|eb
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* At this point, the post-commit error has been converted to a string.      That information will be passed to a callback, if provided. If the      callback invocation fails in some way, that failure is returned here.      IOW, the post-commit error information is low priority compared to      other gunk here.  */
comment|/* Pass new revision information to the caller's callback. */
return|return
name|svn_error_trace
argument_list|(
name|invoke_commit_cb
argument_list|(
name|eb
operator|->
name|commit_callback
argument_list|,
name|eb
operator|->
name|commit_callback_baton
argument_list|,
name|eb
operator|->
name|repos
operator|->
name|fs
argument_list|,
name|new_revision
argument_list|,
name|post_commit_err
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|eb
operator|->
name|txn
operator|)
operator|||
operator|(
operator|!
name|eb
operator|->
name|txn_owner
operator|)
operator|||
name|eb
operator|->
name|txn_aborted
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|eb
operator|->
name|txn_aborted
operator|=
name|TRUE
expr_stmt|;
comment|/* Since abort_edit is supposed to release resources, do it now. */
if|if
condition|(
name|eb
operator|->
name|txn_root
condition|)
name|svn_fs_close_root
argument_list|(
name|eb
operator|->
name|txn_root
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_fs_abort_txn
argument_list|(
name|eb
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|svn_fs_txn_base_revision
argument_list|(
name|eb
operator|->
name|txn
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_node_proplist
argument_list|(
name|props
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|svn_fs_txn_base_revision
argument_list|(
name|eb
operator|->
name|txn
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
name|kind
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_filename
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|svn_fs_txn_base_revision
argument_list|(
name|eb
operator|->
name|txn
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|file_stream
argument_list|,
operator|&
name|tmp_filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|file_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|tmp_filename
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public interfaces. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_get_commit_editor5
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_url
parameter_list|,
specifier|const
name|char
modifier|*
name|base_path
parameter_list|,
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_repos_authz_callback_t
name|authz_callback
parameter_list|,
name|void
modifier|*
name|authz_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_delta_editor_t
modifier|*
name|e
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
decl_stmt|;
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Do a global authz access lookup.  Users with no write access      whatsoever to the repository don't get a commit editor. */
if|if
condition|(
name|authz_callback
condition|)
block|{
name|svn_boolean_t
name|allowed
decl_stmt|;
name|SVN_ERR
argument_list|(
name|authz_callback
argument_list|(
name|svn_authz_write
argument_list|,
operator|&
name|allowed
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|authz_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_UNWRITABLE
argument_list|,
name|NULL
argument_list|,
literal|"Not authorized to open a commit editor."
argument_list|)
return|;
block|}
comment|/* Allocate the structures. */
name|e
operator|=
name|svn_delta_default_editor
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|eb
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the editor. */
name|e
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|e
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|e
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|e
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
name|e
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|e
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|e
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|e
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|e
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|e
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|e
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
name|e
operator|->
name|abort_edit
operator|=
name|abort_edit
expr_stmt|;
comment|/* Set up the edit baton. */
name|eb
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
name|eb
operator|->
name|revprop_table
operator|=
name|svn_prop_hash_dup
argument_list|(
name|revprop_table
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|commit_callback
operator|=
name|commit_callback
expr_stmt|;
name|eb
operator|->
name|commit_callback_baton
operator|=
name|commit_baton
expr_stmt|;
name|eb
operator|->
name|authz_callback
operator|=
name|authz_callback
expr_stmt|;
name|eb
operator|->
name|authz_baton
operator|=
name|authz_baton
expr_stmt|;
name|eb
operator|->
name|base_path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|base_path
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|repos
operator|=
name|repos
expr_stmt|;
name|eb
operator|->
name|repos_url
operator|=
name|repos_url
expr_stmt|;
name|eb
operator|->
name|repos_name
operator|=
name|svn_dirent_basename
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|eb
operator|->
name|txn
operator|=
name|txn
expr_stmt|;
name|eb
operator|->
name|txn_owner
operator|=
name|txn
operator|==
name|NULL
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|editor
operator|=
name|e
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_baton
operator|=
name|eb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor__insert_shims
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|*
name|editor
argument_list|,
operator|*
name|edit_baton
argument_list|,
name|eb
operator|->
name|repos_url
argument_list|,
name|eb
operator|->
name|base_path
argument_list|,
name|shim_callbacks
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static svn_error_t * ev2_check_authz(const struct ev2_baton *eb,                 const char *relpath,                 svn_repos_authz_access_t required,                 apr_pool_t *scratch_pool) {   const char *fspath;   svn_boolean_t allowed;    if (eb->authz == NULL)     return SVN_NO_ERROR;    if (relpath)     fspath = apr_pstrcat(scratch_pool, "/", relpath, NULL);   else     fspath = NULL;    SVN_ERR(svn_repos_authz_check_access(eb->authz, eb->authz_repos_name, fspath,                                        eb->authz_user, required,&allowed, scratch_pool));   if (!allowed)     return svn_error_create(required& svn_authz_write                             ? SVN_ERR_AUTHZ_UNWRITABLE                             : SVN_ERR_AUTHZ_UNREADABLE,                             NULL, "Access denied");    return SVN_NO_ERROR; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This implements svn_editor_cb_add_directory_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|children
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_add_directory
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|relpath
argument_list|,
name|children
argument_list|,
name|props
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_file_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|svn_stream_t
modifier|*
name|contents
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_add_file
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|relpath
argument_list|,
name|checksum
argument_list|,
name|contents
argument_list|,
name|props
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_symlink_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_symlink_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_add_symlink
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|relpath
argument_list|,
name|target
argument_list|,
name|props
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_absent_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_absent_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_add_absent
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|relpath
argument_list|,
name|kind
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_alter_directory_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_directory_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|children
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_alter_directory
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|relpath
argument_list|,
name|revision
argument_list|,
name|children
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_alter_file_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_file_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|svn_stream_t
modifier|*
name|contents
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_alter_file
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|relpath
argument_list|,
name|revision
argument_list|,
name|props
argument_list|,
name|checksum
argument_list|,
name|contents
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_alter_symlink_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_symlink_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_alter_symlink
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|relpath
argument_list|,
name|revision
argument_list|,
name|props
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_delete_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_delete
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|relpath
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_copy_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
name|svn_revnum_t
name|src_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_copy
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|src_relpath
argument_list|,
name|src_revision
argument_list|,
name|dst_relpath
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_move_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|move_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
name|svn_revnum_t
name|src_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_move
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|src_relpath
argument_list|,
name|src_revision
argument_list|,
name|dst_relpath
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_rotate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rotate_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|relpaths
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revisions
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_rotate
argument_list|(
name|eb
operator|->
name|inner
argument_list|,
name|relpaths
argument_list|,
name|revisions
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_complete_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|complete_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_error_t
modifier|*
name|post_commit_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_path
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|post_commit_errstr
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
comment|/* Parse the hooks-env file (if any). */
name|SVN_ERR
argument_list|(
name|svn_repos__parse_hooks_env
argument_list|(
operator|&
name|hooks_env
argument_list|,
name|eb
operator|->
name|repos
operator|->
name|hooks_env_path
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The transaction has been fully edited. Let the pre-commit hook      have a look at the thing.  */
name|SVN_ERR
argument_list|(
name|svn_repos__hooks_pre_commit
argument_list|(
name|eb
operator|->
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|eb
operator|->
name|txn_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Hook is done. Let's do the actual commit.  */
name|SVN_ERR
argument_list|(
name|svn_fs__editor_commit
argument_list|(
operator|&
name|revision
argument_list|,
operator|&
name|post_commit_err
argument_list|,
operator|&
name|conflict_path
argument_list|,
name|eb
operator|->
name|inner
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Did a conflict occur during the commit process?  */
if|if
condition|(
name|conflict_path
operator|!=
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict at '%s'"
argument_list|)
argument_list|,
name|conflict_path
argument_list|)
return|;
comment|/* Since did not receive an error during the commit process, and no      conflict was specified... we committed a revision. Run the hooks.      Other errors may have occurred within the FS (specified by the      POST_COMMIT_ERR localvar), but we need to run the hooks.  */
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_repos__hooks_post_commit
argument_list|(
name|eb
operator|->
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|revision
argument_list|,
name|eb
operator|->
name|txn_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Commit succeeded, but post-commit hook failed"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Combine the FS errors with the hook errors, and stringify.  */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|post_commit_err
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|post_commit_errstr
operator|=
name|svn_repos__post_commit_error_str
argument_list|(
name|err
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|post_commit_errstr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|invoke_commit_cb
argument_list|(
name|eb
operator|->
name|commit_cb
argument_list|,
name|eb
operator|->
name|commit_baton
argument_list|,
name|eb
operator|->
name|repos
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|post_commit_errstr
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_abort_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_abort
argument_list|(
name|eb
operator|->
name|inner
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_name
parameter_list|,
name|apr_hash_t
modifier|*
name|revprops
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|revprops_array
decl_stmt|;
comment|/* The FS editor has a TXN inside it, but we can't access it. Open another      based on the TXN_NAME.  */
name|SVN_ERR
argument_list|(
name|svn_fs_open_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|fs
argument_list|,
name|txn_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Validate and apply the revision properties.  */
name|revprops_array
operator|=
name|svn_prop_hash_to_array
argument_list|(
name|revprops
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_fs_change_txn_props
argument_list|(
name|txn
argument_list|,
name|revprops_array
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### do we need to force the txn to close, or is it enough to wait      ### for the pool to be cleared?  */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__get_commit_ev2
parameter_list|(
name|svn_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_authz_t
modifier|*
name|authz
parameter_list|,
specifier|const
name|char
modifier|*
name|authz_repos_name
parameter_list|,
specifier|const
name|char
modifier|*
name|authz_user
parameter_list|,
name|apr_hash_t
modifier|*
name|revprops
parameter_list|,
name|svn_commit_callback2_t
name|commit_cb
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_editor_cb_many_t
name|editor_cbs
init|=
block|{
name|add_directory_cb
block|,
name|add_file_cb
block|,
name|add_symlink_cb
block|,
name|add_absent_cb
block|,
name|alter_directory_cb
block|,
name|alter_file_cb
block|,
name|alter_symlink_cb
block|,
name|delete_cb
block|,
name|copy_cb
block|,
name|move_cb
block|,
name|rotate_cb
block|,
name|complete_cb
block|,
name|abort_cb
block|}
decl_stmt|;
name|struct
name|ev2_baton
modifier|*
name|eb
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|author
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
comment|/* Parse the hooks-env file (if any). */
name|SVN_ERR
argument_list|(
name|svn_repos__parse_hooks_env
argument_list|(
operator|&
name|hooks_env
argument_list|,
name|repos
operator|->
name|hooks_env_path
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Can the user modify the repository at all?  */
comment|/* ### check against AUTHZ.  */
name|author
operator|=
name|svn_hash_gets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
expr_stmt|;
name|eb
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|repos
operator|=
name|repos
expr_stmt|;
name|eb
operator|->
name|authz
operator|=
name|authz
expr_stmt|;
name|eb
operator|->
name|authz_repos_name
operator|=
name|authz_repos_name
expr_stmt|;
name|eb
operator|->
name|authz_user
operator|=
name|authz_user
expr_stmt|;
name|eb
operator|->
name|commit_cb
operator|=
name|commit_cb
expr_stmt|;
name|eb
operator|->
name|commit_baton
operator|=
name|commit_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__editor_create
argument_list|(
operator|&
name|eb
operator|->
name|inner
argument_list|,
operator|&
name|eb
operator|->
name|txn_name
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|SVN_FS_TXN_CHECK_LOCKS
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The TXN has been created. Go ahead and apply all revision properties.  */
name|SVN_ERR
argument_list|(
name|apply_revprops
argument_list|(
name|repos
operator|->
name|fs
argument_list|,
name|eb
operator|->
name|txn_name
argument_list|,
name|revprops
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Okay... some access is allowed. Let's run the start-commit hook.  */
name|SVN_ERR
argument_list|(
name|svn_repos__hooks_start_commit
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|author
condition|?
name|author
operator|->
name|data
else|:
name|NULL
argument_list|,
name|repos
operator|->
name|client_capabilities
argument_list|,
name|eb
operator|->
name|txn_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wrap the FS editor within our editor.  */
name|SVN_ERR
argument_list|(
name|svn_editor_create
argument_list|(
name|editor
argument_list|,
name|eb
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_setcb_many
argument_list|(
operator|*
name|editor
argument_list|,
operator|&
name|editor_cbs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

