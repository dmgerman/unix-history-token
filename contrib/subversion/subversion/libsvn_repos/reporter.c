begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * reporter.c : `reporter' vtable routines for updates.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_define
define|#
directive|define
name|NUM_CACHED_SOURCE_ROOTS
value|4
end_define

begin_comment
comment|/* Theory of operation: we write report operations out to a spill-buffer    as we receive them.  When the report is finished, we read the    operations back out again, using them to guide the progression of    the delta between the source and target revs.     Spill-buffer content format: we use a simple ad-hoc format to store the    report operations.  Each report operation is the concatention of    the following ("+/-" indicates the single character '+' or '-';<length> and<revnum> are written out as decimal strings):       +/-                      '-' marks the end of the report      If previous is +:<length>:<bytes>       Length-counted path string        +/-                    '+' indicates the presence of link_path        If previous is +:<length>:<bytes>     Length-counted link_path string        +/-                    '+' indicates presence of revnum        If previous is +:<revnum>:            Revnum of set_path or link_path        +/-                    '+' indicates depth other than svn_depth_infinity        If previous is +:<depth>:             "X","E","F","M" =>                                  svn_depth_{exclude,empty,files,immediates}        +/-                    '+' indicates start_empty field set        +/-                    '+' indicates presence of lock_token field.        If previous is +:<length>:<bytes>     Length-counted lock_token string     Terminology: for brevity, this file frequently uses the prefixes    "s_" for source, "t_" for target, and "e_" for editor.  Also, to    avoid overloading the word "target", we talk about the source    "anchor and operand", rather than the usual "anchor and target". */
end_comment

begin_comment
comment|/* Describes the state of a working copy subtree, as given by a    report.  Because we keep a lookahead pathinfo, we need to allocate    each one of these things in a subpool of the report baton and free    it when done. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|path_info_t
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* path, munged to be anchor-relative */
specifier|const
name|char
modifier|*
name|link_path
decl_stmt|;
comment|/* NULL for set_path or delete_path */
name|svn_revnum_t
name|rev
decl_stmt|;
comment|/* SVN_INVALID_REVNUM for delete_path */
name|svn_depth_t
name|depth
decl_stmt|;
comment|/* Depth of this path, meaningless for files */
name|svn_boolean_t
name|start_empty
decl_stmt|;
comment|/* Meaningless for delete_path */
specifier|const
name|char
modifier|*
name|lock_token
decl_stmt|;
comment|/* NULL if no token */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Container pool */
block|}
name|path_info_t
typedef|;
end_typedef

begin_comment
comment|/* Describes the standard revision properties that are relevant for    reports.  Since a particular revision will often show up more than    once in the report, we cache these properties for the time of the    report generation. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|revision_info_t
block|{
name|svn_revnum_t
name|rev
decl_stmt|;
comment|/* revision number */
name|svn_string_t
modifier|*
name|date
decl_stmt|;
comment|/* revision timestamp */
name|svn_string_t
modifier|*
name|author
decl_stmt|;
comment|/* name of the revisions' author */
block|}
name|revision_info_t
typedef|;
end_typedef

begin_comment
comment|/* A structure used by the routines within the `reporter' vtable,    driven by the client as it describes its working copy revisions. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|report_baton_t
block|{
comment|/* Parameters remembered from svn_repos_begin_report3 */
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_base
decl_stmt|;
comment|/* fspath corresponding to wc anchor */
specifier|const
name|char
modifier|*
name|s_operand
decl_stmt|;
comment|/* anchor-relative wc target (may be empty) */
name|svn_revnum_t
name|t_rev
decl_stmt|;
comment|/* Revnum which the edit will bring the wc to */
specifier|const
name|char
modifier|*
name|t_path
decl_stmt|;
comment|/* FS path the edit will bring the wc to */
name|svn_boolean_t
name|text_deltas
decl_stmt|;
comment|/* Whether to report text deltas */
name|apr_size_t
name|zero_copy_limit
decl_stmt|;
comment|/* Max item size that will be sent using                                   the zero-copy code path. */
comment|/* If the client requested a specific depth, record it here; if the      client did not, then this is svn_depth_unknown, and the depth of      information transmitted from server to client will be governed      strictly by the path-associated depths recorded in the report. */
name|svn_depth_t
name|requested_depth
decl_stmt|;
name|svn_boolean_t
name|ignore_ancestry
decl_stmt|;
name|svn_boolean_t
name|send_copyfrom_args
decl_stmt|;
name|svn_boolean_t
name|is_switch
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|svn_repos_authz_func_t
name|authz_read_func
decl_stmt|;
name|void
modifier|*
name|authz_read_baton
decl_stmt|;
comment|/* The spill-buffer holding the report. */
name|svn_spillbuf_reader_t
modifier|*
name|reader
decl_stmt|;
comment|/* For the actual editor drive, we'll need a lookahead path info      entry, a cache of FS roots, and a pool to store them. */
name|path_info_t
modifier|*
name|lookahead
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|t_root
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|s_roots
index|[
name|NUM_CACHED_SOURCE_ROOTS
index|]
decl_stmt|;
comment|/* Cache for revision properties. This is used to eliminate redundant      revprop fetching. */
name|apr_hash_t
modifier|*
name|revision_infos
decl_stmt|;
comment|/* This will not change. So, fetch it once and reuse it. */
name|svn_string_t
modifier|*
name|repos_uuid
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|report_baton_t
typedef|;
end_typedef

begin_comment
comment|/* The type of a function that accepts changes to an object's property    list.  OBJECT is the object whose properties are being changed.    NAME is the name of the property to change.  VALUE is the new value    for the property, or zero if the property should be deleted. */
end_comment

begin_typedef
typedef|typedef
name|svn_error_t
modifier|*
name|proplist_change_fn_t
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|void
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|delta_dirs
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|svn_revnum_t
name|s_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|s_path
parameter_list|,
specifier|const
name|char
modifier|*
name|t_path
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|e_path
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
name|svn_depth_t
name|wc_depth
parameter_list|,
name|svn_depth_t
name|requested_depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* --- READING PREVIOUSLY STORED REPORT INFORMATION --- */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_number
parameter_list|(
name|apr_uint64_t
modifier|*
name|num
parameter_list|,
name|svn_spillbuf_reader_t
modifier|*
name|reader
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
operator|*
name|num
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_getc
argument_list|(
operator|&
name|c
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
break|break;
operator|*
name|num
operator|=
operator|*
name|num
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|svn_spillbuf_reader_t
modifier|*
name|reader
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint64_t
name|len
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
name|apr_size_t
name|amt
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_number
argument_list|(
operator|&
name|len
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Len can never be less than zero.  But could len be so large that      len + 1 wraps around and we end up passing 0 to apr_palloc(),      thus getting a pointer to no storage?  Probably not (16 exabyte      string, anyone?) but let's be future-proof anyway. */
if|if
condition|(
name|len
operator|+
literal|1
operator|<
name|len
operator|||
name|len
operator|+
literal|1
operator|>
name|APR_SIZE_MAX
condition|)
block|{
comment|/* xgettext doesn't expand preprocessor definitions, so we must          pass translatable string to apr_psprintf() function to create          intermediate string with appropriate format specifier. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_REVISION_REPORT
argument_list|,
name|NULL
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Invalid length (%%%s) when "
literal|"about to read a string"
argument_list|)
argument_list|,
name|APR_UINT64_T_FMT
argument_list|)
argument_list|,
name|len
argument_list|)
return|;
block|}
name|size
operator|=
operator|(
name|apr_size_t
operator|)
name|len
expr_stmt|;
name|buf
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_read
argument_list|(
operator|&
name|amt
argument_list|,
name|reader
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|amt
operator|==
name|size
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|str
operator|=
name|buf
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|svn_spillbuf_reader_t
modifier|*
name|reader
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|apr_uint64_t
name|num
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_getc
argument_list|(
operator|&
name|c
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_number
argument_list|(
operator|&
name|num
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|num
expr_stmt|;
block|}
else|else
operator|*
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a single character to set *DEPTH (having already read '+')    from READER.  PATH is the path to which the depth applies, and is    used for error reporting only. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_depth
parameter_list|(
name|svn_depth_t
modifier|*
name|depth
parameter_list|,
name|svn_spillbuf_reader_t
modifier|*
name|reader
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_getc
argument_list|(
operator|&
name|c
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'X'
case|:
operator|*
name|depth
operator|=
name|svn_depth_exclude
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
operator|*
name|depth
operator|=
name|svn_depth_empty
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
operator|*
name|depth
operator|=
name|svn_depth_files
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
operator|*
name|depth
operator|=
name|svn_depth_immediates
expr_stmt|;
break|break;
comment|/* Note that we do not tolerate explicit representation of          svn_depth_infinity here, because that's not how          write_path_info() writes it. */
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_REVISION_REPORT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid depth (%c) for path '%s'"
argument_list|)
argument_list|,
name|c
argument_list|,
name|path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a report operation *PI out of READER.  Set *PI to NULL if we    have reached the end of the report. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_path_info
parameter_list|(
name|path_info_t
modifier|*
modifier|*
name|pi
parameter_list|,
name|svn_spillbuf_reader_t
modifier|*
name|reader
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_getc
argument_list|(
operator|&
name|c
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
operator|*
name|pi
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
name|pi
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_string
argument_list|(
operator|&
operator|(
operator|*
name|pi
operator|)
operator|->
name|path
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_getc
argument_list|(
operator|&
name|c
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|SVN_ERR
argument_list|(
name|read_string
argument_list|(
operator|&
operator|(
operator|*
name|pi
operator|)
operator|->
name|link_path
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
operator|*
name|pi
operator|)
operator|->
name|link_path
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_rev
argument_list|(
operator|&
operator|(
operator|*
name|pi
operator|)
operator|->
name|rev
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_getc
argument_list|(
operator|&
name|c
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|SVN_ERR
argument_list|(
name|read_depth
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pi
operator|)
operator|->
name|depth
operator|)
argument_list|,
name|reader
argument_list|,
operator|(
operator|*
name|pi
operator|)
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
operator|*
name|pi
operator|)
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_getc
argument_list|(
operator|&
name|c
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pi
operator|)
operator|->
name|start_empty
operator|=
operator|(
name|c
operator|==
literal|'+'
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_getc
argument_list|(
operator|&
name|c
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|SVN_ERR
argument_list|(
name|read_string
argument_list|(
operator|&
operator|(
operator|*
name|pi
operator|)
operator|->
name|lock_token
argument_list|,
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
operator|*
name|pi
operator|)
operator|->
name|lock_token
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|pi
operator|)
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return true if PI's path is a child of PREFIX (which has length PLEN). */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|relevant
parameter_list|(
name|path_info_t
modifier|*
name|pi
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|apr_size_t
name|plen
parameter_list|)
block|{
return|return
operator|(
name|pi
operator|&&
name|strncmp
argument_list|(
name|pi
operator|->
name|path
argument_list|,
name|prefix
argument_list|,
name|plen
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
operator|*
name|prefix
operator|||
name|pi
operator|->
name|path
index|[
name|plen
index|]
operator|==
literal|'/'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fetch the next pathinfo from B->reader for a descendant of    PREFIX.  If the next pathinfo is for an immediate child of PREFIX,    set *ENTRY to the path component of the report information and    *INFO to the path information for that entry.  If the next pathinfo    is for a grandchild or other more remote descendant of PREFIX, set    *ENTRY to the immediate child corresponding to that descendant and    set *INFO to NULL.  If the next pathinfo is not for a descendant of    PREFIX, or if we reach the end of the report, set both *ENTRY and    *INFO to NULL.     At all times, B->lookahead is presumed to be the next pathinfo not    yet returned as an immediate child, or NULL if we have reached the    end of the report.  Because we use a lookahead element, we can't    rely on the usual nested pool lifetimes, so allocate each pathinfo    in a subpool of the report baton's pool.  The caller should delete    (*INFO)->pool when it is done with the information. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_path_info
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|entry
parameter_list|,
name|path_info_t
modifier|*
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|plen
init|=
name|strlen
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|,
modifier|*
name|sep
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
if|if
condition|(
operator|!
name|relevant
argument_list|(
name|b
operator|->
name|lookahead
argument_list|,
name|prefix
argument_list|,
name|plen
argument_list|)
condition|)
block|{
comment|/* No more entries relevant to prefix. */
operator|*
name|entry
operator|=
name|NULL
expr_stmt|;
operator|*
name|info
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Take a look at the prefix-relative part of the path. */
name|relpath
operator|=
name|b
operator|->
name|lookahead
operator|->
name|path
operator|+
operator|(
operator|*
name|prefix
condition|?
name|plen
operator|+
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|sep
operator|=
name|strchr
argument_list|(
name|relpath
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
block|{
comment|/* Return the immediate child part; do not advance. */
operator|*
name|entry
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|relpath
argument_list|,
name|sep
operator|-
name|relpath
argument_list|)
expr_stmt|;
operator|*
name|info
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an immediate child; return it and advance. */
operator|*
name|entry
operator|=
name|relpath
expr_stmt|;
operator|*
name|info
operator|=
name|b
operator|->
name|lookahead
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_path_info
argument_list|(
operator|&
name|b
operator|->
name|lookahead
argument_list|,
name|b
operator|->
name|reader
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Skip all path info entries relevant to *PREFIX.  Call this when the    editor drive skips a directory. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_path_info
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|apr_size_t
name|plen
init|=
name|strlen
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
while|while
condition|(
name|relevant
argument_list|(
name|b
operator|->
name|lookahead
argument_list|,
name|prefix
argument_list|,
name|plen
argument_list|)
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|b
operator|->
name|lookahead
operator|->
name|pool
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_path_info
argument_list|(
operator|&
name|b
operator|->
name|lookahead
argument_list|,
name|b
operator|->
name|reader
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return true if there is at least one path info entry relevant to *PREFIX. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|any_path_info
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
return|return
name|relevant
argument_list|(
name|b
operator|->
name|lookahead
argument_list|,
name|prefix
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --- DRIVING THE EDITOR ONCE THE REPORT IS FINISHED --- */
end_comment

begin_comment
comment|/* While driving the editor, the target root will remain constant, but    we may have to jump around between source roots depending on the    state of the working copy.  If we were to open a root each time we    revisit a rev, we would get no benefit from node-id caching; on the    other hand, if we hold open all the roots we ever visit, we'll use    an unbounded amount of memory.  As a compromise, we maintain a    fixed-size LRU cache of source roots.  get_source_root retrieves a    root from the cache, using POOL to allocate the new root if    necessary.  Be careful not to hold onto the root for too long,    particularly after recursing, since another call to get_source_root    can close it. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_source_root
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|svn_fs_root_t
modifier|*
modifier|*
name|s_root
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
comment|/* Look for the desired root in the cache, sliding all the unmatched      entries backwards a slot to make room for the right one. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CACHED_SOURCE_ROOTS
condition|;
name|i
operator|++
control|)
block|{
name|root
operator|=
name|b
operator|->
name|s_roots
index|[
name|i
index|]
expr_stmt|;
name|b
operator|->
name|s_roots
index|[
name|i
index|]
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|root
operator|&&
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
operator|==
name|rev
condition|)
break|break;
name|prev
operator|=
name|root
expr_stmt|;
block|}
comment|/* If we didn't find it, throw out the oldest root and open a new one. */
if|if
condition|(
name|i
operator|==
name|NUM_CACHED_SOURCE_ROOTS
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|svn_fs_close_root
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|b
operator|->
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Assign the desired root to the first cache slot and hand it back. */
name|b
operator|->
name|s_roots
index|[
literal|0
index|]
operator|=
name|root
expr_stmt|;
operator|*
name|s_root
operator|=
name|root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Call the directory property-setting function of B->editor to set    the property NAME to VALUE on DIR_BATON. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|b
operator|->
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|dir_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call the file property-setting function of B->editor to set the    property NAME to VALUE on FILE_BATON. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|b
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For the report B, return the relevant revprop data of revision REV in    REVISION_INFO. The revision info will be allocated in b->pool.    Temporaries get allocated on SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_revision_info
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|revision_info_t
modifier|*
modifier|*
name|revision_info
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|r_props
decl_stmt|;
name|svn_string_t
modifier|*
name|cdate
decl_stmt|,
modifier|*
name|author
decl_stmt|;
name|revision_info_t
modifier|*
name|info
decl_stmt|;
comment|/* Try to find the info in the report's cache */
name|info
operator|=
name|apr_hash_get
argument_list|(
name|b
operator|->
name|revision_infos
argument_list|,
operator|&
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
block|{
comment|/* Info is not available, yet.          Get all revprops. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|r_props
argument_list|,
name|b
operator|->
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract the committed-date. */
name|cdate
operator|=
name|svn_hash_gets
argument_list|(
name|r_props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
expr_stmt|;
comment|/* Extract the last-author. */
name|author
operator|=
name|svn_hash_gets
argument_list|(
name|r_props
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
expr_stmt|;
comment|/* Create a result object */
name|info
operator|=
name|apr_palloc
argument_list|(
name|b
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|rev
operator|=
name|rev
expr_stmt|;
name|info
operator|->
name|date
operator|=
name|cdate
condition|?
name|svn_string_dup
argument_list|(
name|cdate
argument_list|,
name|b
operator|->
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|info
operator|->
name|author
operator|=
name|author
condition|?
name|svn_string_dup
argument_list|(
name|author
argument_list|,
name|b
operator|->
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* Cache it */
name|apr_hash_set
argument_list|(
name|b
operator|->
name|revision_infos
argument_list|,
operator|&
name|info
operator|->
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
operator|*
name|revision_info
operator|=
name|info
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Generate the appropriate property editing calls to turn the    properties of S_REV/S_PATH into those of B->t_root/T_PATH.  If    S_PATH is NULL, this is an add, so assume the target starts with no    properties.  Pass OBJECT on to the editor function wrapper    CHANGE_FN. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_proplists
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|svn_revnum_t
name|s_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|s_path
parameter_list|,
specifier|const
name|char
modifier|*
name|t_path
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|proplist_change_fn_t
modifier|*
name|change_fn
parameter_list|,
name|void
modifier|*
name|object
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|s_root
decl_stmt|;
name|apr_hash_t
modifier|*
name|s_props
init|=
name|NULL
decl_stmt|,
modifier|*
name|t_props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|prop_diffs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_revnum_t
name|crev
decl_stmt|;
name|revision_info_t
modifier|*
name|revision_info
decl_stmt|;
name|svn_boolean_t
name|changed
decl_stmt|;
specifier|const
name|svn_prop_t
modifier|*
name|pc
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Fetch the created-rev and send entry props. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_created_rev
argument_list|(
operator|&
name|crev
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|crev
argument_list|)
condition|)
block|{
comment|/* convert committed-rev to  string */
name|char
name|buf
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
name|svn_string_t
name|cr_str
decl_stmt|;
name|cr_str
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|cr_str
operator|.
name|len
operator|=
name|svn__i64toa
argument_list|(
name|buf
argument_list|,
name|crev
argument_list|)
expr_stmt|;
comment|/* Transmit the committed-rev. */
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|b
argument_list|,
name|object
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|,
operator|&
name|cr_str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_revision_info
argument_list|(
name|b
argument_list|,
name|crev
argument_list|,
operator|&
name|revision_info
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Transmit the committed-date. */
if|if
condition|(
name|revision_info
operator|->
name|date
operator|||
name|s_path
condition|)
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|b
argument_list|,
name|object
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|,
name|revision_info
operator|->
name|date
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Transmit the last-author. */
if|if
condition|(
name|revision_info
operator|->
name|author
operator|||
name|s_path
condition|)
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|b
argument_list|,
name|object
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|,
name|revision_info
operator|->
name|author
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Transmit the UUID. */
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|b
argument_list|,
name|object
argument_list|,
name|SVN_PROP_ENTRY_UUID
argument_list|,
name|b
operator|->
name|repos_uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update lock properties. */
if|if
condition|(
name|lock_token
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_get_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|b
operator|->
name|repos
operator|->
name|fs
argument_list|,
name|t_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete a defunct lock. */
if|if
condition|(
operator|!
name|lock
operator|||
name|strcmp
argument_list|(
name|lock_token
argument_list|,
name|lock
operator|->
name|token
argument_list|)
operator|!=
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|b
argument_list|,
name|object
argument_list|,
name|SVN_PROP_ENTRY_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_source_root
argument_list|(
name|b
argument_list|,
operator|&
name|s_root
argument_list|,
name|s_rev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is this deltification worth our time? */
name|SVN_ERR
argument_list|(
name|svn_fs_props_changed
argument_list|(
operator|&
name|changed
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|s_root
argument_list|,
name|s_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If so, go ahead and get the source path's properties. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|s_props
argument_list|,
name|s_root
argument_list|,
name|s_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the target path's properties */
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|t_props
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_props
operator|&&
name|apr_hash_count
argument_list|(
name|s_props
argument_list|)
condition|)
block|{
comment|/* Now transmit the differences. */
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|prop_diffs
argument_list|,
name|t_props
argument_list|,
name|s_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_diffs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|pc
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|prop_diffs
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|b
argument_list|,
name|object
argument_list|,
name|pc
operator|->
name|name
argument_list|,
name|pc
operator|->
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|apr_hash_count
argument_list|(
name|t_props
argument_list|)
condition|)
block|{
comment|/* So source, i.e. all new.  Transmit all target props. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|t_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|b
argument_list|,
name|object
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton type to be passed into send_zero_copy_delta.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zero_copy_baton_t
block|{
comment|/* don't process data larger than this limit */
name|apr_size_t
name|zero_copy_limit
decl_stmt|;
comment|/* window handler and baton to send the data to */
name|svn_txdelta_window_handler_t
name|dhandler
decl_stmt|;
name|void
modifier|*
name|dbaton
decl_stmt|;
comment|/* return value: will be set to TRUE, if the data was processed. */
name|svn_boolean_t
name|zero_copy_succeeded
decl_stmt|;
block|}
name|zero_copy_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Implement svn_fs_process_contents_func_t.  If LEN is smaller than the  * limit given in *BATON, send the CONTENTS as an delta windows to the  * handler given in BATON and set the ZERO_COPY_SUCCEEDED flag in that  * BATON.  Otherwise, reset it to FALSE.  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_zero_copy_delta
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|contents
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|zero_copy_baton_t
modifier|*
name|zero_copy_baton
init|=
name|baton
decl_stmt|;
comment|/* if the item is too large, the caller must revert to traditional      streaming code. */
if|if
condition|(
name|len
operator|>
name|zero_copy_baton
operator|->
name|zero_copy_limit
condition|)
block|{
name|zero_copy_baton
operator|->
name|zero_copy_succeeded
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_contents
argument_list|(
name|contents
argument_list|,
name|len
argument_list|,
name|zero_copy_baton
operator|->
name|dhandler
argument_list|,
name|zero_copy_baton
operator|->
name|dbaton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* all fine now */
name|zero_copy_baton
operator|->
name|zero_copy_succeeded
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make the appropriate edits on FILE_BATON to change its contents and    properties from those in S_REV/S_PATH to those in B->t_root/T_PATH,    possibly using LOCK_TOKEN to determine if the client's lock on the file    is defunct. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_files
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
name|svn_revnum_t
name|s_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|s_path
parameter_list|,
specifier|const
name|char
modifier|*
name|t_path
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|changed
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|s_root
init|=
name|NULL
decl_stmt|;
name|svn_txdelta_stream_t
modifier|*
name|dstream
init|=
name|NULL
decl_stmt|;
name|svn_checksum_t
modifier|*
name|s_checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|s_hex_digest
init|=
name|NULL
decl_stmt|;
name|svn_txdelta_window_handler_t
name|dhandler
decl_stmt|;
name|void
modifier|*
name|dbaton
decl_stmt|;
comment|/* Compare the files' property lists.  */
name|SVN_ERR
argument_list|(
name|delta_proplists
argument_list|(
name|b
argument_list|,
name|s_rev
argument_list|,
name|s_path
argument_list|,
name|t_path
argument_list|,
name|lock_token
argument_list|,
name|change_file_prop
argument_list|,
name|file_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_source_root
argument_list|(
name|b
argument_list|,
operator|&
name|s_root
argument_list|,
name|s_rev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're not interested in the theoretical difference between "has          contents which have not changed with respect to" and "has the same          actual contents as" when sending text-deltas.  If we know the          delta is an empty one, we avoiding sending it in either case. */
name|SVN_ERR
argument_list|(
name|svn_repos__compare_files
argument_list|(
operator|&
name|changed
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|s_root
argument_list|,
name|s_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|s_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|s_root
argument_list|,
name|s_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|s_hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|s_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Send the delta stream if desired, or just a NULL window if not. */
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|file_baton
argument_list|,
name|s_hex_digest
argument_list|,
name|pool
argument_list|,
operator|&
name|dhandler
argument_list|,
operator|&
name|dbaton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dhandler
operator|!=
name|svn_delta_noop_window_handler
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|text_deltas
condition|)
block|{
comment|/* if we send deltas against empty streams, we may use our              zero-copy code. */
if|if
condition|(
name|b
operator|->
name|zero_copy_limit
operator|>
literal|0
operator|&&
name|s_path
operator|==
name|NULL
condition|)
block|{
name|zero_copy_baton_t
name|baton
decl_stmt|;
name|svn_boolean_t
name|called
init|=
name|FALSE
decl_stmt|;
name|baton
operator|.
name|zero_copy_limit
operator|=
name|b
operator|->
name|zero_copy_limit
expr_stmt|;
name|baton
operator|.
name|dhandler
operator|=
name|dhandler
expr_stmt|;
name|baton
operator|.
name|dbaton
operator|=
name|dbaton
expr_stmt|;
name|baton
operator|.
name|zero_copy_succeeded
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_try_process_file_contents
argument_list|(
operator|&
name|called
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|send_zero_copy_delta
argument_list|,
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* data has been available and small enough,                  i.e. been processed? */
if|if
condition|(
name|called
operator|&&
name|baton
operator|.
name|zero_copy_succeeded
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_get_file_delta_stream
argument_list|(
operator|&
name|dstream
argument_list|,
name|s_root
argument_list|,
name|s_path
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_txstream
argument_list|(
name|dstream
argument_list|,
name|dhandler
argument_list|,
name|dbaton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|dhandler
argument_list|(
name|NULL
argument_list|,
name|dbaton
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Determine if the user is authorized to view B->t_root/PATH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_auth
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|svn_boolean_t
modifier|*
name|allowed
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|b
operator|->
name|authz_read_func
condition|)
return|return
name|svn_error_trace
argument_list|(
name|b
operator|->
name|authz_read_func
argument_list|(
name|allowed
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|path
argument_list|,
name|b
operator|->
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
operator|*
name|allowed
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a dirent in *ENTRY for the given ROOT and PATH.  We use this to    replace the source or target dirent when a report pathinfo tells us to    change paths or revisions. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fake_dirent
parameter_list|(
specifier|const
name|svn_fs_dirent_t
modifier|*
modifier|*
name|entry
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|ent
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
operator|*
name|entry
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|ent
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### All callers should be updated to pass just one of these              formats */
name|ent
operator|->
name|name
operator|=
operator|(
operator|*
name|path
operator|==
literal|'/'
operator|)
condition|?
name|svn_fspath__basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
else|:
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_id
argument_list|(
operator|&
name|ent
operator|->
name|id
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
operator|*
name|entry
operator|=
name|ent
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given REQUESTED_DEPTH, WC_DEPTH and the current entry's KIND,    determine whether we need to send the whole entry, not just deltas.    Please refer to delta_dirs' docstring for an explanation of the    conditionals below. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_depth_upgrade
parameter_list|(
name|svn_depth_t
name|wc_depth
parameter_list|,
name|svn_depth_t
name|requested_depth
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|)
block|{
if|if
condition|(
name|requested_depth
operator|==
name|svn_depth_unknown
operator|||
name|requested_depth
operator|<=
name|wc_depth
operator|||
name|wc_depth
operator|==
name|svn_depth_immediates
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|&&
name|wc_depth
operator|==
name|svn_depth_files
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
operator|&&
name|wc_depth
operator|==
name|svn_depth_empty
operator|&&
name|requested_depth
operator|==
name|svn_depth_files
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Call the B->editor's add_file() function to create PATH as a child    of PARENT_BATON, returning a new baton in *NEW_FILE_BATON.    However, make an attempt to send 'copyfrom' arguments if they're    available, by examining the closest copy of the original file    O_PATH within B->t_root.  If any copyfrom args are discovered,    return those in *COPYFROM_PATH and *COPYFROM_REV;  otherwise leave    those return args untouched. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file_smartly
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|o_path
parameter_list|,
name|void
modifier|*
modifier|*
name|new_file_baton
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
modifier|*
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* ### TODO:  use a subpool to do this work, clear it at the end? */
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_repos_fs
argument_list|(
name|b
operator|->
name|repos
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|closest_copy_root
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|closest_copy_path
init|=
name|NULL
decl_stmt|;
comment|/* Pre-emptively assume no copyfrom args exist. */
operator|*
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
operator|*
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|send_copyfrom_args
condition|)
block|{
comment|/* Find the destination of the nearest 'copy event' which may have          caused o_path@t_root to exist. svn_fs_closest_copy only returns paths          starting with '/', so make sure o_path always starts with a '/'          too. */
if|if
condition|(
operator|*
name|o_path
operator|!=
literal|'/'
condition|)
name|o_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|o_path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_closest_copy
argument_list|(
operator|&
name|closest_copy_root
argument_list|,
operator|&
name|closest_copy_path
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|o_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|closest_copy_root
operator|!=
name|NULL
condition|)
block|{
comment|/* If the destination of the copy event is the same path as              o_path, then we've found something interesting that should              have 'copyfrom' history. */
if|if
condition|(
name|strcmp
argument_list|(
name|closest_copy_path
argument_list|,
name|o_path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_copied_from
argument_list|(
name|copyfrom_rev
argument_list|,
name|copyfrom_path
argument_list|,
name|closest_copy_root
argument_list|,
name|closest_copy_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|allowed
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copyfrom_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|copyfrom_root
argument_list|,
name|fs
argument_list|,
operator|*
name|copyfrom_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|b
operator|->
name|authz_read_func
argument_list|(
operator|&
name|allowed
argument_list|,
name|copyfrom_root
argument_list|,
operator|*
name|copyfrom_path
argument_list|,
name|b
operator|->
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
condition|)
block|{
operator|*
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
operator|*
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|b
operator|->
name|editor
operator|->
name|add_file
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
operator|*
name|copyfrom_path
argument_list|,
operator|*
name|copyfrom_rev
argument_list|,
name|pool
argument_list|,
name|new_file_baton
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit a series of editing operations to transform a source entry to    a target entry.     S_REV and S_PATH specify the source entry.  S_ENTRY contains the    already-looked-up information about the node-revision existing at    that location.  S_PATH and S_ENTRY may be NULL if the entry does    not exist in the source.  S_PATH may be non-NULL and S_ENTRY may be    NULL if the caller expects INFO to modify the source to an existing    location.     B->t_root and T_PATH specify the target entry.  T_ENTRY contains    the already-looked-up information about the node-revision existing    at that location.  T_PATH and T_ENTRY may be NULL if the entry does    not exist in the target.     DIR_BATON and E_PATH contain the parameters which should be passed    to the editor calls--DIR_BATON for the parent directory baton and    E_PATH for the pathname.  (E_PATH is the anchor-relative working    copy pathname, which may differ from the source and target    pathnames if the report contains a link_path.)     INFO contains the report information for this working copy path, or    NULL if there is none.  This function will internally modify the    source and target entries as appropriate based on the report    information.     WC_DEPTH and REQUESTED_DEPTH are propagated to delta_dirs() if    necessary.  Refer to delta_dirs' docstring to find out what    should happen for various combinations of WC_DEPTH/REQUESTED_DEPTH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_entry
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|svn_revnum_t
name|s_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|s_path
parameter_list|,
specifier|const
name|svn_fs_dirent_t
modifier|*
name|s_entry
parameter_list|,
specifier|const
name|char
modifier|*
name|t_path
parameter_list|,
specifier|const
name|svn_fs_dirent_t
modifier|*
name|t_entry
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|e_path
parameter_list|,
name|path_info_t
modifier|*
name|info
parameter_list|,
name|svn_depth_t
name|wc_depth
parameter_list|,
name|svn_depth_t
name|requested_depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|s_root
decl_stmt|;
name|svn_boolean_t
name|allowed
decl_stmt|,
name|related
decl_stmt|;
name|void
modifier|*
name|new_baton
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex_digest
decl_stmt|;
comment|/* For non-switch operations, follow link_path in the target. */
if|if
condition|(
name|info
operator|&&
name|info
operator|->
name|link_path
operator|&&
operator|!
name|b
operator|->
name|is_switch
condition|)
block|{
name|t_path
operator|=
name|info
operator|->
name|link_path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fake_dirent
argument_list|(
operator|&
name|t_entry
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|&&
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|rev
argument_list|)
condition|)
block|{
comment|/* Delete this entry in the source. */
name|s_path
operator|=
name|NULL
expr_stmt|;
name|s_entry
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|&&
name|s_path
condition|)
block|{
comment|/* Follow the rev and possibly path in this entry. */
name|s_path
operator|=
operator|(
name|info
operator|->
name|link_path
operator|)
condition|?
name|info
operator|->
name|link_path
else|:
name|s_path
expr_stmt|;
name|s_rev
operator|=
name|info
operator|->
name|rev
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_source_root
argument_list|(
name|b
argument_list|,
operator|&
name|s_root
argument_list|,
name|s_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fake_dirent
argument_list|(
operator|&
name|s_entry
argument_list|,
name|s_root
argument_list|,
name|s_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Don't let the report carry us somewhere nonexistent. */
if|if
condition|(
name|s_path
operator|&&
operator|!
name|s_entry
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Working copy path '%s' does not exist in "
literal|"repository"
argument_list|)
argument_list|,
name|e_path
argument_list|)
return|;
comment|/* If the source and target both exist and are of the same kind,      then find out whether they're related.  If they're exactly the      same, then we don't have to do anything (unless the report has      changes to the source).  If we're ignoring ancestry, then any two      nodes of the same type are related enough for us. */
name|related
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|s_entry
operator|&&
name|t_entry
operator|&&
name|s_entry
operator|->
name|kind
operator|==
name|t_entry
operator|->
name|kind
condition|)
block|{
name|int
name|distance
init|=
name|svn_fs_compare_ids
argument_list|(
name|s_entry
operator|->
name|id
argument_list|,
name|t_entry
operator|->
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|==
literal|0
operator|&&
operator|!
name|any_path_info
argument_list|(
name|b
argument_list|,
name|e_path
argument_list|)
operator|&&
operator|(
name|requested_depth
operator|<=
name|wc_depth
operator|||
name|t_entry
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|info
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|start_empty
condition|)
block|{
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|lock_token
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|b
operator|->
name|repos
operator|->
name|fs
argument_list|,
name|t_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|&&
operator|(
name|strcmp
argument_list|(
name|lock
operator|->
name|token
argument_list|,
name|info
operator|->
name|lock_token
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|related
operator|=
operator|(
name|distance
operator|!=
operator|-
literal|1
operator|||
name|b
operator|->
name|ignore_ancestry
operator|)
expr_stmt|;
block|}
comment|/* If there's a source and it's not related to the target, nuke it. */
if|if
condition|(
name|s_entry
operator|&&
operator|!
name|related
condition|)
block|{
name|svn_revnum_t
name|deleted_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_deleted_rev
argument_list|(
name|svn_fs_root_fs
argument_list|(
name|b
operator|->
name|t_root
argument_list|)
argument_list|,
name|t_path
argument_list|,
name|s_rev
argument_list|,
name|b
operator|->
name|t_rev
argument_list|,
operator|&
name|deleted_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|deleted_rev
argument_list|)
condition|)
block|{
comment|/* Two possibilities: either the thing doesn't exist in S_REV; or              it wasn't deleted between S_REV and B->T_REV.  In the first case,              I think we should leave DELETED_REV as SVN_INVALID_REVNUM, but              in the second, it should be set to B->T_REV-1 for the call to              delete_entry() below. */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
condition|)
name|deleted_rev
operator|=
name|b
operator|->
name|t_rev
operator|-
literal|1
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|delete_entry
argument_list|(
name|e_path
argument_list|,
name|deleted_rev
argument_list|,
name|dir_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|s_path
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If there's no target, we have nothing more to do. */
if|if
condition|(
operator|!
name|t_entry
condition|)
return|return
name|svn_error_trace
argument_list|(
name|skip_path_info
argument_list|(
name|b
argument_list|,
name|e_path
argument_list|)
argument_list|)
return|;
comment|/* Check if the user is authorized to find out about the target. */
name|SVN_ERR
argument_list|(
name|check_auth
argument_list|(
name|b
argument_list|,
operator|&
name|allowed
argument_list|,
name|t_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
condition|)
block|{
if|if
condition|(
name|t_entry
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|absent_directory
argument_list|(
name|e_path
argument_list|,
name|dir_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|absent_file
argument_list|(
name|e_path
argument_list|,
name|dir_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|skip_path_info
argument_list|(
name|b
argument_list|,
name|e_path
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|t_entry
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
name|related
condition|)
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|open_directory
argument_list|(
name|e_path
argument_list|,
name|dir_baton
argument_list|,
name|s_rev
argument_list|,
name|pool
argument_list|,
operator|&
name|new_baton
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|add_directory
argument_list|(
name|e_path
argument_list|,
name|dir_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
operator|&
name|new_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delta_dirs
argument_list|(
name|b
argument_list|,
name|s_rev
argument_list|,
name|s_path
argument_list|,
name|t_path
argument_list|,
name|new_baton
argument_list|,
name|e_path
argument_list|,
name|info
condition|?
name|info
operator|->
name|start_empty
else|:
name|FALSE
argument_list|,
name|wc_depth
argument_list|,
name|requested_depth
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|b
operator|->
name|editor
operator|->
name|close_directory
argument_list|(
name|new_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|related
condition|)
block|{
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|open_file
argument_list|(
name|e_path
argument_list|,
name|dir_baton
argument_list|,
name|s_rev
argument_list|,
name|pool
argument_list|,
operator|&
name|new_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delta_files
argument_list|(
name|b
argument_list|,
name|new_baton
argument_list|,
name|s_rev
argument_list|,
name|s_path
argument_list|,
name|t_path
argument_list|,
name|info
condition|?
name|info
operator|->
name|lock_token
else|:
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_revnum_t
name|copyfrom_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|add_file_smartly
argument_list|(
name|b
argument_list|,
name|e_path
argument_list|,
name|dir_baton
argument_list|,
name|t_path
argument_list|,
operator|&
name|new_baton
argument_list|,
operator|&
name|copyfrom_path
argument_list|,
operator|&
name|copyfrom_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copyfrom_path
condition|)
comment|/* Send txdelta between empty file (s_path@s_rev doesn't                exist) and added file (t_path@t_root). */
name|SVN_ERR
argument_list|(
name|delta_files
argument_list|(
name|b
argument_list|,
name|new_baton
argument_list|,
name|s_rev
argument_list|,
name|s_path
argument_list|,
name|t_path
argument_list|,
name|info
condition|?
name|info
operator|->
name|lock_token
else|:
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Send txdelta between copied file (copyfrom_path@copyfrom_rev)                and added file (tpath@t_root). */
name|SVN_ERR
argument_list|(
name|delta_files
argument_list|(
name|b
argument_list|,
name|new_baton
argument_list|,
name|copyfrom_rev
argument_list|,
name|copyfrom_path
argument_list|,
name|t_path
argument_list|,
name|info
condition|?
name|info
operator|->
name|lock_token
else|:
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|b
operator|->
name|editor
operator|->
name|close_file
argument_list|(
name|new_baton
argument_list|,
name|hex_digest
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* A helper macro for when we have to recurse into subdirectories. */
end_comment

begin_define
define|#
directive|define
name|DEPTH_BELOW_HERE
parameter_list|(
name|depth
parameter_list|)
value|((depth) == svn_depth_immediates) ? \                                  svn_depth_empty : (depth)
end_define

begin_comment
comment|/* Emit edits within directory DIR_BATON (with corresponding path    E_PATH) with the changes from the directory S_REV/S_PATH to the    directory B->t_rev/T_PATH.  S_PATH may be NULL if the entry does    not exist in the source.     WC_DEPTH is this path's depth as reported by set_path/link_path.    REQUESTED_DEPTH is derived from the depth set by    svn_repos_begin_report().     When iterating over this directory's entries, the following tables    describe what happens for all possible combinations    of WC_DEPTH/REQUESTED_DEPTH (rows represent WC_DEPTH, columns    represent REQUESTED_DEPTH):     Legend:      X: ignore this entry (it's either below the requested depth, or         if the requested depth is svn_depth_unknown, below the working         copy depth)      o: handle this entry normally      U: handle the entry as if it were a newly added repository path         (the client is upgrading to a deeper wc and doesn't currently         have this entry, but it should be there after the upgrade, so we         need to send the whole thing, not just deltas)                                For files:    ______________________________________________________________    | req. depth| unknown | empty | files | immediates | infinity |    |wc. depth  |         |       |       |            |          |    |___________|_________|_______|_______|____________|__________|    |empty      |    X    |   X   |   U   |     U      |    U     |    |___________|_________|_______|_______|____________|__________|    |files      |    o    |   X   |   o   |     o      |    o     |    |___________|_________|_______|_______|____________|__________|    |immediates |    o    |   X   |   o   |     o      |    o     |    |___________|_________|_______|_______|____________|__________|    |infinity   |    o    |   X   |   o   |     o      |    o     |    |___________|_________|_______|_______|____________|__________|                              For directories:    ______________________________________________________________    | req. depth| unknown | empty | files | immediates | infinity |    |wc. depth  |         |       |       |            |          |    |___________|_________|_______|_______|____________|__________|    |empty      |    X    |   X   |   X   |     U      |    U     |    |___________|_________|_______|_______|____________|__________|    |files      |    X    |   X   |   X   |     U      |    U     |    |___________|_________|_______|_______|____________|__________|    |immediates |    o    |   X   |   X   |     o      |    o     |    |___________|_________|_______|_______|____________|__________|    |infinity   |    o    |   X   |   X   |     o      |    o     |    |___________|_________|_______|_______|____________|__________|     These rules are enforced by the is_depth_upgrade() function and by    various other checks below. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_dirs
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|svn_revnum_t
name|s_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|s_path
parameter_list|,
specifier|const
name|char
modifier|*
name|t_path
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|e_path
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
name|svn_depth_t
name|wc_depth
parameter_list|,
name|svn_depth_t
name|requested_depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|s_root
decl_stmt|;
name|apr_hash_t
modifier|*
name|s_entries
init|=
name|NULL
decl_stmt|,
modifier|*
name|t_entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|s_fullpath
decl_stmt|,
modifier|*
name|t_fullpath
decl_stmt|,
modifier|*
name|e_fullpath
decl_stmt|;
name|path_info_t
modifier|*
name|info
decl_stmt|;
comment|/* Compare the property lists.  If we're starting empty, pass a NULL      source path so that we add all the properties.       When we support directory locks, we must pass the lock token here. */
name|SVN_ERR
argument_list|(
name|delta_proplists
argument_list|(
name|b
argument_list|,
name|s_rev
argument_list|,
name|start_empty
condition|?
name|NULL
else|:
name|s_path
argument_list|,
name|t_path
argument_list|,
name|NULL
argument_list|,
name|change_dir_prop
argument_list|,
name|dir_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|requested_depth
operator|>
name|svn_depth_empty
operator|||
name|requested_depth
operator|==
name|svn_depth_unknown
condition|)
block|{
comment|/* Get the list of entries in each of source and target. */
if|if
condition|(
name|s_path
operator|&&
operator|!
name|start_empty
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_source_root
argument_list|(
name|b
argument_list|,
operator|&
name|s_root
argument_list|,
name|s_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|s_entries
argument_list|,
name|s_root
argument_list|,
name|s_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|t_entries
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|t_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Iterate over the report information for this directory. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|t_entry
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fetch_path_info
argument_list|(
name|b
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|info
argument_list|,
name|e_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
break|break;
comment|/* Invalid revnum means we should delete, unless this is              just an excluded subpath. */
if|if
condition|(
name|info
operator|&&
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|rev
argument_list|)
operator|&&
name|info
operator|->
name|depth
operator|!=
name|svn_depth_exclude
condition|)
block|{
comment|/* We want to perform deletes before non-replacement adds,                  for graceful handling of case-only renames on                  case-insensitive client filesystems.  So, if the report                  item is a delete, remove the entry from the source hash,                  but don't update the entry yet. */
if|if
condition|(
name|s_entries
condition|)
name|svn_hash_sets
argument_list|(
name|s_entries
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|e_fullpath
operator|=
name|svn_relpath_join
argument_list|(
name|e_path
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|t_fullpath
operator|=
name|svn_fspath__join
argument_list|(
name|t_path
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|t_entry
operator|=
name|svn_hash_gets
argument_list|(
name|t_entries
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s_fullpath
operator|=
name|s_path
condition|?
name|svn_fspath__join
argument_list|(
name|s_path
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|s_entry
operator|=
name|s_entries
condition|?
name|svn_hash_gets
argument_list|(
name|s_entries
argument_list|,
name|name
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* The only special cases here are               - When requested_depth is files but the reported path is              a directory.  This is technically a client error, but we              handle it anyway, by skipping the entry.               - When the reported depth is svn_depth_exclude.           */
if|if
condition|(
operator|(
operator|!
name|info
operator|||
name|info
operator|->
name|depth
operator|!=
name|svn_depth_exclude
operator|)
operator|&&
operator|(
name|requested_depth
operator|!=
name|svn_depth_files
operator|||
operator|(
operator|(
operator|!
name|t_entry
operator|||
name|t_entry
operator|->
name|kind
operator|!=
name|svn_node_dir
operator|)
operator|&&
operator|(
operator|!
name|s_entry
operator|||
name|s_entry
operator|->
name|kind
operator|!=
name|svn_node_dir
operator|)
operator|)
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|update_entry
argument_list|(
name|b
argument_list|,
name|s_rev
argument_list|,
name|s_fullpath
argument_list|,
name|s_entry
argument_list|,
name|t_fullpath
argument_list|,
name|t_entry
argument_list|,
name|dir_baton
argument_list|,
name|e_fullpath
argument_list|,
name|info
argument_list|,
name|info
condition|?
name|info
operator|->
name|depth
else|:
name|DEPTH_BELOW_HERE
argument_list|(
name|wc_depth
argument_list|)
argument_list|,
name|DEPTH_BELOW_HERE
argument_list|(
name|requested_depth
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't revisit this name in the target or source entries. */
name|svn_hash_sets
argument_list|(
name|t_entries
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_entries
comment|/* Keep the entry for later process if it is reported as                  excluded and got deleted in repos. */
operator|&&
operator|(
operator|!
name|info
operator|||
name|info
operator|->
name|depth
operator|!=
name|svn_depth_exclude
operator|||
name|t_entry
operator|)
condition|)
name|svn_hash_sets
argument_list|(
name|s_entries
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* pathinfo entries live in their own subpools due to lookahead,              so we need to clear each one out as we finish with it. */
if|if
condition|(
name|info
condition|)
name|svn_pool_destroy
argument_list|(
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Remove any deleted entries.  Do this before processing the          target, for graceful handling of case-only renames. */
if|if
condition|(
name|s_entries
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|s_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|s_entry
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|t_entries
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|svn_revnum_t
name|deleted_rev
decl_stmt|;
if|if
condition|(
name|s_entry
operator|->
name|kind
operator|==
name|svn_node_file
operator|&&
name|wc_depth
operator|<
name|svn_depth_files
condition|)
continue|continue;
if|if
condition|(
name|s_entry
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
operator|(
name|wc_depth
operator|<
name|svn_depth_immediates
operator|||
name|requested_depth
operator|==
name|svn_depth_files
operator|)
condition|)
continue|continue;
comment|/* There is no corresponding target entry, so delete. */
name|e_fullpath
operator|=
name|svn_relpath_join
argument_list|(
name|e_path
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_deleted_rev
argument_list|(
name|svn_fs_root_fs
argument_list|(
name|b
operator|->
name|t_root
argument_list|)
argument_list|,
name|svn_fspath__join
argument_list|(
name|t_path
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|s_rev
argument_list|,
name|b
operator|->
name|t_rev
argument_list|,
operator|&
name|deleted_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|delete_entry
argument_list|(
name|e_fullpath
argument_list|,
name|deleted_rev
argument_list|,
name|dir_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Loop over the dirents in the target. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|t_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|t_entry
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|t_entry
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_depth_upgrade
argument_list|(
name|wc_depth
argument_list|,
name|requested_depth
argument_list|,
name|t_entry
operator|->
name|kind
argument_list|)
condition|)
block|{
comment|/* We're making the working copy deeper, pretend the source                  doesn't exist. */
name|s_entry
operator|=
name|NULL
expr_stmt|;
name|s_fullpath
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t_entry
operator|->
name|kind
operator|==
name|svn_node_file
operator|&&
name|requested_depth
operator|==
name|svn_depth_unknown
operator|&&
name|wc_depth
operator|<
name|svn_depth_files
condition|)
continue|continue;
if|if
condition|(
name|t_entry
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
operator|(
name|wc_depth
operator|<
name|svn_depth_immediates
operator|||
name|requested_depth
operator|==
name|svn_depth_files
operator|)
condition|)
continue|continue;
comment|/* Look for an entry with the same name                  in the source dirents. */
name|s_entry
operator|=
name|s_entries
condition|?
name|svn_hash_gets
argument_list|(
name|s_entries
argument_list|,
name|t_entry
operator|->
name|name
argument_list|)
else|:
name|NULL
expr_stmt|;
name|s_fullpath
operator|=
name|s_entry
condition|?
name|svn_fspath__join
argument_list|(
name|s_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
comment|/* Compose the report, editor, and target paths for this entry. */
name|e_fullpath
operator|=
name|svn_relpath_join
argument_list|(
name|e_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|t_fullpath
operator|=
name|svn_fspath__join
argument_list|(
name|t_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|update_entry
argument_list|(
name|b
argument_list|,
name|s_rev
argument_list|,
name|s_fullpath
argument_list|,
name|s_entry
argument_list|,
name|t_fullpath
argument_list|,
name|t_entry
argument_list|,
name|dir_baton
argument_list|,
name|e_fullpath
argument_list|,
name|NULL
argument_list|,
name|DEPTH_BELOW_HERE
argument_list|(
name|wc_depth
argument_list|)
argument_list|,
name|DEPTH_BELOW_HERE
argument_list|(
name|requested_depth
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy iteration subpool. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|drive
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|svn_revnum_t
name|s_rev
parameter_list|,
name|path_info_t
modifier|*
name|info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t_anchor
decl_stmt|,
modifier|*
name|s_fullpath
decl_stmt|;
name|svn_boolean_t
name|allowed
decl_stmt|,
name|info_is_set_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|s_root
decl_stmt|;
specifier|const
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|t_entry
decl_stmt|;
name|void
modifier|*
name|root_baton
decl_stmt|;
comment|/* Compute the target path corresponding to the working copy anchor,      and check its authorization. */
name|t_anchor
operator|=
operator|*
name|b
operator|->
name|s_operand
condition|?
name|svn_fspath__dirname
argument_list|(
name|b
operator|->
name|t_path
argument_list|,
name|pool
argument_list|)
else|:
name|b
operator|->
name|t_path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_auth
argument_list|(
name|b
argument_list|,
operator|&
name|allowed
argument_list|,
name|t_anchor
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_ROOT_UNREADABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Not authorized to open root of edit operation"
argument_list|)
argument_list|)
return|;
comment|/* Collect information about the source and target nodes. */
name|s_fullpath
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_base
argument_list|,
name|b
operator|->
name|s_operand
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_source_root
argument_list|(
name|b
argument_list|,
operator|&
name|s_root
argument_list|,
name|s_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fake_dirent
argument_list|(
operator|&
name|s_entry
argument_list|,
name|s_root
argument_list|,
name|s_fullpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fake_dirent
argument_list|(
operator|&
name|t_entry
argument_list|,
name|b
operator|->
name|t_root
argument_list|,
name|b
operator|->
name|t_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the operand is a locally added file or directory, it won't      exist in the source, so accept that. */
name|info_is_set_path
operator|=
operator|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|rev
argument_list|)
operator|&&
operator|!
name|info
operator|->
name|link_path
operator|)
expr_stmt|;
if|if
condition|(
name|info_is_set_path
operator|&&
operator|!
name|s_entry
condition|)
name|s_fullpath
operator|=
name|NULL
expr_stmt|;
comment|/* Check if the target path exists first.  */
if|if
condition|(
operator|!
operator|*
name|b
operator|->
name|s_operand
operator|&&
operator|!
operator|(
name|t_entry
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PATH_SYNTAX
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Target path '%s' does not exist"
argument_list|)
argument_list|,
name|b
operator|->
name|t_path
argument_list|)
return|;
comment|/* If the anchor is the operand, the source and target must be dirs.      Check this before opening the root to avoid modifying the wc. */
elseif|else
if|if
condition|(
operator|!
operator|*
name|b
operator|->
name|s_operand
operator|&&
operator|(
operator|!
name|s_entry
operator|||
name|s_entry
operator|->
name|kind
operator|!=
name|svn_node_dir
operator|||
name|t_entry
operator|->
name|kind
operator|!=
name|svn_node_dir
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_PATH_SYNTAX
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot replace a directory from within"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|set_target_revision
argument_list|(
name|b
operator|->
name|edit_baton
argument_list|,
name|b
operator|->
name|t_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|b
operator|->
name|editor
operator|->
name|open_root
argument_list|(
name|b
operator|->
name|edit_baton
argument_list|,
name|s_rev
argument_list|,
name|pool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the anchor is the operand, diff the two directories; otherwise      update the operand within the anchor directory. */
if|if
condition|(
operator|!
operator|*
name|b
operator|->
name|s_operand
condition|)
name|SVN_ERR
argument_list|(
name|delta_dirs
argument_list|(
name|b
argument_list|,
name|s_rev
argument_list|,
name|s_fullpath
argument_list|,
name|b
operator|->
name|t_path
argument_list|,
name|root_baton
argument_list|,
literal|""
argument_list|,
name|info
operator|->
name|start_empty
argument_list|,
name|info
operator|->
name|depth
argument_list|,
name|b
operator|->
name|requested_depth
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|update_entry
argument_list|(
name|b
argument_list|,
name|s_rev
argument_list|,
name|s_fullpath
argument_list|,
name|s_entry
argument_list|,
name|b
operator|->
name|t_path
argument_list|,
name|t_entry
argument_list|,
name|root_baton
argument_list|,
name|b
operator|->
name|s_operand
argument_list|,
name|info
argument_list|,
name|info
operator|->
name|depth
argument_list|,
name|b
operator|->
name|requested_depth
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|b
operator|->
name|editor
operator|->
name|close_directory
argument_list|(
name|root_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize the baton fields for editor-driving, and drive the editor. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|finish_report
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|path_info_t
modifier|*
name|info
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|svn_revnum_t
name|s_rev
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Save our pool to manage the lookahead and fs_root cache with. */
name|b
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Add the end marker. */
name|SVN_ERR
argument_list|(
name|svn_spillbuf__reader_write
argument_list|(
name|b
operator|->
name|reader
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the first pathinfo from the report and verify that it is a top-level      set_path entry. */
name|SVN_ERR
argument_list|(
name|read_path_info
argument_list|(
operator|&
name|info
argument_list|,
name|b
operator|->
name|reader
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|||
name|strcmp
argument_list|(
name|info
operator|->
name|path
argument_list|,
name|b
operator|->
name|s_operand
argument_list|)
operator|!=
literal|0
operator|||
name|info
operator|->
name|link_path
operator|||
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|rev
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_BAD_REVISION_REPORT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid report for top level of working copy"
argument_list|)
argument_list|)
return|;
name|s_rev
operator|=
name|info
operator|->
name|rev
expr_stmt|;
comment|/* Initialize the lookahead pathinfo. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_path_info
argument_list|(
operator|&
name|b
operator|->
name|lookahead
argument_list|,
name|b
operator|->
name|reader
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|lookahead
operator|&&
name|strcmp
argument_list|(
name|b
operator|->
name|lookahead
operator|->
name|path
argument_list|,
name|b
operator|->
name|s_operand
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If the operand of the wc operation is switched or deleted,          then info above is just a place-holder, and the only thing we          have to do is pass the revision it contains to open_root.          The next pathinfo actually describes the target. */
if|if
condition|(
operator|!
operator|*
name|b
operator|->
name|s_operand
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_BAD_REVISION_REPORT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Two top-level reports with no target"
argument_list|)
argument_list|)
return|;
comment|/* If the client issued a set-path followed by a delete-path, we need          to respect the depth set by the initial set-path. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|b
operator|->
name|lookahead
operator|->
name|rev
argument_list|)
condition|)
block|{
name|b
operator|->
name|lookahead
operator|->
name|depth
operator|=
name|info
operator|->
name|depth
expr_stmt|;
block|}
name|info
operator|=
name|b
operator|->
name|lookahead
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_path_info
argument_list|(
operator|&
name|b
operator|->
name|lookahead
argument_list|,
name|b
operator|->
name|reader
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Open the target root and initialize the source root cache. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|b
operator|->
name|t_root
argument_list|,
name|b
operator|->
name|repos
operator|->
name|fs
argument_list|,
name|b
operator|->
name|t_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CACHED_SOURCE_ROOTS
condition|;
name|i
operator|++
control|)
name|b
operator|->
name|s_roots
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_trace
argument_list|(
name|drive
argument_list|(
name|b
argument_list|,
name|s_rev
argument_list|,
name|info
argument_list|,
name|pool
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
return|return
name|svn_error_trace
argument_list|(
name|b
operator|->
name|editor
operator|->
name|close_edit
argument_list|(
name|b
operator|->
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|b
operator|->
name|editor
operator|->
name|abort_edit
argument_list|(
name|b
operator|->
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* --- COLLECTING THE REPORT INFORMATION --- */
end_comment

begin_comment
comment|/* Record a report operation into the spill buffer.  Return an error    if DEPTH is svn_depth_unknown. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_path_info
parameter_list|(
name|report_baton_t
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|lpath
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|lrep
decl_stmt|,
modifier|*
name|rrep
decl_stmt|,
modifier|*
name|drep
decl_stmt|,
modifier|*
name|ltrep
decl_stmt|,
modifier|*
name|rep
decl_stmt|;
comment|/* Munge the path to be anchor-relative, so that we can use edit paths      as report paths. */
name|path
operator|=
name|svn_relpath_join
argument_list|(
name|b
operator|->
name|s_operand
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|lrep
operator|=
name|lpath
condition|?
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"+%"
name|APR_SIZE_T_FMT
literal|":%s"
argument_list|,
name|strlen
argument_list|(
name|lpath
argument_list|)
argument_list|,
name|lpath
argument_list|)
else|:
literal|"-"
expr_stmt|;
name|rrep
operator|=
operator|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
operator|)
condition|?
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"+%ld:"
argument_list|,
name|rev
argument_list|)
else|:
literal|"-"
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_exclude
condition|)
name|drep
operator|=
literal|"+X"
expr_stmt|;
elseif|else
if|if
condition|(
name|depth
operator|==
name|svn_depth_empty
condition|)
name|drep
operator|=
literal|"+E"
expr_stmt|;
elseif|else
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
condition|)
name|drep
operator|=
literal|"+F"
expr_stmt|;
elseif|else
if|if
condition|(
name|depth
operator|==
name|svn_depth_immediates
condition|)
name|drep
operator|=
literal|"+M"
expr_stmt|;
elseif|else
if|if
condition|(
name|depth
operator|==
name|svn_depth_infinity
condition|)
name|drep
operator|=
literal|"-"
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported report depth '%s'"
argument_list|)
argument_list|,
name|svn_depth_to_word
argument_list|(
name|depth
argument_list|)
argument_list|)
return|;
name|ltrep
operator|=
name|lock_token
condition|?
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"+%"
name|APR_SIZE_T_FMT
literal|":%s"
argument_list|,
name|strlen
argument_list|(
name|lock_token
argument_list|)
argument_list|,
name|lock_token
argument_list|)
else|:
literal|"-"
expr_stmt|;
name|rep
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"+%"
name|APR_SIZE_T_FMT
literal|":%s%s%s%s%c%s"
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|,
name|path
argument_list|,
name|lrep
argument_list|,
name|rrep
argument_list|,
name|drep
argument_list|,
name|start_empty
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
name|ltrep
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_spillbuf__reader_write
argument_list|(
name|b
operator|->
name|reader
argument_list|,
name|rep
argument_list|,
name|strlen
argument_list|(
name|rep
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_set_path3
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|write_path_info
argument_list|(
name|baton
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_link_path3
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|link_path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
name|svn_depth_exclude
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Depth 'exclude' not supported for link"
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|write_path_info
argument_list|(
name|baton
argument_list|,
name|path
argument_list|,
name|link_path
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_delete_path
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* We pass svn_depth_infinity because deletion of a path always      deletes everything underneath it. */
return|return
name|svn_error_trace
argument_list|(
name|write_path_info
argument_list|(
name|baton
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_finish_report
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|finish_report
argument_list|(
name|b
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_abort_report
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- BEGINNING THE REPORT --- */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_begin_report3
parameter_list|(
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revnum
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_base
parameter_list|,
specifier|const
name|char
modifier|*
name|s_operand
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_path
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_size_t
name|zero_copy_limit
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_baton_t
modifier|*
name|b
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_exclude
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Request depth 'exclude' not supported"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_uuid
argument_list|(
name|repos
operator|->
name|fs
argument_list|,
operator|&
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build a reporter baton.  Copy strings in case the caller doesn't      keep track of them. */
name|b
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|repos
operator|=
name|repos
expr_stmt|;
name|b
operator|->
name|fs_base
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|fs_base
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|s_operand
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|s_operand
argument_list|)
expr_stmt|;
name|b
operator|->
name|t_rev
operator|=
name|revnum
expr_stmt|;
name|b
operator|->
name|t_path
operator|=
name|switch_path
condition|?
name|svn_fspath__canonicalize
argument_list|(
name|switch_path
argument_list|,
name|pool
argument_list|)
else|:
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_base
argument_list|,
name|s_operand
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|text_deltas
operator|=
name|text_deltas
expr_stmt|;
name|b
operator|->
name|zero_copy_limit
operator|=
name|zero_copy_limit
expr_stmt|;
name|b
operator|->
name|requested_depth
operator|=
name|depth
expr_stmt|;
name|b
operator|->
name|ignore_ancestry
operator|=
name|ignore_ancestry
expr_stmt|;
name|b
operator|->
name|send_copyfrom_args
operator|=
name|send_copyfrom_args
expr_stmt|;
name|b
operator|->
name|is_switch
operator|=
operator|(
name|switch_path
operator|!=
name|NULL
operator|)
expr_stmt|;
name|b
operator|->
name|editor
operator|=
name|editor
expr_stmt|;
name|b
operator|->
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|b
operator|->
name|authz_read_func
operator|=
name|authz_read_func
expr_stmt|;
name|b
operator|->
name|authz_read_baton
operator|=
name|authz_read_baton
expr_stmt|;
name|b
operator|->
name|revision_infos
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|b
operator|->
name|reader
operator|=
name|svn_spillbuf__reader_create
argument_list|(
literal|1000
comment|/* blocksize */
argument_list|,
literal|1000000
comment|/* maxsize */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|repos_uuid
operator|=
name|svn_string_create
argument_list|(
name|uuid
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Hand reporter back to client. */
operator|*
name|report_baton
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

