begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * delta.c:   an editor driver for expressing differences between two trees  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* THINGS TODO:  Currently the code herein gives only a slight nod to    fully supporting directory deltas that involve renames, copies, and    such.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Some datatypes and declarations used throughout the file.  */
end_comment

begin_comment
comment|/* Parameters which remain constant throughout a delta traversal.    At the top of the recursion, we initialize one of these structures.    Then we pass it down to every call.  This way, functions invoked    deep in the recursion can get access to this traversal's global    parameters, without using global variables.  */
end_comment

begin_struct
struct|struct
name|context
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
specifier|const
name|char
modifier|*
name|edit_base_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|source_root
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|target_root
decl_stmt|;
name|svn_repos_authz_func_t
name|authz_read_func
decl_stmt|;
name|void
modifier|*
name|authz_read_baton
decl_stmt|;
name|svn_boolean_t
name|text_deltas
decl_stmt|;
name|svn_boolean_t
name|entry_props
decl_stmt|;
name|svn_boolean_t
name|ignore_ancestry
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The type of a function that accepts changes to an object's property    list.  OBJECT is the object whose properties are being changed.    NAME is the name of the property to change.  VALUE is the new value    for the property, or zero if the property should be deleted.  */
end_comment

begin_typedef
typedef|typedef
name|svn_error_t
modifier|*
name|proplist_change_fn_t
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Some prototypes for functions used throughout.  See each individual    function for information about what it does.  */
end_comment

begin_comment
comment|/* Retrieving the base revision from the path/revision hash.  */
end_comment

begin_function_decl
specifier|static
name|svn_revnum_t
name|get_path_revision
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* proplist_change_fn_t property changing functions.  */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Constructing deltas for properties of files and directories.  */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|delta_proplists
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|proplist_change_fn_t
modifier|*
name|change_fn
parameter_list|,
name|void
modifier|*
name|object
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Constructing deltas for file constents.  */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|send_text_delta
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|delta_files
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Generic directory deltafication routines.  */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|delete
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|add_file_or_dir
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|svn_node_kind_t
name|tgt_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|replace_file_or_dir
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|svn_node_kind_t
name|tgt_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|absent_file_or_dir
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|svn_node_kind_t
name|tgt_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|delta_dirs
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAYBE_DEMOTE_DEPTH
parameter_list|(
name|depth
parameter_list|)
define|\
value|(((depth) == svn_depth_immediates || (depth) == svn_depth_files) \    ? svn_depth_empty                                               \    : (depth))
end_define

begin_escape
end_escape

begin_comment
comment|/* Return the error 'SVN_ERR_AUTHZ_ROOT_UNREADABLE' if PATH in ROOT is  * unreadable according to AUTHZ_READ_FUNC with AUTHZ_READ_BATON.  *  * PATH should be the implicit root path of an editor drive, that is,  * the path used by editor->open_root().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|authz_root_check
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|allowed
decl_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|allowed
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_ROOT_UNREADABLE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Unable to open root of edit"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Public interface to computing directory deltas.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_dir_delta2
parameter_list|(
name|svn_fs_root_t
modifier|*
name|src_root
parameter_list|,
specifier|const
name|char
modifier|*
name|src_parent_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|src_entry
parameter_list|,
name|svn_fs_root_t
modifier|*
name|tgt_root
parameter_list|,
specifier|const
name|char
modifier|*
name|tgt_fullpath
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|entry_props
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|void
modifier|*
name|root_baton
init|=
name|NULL
decl_stmt|;
name|struct
name|context
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_fullpath
decl_stmt|;
name|svn_node_kind_t
name|src_kind
decl_stmt|,
name|tgt_kind
decl_stmt|;
name|svn_revnum_t
name|rootrev
decl_stmt|;
name|svn_fs_node_relation_t
name|relation
decl_stmt|;
specifier|const
name|char
modifier|*
name|authz_root_path
decl_stmt|;
comment|/* SRC_PARENT_DIR must be valid. */
if|if
condition|(
name|src_parent_dir
condition|)
name|src_parent_dir
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|src_parent_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
literal|0
argument_list|,
literal|"Invalid source parent directory '(null)'"
argument_list|)
return|;
comment|/* TGT_FULLPATH must be valid. */
if|if
condition|(
name|tgt_fullpath
condition|)
name|tgt_fullpath
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|tgt_fullpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_PATH_SYNTAX
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Invalid target path"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_exclude
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Delta depth 'exclude' not supported"
argument_list|)
argument_list|)
return|;
comment|/* Calculate the fs path implicitly used for editor->open_root, so      we can do an authz check on that path first. */
if|if
condition|(
operator|*
name|src_entry
condition|)
name|authz_root_path
operator|=
name|svn_relpath_dirname
argument_list|(
name|tgt_fullpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|authz_root_path
operator|=
name|tgt_fullpath
expr_stmt|;
comment|/* Construct the full path of the source item. */
name|src_fullpath
operator|=
name|svn_relpath_join
argument_list|(
name|src_parent_dir
argument_list|,
name|src_entry
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Get the node kinds for the source and target paths.  */
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|tgt_kind
argument_list|,
name|tgt_root
argument_list|,
name|tgt_fullpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|src_kind
argument_list|,
name|src_root
argument_list|,
name|src_fullpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If neither of our paths exists, we don't really have anything to do. */
if|if
condition|(
operator|(
name|tgt_kind
operator|==
name|svn_node_none
operator|)
operator|&&
operator|(
name|src_kind
operator|==
name|svn_node_none
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* If either the source or the target is a non-directory, we      require that a SRC_ENTRY be supplied. */
if|if
condition|(
operator|(
operator|!
operator|*
name|src_entry
operator|)
operator|&&
operator|(
operator|(
name|src_kind
operator|!=
name|svn_node_dir
operator|)
operator|||
name|tgt_kind
operator|!=
name|svn_node_dir
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_PATH_SYNTAX
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Invalid editor anchoring; at least one of the "
literal|"input paths is not a directory and there was no source entry"
argument_list|)
argument_list|)
return|;
comment|/* Set the global target revision if one can be determined. */
if|if
condition|(
name|svn_fs_is_revision_root
argument_list|(
name|tgt_root
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|set_target_revision
argument_list|(
name|edit_baton
argument_list|,
name|svn_fs_revision_root_revision
argument_list|(
name|tgt_root
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svn_fs_is_txn_root
argument_list|(
name|tgt_root
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|set_target_revision
argument_list|(
name|edit_baton
argument_list|,
name|svn_fs_txn_root_base_revision
argument_list|(
name|tgt_root
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Setup our pseudo-global structure here.  We need these variables      throughout the deltafication process, so pass them around by      reference to all the helper functions. */
name|c
operator|.
name|editor
operator|=
name|editor
expr_stmt|;
name|c
operator|.
name|source_root
operator|=
name|src_root
expr_stmt|;
name|c
operator|.
name|target_root
operator|=
name|tgt_root
expr_stmt|;
name|c
operator|.
name|authz_read_func
operator|=
name|authz_read_func
expr_stmt|;
name|c
operator|.
name|authz_read_baton
operator|=
name|authz_read_baton
expr_stmt|;
name|c
operator|.
name|text_deltas
operator|=
name|text_deltas
expr_stmt|;
name|c
operator|.
name|entry_props
operator|=
name|entry_props
expr_stmt|;
name|c
operator|.
name|ignore_ancestry
operator|=
name|ignore_ancestry
expr_stmt|;
comment|/* Get our editor root's revision. */
name|rootrev
operator|=
name|get_path_revision
argument_list|(
name|src_root
argument_list|,
name|src_parent_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If one or the other of our paths doesn't exist, we have to handle      those cases specially. */
if|if
condition|(
name|tgt_kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* Caller thinks that target still exists, but it doesn't.          So transform their source path to "nothing" by deleting it. */
name|SVN_ERR
argument_list|(
name|authz_root_check
argument_list|(
name|tgt_root
argument_list|,
name|authz_root_path
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|edit_baton
argument_list|,
name|rootrev
argument_list|,
name|pool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delete
argument_list|(
operator|&
name|c
argument_list|,
name|root_baton
argument_list|,
name|src_entry
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|src_kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* The source path no longer exists, but the target does.          So transform "nothing" into "something" by adding. */
name|SVN_ERR
argument_list|(
name|authz_root_check
argument_list|(
name|tgt_root
argument_list|,
name|authz_root_path
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|edit_baton
argument_list|,
name|rootrev
argument_list|,
name|pool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_file_or_dir
argument_list|(
operator|&
name|c
argument_list|,
name|root_baton
argument_list|,
name|depth
argument_list|,
name|tgt_fullpath
argument_list|,
name|src_entry
argument_list|,
name|tgt_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Get and compare the node IDs for the source and target. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_relation
argument_list|(
operator|&
name|relation
argument_list|,
name|tgt_root
argument_list|,
name|tgt_fullpath
argument_list|,
name|src_root
argument_list|,
name|src_fullpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relation
operator|==
name|svn_fs_node_unchanged
condition|)
block|{
comment|/* They are the same node!  No-op (you gotta love those). */
goto|goto
name|cleanup
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|src_entry
condition|)
block|{
comment|/* If the nodes have different kinds, we must delete the one and          add the other.  Also, if they are completely unrelated and          our caller is interested in relatedness, we do the same thing. */
if|if
condition|(
operator|(
name|src_kind
operator|!=
name|tgt_kind
operator|)
operator|||
operator|(
operator|(
name|relation
operator|==
name|svn_fs_node_unrelated
operator|)
operator|&&
operator|(
operator|!
name|ignore_ancestry
operator|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|authz_root_check
argument_list|(
name|tgt_root
argument_list|,
name|authz_root_path
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|edit_baton
argument_list|,
name|rootrev
argument_list|,
name|pool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delete
argument_list|(
operator|&
name|c
argument_list|,
name|root_baton
argument_list|,
name|src_entry
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_file_or_dir
argument_list|(
operator|&
name|c
argument_list|,
name|root_baton
argument_list|,
name|depth
argument_list|,
name|tgt_fullpath
argument_list|,
name|src_entry
argument_list|,
name|tgt_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we just replace the one with the other. */
else|else
block|{
name|SVN_ERR
argument_list|(
name|authz_root_check
argument_list|(
name|tgt_root
argument_list|,
name|authz_root_path
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|edit_baton
argument_list|,
name|rootrev
argument_list|,
name|pool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|replace_file_or_dir
argument_list|(
operator|&
name|c
argument_list|,
name|root_baton
argument_list|,
name|depth
argument_list|,
name|src_fullpath
argument_list|,
name|tgt_fullpath
argument_list|,
name|src_entry
argument_list|,
name|tgt_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is no entry given, so delta the whole parent directory. */
name|SVN_ERR
argument_list|(
name|authz_root_check
argument_list|(
name|tgt_root
argument_list|,
name|authz_root_path
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|edit_baton
argument_list|,
name|rootrev
argument_list|,
name|pool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delta_dirs
argument_list|(
operator|&
name|c
argument_list|,
name|root_baton
argument_list|,
name|depth
argument_list|,
name|src_fullpath
argument_list|,
name|tgt_fullpath
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
comment|/* Make sure we close the root directory if we opened one above. */
if|if
condition|(
name|root_baton
condition|)
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_directory
argument_list|(
name|root_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close the edit. */
return|return
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Retrieving the base revision from the path/revision hash.  */
end_comment

begin_function
specifier|static
name|svn_revnum_t
name|get_path_revision
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Easy out -- if ROOT is a revision root, we can use the revision      that it's a root of. */
if|if
condition|(
name|svn_fs_is_revision_root
argument_list|(
name|root
argument_list|)
condition|)
return|return
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
return|;
comment|/* Else, this must be a transaction root, so ask the filesystem in      what revision this path was created. */
if|if
condition|(
operator|(
name|err
operator|=
name|svn_fs_node_created_rev
argument_list|(
operator|&
name|revision
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't get back a valid revision, this path is mutable in      the transaction.  We should probably examine the node on which it      is based, doable by querying for the node-id of the path, and      then examining that node-id's predecessor.  ### This predecessor      determination isn't exposed via the FS public API right now, so      for now, we'll just return the SVN_INVALID_REVNUM. */
return|return
name|revision
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* proplist_change_fn_t property changing functions.  */
end_comment

begin_comment
comment|/* Call the directory property-setting function of C->editor to set    the property NAME to given VALUE on the OBJECT passed to this    function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|c
operator|->
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|object
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call the file property-setting function of C->editor to set the    property NAME to given VALUE on the OBJECT passed to this    function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|c
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|object
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Constructing deltas for properties of files and directories.  */
end_comment

begin_comment
comment|/* Generate the appropriate property editing calls to turn the    properties of SOURCE_PATH into those of TARGET_PATH.  If    SOURCE_PATH is NULL, this is an add, so assume the target starts    with no properties.  Pass OBJECT on to the editor function wrapper    CHANGE_FN. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_proplists
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|proplist_change_fn_t
modifier|*
name|change_fn
parameter_list|,
name|void
modifier|*
name|object
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|s_props
init|=
literal|0
decl_stmt|;
name|apr_hash_t
modifier|*
name|t_props
init|=
literal|0
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|apr_array_header_t
modifier|*
name|prop_diffs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|target_path
argument_list|)
expr_stmt|;
comment|/* Make a subpool for local allocations. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* If we're supposed to send entry props for all non-deleted items,      here we go! */
if|if
condition|(
name|c
operator|->
name|entry_props
condition|)
block|{
name|svn_revnum_t
name|committed_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_string_t
modifier|*
name|cr_str
init|=
name|NULL
decl_stmt|;
name|svn_string_t
modifier|*
name|committed_date
init|=
name|NULL
decl_stmt|;
name|svn_string_t
modifier|*
name|last_author
init|=
name|NULL
decl_stmt|;
comment|/* Get the CR and two derivative props. ### check for error returns. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_created_rev
argument_list|(
operator|&
name|committed_rev
argument_list|,
name|c
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|committed_rev
argument_list|)
condition|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_root_fs
argument_list|(
name|c
operator|->
name|target_root
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|r_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
comment|/* Transmit the committed-rev. */
name|cr_str
operator|=
name|svn_string_createf
argument_list|(
name|subpool
argument_list|,
literal|"%ld"
argument_list|,
name|committed_rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|c
argument_list|,
name|object
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|,
name|cr_str
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|r_props
argument_list|,
name|fs
argument_list|,
name|committed_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Transmit the committed-date. */
name|committed_date
operator|=
name|svn_hash_gets
argument_list|(
name|r_props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|committed_date
operator|||
name|source_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|c
argument_list|,
name|object
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|,
name|committed_date
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Transmit the last-author. */
name|last_author
operator|=
name|svn_hash_gets
argument_list|(
name|r_props
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_author
operator|||
name|source_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|c
argument_list|,
name|object
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|,
name|last_author
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Transmit the UUID. */
name|SVN_ERR
argument_list|(
name|svn_fs_get_uuid
argument_list|(
name|fs
argument_list|,
operator|&
name|uuid
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|c
argument_list|,
name|object
argument_list|,
name|SVN_PROP_ENTRY_UUID
argument_list|,
name|svn_string_create
argument_list|(
name|uuid
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|source_path
condition|)
block|{
name|svn_boolean_t
name|changed
decl_stmt|;
comment|/* Is this deltification worth our time? */
name|SVN_ERR
argument_list|(
name|svn_fs_props_different
argument_list|(
operator|&
name|changed
argument_list|,
name|c
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|c
operator|->
name|source_root
argument_list|,
name|source_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
goto|goto
name|cleanup
goto|;
comment|/* If so, go ahead and get the source path's properties. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|s_props
argument_list|,
name|c
operator|->
name|source_root
argument_list|,
name|source_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_props
operator|=
name|apr_hash_make
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* Get the target path's properties */
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|t_props
argument_list|,
name|c
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now transmit the differences. */
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|prop_diffs
argument_list|,
name|t_props
argument_list|,
name|s_props
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_diffs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|pc
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|prop_diffs
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|change_fn
argument_list|(
name|c
argument_list|,
name|object
argument_list|,
name|pc
operator|->
name|name
argument_list|,
name|pc
operator|->
name|value
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
comment|/* Destroy local subpool. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Constructing deltas for file contents.  */
end_comment

begin_comment
comment|/* Change the contents of FILE_BATON in C->editor, according to the    text delta from DELTA_STREAM.  Pass BASE_CHECKSUM along to    C->editor->apply_textdelta. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_text_delta
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_window_handler_t
name|delta_handler
decl_stmt|;
name|void
modifier|*
name|delta_handler_baton
decl_stmt|;
comment|/* Get a handler that will apply the delta to the file.  */
name|SVN_ERR
argument_list|(
name|c
operator|->
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|file_baton
argument_list|,
name|base_checksum
argument_list|,
name|pool
argument_list|,
operator|&
name|delta_handler
argument_list|,
operator|&
name|delta_handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|text_deltas
operator|&&
name|delta_stream
condition|)
block|{
comment|/* Deliver the delta stream to the file.  */
return|return
name|svn_txdelta_send_txstream
argument_list|(
name|delta_stream
argument_list|,
name|delta_handler
argument_list|,
name|delta_handler_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
else|else
block|{
comment|/* The caller doesn't want text delta data.  Just send a single          NULL window. */
return|return
name|delta_handler
argument_list|(
name|NULL
argument_list|,
name|delta_handler_baton
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__compare_files
parameter_list|(
name|svn_boolean_t
modifier|*
name|changed_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root1
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root2
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_fs_contents_different
argument_list|(
name|changed_p
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make the appropriate edits on FILE_BATON to change its contents and    properties from those in SOURCE_PATH to those in TARGET_PATH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_files
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|svn_boolean_t
name|changed
init|=
name|TRUE
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|target_path
argument_list|)
expr_stmt|;
comment|/* Make a subpool for local allocations. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Compare the files' property lists.  */
name|SVN_ERR
argument_list|(
name|delta_proplists
argument_list|(
name|c
argument_list|,
name|source_path
argument_list|,
name|target_path
argument_list|,
name|change_file_prop
argument_list|,
name|file_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_contents_different
argument_list|(
operator|&
name|changed
argument_list|,
name|c
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|c
operator|->
name|source_root
argument_list|,
name|source_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If there isn't a source path, this is an add, which          necessarily has textual mods. */
block|}
comment|/* If there is a change, and the context indicates that we should      care about it, then hand it off to a delta stream.  */
if|if
condition|(
name|changed
condition|)
block|{
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
init|=
name|NULL
decl_stmt|;
name|svn_checksum_t
modifier|*
name|source_checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_hex_digest
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|text_deltas
condition|)
block|{
comment|/* Get a delta stream turning an empty file into one having              TARGET_PATH's contents.  */
name|SVN_ERR
argument_list|(
name|svn_fs_get_file_delta_stream
argument_list|(
operator|&
name|delta_stream
argument_list|,
name|source_path
condition|?
name|c
operator|->
name|source_root
else|:
name|NULL
argument_list|,
name|source_path
condition|?
name|source_path
else|:
name|NULL
argument_list|,
name|c
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|source_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|c
operator|->
name|source_root
argument_list|,
name|source_path
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|source_hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|source_checksum
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|send_text_delta
argument_list|(
name|c
argument_list|,
name|file_baton
argument_list|,
name|source_hex_digest
argument_list|,
name|delta_stream
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic directory deltafication routines.  */
end_comment

begin_comment
comment|/* Emit a delta to delete the entry named TARGET_ENTRY from DIR_BATON.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|c
operator|->
name|editor
operator|->
name|delete_entry
argument_list|(
name|edit_path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|dir_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If authorized, emit a delta to create the entry named TARGET_ENTRY    at the location EDIT_PATH.  If not authorized, indicate that    EDIT_PATH is absent.  Pass DIR_BATON through to editor functions    that require it.  DEPTH is the depth from this point downward. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file_or_dir
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|svn_node_kind_t
name|tgt_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|context
init|=
name|c
decl_stmt|;
name|svn_boolean_t
name|allowed
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|target_path
operator|&&
name|edit_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|authz_read_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|c
operator|->
name|authz_read_func
argument_list|(
operator|&
name|allowed
argument_list|,
name|c
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|c
operator|->
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
condition|)
return|return
name|absent_file_or_dir
argument_list|(
name|c
argument_list|,
name|dir_baton
argument_list|,
name|edit_path
argument_list|,
name|tgt_kind
argument_list|,
name|pool
argument_list|)
return|;
block|}
if|if
condition|(
name|tgt_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|void
modifier|*
name|subdir_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|context
operator|->
name|editor
operator|->
name|add_directory
argument_list|(
name|edit_path
argument_list|,
name|dir_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
operator|&
name|subdir_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delta_dirs
argument_list|(
name|context
argument_list|,
name|subdir_baton
argument_list|,
name|MAYBE_DEMOTE_DEPTH
argument_list|(
name|depth
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|target_path
argument_list|,
name|edit_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|context
operator|->
name|editor
operator|->
name|close_directory
argument_list|(
name|subdir_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
else|else
block|{
name|void
modifier|*
name|file_baton
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|context
operator|->
name|editor
operator|->
name|add_file
argument_list|(
name|edit_path
argument_list|,
name|dir_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delta_files
argument_list|(
name|context
argument_list|,
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|target_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|context
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|context
operator|->
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* If authorized, emit a delta to modify EDIT_PATH with the changes    from SOURCE_PATH to TARGET_PATH.  If not authorized, indicate that    EDIT_PATH is absent.  Pass DIR_BATON through to editor functions    that require it.  DEPTH is the depth from this point downward. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replace_file_or_dir
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|svn_node_kind_t
name|tgt_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|base_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_boolean_t
name|allowed
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|target_path
operator|&&
name|source_path
operator|&&
name|edit_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|authz_read_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|c
operator|->
name|authz_read_func
argument_list|(
operator|&
name|allowed
argument_list|,
name|c
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|c
operator|->
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
condition|)
return|return
name|absent_file_or_dir
argument_list|(
name|c
argument_list|,
name|dir_baton
argument_list|,
name|edit_path
argument_list|,
name|tgt_kind
argument_list|,
name|pool
argument_list|)
return|;
block|}
comment|/* Get the base revision for the entry from the hash. */
name|base_revision
operator|=
name|get_path_revision
argument_list|(
name|c
operator|->
name|source_root
argument_list|,
name|source_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgt_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|void
modifier|*
name|subdir_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|c
operator|->
name|editor
operator|->
name|open_directory
argument_list|(
name|edit_path
argument_list|,
name|dir_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|subdir_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delta_dirs
argument_list|(
name|c
argument_list|,
name|subdir_baton
argument_list|,
name|MAYBE_DEMOTE_DEPTH
argument_list|(
name|depth
argument_list|)
argument_list|,
name|source_path
argument_list|,
name|target_path
argument_list|,
name|edit_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
operator|->
name|editor
operator|->
name|close_directory
argument_list|(
name|subdir_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
else|else
block|{
name|void
modifier|*
name|file_baton
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|c
operator|->
name|editor
operator|->
name|open_file
argument_list|(
name|edit_path
argument_list|,
name|dir_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delta_files
argument_list|(
name|c
argument_list|,
name|file_baton
argument_list|,
name|source_path
argument_list|,
name|target_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|c
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
operator|->
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* In directory DIR_BATON, indicate that EDIT_PATH  (relative to the    edit root) is absent by invoking C->editor->absent_directory or    C->editor->absent_file (depending on TGT_KIND). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_file_or_dir
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|svn_node_kind_t
name|tgt_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|edit_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgt_kind
operator|==
name|svn_node_dir
condition|)
return|return
name|c
operator|->
name|editor
operator|->
name|absent_directory
argument_list|(
name|edit_path
argument_list|,
name|dir_baton
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|c
operator|->
name|editor
operator|->
name|absent_file
argument_list|(
name|edit_path
argument_list|,
name|dir_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit deltas to turn SOURCE_PATH into TARGET_PATH.  Assume that    DIR_BATON represents the directory we're constructing to the editor    in the context C.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_dirs
parameter_list|(
name|struct
name|context
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|s_entries
init|=
literal|0
decl_stmt|,
modifier|*
name|t_entries
init|=
literal|0
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|target_path
argument_list|)
expr_stmt|;
comment|/* Compare the property lists.  */
name|SVN_ERR
argument_list|(
name|delta_proplists
argument_list|(
name|c
argument_list|,
name|source_path
argument_list|,
name|target_path
argument_list|,
name|change_dir_prop
argument_list|,
name|dir_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the list of entries in each of source and target.  */
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|t_entries
argument_list|,
name|c
operator|->
name|target_root
argument_list|,
name|target_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_path
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|s_entries
argument_list|,
name|c
operator|->
name|source_root
argument_list|,
name|source_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a subpool for local allocations. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Loop over the hash of entries in the target, searching for its      partner in the source.  If we find the matching partner entry,      use editor calls to replace the one in target with a new version      if necessary, then remove that entry from the source entries      hash.  If we can't find a related node in the source, we use      editor calls to add the entry as a new item in the target.      Having handled all the entries that exist in target, any entries      still remaining the source entries hash represent entries that no      longer exist in target.  Use editor calls to delete those entries      from the target tree. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|t_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|klen
init|=
name|apr_hash_this_key_len
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_fs_dirent_t
modifier|*
name|t_entry
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|t_fullpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|e_fullpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|s_fullpath
decl_stmt|;
name|svn_node_kind_t
name|tgt_kind
decl_stmt|;
comment|/* Clear out our subpool for the next iteration... */
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|tgt_kind
operator|=
name|t_entry
operator|->
name|kind
expr_stmt|;
name|t_fullpath
operator|=
name|svn_relpath_join
argument_list|(
name|target_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|e_fullpath
operator|=
name|svn_relpath_join
argument_list|(
name|edit_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* Can we find something with the same name in the source          entries hash? */
if|if
condition|(
name|s_entries
operator|&&
operator|(
operator|(
name|s_entry
operator|=
name|apr_hash_get
argument_list|(
name|s_entries
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|svn_node_kind_t
name|src_kind
decl_stmt|;
name|s_fullpath
operator|=
name|svn_relpath_join
argument_list|(
name|source_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|src_kind
operator|=
name|s_entry
operator|->
name|kind
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_infinity
operator|||
name|src_kind
operator|!=
name|svn_node_dir
operator|||
operator|(
name|src_kind
operator|==
name|svn_node_dir
operator|&&
name|depth
operator|==
name|svn_depth_immediates
operator|)
condition|)
block|{
comment|/* Use svn_fs_compare_ids() to compare our current                  source and target ids.                      0: means they are the same id, and this is a noop.                    -1: means they are unrelated, so we have to delete the                        old one and add the new one.                     1: means the nodes are related through ancestry, so go                        ahead and do the replace directly.  */
name|int
name|distance
init|=
name|svn_fs_compare_ids
argument_list|(
name|s_entry
operator|->
name|id
argument_list|,
name|t_entry
operator|->
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|==
literal|0
condition|)
block|{
comment|/* no-op */
block|}
elseif|else
if|if
condition|(
operator|(
name|src_kind
operator|!=
name|tgt_kind
operator|)
operator|||
operator|(
operator|(
name|distance
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|!
name|c
operator|->
name|ignore_ancestry
operator|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|delete
argument_list|(
name|c
argument_list|,
name|dir_baton
argument_list|,
name|e_fullpath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_file_or_dir
argument_list|(
name|c
argument_list|,
name|dir_baton
argument_list|,
name|MAYBE_DEMOTE_DEPTH
argument_list|(
name|depth
argument_list|)
argument_list|,
name|t_fullpath
argument_list|,
name|e_fullpath
argument_list|,
name|tgt_kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|replace_file_or_dir
argument_list|(
name|c
argument_list|,
name|dir_baton
argument_list|,
name|MAYBE_DEMOTE_DEPTH
argument_list|(
name|depth
argument_list|)
argument_list|,
name|s_fullpath
argument_list|,
name|t_fullpath
argument_list|,
name|e_fullpath
argument_list|,
name|tgt_kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Remove the entry from the source_hash. */
name|svn_hash_sets
argument_list|(
name|s_entries
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|depth
operator|==
name|svn_depth_infinity
operator|||
name|tgt_kind
operator|!=
name|svn_node_dir
operator|||
operator|(
name|tgt_kind
operator|==
name|svn_node_dir
operator|&&
name|depth
operator|==
name|svn_depth_immediates
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|add_file_or_dir
argument_list|(
name|c
argument_list|,
name|dir_baton
argument_list|,
name|MAYBE_DEMOTE_DEPTH
argument_list|(
name|depth
argument_list|)
argument_list|,
name|t_fullpath
argument_list|,
name|e_fullpath
argument_list|,
name|tgt_kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* All that is left in the source entries hash are things that need      to be deleted.  Delete them.  */
if|if
condition|(
name|s_entries
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|s_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|s_entry
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|e_fullpath
decl_stmt|;
name|svn_node_kind_t
name|src_kind
decl_stmt|;
comment|/* Clear out our subpool for the next iteration... */
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|src_kind
operator|=
name|s_entry
operator|->
name|kind
expr_stmt|;
name|e_fullpath
operator|=
name|svn_relpath_join
argument_list|(
name|edit_path
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* Do we actually want to delete the dir if we're non-recursive? */
if|if
condition|(
name|depth
operator|==
name|svn_depth_infinity
operator|||
name|src_kind
operator|!=
name|svn_node_dir
operator|||
operator|(
name|src_kind
operator|==
name|svn_node_dir
operator|&&
name|depth
operator|==
name|svn_depth_immediates
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|delete
argument_list|(
name|c
argument_list|,
name|dir_baton
argument_list|,
name|e_fullpath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Destroy local allocation subpool. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

