begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* rev_hunt.c --- routines to hunt down particular fs revisions and  *                their properties.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_compat.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Note:  this binary search assumes that the datestamp properties on    each revision are in chronological order.  That is if revision A>    revision B, then A's datestamp is younger then B's datestamp.     If someone comes along and sets a bogus datestamp, this routine    might not work right.     ### todo:  you know, we *could* have svn_fs_change_rev_prop() do    some semantic checking when it's asked to change special reserved    svn: properties.  It could prevent such a problem. */
end_comment

begin_comment
comment|/* helper for svn_repos_dated_revision().     Set *TM to the apr_time_t datestamp on revision REV in FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_time
parameter_list|(
name|apr_time_t
modifier|*
name|tm
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|date_str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_prop
argument_list|(
operator|&
name|date_str
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|date_str
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to find time on revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
return|return
name|svn_time_from_cstring
argument_list|(
name|tm
argument_list|,
name|date_str
operator|->
name|data
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_dated_revision
parameter_list|(
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_time_t
name|tm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|rev_mid
decl_stmt|,
name|rev_top
decl_stmt|,
name|rev_bot
decl_stmt|,
name|rev_latest
decl_stmt|;
name|apr_time_t
name|this_time
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|repos
operator|->
name|fs
decl_stmt|;
comment|/* Initialize top and bottom values of binary search. */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev_latest
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rev_bot
operator|=
literal|0
expr_stmt|;
name|rev_top
operator|=
name|rev_latest
expr_stmt|;
while|while
condition|(
name|rev_bot
operator|<=
name|rev_top
condition|)
block|{
name|rev_mid
operator|=
operator|(
name|rev_top
operator|+
name|rev_bot
operator|)
operator|/
literal|2
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_time
argument_list|(
operator|&
name|this_time
argument_list|,
name|fs
argument_list|,
name|rev_mid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_time
operator|>
name|tm
condition|)
comment|/* we've overshot */
block|{
name|apr_time_t
name|previous_time
decl_stmt|;
if|if
condition|(
operator|(
name|rev_mid
operator|-
literal|1
operator|)
operator|<
literal|0
condition|)
block|{
operator|*
name|revision
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* see if time falls between rev_mid and rev_mid-1: */
name|SVN_ERR
argument_list|(
name|get_time
argument_list|(
operator|&
name|previous_time
argument_list|,
name|fs
argument_list|,
name|rev_mid
operator|-
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous_time
operator|<=
name|tm
condition|)
block|{
operator|*
name|revision
operator|=
name|rev_mid
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|rev_top
operator|=
name|rev_mid
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_time
operator|<
name|tm
condition|)
comment|/* we've undershot */
block|{
name|apr_time_t
name|next_time
decl_stmt|;
if|if
condition|(
operator|(
name|rev_mid
operator|+
literal|1
operator|)
operator|>
name|rev_latest
condition|)
block|{
operator|*
name|revision
operator|=
name|rev_latest
expr_stmt|;
break|break;
block|}
comment|/* see if time falls between rev_mid and rev_mid+1: */
name|SVN_ERR
argument_list|(
name|get_time
argument_list|(
operator|&
name|next_time
argument_list|,
name|fs
argument_list|,
name|rev_mid
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_time
operator|>
name|tm
condition|)
block|{
operator|*
name|revision
operator|=
name|rev_mid
expr_stmt|;
break|break;
block|}
name|rev_bot
operator|=
name|rev_mid
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|revision
operator|=
name|rev_mid
expr_stmt|;
comment|/* exact match! */
break|break;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_get_committed_info
parameter_list|(
name|svn_revnum_t
modifier|*
name|committed_rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|committed_date
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|last_author
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|revprops
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
decl_stmt|;
comment|/* ### It might be simpler just to declare that revision      properties have char * (i.e., UTF-8) values, not arbitrary      binary values, hmmm. */
name|svn_string_t
modifier|*
name|committed_date_s
decl_stmt|,
modifier|*
name|last_author_s
decl_stmt|;
comment|/* Get the CR field out of the node's skel. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_created_rev
argument_list|(
name|committed_rev
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the revision properties of this revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|revprops
argument_list|,
name|fs
argument_list|,
operator|*
name|committed_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract date and author from these revprops. */
name|committed_date_s
operator|=
name|svn_hash_gets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
expr_stmt|;
name|last_author_s
operator|=
name|svn_hash_gets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
expr_stmt|;
operator|*
name|committed_date
operator|=
name|committed_date_s
condition|?
name|committed_date_s
operator|->
name|data
else|:
name|NULL
expr_stmt|;
operator|*
name|last_author
operator|=
name|last_author_s
condition|?
name|last_author_s
operator|->
name|data
else|:
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_history2
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_repos_history_func_t
name|history_func
parameter_list|,
name|void
modifier|*
name|history_baton
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|cross_copies
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_history_t
modifier|*
name|history
decl_stmt|;
name|apr_pool_t
modifier|*
name|oldpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|newpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|history_path
decl_stmt|;
name|svn_revnum_t
name|history_rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
comment|/* Validate the revisions. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Invalid start revision %ld"
argument_list|)
argument_list|,
name|start
argument_list|)
return|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Invalid end revision %ld"
argument_list|)
argument_list|,
name|end
argument_list|)
return|;
comment|/* Ensure that the input is ordered. */
if|if
condition|(
name|start
operator|>
name|end
condition|)
block|{
name|svn_revnum_t
name|tmprev
init|=
name|start
decl_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|tmprev
expr_stmt|;
block|}
comment|/* Get a revision root for END, and an initial HISTORY baton.  */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_UNREADABLE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_node_history2
argument_list|(
operator|&
name|history
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|oldpool
argument_list|,
name|oldpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, we loop over the history items, calling svn_fs_history_prev(). */
do|do
block|{
comment|/* Note that we have to do some crazy pool work here.  We can't          get rid of the old history until we use it to get the new, so          we alternate back and forth between our subpools.  */
name|apr_pool_t
modifier|*
name|tmppool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_history_prev2
argument_list|(
operator|&
name|history
argument_list|,
name|history
argument_list|,
name|cross_copies
argument_list|,
name|newpool
argument_list|,
name|oldpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only continue if there is further history to deal with. */
if|if
condition|(
operator|!
name|history
condition|)
break|break;
comment|/* Fetch the location information for this history step. */
name|SVN_ERR
argument_list|(
name|svn_fs_history_location
argument_list|(
operator|&
name|history_path
argument_list|,
operator|&
name|history_rev
argument_list|,
name|history
argument_list|,
name|newpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this history item predates our START revision, quit          here. */
if|if
condition|(
name|history_rev
operator|<
name|start
condition|)
break|break;
comment|/* Is the history item readable?  If not, quit. */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|history_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|history_root
argument_list|,
name|fs
argument_list|,
name|history_rev
argument_list|,
name|newpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|history_root
argument_list|,
name|history_path
argument_list|,
name|authz_read_baton
argument_list|,
name|newpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
break|break;
block|}
comment|/* Call the user-provided callback function. */
name|err
operator|=
name|history_func
argument_list|(
name|history_baton
argument_list|,
name|history_path
argument_list|,
name|history_rev
argument_list|,
name|newpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CEASE_INVOCATION
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* We're done with the old history item, so we can clear its          pool, and then toggle our notion of "the old pool". */
name|svn_pool_clear
argument_list|(
name|oldpool
argument_list|)
expr_stmt|;
name|tmppool
operator|=
name|oldpool
expr_stmt|;
name|oldpool
operator|=
name|newpool
expr_stmt|;
name|newpool
operator|=
name|tmppool
expr_stmt|;
block|}
do|while
condition|(
name|history
condition|)
do|;
comment|/* shouldn't hit this */
name|cleanup
label|:
name|svn_pool_destroy
argument_list|(
name|oldpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|newpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_deleted_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_revnum_t
modifier|*
name|deleted
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|start_root
decl_stmt|,
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|mid_rev
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_fs_node_relation_t
name|node_relation
decl_stmt|;
comment|/* Validate the revision range. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Invalid start revision %ld"
argument_list|)
argument_list|,
name|start
argument_list|)
return|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Invalid end revision %ld"
argument_list|)
argument_list|,
name|end
argument_list|)
return|;
comment|/* Ensure that the input is ordered. */
if|if
condition|(
name|start
operator|>
name|end
condition|)
block|{
name|svn_revnum_t
name|tmprev
init|=
name|start
decl_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|tmprev
expr_stmt|;
block|}
comment|/* Ensure path exists in fs at start revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|start_root
argument_list|,
name|fs
argument_list|,
name|start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|start_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* Path must exist in fs at start rev. */
operator|*
name|deleted
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Ensure path was deleted at or before end revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
condition|)
block|{
comment|/* path exists in the end node and the end node is equivalent          or otherwise equivalent to the start node.  This can mean          a few things:             1) The end node *is* simply the start node, uncopied               and unmodified in the start to end range.             2) The start node was modified, but never copied.             3) The start node was copied, but this copy occurred at               start or some rev *previous* to start, this is               effectively the same situation as 1 if the node was               never modified or 2 if it was.           In the first three cases the path was not deleted in          the specified range and we are done, but in the following          cases the start node must have been deleted at least once:             4) The start node was deleted and replaced by a copy of               itself at some rev between start and end.  This copy               may itself have been replaced with copies of itself.             5) The start node was deleted and replaced by a node which               it does not share any history with.       */
name|SVN_ERR
argument_list|(
name|svn_fs_node_relation
argument_list|(
operator|&
name|node_relation
argument_list|,
name|start_root
argument_list|,
name|path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_relation
operator|!=
name|svn_fs_node_unrelated
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|copy_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_closest_copy
argument_list|(
operator|&
name|copy_root
argument_list|,
operator|&
name|copy_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy_root
operator|||
operator|(
name|svn_fs_revision_root_revision
argument_list|(
name|copy_root
argument_list|)
operator|<=
name|start
operator|)
condition|)
block|{
comment|/* Case 1,2 or 3, nothing more to do. */
operator|*
name|deleted
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
comment|/* If we get here we know that path exists in rev start and was deleted      at least once before rev end.  To find the revision path was first      deleted we use a binary search.  The rules for the determining if      the deletion comes before or after a given median revision are      described by this matrix:                     |             Most recent copy event that                    |               caused mid node to exist.                    |-----------------------------------------------------      Compare path  |                   |                |               |      at start and  |   Copied at       |  Copied at     | Never copied  |      mid nodes.    |   rev> start     |  rev<= start  |               |                    |                   |                |               |      -------------------------------------------------------------------|      Mid node is   |  A) Start node    |                                |      equivalent to |     replaced with |  E) Mid node == start node,    |      start node    |     an unmodified |     look HIGHER.               |                    |     copy of       |                                |                    |     itself,       |                                |                    |     look LOWER.   |                                |      -------------------------------------------------------------------|      Mid node is   |  B) Start node    |                                |      otherwise     |     replaced with |  F) Mid node is a modified     |      related to    |     a modified    |     version of start node,     |      start node    |     copy of       |     look HIGHER.               |                    |     itself,       |                                |                    |     look LOWER.   |                                |      -------------------------------------------------------------------|      Mid node is   |                                                    |      unrelated to  |  C) Start node replaced with unrelated mid node,   |      start node    |     look LOWER.                                    |                    |                                                    |      -------------------------------------------------------------------|      Path doesn't  |                                                    |      exist at mid  |  D) Start node deleted before mid node,            |      node          |     look LOWER                                     |                    |                                                    |      --------------------------------------------------------------------   */
name|mid_rev
operator|=
operator|(
name|start
operator|+
name|end
operator|)
operator|/
literal|2
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get revision root and node id for mid_rev at that revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|mid_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* Case D: Look lower in the range. */
name|end
operator|=
name|mid_rev
expr_stmt|;
name|mid_rev
operator|=
operator|(
name|start
operator|+
name|mid_rev
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_root_t
modifier|*
name|copy_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_path
decl_stmt|;
comment|/* Determine the relationship between the start node              and the current node. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_relation
argument_list|(
operator|&
name|node_relation
argument_list|,
name|start_root
argument_list|,
name|path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_relation
operator|!=
name|svn_fs_node_unrelated
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_closest_copy
argument_list|(
operator|&
name|copy_root
argument_list|,
operator|&
name|copy_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_relation
operator|==
name|svn_fs_node_unrelated
operator|||
operator|(
name|copy_root
operator|&&
operator|(
name|svn_fs_revision_root_revision
argument_list|(
name|copy_root
argument_list|)
operator|>
name|start
operator|)
operator|)
condition|)
block|{
comment|/* Cases A, B, C: Look at lower revs. */
name|end
operator|=
name|mid_rev
expr_stmt|;
name|mid_rev
operator|=
operator|(
name|start
operator|+
name|mid_rev
operator|)
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
operator|-
name|mid_rev
operator|==
literal|1
condition|)
block|{
comment|/* Found the node path was deleted. */
operator|*
name|deleted
operator|=
name|end
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Cases E, F: Look at higher revs. */
name|start
operator|=
name|mid_rev
expr_stmt|;
name|mid_rev
operator|=
operator|(
name|start
operator|+
name|end
operator|)
operator|/
literal|2
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper func:  return SVN_ERR_AUTHZ_UNREADABLE if ROOT/PATH is    unreadable. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_readability
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_UNREADABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unreadable path encountered; access denied"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The purpose of this function is to discover if fs_path@future_rev  * is derived from fs_path@peg_rev.  The return is placed in *is_ancestor. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_ancestry_of_peg_path
parameter_list|(
name|svn_boolean_t
modifier|*
name|is_ancestor
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|future_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_fs_history_t
modifier|*
name|history
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|apr_pool_t
modifier|*
name|lastpool
decl_stmt|,
modifier|*
name|currpool
decl_stmt|;
name|lastpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|currpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|future_revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_history2
argument_list|(
operator|&
name|history
argument_list|,
name|root
argument_list|,
name|fs_path
argument_list|,
name|lastpool
argument_list|,
name|lastpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since paths that are different according to strcmp may still be      equivalent (due to number of consecutive slashes and the fact that      "" is the same as "/"), we get the "canonical" path in the first      iteration below so that the comparison after the loop will work      correctly. */
name|fs_path
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|apr_pool_t
modifier|*
name|tmppool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_history_prev2
argument_list|(
operator|&
name|history
argument_list|,
name|history
argument_list|,
name|TRUE
argument_list|,
name|currpool
argument_list|,
name|lastpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|history
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|svn_fs_history_location
argument_list|(
operator|&
name|path
argument_list|,
operator|&
name|revision
argument_list|,
name|history
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs_path
condition|)
name|fs_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|revision
operator|<=
name|peg_revision
condition|)
break|break;
comment|/* Clear old pool and flip. */
name|svn_pool_clear
argument_list|(
name|lastpool
argument_list|)
expr_stmt|;
name|tmppool
operator|=
name|lastpool
expr_stmt|;
name|lastpool
operator|=
name|currpool
expr_stmt|;
name|currpool
operator|=
name|tmppool
expr_stmt|;
block|}
comment|/* We must have had at least one iteration above where we      reassigned fs_path. Else, the path wouldn't have existed at      future_revision and svn_fs_history would have thrown. */
name|SVN_ERR_ASSERT
argument_list|(
name|fs_path
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|is_ancestor
operator|=
operator|(
name|history
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
name|fs_path
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__prev_location
parameter_list|(
name|svn_revnum_t
modifier|*
name|appeared_rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|prev_path
parameter_list|,
name|svn_revnum_t
modifier|*
name|prev_rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|,
modifier|*
name|copy_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_path
decl_stmt|,
modifier|*
name|copy_src_path
decl_stmt|,
modifier|*
name|remainder
decl_stmt|;
name|svn_revnum_t
name|copy_src_rev
decl_stmt|;
comment|/* Initialize return variables. */
if|if
condition|(
name|appeared_rev
condition|)
operator|*
name|appeared_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|prev_rev
condition|)
operator|*
name|prev_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|prev_path
condition|)
operator|*
name|prev_path
operator|=
name|NULL
expr_stmt|;
comment|/* Ask about the most recent copy which affected PATH@REVISION.  If      there was no such copy, we're done.  */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_closest_copy
argument_list|(
operator|&
name|copy_root
argument_list|,
operator|&
name|copy_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy_root
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Ultimately, it's not the path of the closest copy's source that      we care about -- it's our own path's location in the copy source      revision.  So we'll tack the relative path that expresses the      difference between the copy destination and our path in the copy      revision onto the copy source path to determine this information.       In other words, if our path is "/branches/my-branch/foo/bar", and      we know that the closest relevant copy was a copy of "/trunk" to      "/branches/my-branch", then that relative path under the copy      destination is "/foo/bar".  Tacking that onto the copy source      path tells us that our path was located at "/trunk/foo/bar"      before the copy.   */
name|SVN_ERR
argument_list|(
name|svn_fs_copied_from
argument_list|(
operator|&
name|copy_src_rev
argument_list|,
operator|&
name|copy_src_path
argument_list|,
name|copy_root
argument_list|,
name|copy_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|remainder
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|copy_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_path
condition|)
operator|*
name|prev_path
operator|=
name|svn_fspath__join
argument_list|(
name|copy_src_path
argument_list|,
name|remainder
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|appeared_rev
condition|)
operator|*
name|appeared_rev
operator|=
name|svn_fs_revision_root_revision
argument_list|(
name|copy_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_rev
condition|)
operator|*
name|prev_rev
operator|=
name|copy_src_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_trace_node_locations
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locations
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|location_revisions_orig
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|location_revisions
decl_stmt|;
name|svn_revnum_t
modifier|*
name|revision_ptr
decl_stmt|,
modifier|*
name|revision_ptr_end
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_boolean_t
name|is_ancestor
decl_stmt|;
name|apr_pool_t
modifier|*
name|lastpool
decl_stmt|,
modifier|*
name|currpool
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|location_revisions_orig
operator|->
name|elt_size
operator|==
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ensure that FS_PATH is absolute, because our path-math below will      depend on that being the case.  */
if|if
condition|(
operator|*
name|fs_path
operator|!=
literal|'/'
condition|)
name|fs_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|fs_path
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
comment|/* Another sanity check. */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|peg_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|peg_root
argument_list|,
name|fs
argument_list|,
name|peg_revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_readability
argument_list|(
name|peg_root
argument_list|,
name|fs_path
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|locations
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* We flip between two pools in the second loop below. */
name|lastpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|currpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* First - let's sort the array of the revisions from the greatest revision    * downward, so it will be easier to search on. */
name|location_revisions
operator|=
name|apr_array_copy
argument_list|(
name|pool
argument_list|,
name|location_revisions_orig
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|location_revisions
operator|->
name|elts
argument_list|,
name|location_revisions
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|revision_ptr
argument_list|)
argument_list|,
name|svn_sort_compare_revisions
argument_list|)
expr_stmt|;
name|revision_ptr
operator|=
operator|(
name|svn_revnum_t
operator|*
operator|)
name|location_revisions
operator|->
name|elts
expr_stmt|;
name|revision_ptr_end
operator|=
name|revision_ptr
operator|+
name|location_revisions
operator|->
name|nelts
expr_stmt|;
comment|/* Ignore revisions R that are younger than the peg_revisions where      path@peg_revision is not an ancestor of path@R. */
name|is_ancestor
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|revision_ptr
operator|<
name|revision_ptr_end
operator|&&
operator|*
name|revision_ptr
operator|>
name|peg_revision
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|currpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_ancestry_of_peg_path
argument_list|(
operator|&
name|is_ancestor
argument_list|,
name|fs
argument_list|,
name|fs_path
argument_list|,
name|peg_revision
argument_list|,
operator|*
name|revision_ptr
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ancestor
condition|)
break|break;
operator|++
name|revision_ptr
expr_stmt|;
block|}
name|revision
operator|=
name|is_ancestor
condition|?
operator|*
name|revision_ptr
else|:
name|peg_revision
expr_stmt|;
name|path
operator|=
name|fs_path
expr_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_readability
argument_list|(
name|root
argument_list|,
name|fs_path
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|revision_ptr
operator|<
name|revision_ptr_end
condition|)
block|{
name|apr_pool_t
modifier|*
name|tmppool
decl_stmt|;
name|svn_revnum_t
name|appeared_rev
decl_stmt|,
name|prev_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|prev_path
decl_stmt|;
comment|/* Find the target of the innermost copy relevant to path@revision.          The copy may be of path itself, or of a parent directory. */
name|SVN_ERR
argument_list|(
name|svn_repos__prev_location
argument_list|(
operator|&
name|appeared_rev
argument_list|,
operator|&
name|prev_path
argument_list|,
operator|&
name|prev_rev
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|path
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev_path
condition|)
break|break;
comment|/* Assign the current path to all younger revisions until we reach          the copy target rev. */
while|while
condition|(
operator|(
name|revision_ptr
operator|<
name|revision_ptr_end
operator|)
operator|&&
operator|(
operator|*
name|revision_ptr
operator|>=
name|appeared_rev
operator|)
condition|)
block|{
comment|/* *revision_ptr is allocated out of pool, so we can point              to in the hash table. */
name|apr_hash_set
argument_list|(
operator|*
name|locations
argument_list|,
name|revision_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|revision_ptr
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|revision_ptr
operator|++
expr_stmt|;
block|}
comment|/* Ignore all revs between the copy target rev and the copy          source rev (non-inclusive). */
while|while
condition|(
operator|(
name|revision_ptr
operator|<
name|revision_ptr_end
operator|)
operator|&&
operator|(
operator|*
name|revision_ptr
operator|>
name|prev_rev
operator|)
condition|)
name|revision_ptr
operator|++
expr_stmt|;
comment|/* State update. */
name|path
operator|=
name|prev_path
expr_stmt|;
name|revision
operator|=
name|prev_rev
expr_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|authz_read_baton
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|lastpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|currpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Clear last pool and switch. */
name|svn_pool_clear
argument_list|(
name|lastpool
argument_list|)
expr_stmt|;
name|tmppool
operator|=
name|lastpool
expr_stmt|;
name|lastpool
operator|=
name|currpool
expr_stmt|;
name|currpool
operator|=
name|tmppool
expr_stmt|;
block|}
comment|/* There are no copies relevant to path@revision.  So any remaining      revisions either predate the creation of path@revision or have      the node existing at the same path.  We will look up path@lrev      for each remaining location-revision and make sure it is related      to path@revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|lastpool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|revision_ptr
operator|<
name|revision_ptr_end
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_fs_node_relation_t
name|node_relation
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|cur_rev_root
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|currpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|cur_rev_root
argument_list|,
name|fs
argument_list|,
operator|*
name|revision_ptr
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|cur_rev_root
argument_list|,
name|path
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|svn_fs_node_relation
argument_list|(
operator|&
name|node_relation
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|cur_rev_root
argument_list|,
name|path
argument_list|,
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_relation
operator|==
name|svn_fs_node_unrelated
condition|)
break|break;
comment|/* The node exists at the same path; record that and advance. */
name|apr_hash_set
argument_list|(
operator|*
name|locations
argument_list|,
name|revision_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|revision_ptr
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|revision_ptr
operator|++
expr_stmt|;
block|}
comment|/* Ignore any remaining location-revisions; they predate the      creation of path@revision. */
name|svn_pool_destroy
argument_list|(
name|lastpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|currpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Transmit SEGMENT through RECEIVER/RECEIVER_BATON iff a portion of    its revision range fits between END_REV and START_REV, possibly    cropping the range so that it fits *entirely* in that range. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_crop_and_send_segment
parameter_list|(
name|svn_location_segment_t
modifier|*
name|segment
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_location_segment_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* We only want to transmit this segment if some portion of it      is between our END_REV and START_REV. */
if|if
condition|(
operator|!
operator|(
operator|(
name|segment
operator|->
name|range_start
operator|>
name|start_rev
operator|)
operator|||
operator|(
name|segment
operator|->
name|range_end
operator|<
name|end_rev
operator|)
operator|)
condition|)
block|{
comment|/* Correct our segment range when the range straddles one of          our requested revision boundaries. */
if|if
condition|(
name|segment
operator|->
name|range_start
operator|<
name|end_rev
condition|)
name|segment
operator|->
name|range_start
operator|=
name|end_rev
expr_stmt|;
if|if
condition|(
name|segment
operator|->
name|range_end
operator|>
name|start_rev
condition|)
name|segment
operator|->
name|range_end
operator|=
name|start_rev
expr_stmt|;
name|SVN_ERR
argument_list|(
name|receiver
argument_list|(
name|segment
argument_list|,
name|receiver_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_node_location_segments
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_location_segment_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|current_path
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|,
name|current_rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
comment|/* No PEG_REVISION?  We'll use HEAD. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|peg_revision
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|peg_revision
operator|=
name|youngest_rev
expr_stmt|;
block|}
comment|/* No START_REV?  We'll use HEAD (which we may have already fetched). */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
condition|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|youngest_rev
argument_list|)
condition|)
name|start_rev
operator|=
name|youngest_rev
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|start_rev
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* No END_REV?  We'll use 0. */
name|end_rev
operator|=
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
condition|?
name|end_rev
else|:
literal|0
expr_stmt|;
comment|/* Are the revision properly ordered?  They better be -- the API      demands it. */
name|SVN_ERR_ASSERT
argument_list|(
name|end_rev
operator|<=
name|start_rev
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|start_rev
operator|<=
name|peg_revision
argument_list|)
expr_stmt|;
comment|/* Ensure that PATH is absolute, because our path-math will depend      on that being the case.  */
if|if
condition|(
operator|*
name|path
operator|!=
literal|'/'
condition|)
name|path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|path
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
comment|/* Auth check. */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|peg_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|peg_root
argument_list|,
name|fs
argument_list|,
name|peg_revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_readability
argument_list|(
name|peg_root
argument_list|,
name|path
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Okay, let's get searching! */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|current_rev
operator|=
name|peg_revision
expr_stmt|;
name|current_path
operator|=
name|svn_stringbuf_create
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_rev
operator|>=
name|end_rev
condition|)
block|{
name|svn_revnum_t
name|appeared_rev
decl_stmt|,
name|prev_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|cur_path
decl_stmt|,
modifier|*
name|prev_path
decl_stmt|;
name|svn_location_segment_t
modifier|*
name|segment
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|cur_path
operator|=
name|apr_pstrmemdup
argument_list|(
name|subpool
argument_list|,
name|current_path
operator|->
name|data
argument_list|,
name|current_path
operator|->
name|len
argument_list|)
expr_stmt|;
name|segment
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|segment
argument_list|)
argument_list|)
expr_stmt|;
name|segment
operator|->
name|range_end
operator|=
name|current_rev
expr_stmt|;
name|segment
operator|->
name|range_start
operator|=
name|end_rev
expr_stmt|;
comment|/* segment path should be absolute without leading '/'. */
name|segment
operator|->
name|path
operator|=
name|cur_path
operator|+
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__prev_location
argument_list|(
operator|&
name|appeared_rev
argument_list|,
operator|&
name|prev_path
argument_list|,
operator|&
name|prev_rev
argument_list|,
name|fs
argument_list|,
name|current_rev
argument_list|,
name|cur_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there are no previous locations for this thing (meaning,          it originated at the current path), then we simply need to          find its revision of origin to populate our final segment.          Otherwise, the APPEARED_REV is the start of current segment's          range. */
if|if
condition|(
operator|!
name|prev_path
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|revroot
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|revroot
argument_list|,
name|fs
argument_list|,
name|current_rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_origin_rev
argument_list|(
operator|&
operator|(
name|segment
operator|->
name|range_start
operator|)
argument_list|,
name|revroot
argument_list|,
name|cur_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|->
name|range_start
operator|<
name|end_rev
condition|)
name|segment
operator|->
name|range_start
operator|=
name|end_rev
expr_stmt|;
name|current_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
name|segment
operator|->
name|range_start
operator|=
name|appeared_rev
expr_stmt|;
name|svn_stringbuf_set
argument_list|(
name|current_path
argument_list|,
name|prev_path
argument_list|)
expr_stmt|;
name|current_rev
operator|=
name|prev_rev
expr_stmt|;
block|}
comment|/* Report our segment, providing it passes authz muster. */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|cur_rev_root
decl_stmt|;
comment|/* authz_read_func requires path to have a leading slash. */
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|apr_pstrcat
argument_list|(
name|subpool
argument_list|,
literal|"/"
argument_list|,
name|segment
operator|->
name|path
argument_list|,
name|SVN_VA_NULL
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|cur_rev_root
argument_list|,
name|fs
argument_list|,
name|segment
operator|->
name|range_end
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|cur_rev_root
argument_list|,
name|abs_path
argument_list|,
name|authz_read_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Transmit the segment (if it's within the scope of our concern). */
name|SVN_ERR
argument_list|(
name|maybe_crop_and_send_segment
argument_list|(
name|segment
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we've set CURRENT_REV to SVN_INVALID_REVNUM, we're done          (and didn't ever reach END_REV).  */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|current_rev
argument_list|)
condition|)
break|break;
comment|/* If there's a gap in the history, we need to report as much          (if the gap is within the scope of our concern). */
if|if
condition|(
name|segment
operator|->
name|range_start
operator|-
name|current_rev
operator|>
literal|1
condition|)
block|{
name|svn_location_segment_t
modifier|*
name|gap_segment
decl_stmt|;
name|gap_segment
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gap_segment
argument_list|)
argument_list|)
expr_stmt|;
name|gap_segment
operator|->
name|range_end
operator|=
name|segment
operator|->
name|range_start
operator|-
literal|1
expr_stmt|;
name|gap_segment
operator|->
name|range_start
operator|=
name|current_rev
operator|+
literal|1
expr_stmt|;
name|gap_segment
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|maybe_crop_and_send_segment
argument_list|(
name|gap_segment
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
name|svn_boolean_t
name|is_path_in_hash
parameter_list|(
name|apr_hash_t
modifier|*
name|duplicate_path_revs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s:%ld"
argument_list|,
name|path
argument_list|,
name|revision
argument_list|)
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|svn_hash_gets
argument_list|(
name|duplicate_path_revs
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|ptr
operator|!=
name|NULL
return|;
block|}
end_function

begin_struct
struct|struct
name|path_revision
block|{
name|svn_revnum_t
name|revnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Does this path_rev have merges to also be included?  If so, this is      the union of both additions and (negated) deletions of mergeinfo. */
name|apr_hash_t
modifier|*
name|merged_mergeinfo
decl_stmt|;
comment|/* Is this a merged revision? */
name|svn_boolean_t
name|merged
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Check for merges in OLD_PATH_REV->PATH at OLD_PATH_REV->REVNUM.  Store    the mergeinfo difference in *MERGED_MERGEINFO, allocated in POOL.  The    difference is the union of both additions and (negated) deletions.  The    returned *MERGED_MERGEINFO will be NULL if there are no changes. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_merged_mergeinfo
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|merged_mergeinfo
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|struct
name|path_revision
modifier|*
name|old_path_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|curr_mergeinfo
decl_stmt|,
modifier|*
name|prev_mergeinfo
decl_stmt|,
modifier|*
name|deleted
decl_stmt|,
modifier|*
name|changed
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|,
modifier|*
name|prev_root
decl_stmt|;
name|apr_hash_t
modifier|*
name|changed_paths
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|old_path_rev
operator|->
name|path
decl_stmt|;
comment|/* Getting/parsing/diffing svn:mergeinfo is expensive, so only do it      if there is a property change. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|old_path_rev
operator|->
name|revnum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_paths_changed2
argument_list|(
operator|&
name|changed_paths
argument_list|,
name|root
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_fs_path_change2_t
modifier|*
name|changed_path
init|=
name|svn_hash_gets
argument_list|(
name|changed_paths
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed_path
operator|&&
name|changed_path
operator|->
name|prop_mod
operator|&&
name|changed_path
operator|->
name|mergeinfo_mod
operator|!=
name|svn_tristate_false
condition|)
break|break;
if|if
condition|(
name|svn_fspath__is_root
argument_list|(
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|merged_mergeinfo
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|path
operator|=
name|svn_fspath__dirname
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* First, find the mergeinfo difference for old_path_rev->revnum, and      old_path_rev->revnum - 1. */
comment|/* We do not need to call svn_repos_fs_get_mergeinfo() (which performs authz)      because we will filter out unreadable revisions in      find_interesting_revision() */
name|err
operator|=
name|svn_fs__get_mergeinfo_for_path
argument_list|(
operator|&
name|curr_mergeinfo
argument_list|,
name|root
argument_list|,
name|old_path_rev
operator|->
name|path
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
comment|/* Issue #3896: If invalid mergeinfo is encountered the              best we can do is ignore it and act is if there are              no mergeinfo differences. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|merged_mergeinfo
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|prev_root
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|old_path_rev
operator|->
name|revnum
operator|-
literal|1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs__get_mergeinfo_for_path
argument_list|(
operator|&
name|prev_mergeinfo
argument_list|,
name|prev_root
argument_list|,
name|old_path_rev
operator|->
name|path
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
operator|)
condition|)
block|{
comment|/* If the path doesn't exist in the previous revision or it does exist          but has invalid mergeinfo (Issue #3896), assume no merges. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|merged_mergeinfo
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Then calculate and merge the differences, combining additions and      (negated) deletions as all positive changes in CHANGES. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_diff2
argument_list|(
operator|&
name|deleted
argument_list|,
operator|&
name|changed
argument_list|,
name|prev_mergeinfo
argument_list|,
name|curr_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|changed
argument_list|,
name|deleted
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the result. */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|changed
argument_list|)
condition|)
operator|*
name|merged_mergeinfo
operator|=
name|changed
expr_stmt|;
else|else
operator|*
name|merged_mergeinfo
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_interesting_revisions
parameter_list|(
name|apr_array_header_t
modifier|*
name|path_revisions
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
name|svn_boolean_t
name|mark_as_merged
parameter_list|,
name|apr_hash_t
modifier|*
name|duplicate_path_revs
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|,
modifier|*
name|last_pool
decl_stmt|;
name|svn_fs_history_t
modifier|*
name|history
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* We switch between two pools while looping, since we need information from      the last iteration to be available. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|last_pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* The path had better be a file in this revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|end
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file in revision %ld"
argument_list|)
argument_list|,
name|path
argument_list|,
name|end
argument_list|)
return|;
comment|/* Open a history object. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_history2
argument_list|(
operator|&
name|history
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|path_revision
modifier|*
name|path_rev
decl_stmt|;
name|svn_revnum_t
name|tmp_revnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
name|apr_pool_t
modifier|*
name|tmp_pool
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Fetch the history object to walk through. */
name|SVN_ERR
argument_list|(
name|svn_fs_history_prev2
argument_list|(
operator|&
name|history
argument_list|,
name|history
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|history
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|svn_fs_history_location
argument_list|(
operator|&
name|tmp_path
argument_list|,
operator|&
name|tmp_revnum
argument_list|,
name|history
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if we already saw this path (and it's ancestors) */
if|if
condition|(
name|include_merged_revisions
operator|&&
name|is_path_in_hash
argument_list|(
name|duplicate_path_revs
argument_list|,
name|tmp_path
argument_list|,
name|tmp_revnum
argument_list|,
name|iterpool
argument_list|)
condition|)
break|break;
comment|/* Check authorization. */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|tmp_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|tmp_root
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|tmp_revnum
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|tmp_root
argument_list|,
name|tmp_path
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
break|break;
block|}
comment|/* We didn't break, so we must really want this path-rev. */
name|path_rev
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|path_rev
argument_list|)
argument_list|)
expr_stmt|;
name|path_rev
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|tmp_path
argument_list|)
expr_stmt|;
name|path_rev
operator|->
name|revnum
operator|=
name|tmp_revnum
expr_stmt|;
name|path_rev
operator|->
name|merged
operator|=
name|mark_as_merged
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|path_revisions
argument_list|,
expr|struct
name|path_revision
operator|*
argument_list|)
operator|=
name|path_rev
expr_stmt|;
if|if
condition|(
name|include_merged_revisions
condition|)
name|SVN_ERR
argument_list|(
name|get_merged_mergeinfo
argument_list|(
operator|&
name|path_rev
operator|->
name|merged_mergeinfo
argument_list|,
name|repos
argument_list|,
name|path_rev
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|path_rev
operator|->
name|merged_mergeinfo
operator|=
name|NULL
expr_stmt|;
comment|/* Add the path/rev pair to the hash, so we can filter out future          occurrences of it.  We only care about this if including merged          revisions, 'cause that's the only time we can have duplicates. */
name|svn_hash_sets
argument_list|(
name|duplicate_path_revs
argument_list|,
name|apr_psprintf
argument_list|(
name|result_pool
argument_list|,
literal|"%s:%ld"
argument_list|,
name|path_rev
operator|->
name|path
argument_list|,
name|path_rev
operator|->
name|revnum
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0xdeadbeef
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_rev
operator|->
name|revnum
operator|<=
name|start
condition|)
break|break;
comment|/* Swap pools. */
name|tmp_pool
operator|=
name|iterpool
expr_stmt|;
name|iterpool
operator|=
name|last_pool
expr_stmt|;
name|last_pool
operator|=
name|tmp_pool
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|last_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Comparison function to sort path/revisions in increasing order */
end_comment

begin_function
specifier|static
name|int
name|compare_path_revisions
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|path_revision
modifier|*
name|a_pr
init|=
operator|*
operator|(
expr|struct
name|path_revision
operator|*
specifier|const
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|path_revision
modifier|*
name|b_pr
init|=
operator|*
operator|(
expr|struct
name|path_revision
operator|*
specifier|const
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|a_pr
operator|->
name|revnum
operator|==
name|b_pr
operator|->
name|revnum
condition|)
return|return
literal|0
return|;
return|return
name|a_pr
operator|->
name|revnum
operator|<
name|b_pr
operator|->
name|revnum
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_merged_revisions
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|merged_path_revisions_out
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|mainline_path_revisions
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|duplicate_path_revs
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|old
decl_stmt|;
name|apr_array_header_t
modifier|*
name|new_merged_path_revs
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|,
modifier|*
name|last_pool
decl_stmt|;
name|apr_array_header_t
modifier|*
name|merged_path_revisions
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_revision
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|old
operator|=
name|mainline_path_revisions
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|last_pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|temp_pool
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|new_merged_path_revs
operator|=
name|apr_array_make
argument_list|(
name|iterpool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_revision
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Iterate over OLD, checking for non-empty mergeinfo.  If found, gather          path_revisions for any merged revisions, and store those in NEW. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|apr_pool_t
modifier|*
name|iterpool2
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|struct
name|path_revision
modifier|*
name|old_pr
init|=
name|APR_ARRAY_IDX
argument_list|(
name|old
argument_list|,
name|i
argument_list|,
expr|struct
name|path_revision
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|old_pr
operator|->
name|merged_mergeinfo
condition|)
continue|continue;
name|iterpool2
operator|=
name|svn_pool_create
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Determine and trace the merge sources. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|old_pr
operator|->
name|merged_mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool3
decl_stmt|;
name|int
name|j
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
name|iterpool3
operator|=
name|svn_pool_create
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|j
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|end
operator|<
name|start
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool3
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|range
operator|->
name|end
argument_list|,
name|iterpool3
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|iterpool3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
continue|continue;
comment|/* Search and find revisions to add to the NEW list. */
name|SVN_ERR
argument_list|(
name|find_interesting_revisions
argument_list|(
name|new_merged_path_revs
argument_list|,
name|repos
argument_list|,
name|path
argument_list|,
name|range
operator|->
name|start
argument_list|,
name|range
operator|->
name|end
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|duplicate_path_revs
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|result_pool
argument_list|,
name|iterpool3
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool3
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
block|}
comment|/* Append the newly found path revisions with the old ones. */
name|merged_path_revisions
operator|=
name|apr_array_append
argument_list|(
name|iterpool
argument_list|,
name|merged_path_revisions
argument_list|,
name|new_merged_path_revs
argument_list|)
expr_stmt|;
comment|/* Swap data structures */
name|old
operator|=
name|new_merged_path_revs
expr_stmt|;
name|temp_pool
operator|=
name|last_pool
expr_stmt|;
name|last_pool
operator|=
name|iterpool
expr_stmt|;
name|iterpool
operator|=
name|temp_pool
expr_stmt|;
block|}
do|while
condition|(
name|new_merged_path_revs
operator|->
name|nelts
operator|>
literal|0
condition|)
do|;
comment|/* Sort MERGED_PATH_REVISIONS in increasing order by REVNUM. */
name|svn_sort__array
argument_list|(
name|merged_path_revisions
argument_list|,
name|compare_path_revisions
argument_list|)
expr_stmt|;
comment|/* Copy to the output array. */
operator|*
name|merged_path_revisions_out
operator|=
name|apr_array_copy
argument_list|(
name|result_pool
argument_list|,
name|merged_path_revisions
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|last_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|send_baton
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_pool_t
modifier|*
name|last_pool
decl_stmt|;
name|apr_hash_t
modifier|*
name|last_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|last_root
decl_stmt|;
name|svn_boolean_t
name|include_merged_revisions
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Send PATH_REV to HANDLER and HANDLER_BATON, using information provided by    SB. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_path_revision
parameter_list|(
name|struct
name|path_revision
modifier|*
name|path_rev
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|struct
name|send_baton
modifier|*
name|sb
parameter_list|,
name|svn_file_rev_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|rev_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|prop_diffs
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
decl_stmt|;
name|svn_txdelta_window_handler_t
name|delta_handler
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|delta_baton
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|tmp_pool
decl_stmt|;
comment|/* For swapping */
name|svn_boolean_t
name|contents_changed
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|sb
operator|->
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the revision properties. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|rev_props
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|path_rev
operator|->
name|revnum
argument_list|,
name|sb
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open the revision root. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|path_rev
operator|->
name|revnum
argument_list|,
name|sb
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the file's properties for this revision and compute the diffs. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|root
argument_list|,
name|path_rev
operator|->
name|path
argument_list|,
name|sb
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|prop_diffs
argument_list|,
name|props
argument_list|,
name|sb
operator|->
name|last_props
argument_list|,
name|sb
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if the contents *may* have changed. */
if|if
condition|(
operator|!
name|sb
operator|->
name|last_root
condition|)
block|{
comment|/* Special case: In the first revision, we always provide a delta. */
name|contents_changed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|->
name|include_merged_revisions
operator|&&
name|strcmp
argument_list|(
name|sb
operator|->
name|last_path
argument_list|,
name|path_rev
operator|->
name|path
argument_list|)
condition|)
block|{
comment|/* ### This is a HACK!!!        * Blame -g, in older clients anyways, relies on getting a notification        * whenever the path changes - even if there was no content change.        *        * TODO: A future release should take an extra parameter and depending        * on that either always send a text delta or only send it if there        * is a difference. */
name|contents_changed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Did the file contents actually change?        * It could e.g. be a property-only change. */
name|SVN_ERR
argument_list|(
name|svn_fs_contents_different
argument_list|(
operator|&
name|contents_changed
argument_list|,
name|sb
operator|->
name|last_root
argument_list|,
name|sb
operator|->
name|last_path
argument_list|,
name|root
argument_list|,
name|path_rev
operator|->
name|path
argument_list|,
name|sb
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We have all we need, give to the handler. */
name|SVN_ERR
argument_list|(
name|handler
argument_list|(
name|handler_baton
argument_list|,
name|path_rev
operator|->
name|path
argument_list|,
name|path_rev
operator|->
name|revnum
argument_list|,
name|rev_props
argument_list|,
name|path_rev
operator|->
name|merged
argument_list|,
name|contents_changed
condition|?
operator|&
name|delta_handler
else|:
name|NULL
argument_list|,
name|contents_changed
condition|?
operator|&
name|delta_baton
else|:
name|NULL
argument_list|,
name|prop_diffs
argument_list|,
name|sb
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute and send delta if client asked for it.      Note that this was initialized to NULL, so if !contents_changed,      no deltas will be computed. */
if|if
condition|(
name|delta_handler
operator|&&
name|delta_handler
operator|!=
name|svn_delta_noop_window_handler
condition|)
block|{
comment|/* Get the content delta. */
name|SVN_ERR
argument_list|(
name|svn_fs_get_file_delta_stream
argument_list|(
operator|&
name|delta_stream
argument_list|,
name|sb
operator|->
name|last_root
argument_list|,
name|sb
operator|->
name|last_path
argument_list|,
name|root
argument_list|,
name|path_rev
operator|->
name|path
argument_list|,
name|sb
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And send. */
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_txstream
argument_list|(
name|delta_stream
argument_list|,
name|delta_handler
argument_list|,
name|delta_baton
argument_list|,
name|sb
operator|->
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remember root, path and props for next iteration. */
name|sb
operator|->
name|last_root
operator|=
name|root
expr_stmt|;
name|sb
operator|->
name|last_path
operator|=
name|path_rev
operator|->
name|path
expr_stmt|;
name|sb
operator|->
name|last_props
operator|=
name|props
expr_stmt|;
comment|/* Swap the pools. */
name|tmp_pool
operator|=
name|sb
operator|->
name|iterpool
expr_stmt|;
name|sb
operator|->
name|iterpool
operator|=
name|sb
operator|->
name|last_pool
expr_stmt|;
name|sb
operator|->
name|last_pool
operator|=
name|tmp_pool
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Similar to svn_repos_get_file_revs2() but returns paths while walking    history instead of after collecting all history.     This allows implementing clients to immediately start processing and    stop when they got the information they need. (E.g. all or a specific set    of lines were modified) */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_revs_backwards
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|svn_file_rev_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|,
modifier|*
name|last_pool
decl_stmt|;
name|svn_fs_history_t
modifier|*
name|history
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|struct
name|send_baton
name|sb
decl_stmt|;
comment|/* We switch between two pools while looping and so does the path-rev      handler for actually reported revisions. We do this as we      need just information from last iteration to be available. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|last_pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|sb
operator|.
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|sb
operator|.
name|last_pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|sb
operator|.
name|include_merged_revisions
operator|=
name|FALSE
expr_stmt|;
comment|/* We want the first txdelta to be against the empty file. */
name|sb
operator|.
name|last_root
operator|=
name|NULL
expr_stmt|;
name|sb
operator|.
name|last_path
operator|=
name|NULL
expr_stmt|;
comment|/* Create an empty hash table for the first property diff. */
name|sb
operator|.
name|last_props
operator|=
name|apr_hash_make
argument_list|(
name|sb
operator|.
name|last_pool
argument_list|)
expr_stmt|;
comment|/* The path had better be a file in this revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|end
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file in revision %ld"
argument_list|)
argument_list|,
name|path
argument_list|,
name|end
argument_list|)
return|;
comment|/* Open a history object. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_history2
argument_list|(
operator|&
name|history
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|path_revision
modifier|*
name|path_rev
decl_stmt|;
name|svn_revnum_t
name|tmp_revnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Fetch the history object to walk through. */
name|SVN_ERR
argument_list|(
name|svn_fs_history_prev2
argument_list|(
operator|&
name|history
argument_list|,
name|history
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|history
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|svn_fs_history_location
argument_list|(
operator|&
name|tmp_path
argument_list|,
operator|&
name|tmp_revnum
argument_list|,
name|history
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check authorization. */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|tmp_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|tmp_root
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|tmp_revnum
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|tmp_root
argument_list|,
name|tmp_path
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
break|break;
block|}
comment|/* We didn't break, so we must really want this path-rev. */
name|path_rev
operator|=
name|apr_palloc
argument_list|(
name|iterpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|path_rev
argument_list|)
argument_list|)
expr_stmt|;
name|path_rev
operator|->
name|path
operator|=
name|tmp_path
expr_stmt|;
name|path_rev
operator|->
name|revnum
operator|=
name|tmp_revnum
expr_stmt|;
name|path_rev
operator|->
name|merged
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|send_path_revision
argument_list|(
name|path_rev
argument_list|,
name|repos
argument_list|,
operator|&
name|sb
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_rev
operator|->
name|revnum
operator|<=
name|start
condition|)
break|break;
comment|/* Swap pools. */
block|{
name|apr_pool_t
modifier|*
name|tmp_pool
init|=
name|iterpool
decl_stmt|;
name|iterpool
operator|=
name|last_pool
expr_stmt|;
name|last_pool
operator|=
name|tmp_pool
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|last_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|sb
operator|.
name|last_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|sb
operator|.
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* We don't yet support sending revisions in reverse order; the caller wait  * until we've traced back through the entire history, and then accept  * them from oldest to youngest.  Someday this may change, but in the meantime,  * the general algorithm is thus:  *  *  1) Trace back through the history of an object, adding each revision  *     found to the MAINLINE_PATH_REVISIONS array, marking any which were  *     merges.  *  2) If INCLUDE_MERGED_REVISIONS is TRUE, we repeat Step 1 on each of the  *     merged revisions, including them in the MERGED_PATH_REVISIONS, and using  *     DUPLICATE_PATH_REVS to avoid tracing the same paths of history multiple  *     times.  *  3) Send both MAINLINE_PATH_REVISIONS and MERGED_PATH_REVISIONS from  *     oldest to youngest, interleaving as appropriate.  This is implemented  *     similar to an insertion sort, but instead of inserting into another  *     array, we just call the appropriate handler.  *  * 2013-02: Added a very simple reverse for mainline only changes. Before this,  *          this would return an error (path not found) or just the first  *          revision before end.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_get_file_revs2
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|svn_file_rev_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|mainline_path_revisions
decl_stmt|,
modifier|*
name|merged_path_revisions
decl_stmt|;
name|apr_hash_t
modifier|*
name|duplicate_path_revs
decl_stmt|;
name|struct
name|send_baton
name|sb
decl_stmt|;
name|int
name|mainline_pos
decl_stmt|,
name|merged_pos
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start
argument_list|)
operator|||
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start
argument_list|)
condition|)
name|start
operator|=
name|youngest_rev
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end
argument_list|)
condition|)
name|end
operator|=
name|youngest_rev
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
if|if
condition|(
name|include_merged_revisions
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|get_file_revs_backwards
argument_list|(
name|repos
argument_list|,
name|path
argument_list|,
name|end
argument_list|,
name|start
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* We switch between two pools while looping, since we need information from      the last iteration to be available. */
name|sb
operator|.
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|sb
operator|.
name|last_pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* We want the first txdelta to be against the empty file. */
name|sb
operator|.
name|last_root
operator|=
name|NULL
expr_stmt|;
name|sb
operator|.
name|last_path
operator|=
name|NULL
expr_stmt|;
comment|/* Create an empty hash table for the first property diff. */
name|sb
operator|.
name|last_props
operator|=
name|apr_hash_make
argument_list|(
name|sb
operator|.
name|last_pool
argument_list|)
expr_stmt|;
comment|/* Inform send_path_revision() whether workarounds / special behavior    * may be needed. */
name|sb
operator|.
name|include_merged_revisions
operator|=
name|include_merged_revisions
expr_stmt|;
comment|/* Get the revisions we are interested in. */
name|duplicate_path_revs
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|mainline_path_revisions
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|100
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_revision
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_interesting_revisions
argument_list|(
name|mainline_path_revisions
argument_list|,
name|repos
argument_list|,
name|path
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|include_merged_revisions
argument_list|,
name|FALSE
argument_list|,
name|duplicate_path_revs
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|scratch_pool
argument_list|,
name|sb
operator|.
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are including merged revisions, go get those, too. */
if|if
condition|(
name|include_merged_revisions
condition|)
name|SVN_ERR
argument_list|(
name|find_merged_revisions
argument_list|(
operator|&
name|merged_path_revisions
argument_list|,
name|start
argument_list|,
name|mainline_path_revisions
argument_list|,
name|repos
argument_list|,
name|duplicate_path_revs
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|scratch_pool
argument_list|,
name|sb
operator|.
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|merged_path_revisions
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_revision
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must have at least one revision to get. */
name|SVN_ERR_ASSERT
argument_list|(
name|mainline_path_revisions
operator|->
name|nelts
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Walk through both mainline and merged revisions, and send them in      reverse chronological order, interleaving as appropriate. */
name|mainline_pos
operator|=
name|mainline_path_revisions
operator|->
name|nelts
operator|-
literal|1
expr_stmt|;
name|merged_pos
operator|=
name|merged_path_revisions
operator|->
name|nelts
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|mainline_pos
operator|>=
literal|0
operator|&&
name|merged_pos
operator|>=
literal|0
condition|)
block|{
name|struct
name|path_revision
modifier|*
name|main_pr
init|=
name|APR_ARRAY_IDX
argument_list|(
name|mainline_path_revisions
argument_list|,
name|mainline_pos
argument_list|,
expr|struct
name|path_revision
operator|*
argument_list|)
decl_stmt|;
name|struct
name|path_revision
modifier|*
name|merged_pr
init|=
name|APR_ARRAY_IDX
argument_list|(
name|merged_path_revisions
argument_list|,
name|merged_pos
argument_list|,
expr|struct
name|path_revision
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|main_pr
operator|->
name|revnum
operator|<=
name|merged_pr
operator|->
name|revnum
condition|)
block|{
name|SVN_ERR
argument_list|(
name|send_path_revision
argument_list|(
name|main_pr
argument_list|,
name|repos
argument_list|,
operator|&
name|sb
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
name|mainline_pos
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|send_path_revision
argument_list|(
name|merged_pr
argument_list|,
name|repos
argument_list|,
operator|&
name|sb
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
name|merged_pos
operator|-=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Send any remaining revisions from the mainline list. */
for|for
control|(
init|;
name|mainline_pos
operator|>=
literal|0
condition|;
name|mainline_pos
operator|-=
literal|1
control|)
block|{
name|struct
name|path_revision
modifier|*
name|main_pr
init|=
name|APR_ARRAY_IDX
argument_list|(
name|mainline_path_revisions
argument_list|,
name|mainline_pos
argument_list|,
expr|struct
name|path_revision
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|send_path_revision
argument_list|(
name|main_pr
argument_list|,
name|repos
argument_list|,
operator|&
name|sb
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Ditto for the merged list. */
for|for
control|(
init|;
name|merged_pos
operator|>=
literal|0
condition|;
name|merged_pos
operator|-=
literal|1
control|)
block|{
name|struct
name|path_revision
modifier|*
name|merged_pr
init|=
name|APR_ARRAY_IDX
argument_list|(
name|merged_path_revisions
argument_list|,
name|merged_pos
argument_list|,
expr|struct
name|path_revision
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|send_path_revision
argument_list|(
name|merged_pr
argument_list|,
name|repos
argument_list|,
operator|&
name|sb
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|sb
operator|.
name|last_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|sb
operator|.
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

