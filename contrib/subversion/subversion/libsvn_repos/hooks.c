begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hooks.c : running repository hooks  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Hook drivers. ***/
end_comment

begin_comment
comment|/* Helper function for run_hook_cmd().  Wait for a hook to finish    executing and return either SVN_NO_ERROR if the hook script completed    without error, or an error describing the reason for failure.     NAME and CMD are the name and path of the hook program, CMD_PROC    is a pointer to the structure representing the running process,    and READ_ERRHANDLE is an open handle to the hook's stderr.     Hooks are considered to have failed if we are unable to wait for the    process, if we are unable to read from the hook's stderr, if the    process has failed to exit cleanly (due to a coredump, for example),    or if the process returned a non-zero return code.     Any error output returned by the hook's stderr will be included in an    error message, though the presence of output on stderr is not itself    a reason to fail a hook. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_hook_result
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|apr_proc_t
modifier|*
name|cmd_proc
parameter_list|,
name|apr_file_t
modifier|*
name|read_errhandle
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|err2
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|native_stderr
decl_stmt|,
modifier|*
name|failure_message
decl_stmt|;
specifier|const
name|char
modifier|*
name|utf8_stderr
decl_stmt|;
name|int
name|exitcode
decl_stmt|;
name|apr_exit_why_e
name|exitwhy
decl_stmt|;
name|err2
operator|=
name|svn_stringbuf_from_aprfile
argument_list|(
operator|&
name|native_stderr
argument_list|,
name|read_errhandle
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_wait_for_cmd
argument_list|(
name|cmd_proc
argument_list|,
name|cmd
argument_list|,
operator|&
name|exitcode
argument_list|,
operator|&
name|exitwhy
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err2
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|APR_PROC_CHECK_EXIT
argument_list|(
name|exitwhy
argument_list|)
operator|&&
name|exitcode
operator|==
literal|0
condition|)
block|{
comment|/* The hook exited cleanly.  However, if we got an error reading          the hook's stderr, fail the hook anyway, because this might be          symptomatic of a more important problem. */
if|if
condition|(
name|err2
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_HOOK_FAILURE
argument_list|,
name|err2
argument_list|,
name|_
argument_list|(
literal|"'%s' hook succeeded, but error output could not be read"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The hook script failed. */
comment|/* If we got the stderr output okay, try to translate it into UTF-8.      Ensure there is something sensible in the UTF-8 string regardless. */
if|if
condition|(
operator|!
name|err2
condition|)
block|{
name|err2
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_stderr
argument_list|,
name|native_stderr
operator|->
name|data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
name|utf8_stderr
operator|=
name|_
argument_list|(
literal|"[Error output could not be translated from the "
literal|"native locale to UTF-8.]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_stderr
operator|=
name|_
argument_list|(
literal|"[Error output could not be read.]"
argument_list|)
expr_stmt|;
block|}
comment|/*### It would be nice to include the text of any translation or read         error in the messages above before we clear it here. */
name|svn_error_clear
argument_list|(
name|err2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|APR_PROC_CHECK_EXIT
argument_list|(
name|exitwhy
argument_list|)
condition|)
block|{
name|failure_message
operator|=
name|svn_stringbuf_createf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"'%s' hook failed (did not exit cleanly: "
literal|"apr_exit_why_e was %d, exitcode was %d).  "
argument_list|)
argument_list|,
name|name
argument_list|,
name|exitwhy
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|action
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"start-commit"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pre-commit"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|=
name|_
argument_list|(
literal|"Commit"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pre-revprop-change"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|=
name|_
argument_list|(
literal|"Revprop change"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pre-lock"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|=
name|_
argument_list|(
literal|"Lock"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pre-unlock"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|=
name|_
argument_list|(
literal|"Unlock"
argument_list|)
expr_stmt|;
else|else
name|action
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|NULL
condition|)
name|failure_message
operator|=
name|svn_stringbuf_createf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"%s hook failed (exit code %d)"
argument_list|)
argument_list|,
name|name
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
else|else
name|failure_message
operator|=
name|svn_stringbuf_createf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"%s blocked by %s hook (exit code %d)"
argument_list|)
argument_list|,
name|action
argument_list|,
name|name
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|utf8_stderr
index|[
literal|0
index|]
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|failure_message
argument_list|,
name|_
argument_list|(
literal|" with output:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|failure_message
argument_list|,
name|utf8_stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|failure_message
argument_list|,
name|_
argument_list|(
literal|" with no output."
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_HOOK_FAILURE
argument_list|,
name|err
argument_list|,
name|failure_message
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the environment given as key/value pairs of ENV_HASH into  * an array of C strings allocated in RESULT_POOL.  * If the hook environment is empty, return NULL.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|env_from_env_hash
parameter_list|(
name|apr_hash_t
modifier|*
name|env_hash
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
if|if
condition|(
operator|!
name|env_hash
condition|)
return|return
name|NULL
return|;
name|env
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|*
operator|(
name|apr_hash_count
argument_list|(
name|env_hash
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|envp
operator|=
name|env
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|env_hash
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
operator|*
name|envp
operator|=
name|apr_psprintf
argument_list|(
name|result_pool
argument_list|,
literal|"%s=%s"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|envp
operator|++
expr_stmt|;
block|}
operator|*
name|envp
operator|=
name|NULL
expr_stmt|;
return|return
name|env
return|;
block|}
end_function

begin_comment
comment|/* NAME, CMD and ARGS are the name, path to and arguments for the hook    program that is to be run.  The hook's exit status will be checked,    and if an error occurred the hook's stderr output will be added to    the returned error.     If STDIN_HANDLE is non-null, pass it as the hook's stdin, else pass    no stdin to the hook.     If RESULT is non-null, set *RESULT to the stdout of the hook or to    a zero-length string if the hook generates no output on stdout. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_hook_cmd
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|args
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
name|apr_file_t
modifier|*
name|stdin_handle
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|null_handle
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_proc_t
name|cmd_proc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_pool_t
modifier|*
name|cmd_pool
decl_stmt|;
name|apr_hash_t
modifier|*
name|hook_env
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|null_handle
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Redirect stdout to the null device */
name|apr_err
operator|=
name|apr_file_open
argument_list|(
operator|&
name|null_handle
argument_list|,
name|SVN_NULL_DEVICE_NAME
argument_list|,
name|APR_WRITE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't create null stdout for hook '%s'"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
block|}
comment|/* Tie resources allocated for the command to a special pool which we can    * destroy in order to clean up the stderr pipe opened for the process. */
name|cmd_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Check if a custom environment is defined for this hook, or else    * whether a default environment is defined. */
if|if
condition|(
name|hooks_env
condition|)
block|{
name|hook_env
operator|=
name|svn_hash_gets
argument_list|(
name|hooks_env
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook_env
operator|==
name|NULL
condition|)
name|hook_env
operator|=
name|svn_hash_gets
argument_list|(
name|hooks_env
argument_list|,
name|SVN_REPOS__HOOKS_ENV_DEFAULT_SECTION
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_io_start_cmd3
argument_list|(
operator|&
name|cmd_proc
argument_list|,
literal|"."
argument_list|,
name|cmd
argument_list|,
name|args
argument_list|,
name|env_from_env_hash
argument_list|(
name|hook_env
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|stdin_handle
argument_list|,
name|result
operator|!=
name|NULL
argument_list|,
name|null_handle
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|cmd_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|check_hook_result
argument_list|(
name|name
argument_list|,
name|cmd
argument_list|,
operator|&
name|cmd_proc
argument_list|,
name|cmd_proc
operator|.
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The command could not be started for some reason. */
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Failed to start '%s' hook"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/* Hooks are fallible, and so hook failure is "expected" to occur at      times.  When such a failure happens we still want to close the pipe      and null file */
if|if
condition|(
operator|!
name|err
operator|&&
name|result
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|native_stdout
decl_stmt|;
name|err
operator|=
name|svn_stringbuf_from_aprfile
argument_list|(
operator|&
name|native_stdout
argument_list|,
name|cmd_proc
operator|.
name|out
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|result
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|native_stdout
argument_list|)
expr_stmt|;
block|}
comment|/* Close resources allocated by svn_io_start_cmd3(), such as the pipe. */
name|svn_pool_destroy
argument_list|(
name|cmd_pool
argument_list|)
expr_stmt|;
comment|/* Close the null handle. */
if|if
condition|(
name|null_handle
condition|)
block|{
name|apr_err
operator|=
name|apr_file_close
argument_list|(
name|null_handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error closing null file"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a temporary file F that will automatically be deleted when the    pool is cleaned up.  Fill it with VALUE, and leave it open and rewound,    ready to be read from. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_temp_file
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|f
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|f
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
operator|*
name|f
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|value
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_io_file_seek
argument_list|(
operator|*
name|f
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check if the HOOK program exists and is a file or a symbolic link, using    POOL for temporary allocations.     If the hook exists but is a broken symbolic link, set *BROKEN_LINK    to TRUE, else if the hook program exists set *BROKEN_LINK to FALSE.     Return the hook program if found, else return NULL and don't touch    *BROKEN_LINK. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|check_hook_cmd
parameter_list|(
specifier|const
name|char
modifier|*
name|hook
parameter_list|,
name|svn_boolean_t
modifier|*
name|broken_link
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|check_extns
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|WIN32
comment|/* For WIN32, we need to check with file name extension(s) added.       As Windows Scripting Host (.wsf) files can accomodate (at least)      JavaScript (.js) and VB Script (.vbs) code, extensions for the      corresponding file types need not be enumerated explicitly. */
literal|".exe"
block|,
literal|".cmd"
block|,
literal|".bat"
block|,
literal|".wsf"
block|,
comment|/* ### Any other extensions? */
else|#
directive|else
literal|""
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|extn
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|is_special
decl_stmt|;
for|for
control|(
name|extn
operator|=
name|check_extns
init|;
operator|*
name|extn
condition|;
operator|++
name|extn
control|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|hook_path
init|=
operator|(
operator|*
operator|*
name|extn
condition|?
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|hook
argument_list|,
operator|*
name|extn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
else|:
name|hook
operator|)
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|err
operator|=
name|svn_io_check_resolved_path
argument_list|(
name|hook_path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|kind
operator|==
name|svn_node_file
condition|)
block|{
operator|*
name|broken_link
operator|=
name|FALSE
expr_stmt|;
return|return
name|hook_path
return|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|err
operator|=
name|svn_io_check_special_path
argument_list|(
name|hook_path
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|is_special
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|is_special
condition|)
block|{
operator|*
name|broken_link
operator|=
name|TRUE
expr_stmt|;
return|return
name|hook_path
return|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Baton for parse_hooks_env_option. */
end_comment

begin_struct
struct|struct
name|parse_hooks_env_option_baton
block|{
comment|/* The name of the section being parsed. If not the default section,    * the section name should match the name of a hook to which the    * options apply. */
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
block|}
name|parse_hooks_env_option_baton
struct|;
end_struct

begin_comment
comment|/* An implementation of svn_config_enumerator2_t.  * Set environment variable NAME to value VALUE in the environment for  * all hooks (in case the current section is the default section),  * or the hook with the name corresponding to the current section's name. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|parse_hooks_env_option
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_hooks_env_option_baton
modifier|*
name|bo
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|bo
operator|->
name|hooks_env
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|hook_env
decl_stmt|;
name|hook_env
operator|=
name|svn_hash_gets
argument_list|(
name|bo
operator|->
name|hooks_env
argument_list|,
name|bo
operator|->
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook_env
operator|==
name|NULL
condition|)
block|{
name|hook_env
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|bo
operator|->
name|hooks_env
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|bo
operator|->
name|section
argument_list|)
argument_list|,
name|hook_env
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|hook_env
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_struct
struct|struct
name|parse_hooks_env_section_baton
block|{
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
block|}
name|parse_hooks_env_section_baton
struct|;
end_struct

begin_comment
comment|/* An implementation of svn_config_section_enumerator2_t. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|parse_hooks_env_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_hooks_env_section_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|struct
name|parse_hooks_env_option_baton
name|bo
decl_stmt|;
name|bo
operator|.
name|section
operator|=
name|name
expr_stmt|;
name|bo
operator|.
name|hooks_env
operator|=
name|b
operator|->
name|hooks_env
expr_stmt|;
operator|(
name|void
operator|)
name|svn_config_enumerate2
argument_list|(
name|b
operator|->
name|cfg
argument_list|,
name|name
argument_list|,
name|parse_hooks_env_option
argument_list|,
operator|&
name|bo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__parse_hooks_env
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|hooks_env_p
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
name|struct
name|parse_hooks_env_section_baton
name|b
decl_stmt|;
if|if
condition|(
name|local_abspath
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
operator|&
name|cfg
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|cfg
operator|=
name|cfg
expr_stmt|;
name|b
operator|.
name|hooks_env
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|svn_config_enumerate_sections2
argument_list|(
name|cfg
argument_list|,
name|parse_hooks_env_section
argument_list|,
operator|&
name|b
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|hooks_env_p
operator|=
name|b
operator|.
name|hooks_env
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hooks_env_p
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return an error for the failure of HOOK due to a broken symlink. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hook_symlink_error
parameter_list|(
specifier|const
name|char
modifier|*
name|hook
parameter_list|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_HOOK_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to run '%s' hook; broken symlink"
argument_list|)
argument_list|,
name|hook
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__hooks_start_commit
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|capabilities
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook
init|=
name|svn_repos_start_commit_hook
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|broken_link
decl_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|check_hook_cmd
argument_list|(
name|hook
argument_list|,
operator|&
name|broken_link
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|broken_link
condition|)
block|{
return|return
name|hook_symlink_error
argument_list|(
name|hook
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hook
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|capabilities_string
decl_stmt|;
if|if
condition|(
name|capabilities
condition|)
block|{
name|capabilities_string
operator|=
name|svn_cstring_join
argument_list|(
name|capabilities
argument_list|,
literal|":"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Get rid of that annoying final colon. */
if|if
condition|(
name|capabilities_string
index|[
literal|0
index|]
condition|)
name|capabilities_string
index|[
name|strlen
argument_list|(
name|capabilities_string
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|capabilities_string
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|args
index|[
literal|0
index|]
operator|=
name|hook
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|user
condition|?
name|user
else|:
literal|""
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|capabilities_string
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|txn_name
expr_stmt|;
name|args
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|run_hook_cmd
argument_list|(
name|NULL
argument_list|,
name|SVN_REPOS__HOOK_START_COMMIT
argument_list|,
name|hook
argument_list|,
name|args
argument_list|,
name|hooks_env
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *HANDLE to an open filehandle for a temporary file (i.e.,    automatically deleted when closed), into which the LOCK_TOKENS have    been written out in the format described in the pre-commit hook    template.     LOCK_TOKENS is as returned by svn_fs__access_get_lock_tokens().     Allocate *HANDLE in POOL, and use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lock_token_content
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|handle
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|lock_str
init|=
name|svn_stringbuf_create
argument_list|(
literal|"LOCK-TOKENS:\n"
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|lock_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|token
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|val
expr_stmt|;
name|svn_stringbuf_appendstr
argument_list|(
name|lock_str
argument_list|,
name|svn_stringbuf_createf
argument_list|(
name|pool
argument_list|,
literal|"%s|%s\n"
argument_list|,
name|svn_path_uri_autoescape
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendcstr
argument_list|(
name|lock_str
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|create_temp_file
argument_list|(
name|handle
argument_list|,
name|svn_stringbuf__morph_into_string
argument_list|(
name|lock_str
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__hooks_pre_commit
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook
init|=
name|svn_repos_pre_commit_hook
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|broken_link
decl_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|check_hook_cmd
argument_list|(
name|hook
argument_list|,
operator|&
name|broken_link
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|broken_link
condition|)
block|{
return|return
name|hook_symlink_error
argument_list|(
name|hook
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hook
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[
literal|4
index|]
decl_stmt|;
name|svn_fs_access_t
modifier|*
name|access_ctx
decl_stmt|;
name|apr_file_t
modifier|*
name|stdin_handle
init|=
name|NULL
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|hook
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|txn_name
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_access
argument_list|(
operator|&
name|access_ctx
argument_list|,
name|repos
operator|->
name|fs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_ctx
condition|)
block|{
name|apr_hash_t
modifier|*
name|lock_tokens
init|=
name|svn_fs__access_get_lock_tokens
argument_list|(
name|access_ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|lock_tokens
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|lock_token_content
argument_list|(
operator|&
name|stdin_handle
argument_list|,
name|lock_tokens
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|stdin_handle
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|stdin_handle
argument_list|,
name|SVN_NULL_DEVICE_NAME
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|run_hook_cmd
argument_list|(
name|NULL
argument_list|,
name|SVN_REPOS__HOOK_PRE_COMMIT
argument_list|,
name|hook
argument_list|,
name|args
argument_list|,
name|hooks_env
argument_list|,
name|stdin_handle
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__hooks_post_commit
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook
init|=
name|svn_repos_post_commit_hook
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|broken_link
decl_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|check_hook_cmd
argument_list|(
name|hook
argument_list|,
operator|&
name|broken_link
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|broken_link
condition|)
block|{
return|return
name|hook_symlink_error
argument_list|(
name|hook
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hook
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[
literal|5
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|hook
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|txn_name
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|run_hook_cmd
argument_list|(
name|NULL
argument_list|,
name|SVN_REPOS__HOOK_POST_COMMIT
argument_list|,
name|hook
argument_list|,
name|args
argument_list|,
name|hooks_env
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__hooks_pre_revprop_change
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|new_value
parameter_list|,
name|char
name|action
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook
init|=
name|svn_repos_pre_revprop_change_hook
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|broken_link
decl_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|check_hook_cmd
argument_list|(
name|hook
argument_list|,
operator|&
name|broken_link
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|broken_link
condition|)
block|{
return|return
name|hook_symlink_error
argument_list|(
name|hook
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hook
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[
literal|7
index|]
decl_stmt|;
name|apr_file_t
modifier|*
name|stdin_handle
init|=
name|NULL
decl_stmt|;
name|char
name|action_string
index|[
literal|2
index|]
decl_stmt|;
comment|/* Pass the new value as stdin to hook */
if|if
condition|(
name|new_value
condition|)
name|SVN_ERR
argument_list|(
name|create_temp_file
argument_list|(
operator|&
name|stdin_handle
argument_list|,
name|new_value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|stdin_handle
argument_list|,
name|SVN_NULL_DEVICE_NAME
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|action_string
index|[
literal|0
index|]
operator|=
name|action
expr_stmt|;
name|action_string
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|hook
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|author
condition|?
name|author
else|:
literal|""
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|name
expr_stmt|;
name|args
index|[
literal|5
index|]
operator|=
name|action_string
expr_stmt|;
name|args
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|run_hook_cmd
argument_list|(
name|NULL
argument_list|,
name|SVN_REPOS__HOOK_PRE_REVPROP_CHANGE
argument_list|,
name|hook
argument_list|,
name|args
argument_list|,
name|hooks_env
argument_list|,
name|stdin_handle
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|stdin_handle
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the pre- hook doesn't exist at all, then default to          MASSIVE PARANOIA.  Changing revision properties is a lossy          operation; so unless the repository admininstrator has          *deliberately* created the pre-hook, disallow all changes. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_DISABLED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Repository has not been enabled to accept revision propchanges;\n"
literal|"ask the administrator to create a pre-revprop-change hook"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__hooks_post_revprop_change
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|old_value
parameter_list|,
name|char
name|action
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook
init|=
name|svn_repos_post_revprop_change_hook
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|broken_link
decl_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|check_hook_cmd
argument_list|(
name|hook
argument_list|,
operator|&
name|broken_link
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|broken_link
condition|)
block|{
return|return
name|hook_symlink_error
argument_list|(
name|hook
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hook
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[
literal|7
index|]
decl_stmt|;
name|apr_file_t
modifier|*
name|stdin_handle
init|=
name|NULL
decl_stmt|;
name|char
name|action_string
index|[
literal|2
index|]
decl_stmt|;
comment|/* Pass the old value as stdin to hook */
if|if
condition|(
name|old_value
condition|)
name|SVN_ERR
argument_list|(
name|create_temp_file
argument_list|(
operator|&
name|stdin_handle
argument_list|,
name|old_value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|stdin_handle
argument_list|,
name|SVN_NULL_DEVICE_NAME
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|action_string
index|[
literal|0
index|]
operator|=
name|action
expr_stmt|;
name|action_string
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|hook
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|author
condition|?
name|author
else|:
literal|""
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|name
expr_stmt|;
name|args
index|[
literal|5
index|]
operator|=
name|action_string
expr_stmt|;
name|args
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|run_hook_cmd
argument_list|(
name|NULL
argument_list|,
name|SVN_REPOS__HOOK_POST_REVPROP_CHANGE
argument_list|,
name|hook
argument_list|,
name|args
argument_list|,
name|hooks_env
argument_list|,
name|stdin_handle
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|stdin_handle
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__hooks_pre_lock
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook
init|=
name|svn_repos_pre_lock_hook
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|broken_link
decl_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|check_hook_cmd
argument_list|(
name|hook
argument_list|,
operator|&
name|broken_link
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|broken_link
condition|)
block|{
return|return
name|hook_symlink_error
argument_list|(
name|hook
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hook
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[
literal|7
index|]
decl_stmt|;
name|svn_string_t
modifier|*
name|buf
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|hook
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|path
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|username
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|comment
condition|?
name|comment
else|:
literal|""
expr_stmt|;
name|args
index|[
literal|5
index|]
operator|=
name|steal_lock
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
name|args
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|run_hook_cmd
argument_list|(
operator|&
name|buf
argument_list|,
name|SVN_REPOS__HOOK_PRE_LOCK
argument_list|,
name|hook
argument_list|,
name|args
argument_list|,
name|hooks_env
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
condition|)
comment|/* No validation here; the FS will take care of that. */
operator|*
name|token
operator|=
name|buf
operator|->
name|data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
condition|)
operator|*
name|token
operator|=
literal|""
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__hooks_post_lock
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook
init|=
name|svn_repos_post_lock_hook
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|broken_link
decl_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|check_hook_cmd
argument_list|(
name|hook
argument_list|,
operator|&
name|broken_link
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|broken_link
condition|)
block|{
return|return
name|hook_symlink_error
argument_list|(
name|hook
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hook
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[
literal|5
index|]
decl_stmt|;
name|apr_file_t
modifier|*
name|stdin_handle
init|=
name|NULL
decl_stmt|;
name|svn_string_t
modifier|*
name|paths_str
init|=
name|svn_string_create
argument_list|(
name|svn_cstring_join
argument_list|(
name|paths
argument_list|,
literal|"\n"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|create_temp_file
argument_list|(
operator|&
name|stdin_handle
argument_list|,
name|paths_str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|hook
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|username
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|run_hook_cmd
argument_list|(
name|NULL
argument_list|,
name|SVN_REPOS__HOOK_POST_LOCK
argument_list|,
name|hook
argument_list|,
name|args
argument_list|,
name|hooks_env
argument_list|,
name|stdin_handle
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|stdin_handle
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__hooks_pre_unlock
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|svn_boolean_t
name|break_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook
init|=
name|svn_repos_pre_unlock_hook
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|broken_link
decl_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|check_hook_cmd
argument_list|(
name|hook
argument_list|,
operator|&
name|broken_link
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|broken_link
condition|)
block|{
return|return
name|hook_symlink_error
argument_list|(
name|hook
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hook
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[
literal|7
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|hook
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|path
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|username
condition|?
name|username
else|:
literal|""
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|token
condition|?
name|token
else|:
literal|""
expr_stmt|;
name|args
index|[
literal|5
index|]
operator|=
name|break_lock
condition|?
literal|"1"
else|:
literal|"0"
expr_stmt|;
name|args
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|run_hook_cmd
argument_list|(
name|NULL
argument_list|,
name|SVN_REPOS__HOOK_PRE_UNLOCK
argument_list|,
name|hook
argument_list|,
name|args
argument_list|,
name|hooks_env
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__hooks_post_unlock
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_hash_t
modifier|*
name|hooks_env
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook
init|=
name|svn_repos_post_unlock_hook
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|broken_link
decl_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|check_hook_cmd
argument_list|(
name|hook
argument_list|,
operator|&
name|broken_link
argument_list|,
name|pool
argument_list|)
operator|)
operator|&&
name|broken_link
condition|)
block|{
return|return
name|hook_symlink_error
argument_list|(
name|hook
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hook
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[
literal|5
index|]
decl_stmt|;
name|apr_file_t
modifier|*
name|stdin_handle
init|=
name|NULL
decl_stmt|;
name|svn_string_t
modifier|*
name|paths_str
init|=
name|svn_string_create
argument_list|(
name|svn_cstring_join
argument_list|(
name|paths
argument_list|,
literal|"\n"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|create_temp_file
argument_list|(
operator|&
name|stdin_handle
argument_list|,
name|paths_str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|hook
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|svn_repos_path
argument_list|(
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|username
condition|?
name|username
else|:
literal|""
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|run_hook_cmd
argument_list|(
name|NULL
argument_list|,
name|SVN_REPOS__HOOK_POST_UNLOCK
argument_list|,
name|hook
argument_list|,
name|args
argument_list|,
name|hooks_env
argument_list|,
name|stdin_handle
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|stdin_handle
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * vim:ts=4:sw=4:expandtab:tw=80:fo=tcroq  * vim:isk=a-z,A-Z,48-57,_,.,-,>  * vim:cino=>1s,e0,n0,f0,{.5s,}0,^-.5s,=.5s,t0,+1s,c3,(0,u0,\:0  */
end_comment

end_unit

