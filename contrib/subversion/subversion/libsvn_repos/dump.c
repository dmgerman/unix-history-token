begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dump.c --- writing filesystem contents into a portable 'dumpfile' format.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_iter.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cache.h"
end_include

begin_define
define|#
directive|define
name|ARE_VALID_COPY_ARGS
parameter_list|(
name|p
parameter_list|,
name|r
parameter_list|)
value|((p)&& SVN_IS_VALID_REVNUM(r))
end_define

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/* To be able to check whether a path exists in the current revision    (as changes come in), we need to track the relevant tree changes.     In particular, we remember deletions, additions and copies including    their copy-from info.  Since the dump performs a pre-order tree walk,    we only need to store the data for the stack of parent folders.     The problem that we are trying to solve is that the dump receives    transforming operations whose validity depends on previous operations    in the same revision but cannot be checked against the final state    as stored in the repository as that is the state *after* we applied    the respective tree changes.     Note that the tracker functions don't perform any sanity or validity    checks.  Those higher-level tests have to be done in the calling code.    However, there is no way to corrupt the data structure using the    provided functions.  */
end_comment

begin_comment
comment|/* Single entry in the path tracker.  Not all levels along the path    hierarchy do need to have an instance of this struct but only those    that got changed by a tree modification.     Please note that the path info in this struct is stored in re-usable    stringbuf objects such that we don't need to allocate more memory than    the longest path we encounter.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|path_tracker_entry_t
block|{
comment|/* path in the current tree */
name|svn_stringbuf_t
modifier|*
name|path
decl_stmt|;
comment|/* copy-from path (must be empty if COPYFROM_REV is SVN_INVALID_REVNUM) */
name|svn_stringbuf_t
modifier|*
name|copyfrom_path
decl_stmt|;
comment|/* copy-from revision (SVN_INVALID_REVNUM for additions / replacements      that don't copy history, i.e. with no sub-tree) */
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* if FALSE, PATH has been deleted */
name|svn_boolean_t
name|exists
decl_stmt|;
block|}
name|path_tracker_entry_t
typedef|;
end_typedef

begin_comment
comment|/* Tracks all tree modifications above the current path.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|path_tracker_t
block|{
comment|/* Container for all relevant tree changes in depth order.      May contain more entries than DEPTH to allow for reusing memory.      Only entries 0 .. DEPTH-1 are valid.    */
name|apr_array_header_t
modifier|*
name|stack
decl_stmt|;
comment|/* Number of relevant entries in STACK.  May be 0 */
name|int
name|depth
decl_stmt|;
comment|/* Revision that we current track.  If DEPTH is 0, paths are exist in      REVISION exactly when they exist in REVISION-1.  This applies only      to the current state of our tree walk.    */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* Allocate container entries here. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|path_tracker_t
typedef|;
end_typedef

begin_comment
comment|/* Return a new path tracker object for REVISION, allocated in POOL.  */
end_comment

begin_function
specifier|static
name|path_tracker_t
modifier|*
name|tracker_create
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|path_tracker_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|stack
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|path_tracker_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|result
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Remove all entries from TRACKER that are not relevant to PATH anymore.  * If ALLOW_EXACT_MATCH is FALSE, keep only entries that pertain to  * parent folders but not to PATH itself.  *  * This internal function implicitly updates the tracker state during the  * tree by removing "past" entries.  Other functions will add entries when  * we encounter a new tree change.  */
end_comment

begin_function
specifier|static
name|void
name|tracker_trim
parameter_list|(
name|path_tracker_t
modifier|*
name|tracker
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|allow_exact_match
parameter_list|)
block|{
comment|/* remove everything that is unrelated to PATH.      Note that TRACKER->STACK is depth-ordered,      i.e. stack[N] is a (maybe indirect) parent of stack[N+1]      for N+1< DEPTH.    */
for|for
control|(
init|;
name|tracker
operator|->
name|depth
condition|;
operator|--
name|tracker
operator|->
name|depth
control|)
block|{
name|path_tracker_entry_t
modifier|*
name|parent
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|tracker
operator|->
name|stack
argument_list|,
name|tracker
operator|->
name|depth
operator|-
literal|1
argument_list|,
name|path_tracker_entry_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_path
init|=
name|svn_dirent_skip_ancestor
argument_list|(
name|parent
operator|->
name|path
operator|->
name|data
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|/* always keep parents.  Keep exact matches when allowed. */
if|if
condition|(
name|rel_path
operator|&&
operator|(
name|allow_exact_match
operator|||
operator|*
name|rel_path
operator|!=
literal|'\0'
operator|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Using TRACKER, check what path at what revision in the repository must    be checked to decide that whether PATH exists.  Return the info in    *ORIG_PATH and *ORIG_REV, respectively.     If the path is known to not exist, *ORIG_PATH will be NULL and *ORIG_REV    will be SVN_INVALID_REVNUM.  If *ORIG_REV is SVN_INVALID_REVNUM, PATH    has just been added in the revision currently being tracked.     Use POOL for allocations.  Note that *ORIG_PATH may be allocated in POOL,    a reference to internal data with the same lifetime as TRACKER or just    PATH.  */
end_comment

begin_function
specifier|static
name|void
name|tracker_lookup
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|orig_path
parameter_list|,
name|svn_revnum_t
modifier|*
name|orig_rev
parameter_list|,
name|path_tracker_t
modifier|*
name|tracker
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|tracker_trim
argument_list|(
name|tracker
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracker
operator|->
name|depth
operator|==
literal|0
condition|)
block|{
comment|/* no tree changes -> paths are the same as in the previous rev. */
operator|*
name|orig_path
operator|=
name|path
expr_stmt|;
operator|*
name|orig_rev
operator|=
name|tracker
operator|->
name|revision
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|path_tracker_entry_t
modifier|*
name|parent
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|tracker
operator|->
name|stack
argument_list|,
name|tracker
operator|->
name|depth
operator|-
literal|1
argument_list|,
name|path_tracker_entry_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|exists
condition|)
block|{
specifier|const
name|char
modifier|*
name|rel_path
init|=
name|svn_dirent_skip_ancestor
argument_list|(
name|parent
operator|->
name|path
operator|->
name|data
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|copyfrom_rev
operator|!=
name|SVN_INVALID_REVNUM
condition|)
block|{
comment|/* parent is a copy with history. Translate path. */
operator|*
name|orig_path
operator|=
name|svn_dirent_join
argument_list|(
name|parent
operator|->
name|copyfrom_path
operator|->
name|data
argument_list|,
name|rel_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|orig_rev
operator|=
name|parent
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|rel_path
operator|==
literal|'\0'
condition|)
block|{
comment|/* added in this revision with no history */
operator|*
name|orig_path
operator|=
name|path
expr_stmt|;
operator|*
name|orig_rev
operator|=
name|tracker
operator|->
name|revision
expr_stmt|;
block|}
else|else
block|{
comment|/* parent got added but not this path */
operator|*
name|orig_path
operator|=
name|NULL
expr_stmt|;
operator|*
name|orig_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* (maybe parent) path has been deleted */
operator|*
name|orig_path
operator|=
name|NULL
expr_stmt|;
operator|*
name|orig_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a reference to the stack entry in TRACKER for PATH.  If no    suitable entry exists, add one.  Implicitly updates the tracked tree    location.     Only the PATH member of the result is being updated.  All other members    will have undefined values.  */
end_comment

begin_function
specifier|static
name|path_tracker_entry_t
modifier|*
name|tracker_add_entry
parameter_list|(
name|path_tracker_t
modifier|*
name|tracker
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|path_tracker_entry_t
modifier|*
name|entry
decl_stmt|;
name|tracker_trim
argument_list|(
name|tracker
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracker
operator|->
name|depth
operator|==
name|tracker
operator|->
name|stack
operator|->
name|nelts
condition|)
block|{
name|entry
operator|=
name|apr_array_push
argument_list|(
name|tracker
operator|->
name|stack
argument_list|)
expr_stmt|;
name|entry
operator|->
name|path
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|tracker
operator|->
name|pool
argument_list|)
expr_stmt|;
name|entry
operator|->
name|copyfrom_path
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|tracker
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|tracker
operator|->
name|stack
argument_list|,
name|tracker
operator|->
name|depth
argument_list|,
name|path_tracker_entry_t
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_set
argument_list|(
name|entry
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|++
name|tracker
operator|->
name|depth
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Update the TRACKER with a copy from COPYFROM_PATH@COPYFROM_REV to    PATH in the tracked revision.  */
end_comment

begin_function
specifier|static
name|void
name|tracker_path_copy
parameter_list|(
name|path_tracker_t
modifier|*
name|tracker
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|)
block|{
name|path_tracker_entry_t
modifier|*
name|entry
init|=
name|tracker_add_entry
argument_list|(
name|tracker
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|svn_stringbuf_set
argument_list|(
name|entry
operator|->
name|copyfrom_path
argument_list|,
name|copyfrom_path
argument_list|)
expr_stmt|;
name|entry
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
name|entry
operator|->
name|exists
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the TRACKER with a plain addition of PATH (without history).  */
end_comment

begin_function
specifier|static
name|void
name|tracker_path_add
parameter_list|(
name|path_tracker_t
modifier|*
name|tracker
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|path_tracker_entry_t
modifier|*
name|entry
init|=
name|tracker_add_entry
argument_list|(
name|tracker
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|entry
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
name|entry
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|exists
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the TRACKER with a replacement of PATH with a plain addition    (without history).  */
end_comment

begin_function
specifier|static
name|void
name|tracker_path_replace
parameter_list|(
name|path_tracker_t
modifier|*
name|tracker
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
comment|/* this will implicitly purge all previous sub-tree info from STACK.      Thus, no need to tack the deletion explicitly. */
name|tracker_path_add
argument_list|(
name|tracker
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the TRACKER with a deletion of PATH.  */
end_comment

begin_function
specifier|static
name|void
name|tracker_path_delete
parameter_list|(
name|path_tracker_t
modifier|*
name|tracker
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|path_tracker_entry_t
modifier|*
name|entry
init|=
name|tracker_add_entry
argument_list|(
name|tracker
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|entry
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
name|entry
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|exists
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the delta between OLDROOT/OLDPATH and NEWROOT/NEWPATH and    store it into a new temporary file *TEMPFILE.  OLDROOT may be NULL,    in which case the delta will be computed against an empty file, as    per the svn_fs_get_file_delta_stream docstring.  Record the length    of the temporary file in *LEN, and rewind the file before    returning. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_delta
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|tempfile
parameter_list|,
name|svn_filesize_t
modifier|*
name|len
parameter_list|,
name|svn_fs_root_t
modifier|*
name|oldroot
parameter_list|,
specifier|const
name|char
modifier|*
name|oldpath
parameter_list|,
name|svn_fs_root_t
modifier|*
name|newroot
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|temp_stream
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
decl_stmt|;
name|svn_txdelta_window_handler_t
name|wh
decl_stmt|;
name|void
modifier|*
name|whb
decl_stmt|;
comment|/* Create a temporary file and open a stream to it. Note that we need      the file handle in order to rewind it. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|tempfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|temp_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
operator|*
name|tempfile
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Compute the delta and send it to the temporary file. */
name|SVN_ERR
argument_list|(
name|svn_fs_get_file_delta_stream
argument_list|(
operator|&
name|delta_stream
argument_list|,
name|oldroot
argument_list|,
name|oldpath
argument_list|,
name|newroot
argument_list|,
name|newpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_txdelta_to_svndiff3
argument_list|(
operator|&
name|wh
argument_list|,
operator|&
name|whb
argument_list|,
name|temp_stream
argument_list|,
literal|0
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_txstream
argument_list|(
name|delta_stream
argument_list|,
name|wh
argument_list|,
name|whb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the length of the temporary file and rewind it. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
operator|*
name|tempfile
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|svn_io_file_seek
argument_list|(
operator|*
name|tempfile
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send a notification of type #svn_repos_notify_warning, subtype WARNING,    with message WARNING_FMT formatted with the remaining variable arguments.    Send it by calling NOTIFY_FUNC (if not null) with NOTIFY_BATON.  */
end_comment

begin_macro
name|__attribute__
argument_list|(
argument|(format(printf,
literal|5
argument|,
literal|6
argument|))
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|notify_warning
parameter_list|(
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_repos_notify_warning_t
name|warning
parameter_list|,
specifier|const
name|char
modifier|*
name|warning_fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
name|svn_repos_notify_t
modifier|*
name|notify
decl_stmt|;
if|if
condition|(
name|notify_func
operator|==
name|NULL
condition|)
return|return;
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_warning
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|warning
operator|=
name|warning
expr_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|warning_fmt
argument_list|)
expr_stmt|;
name|notify
operator|->
name|warning_str
operator|=
name|apr_pvsprintf
argument_list|(
name|scratch_pool
argument_list|,
name|warning_fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/* Write to STREAM the header in HEADERS named KEY, if present.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_header
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write headers, in arbitrary order.  * ### TODO: use a stable order  * ### Modifies HEADERS.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revision_headers
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|h
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|revision_headers_order
index|[]
init|=
block|{
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
block|,
comment|/* must be first */
name|NULL
block|}
decl_stmt|;
comment|/* Write some headers in a given order */
for|for
control|(
name|h
operator|=
name|revision_headers_order
init|;
operator|*
name|h
condition|;
name|h
operator|++
control|)
block|{
name|SVN_ERR
argument_list|(
name|write_header
argument_list|(
name|stream
argument_list|,
name|headers
argument_list|,
operator|*
name|h
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|headers
argument_list|,
operator|*
name|h
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Write any and all remaining headers except Content-length.    * ### TODO: use a stable order    */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|headers
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
argument_list|)
operator|!=
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|write_header
argument_list|(
name|stream
argument_list|,
name|headers
argument_list|,
name|key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Content-length must be last */
name|SVN_ERR
argument_list|(
name|write_header
argument_list|(
name|stream
argument_list|,
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A header entry: the element type of the apr_array_header_t which is  * the real type of svn_repos__dumpfile_headers_t.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|svn_repos__dumpfile_header_entry_t
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|val
decl_stmt|;
block|}
name|svn_repos__dumpfile_header_entry_t
typedef|;
end_typedef

begin_function
name|svn_repos__dumpfile_headers_t
modifier|*
name|svn_repos__dumpfile_headers_create
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos__dumpfile_headers_t
modifier|*
name|headers
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|5
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_repos__dumpfile_header_entry_t
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|headers
return|;
block|}
end_function

begin_function
name|void
name|svn_repos__dumpfile_header_push
parameter_list|(
name|svn_repos__dumpfile_headers_t
modifier|*
name|headers
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|svn_repos__dumpfile_header_entry_t
modifier|*
name|h
init|=
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|headers
argument_list|,
name|svn_repos__dumpfile_header_entry_t
argument_list|)
decl_stmt|;
name|h
operator|->
name|key
operator|=
name|apr_pstrdup
argument_list|(
name|headers
operator|->
name|pool
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|h
operator|->
name|val
operator|=
name|apr_pstrdup
argument_list|(
name|headers
operator|->
name|pool
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_repos__dumpfile_header_pushf
parameter_list|(
name|svn_repos__dumpfile_headers_t
modifier|*
name|headers
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val_fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|svn_repos__dumpfile_header_entry_t
modifier|*
name|h
init|=
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|headers
argument_list|,
name|svn_repos__dumpfile_header_entry_t
argument_list|)
decl_stmt|;
name|h
operator|->
name|key
operator|=
name|apr_pstrdup
argument_list|(
name|headers
operator|->
name|pool
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|val_fmt
argument_list|)
expr_stmt|;
name|h
operator|->
name|val
operator|=
name|apr_pvsprintf
argument_list|(
name|headers
operator|->
name|pool
argument_list|,
name|val_fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__dump_headers
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_repos__dumpfile_headers_t
modifier|*
name|headers
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|headers
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_repos__dumpfile_header_entry_t
modifier|*
name|h
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|headers
argument_list|,
name|i
argument_list|,
name|svn_repos__dumpfile_header_entry_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|h
operator|->
name|key
argument_list|,
name|h
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* End of headers */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__dump_revision_record
parameter_list|(
name|svn_stream_t
modifier|*
name|dump_stream
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_hash_t
modifier|*
name|extra_headers
parameter_list|,
name|apr_hash_t
modifier|*
name|revprops
parameter_list|,
name|svn_boolean_t
name|props_section_always
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|propstring
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|headers
decl_stmt|;
if|if
condition|(
name|extra_headers
condition|)
name|headers
operator|=
name|apr_hash_copy
argument_list|(
name|scratch_pool
argument_list|,
name|extra_headers
argument_list|)
expr_stmt|;
else|else
name|headers
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* ### someday write a revision-content-checksum */
name|svn_hash_sets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|revprops
argument_list|)
operator|||
name|props_section_always
condition|)
block|{
name|svn_stream_t
modifier|*
name|propstream
decl_stmt|;
name|propstring
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|propstream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|propstring
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|revprops
argument_list|,
name|propstream
argument_list|,
literal|"PROPS-END"
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|propstream
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
argument_list|,
name|propstring
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|propstring
condition|)
block|{
comment|/* Write out a regular Content-length header for the benefit of          non-Subversion RFC-822 parsers. */
name|svn_hash_sets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
argument_list|,
name|propstring
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|write_revision_headers
argument_list|(
name|dump_stream
argument_list|,
name|headers
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* End of headers */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|dump_stream
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Property data. */
if|if
condition|(
name|propstring
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|dump_stream
argument_list|,
name|propstring
operator|->
name|data
argument_list|,
operator|&
name|propstring
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* put an end to revision */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|dump_stream
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__dump_node_record
parameter_list|(
name|svn_stream_t
modifier|*
name|dump_stream
parameter_list|,
name|svn_repos__dumpfile_headers_t
modifier|*
name|headers
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|props_str
parameter_list|,
name|svn_boolean_t
name|has_text
parameter_list|,
name|svn_filesize_t
name|text_content_length
parameter_list|,
name|svn_boolean_t
name|content_length_always
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_filesize_t
name|content_length
init|=
literal|0
decl_stmt|;
comment|/* add content-length headers */
if|if
condition|(
name|props_str
condition|)
block|{
name|svn_repos__dumpfile_header_pushf
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
argument_list|,
name|props_str
operator|->
name|len
argument_list|)
expr_stmt|;
name|content_length
operator|+=
name|props_str
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
name|has_text
condition|)
block|{
name|svn_repos__dumpfile_header_pushf
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH
argument_list|,
literal|"%"
name|SVN_FILESIZE_T_FMT
argument_list|,
name|text_content_length
argument_list|)
expr_stmt|;
name|content_length
operator|+=
name|text_content_length
expr_stmt|;
block|}
if|if
condition|(
name|content_length_always
operator|||
name|props_str
operator|||
name|has_text
condition|)
block|{
name|svn_repos__dumpfile_header_pushf
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
argument_list|,
literal|"%"
name|SVN_FILESIZE_T_FMT
argument_list|,
name|content_length
argument_list|)
expr_stmt|;
block|}
comment|/* write the headers */
name|SVN_ERR
argument_list|(
name|svn_repos__dump_headers
argument_list|(
name|dump_stream
argument_list|,
name|headers
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the props */
if|if
condition|(
name|props_str
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|dump_stream
argument_list|,
name|props_str
operator|->
name|data
argument_list|,
operator|&
name|props_str
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** An editor which dumps node-data in 'dumpfile format' to a file. **/
end_comment

begin_comment
comment|/* Look, mom!  No file batons! */
end_comment

begin_struct
struct|struct
name|edit_baton
block|{
comment|/* The relpath which implicitly prepends all full paths coming into      this editor.  This will almost always be "".  */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The stream to dump to. */
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* Send feedback here, if non-NULL */
name|svn_repos_notify_func_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
comment|/* The fs revision root, so we can read the contents of paths. */
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
name|svn_revnum_t
name|current_rev
decl_stmt|;
comment|/* The fs, so we can grab historic information if needed. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* True if dumped nodes should output deltas instead of full text. */
name|svn_boolean_t
name|use_deltas
decl_stmt|;
comment|/* True if this "dump" is in fact a verify. */
name|svn_boolean_t
name|verify
decl_stmt|;
comment|/* True if checking UCS normalization during a verify. */
name|svn_boolean_t
name|check_normalization
decl_stmt|;
comment|/* The first revision dumped in this dumpstream. */
name|svn_revnum_t
name|oldest_dumped_rev
decl_stmt|;
comment|/* If not NULL, set to true if any references to revisions older than      OLDEST_DUMPED_REV were found in the dumpstream. */
name|svn_boolean_t
modifier|*
name|found_old_reference
decl_stmt|;
comment|/* If not NULL, set to true if any mergeinfo was dumped which contains      revisions older than OLDEST_DUMPED_REV. */
name|svn_boolean_t
modifier|*
name|found_old_mergeinfo
decl_stmt|;
comment|/* Structure allows us to verify the paths currently being dumped.      If NULL, validity checks are being skipped. */
name|path_tracker_t
modifier|*
name|path_tracker
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dir_baton
block|{
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
comment|/* has this directory been written to the output stream? */
name|svn_boolean_t
name|written_out
decl_stmt|;
comment|/* the repository relpath associated with this directory */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The comparison repository relpath and revision of this directory.      If both of these are valid, use them as a source against which to      compare the directory instead of the default comparison source of      PATH in the previous revision. */
specifier|const
name|char
modifier|*
name|cmp_path
decl_stmt|;
name|svn_revnum_t
name|cmp_rev
decl_stmt|;
comment|/* hash of paths that need to be deleted, though some -might- be      replaced.  maps const char * paths to this dir_baton.  (they're      full paths, because that's what the editor driver gives us.  but      really, they're all within this directory.) */
name|apr_hash_t
modifier|*
name|deleted_entries
decl_stmt|;
comment|/* A flag indicating that new entries have been added to this      directory in this revision. Used to optimize detection of UCS      representation collisions; we will only check for that in      revisions where new names appear in the directory. */
name|svn_boolean_t
name|check_name_collision
decl_stmt|;
comment|/* pool to be used for deleting the hash items */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make a directory baton to represent the directory was path    (relative to EDIT_BATON's path) is PATH.     CMP_PATH/CMP_REV are the path/revision against which this directory    should be compared for changes.  If either is omitted (NULL for the    path, SVN_INVALID_REVNUM for the rev), just compare this directory    PATH against itself in the previous revision.     PB is the directory baton of this directory's parent,    or NULL if this is the top-level directory of the edit.     Perform all allocations in POOL.  */
end_comment

begin_function
specifier|static
name|struct
name|dir_baton
modifier|*
name|make_dir_baton
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|cmp_path
parameter_list|,
name|svn_revnum_t
name|cmp_rev
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|struct
name|dir_baton
modifier|*
name|pb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_db
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
comment|/* A path relative to nothing?  I don't think so. */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
operator|!
name|path
operator|||
name|pb
argument_list|)
expr_stmt|;
comment|/* Construct the full path of this node. */
if|if
condition|(
name|pb
condition|)
name|full_path
operator|=
name|svn_relpath_join
argument_list|(
name|eb
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|full_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|eb
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* Remove leading slashes from copyfrom paths. */
if|if
condition|(
name|cmp_path
condition|)
name|cmp_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|cmp_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_db
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
name|new_db
operator|->
name|path
operator|=
name|full_path
expr_stmt|;
name|new_db
operator|->
name|cmp_path
operator|=
name|cmp_path
expr_stmt|;
name|new_db
operator|->
name|cmp_rev
operator|=
name|cmp_rev
expr_stmt|;
name|new_db
operator|->
name|written_out
operator|=
name|FALSE
expr_stmt|;
name|new_db
operator|->
name|deleted_entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|new_db
operator|->
name|check_name_collision
operator|=
name|FALSE
expr_stmt|;
name|new_db
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|new_db
return|;
block|}
end_function

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return an error when PATH in REVISION does not exist or is of a    different kind than EXPECTED_KIND.  If the latter is svn_node_unknown,    skip that check.  Use EB for context information.  If REVISION is the    current revision, use EB's path tracker to follow renames, deletions,    etc.     Use SCRATCH_POOL for temporary allocations.    No-op if EB's path tracker has not been initialized.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|node_must_exist
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_node_kind_t
name|expected_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
init|=
name|svn_node_none
decl_stmt|;
comment|/* in case the caller is trying something stupid ... */
if|if
condition|(
name|eb
operator|->
name|path_tracker
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* paths pertaining to the revision currently being processed must      be translated / checked using our path tracker. */
if|if
condition|(
name|revision
operator|==
name|eb
operator|->
name|path_tracker
operator|->
name|revision
condition|)
name|tracker_lookup
argument_list|(
operator|&
name|path
argument_list|,
operator|&
name|revision
argument_list|,
name|eb
operator|->
name|path_tracker
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* determine the node type (default: no such node) */
if|if
condition|(
name|path
condition|)
name|SVN_ERR
argument_list|(
name|fetch_kind_func
argument_list|(
operator|&
name|kind
argument_list|,
name|eb
argument_list|,
name|path
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check results */
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' not found in r%ld."
argument_list|)
argument_list|,
name|path
argument_list|,
name|revision
argument_list|)
return|;
if|if
condition|(
name|expected_kind
operator|!=
name|kind
operator|&&
name|expected_kind
operator|!=
name|svn_node_unknown
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected node kind %d for '%s' at r%ld. "
literal|"Expected kind was %d."
argument_list|)
argument_list|,
name|kind
argument_list|,
name|path
argument_list|,
name|revision
argument_list|,
name|expected_kind
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return an error when PATH exists in REVISION.  Use EB for context    information.  If REVISION is the current revision, use EB's path    tracker to follow renames, deletions, etc.     Use SCRATCH_POOL for temporary allocations.    No-op if EB's path tracker has not been initialized.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|node_must_not_exist
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
init|=
name|svn_node_none
decl_stmt|;
comment|/* in case the caller is trying something stupid ... */
if|if
condition|(
name|eb
operator|->
name|path_tracker
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* paths pertaining to the revision currently being processed must      be translated / checked using our path tracker. */
if|if
condition|(
name|revision
operator|==
name|eb
operator|->
name|path_tracker
operator|->
name|revision
condition|)
name|tracker_lookup
argument_list|(
operator|&
name|path
argument_list|,
operator|&
name|revision
argument_list|,
name|eb
operator|->
name|path_tracker
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* determine the node type (default: no such node) */
if|if
condition|(
name|path
condition|)
name|SVN_ERR
argument_list|(
name|fetch_kind_func
argument_list|(
operator|&
name|kind
argument_list|,
name|eb
argument_list|,
name|path
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check results */
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ALREADY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' exists in r%ld."
argument_list|)
argument_list|,
name|path
argument_list|,
name|revision
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If the mergeinfo in MERGEINFO_STR refers to any revisions older than  * OLDEST_DUMPED_REV, issue a warning and set *FOUND_OLD_MERGEINFO to TRUE,  * otherwise leave *FOUND_OLD_MERGEINFO unchanged.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_mergeinfo_revisions
parameter_list|(
name|svn_boolean_t
modifier|*
name|found_old_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|mergeinfo_str
parameter_list|,
name|svn_revnum_t
name|oldest_dumped_rev
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|,
name|old_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo_str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|old_mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|oldest_dumped_rev
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|old_mergeinfo
argument_list|)
condition|)
block|{
name|notify_warning
argument_list|(
name|pool
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|svn_repos_notify_warning_found_old_mergeinfo
argument_list|,
name|_
argument_list|(
literal|"Mergeinfo referencing revision(s) prior "
literal|"to the oldest dumped revision (r%ld). "
literal|"Loading this dump may result in invalid "
literal|"mergeinfo."
argument_list|)
argument_list|,
name|oldest_dumped_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_old_mergeinfo
condition|)
operator|*
name|found_old_mergeinfo
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Unique string pointers used by verify_mergeinfo_normalization()    and check_name_collision() */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|normalized_unique
index|[]
init|=
literal|"normalized_unique"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|normalized_collision
index|[]
init|=
literal|"normalized_collision"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Baton for extract_mergeinfo_paths */
end_comment

begin_struct
struct|struct
name|extract_mergeinfo_paths_baton
block|{
name|apr_hash_t
modifier|*
name|result
decl_stmt|;
name|svn_boolean_t
name|normalize
decl_stmt|;
name|svn_membuf_t
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash iterator that uniquifies all keys into a single hash table,    optionally normalizing them first. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|extract_mergeinfo_paths
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|iterpool
parameter_list|)
block|{
name|struct
name|extract_mergeinfo_paths_baton
modifier|*
specifier|const
name|xb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|xb
operator|->
name|normalize
condition|)
block|{
specifier|const
name|char
modifier|*
name|normkey
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf__normalize
argument_list|(
operator|&
name|normkey
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
operator|&
name|xb
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|xb
operator|->
name|result
argument_list|,
name|apr_pstrdup
argument_list|(
name|xb
operator|->
name|buffer
operator|.
name|pool
argument_list|,
name|normkey
argument_list|)
argument_list|,
name|normalized_unique
argument_list|)
expr_stmt|;
block|}
else|else
name|apr_hash_set
argument_list|(
name|xb
operator|->
name|result
argument_list|,
name|apr_pmemdup
argument_list|(
name|xb
operator|->
name|buffer
operator|.
name|pool
argument_list|,
name|key
argument_list|,
name|klen
operator|+
literal|1
argument_list|)
argument_list|,
name|klen
argument_list|,
name|normalized_unique
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for filter_mergeinfo_paths */
end_comment

begin_struct
struct|struct
name|filter_mergeinfo_paths_baton
block|{
name|apr_hash_t
modifier|*
name|paths
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compare two sets of denormalized paths from mergeinfo entries,    removing duplicates. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|filter_mergeinfo_paths
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|iterpool
parameter_list|)
block|{
name|struct
name|filter_mergeinfo_paths_baton
modifier|*
specifier|const
name|fb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|apr_hash_get
argument_list|(
name|fb
operator|->
name|paths
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
name|apr_hash_set
argument_list|(
name|fb
operator|->
name|paths
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used by the check_mergeinfo_normalization hash iterator. */
end_comment

begin_struct
struct|struct
name|verify_mergeinfo_normalization_baton
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_hash_t
modifier|*
name|normalized_paths
decl_stmt|;
name|svn_membuf_t
name|buffer
decl_stmt|;
name|svn_repos_notify_func_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash iterator that verifies normalization and collision of paths in    an svn:mergeinfo property. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_mergeinfo_normalization
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|iterpool
parameter_list|)
block|{
name|struct
name|verify_mergeinfo_normalization_baton
modifier|*
specifier|const
name|vb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|path
init|=
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|normpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|found
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf__normalize
argument_list|(
operator|&
name|normpath
argument_list|,
name|path
argument_list|,
name|klen
argument_list|,
operator|&
name|vb
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|svn_hash_gets
argument_list|(
name|vb
operator|->
name|normalized_paths
argument_list|,
name|normpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|svn_hash_sets
argument_list|(
name|vb
operator|->
name|normalized_paths
argument_list|,
name|apr_pstrdup
argument_list|(
name|vb
operator|->
name|buffer
operator|.
name|pool
argument_list|,
name|normpath
argument_list|)
argument_list|,
name|normalized_unique
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|found
operator|==
name|normalized_collision
condition|)
comment|/* Skip already reported collision */
empty_stmt|;
else|else
block|{
comment|/* Report path collision in mergeinfo */
name|svn_hash_sets
argument_list|(
name|vb
operator|->
name|normalized_paths
argument_list|,
name|apr_pstrdup
argument_list|(
name|vb
operator|->
name|buffer
operator|.
name|pool
argument_list|,
name|normpath
argument_list|)
argument_list|,
name|normalized_collision
argument_list|)
expr_stmt|;
name|notify_warning
argument_list|(
name|iterpool
argument_list|,
name|vb
operator|->
name|notify_func
argument_list|,
name|vb
operator|->
name|notify_baton
argument_list|,
name|svn_repos_notify_warning_mergeinfo_collision
argument_list|,
name|_
argument_list|(
literal|"Duplicate representation of path '%s'"
literal|" in %s property of '%s'"
argument_list|)
argument_list|,
name|normpath
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|vb
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Check UCS normalization of mergeinfo for PATH. NEW_MERGEINFO is the    svn:mergeinfo property value being set; OLD_MERGEINFO is the    previous property value, which may be NULL. Only the paths that    were added in are checked, including collision checks. This    minimizes the number of notifications we generate for a given    mergeinfo property. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_mergeinfo_normalization
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|new_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|old_mergeinfo
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
name|apr_hash_t
modifier|*
name|normalized_paths
decl_stmt|;
name|apr_hash_t
modifier|*
name|added_paths
decl_stmt|;
name|struct
name|extract_mergeinfo_paths_baton
name|extract_baton
decl_stmt|;
name|struct
name|verify_mergeinfo_normalization_baton
name|verify_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|new_mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|extract_baton
operator|.
name|result
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|extract_baton
operator|.
name|normalize
operator|=
name|FALSE
expr_stmt|;
name|svn_membuf__create
argument_list|(
operator|&
name|extract_baton
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_iter_apr_hash
argument_list|(
name|NULL
argument_list|,
name|mergeinfo
argument_list|,
name|extract_mergeinfo_paths
argument_list|,
operator|&
name|extract_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|added_paths
operator|=
name|extract_baton
operator|.
name|result
expr_stmt|;
if|if
condition|(
name|old_mergeinfo
condition|)
block|{
name|struct
name|filter_mergeinfo_paths_baton
name|filter_baton
decl_stmt|;
name|svn_mergeinfo_t
name|oldinfo
decl_stmt|;
name|extract_baton
operator|.
name|result
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|extract_baton
operator|.
name|normalize
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|oldinfo
argument_list|,
name|old_mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_iter_apr_hash
argument_list|(
name|NULL
argument_list|,
name|oldinfo
argument_list|,
name|extract_mergeinfo_paths
argument_list|,
operator|&
name|extract_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|normalized_paths
operator|=
name|extract_baton
operator|.
name|result
expr_stmt|;
name|filter_baton
operator|.
name|paths
operator|=
name|added_paths
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_iter_apr_hash
argument_list|(
name|NULL
argument_list|,
name|oldinfo
argument_list|,
name|filter_mergeinfo_paths
argument_list|,
operator|&
name|filter_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|normalized_paths
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|verify_baton
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|verify_baton
operator|.
name|normalized_paths
operator|=
name|normalized_paths
expr_stmt|;
name|verify_baton
operator|.
name|buffer
operator|=
name|extract_baton
operator|.
name|buffer
expr_stmt|;
name|verify_baton
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|verify_baton
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_iter_apr_hash
argument_list|(
name|NULL
argument_list|,
name|added_paths
argument_list|,
name|verify_mergeinfo_normalization
argument_list|,
operator|&
name|verify_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A special case of dump_node(), for a delete record.  *  * The only thing special about this version is it only writes one blank  * line, not two, after the headers. Why? Historical precedent for the  * case where a delete record is used as part of a (delete + add-with-history)  * in implementing a replacement.  *  * Also it doesn't do a path-tracker check.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_node_delete
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|node_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos__dumpfile_headers_t
modifier|*
name|headers
init|=
name|svn_repos__dumpfile_headers_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Node-path: ... */
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
argument_list|,
name|node_relpath
argument_list|)
expr_stmt|;
comment|/* Node-action: delete */
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__dump_headers
argument_list|(
name|stream
argument_list|,
name|headers
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This helper is the main "meat" of the editor -- it does all the    work of writing a node record.     Write out a node record for PATH of type KIND under EB->FS_ROOT.    ACTION describes what is happening to the node (see enum svn_node_action).    Write record to writable EB->STREAM.     If the node was itself copied, IS_COPY is TRUE and the    path/revision of the copy source are in CMP_PATH/CMP_REV.  If    IS_COPY is FALSE, yet CMP_PATH/CMP_REV are valid, this node is part    of a copied subtree.   */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_node
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|enum
name|svn_node_action
name|action
parameter_list|,
name|svn_boolean_t
name|is_copy
parameter_list|,
specifier|const
name|char
modifier|*
name|cmp_path
parameter_list|,
name|svn_revnum_t
name|cmp_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|propstring
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_boolean_t
name|must_dump_text
init|=
name|FALSE
decl_stmt|,
name|must_dump_props
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|compare_path
init|=
name|path
decl_stmt|;
name|svn_revnum_t
name|compare_rev
init|=
name|eb
operator|->
name|current_rev
operator|-
literal|1
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|compare_root
init|=
name|NULL
decl_stmt|;
name|apr_file_t
modifier|*
name|delta_file
init|=
name|NULL
decl_stmt|;
name|svn_repos__dumpfile_headers_t
modifier|*
name|headers
init|=
name|svn_repos__dumpfile_headers_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_filesize_t
name|textlen
decl_stmt|;
comment|/* Maybe validate the path. */
if|if
condition|(
name|eb
operator|->
name|verify
operator|||
name|eb
operator|->
name|notify_func
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs__path_valid
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|eb
operator|->
name|notify_func
condition|)
block|{
name|char
name|errbuf
index|[
literal|512
index|]
decl_stmt|;
comment|/* ### svn_strerror() magic number  */
name|notify_warning
argument_list|(
name|pool
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|svn_repos_notify_warning_invalid_fspath
argument_list|,
name|_
argument_list|(
literal|"E%06d: While validating fspath '%s': %s"
argument_list|)
argument_list|,
name|err
operator|->
name|apr_err
argument_list|,
name|path
argument_list|,
name|svn_err_best_message
argument_list|(
name|err
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Return the error in addition to notifying about it. */
if|if
condition|(
name|eb
operator|->
name|verify
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
else|else
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write out metadata headers for this file node. */
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|,
literal|"file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|,
literal|"dir"
argument_list|)
expr_stmt|;
comment|/* Remove leading slashes from copyfrom paths. */
if|if
condition|(
name|cmp_path
condition|)
name|cmp_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|cmp_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Validate the comparison path/rev. */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|cmp_path
argument_list|,
name|cmp_rev
argument_list|)
condition|)
block|{
name|compare_path
operator|=
name|cmp_path
expr_stmt|;
name|compare_rev
operator|=
name|cmp_rev
expr_stmt|;
block|}
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|svn_node_action_change
case|:
if|if
condition|(
name|eb
operator|->
name|path_tracker
condition|)
name|SVN_ERR_W
argument_list|(
name|node_must_exist
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|current_rev
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Change invalid path '%s' in r%ld"
argument_list|)
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|current_rev
argument_list|)
argument_list|)
expr_stmt|;
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|,
literal|"change"
argument_list|)
expr_stmt|;
comment|/* either the text or props changed, or possibly both. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|compare_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|eb
operator|->
name|fs_root
argument_list|)
argument_list|,
name|compare_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_props_changed
argument_list|(
operator|&
name|must_dump_props
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_contents_changed
argument_list|(
operator|&
name|must_dump_text
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_action_delete
case|:
if|if
condition|(
name|eb
operator|->
name|path_tracker
condition|)
block|{
name|SVN_ERR_W
argument_list|(
name|node_must_exist
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|current_rev
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Deleting invalid path '%s' in r%ld"
argument_list|)
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|current_rev
argument_list|)
argument_list|)
expr_stmt|;
name|tracker_path_delete
argument_list|(
name|eb
operator|->
name|path_tracker
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
comment|/* we can leave this routine quietly now, don't need to dump          any content. */
name|must_dump_text
operator|=
name|FALSE
expr_stmt|;
name|must_dump_props
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|svn_node_action_replace
case|:
if|if
condition|(
name|eb
operator|->
name|path_tracker
condition|)
name|SVN_ERR_W
argument_list|(
name|node_must_exist
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|current_rev
argument_list|,
name|svn_node_unknown
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Replacing non-existent path '%s' in r%ld"
argument_list|)
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|current_rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_copy
condition|)
block|{
if|if
condition|(
name|eb
operator|->
name|path_tracker
condition|)
name|tracker_path_replace
argument_list|(
name|eb
operator|->
name|path_tracker
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* a simple delete+add, implied by a single 'replace' action. */
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|,
literal|"replace"
argument_list|)
expr_stmt|;
comment|/* definitely need to dump all content for a replace. */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|must_dump_text
operator|=
name|TRUE
expr_stmt|;
name|must_dump_props
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* more complex:  delete original, then add-with-history.  */
comment|/* ### Why not write a 'replace' record? Don't know. */
if|if
condition|(
name|eb
operator|->
name|path_tracker
condition|)
block|{
name|tracker_path_delete
argument_list|(
name|eb
operator|->
name|path_tracker
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* ### Unusually, we end this 'delete' node record with only a single                  blank line after the header block -- no extra blank line. */
name|SVN_ERR
argument_list|(
name|dump_node_delete
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The remaining action is a non-replacing add-with-history */
comment|/* action = svn_node_action_add; */
block|}
comment|/* FALL THROUGH to 'add' */
case|case
name|svn_node_action_add
case|:
if|if
condition|(
name|eb
operator|->
name|path_tracker
condition|)
name|SVN_ERR_W
argument_list|(
name|node_must_not_exist
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|current_rev
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Adding already existing path '%s' in r%ld"
argument_list|)
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|current_rev
argument_list|)
argument_list|)
expr_stmt|;
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_copy
condition|)
block|{
if|if
condition|(
name|eb
operator|->
name|path_tracker
condition|)
name|tracker_path_add
argument_list|(
name|eb
operator|->
name|path_tracker
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Dump all contents for a simple 'add'. */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|must_dump_text
operator|=
name|TRUE
expr_stmt|;
name|must_dump_props
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|eb
operator|->
name|path_tracker
condition|)
block|{
name|SVN_ERR_W
argument_list|(
name|node_must_exist
argument_list|(
name|eb
argument_list|,
name|compare_path
argument_list|,
name|compare_rev
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Copying from invalid path to "
literal|"'%s' in r%ld"
argument_list|)
argument_list|,
name|path
argument_list|,
name|eb
operator|->
name|current_rev
argument_list|)
argument_list|)
expr_stmt|;
name|tracker_path_copy
argument_list|(
name|eb
operator|->
name|path_tracker
argument_list|,
name|path
argument_list|,
name|compare_path
argument_list|,
name|compare_rev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eb
operator|->
name|verify
operator|&&
name|cmp_rev
operator|<
name|eb
operator|->
name|oldest_dumped_rev
operator|&&
name|eb
operator|->
name|notify_func
condition|)
block|{
name|notify_warning
argument_list|(
name|pool
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|svn_repos_notify_warning_found_old_reference
argument_list|,
name|_
argument_list|(
literal|"Referencing data in revision %ld,"
literal|" which is older than the oldest"
literal|" dumped revision (r%ld).  Loading this dump"
literal|" into an empty repository"
literal|" will fail."
argument_list|)
argument_list|,
name|cmp_rev
argument_list|,
name|eb
operator|->
name|oldest_dumped_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|found_old_reference
condition|)
operator|*
name|eb
operator|->
name|found_old_reference
operator|=
name|TRUE
expr_stmt|;
block|}
name|svn_repos__dumpfile_header_pushf
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
argument_list|,
literal|"%ld"
argument_list|,
name|cmp_rev
argument_list|)
expr_stmt|;
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH
argument_list|,
name|cmp_path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|compare_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|eb
operator|->
name|fs_root
argument_list|)
argument_list|,
name|compare_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Need to decide if the copied node had any extra textual or              property mods as well.  */
name|SVN_ERR
argument_list|(
name|svn_fs_props_changed
argument_list|(
operator|&
name|must_dump_props
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex_digest
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_contents_changed
argument_list|(
operator|&
name|must_dump_text
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_MD5
argument_list|,
name|hex_digest
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_SHA1
argument_list|,
name|hex_digest
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
operator|(
operator|!
name|must_dump_text
operator|)
operator|&&
operator|(
operator|!
name|must_dump_props
operator|)
condition|)
block|{
comment|/* If we're not supposed to dump text or props, so be it, we can          just go home.  However, if either one needs to be dumped,          then our dumpstream format demands that at a *minimum*, we          see a lone "PROPS-END" as a divider between text and props          content within the content-block. */
name|SVN_ERR
argument_list|(
name|svn_repos__dump_headers
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|headers
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
return|return
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|len
argument_list|)
return|;
comment|/* ### needed? */
block|}
comment|/*** Start prepping content to dump... ***/
comment|/* If we are supposed to dump properties, write out a property      length header and generate a stringbuf that contains those      property values here. */
if|if
condition|(
name|must_dump_props
condition|)
block|{
name|apr_hash_t
modifier|*
name|prophash
decl_stmt|,
modifier|*
name|oldhash
init|=
name|NULL
decl_stmt|;
name|svn_stream_t
modifier|*
name|propstream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|prophash
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a partial dump, then issue a warning if we dump mergeinfo          properties that refer to revisions older than the first revision          dumped. */
if|if
condition|(
operator|!
name|eb
operator|->
name|verify
operator|&&
name|eb
operator|->
name|notify_func
operator|&&
name|eb
operator|->
name|oldest_dumped_rev
operator|>
literal|1
condition|)
block|{
name|svn_string_t
modifier|*
name|mergeinfo_str
init|=
name|svn_hash_gets
argument_list|(
name|prophash
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergeinfo_str
condition|)
block|{
comment|/* An error in verifying the mergeinfo must not prevent dumping                  the data. Ignore any such error. */
name|svn_error_clear
argument_list|(
name|verify_mergeinfo_revisions
argument_list|(
name|eb
operator|->
name|found_old_mergeinfo
argument_list|,
name|mergeinfo_str
operator|->
name|data
argument_list|,
name|eb
operator|->
name|oldest_dumped_rev
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we're checking UCS normalization, also parse any changed          mergeinfo and warn about denormalized paths and name          collisions there. */
if|if
condition|(
name|eb
operator|->
name|verify
operator|&&
name|eb
operator|->
name|check_normalization
operator|&&
name|eb
operator|->
name|notify_func
condition|)
block|{
comment|/* N.B.: This hash lookup happens only once; the conditions              for verifying historic mergeinfo references and checking              UCS normalization are mutually exclusive. */
name|svn_string_t
modifier|*
name|mergeinfo_str
init|=
name|svn_hash_gets
argument_list|(
name|prophash
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergeinfo_str
condition|)
block|{
name|svn_string_t
modifier|*
name|oldinfo_str
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|compare_root
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|oldhash
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|oldinfo_str
operator|=
name|svn_hash_gets
argument_list|(
name|oldhash
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|check_mergeinfo_normalization
argument_list|(
name|path
argument_list|,
name|mergeinfo_str
operator|->
name|data
argument_list|,
operator|(
name|oldinfo_str
condition|?
name|oldinfo_str
operator|->
name|data
else|:
name|NULL
operator|)
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eb
operator|->
name|use_deltas
operator|&&
name|compare_root
condition|)
block|{
comment|/* Fetch the old property hash to diff against and output a header              saying that our property contents are a delta. */
if|if
condition|(
operator|!
name|oldhash
condition|)
comment|/* May have been set for normalization check */
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|oldhash
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_DELTA
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
else|else
name|oldhash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|propstring
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|propstream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|propstring
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write_incremental
argument_list|(
name|prophash
argument_list|,
name|oldhash
argument_list|,
name|propstream
argument_list|,
literal|"PROPS-END"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|propstream
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are supposed to dump text, write out a text length header      here, and an MD5 checksum (if available). */
if|if
condition|(
name|must_dump_text
operator|&&
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex_digest
decl_stmt|;
if|if
condition|(
name|eb
operator|->
name|use_deltas
condition|)
block|{
comment|/* Compute the text delta now and write it into a temporary              file, so that we can find its length.  Output a header              saying our text contents are a delta. */
name|SVN_ERR
argument_list|(
name|store_delta
argument_list|(
operator|&
name|delta_file
argument_list|,
operator|&
name|textlen
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_root
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_MD5
argument_list|,
name|hex_digest
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_SHA1
argument_list|,
name|hex_digest
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just fetch the length of the file. */
name|SVN_ERR
argument_list|(
name|svn_fs_file_length
argument_list|(
operator|&
name|textlen
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_MD5
argument_list|,
name|hex_digest
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|svn_repos__dumpfile_header_push
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_SHA1
argument_list|,
name|hex_digest
argument_list|)
expr_stmt|;
block|}
comment|/* 'Content-length:' is the last header before we dump the content,      and is the sum of the text and prop contents lengths.  We write      this only for the benefit of non-Subversion RFC-822 parsers. */
name|SVN_ERR
argument_list|(
name|svn_repos__dump_node_record
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|headers
argument_list|,
name|must_dump_props
condition|?
name|propstring
else|:
name|NULL
argument_list|,
name|must_dump_text
argument_list|,
name|must_dump_text
condition|?
name|textlen
else|:
literal|0
argument_list|,
name|TRUE
comment|/*content_length_always*/
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump text content */
if|if
condition|(
name|must_dump_text
operator|&&
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
condition|)
block|{
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
name|delta_file
condition|)
block|{
comment|/* Make sure to close the underlying file when the stream is              closed. */
name|contents
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|delta_file
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|svn_stream_disown
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
literal|2
expr_stmt|;
return|return
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
literal|"\n\n"
argument_list|,
operator|&
name|len
argument_list|)
return|;
comment|/* ### needed? */
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
operator|*
name|root_baton
operator|=
name|make_dir_baton
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|mypath
init|=
name|apr_pstrdup
argument_list|(
name|pb
operator|->
name|pool
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|/* remember this path needs to be deleted. */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|mypath
argument_list|,
name|pb
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|void
modifier|*
name|was_deleted
decl_stmt|;
name|svn_boolean_t
name|is_copy
init|=
name|FALSE
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
init|=
name|make_dir_baton
argument_list|(
name|path
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|eb
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* This might be a replacement -- is the path already deleted? */
name|was_deleted
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Detect an add-with-history. */
name|is_copy
operator|=
name|ARE_VALID_COPY_ARGS
argument_list|(
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|)
expr_stmt|;
comment|/* Dump the node. */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|svn_node_dir
argument_list|,
name|was_deleted
condition|?
name|svn_node_action_replace
else|:
name|svn_node_action_add
argument_list|,
name|is_copy
argument_list|,
name|is_copy
condition|?
name|copyfrom_path
else|:
name|NULL
argument_list|,
name|is_copy
condition|?
name|copyfrom_rev
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_deleted
condition|)
comment|/* Delete the path, it's now been dumped. */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check for normalized name clashes, but only if this is actually a      new name in the parent, not a replacement. */
if|if
condition|(
operator|!
name|was_deleted
operator|&&
name|eb
operator|->
name|verify
operator|&&
name|eb
operator|->
name|check_normalization
operator|&&
name|eb
operator|->
name|notify_func
condition|)
block|{
name|pb
operator|->
name|check_name_collision
operator|=
name|TRUE
expr_stmt|;
block|}
name|new_db
operator|->
name|written_out
operator|=
name|TRUE
expr_stmt|;
operator|*
name|child_baton
operator|=
name|new_db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmp_path
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|cmp_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* If the parent directory has explicit comparison path and rev,      record the same for this one. */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|pb
operator|->
name|cmp_path
argument_list|,
name|pb
operator|->
name|cmp_rev
argument_list|)
condition|)
block|{
name|cmp_path
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|cmp_path
argument_list|,
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|cmp_rev
operator|=
name|pb
operator|->
name|cmp_rev
expr_stmt|;
block|}
name|new_db
operator|=
name|make_dir_baton
argument_list|(
name|path
argument_list|,
name|cmp_path
argument_list|,
name|cmp_rev
argument_list|,
name|eb
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|new_db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_entries
decl_stmt|;
comment|/* Sort entries lexically instead of as paths. Even though the entries    * are full paths they're all in the same directory (see comment in struct    * dir_baton definition). So we really want to sort by basename, in which    * case the lexical sort function is more efficient. */
name|sorted_entries
operator|=
name|svn_sort__hash
argument_list|(
name|db
operator|->
name|deleted_entries
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_entries
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_entries
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|.
name|key
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* By sending 'svn_node_unknown', the Node-kind: header simply won't          be written out.  No big deal at all, really.  The loader          shouldn't care.  */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_node_action_delete
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|void
modifier|*
name|was_deleted
decl_stmt|;
name|svn_boolean_t
name|is_copy
init|=
name|FALSE
decl_stmt|;
comment|/* This might be a replacement -- is the path already deleted? */
name|was_deleted
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Detect add-with-history. */
name|is_copy
operator|=
name|ARE_VALID_COPY_ARGS
argument_list|(
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|)
expr_stmt|;
comment|/* Dump the node. */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|svn_node_file
argument_list|,
name|was_deleted
condition|?
name|svn_node_action_replace
else|:
name|svn_node_action_add
argument_list|,
name|is_copy
argument_list|,
name|is_copy
condition|?
name|copyfrom_path
else|:
name|NULL
argument_list|,
name|is_copy
condition|?
name|copyfrom_rev
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_deleted
condition|)
comment|/* delete the path, it's now been dumped. */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check for normalized name clashes, but only if this is actually a      new name in the parent, not a replacement. */
if|if
condition|(
operator|!
name|was_deleted
operator|&&
name|eb
operator|->
name|verify
operator|&&
name|eb
operator|->
name|check_normalization
operator|&&
name|eb
operator|->
name|notify_func
condition|)
block|{
name|pb
operator|->
name|check_name_collision
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|file_baton
operator|=
name|NULL
expr_stmt|;
comment|/* muhahahaha */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|ancestor_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmp_path
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|cmp_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* If the parent directory has explicit comparison path and rev,      record the same for this one. */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|pb
operator|->
name|cmp_path
argument_list|,
name|pb
operator|->
name|cmp_rev
argument_list|)
condition|)
block|{
name|cmp_path
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|cmp_path
argument_list|,
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|cmp_rev
operator|=
name|pb
operator|->
name|cmp_rev
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|svn_node_file
argument_list|,
name|svn_node_action_change
argument_list|,
name|FALSE
argument_list|,
name|cmp_path
argument_list|,
name|cmp_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|NULL
expr_stmt|;
comment|/* muhahahaha again */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
comment|/* This function is what distinguishes between a directory that is      opened to merely get somewhere, vs. one that is opened because it      *actually* changed by itself.       Instead of recording the prop changes here, we just use this method      to trigger writing the node; dump_node() finds all the changes. */
if|if
condition|(
operator|!
name|db
operator|->
name|written_out
condition|)
block|{
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_node_action_change
argument_list|,
comment|/* ### We pass is_copy=FALSE; this might be wrong                            but the parameter isn't used when action=change. */
name|FALSE
argument_list|,
name|db
operator|->
name|cmp_path
argument_list|,
name|db
operator|->
name|cmp_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|written_out
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|current_rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_node_proplist
argument_list|(
name|props
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|current_rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
name|kind
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_filename
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|current_rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|file_stream
argument_list|,
operator|&
name|tmp_filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|file_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|tmp_filename
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dump_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|to_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|root_path
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_boolean_t
modifier|*
name|found_old_reference
parameter_list|,
name|svn_boolean_t
modifier|*
name|found_old_mergeinfo
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|custom_close_directory
function_decl|)
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_revnum_t
name|oldest_dumped_rev
parameter_list|,
name|svn_boolean_t
name|use_deltas
parameter_list|,
name|svn_boolean_t
name|verify
parameter_list|,
name|svn_boolean_t
name|check_normalization
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Allocate an edit baton to be stored in every directory baton.      Set it up for the directory baton we create here, which is the      root baton. */
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
name|svn_delta_editor_t
modifier|*
name|dump_editor
init|=
name|svn_delta_default_editor
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Set up the edit baton. */
name|eb
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|eb
operator|->
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|eb
operator|->
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|eb
operator|->
name|oldest_dumped_rev
operator|=
name|oldest_dumped_rev
expr_stmt|;
name|eb
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|root_path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
operator|(
name|eb
operator|->
name|fs_root
operator|)
argument_list|,
name|fs
argument_list|,
name|to_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|eb
operator|->
name|current_rev
operator|=
name|to_rev
expr_stmt|;
name|eb
operator|->
name|use_deltas
operator|=
name|use_deltas
expr_stmt|;
name|eb
operator|->
name|verify
operator|=
name|verify
expr_stmt|;
name|eb
operator|->
name|check_normalization
operator|=
name|check_normalization
expr_stmt|;
name|eb
operator|->
name|found_old_reference
operator|=
name|found_old_reference
expr_stmt|;
name|eb
operator|->
name|found_old_mergeinfo
operator|=
name|found_old_mergeinfo
expr_stmt|;
comment|/* In non-verification mode, we will allow anything to be dumped because      it might be an incremental dump with possible manual intervention.      Also, this might be the last resort when it comes to data recovery.       Else, make sure that all paths exists at their respective revisions.   */
name|eb
operator|->
name|path_tracker
operator|=
name|verify
condition|?
name|tracker_create
argument_list|(
name|to_rev
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* Set up the editor. */
name|dump_editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|dump_editor
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|dump_editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|dump_editor
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
if|if
condition|(
name|custom_close_directory
condition|)
name|dump_editor
operator|->
name|close_directory
operator|=
name|custom_close_directory
expr_stmt|;
else|else
name|dump_editor
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|dump_editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|dump_editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|dump_editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|editor
operator|=
name|dump_editor
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_baton
operator|=
name|eb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor__insert_shims
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|*
name|editor
argument_list|,
operator|*
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|shim_callbacks
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** The main dumping routine, svn_repos_dump_fs. **/
end_comment

begin_comment
comment|/* Helper for svn_repos_dump_fs.     Write a revision record of REV in FS to writable STREAM, using POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revision_record
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_time_t
name|timetemp
decl_stmt|;
name|svn_string_t
modifier|*
name|datevalue
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run revision date properties through the time conversion to      canonicalize them. */
comment|/* ### Remove this when it is no longer needed for sure. */
name|datevalue
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|datevalue
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|timetemp
argument_list|,
name|datevalue
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|datevalue
operator|=
name|svn_string_create
argument_list|(
name|svn_time_to_cstring
argument_list|(
name|timetemp
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|datevalue
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_repos__dump_revision_record
argument_list|(
name|stream
argument_list|,
name|rev
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|TRUE
comment|/*props_section_always*/
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The main dumper. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_dump_fs3
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
name|svn_boolean_t
name|use_deltas
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|dump_editor
decl_stmt|;
name|void
modifier|*
name|dump_edit_baton
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
name|int
name|version
decl_stmt|;
name|svn_boolean_t
name|found_old_reference
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|found_old_mergeinfo
init|=
name|FALSE
decl_stmt|;
name|svn_repos_notify_t
modifier|*
name|notify
decl_stmt|;
comment|/* Determine the current youngest revision of the filesystem. */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use default vals if necessary. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
condition|)
name|start_rev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
condition|)
name|end_rev
operator|=
name|youngest
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
name|stream
operator|=
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Validate the revisions. */
if|if
condition|(
name|start_rev
operator|>
name|end_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Start revision %ld"
literal|" is greater than end revision %ld"
argument_list|)
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|)
return|;
if|if
condition|(
name|end_rev
operator|>
name|youngest
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"End revision %ld is invalid "
literal|"(youngest revision is %ld)"
argument_list|)
argument_list|,
name|end_rev
argument_list|,
name|youngest
argument_list|)
return|;
comment|/* Write out the UUID. */
name|SVN_ERR
argument_list|(
name|svn_fs_get_uuid
argument_list|(
name|fs
argument_list|,
operator|&
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're not using deltas, use the previous version, for      compatibility with svn 1.0.x. */
name|version
operator|=
name|SVN_REPOS_DUMPFILE_FORMAT_VERSION
expr_stmt|;
if|if
condition|(
operator|!
name|use_deltas
condition|)
name|version
operator|--
expr_stmt|;
comment|/* Write out "general" metadata for the dumpfile.  In this case, a      magic header followed by a dumpfile format version. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_MAGIC_HEADER
literal|": %d\n\n"
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_UUID
literal|": %s\n\n"
argument_list|,
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a notify object that we can reuse in the loop. */
if|if
condition|(
name|notify_func
condition|)
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_dump_rev_end
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Main loop:  we're going to dump revision REV.  */
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
name|svn_fs_root_t
modifier|*
name|to_root
decl_stmt|;
name|svn_boolean_t
name|use_deltas_for_rev
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Check for cancellation. */
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the revision record. */
name|SVN_ERR
argument_list|(
name|write_revision_record
argument_list|(
name|stream
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When dumping revision 0, we just write out the revision record.          The parser might want to use its properties. */
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
goto|goto
name|loop_end
goto|;
comment|/* Fetch the editor which dumps nodes to a file.  Regardless of          what we've been told, don't use deltas for the first rev of a          non-incremental dump. */
name|use_deltas_for_rev
operator|=
name|use_deltas
operator|&&
operator|(
name|incremental
operator|||
name|rev
operator|!=
name|start_rev
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dump_editor
argument_list|(
operator|&
name|dump_editor
argument_list|,
operator|&
name|dump_edit_baton
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|&
name|found_old_reference
argument_list|,
operator|&
name|found_old_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|start_rev
argument_list|,
name|use_deltas_for_rev
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Drive the editor in one way or another. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|to_root
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is the first revision of a non-incremental dump,          we're in for a full tree dump.  Otherwise, we want to simply          replay the revision.  */
if|if
condition|(
operator|(
name|rev
operator|==
name|start_rev
operator|)
operator|&&
operator|(
operator|!
name|incremental
operator|)
condition|)
block|{
comment|/* Compare against revision 0, so everything appears to be added. */
name|svn_fs_root_t
modifier|*
name|from_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|from_root
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_dir_delta2
argument_list|(
name|from_root
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|to_root
argument_list|,
literal|""
argument_list|,
name|dump_editor
argument_list|,
name|dump_edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
comment|/* don't send text-deltas */
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
comment|/* don't send entry props */
name|FALSE
argument_list|,
comment|/* don't ignore ancestry */
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The normal case: compare consecutive revs. */
name|SVN_ERR
argument_list|(
name|svn_repos_replay2
argument_list|(
name|to_root
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|FALSE
argument_list|,
name|dump_editor
argument_list|,
name|dump_edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* While our editor close_edit implementation is a no-op, we still              do this for completeness. */
name|SVN_ERR
argument_list|(
name|dump_editor
operator|->
name|close_edit
argument_list|(
name|dump_edit_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|loop_end
label|:
if|if
condition|(
name|notify_func
condition|)
block|{
name|notify
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|notify_func
condition|)
block|{
comment|/* Did we issue any warnings about references to revisions older than          the oldest dumped revision?  If so, then issue a final generic          warning, since the inline warnings already issued might easily be          missed. */
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_dump_end
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_old_reference
condition|)
block|{
name|notify_warning
argument_list|(
name|subpool
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|svn_repos_notify_warning_found_old_reference
argument_list|,
name|_
argument_list|(
literal|"The range of revisions dumped "
literal|"contained references to "
literal|"copy sources outside that "
literal|"range."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Ditto if we issued any warnings about old revisions referenced          in dumped mergeinfo. */
if|if
condition|(
name|found_old_mergeinfo
condition|)
block|{
name|notify_warning
argument_list|(
name|subpool
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|svn_repos_notify_warning_found_old_mergeinfo
argument_list|,
name|_
argument_list|(
literal|"The range of revisions dumped "
literal|"contained mergeinfo "
literal|"which reference revisions outside "
literal|"that range."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/* verify, based on dump */
end_comment

begin_comment
comment|/* Creating a new revision that changes /A/B/E/bravo means creating new    directory listings for /, /A, /A/B, and /A/B/E in the new revision, with    each entry not changed in the new revision a link back to the entry in a    previous revision.  svn_repos_replay()ing a revision does not verify that    those links are correct.     For paths actually changed in the revision we verify, we get directory    contents or file length twice: once in the dump editor, and once here.    We could create a new verify baton, store in it the changed paths, and    skip those here, but that means building an entire wrapper editor and    managing two levels of batons.  The impact from checking these entries    twice should be minimal, while the code to avoid it is not. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_directory_entry
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|baton
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
operator|(
name|svn_fs_dirent_t
operator|*
operator|)
name|val
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|svn_boolean_t
name|right_kind
decl_stmt|;
name|path
operator|=
name|svn_relpath_join
argument_list|(
name|db
operator|->
name|path
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* since we can't access the directory entries directly by their ID,      we need to navigate from the FS_ROOT to them (relatively expensive      because we may start at a never rev than the last change to node).      We check that the node kind stored in the noderev matches the dir      entry.  This also ensures that all entries point to valid noderevs.    */
switch|switch
condition|(
name|dirent
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_dir
case|:
name|SVN_ERR
argument_list|(
name|svn_fs_is_dir
argument_list|(
operator|&
name|right_kind
argument_list|,
name|db
operator|->
name|edit_baton
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|right_kind
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node '%s' is not a directory."
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
break|break;
case|case
name|svn_node_file
case|:
name|SVN_ERR
argument_list|(
name|svn_fs_is_file
argument_list|(
operator|&
name|right_kind
argument_list|,
name|db
operator|->
name|edit_baton
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|right_kind
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node '%s' is not a file."
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
break|break;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected node kind %d for '%s'"
argument_list|)
argument_list|,
name|dirent
operator|->
name|kind
argument_list|,
name|path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used by the check_name_collision hash iterator. */
end_comment

begin_struct
struct|struct
name|check_name_collision_baton
block|{
name|struct
name|dir_baton
modifier|*
name|dir_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|normalized
decl_stmt|;
name|svn_membuf_t
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Scan the directory and report all entry names that differ only in    Unicode character representation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_name_collision
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|iterpool
parameter_list|)
block|{
name|struct
name|check_name_collision_baton
modifier|*
specifier|const
name|cb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|found
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf__normalize
argument_list|(
operator|&
name|name
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
operator|&
name|cb
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|svn_hash_gets
argument_list|(
name|cb
operator|->
name|normalized
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|svn_hash_sets
argument_list|(
name|cb
operator|->
name|normalized
argument_list|,
name|apr_pstrdup
argument_list|(
name|cb
operator|->
name|buffer
operator|.
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|normalized_unique
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|found
operator|==
name|normalized_collision
condition|)
comment|/* Skip already reported collision */
empty_stmt|;
else|else
block|{
name|struct
name|dir_baton
modifier|*
specifier|const
name|db
init|=
name|cb
operator|->
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
specifier|const
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|normpath
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|cb
operator|->
name|normalized
argument_list|,
name|apr_pstrdup
argument_list|(
name|cb
operator|->
name|buffer
operator|.
name|pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|normalized_collision
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf__normalize
argument_list|(
operator|&
name|normpath
argument_list|,
name|svn_relpath_join
argument_list|(
name|db
operator|->
name|path
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|SVN_UTF__UNKNOWN_LENGTH
argument_list|,
operator|&
name|cb
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|notify_warning
argument_list|(
name|iterpool
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|svn_repos_notify_warning_name_collision
argument_list|,
name|_
argument_list|(
literal|"Duplicate representation of path '%s'"
argument_list|)
argument_list|,
name|normpath
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|dirents
argument_list|,
name|db
operator|->
name|edit_baton
operator|->
name|fs_root
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_iter_apr_hash
argument_list|(
name|NULL
argument_list|,
name|dirents
argument_list|,
name|verify_directory_entry
argument_list|,
name|dir_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|check_name_collision
condition|)
block|{
name|struct
name|check_name_collision_baton
name|check_baton
decl_stmt|;
name|check_baton
operator|.
name|dir_baton
operator|=
name|db
expr_stmt|;
name|check_baton
operator|.
name|normalized
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_membuf__create
argument_list|(
operator|&
name|check_baton
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_iter_apr_hash
argument_list|(
name|NULL
argument_list|,
name|dirents
argument_list|,
name|check_name_collision
argument_list|,
operator|&
name|check_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|close_directory
argument_list|(
name|dir_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify revision REV in file system FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_one_revision
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_boolean_t
name|check_normalization
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|dump_editor
decl_stmt|;
name|void
modifier|*
name|dump_edit_baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|to_root
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|cancel_editor
decl_stmt|;
name|void
modifier|*
name|cancel_edit_baton
decl_stmt|;
comment|/* Get cancellable dump editor, but with our close_directory handler.*/
name|SVN_ERR
argument_list|(
name|get_dump_editor
argument_list|(
operator|&
name|dump_editor
argument_list|,
operator|&
name|dump_edit_baton
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
literal|""
argument_list|,
name|svn_stream_empty
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|verify_close_directory
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|start_rev
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
comment|/* use_deltas, verify */
name|check_normalization
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta_get_cancellation_editor
argument_list|(
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|dump_editor
argument_list|,
name|dump_edit_baton
argument_list|,
operator|&
name|cancel_editor
argument_list|,
operator|&
name|cancel_edit_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|to_root
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_verify_root
argument_list|(
name|to_root
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_replay2
argument_list|(
name|to_root
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|FALSE
argument_list|,
name|cancel_editor
argument_list|,
name|cancel_edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* While our editor close_edit implementation is a no-op, we still      do this for completeness. */
name|SVN_ERR
argument_list|(
name|cancel_editor
operator|->
name|close_edit
argument_list|(
name|cancel_edit_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton type used for forwarding notifications from FS API to REPOS API. */
end_comment

begin_struct
struct|struct
name|verify_fs_notify_func_baton_t
block|{
comment|/* notification function to call (must not be NULL) */
name|svn_repos_notify_func_t
name|notify_func
decl_stmt|;
comment|/* baton to use for it */
name|void
modifier|*
name|notify_baton
decl_stmt|;
comment|/* type of notification to send (we will simply plug in the revision) */
name|svn_repos_notify_t
modifier|*
name|notify
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward the notification to BATON. */
end_comment

begin_function
specifier|static
name|void
name|verify_fs_notify_func
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|verify_fs_notify_func_baton_t
modifier|*
name|notify_baton
init|=
name|baton
decl_stmt|;
name|notify_baton
operator|->
name|notify
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|notify_baton
operator|->
name|notify_func
argument_list|(
name|notify_baton
operator|->
name|notify_baton
argument_list|,
name|notify_baton
operator|->
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|report_error
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_error_t
modifier|*
name|verify_err
parameter_list|,
name|svn_repos_verify_callback_t
name|verify_callback
parameter_list|,
name|void
modifier|*
name|verify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|verify_callback
condition|)
block|{
name|svn_error_t
modifier|*
name|cb_err
decl_stmt|;
comment|/* The caller provided us with a callback, so make him responsible          for what's going to happen with the error. */
name|cb_err
operator|=
name|verify_callback
argument_list|(
name|verify_baton
argument_list|,
name|revision
argument_list|,
name|verify_err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|verify_err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cb_err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* No callback -- no second guessing.  Just return the error. */
return|return
name|svn_error_trace
argument_list|(
name|verify_err
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_verify_fs3
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_boolean_t
name|check_normalization
parameter_list|,
name|svn_boolean_t
name|metadata_only
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_repos_verify_callback_t
name|verify_callback
parameter_list|,
name|void
modifier|*
name|verify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_repos_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_fs_progress_notify_func_t
name|verify_notify
init|=
name|NULL
decl_stmt|;
name|struct
name|verify_fs_notify_func_baton_t
modifier|*
name|verify_notify_baton
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Determine the current youngest revision of the filesystem. */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use default vals if necessary. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
condition|)
name|start_rev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
condition|)
name|end_rev
operator|=
name|youngest
expr_stmt|;
comment|/* Validate the revisions. */
if|if
condition|(
name|start_rev
operator|>
name|end_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Start revision %ld"
literal|" is greater than end revision %ld"
argument_list|)
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|)
return|;
if|if
condition|(
name|end_rev
operator|>
name|youngest
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"End revision %ld is invalid "
literal|"(youngest revision is %ld)"
argument_list|)
argument_list|,
name|end_rev
argument_list|,
name|youngest
argument_list|)
return|;
comment|/* Create a notify object that we can reuse within the loop and a      forwarding structure for notifications from inside svn_fs_verify(). */
if|if
condition|(
name|notify_func
condition|)
block|{
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_verify_rev_end
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|verify_notify
operator|=
name|verify_fs_notify_func
expr_stmt|;
name|verify_notify_baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|verify_notify_baton
argument_list|)
argument_list|)
expr_stmt|;
name|verify_notify_baton
operator|->
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|verify_notify_baton
operator|->
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|verify_notify_baton
operator|->
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_verify_rev_structure
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Verify global metadata and backend-specific data first. */
name|err
operator|=
name|svn_fs_verify
argument_list|(
name|svn_fs_path
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_fs_config
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|verify_notify
argument_list|,
name|verify_notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CANCELLED
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
name|SVN_ERR
argument_list|(
name|report_error
argument_list|(
name|SVN_INVALID_REVNUM
argument_list|,
name|err
argument_list|,
name|verify_callback
argument_list|,
name|verify_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|metadata_only
condition|)
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Wrapper function to catch the possible errors. */
name|err
operator|=
name|verify_one_revision
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|start_rev
argument_list|,
name|check_normalization
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CANCELLED
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
name|SVN_ERR
argument_list|(
name|report_error
argument_list|(
name|rev
argument_list|,
name|err
argument_list|,
name|verify_callback
argument_list|,
name|verify_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notify_func
condition|)
block|{
comment|/* Tell the caller that we're done with this revision. */
name|notify
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We're done. */
if|if
condition|(
name|notify_func
condition|)
block|{
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_verify_end
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

