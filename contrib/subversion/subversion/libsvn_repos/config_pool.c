begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * config_pool.c :  pool of configuration objects  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mutex.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_object_pool.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Our wrapper structure for parsed svn_config_t* instances.  All data in  * CS_CFG and CI_CFG is expanded (to make it thread-safe) and considered  * read-only.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|config_object_t
block|{
comment|/* UUID of the configuration contents.    * This is a SHA1 checksum of the parsed textual representation of CFG. */
name|svn_checksum_t
modifier|*
name|key
decl_stmt|;
comment|/* Parsed and expanded configuration.  At least one of the following    * must not be NULL. */
comment|/* Case-sensitive config. May be NULL */
name|svn_config_t
modifier|*
name|cs_cfg
decl_stmt|;
comment|/* Case-insensitive config. May be NULL */
name|svn_config_t
modifier|*
name|ci_cfg
decl_stmt|;
block|}
name|config_object_t
typedef|;
end_typedef

begin_comment
comment|/* Data structure used to short-circuit the repository access for configs  * read via URL.  After reading such a config successfully, we store key  * repository information here and will validate it without actually opening  * the repository.  *  * As this is only an optimization and may create many entries in  * svn_repos__config_pool_t's IN_REPO_HASH_POOL index, we clean them up  * once in a while.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|in_repo_config_t
block|{
comment|/* URL used to open the configuration */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
comment|/* Path of the repository that contained URL */
specifier|const
name|char
modifier|*
name|repo_root
decl_stmt|;
comment|/* Head revision of that repository when last read */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* Contents checksum of the file stored under URL@REVISION */
name|svn_checksum_t
modifier|*
name|key
decl_stmt|;
block|}
name|in_repo_config_t
typedef|;
end_typedef

begin_comment
comment|/* Core data structure extending the encapsulated OBJECT_POOL.  All access  * to it must be serialized using the OBJECT_POOL->MUTEX.  *  * To speed up URL@HEAD lookups, we maintain IN_REPO_CONFIGS as a secondary  * hash index.  It maps URLs as provided by the caller onto in_repo_config_t  * instances.  If that is still up-to-date, a further lookup into CONFIG  * may yield the desired configuration without the need to actually open  * the respective repository.  *  * Unused configurations that are kept in the IN_REPO_CONFIGS hash and may  * be cleaned up when the hash is about to grow.  */
end_comment

begin_struct
struct|struct
name|svn_repos__config_pool_t
block|{
name|svn_object_pool__t
modifier|*
name|object_pool
decl_stmt|;
comment|/* URL -> in_repo_config_t* mapping.    * This is only a partial index and will get cleared regularly. */
name|apr_hash_t
modifier|*
name|in_repo_configs
decl_stmt|;
comment|/* allocate the IN_REPO_CONFIGS index and in_repo_config_t here */
name|apr_pool_t
modifier|*
name|in_repo_hash_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Return an automatic reference to the CFG member in CONFIG that will be  * released when POOL gets cleaned up.  The case sensitivity flag in *BATON  * selects the desired option and section name matching mode.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|getter
parameter_list|(
name|void
modifier|*
name|object
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|config_object_t
modifier|*
name|wrapper
init|=
name|object
decl_stmt|;
name|svn_boolean_t
modifier|*
name|case_sensitive
init|=
name|baton
decl_stmt|;
name|svn_config_t
modifier|*
name|config
init|=
operator|*
name|case_sensitive
condition|?
name|wrapper
operator|->
name|cs_cfg
else|:
name|wrapper
operator|->
name|ci_cfg
decl_stmt|;
comment|/* we need to duplicate the root structure as it contains temp. buffers */
return|return
name|config
condition|?
name|svn_config__shallow_copy
argument_list|(
name|config
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a memory buffer structure allocated in POOL and containing the  * data from CHECKSUM.  */
end_comment

begin_function
specifier|static
name|svn_membuf_t
modifier|*
name|checksum_as_key
parameter_list|(
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_membuf_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|apr_size_t
name|size
init|=
name|svn_checksum_size
argument_list|(
name|checksum
argument_list|)
decl_stmt|;
name|svn_membuf__create
argument_list|(
name|result
argument_list|,
name|size
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|result
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* exact length is required! */
name|memcpy
argument_list|(
name|result
operator|->
name|data
argument_list|,
name|checksum
operator|->
name|digest
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Copy the configuration from the wrapper in SOURCE to the wrapper in  * *TARGET with the case sensitivity flag in *BATON selecting the config  * to copy.  This is usually done to add the missing case-(in)-sensitive  * variant.  Since we must hold all data in *TARGET from the same POOL,  * a deep copy is required.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setter
parameter_list|(
name|void
modifier|*
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|source
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
modifier|*
name|case_sensitive
init|=
name|baton
decl_stmt|;
name|config_object_t
modifier|*
name|target_cfg
init|=
operator|*
operator|(
name|config_object_t
operator|*
operator|*
operator|)
name|target
decl_stmt|;
name|config_object_t
modifier|*
name|source_cfg
init|=
name|source
decl_stmt|;
comment|/* Maybe, we created a variant with different case sensitivity? */
if|if
condition|(
operator|*
name|case_sensitive
operator|&&
name|target_cfg
operator|->
name|cs_cfg
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_dup
argument_list|(
operator|&
name|target_cfg
operator|->
name|cs_cfg
argument_list|,
name|source_cfg
operator|->
name|cs_cfg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config__set_read_only
argument_list|(
name|target_cfg
operator|->
name|cs_cfg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|case_sensitive
operator|&&
name|target_cfg
operator|->
name|ci_cfg
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_dup
argument_list|(
operator|&
name|target_cfg
operator|->
name|ci_cfg
argument_list|,
name|source_cfg
operator|->
name|ci_cfg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config__set_read_only
argument_list|(
name|target_cfg
operator|->
name|ci_cfg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *CFG to the configuration passed in as text in CONTENTS and *KEY to  * the corresponding object pool key.  If no such configuration exists in  * CONFIG_POOL, yet, parse CONTENTS and cache the result.  CASE_SENSITIVE  * controls option and section name matching.  *  * RESULT_POOL determines the lifetime of the returned reference and  * SCRATCH_POOL is being used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_parse
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfg
parameter_list|,
name|svn_membuf_t
modifier|*
modifier|*
name|key
parameter_list|,
name|svn_repos__config_pool_t
modifier|*
name|config_pool
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|contents
parameter_list|,
name|svn_boolean_t
name|case_sensitive
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|config_object_t
modifier|*
name|config_object
decl_stmt|;
name|apr_pool_t
modifier|*
name|cfg_pool
decl_stmt|;
comment|/* calculate SHA1 over the whole file contents */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|svn_stream_checksummed2
argument_list|(
name|svn_stream_from_stringbuf
argument_list|(
name|contents
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return reference to suitable config object if that already exists */
operator|*
name|key
operator|=
name|checksum_as_key
argument_list|(
name|checksum
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_object_pool__lookup
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cfg
argument_list|,
name|config_pool
operator|->
name|object_pool
argument_list|,
operator|*
name|key
argument_list|,
operator|&
name|case_sensitive
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cfg
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* create a pool for the new config object and parse the data into it  */
name|cfg_pool
operator|=
name|svn_object_pool__new_wrapper_pool
argument_list|(
name|config_pool
operator|->
name|object_pool
argument_list|)
expr_stmt|;
name|config_object
operator|=
name|apr_pcalloc
argument_list|(
name|cfg_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config_object
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_parse
argument_list|(
name|case_sensitive
condition|?
operator|&
name|config_object
operator|->
name|cs_cfg
else|:
operator|&
name|config_object
operator|->
name|ci_cfg
argument_list|,
name|svn_stream_from_stringbuf
argument_list|(
name|contents
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|case_sensitive
argument_list|,
name|case_sensitive
argument_list|,
name|cfg_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* switch config data to r/o mode to guarantee thread-safe access */
name|svn_config__set_read_only
argument_list|(
name|case_sensitive
condition|?
name|config_object
operator|->
name|cs_cfg
else|:
name|config_object
operator|->
name|ci_cfg
argument_list|,
name|cfg_pool
argument_list|)
expr_stmt|;
comment|/* add config in pool, handle loads races and return the right config */
name|SVN_ERR
argument_list|(
name|svn_object_pool__insert
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cfg
argument_list|,
name|config_pool
operator|->
name|object_pool
argument_list|,
operator|*
name|key
argument_list|,
name|config_object
argument_list|,
operator|&
name|case_sensitive
argument_list|,
name|cfg_pool
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store a URL@REVISION to CHECKSUM, REPOS_ROOT in CONFIG_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_checksum
parameter_list|(
name|svn_repos__config_pool_t
modifier|*
name|config_pool
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|)
block|{
name|apr_size_t
name|path_len
init|=
name|strlen
argument_list|(
name|url
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|config_pool
operator|->
name|in_repo_hash_pool
decl_stmt|;
name|in_repo_config_t
modifier|*
name|config
init|=
name|apr_hash_get
argument_list|(
name|config_pool
operator|->
name|in_repo_configs
argument_list|,
name|url
argument_list|,
name|path_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
condition|)
block|{
comment|/* update the existing entry */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|config
operator|->
name|key
operator|->
name|digest
argument_list|,
name|checksum
operator|->
name|digest
argument_list|,
name|svn_checksum_size
argument_list|(
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
comment|/* duplicate the string only if necessary */
if|if
condition|(
name|strcmp
argument_list|(
name|config
operator|->
name|repo_root
argument_list|,
name|repos_root
argument_list|)
condition|)
name|config
operator|->
name|repo_root
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|repos_root
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* insert a new entry.        * Limit memory consumption by cyclically clearing pool and hash. */
if|if
condition|(
literal|2
operator|*
name|svn_object_pool__count
argument_list|(
name|config_pool
operator|->
name|object_pool
argument_list|)
operator|<
name|apr_hash_count
argument_list|(
name|config_pool
operator|->
name|in_repo_configs
argument_list|)
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|config_pool
operator|->
name|in_repo_configs
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* construct the new entry */
name|config
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|->
name|key
operator|=
name|svn_checksum_dup
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|config
operator|->
name|url
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|url
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
name|config
operator|->
name|repo_root
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|repos_root
argument_list|)
expr_stmt|;
name|config
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
comment|/* add to index */
name|apr_hash_set
argument_list|(
name|config_pool
operator|->
name|in_repo_configs
argument_list|,
name|url
argument_list|,
name|path_len
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *CFG to the configuration stored in URL@HEAD and cache it in  * CONFIG_POOL.  CASE_SENSITIVE controls  * option and section name matching.  If PREFERRED_REPOS is given,  * use that if it also matches URL.  *  * RESULT_POOL determines the lifetime of the returned reference and  * SCRATCH_POOL is being used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_repos_config
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfg
parameter_list|,
name|svn_membuf_t
modifier|*
modifier|*
name|key
parameter_list|,
name|svn_repos__config_pool_t
modifier|*
name|config_pool
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_boolean_t
name|case_sensitive
parameter_list|,
name|svn_repos_t
modifier|*
name|preferred_repos
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_repos_t
modifier|*
name|repos
init|=
name|NULL
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirent
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_dirent
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|contents
decl_stmt|;
operator|*
name|cfg
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_uri_get_dirent_from_file_url
argument_list|(
operator|&
name|dirent
argument_list|,
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* maybe we can use the preferred repos instance instead of creating a    * new one */
if|if
condition|(
name|preferred_repos
condition|)
block|{
name|repos_root_dirent
operator|=
name|svn_repos_path
argument_list|(
name|preferred_repos
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_dirent_is_absolute
argument_list|(
name|repos_root_dirent
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|repos_root_dirent
argument_list|,
name|repos_root_dirent
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_dirent_is_ancestor
argument_list|(
name|repos_root_dirent
argument_list|,
name|dirent
argument_list|)
condition|)
name|repos
operator|=
name|preferred_repos
expr_stmt|;
block|}
comment|/* open repos if no suitable preferred repos was provided. */
if|if
condition|(
operator|!
name|repos
condition|)
block|{
comment|/* Search for a repository in the full path. */
name|repos_root_dirent
operator|=
name|svn_repos_find_root_path
argument_list|(
name|dirent
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Attempt to open a repository at repos_root_dirent. */
name|SVN_ERR
argument_list|(
name|svn_repos_open3
argument_list|(
operator|&
name|repos
argument_list|,
name|repos_root_dirent
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fs_path
operator|=
operator|&
name|dirent
index|[
name|strlen
argument_list|(
name|repos_root_dirent
argument_list|)
index|]
expr_stmt|;
comment|/* Get the filesystem. */
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
comment|/* Find HEAD and the revision root */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|youngest_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch checksum and see whether we already have a matching config */
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|root
argument_list|,
name|fs_path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
operator|*
name|key
operator|=
name|checksum_as_key
argument_list|(
name|checksum
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_object_pool__lookup
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cfg
argument_list|,
name|config_pool
operator|->
name|object_pool
argument_list|,
operator|*
name|key
argument_list|,
operator|&
name|case_sensitive
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* not parsed, yet? */
if|if
condition|(
operator|!
operator|*
name|cfg
condition|)
block|{
name|svn_filesize_t
name|length
decl_stmt|;
comment|/* fetch the file contents */
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|node_kind
argument_list|,
name|root
argument_list|,
name|fs_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|!=
name|svn_node_file
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_length
argument_list|(
operator|&
name|length
argument_list|,
name|root
argument_list|,
name|fs_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|stream
argument_list|,
name|root
argument_list|,
name|fs_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_stream
argument_list|(
operator|&
name|contents
argument_list|,
name|stream
argument_list|,
operator|(
name|apr_size_t
operator|)
name|length
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* handle it like ordinary file contents and cache it */
name|SVN_ERR
argument_list|(
name|auto_parse
argument_list|(
name|cfg
argument_list|,
name|key
argument_list|,
name|config_pool
argument_list|,
name|contents
argument_list|,
name|case_sensitive
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* store the (path,rev) -> checksum mapping as well */
if|if
condition|(
operator|*
name|cfg
operator|&&
name|checksum
condition|)
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|svn_object_pool__mutex
argument_list|(
name|config_pool
operator|->
name|object_pool
argument_list|)
argument_list|,
name|add_checksum
argument_list|(
name|config_pool
argument_list|,
name|url
argument_list|,
name|repos_root_dirent
argument_list|,
name|youngest_rev
argument_list|,
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given the URL, search the CONFIG_POOL for an entry that maps it URL to  * a content checksum and is still up-to-date.  If this could be found,  * return the object's *KEY.  Use POOL for allocations.  *  * Requires external serialization on CONFIG_POOL.  *  * Note that this is only the URL(+rev) -> Checksum lookup and does not  * guarantee that there is actually a config object available for *KEY.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|key_by_url
parameter_list|(
name|svn_membuf_t
modifier|*
modifier|*
name|key
parameter_list|,
name|svn_repos__config_pool_t
modifier|*
name|config_pool
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|contents
decl_stmt|;
name|apr_int64_t
name|current
decl_stmt|;
comment|/* hash lookup url -> sha1 -> config */
name|in_repo_config_t
modifier|*
name|config
init|=
name|svn_hash_gets
argument_list|(
name|config_pool
operator|->
name|in_repo_configs
argument_list|,
name|url
argument_list|)
decl_stmt|;
operator|*
name|key
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|config
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* found *some* reference to a configuration.    * Verify that it is still current.  Will fail for BDB repos. */
name|err
operator|=
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|contents
argument_list|,
name|svn_dirent_join
argument_list|(
name|config
operator|->
name|repo_root
argument_list|,
literal|"db/current"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_cstring_atoi64
argument_list|(
operator|&
name|current
argument_list|,
name|contents
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current
operator|==
name|config
operator|->
name|revision
condition|)
operator|*
name|key
operator|=
name|checksum_as_key
argument_list|(
name|config
operator|->
name|key
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* API implementation */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos__config_pool_create
parameter_list|(
name|svn_repos__config_pool_t
modifier|*
modifier|*
name|config_pool
parameter_list|,
name|svn_boolean_t
name|thread_safe
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos__config_pool_t
modifier|*
name|result
decl_stmt|;
name|svn_object_pool__t
modifier|*
name|object_pool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_object_pool__create
argument_list|(
operator|&
name|object_pool
argument_list|,
name|getter
argument_list|,
name|setter
argument_list|,
name|thread_safe
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* construct the config pool in our private ROOT_POOL to survive POOL    * cleanup and to prevent threading issues with the allocator */
name|result
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|object_pool
operator|=
name|object_pool
expr_stmt|;
name|result
operator|->
name|in_repo_hash_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|result
operator|->
name|in_repo_configs
operator|=
name|svn_hash__make
argument_list|(
name|result
operator|->
name|in_repo_hash_pool
argument_list|)
expr_stmt|;
operator|*
name|config_pool
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__config_pool_get
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfg
parameter_list|,
name|svn_membuf_t
modifier|*
modifier|*
name|key
parameter_list|,
name|svn_repos__config_pool_t
modifier|*
name|config_pool
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|,
name|svn_boolean_t
name|case_sensitive
parameter_list|,
name|svn_repos_t
modifier|*
name|preferred_repos
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* make sure we always have a *KEY object */
name|svn_membuf_t
modifier|*
name|local_key
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
name|key
operator|=
operator|&
name|local_key
expr_stmt|;
else|else
operator|*
name|key
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|/* Read config file from repository.        * Attempt a quick lookup first. */
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|svn_object_pool__mutex
argument_list|(
name|config_pool
operator|->
name|object_pool
argument_list|)
argument_list|,
name|key_by_url
argument_list|(
name|key
argument_list|,
name|config_pool
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|key
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_object_pool__lookup
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cfg
argument_list|,
name|config_pool
operator|->
name|object_pool
argument_list|,
operator|*
name|key
argument_list|,
operator|&
name|case_sensitive
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cfg
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Read and cache the configuration.  This may fail. */
name|err
operator|=
name|find_repos_config
argument_list|(
name|cfg
argument_list|,
name|key
argument_list|,
name|config_pool
argument_list|,
name|path
argument_list|,
name|case_sensitive
argument_list|,
name|preferred_repos
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|!
operator|*
name|cfg
condition|)
block|{
comment|/* let the standard implementation handle all the difficult cases */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_repos__retrieve_config
argument_list|(
name|cfg
argument_list|,
name|path
argument_list|,
name|must_exist
argument_list|,
name|case_sensitive
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Outside of repo file.  Read it. */
name|svn_stringbuf_t
modifier|*
name|contents
decl_stmt|;
name|err
operator|=
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|contents
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* let the standard implementation handle all the difficult cases */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_config_read3
argument_list|(
name|cfg
argument_list|,
name|path
argument_list|,
name|must_exist
argument_list|,
name|case_sensitive
argument_list|,
name|case_sensitive
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* parsing and caching will always succeed */
name|err
operator|=
name|auto_parse
argument_list|(
name|cfg
argument_list|,
name|key
argument_list|,
name|config_pool
argument_list|,
name|contents
argument_list|,
name|case_sensitive
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

