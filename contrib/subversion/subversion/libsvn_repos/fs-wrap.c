begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fs-wrap.c --- filesystem interface wrappers.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Commit wrappers ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_commit_txn
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|conflict_p
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
modifier|*
name|new_rev
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|err2
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_name
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
operator|*
name|new_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Parse the hooks-env file (if any). */
name|SVN_ERR
argument_list|(
name|svn_repos__parse_hooks_env
argument_list|(
operator|&
name|hooks_env
argument_list|,
name|repos
operator|->
name|hooks_env_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run pre-commit hooks. */
name|SVN_ERR
argument_list|(
name|svn_fs_txn_name
argument_list|(
operator|&
name|txn_name
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__hooks_pre_commit
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|txn_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove any ephemeral transaction properties. */
name|SVN_ERR
argument_list|(
name|svn_fs_txn_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|key
argument_list|,
name|SVN_PROP_TXN_PREFIX
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|SVN_PROP_TXN_PREFIX
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_change_txn_prop
argument_list|(
name|txn
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Commit. */
name|err
operator|=
name|svn_fs_commit_txn
argument_list|(
name|conflict_p
argument_list|,
name|new_rev
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|new_rev
argument_list|)
condition|)
return|return
name|err
return|;
comment|/* Run post-commit hooks. */
if|if
condition|(
operator|(
name|err2
operator|=
name|svn_repos__hooks_post_commit
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
operator|*
name|new_rev
argument_list|,
name|txn_name
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|err2
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED
argument_list|,
name|err2
argument_list|,
name|_
argument_list|(
literal|"Commit succeeded, but post-commit hook failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Transaction creation wrappers. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_begin_txn_for_commit2
parameter_list|(
name|svn_fs_txn_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|revprops
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_name
decl_stmt|;
name|svn_string_t
modifier|*
name|author
init|=
name|svn_hash_gets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
comment|/* Parse the hooks-env file (if any). */
name|SVN_ERR
argument_list|(
name|svn_repos__parse_hooks_env
argument_list|(
operator|&
name|hooks_env
argument_list|,
name|repos
operator|->
name|hooks_env_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Begin the transaction, ask for the fs to do on-the-fly lock checks.      We fetch its name, too, so the start-commit hook can use it.  */
name|SVN_ERR
argument_list|(
name|svn_fs_begin_txn2
argument_list|(
operator|&
name|txn
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|SVN_FS_TXN_CHECK_LOCKS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_txn_name
argument_list|(
operator|&
name|txn_name
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_fs_abort_txn
argument_list|(
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* We pass the revision properties to the filesystem by adding them      as properties on the txn.  Later, when we commit the txn, these      properties will be copied into the newly created revision. */
name|revprops
operator|=
name|svn_prop_hash_to_array
argument_list|(
name|revprop_table
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_repos_fs_change_txn_props
argument_list|(
name|txn
argument_list|,
name|revprops
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_fs_abort_txn
argument_list|(
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* Run start-commit hooks. */
name|err
operator|=
name|svn_repos__hooks_start_commit
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|author
condition|?
name|author
operator|->
name|data
else|:
name|NULL
argument_list|,
name|repos
operator|->
name|client_capabilities
argument_list|,
name|txn_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_fs_abort_txn
argument_list|(
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* We have API promise that *TXN_P is unaffected on faulure. */
operator|*
name|txn_p
operator|=
name|txn
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_begin_txn_for_commit
parameter_list|(
name|svn_fs_txn_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|log_msg
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|revprop_table
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|author
condition|)
name|svn_hash_sets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|svn_string_create
argument_list|(
name|author
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_msg
condition|)
name|svn_hash_sets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|svn_string_create
argument_list|(
name|log_msg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_repos_fs_begin_txn_for_commit2
argument_list|(
name|txn_p
argument_list|,
name|repos
argument_list|,
name|rev
argument_list|,
name|revprop_table
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Property wrappers ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos__validate_prop
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_prop_kind_t
name|kind
init|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* Allow deleting any property, even a property we don't allow to set. */
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Disallow setting non-regular properties. */
if|if
condition|(
name|kind
operator|!=
name|svn_prop_regular_kind
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Storage of non-regular property '%s' is disallowed through the "
literal|"repository interface, and could indicate a bug in your client"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Validate "svn:" properties. */
if|if
condition|(
name|svn_prop_is_svn_prop
argument_list|(
name|name
argument_list|)
operator|&&
name|value
operator|!=
name|NULL
condition|)
block|{
comment|/* Validate that translated props (e.g., svn:log) are UTF-8 with        * LF line endings. */
if|if
condition|(
name|svn_prop_needs_translation
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|svn_utf__is_valid
argument_list|(
name|value
operator|->
name|data
argument_list|,
name|value
operator|->
name|len
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROPERTY_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot accept '%s' property because it is not encoded in "
literal|"UTF-8"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/* Disallow inconsistent line ending style, by simply looking for            * carriage return characters ('\r'). */
if|if
condition|(
name|strchr
argument_list|(
name|value
operator|->
name|data
argument_list|,
literal|'\r'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROPERTY_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot accept non-LF line endings in '%s' property"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
block|}
comment|/* "svn:date" should be a valid date. */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_time_t
name|temp
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_time_from_cstring
argument_list|(
operator|&
name|temp
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_PROPERTY_VALUE
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify the mergeinfo property value VALUE and return an error if it  * is invalid. The PATH on which that property is set is used for error  * messages only.  Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_mergeinfo
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
comment|/* It's okay to delete svn:mergeinfo. */
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Mergeinfo is UTF-8 encoded so the number of bytes returned by strlen()    * should match VALUE->LEN. Prevents trailing garbage in the property. */
if|if
condition|(
name|strlen
argument_list|(
name|value
operator|->
name|data
argument_list|)
operator|!=
name|value
operator|->
name|len
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MERGEINFO_PARSE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Commit rejected because mergeinfo on '%s' "
literal|"contains unexpected string terminator"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
name|err
operator|=
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Commit rejected because mergeinfo on '%s' "
literal|"is syntactically invalid"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_change_node_prop
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|value
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|verify_mergeinfo
argument_list|(
name|value
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Validate the property, then call the wrapped function. */
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_change_node_prop
argument_list|(
name|root
argument_list|,
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_change_txn_props
parameter_list|(
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|txnprops
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txnprops
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|txnprops
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_fs_change_txn_props
argument_list|(
name|txn
argument_list|,
name|txnprops
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_change_txn_prop
parameter_list|(
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|props
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
decl_stmt|;
name|svn_prop_t
name|prop
decl_stmt|;
name|prop
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|prop
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
name|prop
expr_stmt|;
return|return
name|svn_repos_fs_change_txn_props
argument_list|(
name|txn
argument_list|,
name|props
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_change_rev_prop4
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|new_value
parameter_list|,
name|svn_boolean_t
name|use_pre_revprop_change_hook
parameter_list|,
name|svn_boolean_t
name|use_post_revprop_change_hook
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos_revision_access_level_t
name|readability
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_check_revision_access
argument_list|(
operator|&
name|readability
argument_list|,
name|repos
argument_list|,
name|rev
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readability
operator|==
name|svn_repos_revision_access_full
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|old_value
decl_stmt|;
name|char
name|action
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__validate_prop
argument_list|(
name|name
argument_list|,
name|new_value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch OLD_VALUE for svn_fs_change_rev_prop2(). */
if|if
condition|(
name|old_value_p
condition|)
block|{
name|old_value
operator|=
operator|*
name|old_value_p
expr_stmt|;
block|}
else|else
block|{
comment|/* Get OLD_VALUE anyway, in order for ACTION and OLD_VALUE arguments            * to the hooks to be accurate. */
name|svn_string_t
modifier|*
name|old_value2
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_prop
argument_list|(
operator|&
name|old_value2
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|old_value
operator|=
name|old_value2
expr_stmt|;
block|}
comment|/* Prepare ACTION. */
if|if
condition|(
operator|!
name|new_value
condition|)
name|action
operator|=
literal|'D'
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|old_value
condition|)
name|action
operator|=
literal|'A'
expr_stmt|;
else|else
name|action
operator|=
literal|'M'
expr_stmt|;
comment|/* Parse the hooks-env file (if any, and if to be used). */
if|if
condition|(
name|use_pre_revprop_change_hook
operator|||
name|use_post_revprop_change_hook
condition|)
name|SVN_ERR
argument_list|(
name|svn_repos__parse_hooks_env
argument_list|(
operator|&
name|hooks_env
argument_list|,
name|repos
operator|->
name|hooks_env_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### currently not passing the old_value to hooks */
if|if
condition|(
name|use_pre_revprop_change_hook
condition|)
name|SVN_ERR
argument_list|(
name|svn_repos__hooks_pre_revprop_change
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|rev
argument_list|,
name|author
argument_list|,
name|name
argument_list|,
name|new_value
argument_list|,
name|action
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_change_rev_prop2
argument_list|(
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|name
argument_list|,
operator|&
name|old_value
argument_list|,
name|new_value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_post_revprop_change_hook
condition|)
name|SVN_ERR
argument_list|(
name|svn_repos__hooks_post_revprop_change
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|rev
argument_list|,
name|author
argument_list|,
name|name
argument_list|,
name|old_value
argument_list|,
name|action
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* rev is either unreadable or only partially readable */
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_UNREADABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Write denied:  not authorized to read all of revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_revision_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos_revision_access_level_t
name|readability
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_check_revision_access
argument_list|(
operator|&
name|readability
argument_list|,
name|repos
argument_list|,
name|rev
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readability
operator|==
name|svn_repos_revision_access_none
condition|)
block|{
comment|/* Property?  What property? */
operator|*
name|value_p
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readability
operator|==
name|svn_repos_revision_access_partial
condition|)
block|{
comment|/* Only svn:author and svn:date are fetchable. */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
operator|!=
literal|0
operator|)
condition|)
operator|*
name|value_p
operator|=
name|NULL
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_revision_prop
argument_list|(
name|value_p
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|propname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* wholly readable revision */
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_revision_prop
argument_list|(
name|value_p
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|propname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_revision_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos_revision_access_level_t
name|readability
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_check_revision_access
argument_list|(
operator|&
name|readability
argument_list|,
name|repos
argument_list|,
name|rev
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readability
operator|==
name|svn_repos_revision_access_none
condition|)
block|{
comment|/* Return an empty hash. */
operator|*
name|table_p
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readability
operator|==
name|svn_repos_revision_access_partial
condition|)
block|{
name|apr_hash_t
modifier|*
name|tmphash
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
comment|/* Produce two property hashtables, both in POOL. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|tmphash
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|table_p
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* If they exist, we only copy svn:author and svn:date into the          'real' hashtable being returned. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|tmphash
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|table_p
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|tmphash
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|table_p
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* wholly readable revision */
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
name|table_p
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_lock
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|is_dav_comment
parameter_list|,
name|apr_time_t
name|expiration_date
parameter_list|,
name|svn_revnum_t
name|current_rev
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_access_t
modifier|*
name|access_ctx
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_token
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
comment|/* Parse the hooks-env file (if any). */
name|SVN_ERR
argument_list|(
name|svn_repos__parse_hooks_env
argument_list|(
operator|&
name|hooks_env
argument_list|,
name|repos
operator|->
name|hooks_env_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup an array of paths in anticipation of the ra layers handling      multiple locks in one request (1.3 most likely).  This is only      used by svn_repos__hooks_post_lock. */
name|paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_access
argument_list|(
operator|&
name|access_ctx
argument_list|,
name|repos
operator|->
name|fs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_ctx
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_access_get_username
argument_list|(
operator|&
name|username
argument_list|,
name|access_ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|username
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_USER
argument_list|,
name|NULL
argument_list|,
literal|"Cannot lock path '%s', no authenticated username available."
argument_list|,
name|path
argument_list|)
return|;
comment|/* Run pre-lock hook.  This could throw error, preventing      svn_fs_lock() from happening. */
name|SVN_ERR
argument_list|(
name|svn_repos__hooks_pre_lock
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
operator|&
name|new_token
argument_list|,
name|path
argument_list|,
name|username
argument_list|,
name|comment
argument_list|,
name|steal_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|new_token
condition|)
name|token
operator|=
name|new_token
expr_stmt|;
comment|/* Lock. */
name|SVN_ERR
argument_list|(
name|svn_fs_lock
argument_list|(
name|lock
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|token
argument_list|,
name|comment
argument_list|,
name|is_dav_comment
argument_list|,
name|expiration_date
argument_list|,
name|current_rev
argument_list|,
name|steal_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run post-lock hook. */
if|if
condition|(
operator|(
name|err
operator|=
name|svn_repos__hooks_post_lock
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|paths
argument_list|,
name|username
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_POST_LOCK_HOOK_FAILED
argument_list|,
name|err
argument_list|,
literal|"Lock succeeded, but post-lock hook failed"
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_unlock
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|svn_boolean_t
name|break_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_access_t
modifier|*
name|access_ctx
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
comment|/* Parse the hooks-env file (if any). */
name|SVN_ERR
argument_list|(
name|svn_repos__parse_hooks_env
argument_list|(
operator|&
name|hooks_env
argument_list|,
name|repos
operator|->
name|hooks_env_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup an array of paths in anticipation of the ra layers handling      multiple locks in one request (1.3 most likely).  This is only      used by svn_repos__hooks_post_lock. */
name|paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_access
argument_list|(
operator|&
name|access_ctx
argument_list|,
name|repos
operator|->
name|fs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_ctx
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_access_get_username
argument_list|(
operator|&
name|username
argument_list|,
name|access_ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|break_lock
operator|&&
operator|!
name|username
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_USER
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot unlock path '%s', no authenticated username available"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
comment|/* Run pre-unlock hook.  This could throw error, preventing      svn_fs_unlock() from happening. */
name|SVN_ERR
argument_list|(
name|svn_repos__hooks_pre_unlock
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|path
argument_list|,
name|username
argument_list|,
name|token
argument_list|,
name|break_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unlock. */
name|SVN_ERR
argument_list|(
name|svn_fs_unlock
argument_list|(
name|repos
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|token
argument_list|,
name|break_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run post-unlock hook. */
if|if
condition|(
operator|(
name|err
operator|=
name|svn_repos__hooks_post_unlock
argument_list|(
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|paths
argument_list|,
name|username
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_POST_UNLOCK_HOOK_FAILED
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Unlock succeeded, but post-unlock hook failed"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|get_locks_baton_t
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|head_root
decl_stmt|;
name|svn_repos_authz_func_t
name|authz_read_func
decl_stmt|;
name|void
modifier|*
name|authz_read_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|locks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This implements the svn_fs_get_locks_callback_t interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_locks_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|get_locks_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_boolean_t
name|readable
init|=
name|TRUE
decl_stmt|;
name|apr_pool_t
modifier|*
name|hash_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|b
operator|->
name|locks
argument_list|)
decl_stmt|;
comment|/* If there's auth to deal with, deal with it. */
if|if
condition|(
name|b
operator|->
name|authz_read_func
condition|)
name|SVN_ERR
argument_list|(
name|b
operator|->
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|b
operator|->
name|head_root
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|b
operator|->
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we can read this lock path, add the lock to the return hash. */
if|if
condition|(
name|readable
condition|)
name|svn_hash_sets
argument_list|(
name|b
operator|->
name|locks
argument_list|,
name|apr_pstrdup
argument_list|(
name|hash_pool
argument_list|,
name|lock
operator|->
name|path
argument_list|)
argument_list|,
name|svn_lock_dup
argument_list|(
name|lock
argument_list|,
name|hash_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_get_locks2
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|locks
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|all_locks
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|head_rev
decl_stmt|;
name|struct
name|get_locks_baton_t
name|baton
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|depth
operator|==
name|svn_depth_empty
operator|)
operator|||
operator|(
name|depth
operator|==
name|svn_depth_files
operator|)
operator|||
operator|(
name|depth
operator|==
name|svn_depth_immediates
operator|)
operator|||
operator|(
name|depth
operator|==
name|svn_depth_infinity
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|head_rev
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Populate our callback baton. */
name|baton
operator|.
name|fs
operator|=
name|repos
operator|->
name|fs
expr_stmt|;
name|baton
operator|.
name|locks
operator|=
name|all_locks
expr_stmt|;
name|baton
operator|.
name|authz_read_func
operator|=
name|authz_read_func
expr_stmt|;
name|baton
operator|.
name|authz_read_baton
operator|=
name|authz_read_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
operator|(
name|baton
operator|.
name|head_root
operator|)
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|head_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get all the locks. */
name|SVN_ERR
argument_list|(
name|svn_fs_get_locks2
argument_list|(
name|repos
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|depth
argument_list|,
name|get_locks_callback
argument_list|,
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|locks
operator|=
name|baton
operator|.
name|locks
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_get_mergeinfo
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Here we cast away 'const', but won't try to write through this pointer    * without first allocating a new array. */
name|apr_array_header_t
modifier|*
name|readable_paths
init|=
operator|(
name|apr_array_header_t
operator|*
operator|)
name|paths
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|repos
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Filter out unreadable paths before divining merge tracking info. */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readable
operator|&&
name|readable_paths
operator|!=
name|paths
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|readable_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|readable
operator|&&
name|readable_paths
operator|==
name|paths
condition|)
block|{
comment|/* Requested paths differ from readable paths.  Fork                  list of readable paths from requested paths. */
name|int
name|j
decl_stmt|;
name|readable_paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|paths
operator|->
name|nelts
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|j
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|readable_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* We consciously do not perform authz checks on the paths returned      in *MERGEINFO, avoiding massive authz overhead which would allow      us to protect the name of where a change was merged from, but not      the change itself. */
comment|/* ### TODO(reint): ... but how about descendant merged-to paths? */
if|if
condition|(
name|readable_paths
operator|->
name|nelts
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_get_mergeinfo2
argument_list|(
name|mergeinfo
argument_list|,
name|root
argument_list|,
name|readable_paths
argument_list|,
name|inherit
argument_list|,
name|include_descendants
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|pack_notify_baton
block|{
name|svn_repos_notify_func_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_fs_pack_notify_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_notify_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|svn_fs_pack_notify_action_t
name|pack_action
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|pack_notify_baton
modifier|*
name|pnb
init|=
name|baton
decl_stmt|;
name|svn_repos_notify_t
modifier|*
name|notify
decl_stmt|;
comment|/* Simple conversion works for these values. */
name|SVN_ERR_ASSERT
argument_list|(
name|pack_action
operator|>=
name|svn_fs_pack_notify_start
operator|&&
name|pack_action
operator|<=
name|svn_fs_pack_notify_end_revprop
argument_list|)
expr_stmt|;
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|pack_action
operator|+
name|svn_repos_notify_pack_shard_start
operator|-
name|svn_fs_pack_notify_start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|shard
operator|=
name|shard
expr_stmt|;
name|pnb
operator|->
name|notify_func
argument_list|(
name|pnb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_pack2
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|pack_notify_baton
name|pnb
decl_stmt|;
name|pnb
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|pnb
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
return|return
name|svn_fs_pack
argument_list|(
name|repos
operator|->
name|db_path
argument_list|,
name|notify_func
condition|?
name|pack_notify_func
else|:
name|NULL
argument_list|,
name|notify_func
condition|?
operator|&
name|pnb
else|:
name|NULL
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_fs_get_inherited_props
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|inherited_props_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_path
init|=
name|path
decl_stmt|;
name|inherited_props
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_inherited_item_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|parent_path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|parent_path
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|svn_boolean_t
name|allowed
init|=
name|TRUE
decl_stmt|;
name|apr_hash_t
modifier|*
name|parent_properties
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|parent_path
operator|=
name|svn_fspath__dirname
argument_list|(
name|parent_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|allowed
argument_list|,
name|root
argument_list|,
name|parent_path
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowed
condition|)
block|{
if|if
condition|(
name|propname
condition|)
block|{
name|svn_string_t
modifier|*
name|propval
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_prop
argument_list|(
operator|&
name|propval
argument_list|,
name|root
argument_list|,
name|parent_path
argument_list|,
name|propname
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|propval
condition|)
block|{
name|parent_properties
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|parent_properties
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|parent_properties
argument_list|,
name|root
argument_list|,
name|parent_path
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent_properties
operator|&&
name|apr_hash_count
argument_list|(
name|parent_properties
argument_list|)
condition|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|i_props
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_props
argument_list|)
argument_list|)
decl_stmt|;
name|i_props
operator|->
name|path_or_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|parent_path
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i_props
operator|->
name|prop_hash
operator|=
name|parent_properties
expr_stmt|;
comment|/* Build the output array in depth-first order. */
name|svn_sort__array_insert
argument_list|(
operator|&
name|i_props
argument_list|,
name|inherited_props
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|inherited_props_p
operator|=
name|inherited_props
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * vim:ts=4:sw=2:expandtab:tw=80:fo=tcroq  * vim:isk=a-z,A-Z,48-57,_,.,-,>  * vim:cino=>1s,e0,n0,f0,{.5s,}0,^-.5s,=.5s,t0,+1s,c3,(0,u0,\:0  */
end_comment

end_unit

