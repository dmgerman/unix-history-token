begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* load-fs-vtable.c --- dumpstream loader vtable for committing into a  *                      Subversion filesystem.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** Batons used herein **/
end_comment

begin_struct
struct|struct
name|parse_baton
block|{
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_boolean_t
name|use_history
decl_stmt|;
name|svn_boolean_t
name|validate_props
decl_stmt|;
name|svn_boolean_t
name|use_pre_commit_hook
decl_stmt|;
name|svn_boolean_t
name|use_post_commit_hook
decl_stmt|;
name|enum
name|svn_repos_load_uuid
name|uuid_action
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_dir
decl_stmt|;
comment|/* repository relpath, or NULL */
name|svn_repos_notify_func_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|notify_pool
decl_stmt|;
comment|/* scratch pool for notifications */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Start and end (inclusive) of revision range we'll pay attention      to, or a pair of SVN_INVALID_REVNUMs if we're not filtering by      revisions. */
name|svn_revnum_t
name|start_rev
decl_stmt|;
name|svn_revnum_t
name|end_rev
decl_stmt|;
comment|/* A hash mapping copy-from revisions and mergeinfo range revisions      (svn_revnum_t *) in the dump stream to their corresponding revisions      (svn_revnum_t *) in the loaded repository.  The hash and its      contents are allocated in POOL. */
comment|/* ### See http://subversion.tigris.org/issues/show_bug.cgi?id=3903      ### for discussion about improving the memory costs of this mapping. */
name|apr_hash_t
modifier|*
name|rev_map
decl_stmt|;
comment|/* The most recent (youngest) revision from the dump stream mapped in      REV_MAP.  If no revisions have been mapped yet, this is set to      SVN_INVALID_REVNUM. */
name|svn_revnum_t
name|last_rev_mapped
decl_stmt|;
comment|/* The oldest old revision loaded from the dump stream.  If no revisions      have been loaded yet, this is set to SVN_INVALID_REVNUM. */
name|svn_revnum_t
name|oldest_old_rev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|revision_baton
block|{
name|svn_revnum_t
name|rev
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|txn_root
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|datestamp
decl_stmt|;
name|apr_int32_t
name|rev_offset
decl_stmt|;
name|svn_boolean_t
name|skipped
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|node_baton
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|enum
name|svn_node_action
name|action
decl_stmt|;
name|svn_checksum_t
modifier|*
name|base_checksum
decl_stmt|;
comment|/* null, if not available */
name|svn_checksum_t
modifier|*
name|result_checksum
decl_stmt|;
comment|/* null, if not available */
name|svn_checksum_t
modifier|*
name|copy_source_checksum
decl_stmt|;
comment|/* null, if not available */
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Record the mapping of FROM_REV to TO_REV in REV_MAP, ensuring that    anything added to the hash is allocated in the hash's pool. */
end_comment

begin_function
specifier|static
name|void
name|set_revision_mapping
parameter_list|(
name|apr_hash_t
modifier|*
name|rev_map
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|,
name|svn_revnum_t
name|to_rev
parameter_list|)
block|{
name|svn_revnum_t
modifier|*
name|mapped_revs
init|=
name|apr_palloc
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|rev_map
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
operator|*
literal|2
argument_list|)
decl_stmt|;
name|mapped_revs
index|[
literal|0
index|]
operator|=
name|from_rev
expr_stmt|;
name|mapped_revs
index|[
literal|1
index|]
operator|=
name|to_rev
expr_stmt|;
name|apr_hash_set
argument_list|(
name|rev_map
argument_list|,
name|mapped_revs
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|,
name|mapped_revs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the revision to which FROM_REV maps in REV_MAP, or    SVN_INVALID_REVNUM if no such mapping exists. */
end_comment

begin_function
specifier|static
name|svn_revnum_t
name|get_revision_mapping
parameter_list|(
name|apr_hash_t
modifier|*
name|rev_map
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|)
block|{
name|svn_revnum_t
modifier|*
name|to_rev
init|=
name|apr_hash_get
argument_list|(
name|rev_map
argument_list|,
operator|&
name|from_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|from_rev
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|to_rev
condition|?
operator|*
name|to_rev
else|:
name|SVN_INVALID_REVNUM
return|;
block|}
end_function

begin_comment
comment|/* Change revision property NAME to VALUE for REVISION in REPOS.  If    VALIDATE_PROPS is set, use functions which perform validation of    the property value.  Otherwise, bypass those checks. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_rev_prop
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|svn_boolean_t
name|validate_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|validate_props
condition|)
return|return
name|svn_repos_fs_change_rev_prop4
argument_list|(
name|repos
argument_list|,
name|revision
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|value
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|svn_fs_change_rev_prop2
argument_list|(
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
argument_list|,
name|revision
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Change property NAME to VALUE for PATH in TXN_ROOT.  If    VALIDATE_PROPS is set, use functions which perform validation of    the property value.  Otherwise, bypass those checks. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_node_prop
parameter_list|(
name|svn_fs_root_t
modifier|*
name|txn_root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|svn_boolean_t
name|validate_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|validate_props
condition|)
return|return
name|svn_repos_fs_change_node_prop
argument_list|(
name|txn_root
argument_list|,
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|svn_fs_change_node_prop
argument_list|(
name|txn_root
argument_list|,
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Prepend the mergeinfo source paths in MERGEINFO_ORIG with PARENT_DIR, and    return it in *MERGEINFO_VAL. */
end_comment

begin_comment
comment|/* ### FIXME:  Consider somehow sharing code with    ### svnrdump/load_editor.c:prefix_mergeinfo_paths() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prefix_mergeinfo_paths
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|mergeinfo_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|mergeinfo_orig
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|prefixed_mergeinfo
decl_stmt|,
modifier|*
name|mergeinfo
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|void
modifier|*
name|rangelist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo_orig
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|prefixed_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|merge_source
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|rangelist
argument_list|)
expr_stmt|;
name|merge_source
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|key
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* The svn:mergeinfo property syntax demands a repos abspath */
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|svn_relpath_join
argument_list|(
name|parent_dir
argument_list|,
name|merge_source
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|prefixed_mergeinfo
argument_list|,
name|path
argument_list|,
name|rangelist
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_mergeinfo_to_string
argument_list|(
name|mergeinfo_val
argument_list|,
name|prefixed_mergeinfo
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Examine the mergeinfo in INITIAL_VAL, renumber revisions in rangelists    as appropriate, and return the (possibly new) mergeinfo in *FINAL_VAL    (allocated from POOL). */
end_comment

begin_comment
comment|/* ### FIXME:  Consider somehow sharing code with    ### svnrdump/load_editor.c:renumber_mergeinfo_revs() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|renumber_mergeinfo_revs
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|final_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|initial_val
parameter_list|,
name|struct
name|revision_baton
modifier|*
name|rb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|,
name|predates_stream_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|final_mergeinfo
init|=
name|apr_hash_make
argument_list|(
name|subpool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|initial_val
operator|->
name|data
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Issue #3020      http://subversion.tigris.org/issues/show_bug.cgi?id=3020#desc16      Remove mergeinfo older than the oldest revision in the dump stream      and adjust its revisions by the difference between the head rev of      the target repository and the current dump stream rev. */
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|oldest_old_rev
operator|>
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|predates_stream_mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|rb
operator|->
name|pb
operator|->
name|oldest_old_rev
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|rb
operator|->
name|pb
operator|->
name|oldest_old_rev
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__adjust_mergeinfo_rangelists
argument_list|(
operator|&
name|predates_stream_mergeinfo
argument_list|,
name|predates_stream_mergeinfo
argument_list|,
operator|-
name|rb
operator|->
name|rev_offset
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|predates_stream_mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|merge_source
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|merge_source
operator|=
name|key
expr_stmt|;
name|rangelist
operator|=
name|val
expr_stmt|;
comment|/* Possibly renumber revisions in merge source's rangelist. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_revnum_t
name|rev_from_map
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|rev_from_map
operator|=
name|get_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|range
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev_from_map
argument_list|)
condition|)
block|{
name|range
operator|->
name|start
operator|=
name|rev_from_map
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|range
operator|->
name|start
operator|==
name|pb
operator|->
name|oldest_old_rev
operator|-
literal|1
condition|)
block|{
comment|/* Since the start revision of svn_merge_range_t are not                  inclusive there is one possible valid start revision that                  won't be found in the PB->REV_MAP mapping of load stream                  revsions to loaded revisions: The revision immediately                  preceeding the oldest revision from the load stream.                  This is a valid revision for mergeinfo, but not a valid                  copy from revision (which PB->REV_MAP also maps for) so it                  will never be in the mapping.                   If that is what we have here, then find the mapping for the                  oldest rev from the load stream and subtract 1 to get the                  renumbered, non-inclusive, start revision. */
name|rev_from_map
operator|=
name|get_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|pb
operator|->
name|oldest_old_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev_from_map
argument_list|)
condition|)
name|range
operator|->
name|start
operator|=
name|rev_from_map
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If we can't remap the start revision then don't even bother                  trying to remap the end revision.  It's possible we might                  actually succeed at the latter, which can result in invalid                  mergeinfo with a start rev> end rev.  If that gets into the                  repository then a world of bustage breaks loose anytime that                  bogus mergeinfo is parsed.  See                  http://subversion.tigris.org/issues/show_bug.cgi?id=3020#desc16.                  */
continue|continue;
block|}
name|rev_from_map
operator|=
name|get_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|range
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev_from_map
argument_list|)
condition|)
name|range
operator|->
name|end
operator|=
name|rev_from_map
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|final_mergeinfo
argument_list|,
name|merge_source
argument_list|,
name|rangelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|predates_stream_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|final_mergeinfo
argument_list|,
name|predates_stream_mergeinfo
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__canonicalize_ranges
argument_list|(
name|final_mergeinfo
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
name|final_val
argument_list|,
name|final_mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** vtable for doing commits to a fs **/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_node_baton
parameter_list|(
name|struct
name|node_baton
modifier|*
modifier|*
name|node_baton_p
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|struct
name|revision_baton
modifier|*
name|rb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nb
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
comment|/* Start with sensible defaults. */
name|nb
operator|->
name|rb
operator|=
name|rb
expr_stmt|;
name|nb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|nb
operator|->
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
comment|/* Then add info from the headers.  */
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
argument_list|)
operator|)
condition|)
block|{
name|val
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|val
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|parent_dir
condition|)
name|nb
operator|->
name|path
operator|=
name|svn_relpath_join
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|parent_dir
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|nb
operator|->
name|path
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"file"
argument_list|)
condition|)
name|nb
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"dir"
argument_list|)
condition|)
name|nb
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
name|nb
operator|->
name|action
operator|=
operator|(
expr|enum
name|svn_node_action
operator|)
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* an invalid action code */
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"change"
argument_list|)
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_change
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"add"
argument_list|)
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_add
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"delete"
argument_list|)
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_delete
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"replace"
argument_list|)
condition|)
name|nb
operator|->
name|action
operator|=
name|svn_node_action_replace
expr_stmt|;
block|}
name|nb
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
argument_list|)
operator|)
condition|)
block|{
name|nb
operator|->
name|copyfrom_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH
argument_list|)
operator|)
condition|)
block|{
name|val
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|val
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|parent_dir
condition|)
name|nb
operator|->
name|copyfrom_path
operator|=
name|svn_relpath_join
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|parent_dir
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|nb
operator|->
name|copyfrom_path
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_CHECKSUM
argument_list|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|nb
operator|->
name|result_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_CHECKSUM
argument_list|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|nb
operator|->
name|base_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_CHECKSUM
argument_list|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|nb
operator|->
name|copy_source_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* What's cool about this dump format is that the parser just      ignores any unrecognized headers.  :-)  */
operator|*
name|node_baton_p
operator|=
name|nb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|revision_baton
modifier|*
name|make_revision_baton
parameter_list|(
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|struct
name|parse_baton
modifier|*
name|pb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rb
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|rb
operator|->
name|pb
operator|=
name|pb
expr_stmt|;
name|rb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|rb
operator|->
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
argument_list|)
operator|)
condition|)
block|{
name|rb
operator|->
name|rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* If we're filtering revisions, is this one we'll skip? */
name|rb
operator|->
name|skipped
operator|=
operator|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|pb
operator|->
name|start_rev
argument_list|)
operator|&&
operator|(
operator|(
name|rb
operator|->
name|rev
operator|<
name|pb
operator|->
name|start_rev
operator|)
operator|||
operator|(
name|rb
operator|->
name|rev
operator|>
name|pb
operator|->
name|end_rev
operator|)
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|rb
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|new_revision_record
parameter_list|(
name|void
modifier|*
modifier|*
name|revision_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|parse_baton
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
decl_stmt|;
name|svn_revnum_t
name|head_rev
decl_stmt|;
name|rb
operator|=
name|make_revision_baton
argument_list|(
name|headers
argument_list|,
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* ### If we're filtering revisions, and this is one we've skipped,      ### and we've skipped it because it has a revision number younger      ### than the youngest in our acceptable range, then should we      ### just bail out here? */
comment|/*   if (rb->skipped&& (rb->rev> pb->end_rev))     return svn_error_createf(SVN_ERR_CEASE_INVOCATION, 0,                              _("Finished processing acceptable load "                                "revision range"));   */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|head_rev
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: This is a lame fallback loading multiple segments of dump in      several separate operations. It is highly susceptible to race conditions.      Calculate the revision 'offset' for finding copyfrom sources.      It might be positive or negative. */
name|rb
operator|->
name|rev_offset
operator|=
call|(
name|apr_int32_t
call|)
argument_list|(
operator|(
name|rb
operator|->
name|rev
operator|)
operator|-
operator|(
name|head_rev
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rb
operator|->
name|rev
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|!
name|rb
operator|->
name|skipped
operator|)
condition|)
block|{
comment|/* Create a new fs txn. */
name|SVN_ERR
argument_list|(
name|svn_fs_begin_txn2
argument_list|(
operator|&
operator|(
name|rb
operator|->
name|txn
operator|)
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|head_rev
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_txn_root
argument_list|(
operator|&
operator|(
name|rb
operator|->
name|txn_root
operator|)
argument_list|,
name|rb
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|notify_func
condition|)
block|{
comment|/* ### TODO: Use proper scratch pool instead of pb->notify_pool */
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_load_txn_start
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|old_revision
operator|=
name|rb
operator|->
name|rev
expr_stmt|;
name|pb
operator|->
name|notify_func
argument_list|(
name|pb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Stash the oldest "old" revision committed from the load stream. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|pb
operator|->
name|oldest_old_rev
argument_list|)
condition|)
name|pb
operator|->
name|oldest_old_rev
operator|=
name|rb
operator|->
name|rev
expr_stmt|;
block|}
comment|/* If we're skipping this revision, try to notify someone. */
if|if
condition|(
name|rb
operator|->
name|skipped
operator|&&
name|pb
operator|->
name|notify_func
condition|)
block|{
comment|/* ### TODO: Use proper scratch pool instead of pb->notify_pool */
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_load_skipped_rev
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|old_revision
operator|=
name|rb
operator|->
name|rev
expr_stmt|;
name|pb
operator|->
name|notify_func
argument_list|(
name|pb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
block|}
comment|/* If we're parsing revision 0, only the revision are (possibly)      interesting to us: when loading the stream into an empty      filesystem, then we want new filesystem's revision 0 to have the      same props.  Otherwise, we just ignore revision 0 in the stream. */
operator|*
name|revision_baton
operator|=
name|rb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Factorized helper func for new_node_record() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_add_with_history
parameter_list|(
name|struct
name|node_baton
modifier|*
name|nb
parameter_list|,
name|struct
name|revision_baton
modifier|*
name|rb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
if|if
condition|(
operator|(
name|nb
operator|->
name|copyfrom_path
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|pb
operator|->
name|use_history
operator|)
condition|)
block|{
comment|/* Add empty file or dir, without history. */
if|if
condition|(
name|nb
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_make_file
argument_list|(
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nb
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_make_dir
argument_list|(
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Hunt down the source revision in this fs. */
name|svn_fs_root_t
modifier|*
name|copy_root
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* Try to find the copyfrom revision in the revision map;          failing that, fall back to the revision offset approach. */
name|copyfrom_rev
operator|=
name|get_revision_mapping
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|rev_map
argument_list|,
name|nb
operator|->
name|copyfrom_rev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
condition|)
name|copyfrom_rev
operator|=
name|nb
operator|->
name|copyfrom_rev
operator|-
name|rb
operator|->
name|rev_offset
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Relative source revision %ld is not"
literal|" available in current repository"
argument_list|)
argument_list|,
name|copyfrom_rev
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|copy_root
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|copyfrom_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|->
name|copy_source_checksum
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|copy_root
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|nb
operator|->
name|copy_source_checksum
argument_list|,
name|checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|nb
operator|->
name|copy_source_checksum
argument_list|,
name|checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Copy source checksum mismatch on copy from '%s'@%ld\n"
literal|"to '%s' in rev based on r%ld"
argument_list|)
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|rb
operator|->
name|rev
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_copy
argument_list|(
name|copy_root
argument_list|,
name|nb
operator|->
name|copyfrom_path
argument_list|,
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|notify_func
condition|)
block|{
comment|/* ### TODO: Use proper scratch pool instead of pb->notify_pool */
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_load_copied_node
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
decl_stmt|;
name|pb
operator|->
name|notify_func
argument_list|(
name|pb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|magic_header_record
parameter_list|(
name|int
name|version
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|uuid_record
parameter_list|(
specifier|const
name|char
modifier|*
name|uuid
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|parse_baton
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|uuid_action
operator|==
name|svn_repos_load_uuid_ignore
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|pb
operator|->
name|uuid_action
operator|!=
name|svn_repos_load_uuid_force
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|youngest_rev
operator|!=
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_fs_set_uuid
argument_list|(
name|pb
operator|->
name|fs
argument_list|,
name|uuid
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|new_node_record
parameter_list|(
name|void
modifier|*
modifier|*
name|node_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|revision_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|revision_baton
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
name|struct
name|node_baton
modifier|*
name|nb
decl_stmt|;
if|if
condition|(
name|rb
operator|->
name|rev
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed dumpstream: "
literal|"Revision 0 must not contain node records"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|make_node_baton
argument_list|(
operator|&
name|nb
argument_list|,
name|headers
argument_list|,
name|rb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're skipping this revision, we're done here. */
if|if
condition|(
name|rb
operator|->
name|skipped
condition|)
block|{
operator|*
name|node_baton
operator|=
name|nb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Make sure we have an action we recognize. */
if|if
condition|(
name|nb
operator|->
name|action
operator|<
name|svn_node_action_change
operator|||
name|nb
operator|->
name|action
operator|>
name|svn_node_action_replace
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_STREAM_UNRECOGNIZED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unrecognized node-action on node '%s'"
argument_list|)
argument_list|,
name|nb
operator|->
name|path
argument_list|)
return|;
if|if
condition|(
name|pb
operator|->
name|notify_func
condition|)
block|{
comment|/* ### TODO: Use proper scratch pool instead of pb->notify_pool */
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_load_node_start
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|path
operator|=
name|nb
operator|->
name|path
expr_stmt|;
name|pb
operator|->
name|notify_func
argument_list|(
name|pb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|nb
operator|->
name|action
condition|)
block|{
case|case
name|svn_node_action_change
case|:
break|break;
case|case
name|svn_node_action_delete
case|:
name|SVN_ERR
argument_list|(
name|svn_fs_delete
argument_list|(
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_action_add
case|:
name|SVN_ERR
argument_list|(
name|maybe_add_with_history
argument_list|(
name|nb
argument_list|,
name|rb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_action_replace
case|:
name|SVN_ERR
argument_list|(
name|svn_fs_delete
argument_list|(
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|maybe_add_with_history
argument_list|(
name|nb
argument_list|,
name|rb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|node_baton
operator|=
name|nb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_revision_property
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
comment|/* If we're skipping this revision, we're done here. */
if|if
condition|(
name|rb
operator|->
name|skipped
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|rb
operator|->
name|rev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|validate_props
condition|)
name|SVN_ERR
argument_list|(
name|svn_repos_fs_change_txn_prop
argument_list|(
name|rb
operator|->
name|txn
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_change_txn_prop
argument_list|(
name|rb
operator|->
name|txn
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember any datestamp that passes through!  (See comment in          close_revision() below.) */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
condition|)
name|rb
operator|->
name|datestamp
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rb
operator|->
name|rev
operator|==
literal|0
condition|)
block|{
comment|/* Special case: set revision 0 properties when loading into an          'empty' filesystem. */
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|youngest_rev
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|change_rev_prop
argument_list|(
name|pb
operator|->
name|repos
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pb
operator|->
name|validate_props
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Adjust mergeinfo:  *   - normalize line endings (if all CRLF, change to LF; but error if mixed);  *   - adjust revision numbers (see renumber_mergeinfo_revs());  *   - adjust paths (see prefix_mergeinfo_paths()).  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|adjust_mergeinfo_property
parameter_list|(
name|struct
name|revision_baton
modifier|*
name|rb
parameter_list|,
name|svn_string_t
modifier|*
modifier|*
name|new_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|old_value
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
name|svn_string_t
name|prop_val
init|=
operator|*
name|old_value
decl_stmt|;
comment|/* Tolerate mergeinfo with "\r\n" line endings because some      dumpstream sources might contain as much.  If so normalize      the line endings to '\n' and make a notification to      PARSE_BATON->FEEDBACK_STREAM that we have made this      correction. */
if|if
condition|(
name|strstr
argument_list|(
name|prop_val
operator|.
name|data
argument_list|,
literal|"\r"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|prop_eol_normalized
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|prop_val
operator|.
name|data
argument_list|,
operator|&
name|prop_eol_normalized
argument_list|,
literal|"\n"
argument_list|,
comment|/* translate to LF */
name|FALSE
argument_list|,
comment|/* no repair */
name|NULL
argument_list|,
comment|/* no keywords */
name|FALSE
argument_list|,
comment|/* no expansion */
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|prop_val
operator|.
name|data
operator|=
name|prop_eol_normalized
expr_stmt|;
name|prop_val
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|prop_eol_normalized
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|notify_func
condition|)
block|{
comment|/* ### TODO: Use proper scratch pool instead of pb->notify_pool */
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_load_normalized_mergeinfo
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
decl_stmt|;
name|pb
operator|->
name|notify_func
argument_list|(
name|pb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Renumber mergeinfo as appropriate. */
name|SVN_ERR
argument_list|(
name|renumber_mergeinfo_revs
argument_list|(
name|new_value_p
argument_list|,
operator|&
name|prop_val
argument_list|,
name|rb
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|parent_dir
condition|)
block|{
comment|/* Prefix the merge source paths with PB->parent_dir. */
comment|/* ASSUMPTION: All source paths are included in the dump stream. */
name|SVN_ERR
argument_list|(
name|prefix_mergeinfo_paths
argument_list|(
name|new_value_p
argument_list|,
operator|*
name|new_value_p
argument_list|,
name|pb
operator|->
name|parent_dir
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_node_property
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
comment|/* If we're skipping this revision, we're done here. */
if|if
condition|(
name|rb
operator|->
name|skipped
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Adjust mergeinfo. If this fails, presumably because the mergeinfo      property has an ill-formed value, then we must not fail to load      the repository (at least if it's a simple load with no revision      offset adjustments, path changes, etc.) so just warn and leave it      as it is. */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_string_t
modifier|*
name|new_value
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|adjust_mergeinfo_property
argument_list|(
name|rb
argument_list|,
operator|&
name|new_value
argument_list|,
name|value
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|pb
operator|->
name|validate_props
condition|)
block|{
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Invalid svn:mergeinfo value"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|pb
operator|->
name|notify_func
condition|)
block|{
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_warning
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|warning
operator|=
name|svn_repos__notify_warning_invalid_mergeinfo
expr_stmt|;
name|notify
operator|->
name|warning_str
operator|=
name|_
argument_list|(
literal|"Invalid svn:mergeinfo value; "
literal|"leaving unchanged"
argument_list|)
expr_stmt|;
name|pb
operator|->
name|notify_func
argument_list|(
name|pb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|new_value
expr_stmt|;
block|}
block|}
return|return
name|change_node_prop
argument_list|(
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pb
operator|->
name|validate_props
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_node_property
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
comment|/* If we're skipping this revision, we're done here. */
if|if
condition|(
name|rb
operator|->
name|skipped
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|change_node_prop
argument_list|(
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|pb
operator|->
name|validate_props
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_node_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* If we're skipping this revision, we're done here. */
if|if
condition|(
name|rb
operator|->
name|skipped
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|nb
operator|->
name|pool
argument_list|,
name|proplist
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|change_node_prop
argument_list|(
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|pb
operator|->
name|validate_props
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|,
name|void
modifier|*
name|node_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
comment|/* If we're skipping this revision, we're done here. */
if|if
condition|(
name|rb
operator|->
name|skipped
condition|)
block|{
operator|*
name|handler
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_fs_apply_textdelta
argument_list|(
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|nb
operator|->
name|base_checksum
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|nb
operator|->
name|result_checksum
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_fulltext
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|node_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
comment|/* If we're skipping this revision, we're done here. */
if|if
condition|(
name|rb
operator|->
name|skipped
condition|)
block|{
operator|*
name|stream
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_fs_apply_text
argument_list|(
name|stream
argument_list|,
name|rb
operator|->
name|txn_root
argument_list|,
name|nb
operator|->
name|path
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|nb
operator|->
name|result_checksum
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
argument_list|,
name|nb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_node
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|nb
init|=
name|baton
decl_stmt|;
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
comment|/* If we're skipping this revision, we're done here. */
if|if
condition|(
name|rb
operator|->
name|skipped
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|pb
operator|->
name|notify_func
condition|)
block|{
comment|/* ### TODO: Use proper scratch pool instead of pb->notify_pool */
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_load_node_done
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
decl_stmt|;
name|pb
operator|->
name|notify_func
argument_list|(
name|pb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_revision
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|revision_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_msg
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|committed_rev
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_name
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|hooks_env
decl_stmt|;
comment|/* If we're skipping this revision or it has an invalid revision      number, we're done here. */
if|if
condition|(
name|rb
operator|->
name|skipped
operator|||
operator|(
name|rb
operator|->
name|rev
operator|<=
literal|0
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Get the txn name and hooks environment if they will be needed. */
if|if
condition|(
name|pb
operator|->
name|use_pre_commit_hook
operator|||
name|pb
operator|->
name|use_post_commit_hook
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_repos__parse_hooks_env
argument_list|(
operator|&
name|hooks_env
argument_list|,
name|pb
operator|->
name|repos
operator|->
name|hooks_env_path
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_txn_name
argument_list|(
operator|&
name|txn_name
argument_list|,
name|rb
operator|->
name|txn
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_fs_abort_txn
argument_list|(
name|rb
operator|->
name|txn
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* Run the pre-commit hook, if so commanded. */
if|if
condition|(
name|pb
operator|->
name|use_pre_commit_hook
condition|)
block|{
name|err
operator|=
name|svn_repos__hooks_pre_commit
argument_list|(
name|pb
operator|->
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|txn_name
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_fs_abort_txn
argument_list|(
name|rb
operator|->
name|txn
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* Commit. */
name|err
operator|=
name|svn_fs_commit_txn
argument_list|(
operator|&
name|conflict_msg
argument_list|,
operator|&
name|committed_rev
argument_list|,
name|rb
operator|->
name|txn
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|committed_rev
argument_list|)
condition|)
block|{
if|if
condition|(
name|err
condition|)
block|{
comment|/* ### Log any error, but better yet is to rev              ### close_revision()'s API to allow both committed_rev and err              ### to be returned, see #3768. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|svn_error_clear
argument_list|(
name|svn_fs_abort_txn
argument_list|(
name|rb
operator|->
name|txn
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_msg
condition|)
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|conflict_msg
argument_list|)
return|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* Run post-commit hook, if so commanded.  */
if|if
condition|(
name|pb
operator|->
name|use_post_commit_hook
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|svn_repos__hooks_post_commit
argument_list|(
name|pb
operator|->
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|committed_rev
argument_list|,
name|txn_name
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Commit succeeded, but post-commit hook failed"
argument_list|)
argument_list|)
return|;
block|}
comment|/* After a successful commit, must record the dump-rev -> in-repos-rev      mapping, so that copyfrom instructions in the dump file can look up the      correct repository revision to copy from. */
name|set_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|rb
operator|->
name|rev
argument_list|,
name|committed_rev
argument_list|)
expr_stmt|;
comment|/* If the incoming dump stream has non-contiguous revisions (e.g. from      using svndumpfilter --drop-empty-revs without --renumber-revs) then      we must account for the missing gaps in PB->REV_MAP.  Otherwise we      might not be able to map all mergeinfo source revisions to the correct      revisions in the target repos. */
if|if
condition|(
operator|(
name|pb
operator|->
name|last_rev_mapped
operator|!=
name|SVN_INVALID_REVNUM
operator|)
operator|&&
operator|(
name|rb
operator|->
name|rev
operator|!=
name|pb
operator|->
name|last_rev_mapped
operator|+
literal|1
operator|)
condition|)
block|{
name|svn_revnum_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|pb
operator|->
name|last_rev_mapped
operator|+
literal|1
init|;
name|i
operator|<
name|rb
operator|->
name|rev
condition|;
name|i
operator|++
control|)
block|{
name|set_revision_mapping
argument_list|(
name|pb
operator|->
name|rev_map
argument_list|,
name|i
argument_list|,
name|pb
operator|->
name|last_rev_mapped
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update our "last revision mapped". */
name|pb
operator|->
name|last_rev_mapped
operator|=
name|rb
operator|->
name|rev
expr_stmt|;
comment|/* Deltify the predecessors of paths changed in this revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_deltify_revision
argument_list|(
name|pb
operator|->
name|fs
argument_list|,
name|committed_rev
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Grrr, svn_fs_commit_txn rewrites the datestamp property to the      current clock-time.  We don't want that, we want to preserve      history exactly.  Good thing revision props aren't versioned!      Note that if rb->datestamp is NULL, that's fine -- if the dump      data doesn't carry a datestamp, we want to preserve that fact in      the load. */
name|SVN_ERR
argument_list|(
name|change_rev_prop
argument_list|(
name|pb
operator|->
name|repos
argument_list|,
name|committed_rev
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|rb
operator|->
name|datestamp
argument_list|,
name|pb
operator|->
name|validate_props
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|notify_func
condition|)
block|{
comment|/* ### TODO: Use proper scratch pool instead of pb->notify_pool */
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_load_txn_committed
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|new_revision
operator|=
name|committed_rev
expr_stmt|;
name|notify
operator|->
name|old_revision
operator|=
operator|(
operator|(
name|committed_rev
operator|==
name|rb
operator|->
name|rev
operator|)
condition|?
name|SVN_INVALID_REVNUM
else|:
name|rb
operator|->
name|rev
operator|)
expr_stmt|;
name|pb
operator|->
name|notify_func
argument_list|(
name|pb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|pb
operator|->
name|notify_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** The public routines **/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_get_fs_build_parser4
parameter_list|(
specifier|const
name|svn_repos_parse_fns3_t
modifier|*
modifier|*
name|callbacks
parameter_list|,
name|void
modifier|*
modifier|*
name|parse_baton
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_boolean_t
name|use_history
parameter_list|,
name|svn_boolean_t
name|validate_props
parameter_list|,
name|enum
name|svn_repos_load_uuid
name|uuid_action
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_dir
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos_parse_fns3_t
modifier|*
name|parser
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pb
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent_dir
condition|)
name|parent_dir
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|parent_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
condition|)
name|SVN_ERR_ASSERT
argument_list|(
name|start_rev
operator|<=
name|end_rev
argument_list|)
expr_stmt|;
name|parser
operator|->
name|magic_header_record
operator|=
name|magic_header_record
expr_stmt|;
name|parser
operator|->
name|uuid_record
operator|=
name|uuid_record
expr_stmt|;
name|parser
operator|->
name|new_revision_record
operator|=
name|new_revision_record
expr_stmt|;
name|parser
operator|->
name|new_node_record
operator|=
name|new_node_record
expr_stmt|;
name|parser
operator|->
name|set_revision_property
operator|=
name|set_revision_property
expr_stmt|;
name|parser
operator|->
name|set_node_property
operator|=
name|set_node_property
expr_stmt|;
name|parser
operator|->
name|remove_node_props
operator|=
name|remove_node_props
expr_stmt|;
name|parser
operator|->
name|set_fulltext
operator|=
name|set_fulltext
expr_stmt|;
name|parser
operator|->
name|close_node
operator|=
name|close_node
expr_stmt|;
name|parser
operator|->
name|close_revision
operator|=
name|close_revision
expr_stmt|;
name|parser
operator|->
name|delete_node_property
operator|=
name|delete_node_property
expr_stmt|;
name|parser
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|pb
operator|->
name|repos
operator|=
name|repos
expr_stmt|;
name|pb
operator|->
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|pb
operator|->
name|use_history
operator|=
name|use_history
expr_stmt|;
name|pb
operator|->
name|validate_props
operator|=
name|validate_props
expr_stmt|;
name|pb
operator|->
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|pb
operator|->
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|pb
operator|->
name|uuid_action
operator|=
name|uuid_action
expr_stmt|;
name|pb
operator|->
name|parent_dir
operator|=
name|parent_dir
expr_stmt|;
name|pb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|pb
operator|->
name|notify_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|pb
operator|->
name|rev_map
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|pb
operator|->
name|oldest_old_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|pb
operator|->
name|last_rev_mapped
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|pb
operator|->
name|start_rev
operator|=
name|start_rev
expr_stmt|;
name|pb
operator|->
name|end_rev
operator|=
name|end_rev
expr_stmt|;
operator|*
name|callbacks
operator|=
name|parser
expr_stmt|;
operator|*
name|parse_baton
operator|=
name|pb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_load_fs4
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_stream_t
modifier|*
name|dumpstream
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|enum
name|svn_repos_load_uuid
name|uuid_action
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_dir
parameter_list|,
name|svn_boolean_t
name|use_pre_commit_hook
parameter_list|,
name|svn_boolean_t
name|use_post_commit_hook
parameter_list|,
name|svn_boolean_t
name|validate_props
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_repos_parse_fns3_t
modifier|*
name|parser
decl_stmt|;
name|void
modifier|*
name|parse_baton
decl_stmt|;
name|struct
name|parse_baton
modifier|*
name|pb
decl_stmt|;
comment|/* This is really simple. */
name|SVN_ERR
argument_list|(
name|svn_repos_get_fs_build_parser4
argument_list|(
operator|&
name|parser
argument_list|,
operator|&
name|parse_baton
argument_list|,
name|repos
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|TRUE
argument_list|,
comment|/* look for copyfrom revs */
name|validate_props
argument_list|,
name|uuid_action
argument_list|,
name|parent_dir
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Heh.  We know this is a parse_baton.  This file made it.  So      cast away, and set our hook booleans.  */
name|pb
operator|=
name|parse_baton
expr_stmt|;
name|pb
operator|->
name|use_pre_commit_hook
operator|=
name|use_pre_commit_hook
expr_stmt|;
name|pb
operator|->
name|use_post_commit_hook
operator|=
name|use_post_commit_hook
expr_stmt|;
return|return
name|svn_repos_parse_dumpstream3
argument_list|(
name|dumpstream
argument_list|,
name|parser
argument_list|,
name|parse_baton
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

end_unit

