begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* authz.c : path-based access control  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Structures. ***/
end_comment

begin_comment
comment|/* Information for the config enumerators called during authz    lookup. */
end_comment

begin_struct
struct|struct
name|authz_lookup_baton
block|{
comment|/* The authz configuration. */
name|svn_config_t
modifier|*
name|config
decl_stmt|;
comment|/* The user to authorize. */
specifier|const
name|char
modifier|*
name|user
decl_stmt|;
comment|/* Explicitly granted rights. */
name|svn_repos_authz_access_t
name|allow
decl_stmt|;
comment|/* Explicitly denied rights. */
name|svn_repos_authz_access_t
name|deny
decl_stmt|;
comment|/* The rights required by the caller of the lookup. */
name|svn_repos_authz_access_t
name|required_access
decl_stmt|;
comment|/* The following are used exclusively in recursive lookups. */
comment|/* The path in the repository (an fspath) to authorize. */
specifier|const
name|char
modifier|*
name|repos_path
decl_stmt|;
comment|/* repos_path prefixed by the repository name and a colon. */
specifier|const
name|char
modifier|*
name|qualified_repos_path
decl_stmt|;
comment|/* Whether, at the end of a recursive lookup, access is granted. */
name|svn_boolean_t
name|access
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information for the config enumeration functions called during the    validation process. */
end_comment

begin_struct
struct|struct
name|authz_validate_baton
block|{
name|svn_config_t
modifier|*
name|config
decl_stmt|;
comment|/* The configuration file being validated. */
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* The error being thrown out of the                            enumerator, if any. */
block|}
struct|;
end_struct

begin_comment
comment|/* Currently this structure is just a wrapper around a    svn_config_t. */
end_comment

begin_struct
struct|struct
name|svn_authz_t
block|{
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/*** Checking access. ***/
end_comment

begin_comment
comment|/* Determine whether the REQUIRED access is granted given what authz  * to ALLOW or DENY.  Return TRUE if the REQUIRED access is  * granted.  *  * Access is granted either when no required access is explicitly  * denied (implicit grant), or when the required access is explicitly  * granted, overriding any denials.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_access_is_granted
parameter_list|(
name|svn_repos_authz_access_t
name|allow
parameter_list|,
name|svn_repos_authz_access_t
name|deny
parameter_list|,
name|svn_repos_authz_access_t
name|required
parameter_list|)
block|{
name|svn_repos_authz_access_t
name|stripped_req
init|=
name|required
operator|&
operator|(
name|svn_authz_read
operator||
name|svn_authz_write
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|deny
operator|&
name|required
operator|)
operator|==
name|svn_authz_none
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
operator|(
name|allow
operator|&
name|required
operator|)
operator|==
name|stripped_req
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Decide whether the REQUIRED access has been conclusively  * determined.  Return TRUE if the given ALLOW/DENY authz are  * conclusive regarding the REQUIRED authz.  *  * Conclusive determination occurs when any of the REQUIRED authz are  * granted or denied by ALLOW/DENY.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_access_is_determined
parameter_list|(
name|svn_repos_authz_access_t
name|allow
parameter_list|,
name|svn_repos_authz_access_t
name|deny
parameter_list|,
name|svn_repos_authz_access_t
name|required
parameter_list|)
block|{
if|if
condition|(
operator|(
name|deny
operator|&
name|required
operator|)
operator|||
operator|(
name|allow
operator|&
name|required
operator|)
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE is USER equals ALIAS. The alias definitions are in the    "aliases" sections of CFG. Use POOL for temporary allocations during    the lookup. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_alias_is_user
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|alias
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|value
argument_list|,
literal|"aliases"
argument_list|,
name|alias
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|user
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if USER is in GROUP.  The group definitions are in the    "groups" section of CFG.  Use POOL for temporary allocations during    the lookup. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_group_contains_user
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|group
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|value
argument_list|,
literal|"groups"
argument_list|,
name|group
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list
operator|=
name|svn_cstring_split
argument_list|(
name|value
argument_list|,
literal|","
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|group_user
init|=
name|APR_ARRAY_IDX
argument_list|(
name|list
argument_list|,
name|i
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* If the 'user' is a subgroup, recurse into it. */
if|if
condition|(
operator|*
name|group_user
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|authz_group_contains_user
argument_list|(
name|cfg
argument_list|,
operator|&
name|group_user
index|[
literal|1
index|]
argument_list|,
name|user
argument_list|,
name|pool
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* If the 'user' is an alias, verify it. */
elseif|else
if|if
condition|(
operator|*
name|group_user
operator|==
literal|'&'
condition|)
block|{
if|if
condition|(
name|authz_alias_is_user
argument_list|(
name|cfg
argument_list|,
operator|&
name|group_user
index|[
literal|1
index|]
argument_list|,
name|user
argument_list|,
name|pool
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* If the user matches, stop. */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|user
argument_list|,
name|group_user
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Determines whether an authz rule applies to the current  * user, given the name part of the rule's name-value pair  * in RULE_MATCH_STRING and the authz_lookup_baton object  * B with the username in question.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_line_applies_to_user
parameter_list|(
specifier|const
name|char
modifier|*
name|rule_match_string
parameter_list|,
name|struct
name|authz_lookup_baton
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* If the rule has an inversion, recurse and invert the result. */
if|if
condition|(
name|rule_match_string
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
return|return
operator|!
name|authz_line_applies_to_user
argument_list|(
operator|&
name|rule_match_string
index|[
literal|1
index|]
argument_list|,
name|b
argument_list|,
name|pool
argument_list|)
return|;
comment|/* Check for special tokens. */
if|if
condition|(
name|strcmp
argument_list|(
name|rule_match_string
argument_list|,
literal|"$anonymous"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|b
operator|->
name|user
operator|==
name|NULL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|rule_match_string
argument_list|,
literal|"$authenticated"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|b
operator|->
name|user
operator|!=
name|NULL
operator|)
return|;
comment|/* Check for a wildcard rule. */
if|if
condition|(
name|strcmp
argument_list|(
name|rule_match_string
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* If we get here, then the rule is:    *  - Not an inversion rule.    *  - Not an authz token rule.    *  - Not a wildcard rule.    *    * All that's left over is regular user or group specifications.    */
comment|/* If the session is anonymous, then a user/group    * rule definitely won't match.    */
if|if
condition|(
name|b
operator|->
name|user
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Process the rule depending on whether it is    * a user, alias or group rule.    */
if|if
condition|(
name|rule_match_string
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
return|return
name|authz_group_contains_user
argument_list|(
name|b
operator|->
name|config
argument_list|,
operator|&
name|rule_match_string
index|[
literal|1
index|]
argument_list|,
name|b
operator|->
name|user
argument_list|,
name|pool
argument_list|)
return|;
elseif|else
if|if
condition|(
name|rule_match_string
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
return|return
name|authz_alias_is_user
argument_list|(
name|b
operator|->
name|config
argument_list|,
operator|&
name|rule_match_string
index|[
literal|1
index|]
argument_list|,
name|b
operator|->
name|user
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
operator|(
name|strcmp
argument_list|(
name|b
operator|->
name|user
argument_list|,
name|rule_match_string
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Callback to parse one line of an authz file and update the  * authz_baton accordingly.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_parse_line
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|authz_lookup_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* Stop if the rule doesn't apply to this user. */
if|if
condition|(
operator|!
name|authz_line_applies_to_user
argument_list|(
name|name
argument_list|,
name|b
argument_list|,
name|pool
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Set the access grants for the rule. */
if|if
condition|(
name|strchr
argument_list|(
name|value
argument_list|,
literal|'r'
argument_list|)
condition|)
name|b
operator|->
name|allow
operator||=
name|svn_authz_read
expr_stmt|;
else|else
name|b
operator|->
name|deny
operator||=
name|svn_authz_read
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|value
argument_list|,
literal|'w'
argument_list|)
condition|)
name|b
operator|->
name|allow
operator||=
name|svn_authz_write
expr_stmt|;
else|else
name|b
operator|->
name|deny
operator||=
name|svn_authz_write
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff the access rules in SECTION_NAME apply to PATH_SPEC  * (which is a repository name, colon, and repository fspath, such as  * "myrepos:/trunk/foo").  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_applicable_section
parameter_list|(
specifier|const
name|char
modifier|*
name|path_spec
parameter_list|,
specifier|const
name|char
modifier|*
name|section_name
parameter_list|)
block|{
name|apr_size_t
name|path_spec_len
init|=
name|strlen
argument_list|(
name|path_spec
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|strncmp
argument_list|(
name|path_spec
argument_list|,
name|section_name
argument_list|,
name|path_spec_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|path_spec
index|[
name|path_spec_len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|section_name
index|[
name|path_spec_len
index|]
operator|==
literal|'/'
operator|||
name|section_name
index|[
name|path_spec_len
index|]
operator|==
literal|'\0'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Callback to parse a section and update the authz_baton if the  * section denies access to the subtree the baton describes.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_parse_section
parameter_list|(
specifier|const
name|char
modifier|*
name|section_name
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|authz_lookup_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_boolean_t
name|conclusive
decl_stmt|;
comment|/* Does the section apply to us? */
if|if
condition|(
operator|!
name|is_applicable_section
argument_list|(
name|b
operator|->
name|qualified_repos_path
argument_list|,
name|section_name
argument_list|)
operator|&&
operator|!
name|is_applicable_section
argument_list|(
name|b
operator|->
name|repos_path
argument_list|,
name|section_name
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Work out what this section grants. */
name|b
operator|->
name|allow
operator|=
name|b
operator|->
name|deny
operator|=
literal|0
expr_stmt|;
name|svn_config_enumerate2
argument_list|(
name|b
operator|->
name|config
argument_list|,
name|section_name
argument_list|,
name|authz_parse_line
argument_list|,
name|b
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Has the section explicitly determined an access? */
name|conclusive
operator|=
name|authz_access_is_determined
argument_list|(
name|b
operator|->
name|allow
argument_list|,
name|b
operator|->
name|deny
argument_list|,
name|b
operator|->
name|required_access
argument_list|)
expr_stmt|;
comment|/* Is access granted OR inconclusive? */
name|b
operator|->
name|access
operator|=
name|authz_access_is_granted
argument_list|(
name|b
operator|->
name|allow
argument_list|,
name|b
operator|->
name|deny
argument_list|,
name|b
operator|->
name|required_access
argument_list|)
operator|||
operator|!
name|conclusive
expr_stmt|;
comment|/* As long as access isn't conclusively denied, carry on. */
return|return
name|b
operator|->
name|access
return|;
block|}
end_function

begin_comment
comment|/* Validate access to the given user for the given path.  This  * function checks rules for exactly the given path, and first tries  * to access a section specific to the given repository before falling  * back to pan-repository rules.  *  * Update *access_granted to inform the caller of the outcome of the  * lookup.  Return a boolean indicating whether the access rights were  * successfully determined.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_get_path_access
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_name
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
name|svn_repos_authz_access_t
name|required_access
parameter_list|,
name|svn_boolean_t
modifier|*
name|access_granted
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|qualified_path
decl_stmt|;
name|struct
name|authz_lookup_baton
name|baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|baton
operator|.
name|config
operator|=
name|cfg
expr_stmt|;
name|baton
operator|.
name|user
operator|=
name|user
expr_stmt|;
comment|/* Try to locate a repository-specific block first. */
name|qualified_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|repos_name
argument_list|,
literal|":"
argument_list|,
name|path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|svn_config_enumerate2
argument_list|(
name|cfg
argument_list|,
name|qualified_path
argument_list|,
name|authz_parse_line
argument_list|,
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|access_granted
operator|=
name|authz_access_is_granted
argument_list|(
name|baton
operator|.
name|allow
argument_list|,
name|baton
operator|.
name|deny
argument_list|,
name|required_access
argument_list|)
expr_stmt|;
comment|/* If the first test has determined access, stop now. */
if|if
condition|(
name|authz_access_is_determined
argument_list|(
name|baton
operator|.
name|allow
argument_list|,
name|baton
operator|.
name|deny
argument_list|,
name|required_access
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* No repository specific rule, try pan-repository rules. */
name|svn_config_enumerate2
argument_list|(
name|cfg
argument_list|,
name|path
argument_list|,
name|authz_parse_line
argument_list|,
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|access_granted
operator|=
name|authz_access_is_granted
argument_list|(
name|baton
operator|.
name|allow
argument_list|,
name|baton
operator|.
name|deny
argument_list|,
name|required_access
argument_list|)
expr_stmt|;
return|return
name|authz_access_is_determined
argument_list|(
name|baton
operator|.
name|allow
argument_list|,
name|baton
operator|.
name|deny
argument_list|,
name|required_access
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Validate access to the given user for the subtree starting at the  * given path.  This function walks the whole authz file in search of  * rules applying to paths in the requested subtree which deny the  * requested access.  *  * As soon as one is found, or else when the whole ACL file has been  * searched, return the updated authorization status.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_get_tree_access
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_name
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
name|svn_repos_authz_access_t
name|required_access
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|authz_lookup_baton
name|baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|baton
operator|.
name|config
operator|=
name|cfg
expr_stmt|;
name|baton
operator|.
name|user
operator|=
name|user
expr_stmt|;
name|baton
operator|.
name|required_access
operator|=
name|required_access
expr_stmt|;
name|baton
operator|.
name|repos_path
operator|=
name|path
expr_stmt|;
name|baton
operator|.
name|qualified_repos_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|repos_name
argument_list|,
literal|":"
argument_list|,
name|path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Default to access granted if no rules say otherwise. */
name|baton
operator|.
name|access
operator|=
name|TRUE
expr_stmt|;
name|svn_config_enumerate_sections2
argument_list|(
name|cfg
argument_list|,
name|authz_parse_section
argument_list|,
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|baton
operator|.
name|access
return|;
block|}
end_function

begin_comment
comment|/* Callback to parse sections of the configuration file, looking for    any kind of granted access.  Implements the    svn_config_section_enumerator2_t interface. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_get_any_access_parser_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|section_name
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|authz_lookup_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* Does the section apply to the query? */
if|if
condition|(
name|section_name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|strncmp
argument_list|(
name|section_name
argument_list|,
name|b
operator|->
name|qualified_repos_path
argument_list|,
name|strlen
argument_list|(
name|b
operator|->
name|qualified_repos_path
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|b
operator|->
name|allow
operator|=
name|b
operator|->
name|deny
operator|=
name|svn_authz_none
expr_stmt|;
name|svn_config_enumerate2
argument_list|(
name|b
operator|->
name|config
argument_list|,
name|section_name
argument_list|,
name|authz_parse_line
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|access
operator|=
name|authz_access_is_granted
argument_list|(
name|b
operator|->
name|allow
argument_list|,
name|b
operator|->
name|deny
argument_list|,
name|b
operator|->
name|required_access
argument_list|)
expr_stmt|;
comment|/* Continue as long as we don't find a determined, granted access. */
return|return
operator|!
operator|(
name|b
operator|->
name|access
operator|&&
name|authz_access_is_determined
argument_list|(
name|b
operator|->
name|allow
argument_list|,
name|b
operator|->
name|deny
argument_list|,
name|b
operator|->
name|required_access
argument_list|)
operator|)
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Walk through the authz CFG to check if USER has the REQUIRED_ACCESS  * to any path within the REPOSITORY.  Return TRUE if so.  Use POOL  * for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_get_any_access
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_name
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
name|svn_repos_authz_access_t
name|required_access
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|authz_lookup_baton
name|baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|baton
operator|.
name|config
operator|=
name|cfg
expr_stmt|;
name|baton
operator|.
name|user
operator|=
name|user
expr_stmt|;
name|baton
operator|.
name|required_access
operator|=
name|required_access
expr_stmt|;
name|baton
operator|.
name|access
operator|=
name|FALSE
expr_stmt|;
comment|/* Deny access by default. */
name|baton
operator|.
name|repos_path
operator|=
literal|"/"
expr_stmt|;
name|baton
operator|.
name|qualified_repos_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|repos_name
argument_list|,
literal|":/"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* We could have used svn_config_enumerate2 for "repos_name:/".    * However, this requires access for root explicitly (which the user    * may not always have). So we end up enumerating the sections in    * the authz CFG and stop on the first match with some access for    * this user. */
name|svn_config_enumerate_sections2
argument_list|(
name|cfg
argument_list|,
name|authz_get_any_access_parser_cb
argument_list|,
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If walking the configuration was inconclusive, deny access. */
if|if
condition|(
operator|!
name|authz_access_is_determined
argument_list|(
name|baton
operator|.
name|allow
argument_list|,
name|baton
operator|.
name|deny
argument_list|,
name|baton
operator|.
name|required_access
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|baton
operator|.
name|access
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Validating the authz file. ***/
end_comment

begin_comment
comment|/* Check for errors in GROUP's definition of CFG.  The errors  * detected are references to non-existent groups and circular  * dependencies between groups.  If an error is found, return  * SVN_ERR_AUTHZ_INVALID_CONFIG.  Use POOL for temporary  * allocations only.  *  * CHECKED_GROUPS should be an empty (it is used for recursive calls).  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|authz_group_walk
parameter_list|(
name|svn_config_t
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|group
parameter_list|,
name|apr_hash_t
modifier|*
name|checked_groups
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|value
argument_list|,
literal|"groups"
argument_list|,
name|group
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Having a non-existent group in the ACL configuration might be the      sign of a typo.  Refuse to perform authz on uncertain rules. */
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"An authz rule refers to group '%s', "
literal|"which is undefined"
argument_list|,
name|group
argument_list|)
return|;
name|list
operator|=
name|svn_cstring_split
argument_list|(
name|value
argument_list|,
literal|","
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|group_user
init|=
name|APR_ARRAY_IDX
argument_list|(
name|list
argument_list|,
name|i
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* If the 'user' is a subgroup, recurse into it. */
if|if
condition|(
operator|*
name|group_user
operator|==
literal|'@'
condition|)
block|{
comment|/* A circular dependency between groups is a Bad Thing.  We              don't do authz with invalid ACL files. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|checked_groups
argument_list|,
operator|&
name|group_user
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"Circular dependency between "
literal|"groups '%s' and '%s'"
argument_list|,
operator|&
name|group_user
index|[
literal|1
index|]
argument_list|,
name|group
argument_list|)
return|;
comment|/* Add group to hash of checked groups. */
name|svn_hash_sets
argument_list|(
name|checked_groups
argument_list|,
operator|&
name|group_user
index|[
literal|1
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Recurse on that group. */
name|SVN_ERR
argument_list|(
name|authz_group_walk
argument_list|(
name|cfg
argument_list|,
operator|&
name|group_user
index|[
literal|1
index|]
argument_list|,
name|checked_groups
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove group from hash of checked groups, so that we don't              incorrectly report an error if we see it again as part of              another group. */
name|svn_hash_sets
argument_list|(
name|checked_groups
argument_list|,
operator|&
name|group_user
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|group_user
operator|==
literal|'&'
condition|)
block|{
specifier|const
name|char
modifier|*
name|alias
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|alias
argument_list|,
literal|"aliases"
argument_list|,
operator|&
name|group_user
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Having a non-existent alias in the ACL configuration might be the              sign of a typo.  Refuse to perform authz on uncertain rules. */
if|if
condition|(
operator|!
name|alias
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"An authz rule refers to alias '%s', "
literal|"which is undefined"
argument_list|,
operator|&
name|group_user
index|[
literal|1
index|]
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Callback to perform some simple sanity checks on an authz rule.  *  * - If RULE_MATCH_STRING references a group or an alias, verify that  *   the group or alias definition exists.  * - If RULE_MATCH_STRING specifies a token (starts with $), verify  *   that the token name is valid.  * - If RULE_MATCH_STRING is using inversion, verify that it isn't  *   doing it more than once within the one rule, and that it isn't  *   "~*", as that would never match.  * - Check that VALUE part of the rule specifies only allowed rule  *   flag characters ('r' and 'w').  *  * Return TRUE if the rule has no errors. Use BATON for context and  * error reporting.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_validate_rule
parameter_list|(
specifier|const
name|char
modifier|*
name|rule_match_string
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|match
init|=
name|rule_match_string
decl_stmt|;
name|struct
name|authz_validate_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* Make sure the user isn't using double-negatives. */
if|if
condition|(
name|match
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
comment|/* Bump the pointer past the inversion for the other checks. */
name|match
operator|++
expr_stmt|;
comment|/* Another inversion is a double negative; we can't not stop. */
if|if
condition|(
name|match
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"Rule '%s' has more than one "
literal|"inversion; double negatives are "
literal|"not permitted."
argument_list|,
name|rule_match_string
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Make sure that the rule isn't "~*", which won't ever match. */
if|if
condition|(
name|strcmp
argument_list|(
name|match
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"Authz rules with match string '~*' "
literal|"are not allowed, because they never "
literal|"match anyone."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* If the rule applies to a group, check its existence. */
if|if
condition|(
name|match
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
specifier|const
name|char
modifier|*
name|group
init|=
operator|&
name|match
index|[
literal|1
index|]
decl_stmt|;
name|svn_config_get
argument_list|(
name|b
operator|->
name|config
argument_list|,
operator|&
name|val
argument_list|,
literal|"groups"
argument_list|,
name|group
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Having a non-existent group in the ACL configuration might be          the sign of a typo.  Refuse to perform authz on uncertain          rules. */
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"An authz rule refers to group "
literal|"'%s', which is undefined"
argument_list|,
name|rule_match_string
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* If the rule applies to an alias, check its existence. */
if|if
condition|(
name|match
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
block|{
specifier|const
name|char
modifier|*
name|alias
init|=
operator|&
name|match
index|[
literal|1
index|]
decl_stmt|;
name|svn_config_get
argument_list|(
name|b
operator|->
name|config
argument_list|,
operator|&
name|val
argument_list|,
literal|"aliases"
argument_list|,
name|alias
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"An authz rule refers to alias "
literal|"'%s', which is undefined"
argument_list|,
name|rule_match_string
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* If the rule specifies a token, check its validity. */
if|if
condition|(
name|match
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
specifier|const
name|char
modifier|*
name|token_name
init|=
operator|&
name|match
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|token_name
argument_list|,
literal|"anonymous"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|token_name
argument_list|,
literal|"authenticated"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"Unrecognized authz token '%s'."
argument_list|,
name|rule_match_string
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|val
operator|=
name|value
expr_stmt|;
while|while
condition|(
operator|*
name|val
condition|)
block|{
if|if
condition|(
operator|*
name|val
operator|!=
literal|'r'
operator|&&
operator|*
name|val
operator|!=
literal|'w'
operator|&&
operator|!
name|svn_ctype_isspace
argument_list|(
operator|*
name|val
argument_list|)
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"The character '%c' in rule '%s' is not "
literal|"allowed in authz rules"
argument_list|,
operator|*
name|val
argument_list|,
name|rule_match_string
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|++
name|val
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Callback to check ALIAS's definition for validity.  Use    BATON for context and error reporting. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_validate_alias
parameter_list|(
specifier|const
name|char
modifier|*
name|alias
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* No checking at the moment, every alias is valid */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Callback to check GROUP's definition for cyclic dependancies.  Use    BATON for context and error reporting. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_validate_group
parameter_list|(
specifier|const
name|char
modifier|*
name|group
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|authz_validate_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|b
operator|->
name|err
operator|=
name|authz_group_walk
argument_list|(
name|b
operator|->
name|config
argument_list|,
name|group
argument_list|,
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|err
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Callback to check the contents of the configuration section given    by NAME.  Use BATON for context and error reporting. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_validate_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|authz_validate_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* Use the group checking callback for the "groups" section... */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"groups"
argument_list|)
operator|==
literal|0
condition|)
name|svn_config_enumerate2
argument_list|(
name|b
operator|->
name|config
argument_list|,
name|name
argument_list|,
name|authz_validate_group
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* ...and the alias checking callback for "aliases"... */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"aliases"
argument_list|)
operator|==
literal|0
condition|)
name|svn_config_enumerate2
argument_list|(
name|b
operator|->
name|config
argument_list|,
name|name
argument_list|,
name|authz_validate_alias
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* ...but for everything else use the rule checking callback. */
else|else
block|{
comment|/* Validate the section's name. Skip the optional REPOS_NAME. */
specifier|const
name|char
modifier|*
name|fspath
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|fspath
condition|)
name|fspath
operator|++
expr_stmt|;
else|else
name|fspath
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fspath__is_canonical
argument_list|(
name|fspath
argument_list|)
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"Section name '%s' contains non-canonical "
literal|"fspath '%s'"
argument_list|,
name|name
argument_list|,
name|fspath
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|svn_config_enumerate2
argument_list|(
name|b
operator|->
name|config
argument_list|,
name|name
argument_list|,
name|authz_validate_rule
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|err
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Walk the configuration in AUTHZ looking for any errors. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|authz_validate
parameter_list|(
name|svn_authz_t
modifier|*
name|authz
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|authz_validate_baton
name|baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|baton
operator|.
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|baton
operator|.
name|config
operator|=
name|authz
operator|->
name|cfg
expr_stmt|;
comment|/* Step through the entire rule file stopping on error. */
name|svn_config_enumerate_sections2
argument_list|(
name|authz
operator|->
name|cfg
argument_list|,
name|authz_validate_section
argument_list|,
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|baton
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the file at DIRENT (contained in a repo) then parse it as a config  * file placing the result into CFG_P allocated in POOL.  *  * If DIRENT cannot be parsed as a config file then an error is returned.  The  * contents of CFG_P is then undefined.  If MUST_EXIST is TRUE, a missing  * authz file is also an error.  *  * SCRATCH_POOL will be used for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|authz_retrieve_config_repo
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfg_p
parameter_list|,
specifier|const
name|char
modifier|*
name|dirent
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_dirent
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
comment|/* Search for a repository in the full path. */
name|repos_root_dirent
operator|=
name|svn_repos_find_root_path
argument_list|(
name|dirent
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|repos_root_dirent
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_LOCAL_REPOS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
literal|"Unable to find repository at '%s'"
argument_list|,
name|dirent
argument_list|)
return|;
comment|/* Attempt to open a repository at repos_root_dirent. */
name|SVN_ERR
argument_list|(
name|svn_repos_open2
argument_list|(
operator|&
name|repos
argument_list|,
name|repos_root_dirent
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs_path
operator|=
operator|&
name|dirent
index|[
name|strlen
argument_list|(
name|repos_root_dirent
argument_list|)
index|]
expr_stmt|;
comment|/* Root path is always a directory so no reason to go any further */
if|if
condition|(
operator|*
name|fs_path
operator|==
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
literal|"'/' is not a file in repo '%s'"
argument_list|,
name|repos_root_dirent
argument_list|)
return|;
comment|/* We skip some things that are non-important for how we're going to use    * this repo connection.  We do not set any capabilities since none of    * the current ones are important for what we're doing.  We also do not    * setup the environment that repos hooks would run under since we won't    * be triggering any. */
comment|/* Get the filesystem. */
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
comment|/* Find HEAD and the revision root */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|youngest_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|node_kind
argument_list|,
name|root
argument_list|,
name|fs_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_none
condition|)
block|{
if|if
condition|(
operator|!
name|must_exist
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_create2
argument_list|(
name|cfg_p
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
literal|"'%s' path not found in repo '%s'"
argument_list|,
name|fs_path
argument_list|,
name|repos_root_dirent
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|node_kind
operator|!=
name|svn_node_file
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not a file in repo '%s'"
argument_list|,
name|fs_path
argument_list|,
name|repos_root_dirent
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|root
argument_list|,
name|fs_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_config_parse
argument_list|(
name|cfg_p
argument_list|,
name|contents
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Add the URL to the error stack since the parser doesn't have it. */
if|if
condition|(
name|err
operator|!=
name|SVN_NO_ERROR
condition|)
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
literal|"Error while parsing config file: '%s' in repo '%s':"
argument_list|,
name|fs_path
argument_list|,
name|repos_root_dirent
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a PATH which might be a relative repo URL (^/), an absolute  * local repo URL (file://), an absolute path outside of the repo  * or a location in the Windows registry.  *  * Retrieve the configuration data that PATH points at and parse it into  * CFG_P allocated in POOL.  *  * If PATH cannot be parsed as a config file then an error is returned.  The  * contents of CFG_P is then undefined.  If MUST_EXIST is TRUE, a missing  * authz file is also an error.  *  * REPOS_ROOT points at the root of the repos you are  * going to apply the authz against, can be NULL if you are sure that you  * don't have a repos relative URL in PATH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|authz_retrieve_config
parameter_list|(
name|svn_config_t
modifier|*
modifier|*
name|cfg_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|dirent
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|err
operator|=
name|svn_uri_get_dirent_from_file_url
argument_list|(
operator|&
name|dirent
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
name|err
operator|=
name|authz_retrieve_config_repo
argument_list|(
name|cfg_p
argument_list|,
name|dirent
argument_list|,
name|must_exist
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Close the repos and streams we opened. */
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
else|else
block|{
comment|/* Outside of repo file or Windows registry*/
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
name|cfg_p
argument_list|,
name|path
argument_list|,
name|must_exist
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Callback to copy (name, value) group into the "groups" section    of another configuration. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|authz_copy_group
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|authz_cfg
init|=
name|baton
decl_stmt|;
name|svn_config_set
argument_list|(
name|authz_cfg
argument_list|,
name|SVN_CONFIG_SECTION_GROUPS
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy group definitions from GROUPS_CFG to the resulting AUTHZ.  * If AUTHZ already contains any group definition, report an error.  * Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|authz_copy_groups
parameter_list|(
name|svn_authz_t
modifier|*
name|authz
parameter_list|,
name|svn_config_t
modifier|*
name|groups_cfg
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Easy out: we prohibit local groups in the authz file when global      groups are being used. */
if|if
condition|(
name|svn_config_has_section
argument_list|(
name|authz
operator|->
name|cfg
argument_list|,
name|SVN_CONFIG_SECTION_GROUPS
argument_list|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
literal|"Authz file cannot contain any groups "
literal|"when global groups are being used."
argument_list|)
return|;
block|}
name|svn_config_enumerate2
argument_list|(
name|groups_cfg
argument_list|,
name|SVN_CONFIG_SECTION_GROUPS
argument_list|,
name|authz_copy_group
argument_list|,
name|authz
operator|->
name|cfg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__authz_read
parameter_list|(
name|svn_authz_t
modifier|*
modifier|*
name|authz_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|groups_path
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|,
name|svn_boolean_t
name|accept_urls
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_authz_t
modifier|*
name|authz
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|authz
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Load the authz file */
if|if
condition|(
name|accept_urls
condition|)
name|SVN_ERR
argument_list|(
name|authz_retrieve_config
argument_list|(
operator|&
name|authz
operator|->
name|cfg
argument_list|,
name|path
argument_list|,
name|must_exist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
operator|&
name|authz
operator|->
name|cfg
argument_list|,
name|path
argument_list|,
name|must_exist
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|groups_path
condition|)
block|{
name|svn_config_t
modifier|*
name|groups_cfg
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Load the groups file */
if|if
condition|(
name|accept_urls
condition|)
name|SVN_ERR
argument_list|(
name|authz_retrieve_config
argument_list|(
operator|&
name|groups_cfg
argument_list|,
name|groups_path
argument_list|,
name|must_exist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
operator|&
name|groups_cfg
argument_list|,
name|groups_path
argument_list|,
name|must_exist
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the groups from groups_cfg into authz. */
name|err
operator|=
name|authz_copy_groups
argument_list|(
name|authz
argument_list|,
name|groups_cfg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Add the paths to the error stack since the authz_copy_groups          routine knows nothing about them. */
if|if
condition|(
name|err
operator|!=
name|SVN_NO_ERROR
condition|)
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
literal|"Error reading authz file '%s' with "
literal|"groups file '%s':"
argument_list|,
name|path
argument_list|,
name|groups_path
argument_list|)
return|;
block|}
comment|/* Make sure there are no errors in the configuration. */
name|SVN_ERR
argument_list|(
name|authz_validate
argument_list|(
name|authz
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|authz_p
operator|=
name|authz
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public functions. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_authz_read2
parameter_list|(
name|svn_authz_t
modifier|*
modifier|*
name|authz_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|groups_path
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_repos__authz_read
argument_list|(
name|authz_p
argument_list|,
name|path
argument_list|,
name|groups_path
argument_list|,
name|must_exist
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_authz_parse
parameter_list|(
name|svn_authz_t
modifier|*
modifier|*
name|authz_p
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stream_t
modifier|*
name|groups_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_authz_t
modifier|*
name|authz
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|authz
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Parse the authz stream */
name|SVN_ERR
argument_list|(
name|svn_config_parse
argument_list|(
operator|&
name|authz
operator|->
name|cfg
argument_list|,
name|stream
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|groups_stream
condition|)
block|{
name|svn_config_t
modifier|*
name|groups_cfg
decl_stmt|;
comment|/* Parse the groups stream */
name|SVN_ERR
argument_list|(
name|svn_config_parse
argument_list|(
operator|&
name|groups_cfg
argument_list|,
name|groups_stream
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_copy_groups
argument_list|(
name|authz
argument_list|,
name|groups_cfg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure there are no errors in the configuration. */
name|SVN_ERR
argument_list|(
name|authz_validate
argument_list|(
name|authz
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|authz_p
operator|=
name|authz
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_authz_check_access
parameter_list|(
name|svn_authz_t
modifier|*
name|authz
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_name
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
name|svn_repos_authz_access_t
name|required_access
parameter_list|,
name|svn_boolean_t
modifier|*
name|access_granted
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|current_path
decl_stmt|;
if|if
condition|(
operator|!
name|repos_name
condition|)
name|repos_name
operator|=
literal|""
expr_stmt|;
comment|/* If PATH is NULL, check if the user has *any* access. */
if|if
condition|(
operator|!
name|path
condition|)
block|{
operator|*
name|access_granted
operator|=
name|authz_get_any_access
argument_list|(
name|authz
operator|->
name|cfg
argument_list|,
name|repos_name
argument_list|,
name|user
argument_list|,
name|required_access
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Sanity check. */
name|SVN_ERR_ASSERT
argument_list|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Determine the granted access for the requested path. */
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|current_path
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|!
name|authz_get_path_access
argument_list|(
name|authz
operator|->
name|cfg
argument_list|,
name|repos_name
argument_list|,
name|current_path
argument_list|,
name|user
argument_list|,
name|required_access
argument_list|,
name|access_granted
argument_list|,
name|pool
argument_list|)
condition|)
block|{
comment|/* Stop if the loop hits the repository root with no          results. */
if|if
condition|(
name|current_path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|current_path
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Deny access by default. */
operator|*
name|access_granted
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Work back to the parent path. */
name|current_path
operator|=
name|svn_fspath__dirname
argument_list|(
name|current_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If the caller requested recursive access, we need to walk through      the entire authz config to see whether any child paths are denied      to the requested user. */
if|if
condition|(
operator|*
name|access_granted
operator|&&
operator|(
name|required_access
operator|&
name|svn_authz_recursive
operator|)
condition|)
operator|*
name|access_granted
operator|=
name|authz_get_tree_access
argument_list|(
name|authz
operator|->
name|cfg
argument_list|,
name|repos_name
argument_list|,
name|path
argument_list|,
name|user
argument_list|,
name|required_access
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

