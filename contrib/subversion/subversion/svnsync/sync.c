begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_auth.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"sync.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|<apr_network_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_comment
comment|/* Normalize the encoding and line ending style of *STR, so that it contains  * only LF (\n) line endings and is encoded in UTF-8. After return, *STR may  * point at a new svn_string_t* allocated in RESULT_POOL.  *  * If SOURCE_PROP_ENCODING is NULL, then *STR is presumed to be encoded in  * UTF-8.  *  * *WAS_NORMALIZED is set to TRUE when *STR needed line ending normalization.  * Otherwise it is set to FALSE.  *  * SCRATCH_POOL is used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|normalize_string
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|str
parameter_list|,
name|svn_boolean_t
modifier|*
name|was_normalized
parameter_list|,
specifier|const
name|char
modifier|*
name|source_prop_encoding
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|new_str
decl_stmt|;
operator|*
name|was_normalized
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
operator|*
name|str
operator|)
operator|->
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_prop_encoding
operator|==
name|NULL
condition|)
name|source_prop_encoding
operator|=
literal|"UTF-8"
expr_stmt|;
name|new_str
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_string2
argument_list|(
operator|&
name|new_str
argument_list|,
name|NULL
argument_list|,
name|was_normalized
argument_list|,
operator|*
name|str
argument_list|,
name|source_prop_encoding
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|new_str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Normalize the encoding and line ending style of the values of properties  * in REV_PROPS that "need translation" (according to  * svn_prop_needs_translation(), which is currently all svn:* props) so that  * they are encoded in UTF-8 and contain only LF (\n) line endings.  *  * The number of properties that needed line ending normalization is returned in  * *NORMALIZED_COUNT.  *  * No re-encoding is performed if SOURCE_PROP_ENCODING is NULL.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svnsync_normalize_revprops
parameter_list|(
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|int
modifier|*
name|normalized_count
parameter_list|,
specifier|const
name|char
modifier|*
name|source_prop_encoding
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
operator|*
name|normalized_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|rev_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|propval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_prop_needs_translation
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|was_normalized
decl_stmt|;
name|SVN_ERR
argument_list|(
name|normalize_string
argument_list|(
operator|&
name|propval
argument_list|,
operator|&
name|was_normalized
argument_list|,
name|source_prop_encoding
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the existing prop value. */
name|svn_hash_sets
argument_list|(
name|rev_props
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_normalized
condition|)
operator|(
operator|*
name|normalized_count
operator|)
operator|++
expr_stmt|;
comment|/* Count it. */
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*** Synchronization Editor ***/
end_comment

begin_comment
comment|/* This editor has a couple of jobs.  *  * First, it needs to filter out the propchanges that can't be passed over  * libsvn_ra.  *  * Second, it needs to adjust for the fact that we might not actually have  * permission to see all of the data from the remote repository, which means  * we could get revisions that are totally empty from our point of view.  *  * Third, it needs to adjust copyfrom paths, adding the root url for the  * destination repository to the beginning of them.  */
end_comment

begin_comment
comment|/* Edit baton */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|edit_baton_t
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|wrapped_editor
decl_stmt|;
name|void
modifier|*
name|wrapped_edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_url
decl_stmt|;
comment|/* URL we're copying into, for correct copyfrom URLs */
specifier|const
name|char
modifier|*
name|source_prop_encoding
decl_stmt|;
name|svn_boolean_t
name|called_open_root
decl_stmt|;
name|svn_boolean_t
name|got_textdeltas
decl_stmt|;
name|svn_revnum_t
name|base_revision
decl_stmt|;
name|svn_boolean_t
name|quiet
decl_stmt|;
name|svn_boolean_t
name|strip_mergeinfo
decl_stmt|;
comment|/* Are we stripping svn:mergeinfo? */
name|svn_boolean_t
name|migrate_svnmerge
decl_stmt|;
comment|/* Are we converting svnmerge.py data? */
name|svn_boolean_t
name|mergeinfo_stripped
decl_stmt|;
comment|/* Did we strip svn:mergeinfo? */
name|svn_boolean_t
name|svnmerge_migrated
decl_stmt|;
comment|/* Did we convert svnmerge.py data? */
name|svn_boolean_t
name|svnmerge_blocked
decl_stmt|;
comment|/* Was there any blocked svnmerge data? */
name|int
modifier|*
name|normalized_node_props_counter
decl_stmt|;
comment|/* Where to count normalizations? */
block|}
name|edit_baton_t
typedef|;
end_typedef

begin_comment
comment|/* A dual-purpose baton for files and directories. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|node_baton_t
block|{
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|void
modifier|*
name|wrapped_node_baton
decl_stmt|;
block|}
name|node_baton_t
typedef|;
end_typedef

begin_comment
comment|/*** Editor vtable functions ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_target_revision
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|edit_baton_t
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|set_target_revision
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|target_revision
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|edit_baton_t
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|node_baton_t
modifier|*
name|dir_baton
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dir_baton
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_root
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|dir_baton
operator|->
name|wrapped_node_baton
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|called_open_root
operator|=
name|TRUE
expr_stmt|;
name|dir_baton
operator|->
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
operator|*
name|root_baton
operator|=
name|dir_baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|delete_entry
argument_list|(
name|path
argument_list|,
name|base_revision
argument_list|,
name|pb
operator|->
name|wrapped_node_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|node_baton_t
modifier|*
name|b
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
comment|/* if copyfrom_path is an fspath create a proper uri */
if|if
condition|(
name|copyfrom_path
operator|&&
name|copyfrom_path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|copyfrom_path
operator|=
name|svn_path_url_add_component2
argument_list|(
name|eb
operator|->
name|to_url
argument_list|,
name|copyfrom_path
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|add_directory
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_node_baton
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_node_baton
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|child_baton
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|node_baton_t
modifier|*
name|db
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_directory
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_node_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|db
operator|->
name|wrapped_node_baton
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|child_baton
operator|=
name|db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|node_baton_t
modifier|*
name|fb
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fb
argument_list|)
argument_list|)
decl_stmt|;
comment|/* if copyfrom_path is an fspath create a proper uri */
if|if
condition|(
name|copyfrom_path
operator|&&
name|copyfrom_path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|copyfrom_path
operator|=
name|svn_path_url_add_component2
argument_list|(
name|eb
operator|->
name|to_url
argument_list|,
name|copyfrom_path
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|add_file
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_node_baton
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|pool
argument_list|,
operator|&
name|fb
operator|->
name|wrapped_node_baton
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|node_baton_t
modifier|*
name|fb
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fb
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_file
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_node_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|fb
operator|->
name|wrapped_node_baton
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
if|if
condition|(
operator|!
name|eb
operator|->
name|quiet
condition|)
block|{
if|if
condition|(
operator|!
name|eb
operator|->
name|got_textdeltas
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Transmitting file data "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"."
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|eb
operator|->
name|got_textdeltas
operator|=
name|TRUE
expr_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|apply_textdelta
argument_list|(
name|fb
operator|->
name|wrapped_node_baton
argument_list|,
name|base_checksum
argument_list|,
name|pool
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_file
argument_list|(
name|fb
operator|->
name|wrapped_node_baton
argument_list|,
name|text_checksum
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|absent_file
argument_list|(
name|path
argument_list|,
name|fb
operator|->
name|wrapped_node_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_directory
argument_list|(
name|db
operator|->
name|wrapped_node_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|absent_directory
argument_list|(
name|path
argument_list|,
name|db
operator|->
name|wrapped_node_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
comment|/* only regular properties can pass over libsvn_ra */
if|if
condition|(
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
operator|!=
name|svn_prop_regular_kind
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Maybe drop svn:mergeinfo.  */
if|if
condition|(
name|eb
operator|->
name|strip_mergeinfo
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|eb
operator|->
name|mergeinfo_stripped
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Maybe drop (errantly set, as this is a file) svnmerge.py properties. */
if|if
condition|(
name|eb
operator|->
name|migrate_svnmerge
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"svnmerge-integrated"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|eb
operator|->
name|svnmerge_migrated
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Remember if we see any svnmerge-blocked properties.  (They really      shouldn't be here, as this is a file, but whatever...)  */
if|if
condition|(
name|eb
operator|->
name|migrate_svnmerge
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"svnmerge-blocked"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|eb
operator|->
name|svnmerge_blocked
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Normalize svn:* properties as necessary. */
if|if
condition|(
name|svn_prop_needs_translation
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|was_normalized
decl_stmt|;
name|SVN_ERR
argument_list|(
name|normalize_string
argument_list|(
operator|&
name|value
argument_list|,
operator|&
name|was_normalized
argument_list|,
name|eb
operator|->
name|source_prop_encoding
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_normalized
condition|)
operator|(
operator|*
operator|(
name|eb
operator|->
name|normalized_node_props_counter
operator|)
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|change_file_prop
argument_list|(
name|fb
operator|->
name|wrapped_node_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_baton_t
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
comment|/* Only regular properties can pass over libsvn_ra */
if|if
condition|(
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
operator|!=
name|svn_prop_regular_kind
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Maybe drop svn:mergeinfo.  */
if|if
condition|(
name|eb
operator|->
name|strip_mergeinfo
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|eb
operator|->
name|mergeinfo_stripped
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Maybe convert svnmerge-integrated data into svn:mergeinfo.  (We      ignore svnmerge-blocked for now.) */
comment|/* ### FIXME: Consult the mirror repository's HEAD prop values and      ### merge svn:mergeinfo, svnmerge-integrated, and svnmerge-blocked. */
if|if
condition|(
name|eb
operator|->
name|migrate_svnmerge
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"svnmerge-integrated"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|value
condition|)
block|{
comment|/* svnmerge-integrated differs from svn:mergeinfo in a pair              of ways.  First, it can use tabs, newlines, or spaces to              delimit source information.  Secondly, the source paths              are relative URLs, whereas svn:mergeinfo uses relative              paths (not URI-encoded). */
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|mergeinfo_buf
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sources
init|=
name|svn_cstring_split
argument_list|(
name|value
operator|->
name|data
argument_list|,
literal|" \t\n"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|new_value
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sources
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|rel_path
decl_stmt|;
name|apr_array_header_t
modifier|*
name|path_revs
init|=
name|svn_cstring_split
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|sources
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
literal|":"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* ### TODO: Warn? */
if|if
condition|(
name|path_revs
operator|->
name|nelts
operator|!=
literal|2
condition|)
continue|continue;
comment|/* Append this source's mergeinfo data. */
name|rel_path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|path_revs
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|rel_path
operator|=
name|svn_path_uri_decode
argument_list|(
name|rel_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|mergeinfo_buf
argument_list|,
name|rel_path
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|mergeinfo_buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|mergeinfo_buf
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|path_revs
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|mergeinfo_buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Try to parse the mergeinfo string we've created, just to              check for bogosity.  If all goes well, we'll unparse it              again and use that as our property value.  */
name|err
operator|=
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo_buf
operator|->
name|data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|new_value
argument_list|,
name|mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|new_value
expr_stmt|;
block|}
name|name
operator|=
name|SVN_PROP_MERGEINFO
expr_stmt|;
name|eb
operator|->
name|svnmerge_migrated
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Remember if we see any svnmerge-blocked properties. */
if|if
condition|(
name|eb
operator|->
name|migrate_svnmerge
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"svnmerge-blocked"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|eb
operator|->
name|svnmerge_blocked
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Normalize svn:* properties as necessary. */
if|if
condition|(
name|svn_prop_needs_translation
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|was_normalized
decl_stmt|;
name|SVN_ERR
argument_list|(
name|normalize_string
argument_list|(
operator|&
name|value
argument_list|,
operator|&
name|was_normalized
argument_list|,
name|eb
operator|->
name|source_prop_encoding
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_normalized
condition|)
operator|(
operator|*
operator|(
name|eb
operator|->
name|normalized_node_props_counter
operator|)
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|change_dir_prop
argument_list|(
name|db
operator|->
name|wrapped_node_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|edit_baton_t
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
comment|/* If we haven't opened the root yet, that means we're transfering      an empty revision, probably because we aren't allowed to see the      contents for some reason.  In any event, we need to open the root      and close it again, before we can close out the edit, or the      commit will fail. */
if|if
condition|(
operator|!
name|eb
operator|->
name|called_open_root
condition|)
block|{
name|void
modifier|*
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_root
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|eb
operator|->
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_directory
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eb
operator|->
name|quiet
condition|)
block|{
if|if
condition|(
name|eb
operator|->
name|got_textdeltas
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|mergeinfo_stripped
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"NOTE: Dropped Subversion mergeinfo "
literal|"from this revision.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|svnmerge_migrated
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"NOTE: Migrated 'svnmerge-integrated' in "
literal|"this revision.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|svnmerge_blocked
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"NOTE: Saw 'svnmerge-blocked' in this "
literal|"revision (but didn't migrate it).\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_edit
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|edit_baton_t
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|abort_edit
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*** Editor factory function ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svnsync_get_sync_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
name|wrapped_editor
parameter_list|,
name|void
modifier|*
name|wrapped_edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|to_url
parameter_list|,
specifier|const
name|char
modifier|*
name|source_prop_encoding
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|int
modifier|*
name|normalized_node_props_counter
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_delta_editor_t
modifier|*
name|tree_editor
init|=
name|svn_delta_default_editor
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|edit_baton_t
modifier|*
name|eb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
name|tree_editor
operator|->
name|set_target_revision
operator|=
name|set_target_revision
expr_stmt|;
name|tree_editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|tree_editor
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|tree_editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|tree_editor
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
name|tree_editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|tree_editor
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|tree_editor
operator|->
name|absent_directory
operator|=
name|absent_directory
expr_stmt|;
name|tree_editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|tree_editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|tree_editor
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|tree_editor
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|tree_editor
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|tree_editor
operator|->
name|absent_file
operator|=
name|absent_file
expr_stmt|;
name|tree_editor
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
name|tree_editor
operator|->
name|abort_edit
operator|=
name|abort_edit
expr_stmt|;
name|eb
operator|->
name|wrapped_editor
operator|=
name|wrapped_editor
expr_stmt|;
name|eb
operator|->
name|wrapped_edit_baton
operator|=
name|wrapped_edit_baton
expr_stmt|;
name|eb
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
name|eb
operator|->
name|to_url
operator|=
name|to_url
expr_stmt|;
name|eb
operator|->
name|source_prop_encoding
operator|=
name|source_prop_encoding
expr_stmt|;
name|eb
operator|->
name|quiet
operator|=
name|quiet
expr_stmt|;
name|eb
operator|->
name|normalized_node_props_counter
operator|=
name|normalized_node_props_counter
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"SVNSYNC_UNSUPPORTED_STRIP_MERGEINFO"
argument_list|)
condition|)
block|{
name|eb
operator|->
name|strip_mergeinfo
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|getenv
argument_list|(
literal|"SVNSYNC_UNSUPPORTED_MIGRATE_SVNMERGE"
argument_list|)
condition|)
block|{
comment|/* Current we can't merge property values.  That's only possible          if all the properties to be merged were always modified in          exactly the same revisions, or if we allow ourselves to          lookup the current state of properties in the sync          destination.  So for now, migrating svnmerge.py data implies          stripping pre-existing svn:mergeinfo. */
comment|/* ### FIXME: Do a real migration by consulting the mirror          ### repository's HEAD propvalues and merging svn:mergeinfo,          ### svnmerge-integrated, and svnmerge-blocked together. */
name|eb
operator|->
name|migrate_svnmerge
operator|=
name|TRUE
expr_stmt|;
name|eb
operator|->
name|strip_mergeinfo
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|editor
operator|=
name|tree_editor
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|eb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

