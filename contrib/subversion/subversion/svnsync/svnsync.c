begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_auth.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_opt_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"sync.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_decl_stmt
specifier|static
name|svn_opt_subcommand_t
name|initialize_cmd
decl_stmt|,
name|synchronize_cmd
decl_stmt|,
name|copy_revprops_cmd
decl_stmt|,
name|info_cmd
decl_stmt|,
name|help_cmd
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|svnsync__opt
block|{
name|svnsync_opt_non_interactive
init|=
name|SVN_OPT_FIRST_LONGOPT_ID
block|,
name|svnsync_opt_force_interactive
block|,
name|svnsync_opt_no_auth_cache
block|,
name|svnsync_opt_auth_username
block|,
name|svnsync_opt_auth_password
block|,
name|svnsync_opt_source_username
block|,
name|svnsync_opt_source_password
block|,
name|svnsync_opt_sync_username
block|,
name|svnsync_opt_sync_password
block|,
name|svnsync_opt_config_dir
block|,
name|svnsync_opt_config_options
block|,
name|svnsync_opt_source_prop_encoding
block|,
name|svnsync_opt_disable_locking
block|,
name|svnsync_opt_version
block|,
name|svnsync_opt_trust_server_cert
block|,
name|svnsync_opt_trust_server_cert_failures_src
block|,
name|svnsync_opt_trust_server_cert_failures_dst
block|,
name|svnsync_opt_allow_non_empty
block|,
name|svnsync_opt_steal_lock
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|SVNSYNC_OPTS_DEFAULT
value|svnsync_opt_non_interactive, \                              svnsync_opt_force_interactive, \                              svnsync_opt_no_auth_cache, \                              svnsync_opt_auth_username, \                              svnsync_opt_auth_password, \                              svnsync_opt_trust_server_cert, \                              svnsync_opt_trust_server_cert_failures_src, \                              svnsync_opt_trust_server_cert_failures_dst, \                              svnsync_opt_source_username, \                              svnsync_opt_source_password, \                              svnsync_opt_sync_username, \                              svnsync_opt_sync_password, \                              svnsync_opt_config_dir, \                              svnsync_opt_config_options
end_define

begin_decl_stmt
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|svnsync_cmd_table
index|[]
init|=
block|{
block|{
literal|"initialize"
block|,
name|initialize_cmd
block|,
block|{
literal|"init"
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnsync initialize DEST_URL SOURCE_URL\n"
literal|"\n"
literal|"Initialize a destination repository for synchronization from\n"
literal|"another repository.\n"
literal|"\n"
literal|"If the source URL is not the root of a repository, only the\n"
literal|"specified part of the repository will be synchronized.\n"
literal|"\n"
literal|"The destination URL must point to the root of a repository which\n"
literal|"has been configured to allow revision property changes.  In\n"
literal|"the general case, the destination repository must contain no\n"
literal|"committed revisions.  Use --allow-non-empty to override this\n"
literal|"restriction, which will cause svnsync to assume that any revisions\n"
literal|"already present in the destination repository perfectly mirror\n"
literal|"their counterparts in the source repository.  (This is useful\n"
literal|"when initializing a copy of a repository as a mirror of that same\n"
literal|"repository, for example.)\n"
literal|"\n"
literal|"You should not commit to, or make revision property changes in,\n"
literal|"the destination repository by any method other than 'svnsync'.\n"
literal|"In other words, the destination repository should be a read-only\n"
literal|"mirror of the source repository.\n"
argument_list|)
block|,
block|{
name|SVNSYNC_OPTS_DEFAULT
block|,
name|svnsync_opt_source_prop_encoding
block|,
literal|'q'
block|,
name|svnsync_opt_allow_non_empty
block|,
name|svnsync_opt_disable_locking
block|,
name|svnsync_opt_steal_lock
block|,
literal|'M'
block|}
block|}
block|,
block|{
literal|"synchronize"
block|,
name|synchronize_cmd
block|,
block|{
literal|"sync"
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnsync synchronize DEST_URL [SOURCE_URL]\n"
literal|"\n"
literal|"Transfer all pending revisions to the destination from the source\n"
literal|"with which it was initialized.\n"
literal|"\n"
literal|"If SOURCE_URL is provided, use that as the source repository URL,\n"
literal|"ignoring what is recorded in the destination repository as the\n"
literal|"source URL.  Specifying SOURCE_URL is recommended in particular\n"
literal|"if untrusted users/administrators may have write access to the\n"
literal|"DEST_URL repository.\n"
argument_list|)
block|,
block|{
name|SVNSYNC_OPTS_DEFAULT
block|,
name|svnsync_opt_source_prop_encoding
block|,
literal|'q'
block|,
name|svnsync_opt_disable_locking
block|,
name|svnsync_opt_steal_lock
block|,
literal|'M'
block|}
block|}
block|,
block|{
literal|"copy-revprops"
block|,
name|copy_revprops_cmd
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage:\n"
literal|"\n"
literal|"    1. svnsync copy-revprops DEST_URL [SOURCE_URL]\n"
literal|"    2. svnsync copy-revprops DEST_URL REV[:REV2]\n"
literal|"\n"
literal|"Copy the revision properties in a given range of revisions to the\n"
literal|"destination from the source with which it was initialized.  If the\n"
literal|"revision range is not specified, it defaults to all revisions in\n"
literal|"the DEST_URL repository.  Note also that the 'HEAD' revision is the\n"
literal|"latest in DEST_URL, not necessarily the latest in SOURCE_URL.\n"
literal|"\n"
literal|"If SOURCE_URL is provided, use that as the source repository URL,\n"
literal|"ignoring what is recorded in the destination repository as the\n"
literal|"source URL.  Specifying SOURCE_URL is recommended in particular\n"
literal|"if untrusted users/administrators may have write access to the\n"
literal|"DEST_URL repository.\n"
literal|"\n"
literal|"Form 2 is deprecated syntax, equivalent to specifying \"-rREV[:REV2]\".\n"
argument_list|)
block|,
block|{
name|SVNSYNC_OPTS_DEFAULT
block|,
name|svnsync_opt_source_prop_encoding
block|,
literal|'q'
block|,
literal|'r'
block|,
name|svnsync_opt_disable_locking
block|,
name|svnsync_opt_steal_lock
block|,
literal|'M'
block|}
block|}
block|,
block|{
literal|"info"
block|,
name|info_cmd
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnsync info DEST_URL\n"
literal|"\n"
literal|"Print information about the synchronization destination repository\n"
literal|"located at DEST_URL.\n"
argument_list|)
block|,
block|{
name|SVNSYNC_OPTS_DEFAULT
block|}
block|}
block|,
block|{
literal|"help"
block|,
name|help_cmd
block|,
block|{
literal|"?"
block|,
literal|"h"
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnsync help [SUBCOMMAND...]\n"
literal|"\n"
literal|"Describe the usage of this program or its subcommands.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|apr_getopt_option_t
name|svnsync_options
index|[]
init|=
block|{
block|{
literal|"quiet"
block|,
literal|'q'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"print as little as possible"
argument_list|)
block|}
block|,
block|{
literal|"revision"
block|,
literal|'r'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"operate on revision ARG (or range ARG1:ARG2)\n"
literal|"                             "
literal|"A revision argument can be one of:\n"
literal|"                             "
literal|"    NUMBER       revision number\n"
literal|"                             "
literal|"    'HEAD'       latest in repository"
argument_list|)
block|}
block|,
block|{
literal|"allow-non-empty"
block|,
name|svnsync_opt_allow_non_empty
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"allow a non-empty destination repository"
argument_list|)
block|}
block|,
block|{
literal|"non-interactive"
block|,
name|svnsync_opt_non_interactive
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do no interactive prompting (default is to prompt\n"
literal|"                             "
literal|"only if standard input is a terminal device)"
argument_list|)
block|}
block|,
block|{
literal|"force-interactive"
block|,
name|svnsync_opt_force_interactive
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do interactive prompting even if standard input\n"
literal|"                             "
literal|"is not a terminal device"
argument_list|)
block|}
block|,
block|{
literal|"no-auth-cache"
block|,
name|svnsync_opt_no_auth_cache
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do not cache authentication tokens"
argument_list|)
block|}
block|,
block|{
literal|"username"
block|,
name|svnsync_opt_auth_username
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify a username ARG (deprecated;\n"
literal|"                             "
literal|"see --source-username and --sync-username)"
argument_list|)
block|}
block|,
block|{
literal|"password"
block|,
name|svnsync_opt_auth_password
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify a password ARG (deprecated;\n"
literal|"                             "
literal|"see --source-password and --sync-password)"
argument_list|)
block|}
block|,
block|{
literal|"trust-server-cert"
block|,
name|svnsync_opt_trust_server_cert
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"deprecated; same as\n"
literal|"                             "
literal|"--source-trust-server-cert-failures=unknown-ca\n"
literal|"                             "
literal|"--sync-trust-server-cert-failures=unknown-ca"
argument_list|)
block|}
block|,
block|{
literal|"source-trust-server-cert-failures"
block|,
name|svnsync_opt_trust_server_cert_failures_src
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"with --non-interactive, accept SSL\n"
literal|"                             "
literal|"server certificates with failures.\n"
literal|"                             "
literal|"ARG is a comma-separated list of:\n"
literal|"                             "
literal|"- 'unknown-ca' (Unknown Authority)\n"
literal|"                             "
literal|"- 'cn-mismatch' (Hostname mismatch)\n"
literal|"                             "
literal|"- 'expired' (Expired certificate)\n"
literal|"                             "
literal|"- 'not-yet-valid' (Not yet valid certificate)\n"
literal|"                             "
literal|"- 'other' (all other not separately classified\n"
literal|"                             "
literal|"  certificate errors).\n"
literal|"                             "
literal|"Applied to the source URL."
argument_list|)
block|}
block|,
block|{
literal|"sync-trust-server-cert-failures"
block|,
name|svnsync_opt_trust_server_cert_failures_dst
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Like\n"
literal|"                             "
literal|"--source-trust-server-cert-failures,\n"
literal|"                             "
literal|"but applied to the destination URL."
argument_list|)
block|}
block|,
block|{
literal|"source-username"
block|,
name|svnsync_opt_source_username
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"connect to source repository with username ARG"
argument_list|)
block|}
block|,
block|{
literal|"source-password"
block|,
name|svnsync_opt_source_password
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"connect to source repository with password ARG"
argument_list|)
block|}
block|,
block|{
literal|"sync-username"
block|,
name|svnsync_opt_sync_username
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"connect to sync repository with username ARG"
argument_list|)
block|}
block|,
block|{
literal|"sync-password"
block|,
name|svnsync_opt_sync_password
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"connect to sync repository with password ARG"
argument_list|)
block|}
block|,
block|{
literal|"config-dir"
block|,
name|svnsync_opt_config_dir
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"read user configuration files from directory ARG"
argument_list|)
block|}
block|,
block|{
literal|"config-option"
block|,
name|svnsync_opt_config_options
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"set user configuration option in the format:\n"
literal|"                             "
literal|"    FILE:SECTION:OPTION=[VALUE]\n"
literal|"                             "
literal|"For example:\n"
literal|"                             "
literal|"    servers:global:http-library=serf"
argument_list|)
block|}
block|,
block|{
literal|"source-prop-encoding"
block|,
name|svnsync_opt_source_prop_encoding
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"convert translatable properties from encoding ARG\n"
literal|"                             "
literal|"to UTF-8. If not specified, then properties are\n"
literal|"                             "
literal|"presumed to be encoded in UTF-8."
argument_list|)
block|}
block|,
block|{
literal|"disable-locking"
block|,
name|svnsync_opt_disable_locking
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Disable built-in locking.  Use of this option can\n"
literal|"                             "
literal|"corrupt the mirror unless you ensure that no other\n"
literal|"                             "
literal|"instance of svnsync is running concurrently."
argument_list|)
block|}
block|,
block|{
literal|"steal-lock"
block|,
name|svnsync_opt_steal_lock
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Steal locks as necessary.  Use, with caution,\n"
literal|"                             "
literal|"if your mirror repository contains stale locks\n"
literal|"                             "
literal|"and is not being concurrently accessed by another\n"
literal|"                             "
literal|"svnsync instance."
argument_list|)
block|}
block|,
block|{
literal|"memory-cache-size"
block|,
literal|'M'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"size of the extra in-memory cache in MB used to\n"
literal|"                             "
literal|"minimize operations for local 'file' scheme.\n"
argument_list|)
block|}
block|,
block|{
literal|"version"
block|,
name|svnsync_opt_version
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show program version information"
argument_list|)
block|}
block|,
block|{
literal|"help"
block|,
literal|'h'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
literal|'?'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|opt_baton_t
block|{
name|svn_boolean_t
name|non_interactive
decl_stmt|;
struct|struct
block|{
name|svn_boolean_t
name|trust_server_cert_unknown_ca
decl_stmt|;
name|svn_boolean_t
name|trust_server_cert_cn_mismatch
decl_stmt|;
name|svn_boolean_t
name|trust_server_cert_expired
decl_stmt|;
name|svn_boolean_t
name|trust_server_cert_not_yet_valid
decl_stmt|;
name|svn_boolean_t
name|trust_server_cert_other_failure
decl_stmt|;
block|}
name|src_trust
struct|,
name|dst_trust
struct|;
name|svn_boolean_t
name|no_auth_cache
decl_stmt|;
name|svn_auth_baton_t
modifier|*
name|source_auth_baton
decl_stmt|;
name|svn_auth_baton_t
modifier|*
name|sync_auth_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_username
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_password
decl_stmt|;
specifier|const
name|char
modifier|*
name|sync_username
decl_stmt|;
specifier|const
name|char
modifier|*
name|sync_password
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_dir
decl_stmt|;
name|apr_hash_t
modifier|*
name|config
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_prop_encoding
decl_stmt|;
name|svn_boolean_t
name|disable_locking
decl_stmt|;
name|svn_boolean_t
name|steal_lock
decl_stmt|;
name|svn_boolean_t
name|quiet
decl_stmt|;
name|svn_boolean_t
name|allow_non_empty
decl_stmt|;
name|svn_boolean_t
name|version
decl_stmt|;
name|svn_boolean_t
name|help
decl_stmt|;
name|svn_opt_revision_t
name|start_rev
decl_stmt|;
name|svn_opt_revision_t
name|end_rev
decl_stmt|;
block|}
name|opt_baton_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/*** Helper functions ***/
end_comment

begin_comment
comment|/* Global record of whether the user has requested cancellation. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|cancelled
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callback function for apr_signal(). */
end_comment

begin_function
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|apr_signal
argument_list|(
name|signum
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|cancelled
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cancellation callback function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_cancel
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
if|if
condition|(
name|cancelled
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CANCELLED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Caught signal"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Check that the version of libraries in use match what we expect. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lib_versions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
literal|"svn_ra"
block|,
name|svn_ra_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
return|return
name|svn_ver_check_list2
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements `svn_ra__lock_retry_func_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lock_retry_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|reposlocktoken
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Failed to get lock on destination "
literal|"repos, currently held by '%s'\n"
argument_list|)
argument_list|,
name|reposlocktoken
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Acquire a lock (of sorts) on the repository associated with the  * given RA SESSION. This lock is just a revprop change attempt in a  * time-delay loop. This function is duplicated by svnrdump in  * svnrdump/load_editor.c  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|lock_string_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|be_atomic
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|stolen_lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|session
argument_list|,
operator|&
name|be_atomic
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|be_atomic
condition|)
block|{
comment|/* Pre-1.7 server.  Can't lock without a race condition.          See issue #3546.        */
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Target server does not support atomic revision property "
literal|"edits; consider upgrading it to 1.7 or using an external "
literal|"locking program"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
literal|"svnsync: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_ra__get_operational_lock
argument_list|(
name|lock_string_p
argument_list|,
operator|&
name|stolen_lock
argument_list|,
name|session
argument_list|,
name|SVNSYNC_PROP_LOCK
argument_list|,
name|steal_lock
argument_list|,
literal|10
comment|/* retries */
argument_list|,
name|lock_retry_func
argument_list|,
name|NULL
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|stolen_lock
condition|)
block|{
return|return
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Stole lock previously held by '%s'\n"
argument_list|)
argument_list|,
name|stolen_lock
operator|->
name|data
argument_list|)
return|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Baton for the various subcommands to share. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|subcommand_baton_t
block|{
comment|/* common to all subcommands */
name|apr_hash_t
modifier|*
name|config
decl_stmt|;
name|svn_ra_callbacks2_t
name|source_callbacks
decl_stmt|;
name|svn_ra_callbacks2_t
name|sync_callbacks
decl_stmt|;
name|svn_boolean_t
name|quiet
decl_stmt|;
name|svn_boolean_t
name|allow_non_empty
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_url
decl_stmt|;
comment|/* initialize, synchronize, and copy-revprops only */
specifier|const
name|char
modifier|*
name|source_prop_encoding
decl_stmt|;
comment|/* initialize only */
specifier|const
name|char
modifier|*
name|from_url
decl_stmt|;
comment|/* synchronize only */
name|svn_revnum_t
name|committed_rev
decl_stmt|;
comment|/* copy-revprops only */
name|svn_revnum_t
name|start_rev
decl_stmt|;
name|svn_revnum_t
name|end_rev
decl_stmt|;
block|}
name|subcommand_baton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|with_locked_func_t
function_decl|)
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|subcommand_baton_t
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Lock the repository associated with RA SESSION, then execute the  * given FUNC/BATON pair while holding the lock.  Finally, drop the  * lock once it finishes.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|with_locked
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|with_locked_func_t
name|func
parameter_list|,
name|subcommand_baton_t
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|lock_string
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_lock
argument_list|(
operator|&
name|lock_string
argument_list|,
name|session
argument_list|,
name|steal_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|func
argument_list|(
name|session
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra__release_operational_lock
argument_list|(
name|session
argument_list|,
name|SVNSYNC_PROP_LOCK
argument_list|,
name|lock_string
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Callback function for the RA session's open_tmp_file()  * requirements.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_tmp_file
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_io_open_unique_file3
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return SVN_NO_ERROR iff URL identifies the root directory of the  * repository associated with RA session SESS.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_if_session_is_at_repos_root
parameter_list|(
name|svn_ra_session_t
modifier|*
name|sess
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sess_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|sess
argument_list|,
operator|&
name|sess_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|url
argument_list|,
name|sess_root
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Session is rooted at '%s' but the repos root is '%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|sess_root
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove the properties in TARGET_PROPS but not in SOURCE_PROPS from  * revision REV of the repository associated with RA session SESSION.  *  * For REV zero, don't remove properties with the "svn:sync-" prefix.  *  * All allocations will be done in a subpool of POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_props_not_in_source
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|source_props
parameter_list|,
name|apr_hash_t
modifier|*
name|target_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|target_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
literal|0
operator|&&
operator|!
name|strncmp
argument_list|(
name|propname
argument_list|,
name|SVNSYNC_PROP_PREFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|SVNSYNC_PROP_PREFIX
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
continue|continue;
comment|/* Delete property if the name can't be found in SOURCE_PROPS. */
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|source_props
argument_list|,
name|propname
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|session
argument_list|,
name|rev
argument_list|,
name|propname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Filter callback function.  * Takes a property name KEY, and is expected to return TRUE if the property  * should be filtered out (ie. not be copied to the target list), or FALSE if  * not.  */
end_comment

begin_typedef
typedef|typedef
name|svn_boolean_t
function_decl|(
modifier|*
name|filter_func_t
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Make a new set of properties, by copying those properties in PROPS for which  * the filter FILTER returns FALSE.  *  * The number of properties not copied will be stored in FILTERED_COUNT.  *  * The returned set of properties is allocated from POOL.  */
end_comment

begin_function
specifier|static
name|apr_hash_t
modifier|*
name|filter_props
parameter_list|(
name|int
modifier|*
name|filtered_count
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|filter_func_t
name|filter
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|filtered
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
operator|*
name|filtered_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|void
modifier|*
name|propval
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
comment|/* Copy all properties:           - not matching the exclude pattern if provided OR           - matching the include pattern if provided */
if|if
condition|(
operator|!
name|filter
operator|||
operator|!
name|filter
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|filtered
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|filtered_count
operator|+=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|filtered
return|;
block|}
end_function

begin_comment
comment|/* Write the set of revision properties REV_PROPS to revision REV to the  * repository associated with RA session SESSION.  * Omit any properties whose names are in the svnsync property name space,  * and set *FILTERED_COUNT to the number of properties thus omitted.  * REV_PROPS is a hash mapping (char *)propname to (svn_string_t *)propval.  *  * All allocations will be done in a subpool of POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revprops
parameter_list|(
name|int
modifier|*
name|filtered_count
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
operator|*
name|filtered_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|rev_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|propval
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|propname
argument_list|,
name|SVNSYNC_PROP_PREFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|SVNSYNC_PROP_PREFIX
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|session
argument_list|,
name|rev
argument_list|,
name|propname
argument_list|,
name|NULL
argument_list|,
name|propval
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|filtered_count
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_properties_copied
parameter_list|(
name|svn_boolean_t
name|syncprops_found
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|syncprops_found
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Copied properties for revision %ld "
literal|"(%s* properties skipped).\n"
argument_list|)
argument_list|,
name|rev
argument_list|,
name|SVNSYNC_PROP_PREFIX
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Copied properties for revision %ld.\n"
argument_list|)
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print a notification that NORMALIZED_REV_PROPS_COUNT rev-props and  * NORMALIZED_NODE_PROPS_COUNT node-props were normalized to LF line  * endings, if either of those numbers is non-zero. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_properties_normalized
parameter_list|(
name|int
name|normalized_rev_props_count
parameter_list|,
name|int
name|normalized_node_props_count
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|normalized_rev_props_count
operator|>
literal|0
operator|||
name|normalized_node_props_count
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"NOTE: Normalized %s* properties "
literal|"to LF line endings (%d rev-props, "
literal|"%d node-props).\n"
argument_list|)
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|normalized_rev_props_count
argument_list|,
name|normalized_node_props_count
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy all the revision properties, except for those that have the  * "svn:sync-" prefix, from revision REV of the repository associated  * with RA session FROM_SESSION, to the repository associated with RA  * session TO_SESSION.  *  * If SYNC is TRUE, then properties on the destination revision that  * do not exist on the source revision will be removed.  *  * If QUIET is FALSE, then log_properties_copied() is called to log that  * properties were copied for revision REV.  *  * Make sure the values of svn:* revision properties use only LF (\n)  * line ending style, correcting their values as necessary. The number  * of properties that were normalized is returned in *NORMALIZED_COUNT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_revprops
parameter_list|(
name|svn_ra_session_t
modifier|*
name|from_session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|to_session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_boolean_t
name|sync
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
specifier|const
name|char
modifier|*
name|source_prop_encoding
parameter_list|,
name|int
modifier|*
name|normalized_count
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|existing_props
decl_stmt|,
modifier|*
name|rev_props
decl_stmt|;
name|int
name|filtered_count
init|=
literal|0
decl_stmt|;
comment|/* Get the list of revision properties on REV of TARGET. We're only interested      in the property names, but we'll get the values 'for free'. */
if|if
condition|(
name|sync
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_rev_proplist
argument_list|(
name|to_session
argument_list|,
name|rev
argument_list|,
operator|&
name|existing_props
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|existing_props
operator|=
name|NULL
expr_stmt|;
comment|/* Get the list of revision properties on REV of SOURCE. */
name|SVN_ERR
argument_list|(
name|svn_ra_rev_proplist
argument_list|(
name|from_session
argument_list|,
name|rev
argument_list|,
operator|&
name|rev_props
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If necessary, normalize encoding and line ending style and return the count      of EOL-normalized properties in int *NORMALIZED_COUNT. */
name|SVN_ERR
argument_list|(
name|svnsync_normalize_revprops
argument_list|(
name|rev_props
argument_list|,
name|normalized_count
argument_list|,
name|source_prop_encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy all but the svn:svnsync properties. */
name|SVN_ERR
argument_list|(
name|write_revprops
argument_list|(
operator|&
name|filtered_count
argument_list|,
name|to_session
argument_list|,
name|rev
argument_list|,
name|rev_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete those properties that were in TARGET but not in SOURCE */
if|if
condition|(
name|sync
condition|)
name|SVN_ERR
argument_list|(
name|remove_props_not_in_source
argument_list|(
name|to_session
argument_list|,
name|rev
argument_list|,
name|rev_props
argument_list|,
name|existing_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|log_properties_copied
argument_list|(
name|filtered_count
operator|>
literal|0
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a subcommand baton allocated from POOL and populated with    data from the provided parameters, which include the global    OPT_BATON options structure and a handful of other options.  Not    all parameters are used in all subcommands -- see    subcommand_baton_t's definition for details. */
end_comment

begin_function
specifier|static
name|subcommand_baton_t
modifier|*
name|make_subcommand_baton
parameter_list|(
name|opt_baton_t
modifier|*
name|opt_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|to_url
parameter_list|,
specifier|const
name|char
modifier|*
name|from_url
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|subcommand_baton_t
modifier|*
name|b
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|b
operator|->
name|config
operator|=
name|opt_baton
operator|->
name|config
expr_stmt|;
name|b
operator|->
name|source_callbacks
operator|.
name|open_tmp_file
operator|=
name|open_tmp_file
expr_stmt|;
name|b
operator|->
name|source_callbacks
operator|.
name|auth_baton
operator|=
name|opt_baton
operator|->
name|source_auth_baton
expr_stmt|;
name|b
operator|->
name|sync_callbacks
operator|.
name|open_tmp_file
operator|=
name|open_tmp_file
expr_stmt|;
name|b
operator|->
name|sync_callbacks
operator|.
name|auth_baton
operator|=
name|opt_baton
operator|->
name|sync_auth_baton
expr_stmt|;
name|b
operator|->
name|quiet
operator|=
name|opt_baton
operator|->
name|quiet
expr_stmt|;
name|b
operator|->
name|allow_non_empty
operator|=
name|opt_baton
operator|->
name|allow_non_empty
expr_stmt|;
name|b
operator|->
name|to_url
operator|=
name|to_url
expr_stmt|;
name|b
operator|->
name|source_prop_encoding
operator|=
name|opt_baton
operator|->
name|source_prop_encoding
expr_stmt|;
name|b
operator|->
name|from_url
operator|=
name|from_url
expr_stmt|;
name|b
operator|->
name|start_rev
operator|=
name|start_rev
expr_stmt|;
name|b
operator|->
name|end_rev
operator|=
name|end_rev
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|open_target_session
parameter_list|(
name|svn_ra_session_t
modifier|*
modifier|*
name|to_session_p
parameter_list|,
name|subcommand_baton_t
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*** `svnsync init' ***/
end_comment

begin_comment
comment|/* Initialize the repository associated with RA session TO_SESSION,  * using information found in BATON.  *  * Implements `with_locked_func_t' interface.  The caller has  * acquired a lock on the repository if locking is needed.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_initialize
parameter_list|(
name|svn_ra_session_t
modifier|*
name|to_session
parameter_list|,
name|subcommand_baton_t
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|from_session
decl_stmt|;
name|svn_string_t
modifier|*
name|from_url
decl_stmt|;
name|svn_revnum_t
name|latest
decl_stmt|,
name|from_latest
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|,
modifier|*
name|root_url
decl_stmt|;
name|int
name|normalized_rev_props_count
decl_stmt|;
comment|/* First, sanity check to see that we're copying into a brand new      repos.  If we aren't, and we aren't being asked to forcibly      complete this initialization, that's a bad news.  */
name|SVN_ERR
argument_list|(
name|svn_ra_get_latest_revnum
argument_list|(
name|to_session
argument_list|,
operator|&
name|latest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|latest
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|baton
operator|->
name|allow_non_empty
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination repository already contains revision history; consider "
literal|"using --allow-non-empty if the repository's revisions are known "
literal|"to mirror their respective revisions in the source repository"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_rev_prop
argument_list|(
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_FROM_URL
argument_list|,
operator|&
name|from_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_url
operator|&&
operator|(
operator|!
name|baton
operator|->
name|allow_non_empty
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination repository is already synchronizing from '%s'"
argument_list|)
argument_list|,
name|from_url
operator|->
name|data
argument_list|)
return|;
comment|/* Now fill in our bookkeeping info in the dest repository. */
name|SVN_ERR
argument_list|(
name|svn_ra_open4
argument_list|(
operator|&
name|from_session
argument_list|,
name|NULL
argument_list|,
name|baton
operator|->
name|from_url
argument_list|,
name|NULL
argument_list|,
operator|&
operator|(
name|baton
operator|->
name|source_callbacks
operator|)
argument_list|,
name|baton
argument_list|,
name|baton
operator|->
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|from_session
argument_list|,
operator|&
name|root_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're doing a partial replay, we have to check first if the server      supports this. */
if|if
condition|(
name|strcmp
argument_list|(
name|root_url
argument_list|,
name|baton
operator|->
name|from_url
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|svn_boolean_t
name|server_supports_partial_replay
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_ra_has_capability
argument_list|(
name|from_session
argument_list|,
operator|&
name|server_supports_partial_replay
argument_list|,
name|SVN_RA_CAPABILITY_PARTIAL_REPLAY
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_UNKNOWN_CAPABILITY
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
name|err
operator|||
operator|!
name|server_supports_partial_replay
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_PARTIAL_REPLAY_NOT_SUPPORTED
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* If we're initializing a non-empty destination, we'll make sure      that it at least doesn't have more revisions than the source. */
if|if
condition|(
name|latest
operator|!=
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_latest_revnum
argument_list|(
name|from_session
argument_list|,
operator|&
name|from_latest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_latest
operator|<
name|latest
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination repository has more revisions than source "
literal|"repository"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_FROM_URL
argument_list|,
name|NULL
argument_list|,
name|svn_string_create
argument_list|(
name|baton
operator|->
name|from_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_uuid2
argument_list|(
name|from_session
argument_list|,
operator|&
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_FROM_UUID
argument_list|,
name|NULL
argument_list|,
name|svn_string_create
argument_list|(
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_LAST_MERGED_REV
argument_list|,
name|NULL
argument_list|,
name|svn_string_createf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|latest
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy all non-svnsync revprops from the LATEST rev in the source      repository into the destination, notifying about normalized      props, if any.  When LATEST is 0, this serves the practical      purpose of initializing data that would otherwise be overlooked      by the sync process (which is going to begin with r1).  When      LATEST is not 0, this really serves merely aesthetic and      informational purposes, keeping the output of this command      consistent while allowing folks to see what the latest revision is.  */
name|SVN_ERR
argument_list|(
name|copy_revprops
argument_list|(
name|from_session
argument_list|,
name|to_session
argument_list|,
name|latest
argument_list|,
name|FALSE
argument_list|,
name|baton
operator|->
name|quiet
argument_list|,
name|baton
operator|->
name|source_prop_encoding
argument_list|,
operator|&
name|normalized_rev_props_count
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_properties_normalized
argument_list|(
name|normalized_rev_props_count
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: It would be nice if we could set the dest repos UUID to be      equal to the UUID of the source repos, at least optionally.  That      way people could check out/log/diff using a local fast mirror,      but switch --relocate to the actual final repository in order to      make changes...  But at this time, the RA layer doesn't have a      way to set a UUID. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* SUBCOMMAND: init */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|initialize_cmd
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|to_url
decl_stmt|,
modifier|*
name|from_url
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|to_session
decl_stmt|;
name|opt_baton_t
modifier|*
name|opt_baton
init|=
name|b
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|subcommand_baton_t
modifier|*
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt__args_to_target_array
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|<
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
name|to_url
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|from_url
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|to_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a URL"
argument_list|)
argument_list|,
name|to_url
argument_list|)
return|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|from_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a URL"
argument_list|)
argument_list|,
name|from_url
argument_list|)
return|;
name|baton
operator|=
name|make_subcommand_baton
argument_list|(
name|opt_baton
argument_list|,
name|to_url
argument_list|,
name|from_url
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_target_session
argument_list|(
operator|&
name|to_session
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_baton
operator|->
name|disable_locking
condition|)
name|SVN_ERR
argument_list|(
name|do_initialize
argument_list|(
name|to_session
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|with_locked
argument_list|(
name|to_session
argument_list|,
name|do_initialize
argument_list|,
name|baton
argument_list|,
name|opt_baton
operator|->
name|steal_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** `svnsync sync' ***/
end_comment

begin_comment
comment|/* Implements `svn_commit_callback2_t' interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit_callback
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|subcommand_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|sb
operator|->
name|quiet
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Committed revision %ld.\n"
argument_list|)
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|->
name|committed_rev
operator|=
name|commit_info
operator|->
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *FROM_SESSION to an RA session associated with the source  * repository of the synchronization.  If FROM_URL is non-NULL, use it  * as the source repository URL; otherwise, determine the source  * repository URL by reading svn:sync- properties from the destination  * repository (associated with TO_SESSION).  Set LAST_MERGED_REV to  * the value of the property which records the most recently  * synchronized revision.  *  * CALLBACKS is a vtable of RA callbacks to provide when creating  * *FROM_SESSION.  CONFIG is a configuration hash.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_source_session
parameter_list|(
name|svn_ra_session_t
modifier|*
modifier|*
name|from_session
parameter_list|,
name|svn_string_t
modifier|*
modifier|*
name|last_merged_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|from_url
parameter_list|,
name|svn_ra_session_t
modifier|*
name|to_session
parameter_list|,
name|svn_ra_callbacks2_t
modifier|*
name|callbacks
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_string_t
modifier|*
name|from_url_str
decl_stmt|,
modifier|*
name|from_uuid_str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_rev_proplist
argument_list|(
name|to_session
argument_list|,
literal|0
argument_list|,
operator|&
name|props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|from_url_str
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVNSYNC_PROP_FROM_URL
argument_list|)
expr_stmt|;
name|from_uuid_str
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVNSYNC_PROP_FROM_UUID
argument_list|)
expr_stmt|;
operator|*
name|last_merged_rev
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVNSYNC_PROP_LAST_MERGED_REV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_url_str
operator|||
operator|!
name|from_uuid_str
operator|||
operator|!
operator|*
name|last_merged_rev
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination repository has not been initialized"
argument_list|)
argument_list|)
return|;
comment|/* ### TODO: Should we validate that FROM_URL_STR->data matches any      provided FROM_URL here?  */
if|if
condition|(
operator|!
name|from_url
condition|)
name|SVN_ERR
argument_list|(
name|svn_opt__arg_canonicalize_url
argument_list|(
operator|&
name|from_url
argument_list|,
name|from_url_str
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open the session to copy the revision data. */
name|SVN_ERR
argument_list|(
name|svn_ra_open4
argument_list|(
name|from_session
argument_list|,
name|NULL
argument_list|,
name|from_url
argument_list|,
name|from_uuid_str
operator|->
name|data
argument_list|,
name|callbacks
argument_list|,
name|baton
argument_list|,
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *TARGET_SESSION_P to an RA session associated with the target  * repository of the synchronization.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_target_session
parameter_list|(
name|svn_ra_session_t
modifier|*
modifier|*
name|target_session_p
parameter_list|,
name|subcommand_baton_t
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|target_session
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_open4
argument_list|(
operator|&
name|target_session
argument_list|,
name|NULL
argument_list|,
name|baton
operator|->
name|to_url
argument_list|,
name|NULL
argument_list|,
operator|&
operator|(
name|baton
operator|->
name|sync_callbacks
operator|)
argument_list|,
name|baton
argument_list|,
name|baton
operator|->
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_if_session_is_at_repos_root
argument_list|(
name|target_session
argument_list|,
name|baton
operator|->
name|to_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|target_session_p
operator|=
name|target_session
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Replay baton, used during synchronization. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|replay_baton_t
block|{
name|svn_ra_session_t
modifier|*
name|from_session
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|to_session
decl_stmt|;
name|svn_revnum_t
name|current_revision
decl_stmt|;
name|subcommand_baton_t
modifier|*
name|sb
decl_stmt|;
name|svn_boolean_t
name|has_commit_revprops_capability
decl_stmt|;
name|svn_boolean_t
name|has_atomic_revprops_capability
decl_stmt|;
name|int
name|normalized_rev_props_count
decl_stmt|;
name|int
name|normalized_node_props_count
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_root
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_EV2_SHIMS
comment|/* Extra 'backdoor' session for fetching data *from* the target repo. */
name|svn_ra_session_t
modifier|*
name|extra_to_session
decl_stmt|;
endif|#
directive|endif
block|}
name|replay_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Return a replay baton allocated from POOL and populated with    data from the provided parameters. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_replay_baton
parameter_list|(
name|replay_baton_t
modifier|*
modifier|*
name|baton_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|from_session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|to_session
parameter_list|,
name|subcommand_baton_t
modifier|*
name|sb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|replay_baton_t
modifier|*
name|rb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rb
argument_list|)
argument_list|)
decl_stmt|;
name|rb
operator|->
name|from_session
operator|=
name|from_session
expr_stmt|;
name|rb
operator|->
name|to_session
operator|=
name|to_session
expr_stmt|;
name|rb
operator|->
name|sb
operator|=
name|sb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|to_session
argument_list|,
operator|&
name|rb
operator|->
name|to_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_EV2_SHIMS
comment|/* Open up the extra baton.  Only needed for Ev2 shims. */
name|SVN_ERR
argument_list|(
name|open_target_session
argument_list|(
operator|&
name|rb
operator|->
name|extra_to_session
argument_list|,
name|sb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|baton_p
operator|=
name|rb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff KEY is the name of an svn:date or svn:author or any svnsync  * property. Implements filter_func_t. Use with filter_props() to filter out  * svn:date and svn:author and svnsync properties.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|filter_exclude_date_author_sync
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|key
argument_list|,
name|SVNSYNC_PROP_PREFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|SVNSYNC_PROP_PREFIX
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return FALSE iff KEY is the name of an svn:date or svn:author or any svnsync  * property. Implements filter_func_t. Use with filter_props() to filter out  * all properties except svn:date and svn:author and svnsync properties.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|filter_include_date_author_sync
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
return|return
operator|!
name|filter_exclude_date_author_sync
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff KEY is the name of the svn:log property.  * Implements filter_func_t. Use with filter_props() to only exclude svn:log.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|filter_exclude_log
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return FALSE iff KEY is the name of the svn:log property.  * Implements filter_func_t. Use with filter_props() to only include svn:log.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|filter_include_log
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
return|return
operator|!
name|filter_exclude_log
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_EV2_SHIMS
end_ifdef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|replay_baton_t
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|fstream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
name|path
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|rb
operator|->
name|to_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|path
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|rb
operator|->
name|current_revision
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|fstream
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_get_file
argument_list|(
name|rb
operator|->
name|extra_to_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|fstream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|replay_baton_t
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
name|path
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|rb
operator|->
name|to_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|path
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|rb
operator|->
name|current_revision
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|rb
operator|->
name|extra_to_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
operator|&
name|node_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|rb
operator|->
name|extra_to_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_array_header_t
modifier|*
name|tmp_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|rb
operator|->
name|extra_to_session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
literal|0
comment|/* Dirent fields */
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_props
operator|=
name|svn_prop_hash_to_array
argument_list|(
operator|*
name|props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|tmp_props
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|replay_baton_t
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
name|path
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|rb
operator|->
name|to_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|path
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|rb
operator|->
name|current_revision
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|rb
operator|->
name|extra_to_session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_delta_shim_callbacks_t
modifier|*
name|get_shim_callbacks
parameter_list|(
name|replay_baton_t
modifier|*
name|rb
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_baton
operator|=
name|rb
expr_stmt|;
return|return
name|callbacks
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Callback function for svn_ra_replay_range, invoked when starting to parse  * a replay report.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_rev_started
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|commit_editor
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|cancel_editor
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|sync_editor
decl_stmt|;
name|void
modifier|*
name|commit_baton
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
name|void
modifier|*
name|sync_baton
decl_stmt|;
name|replay_baton_t
modifier|*
name|rb
init|=
name|replay_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|filtered
decl_stmt|;
name|int
name|filtered_count
decl_stmt|;
name|int
name|normalized_count
decl_stmt|;
comment|/* We set this property so that if we error out for some reason      we can later determine where we were in the process of      merging a revision.  If we had committed the change, but we      hadn't finished copying the revprops we need to know that, so      we can go back and finish the job before we move on.       NOTE: We have to set this before we start the commit editor,      because ra_svn doesn't let you change rev props during a      commit. */
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|rb
operator|->
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_CURRENTLY_COPYING
argument_list|,
name|NULL
argument_list|,
name|svn_string_createf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|revision
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The actual copy is just a replay hooked up to a commit.  Include      all the revision properties from the source repositories, except      'svn:author' and 'svn:date', those are not guaranteed to get      through the editor anyway.      If we're syncing to an non-commit-revprops capable server, filter      out all revprops except svn:log and add them later in      revplay_rev_finished. */
name|filtered
operator|=
name|filter_props
argument_list|(
operator|&
name|filtered_count
argument_list|,
name|rev_props
argument_list|,
operator|(
name|rb
operator|->
name|has_commit_revprops_capability
condition|?
name|filter_exclude_date_author_sync
else|:
name|filter_include_log
operator|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* svn_ra_get_commit_editor3 requires the log message to be      set. It's possible that we didn't receive 'svn:log' here, so we      have to set it to at least the empty string. If there's a svn:log      property on this revision, we will write the actual value in the      replay_rev_finished callback. */
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|filtered
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|filtered
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|svn_string_create_empty
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If necessary, normalize encoding and line ending style. Add the number      of properties that required EOL normalization to the overall count      in the replay baton. */
name|SVN_ERR
argument_list|(
name|svnsync_normalize_revprops
argument_list|(
name|filtered
argument_list|,
operator|&
name|normalized_count
argument_list|,
name|rb
operator|->
name|sb
operator|->
name|source_prop_encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|normalized_rev_props_count
operator|+=
name|normalized_count
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_EV2_SHIMS
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|rb
operator|->
name|to_session
argument_list|,
name|get_shim_callbacks
argument_list|(
name|rb
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|rb
operator|->
name|to_session
argument_list|,
operator|&
name|commit_editor
argument_list|,
operator|&
name|commit_baton
argument_list|,
name|filtered
argument_list|,
name|commit_callback
argument_list|,
name|rb
operator|->
name|sb
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There's one catch though, the diff shows us props we can't send      over the RA interface, so we need an editor that's smart enough      to filter those out for us.  */
name|SVN_ERR
argument_list|(
name|svnsync_get_sync_editor
argument_list|(
name|commit_editor
argument_list|,
name|commit_baton
argument_list|,
name|revision
operator|-
literal|1
argument_list|,
name|rb
operator|->
name|sb
operator|->
name|to_url
argument_list|,
name|rb
operator|->
name|sb
operator|->
name|source_prop_encoding
argument_list|,
name|rb
operator|->
name|sb
operator|->
name|quiet
argument_list|,
operator|&
name|sync_editor
argument_list|,
operator|&
name|sync_baton
argument_list|,
operator|&
operator|(
name|rb
operator|->
name|normalized_node_props_count
operator|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta_get_cancellation_editor
argument_list|(
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|sync_editor
argument_list|,
name|sync_baton
argument_list|,
operator|&
name|cancel_editor
argument_list|,
operator|&
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|editor
operator|=
name|cancel_editor
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|cancel_baton
expr_stmt|;
name|rb
operator|->
name|current_revision
operator|=
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Callback function for svn_ra_replay_range, invoked when finishing parsing  * a replay report.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_rev_finished
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|replay_baton_t
modifier|*
name|rb
init|=
name|replay_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|filtered
decl_stmt|,
modifier|*
name|existing_props
decl_stmt|;
name|int
name|filtered_count
decl_stmt|;
name|int
name|normalized_count
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|rev_str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sanity check that we actually committed the revision we meant to. */
if|if
condition|(
name|rb
operator|->
name|sb
operator|->
name|committed_rev
operator|!=
name|revision
condition|)
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Commit created r%ld but should have created r%ld"
argument_list|)
argument_list|,
name|rb
operator|->
name|sb
operator|->
name|committed_rev
argument_list|,
name|revision
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_rev_proplist
argument_list|(
name|rb
operator|->
name|to_session
argument_list|,
name|revision
argument_list|,
operator|&
name|existing_props
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we're done with the data, now we just need to copy the remaining      'svn:date' and 'svn:author' revprops and we're all set.      If the server doesn't support revprops-in-a-commit, we still have to      set all revision properties except svn:log. */
name|filtered
operator|=
name|filter_props
argument_list|(
operator|&
name|filtered_count
argument_list|,
name|rev_props
argument_list|,
operator|(
name|rb
operator|->
name|has_commit_revprops_capability
condition|?
name|filter_include_date_author_sync
else|:
name|filter_exclude_log
operator|)
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* If necessary, normalize encoding and line ending style, and add the number      of EOL-normalized properties to the overall count in the replay baton. */
name|SVN_ERR
argument_list|(
name|svnsync_normalize_revprops
argument_list|(
name|filtered
argument_list|,
operator|&
name|normalized_count
argument_list|,
name|rb
operator|->
name|sb
operator|->
name|source_prop_encoding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|normalized_rev_props_count
operator|+=
name|normalized_count
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_revprops
argument_list|(
operator|&
name|filtered_count
argument_list|,
name|rb
operator|->
name|to_session
argument_list|,
name|revision
argument_list|,
name|filtered
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove all extra properties in TARGET. */
name|SVN_ERR
argument_list|(
name|remove_props_not_in_source
argument_list|(
name|rb
operator|->
name|to_session
argument_list|,
name|revision
argument_list|,
name|rev_props
argument_list|,
name|existing_props
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|rev_str
operator|=
name|svn_string_createf
argument_list|(
name|subpool
argument_list|,
literal|"%ld"
argument_list|,
name|revision
argument_list|)
expr_stmt|;
comment|/* Ok, we're done, bring the last-merged-rev property up to date. */
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|rb
operator|->
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_LAST_MERGED_REV
argument_list|,
name|NULL
argument_list|,
name|rev_str
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And finally drop the currently copying prop, since we're done      with this revision. */
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|rb
operator|->
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_CURRENTLY_COPYING
argument_list|,
name|rb
operator|->
name|has_atomic_revprops_capability
condition|?
operator|&
name|rev_str
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notify the user that we copied revision properties. */
if|if
condition|(
operator|!
name|rb
operator|->
name|sb
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|log_properties_copied
argument_list|(
name|filtered_count
operator|>
literal|0
argument_list|,
name|revision
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Synchronize the repository associated with RA session TO_SESSION,  * using information found in BATON.  *  * Implements `with_locked_func_t' interface.  The caller has  * acquired a lock on the repository if locking is needed.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_synchronize
parameter_list|(
name|svn_ra_session_t
modifier|*
name|to_session
parameter_list|,
name|subcommand_baton_t
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|last_merged_rev
decl_stmt|;
name|svn_revnum_t
name|from_latest
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|from_session
decl_stmt|;
name|svn_string_t
modifier|*
name|currently_copying
decl_stmt|;
name|svn_revnum_t
name|to_latest
decl_stmt|,
name|copying
decl_stmt|,
name|last_merged
decl_stmt|;
name|svn_revnum_t
name|start_revision
decl_stmt|,
name|end_revision
decl_stmt|;
name|replay_baton_t
modifier|*
name|rb
decl_stmt|;
name|int
name|normalized_rev_props_count
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_source_session
argument_list|(
operator|&
name|from_session
argument_list|,
operator|&
name|last_merged_rev
argument_list|,
name|baton
operator|->
name|from_url
argument_list|,
name|to_session
argument_list|,
operator|&
operator|(
name|baton
operator|->
name|source_callbacks
operator|)
argument_list|,
name|baton
operator|->
name|config
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if we have revprops that still need to be copied for      a prior revision we didn't finish copying.  But first, check for      state sanity.  Remember, mirroring is not an atomic action,      because revision properties are copied separately from the      revision's contents.       So, any time that currently-copying is not set, then      last-merged-rev should be the HEAD revision of the destination      repository.  That is, if we didn't fall over in the middle of a      previous synchronization, then our destination repository should      have exactly as many revisions in it as we've synchronized.       Alternately, if currently-copying *is* set, it must      be either last-merged-rev or last-merged-rev + 1, and the HEAD      revision must be equal to either last-merged-rev or      currently-copying. If this is not the case, somebody has meddled      with the destination without using svnsync.   */
name|SVN_ERR
argument_list|(
name|svn_ra_rev_prop
argument_list|(
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_CURRENTLY_COPYING
argument_list|,
operator|&
name|currently_copying
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_latest_revnum
argument_list|(
name|to_session
argument_list|,
operator|&
name|to_latest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|last_merged
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|last_merged_rev
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|currently_copying
condition|)
block|{
name|copying
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|currently_copying
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|copying
operator|<
name|last_merged
operator|)
operator|||
operator|(
name|copying
operator|>
operator|(
name|last_merged
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|to_latest
operator|!=
name|last_merged
operator|)
operator|&&
operator|(
name|to_latest
operator|!=
name|copying
operator|)
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision being currently copied (%ld), last merged revision "
literal|"(%ld), and destination HEAD (%ld) are inconsistent; have you "
literal|"committed to the destination without using svnsync?"
argument_list|)
argument_list|,
name|copying
argument_list|,
name|last_merged
argument_list|,
name|to_latest
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|copying
operator|==
name|to_latest
condition|)
block|{
if|if
condition|(
name|copying
operator|>
name|last_merged
condition|)
block|{
name|SVN_ERR
argument_list|(
name|copy_revprops
argument_list|(
name|from_session
argument_list|,
name|to_session
argument_list|,
name|to_latest
argument_list|,
name|TRUE
argument_list|,
name|baton
operator|->
name|quiet
argument_list|,
name|baton
operator|->
name|source_prop_encoding
argument_list|,
operator|&
name|normalized_rev_props_count
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|last_merged
operator|=
name|copying
expr_stmt|;
name|last_merged_rev
operator|=
name|svn_string_create
argument_list|(
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|last_merged
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Now update last merged rev and drop currently changing.              Note that the order here is significant, if we do them              in the wrong order there are race conditions where we              end up not being able to tell if there have been bogus              (i.e. non-svnsync) commits to the dest repository. */
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_LAST_MERGED_REV
argument_list|,
name|NULL
argument_list|,
name|last_merged_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|to_session
argument_list|,
literal|0
argument_list|,
name|SVNSYNC_PROP_CURRENTLY_COPYING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If copying> to_latest, then we just fall through to          attempting to copy the revision again. */
block|}
else|else
block|{
if|if
condition|(
name|to_latest
operator|!=
name|last_merged
condition|)
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination HEAD (%ld) is not the last "
literal|"merged revision (%ld); have you "
literal|"committed to the destination without "
literal|"using svnsync?"
argument_list|)
argument_list|,
name|to_latest
argument_list|,
name|last_merged
argument_list|)
return|;
block|}
comment|/* Now check to see if there are any revisions to copy. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_latest_revnum
argument_list|(
name|from_session
argument_list|,
operator|&
name|from_latest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_latest
operator|<
name|last_merged
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Ok, so there are new revisions, iterate over them copying them      into the destination repository. */
name|SVN_ERR
argument_list|(
name|make_replay_baton
argument_list|(
operator|&
name|rb
argument_list|,
name|from_session
argument_list|,
name|to_session
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For compatibility with older svnserve versions, check first if we      support adding revprops to the commit. */
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|rb
operator|->
name|to_session
argument_list|,
operator|&
name|rb
operator|->
name|has_commit_revprops_capability
argument_list|,
name|SVN_RA_CAPABILITY_COMMIT_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|rb
operator|->
name|to_session
argument_list|,
operator|&
name|rb
operator|->
name|has_atomic_revprops_capability
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|start_revision
operator|=
name|last_merged
operator|+
literal|1
expr_stmt|;
name|end_revision
operator|=
name|from_latest
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_replay_range
argument_list|(
name|from_session
argument_list|,
name|start_revision
argument_list|,
name|end_revision
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|replay_rev_started
argument_list|,
name|replay_rev_finished
argument_list|,
name|rb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_properties_normalized
argument_list|(
name|rb
operator|->
name|normalized_rev_props_count
operator|+
name|normalized_rev_props_count
argument_list|,
name|rb
operator|->
name|normalized_node_props_count
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* SUBCOMMAND: sync */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|synchronize_cmd
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|to_session
decl_stmt|;
name|opt_baton_t
modifier|*
name|opt_baton
init|=
name|b
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|subcommand_baton_t
modifier|*
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_url
decl_stmt|,
modifier|*
name|from_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt__args_to_target_array
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|<
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
name|to_url
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|to_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a URL"
argument_list|)
argument_list|,
name|to_url
argument_list|)
return|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|2
condition|)
block|{
name|from_url
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|from_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a URL"
argument_list|)
argument_list|,
name|from_url
argument_list|)
return|;
block|}
else|else
block|{
name|from_url
operator|=
name|NULL
expr_stmt|;
comment|/* we'll read it from the destination repos */
block|}
name|baton
operator|=
name|make_subcommand_baton
argument_list|(
name|opt_baton
argument_list|,
name|to_url
argument_list|,
name|from_url
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_target_session
argument_list|(
operator|&
name|to_session
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_baton
operator|->
name|disable_locking
condition|)
name|SVN_ERR
argument_list|(
name|do_synchronize
argument_list|(
name|to_session
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|with_locked
argument_list|(
name|to_session
argument_list|,
name|do_synchronize
argument_list|,
name|baton
argument_list|,
name|opt_baton
operator|->
name|steal_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** `svnsync copy-revprops' ***/
end_comment

begin_comment
comment|/* Copy revision properties to the repository associated with RA  * session TO_SESSION, using information found in BATON.  *  * Implements `with_locked_func_t' interface.  The caller has  * acquired a lock on the repository if locking is needed.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_copy_revprops
parameter_list|(
name|svn_ra_session_t
modifier|*
name|to_session
parameter_list|,
name|subcommand_baton_t
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|from_session
decl_stmt|;
name|svn_string_t
modifier|*
name|last_merged_rev
decl_stmt|;
name|svn_revnum_t
name|i
decl_stmt|;
name|svn_revnum_t
name|step
init|=
literal|1
decl_stmt|;
name|int
name|normalized_rev_props_count
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_source_session
argument_list|(
operator|&
name|from_session
argument_list|,
operator|&
name|last_merged_rev
argument_list|,
name|baton
operator|->
name|from_url
argument_list|,
name|to_session
argument_list|,
operator|&
operator|(
name|baton
operator|->
name|source_callbacks
operator|)
argument_list|,
name|baton
operator|->
name|config
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* An invalid revision means "last-synced" */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|baton
operator|->
name|start_rev
argument_list|)
condition|)
name|baton
operator|->
name|start_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|last_merged_rev
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|baton
operator|->
name|end_rev
argument_list|)
condition|)
name|baton
operator|->
name|end_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|last_merged_rev
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Make sure we have revisions within the valid range. */
if|if
condition|(
name|baton
operator|->
name|start_rev
operator|>
name|SVN_STR_TO_REV
argument_list|(
name|last_merged_rev
operator|->
name|data
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot copy revprops for a revision (%ld) that has not "
literal|"been synchronized yet"
argument_list|)
argument_list|,
name|baton
operator|->
name|start_rev
argument_list|)
return|;
if|if
condition|(
name|baton
operator|->
name|end_rev
operator|>
name|SVN_STR_TO_REV
argument_list|(
name|last_merged_rev
operator|->
name|data
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|APR_EINVAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot copy revprops for a revision (%ld) that has not "
literal|"been synchronized yet"
argument_list|)
argument_list|,
name|baton
operator|->
name|end_rev
argument_list|)
return|;
comment|/* Now, copy all the requested revisions, in the requested order. */
name|step
operator|=
operator|(
name|baton
operator|->
name|start_rev
operator|>
name|baton
operator|->
name|end_rev
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|baton
operator|->
name|start_rev
init|;
name|i
operator|!=
name|baton
operator|->
name|end_rev
operator|+
name|step
condition|;
name|i
operator|=
name|i
operator|+
name|step
control|)
block|{
name|int
name|normalized_count
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_revprops
argument_list|(
name|from_session
argument_list|,
name|to_session
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|,
name|baton
operator|->
name|quiet
argument_list|,
name|baton
operator|->
name|source_prop_encoding
argument_list|,
operator|&
name|normalized_count
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|normalized_rev_props_count
operator|+=
name|normalized_count
expr_stmt|;
block|}
comment|/* Notify about normalized props, if any. */
name|SVN_ERR
argument_list|(
name|log_properties_normalized
argument_list|(
name|normalized_rev_props_count
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *START_REVNUM to the revision number associated with    START_REVISION, or to SVN_INVALID_REVNUM if START_REVISION    represents "HEAD"; if END_REVISION is specified, set END_REVNUM to    the revision number associated with END_REVISION or to    SVN_INVALID_REVNUM if END_REVISION represents "HEAD"; otherwise set    END_REVNUM to the same value as START_REVNUM.     As a special case, if neither START_REVISION nor END_REVISION is    specified, set *START_REVNUM to 0 and set *END_REVNUM to    SVN_INVALID_REVNUM.     Freak out if either START_REVISION or END_REVISION represents an    explicit but invalid revision number. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_revnums
parameter_list|(
name|svn_revnum_t
modifier|*
name|start_revnum
parameter_list|,
name|svn_revnum_t
modifier|*
name|end_revnum
parameter_list|,
name|svn_opt_revision_t
name|start_revision
parameter_list|,
name|svn_opt_revision_t
name|end_revision
parameter_list|)
block|{
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|;
comment|/* Special case: neither revision is specified?  This is like      -r0:HEAD. */
if|if
condition|(
operator|(
name|start_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|&&
operator|(
name|end_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
condition|)
block|{
operator|*
name|start_revnum
operator|=
literal|0
expr_stmt|;
operator|*
name|end_revnum
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Get the start revision, which must be either HEAD or a number      (which is required to be a valid one). */
if|if
condition|(
name|start_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_head
condition|)
block|{
name|start_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
name|start_rev
operator|=
name|start_revision
operator|.
name|value
operator|.
name|number
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision number (%ld)"
argument_list|)
argument_list|,
name|start_rev
argument_list|)
return|;
block|}
comment|/* Get the end revision, which must be unspecified (meaning,      "same as the start_rev"), HEAD, or a number (which is      required to be a valid one). */
if|if
condition|(
name|end_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
block|{
name|end_rev
operator|=
name|start_rev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_head
condition|)
block|{
name|end_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
name|end_rev
operator|=
name|end_revision
operator|.
name|value
operator|.
name|number
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision number (%ld)"
argument_list|)
argument_list|,
name|end_rev
argument_list|)
return|;
block|}
operator|*
name|start_revnum
operator|=
name|start_rev
expr_stmt|;
operator|*
name|end_revnum
operator|=
name|end_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* SUBCOMMAND: copy-revprops */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_revprops_cmd
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|to_session
decl_stmt|;
name|opt_baton_t
modifier|*
name|opt_baton
init|=
name|b
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|subcommand_baton_t
modifier|*
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_url
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_url
init|=
name|NULL
decl_stmt|;
name|svn_opt_revision_t
name|start_revision
decl_stmt|,
name|end_revision
decl_stmt|;
name|svn_revnum_t
name|start_rev
init|=
literal|0
decl_stmt|,
name|end_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* There should be either one or two arguments left to parse. */
if|if
condition|(
name|os
operator|->
name|argc
operator|-
name|os
operator|->
name|ind
operator|>
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|os
operator|->
name|argc
operator|-
name|os
operator|->
name|ind
operator|<
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* If there are two args, the last one is either a revision range or      the source URL.  */
if|if
condition|(
name|os
operator|->
name|argc
operator|-
name|os
operator|->
name|ind
operator|==
literal|2
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg_str
init|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|argc
operator|-
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|utf_arg_str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf_arg_str
argument_list|,
name|arg_str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|utf_arg_str
argument_list|)
condition|)
block|{
comment|/* This is the old "... TO_URL REV[:REV2]" syntax.              Revisions come only from this argument.  (We effectively              pop that last argument from the end of the argument list              so svn_opt__args_to_target_array() can do its thang.) */
name|os
operator|->
name|argc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|opt_baton
operator|->
name|start_rev
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
operator|)
operator|||
operator|(
name|opt_baton
operator|->
name|end_rev
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot specify revisions via both command-line arguments "
literal|"and the --revision (-r) option"
argument_list|)
argument_list|)
return|;
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
if|if
condition|(
name|svn_opt_parse_revision
argument_list|(
operator|&
name|start_revision
argument_list|,
operator|&
name|end_revision
argument_list|,
name|arg_str
argument_list|,
name|pool
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision range '%s' provided"
argument_list|)
argument_list|,
name|arg_str
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|resolve_revnums
argument_list|(
operator|&
name|start_rev
argument_list|,
operator|&
name|end_rev
argument_list|,
name|start_revision
argument_list|,
name|end_revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt__args_to_target_array
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|!=
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
name|to_url
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|from_url
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|to_url
condition|)
block|{
comment|/* This is the "... TO_URL SOURCE_URL" syntax.  Revisions          come only from the --revision parameter.  */
name|SVN_ERR
argument_list|(
name|resolve_revnums
argument_list|(
operator|&
name|start_rev
argument_list|,
operator|&
name|end_rev
argument_list|,
name|opt_baton
operator|->
name|start_rev
argument_list|,
name|opt_baton
operator|->
name|end_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt__args_to_target_array
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|<
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
name|to_url
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|2
condition|)
name|from_url
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
else|else
name|from_url
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|to_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a URL"
argument_list|)
argument_list|,
name|to_url
argument_list|)
return|;
if|if
condition|(
name|from_url
operator|&&
operator|(
operator|!
name|svn_path_is_url
argument_list|(
name|from_url
argument_list|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a URL"
argument_list|)
argument_list|,
name|from_url
argument_list|)
return|;
name|baton
operator|=
name|make_subcommand_baton
argument_list|(
name|opt_baton
argument_list|,
name|to_url
argument_list|,
name|from_url
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_target_session
argument_list|(
operator|&
name|to_session
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_baton
operator|->
name|disable_locking
condition|)
name|SVN_ERR
argument_list|(
name|do_copy_revprops
argument_list|(
name|to_session
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|with_locked
argument_list|(
name|to_session
argument_list|,
name|do_copy_revprops
argument_list|,
name|baton
argument_list|,
name|opt_baton
operator|->
name|steal_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** `svnsync info' ***/
end_comment

begin_comment
comment|/* SUBCOMMAND: info */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|info_cmd
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|to_session
decl_stmt|;
name|opt_baton_t
modifier|*
name|opt_baton
init|=
name|b
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|subcommand_baton_t
modifier|*
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_url
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_string_t
modifier|*
name|from_url
decl_stmt|,
modifier|*
name|from_uuid
decl_stmt|,
modifier|*
name|last_merged_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt__args_to_target_array
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|<
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Get the mirror repository URL, and verify that it is URL-ish. */
name|to_url
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|to_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a URL"
argument_list|)
argument_list|,
name|to_url
argument_list|)
return|;
comment|/* Open an RA session to the mirror repository URL. */
name|baton
operator|=
name|make_subcommand_baton
argument_list|(
name|opt_baton
argument_list|,
name|to_url
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_target_session
argument_list|(
operator|&
name|to_session
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_rev_proplist
argument_list|(
name|to_session
argument_list|,
literal|0
argument_list|,
operator|&
name|props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|from_url
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVNSYNC_PROP_FROM_URL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_url
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Repository '%s' is not initialized for synchronization"
argument_list|)
argument_list|,
name|to_url
argument_list|)
return|;
name|from_uuid
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVNSYNC_PROP_FROM_UUID
argument_list|)
expr_stmt|;
name|last_merged_rev
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVNSYNC_PROP_LAST_MERGED_REV
argument_list|)
expr_stmt|;
comment|/* Print the info. */
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Source URL: %s\n"
argument_list|)
argument_list|,
name|from_url
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_uuid
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Source Repository UUID: %s\n"
argument_list|)
argument_list|,
name|from_uuid
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_merged_rev
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Last Merged Revision: %s\n"
argument_list|)
argument_list|,
name|last_merged_rev
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** `svnsync help' ***/
end_comment

begin_comment
comment|/* SUBCOMMAND: help */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|help_cmd
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|opt_baton_t
modifier|*
name|opt_baton
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
init|=
name|_
argument_list|(
literal|"general usage: svnsync SUBCOMMAND DEST_URL  [ARGS& OPTIONS ...]\n"
literal|"Subversion repository replication tool.\n"
literal|"Type 'svnsync help<subcommand>' for help on a specific subcommand.\n"
literal|"Type 'svnsync --version' to see the program version and RA modules.\n"
literal|"\n"
literal|"Available subcommands:\n"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|ra_desc_start
init|=
name|_
argument_list|(
literal|"The following repository access (RA) modules are available:\n\n"
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|version_footer
init|=
name|svn_stringbuf_create
argument_list|(
name|ra_desc_start
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_print_modules
argument_list|(
name|version_footer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_print_help4
argument_list|(
name|os
argument_list|,
literal|"svnsync"
argument_list|,
name|opt_baton
condition|?
name|opt_baton
operator|->
name|version
else|:
name|FALSE
argument_list|,
name|opt_baton
condition|?
name|opt_baton
operator|->
name|quiet
else|:
name|FALSE
argument_list|,
comment|/*###opt_state ? opt_state->verbose :*/
name|FALSE
argument_list|,
name|version_footer
operator|->
name|data
argument_list|,
name|header
argument_list|,
name|svnsync_cmd_table
argument_list|,
name|svnsync_options
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Main ***/
end_comment

begin_comment
comment|/*  * On success, leave *EXIT_CODE untouched and return SVN_NO_ERROR. On error,  * either return an error to be displayed, or set *EXIT_CODE to non-zero and  * return SVN_NO_ERROR.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sub_main
parameter_list|(
name|int
modifier|*
name|exit_code
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|subcommand
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|received_opts
decl_stmt|;
name|opt_baton_t
name|opt_baton
decl_stmt|;
name|svn_config_t
modifier|*
name|config
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|opt_id
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
init|=
name|NULL
decl_stmt|,
modifier|*
name|source_username
init|=
name|NULL
decl_stmt|,
modifier|*
name|sync_username
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|,
modifier|*
name|source_password
init|=
name|NULL
decl_stmt|,
modifier|*
name|sync_password
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|config_options
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_prop_encoding
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|force_interactive
init|=
name|FALSE
decl_stmt|;
comment|/* Check library versions */
name|SVN_ERR
argument_list|(
name|check_lib_versions
argument_list|()
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_initialize
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the option baton. */
name|memset
argument_list|(
operator|&
name|opt_baton
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opt_baton
argument_list|)
argument_list|)
expr_stmt|;
name|opt_baton
operator|.
name|start_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_baton
operator|.
name|end_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|received_opts
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|SVN_OPT_MAX_OPTIONS
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline__getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|interleave
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
name|svn_error_t
modifier|*
name|opt_err
init|=
name|NULL
decl_stmt|;
name|apr_err
operator|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|svnsync_options
argument_list|,
operator|&
name|opt_id
argument_list|,
operator|&
name|opt_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|apr_err
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|apr_err
condition|)
block|{
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|received_opts
argument_list|,
name|int
argument_list|)
operator|=
name|opt_id
expr_stmt|;
switch|switch
condition|(
name|opt_id
condition|)
block|{
case|case
name|svnsync_opt_non_interactive
case|:
name|opt_baton
operator|.
name|non_interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnsync_opt_force_interactive
case|:
name|force_interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnsync_opt_trust_server_cert
case|:
comment|/* backwards compat */
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_unknown_ca
operator|=
name|TRUE
expr_stmt|;
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_unknown_ca
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnsync_opt_trust_server_cert_failures_src
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_trust_options
argument_list|(
operator|&
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_unknown_ca
argument_list|,
operator|&
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_cn_mismatch
argument_list|,
operator|&
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_expired
argument_list|,
operator|&
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_not_yet_valid
argument_list|,
operator|&
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_other_failure
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_trust_server_cert_failures_dst
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_trust_options
argument_list|(
operator|&
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_unknown_ca
argument_list|,
operator|&
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_cn_mismatch
argument_list|,
operator|&
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_expired
argument_list|,
operator|&
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_not_yet_valid
argument_list|,
operator|&
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_other_failure
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_no_auth_cache
case|:
name|opt_baton
operator|.
name|no_auth_cache
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnsync_opt_auth_username
case|:
name|opt_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|username
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_auth_password
case|:
name|opt_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|password
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_source_username
case|:
name|opt_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|source_username
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_source_password
case|:
name|opt_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|source_password
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_sync_username
case|:
name|opt_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|sync_username
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_sync_password
case|:
name|opt_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|sync_password
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_config_dir
case|:
block|{
specifier|const
name|char
modifier|*
name|path_utf8
decl_stmt|;
name|opt_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|path_utf8
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_err
condition|)
name|opt_baton
operator|.
name|config_dir
operator|=
name|svn_dirent_internal_style
argument_list|(
name|path_utf8
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|svnsync_opt_config_options
case|:
if|if
condition|(
operator|!
name|config_options
condition|)
name|config_options
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_config_option
argument_list|(
name|config_options
argument_list|,
name|opt_arg
argument_list|,
literal|"svnsync: "
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_source_prop_encoding
case|:
name|opt_err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|source_prop_encoding
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnsync_opt_disable_locking
case|:
name|opt_baton
operator|.
name|disable_locking
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnsync_opt_steal_lock
case|:
name|opt_baton
operator|.
name|steal_lock
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnsync_opt_version
case|:
name|opt_baton
operator|.
name|version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnsync_opt_allow_non_empty
case|:
name|opt_baton
operator|.
name|allow_non_empty
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|opt_baton
operator|.
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|svn_opt_parse_revision
argument_list|(
operator|&
name|opt_baton
operator|.
name|start_rev
argument_list|,
operator|&
name|opt_baton
operator|.
name|end_rev
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|utf8_opt_arg
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Syntax error in revision argument '%s'"
argument_list|)
argument_list|,
name|utf8_opt_arg
argument_list|)
return|;
block|}
comment|/* We only allow numbers and 'HEAD'. */
if|if
condition|(
operator|(
operator|(
name|opt_baton
operator|.
name|start_rev
operator|.
name|kind
operator|!=
name|svn_opt_revision_number
operator|)
operator|&&
operator|(
name|opt_baton
operator|.
name|start_rev
operator|.
name|kind
operator|!=
name|svn_opt_revision_head
operator|)
operator|)
operator|||
operator|(
operator|(
name|opt_baton
operator|.
name|end_rev
operator|.
name|kind
operator|!=
name|svn_opt_revision_number
operator|)
operator|&&
operator|(
name|opt_baton
operator|.
name|end_rev
operator|.
name|kind
operator|!=
name|svn_opt_revision_head
operator|)
operator|&&
operator|(
name|opt_baton
operator|.
name|end_rev
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
operator|)
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision range '%s' provided"
argument_list|)
argument_list|,
name|opt_arg
argument_list|)
return|;
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
operator|!
name|config_options
condition|)
name|config_options
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_config_option
argument_list|(
name|config_options
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"config:miscellany:memory-cache-size=%s"
argument_list|,
name|opt_arg
argument_list|)
argument_list|,
name|NULL
comment|/* won't be used */
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
name|opt_baton
operator|.
name|help
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
block|{
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
name|opt_err
condition|)
return|return
name|opt_err
return|;
block|}
if|if
condition|(
name|opt_baton
operator|.
name|help
condition|)
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|svnsync_cmd_table
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
comment|/* The --non-interactive and --force-interactive options are mutually    * exclusive. */
if|if
condition|(
name|opt_baton
operator|.
name|non_interactive
operator|&&
name|force_interactive
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--non-interactive and --force-interactive "
literal|"are mutually exclusive"
argument_list|)
argument_list|)
return|;
block|}
else|else
name|opt_baton
operator|.
name|non_interactive
operator|=
operator|!
name|svn_cmdline__be_interactive
argument_list|(
name|opt_baton
operator|.
name|non_interactive
argument_list|,
name|force_interactive
argument_list|)
expr_stmt|;
comment|/* Disallow the mixing --username/password with their --source- and      --sync- variants.  Treat "--username FOO" as "--source-username      FOO --sync-username FOO"; ditto for "--password FOO". */
if|if
condition|(
operator|(
name|username
operator|||
name|password
operator|)
operator|&&
operator|(
name|source_username
operator|||
name|sync_username
operator|||
name|source_password
operator|||
name|sync_password
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot use --username or --password with any of "
literal|"--source-username, --source-password, --sync-username, "
literal|"or --sync-password.\n"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|username
condition|)
block|{
name|source_username
operator|=
name|username
expr_stmt|;
name|sync_username
operator|=
name|username
expr_stmt|;
block|}
if|if
condition|(
name|password
condition|)
block|{
name|source_password
operator|=
name|password
expr_stmt|;
name|sync_password
operator|=
name|password
expr_stmt|;
block|}
name|opt_baton
operator|.
name|source_username
operator|=
name|source_username
expr_stmt|;
name|opt_baton
operator|.
name|source_password
operator|=
name|source_password
expr_stmt|;
name|opt_baton
operator|.
name|sync_username
operator|=
name|sync_username
expr_stmt|;
name|opt_baton
operator|.
name|sync_password
operator|=
name|sync_password
expr_stmt|;
comment|/* Disallow mixing of --steal-lock and --disable-locking. */
if|if
condition|(
name|opt_baton
operator|.
name|steal_lock
operator|&&
name|opt_baton
operator|.
name|disable_locking
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--disable-locking and --steal-lock are "
literal|"mutually exclusive"
argument_list|)
argument_list|)
return|;
block|}
comment|/* --trust-* can only be used with --non-interactive */
if|if
condition|(
operator|!
name|opt_baton
operator|.
name|non_interactive
condition|)
block|{
if|if
condition|(
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_unknown_ca
operator|||
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_cn_mismatch
operator|||
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_expired
operator|||
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_not_yet_valid
operator|||
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_other_failure
operator|||
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_unknown_ca
operator|||
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_cn_mismatch
operator|||
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_expired
operator|||
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_not_yet_valid
operator|||
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_other_failure
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--source-trust-server-cert-failures "
literal|"and "
literal|"--sync-trust-server-cert-failures require "
literal|"--non-interactive"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_config_ensure
argument_list|(
name|opt_baton
operator|.
name|config_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
if|if
condition|(
name|opt_baton
operator|.
name|version
condition|)
block|{
comment|/* Use the "help" subcommand to handle "--version". */
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|pseudo_cmd
init|=
block|{
literal|"--version"
block|,
name|help_cmd
block|,
block|{
literal|0
block|}
block|,
literal|""
block|,
block|{
name|svnsync_opt_version
block|,
comment|/* must accept its own option */
literal|'q'
block|,
comment|/* --quiet */
block|}
block|}
decl_stmt|;
name|subcommand
operator|=
operator|&
name|pseudo_cmd
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|first_arg
init|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
decl_stmt|;
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|svnsync_cmd_table
argument_list|,
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|received_opts
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|opt_id
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|received_opts
argument_list|,
name|i
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_id
operator|==
literal|'h'
operator|||
name|opt_id
operator|==
literal|'?'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|svn_opt_subcommand_takes_option3
argument_list|(
name|subcommand
argument_list|,
name|opt_id
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
specifier|const
name|apr_getopt_option_t
modifier|*
name|badopt
init|=
name|svn_opt_get_option_from_code2
argument_list|(
name|opt_id
argument_list|,
name|svnsync_options
argument_list|,
name|subcommand
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_opt_format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|badopt
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|SVN_ERR
argument_list|(
name|help_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Subcommand '%s' doesn't accept option '%s'\n"
literal|"Type 'svnsync help %s' for usage.\n"
argument_list|)
argument_list|,
name|subcommand
operator|->
name|name
argument_list|,
name|optstr
argument_list|,
name|subcommand
operator|->
name|name
argument_list|)
return|;
block|}
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_config_get_config
argument_list|(
operator|&
name|opt_baton
operator|.
name|config
argument_list|,
name|opt_baton
operator|.
name|config_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the options in the config */
if|if
condition|(
name|config_options
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline__apply_config_options
argument_list|(
name|opt_baton
operator|.
name|config
argument_list|,
name|config_options
argument_list|,
literal|"svnsync: "
argument_list|,
literal|"--config-option"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|config
operator|=
name|svn_hash_gets
argument_list|(
name|opt_baton
operator|.
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
expr_stmt|;
name|opt_baton
operator|.
name|source_prop_encoding
operator|=
name|source_prop_encoding
expr_stmt|;
name|apr_signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBREAK
comment|/* SIGBREAK is a Win32 specific signal generated by ctrl-break. */
name|apr_signal
argument_list|(
name|SIGBREAK
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|apr_signal
argument_list|(
name|SIGHUP
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|apr_signal
argument_list|(
name|SIGTERM
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* Disable SIGPIPE generation for the platforms that have it. */
name|apr_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
comment|/* Disable SIGXFSZ generation for the platforms that have it,      otherwise working with large files when compiled against an APR      that doesn't have large file support will crash the program,      which is uncool. */
name|apr_signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|svn_cmdline_create_auth_baton2
argument_list|(
operator|&
name|opt_baton
operator|.
name|source_auth_baton
argument_list|,
name|opt_baton
operator|.
name|non_interactive
argument_list|,
name|opt_baton
operator|.
name|source_username
argument_list|,
name|opt_baton
operator|.
name|source_password
argument_list|,
name|opt_baton
operator|.
name|config_dir
argument_list|,
name|opt_baton
operator|.
name|no_auth_cache
argument_list|,
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_unknown_ca
argument_list|,
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_cn_mismatch
argument_list|,
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_expired
argument_list|,
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_not_yet_valid
argument_list|,
name|opt_baton
operator|.
name|src_trust
operator|.
name|trust_server_cert_other_failure
argument_list|,
name|config
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_cmdline_create_auth_baton2
argument_list|(
operator|&
name|opt_baton
operator|.
name|sync_auth_baton
argument_list|,
name|opt_baton
operator|.
name|non_interactive
argument_list|,
name|opt_baton
operator|.
name|sync_username
argument_list|,
name|opt_baton
operator|.
name|sync_password
argument_list|,
name|opt_baton
operator|.
name|config_dir
argument_list|,
name|opt_baton
operator|.
name|no_auth_cache
argument_list|,
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_unknown_ca
argument_list|,
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_cn_mismatch
argument_list|,
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_expired
argument_list|,
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_not_yet_valid
argument_list|,
name|opt_baton
operator|.
name|dst_trust
operator|.
name|trust_server_cert_other_failure
argument_list|,
name|config
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
call|(
modifier|*
name|subcommand
operator|->
name|cmd_func
call|)
argument_list|(
name|os
argument_list|,
operator|&
name|opt_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* For argument-related problems, suggest using the 'help'          subcommand. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_INSUFFICIENT_ARGS
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_ARG_PARSING_ERROR
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Try 'svnsync help' for more info"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|int
name|exit_code
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svnsync"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool.  Use a separate mutexless allocator,    * given this application is single threaded.    */
name|pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|sub_main
argument_list|(
operator|&
name|exit_code
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Flush stdout and report if it fails. It would be flushed on exit anyway      but this makes sure that output is not silently lost if it fails. */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|,
literal|"svnsync: "
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function

end_unit

