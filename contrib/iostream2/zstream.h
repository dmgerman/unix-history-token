begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 1997  * Christian Michelsen Research AS  * Advanced Computing  * Fantoftvegen 38, 5036 BERGEN, Norway  * http://www.cmr.no  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Christian Michelsen Research AS makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTREAM__H
end_ifndef

begin_define
define|#
directive|define
name|ZSTREAM__H
end_define

begin_comment
comment|/*  * zstream.h - C++ interface to the 'zlib' general purpose compression library  * $Id: zstream.h 1.1 1997-06-25 12:00:56+02 tyge Exp tyge $  */
end_comment

begin_include
include|#
directive|include
file|<strstream.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|file
parameter_list|)
value|setmode(fileno(file), O_BINARY)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|file
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|class
name|zstringlen
block|{
name|public
label|:
name|zstringlen
argument_list|(
argument|class izstream&
argument_list|)
empty_stmt|;
name|zstringlen
argument_list|(
argument|class ozstream&
argument_list|,
argument|const char*
argument_list|)
empty_stmt|;
name|size_t
name|value
argument_list|()
specifier|const
block|{
return|return
name|val
operator|.
name|word
return|;
block|}
name|private
label|:
struct|struct
name|Val
block|{
name|unsigned
name|char
name|byte
decl_stmt|;
name|size_t
name|word
decl_stmt|;
block|}
name|val
struct|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//  ----------------------------- izstream -----------------------------
end_comment

begin_decl_stmt
name|class
name|izstream
block|{
name|public
label|:
name|izstream
argument_list|()
operator|:
name|m_fp
argument_list|(
literal|0
argument_list|)
block|{}
name|izstream
argument_list|(
name|FILE
operator|*
name|fp
argument_list|)
operator|:
name|m_fp
argument_list|(
literal|0
argument_list|)
block|{
name|open
argument_list|(
name|fp
argument_list|)
block|; }
name|izstream
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|)
operator|:
name|m_fp
argument_list|(
literal|0
argument_list|)
block|{
name|open
argument_list|(
name|name
argument_list|)
block|; }
operator|~
name|izstream
argument_list|()
block|{
name|close
argument_list|()
block|; }
comment|/* Opens a gzip (.gz) file for reading.          * open() can be used to read a file which is not in gzip format;          * in this case read() will directly read from the file without          * decompression. errno can be checked to distinguish two error          * cases (if errno is zero, the zlib error is Z_MEM_ERROR).          */
name|void
name|open
argument_list|(
argument|const char* name
argument_list|)
block|{
if|if
condition|(
name|m_fp
condition|)
name|close
argument_list|()
expr_stmt|;
name|m_fp
operator|=
operator|::
name|gzopen
argument_list|(
name|name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|open
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|SET_BINARY_MODE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_fp
condition|)
name|close
argument_list|()
expr_stmt|;
name|m_fp
operator|=
operator|::
name|gzdopen
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flushes all pending input if necessary, closes the compressed file          * and deallocates all the (de)compression state. The return value is          * the zlib error number (see function error() below).          */
end_comment

begin_function
name|int
name|close
parameter_list|()
block|{
name|int
name|r
init|=
operator|::
name|gzclose
argument_list|(
name|m_fp
argument_list|)
decl_stmt|;
name|m_fp
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Binary read the given number of bytes from the compressed file.          */
end_comment

begin_function
name|int
name|read
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|::
name|gzread
argument_list|(
name|m_fp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the error message for the last error which occurred on the          * given compressed file. errnum is set to zlib error number. If an          * error occurred in the file system and not in the compression library,          * errnum is set to Z_ERRNO and the application may consult errno          * to get the exact error code.          */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|error
parameter_list|(
name|int
modifier|*
name|errnum
parameter_list|)
block|{
return|return
operator|::
name|gzerror
argument_list|(
name|m_fp
argument_list|,
name|errnum
argument_list|)
return|;
block|}
end_function

begin_function
name|gzFile
name|fp
parameter_list|()
block|{
return|return
name|m_fp
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|gzFile
name|m_fp
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/*  * Binary read the given (array of) object(s) from the compressed file.  * If the input file was not in gzip format, read() copies the objects number  * of bytes into the buffer.  * returns the number of uncompressed bytes actually read  * (0 for end of file, -1 for error).  */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Items
operator|>
specifier|inline
name|int
name|read
argument_list|(
argument|izstream& zs
argument_list|,
argument|T* x
argument_list|,
argument|Items items
argument_list|)
block|{
return|return
operator|::
name|gzread
argument_list|(
name|zs
operator|.
name|fp
argument_list|()
argument_list|,
name|x
argument_list|,
name|items
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Binary input with the '>' operator.  */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|izstream
operator|&
name|operator
operator|>
operator|(
name|izstream
operator|&
name|zs
operator|,
name|T
operator|&
name|x
operator|)
block|{
operator|::
name|gzread
argument_list|(
name|zs
operator|.
name|fp
argument_list|()
argument_list|,
operator|&
name|x
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;
return|return
name|zs
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|zstringlen
operator|::
name|zstringlen
argument_list|(
argument|izstream& zs
argument_list|)
block|{
name|zs
operator|>
name|val
operator|.
name|byte
block|;
if|if
condition|(
name|val
operator|.
name|byte
operator|==
literal|255
condition|)
name|zs
operator|>
name|val
operator|.
name|word
expr_stmt|;
else|else
name|val
operator|.
name|word
operator|=
name|val
operator|.
name|byte
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Read length of string + the string with the '>' operator.  */
end_comment

begin_expr_stmt
specifier|inline
name|izstream
operator|&
name|operator
operator|>
operator|(
name|izstream
operator|&
name|zs
operator|,
name|char
operator|*
name|x
operator|)
block|{
name|zstringlen
name|len
argument_list|(
name|zs
argument_list|)
block|;
operator|::
name|gzread
argument_list|(
name|zs
operator|.
name|fp
argument_list|()
argument_list|,
name|x
argument_list|,
name|len
operator|.
name|value
argument_list|()
argument_list|)
block|;
name|x
index|[
name|len
operator|.
name|value
argument_list|()
index|]
operator|=
literal|'\0'
block|;
return|return
name|zs
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|char
modifier|*
name|read_string
parameter_list|(
name|izstream
modifier|&
name|zs
parameter_list|)
block|{
name|zstringlen
name|len
argument_list|(
name|zs
argument_list|)
decl_stmt|;
name|char
modifier|*
name|x
init|=
name|new
name|char
index|[
name|len
operator|.
name|value
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
operator|::
name|gzread
argument_list|(
name|zs
operator|.
name|fp
argument_list|()
argument_list|,
name|x
argument_list|,
name|len
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|x
index|[
name|len
operator|.
name|value
argument_list|()
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|// ----------------------------- ozstream -----------------------------
end_comment

begin_decl_stmt
name|class
name|ozstream
block|{
name|public
label|:
name|ozstream
argument_list|()
operator|:
name|m_fp
argument_list|(
literal|0
argument_list|)
operator|,
name|m_os
argument_list|(
literal|0
argument_list|)
block|{         }
name|ozstream
argument_list|(
argument|FILE* fp
argument_list|,
argument|int level = Z_DEFAULT_COMPRESSION
argument_list|)
operator|:
name|m_fp
argument_list|(
literal|0
argument_list|)
operator|,
name|m_os
argument_list|(
literal|0
argument_list|)
block|{
name|open
argument_list|(
name|fp
argument_list|,
name|level
argument_list|)
block|;         }
name|ozstream
argument_list|(
argument|const char* name
argument_list|,
argument|int level = Z_DEFAULT_COMPRESSION
argument_list|)
operator|:
name|m_fp
argument_list|(
literal|0
argument_list|)
operator|,
name|m_os
argument_list|(
literal|0
argument_list|)
block|{
name|open
argument_list|(
name|name
argument_list|,
name|level
argument_list|)
block|;         }
operator|~
name|ozstream
argument_list|()
block|{
name|close
argument_list|()
block|;         }
comment|/* Opens a gzip (.gz) file for writing.          * The compression level parameter should be in 0..9          * errno can be checked to distinguish two error cases          * (if errno is zero, the zlib error is Z_MEM_ERROR).          */
name|void
name|open
argument_list|(
argument|const char* name
argument_list|,
argument|int level = Z_DEFAULT_COMPRESSION
argument_list|)
block|{
name|char
name|mode
index|[
literal|4
index|]
operator|=
literal|"wb\0"
block|;
if|if
condition|(
name|level
operator|!=
name|Z_DEFAULT_COMPRESSION
condition|)
name|mode
index|[
literal|2
index|]
operator|=
literal|'0'
operator|+
name|level
expr_stmt|;
if|if
condition|(
name|m_fp
condition|)
name|close
argument_list|()
expr_stmt|;
name|m_fp
operator|=
operator|::
name|gzopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* open from a FILE pointer.          */
end_comment

begin_function
name|void
name|open
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|level
init|=
name|Z_DEFAULT_COMPRESSION
parameter_list|)
block|{
name|SET_BINARY_MODE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|char
name|mode
index|[
literal|4
index|]
init|=
literal|"wb\0"
decl_stmt|;
if|if
condition|(
name|level
operator|!=
name|Z_DEFAULT_COMPRESSION
condition|)
name|mode
index|[
literal|2
index|]
operator|=
literal|'0'
operator|+
name|level
expr_stmt|;
if|if
condition|(
name|m_fp
condition|)
name|close
argument_list|()
expr_stmt|;
name|m_fp
operator|=
operator|::
name|gzdopen
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flushes all pending output if necessary, closes the compressed file          * and deallocates all the (de)compression state. The return value is          * the zlib error number (see function error() below).          */
end_comment

begin_function
name|int
name|close
parameter_list|()
block|{
if|if
condition|(
name|m_os
condition|)
block|{
operator|::
name|gzwrite
argument_list|(
name|m_fp
argument_list|,
name|m_os
operator|->
name|str
argument_list|()
argument_list|,
name|m_os
operator|->
name|pcount
argument_list|()
argument_list|)
expr_stmt|;
name|delete
index|[]
name|m_os
operator|->
name|str
parameter_list|()
function_decl|;
name|delete
name|m_os
decl_stmt|;
name|m_os
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|r
init|=
operator|::
name|gzclose
argument_list|(
name|m_fp
argument_list|)
decl_stmt|;
name|m_fp
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Binary write the given number of bytes into the compressed file.          */
end_comment

begin_function
name|int
name|write
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|::
name|gzwrite
argument_list|(
name|m_fp
argument_list|,
operator|(
name|voidp
operator|)
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Flushes all pending output into the compressed file. The parameter          * _flush is as in the deflate() function. The return value is the zlib          * error number (see function gzerror below). flush() returns Z_OK if          * the flush_ parameter is Z_FINISH and all output could be flushed.          * flush() should be called only when strictly necessary because it can          * degrade compression.          */
end_comment

begin_function
name|int
name|flush
parameter_list|(
name|int
name|_flush
parameter_list|)
block|{
name|os_flush
argument_list|()
expr_stmt|;
return|return
operator|::
name|gzflush
argument_list|(
name|m_fp
argument_list|,
name|_flush
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the error message for the last error which occurred on the          * given compressed file. errnum is set to zlib error number. If an          * error occurred in the file system and not in the compression library,          * errnum is set to Z_ERRNO and the application may consult errno          * to get the exact error code.          */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|error
parameter_list|(
name|int
modifier|*
name|errnum
parameter_list|)
block|{
return|return
operator|::
name|gzerror
argument_list|(
name|m_fp
argument_list|,
name|errnum
argument_list|)
return|;
block|}
end_function

begin_function
name|gzFile
name|fp
parameter_list|()
block|{
return|return
name|m_fp
return|;
block|}
end_function

begin_function
name|ostream
modifier|&
name|os
parameter_list|()
block|{
if|if
condition|(
name|m_os
operator|==
literal|0
condition|)
name|m_os
operator|=
name|new
name|ostrstream
expr_stmt|;
return|return
operator|*
name|m_os
return|;
block|}
end_function

begin_function
name|void
name|os_flush
parameter_list|()
block|{
if|if
condition|(
name|m_os
operator|&&
name|m_os
operator|->
name|pcount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ostrstream
modifier|*
name|oss
init|=
name|new
name|ostrstream
decl_stmt|;
name|oss
operator|->
name|fill
argument_list|(
name|m_os
operator|->
name|fill
argument_list|()
argument_list|)
expr_stmt|;
name|oss
operator|->
name|flags
argument_list|(
name|m_os
operator|->
name|flags
argument_list|()
argument_list|)
expr_stmt|;
name|oss
operator|->
name|precision
argument_list|(
name|m_os
operator|->
name|precision
argument_list|()
argument_list|)
expr_stmt|;
name|oss
operator|->
name|width
argument_list|(
name|m_os
operator|->
name|width
argument_list|()
argument_list|)
expr_stmt|;
operator|::
name|gzwrite
argument_list|(
name|m_fp
argument_list|,
name|m_os
operator|->
name|str
argument_list|()
argument_list|,
name|m_os
operator|->
name|pcount
argument_list|()
argument_list|)
expr_stmt|;
name|delete
index|[]
name|m_os
operator|->
name|str
parameter_list|()
function_decl|;
name|delete
name|m_os
decl_stmt|;
name|m_os
operator|=
name|oss
expr_stmt|;
block|}
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|gzFile
name|m_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ostrstream
modifier|*
name|m_os
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/*  * Binary write the given (array of) object(s) into the compressed file.  * returns the number of uncompressed bytes actually written  * (0 in case of error).  */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|Items
operator|>
specifier|inline
name|int
name|write
argument_list|(
argument|ozstream& zs
argument_list|,
argument|const T* x
argument_list|,
argument|Items items
argument_list|)
block|{
return|return
operator|::
name|gzwrite
argument_list|(
name|zs
operator|.
name|fp
argument_list|()
argument_list|,
operator|(
name|voidp
operator|)
name|x
argument_list|,
name|items
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Binary output with the '<' operator.  */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|ozstream
operator|&
name|operator
operator|<
operator|(
name|ozstream
operator|&
name|zs
operator|,
specifier|const
name|T
operator|&
name|x
operator|)
block|{
operator|::
name|gzwrite
argument_list|(
name|zs
operator|.
name|fp
argument_list|()
argument_list|,
operator|(
name|voidp
operator|)
operator|&
name|x
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;
return|return
name|zs
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|zstringlen
operator|::
name|zstringlen
argument_list|(
argument|ozstream& zs
argument_list|,
argument|const char* x
argument_list|)
block|{
name|val
operator|.
name|byte
operator|=
literal|255
block|;
name|val
operator|.
name|word
operator|=
operator|::
name|strlen
argument_list|(
name|x
argument_list|)
block|;
if|if
condition|(
name|val
operator|.
name|word
operator|<
literal|255
condition|)
name|zs
operator|<
operator|(
name|val
operator|.
name|byte
operator|=
name|val
operator|.
name|word
operator|)
expr_stmt|;
else|else
name|zs
operator|<
name|val
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Write length of string + the string with the '<' operator.  */
end_comment

begin_expr_stmt
specifier|inline
name|ozstream
operator|&
name|operator
operator|<
operator|(
name|ozstream
operator|&
name|zs
operator|,
specifier|const
name|char
operator|*
name|x
operator|)
block|{
name|zstringlen
name|len
argument_list|(
name|zs
argument_list|,
name|x
argument_list|)
block|;
operator|::
name|gzwrite
argument_list|(
name|zs
operator|.
name|fp
argument_list|()
argument_list|,
operator|(
name|voidp
operator|)
name|x
argument_list|,
name|len
operator|.
name|value
argument_list|()
argument_list|)
block|;
return|return
name|zs
return|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_expr_stmt
specifier|inline
name|ozstream
operator|&
name|operator
operator|<
operator|(
name|ozstream
operator|&
name|zs
operator|,
name|char
operator|*
specifier|const
operator|&
name|x
operator|)
block|{
return|return
name|zs
operator|<
operator|(
specifier|const
name|char
operator|*
operator|)
name|x
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Ascii write with the<< operator;  */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|ostream
operator|&
name|operator
operator|<<
operator|(
name|ozstream
operator|&
name|zs
operator|,
specifier|const
name|T
operator|&
name|x
operator|)
block|{
name|zs
operator|.
name|os_flush
argument_list|()
block|;
return|return
name|zs
operator|.
name|os
argument_list|()
operator|<<
name|x
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

