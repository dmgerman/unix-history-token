begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1991, 1994, 1995, 1996  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988, 1989, 1991, 1994, 1995, 1996\n\ The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char rcsid[] =     "@(#)$Header: traceroute.c,v 1.43 96/09/27 20:08:10 leres Exp $ (LBL)";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * traceroute host  - trace the route ip packets follow going to "host".  *  * Attempt to trace the route an ip packet would follow to some  * internet host.  We find out intermediate hops by launching probe  * packets with a small ttl (time to live) then listening for an  * icmp "time exceeded" reply from a gateway.  We start our probes  * with a ttl of one and increase by one until we get an icmp "port  * unreachable" (which means we got to "host") or hit a max (which  * defaults to net.inet.ip.ttl hops& can be changed with the -m flag).  * Three probes (change with -q flag) are sent at each ttl setting and  * a line is printed showing the ttl, address of the gateway and  * round trip time of each probe.  If the probe answers come from  * different gateways, the address of each responding system will  * be printed.  If there is no response within a 5 sec. timeout  * interval (changed with the -w flag), a "*" is printed for that  * probe.  *  * Probe packets are UDP format.  We don't want the destination  * host to process them so the destination port is set to an  * unlikely value (if some clod on the destination is using that  * value, it can be changed with the -p flag).  *  * A sample use might be:  *  *     [yak 71]% traceroute nis.nsf.net.  *     traceroute to nis.nsf.net (35.1.1.48), 64 hops max, 56 byte packet  *      1  helios.ee.lbl.gov (128.3.112.1)  19 ms  19 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  39 ms  *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  39 ms  39 ms  39 ms  *      6  128.32.197.4 (128.32.197.4)  40 ms  59 ms  59 ms  *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  59 ms  *      8  129.140.70.13 (129.140.70.13)  99 ms  99 ms  80 ms  *      9  129.140.71.6 (129.140.71.6)  139 ms  239 ms  319 ms  *     10  129.140.81.7 (129.140.81.7)  220 ms  199 ms  199 ms  *     11  nic.merit.edu (35.1.1.48)  239 ms  239 ms  239 ms  *  * Note that lines 2& 3 are the same.  This is due to a buggy  * kernel on the 2nd hop system -- lbl-csam.arpa -- that forwards  * packets with a zero ttl.  *  * A more interesting example is:  *  *     [yak 72]% traceroute allspice.lcs.mit.edu.  *     traceroute to allspice.lcs.mit.edu (18.26.0.115), 64 hops max  *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  19 ms  19 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  19 ms  39 ms  39 ms  *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  20 ms  39 ms  39 ms  *      6  128.32.197.4 (128.32.197.4)  59 ms  119 ms  39 ms  *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  39 ms  *      8  129.140.70.13 (129.140.70.13)  80 ms  79 ms  99 ms  *      9  129.140.71.6 (129.140.71.6)  139 ms  139 ms  159 ms  *     10  129.140.81.7 (129.140.81.7)  199 ms  180 ms  300 ms  *     11  129.140.72.17 (129.140.72.17)  300 ms  239 ms  239 ms  *     12  * * *  *     13  128.121.54.72 (128.121.54.72)  259 ms  499 ms  279 ms  *     14  * * *  *     15  * * *  *     16  * * *  *     17  * * *  *     18  ALLSPICE.LCS.MIT.EDU (18.26.0.115)  339 ms  279 ms  279 ms  *  * (I start to see why I'm having so much trouble with mail to  * MIT.)  Note that the gateways 12, 14, 15, 16& 17 hops away  * either don't send ICMP "time exceeded" messages or send them  * with a ttl too small to reach us.  14 - 17 are running the  * MIT C Gateway code that doesn't send "time exceeded"s.  God  * only knows what's going on with 12.  *  * The silent gateway 12 in the above may be the result of a bug in  * the 4.[23]BSD network code (and its derivatives):  4.x (x<= 3)  * sends an unreachable message using whatever ttl remains in the  * original datagram.  Since, for gateways, the remaining ttl is  * zero, the icmp "time exceeded" is guaranteed to not make it back  * to us.  The behavior of this bug is slightly more interesting  * when it appears on the destination system:  *  *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  39 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  39 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  19 ms  *      5  ccn-nerif35.Berkeley.EDU (128.32.168.35)  39 ms  39 ms  39 ms  *      6  csgw.Berkeley.EDU (128.32.133.254)  39 ms  59 ms  39 ms  *      7  * * *  *      8  * * *  *      9  * * *  *     10  * * *  *     11  * * *  *     12  * * *  *     13  rip.Berkeley.EDU (128.32.131.22)  59 ms !  39 ms !  39 ms !  *  * Notice that there are 12 "gateways" (13 is the final  * destination) and exactly the last half of them are "missing".  * What's really happening is that rip (a Sun-3 running Sun OS3.5)  * is using the ttl from our arriving datagram as the ttl in its  * icmp reply.  So, the reply will time out on the return path  * (with no notice sent to anyone since icmp's aren't sent for  * icmp's) until we probe with a ttl that's at least twice the path  * length.  I.e., rip is really only 7 hops away.  A reply that  * returns with a ttl of 1 is a clue this problem exists.  * Traceroute prints a "!" after the time if the ttl is<= 1.  * Since vendors ship a lot of obsolete (DEC's Ultrix, Sun 3.x) or  * non-standard (HPUX) software, expect to see this problem  * frequently and/or take care picking the target host of your  * probes.  *  * Other possible annotations after the time are !H, !N, !P (got a host,  * network or protocol unreachable, respectively), !S or !F (source  * route failed or fragmentation needed -- neither of these should  * ever occur and the associated gateway is busted if you see one).  If  * almost all the probes result in some kind of unreachable, traceroute  * will give up and exit.  *  * Notes  * -----  * This program must be run by root or be setuid.  (I suggest that  * you *don't* make it setuid -- casual use could result in a lot  * of unnecessary traffic on our poor, congested nets.)  *  * This program requires a kernel mod that does not appear in any  * system available from Berkeley:  A raw ip socket using proto  * IPPROTO_RAW must interpret the data sent as an ip datagram (as  * opposed to data to be wrapped in a ip datagram).  See the README  * file that came with the source to this program for a description  * of the mods I made to /sys/netinet/raw_ip.c.  Your mileage may  * vary.  But, again, ANY 4.x (x< 4) BSD KERNEL WILL HAVE TO BE  * MODIFIED TO RUN THIS PROGRAM.  *  * The udp port usage may appear bizarre (well, ok, it is bizarre).  * The problem is that an icmp message only contains 8 bytes of  * data from the original datagram.  8 bytes is the size of a udp  * header so, if we want to associate replies with the original  * datagram, the necessary information must be encoded into the  * udp header (the ip id could be used but there's no way to  * interlock with the kernel's assignment of ip id's and, anyway,  * it would have taken a lot more kernel hacking to allow this  * code to set the ip id).  So, to allow two or more users to  * use traceroute simultaneously, we use this task's pid as the  * source port (the high bit is set to move the port number out  * of the "likely" range).  To keep track of which probe is being  * replied to (so times and/or hop counts don't get confused by a  * reply that was delayed in transit), we increment the destination  * port number before each probe.  *  * Don't use this as a coding example.  I was trying to find a  * routing problem and this code sort-of popped out after 48 hours  * without sleep.  I was amazed it ever compiled, much less ran.  *  * I stole the idea for this program from Steve Deering.  Since  * the first release, I've learned that had I attended the right  * IETF working group meetings, I also could have stolen it from Guy  * Almes or Matt Mathis.  I don't know (or care) who came up with  * the idea first.  I envy the originators' perspicacity and I'm  * glad they didn't keep the idea a secret.  *  * Tim Seaver, Ken Adelman and C. Philip Wood provided bug fixes and/or  * enhancements to the original distribution.  *  * I've hacked up a round-trip-route version of this that works by  * sending a loose-source-routed udp datagram through the destination  * back to yourself.  Unfortunately, SO many gateways botch source  * routing, the thing is almost worthless.  Maybe one day...  *  *  -- Van Jacobson (van@ee.lbl.gov)  *     Tue Dec 20 03:50:13 PST 1988  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SELECT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SYSCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPSEC */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MALLOC_H
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"gnuc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Maximum number of gateways (include room for one noop) */
end_comment

begin_define
define|#
directive|define
name|NGATEWAYS
value|((int)((MAX_IPOPTLEN - IPOPT_MINOFF - 1) / sizeof(u_int32_t)))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHOSTNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXHOSTNAMELEN
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Fprintf
value|(void)fprintf
end_define

begin_define
define|#
directive|define
name|Printf
value|(void)printf
end_define

begin_comment
comment|/* What a GRE packet header looks like */
end_comment

begin_struct
struct|struct
name|grehdr
block|{
name|u_int16_t
name|flags
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int16_t
name|length
decl_stmt|;
comment|/* PPTP version of these fields */
name|u_int16_t
name|callId
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|IPPROTO_GRE
end_ifndef

begin_define
define|#
directive|define
name|IPPROTO_GRE
value|47
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For GRE, we prepare what looks like a PPTP packet */
end_comment

begin_define
define|#
directive|define
name|GRE_PPTP_PROTO
value|0x880b
end_define

begin_comment
comment|/* Data section of the probe packet */
end_comment

begin_struct
struct|struct
name|outdata
block|{
name|u_char
name|seq
decl_stmt|;
comment|/* sequence number of this packet */
name|u_char
name|ttl
decl_stmt|;
comment|/* ttl packet left with */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* time packet left */
block|}
struct|;
end_struct

begin_comment
comment|/* Descriptor structure for each outgoing protocol we support */
end_comment

begin_struct
struct|struct
name|outproto
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of protocol */
name|u_char
name|num
decl_stmt|;
comment|/* IP protocol number */
name|u_short
name|hdrlen
decl_stmt|;
comment|/* max size of protocol header */
name|u_short
name|port
decl_stmt|;
comment|/* default base protocol-specific "port" */
name|void
function_decl|(
modifier|*
name|prepare
function_decl|)
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
comment|/* finish preparing an outgoing packet */
name|int
function_decl|(
modifier|*
name|check
function_decl|)
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* check an incoming packet */
block|}
struct|;
end_struct

begin_decl_stmt
name|u_char
name|packet
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last inbound (icmp) packet */
end_comment

begin_decl_stmt
name|struct
name|ip
modifier|*
name|outip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last output ip packet */
end_comment

begin_decl_stmt
name|u_char
modifier|*
name|outprot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last output inner protocol packet */
end_comment

begin_comment
comment|/* loose source route gateway list (including room for final destination) */
end_comment

begin_decl_stmt
name|u_int32_t
name|gwlist
index|[
name|NGATEWAYS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receive (icmp) socket file descriptor */
end_comment

begin_decl_stmt
name|int
name|sndsock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send (udp) socket file descriptor */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
name|whereto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Who to try to reach */
end_comment

begin_decl_stmt
name|int
name|packlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total length of packet */
end_comment

begin_decl_stmt
name|int
name|protlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of protocol part of packet */
end_comment

begin_decl_stmt
name|int
name|maxpacket
init|=
literal|32
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max ip packet size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|source
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nprobes
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|min_ttl
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_ttl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|ident
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* protocol specific base "port" */
end_comment

begin_decl_stmt
name|int
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket options */
end_comment

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|waittime
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time to wait for response (in seconds) */
end_comment

begin_decl_stmt
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print addresses numerically */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|opterr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forwards */
end_comment

begin_function_decl
name|double
name|deltaT
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|inetname
parameter_list|(
name|struct
name|in_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|packet_ok
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|pr_type
parameter_list|(
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getaddr
parameter_list|(
name|u_int32_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getsin
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|savestr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_decl_stmt
name|int
name|setpolicy
name|__P
argument_list|(
operator|(
name|int
name|so
operator|,
name|char
operator|*
name|policy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|send_probe
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tvsub
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__dead
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wait_for_reply
parameter_list|(
name|int
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|udp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|udp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tcp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tcp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gre_prep
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gre_check
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gen_prep
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gen_check
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* List of supported protocols. The first one is the default. The last    one is the handler for generic protocols not explicitly listed. */
end_comment

begin_decl_stmt
name|struct
name|outproto
name|protos
index|[]
init|=
block|{
block|{
literal|"udp"
block|,
name|IPPROTO_UDP
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
block|,
literal|32768
operator|+
literal|666
block|,
name|udp_prep
block|,
name|udp_check
block|}
block|,
block|{
literal|"tcp"
block|,
name|IPPROTO_TCP
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
block|,
literal|32768
operator|+
literal|666
block|,
name|tcp_prep
block|,
name|tcp_check
block|}
block|,
block|{
literal|"gre"
block|,
name|IPPROTO_GRE
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|grehdr
argument_list|)
block|,
name|GRE_PPTP_PROTO
block|,
name|gre_prep
block|,
name|gre_check
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
block|,
literal|0
block|,
name|gen_prep
block|,
name|gen_check
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|outproto
modifier|*
name|proto
init|=
operator|&
name|protos
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|register
name|int
name|op
decl_stmt|,
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|to
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|whereto
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
specifier|register
name|struct
name|protoent
modifier|*
name|pe
decl_stmt|;
specifier|register
name|int
name|ttl
decl_stmt|,
name|probe
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|int
name|seq
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|tos
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|lsrr
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|optlen
init|=
literal|0
decl_stmt|;
name|int
name|requestPort
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|sump
init|=
literal|0
decl_stmt|;
name|int
name|sockerrno
decl_stmt|;
comment|/* 	 * Do the setuid-required stuff first, then lose priveleges ASAP. 	 * Do error checking for these two calls where they appeared in 	 * the original code. 	 */
name|cp
operator|=
literal|"icmp"
expr_stmt|;
name|pe
operator|=
name|getprotobyname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|pe
operator|->
name|p_proto
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|sockerrno
operator|=
name|errno
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sndsock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_RAW
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|sockerrno
operator|=
name|errno
expr_stmt|;
block|}
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPCTL_DEFTTL
block|{
name|int
name|mib
index|[
literal|4
index|]
init|=
block|{
name|CTL_NET
block|,
name|PF_INET
block|,
name|IPPROTO_IP
block|,
name|IPCTL_DEFTTL
block|}
decl_stmt|;
name|size_t
name|sz
init|=
sizeof|sizeof
argument_list|(
name|max_ttl
argument_list|)
decl_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|4
argument_list|,
operator|&
name|max_ttl
argument_list|,
operator|&
name|sz
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"sysctl(net.inet.ip.ttl)"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|max_ttl
operator|=
literal|30
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|prog
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
else|else
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Sdnrvg:M:m:P:p:q:s:t:w:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'S'
case|:
name|sump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|options
operator||=
name|SO_DEBUG
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|lsrr
operator|>=
name|NGATEWAYS
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: No more than %d gateways\n"
argument_list|,
name|prog
argument_list|,
name|NGATEWAYS
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|getaddr
argument_list|(
name|gwlist
operator|+
name|lsrr
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
operator|++
name|lsrr
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|min_ttl
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_ttl
operator|<
literal|1
operator|||
name|min_ttl
operator|>
literal|0xff
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid ttl value %s\n"
argument_list|,
name|prog
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
name|max_ttl
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_ttl
operator|<
literal|1
operator|||
name|max_ttl
operator|>
literal|0xff
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid ttl value %s\n"
argument_list|,
name|prog
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
operator|++
name|nflag
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|protos
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|protos
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|proto
operator|=
operator|&
name|protos
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|protos
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* generic handler */
name|struct
name|protoent
modifier|*
name|pe
decl_stmt|;
name|u_long
name|pnum
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
comment|/* Determine the IP protocol number */
if|if
condition|(
operator|(
name|pe
operator|=
name|getprotobyname
argument_list|(
name|optarg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pnum
operator|=
name|pe
operator|->
name|p_proto
expr_stmt|;
else|else
block|{
name|pnum
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnum
operator|>
literal|0xff
operator|||
operator|*
name|optarg
operator|==
literal|'\0'
operator|||
operator|*
name|eptr
operator|!=
literal|'\0'
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown "
literal|"protocol \"%s\"\n"
argument_list|,
name|prog
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|proto
operator|->
name|num
operator|=
name|pnum
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
name|requestPort
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|requestPort
operator|<=
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: port must be> 0\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|nprobes
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nprobes
operator|<=
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: nprobes must be> 0\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|options
operator||=
name|SO_DONTROUTE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* 			 * set the ip source address of the outbound 			 * probe (e.g., on a multi-homed host). 			 */
name|source
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tos
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tos
operator|<
literal|0
operator|||
name|tos
operator|>
literal|255
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: tos must be 0 to 255\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
operator|++
name|verbose
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|waittime
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|waittime
operator|<=
literal|1
operator|||
name|waittime
operator|>=
literal|24L
operator|*
literal|60
operator|*
literal|60
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: wait must be> 1 sec and< 1 day\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* Set requested port, if any, else default for this protocol */
name|port
operator|=
operator|(
name|requestPort
operator|!=
operator|-
literal|1
operator|)
condition|?
name|requestPort
else|:
name|proto
operator|->
name|port
expr_stmt|;
comment|/* Check min vs. max TTL */
if|if
condition|(
name|min_ttl
operator|>
name|max_ttl
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: min ttl must be<= max ttl\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Process destination and optional packet size */
switch|switch
condition|(
name|argc
operator|-
name|optind
condition|)
block|{
case|case
literal|2
case|:
name|packlen
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Fall thorugh */
case|case
literal|1
case|:
name|hostname
operator|=
name|savestr
argument_list|(
name|getsin
argument_list|(
name|to
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SETLINEBUF
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
else|#
directive|else
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lsrr
operator|>
literal|0
condition|)
name|optlen
operator|=
operator|(
name|lsrr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|gwlist
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|outip
argument_list|)
operator|+
name|proto
operator|->
name|hdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|outdata
argument_list|)
operator|+
name|optlen
expr_stmt|;
if|if
condition|(
name|packlen
operator|==
literal|0
condition|)
name|packlen
operator|=
name|i
expr_stmt|;
comment|/* minimum sized packet */
elseif|else
if|if
condition|(
name|i
operator|>
name|packlen
operator|||
name|packlen
operator|>
name|maxpacket
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: packet size must be %d<= s<= %d\n"
argument_list|,
name|prog
argument_list|,
name|i
argument_list|,
name|maxpacket
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|protlen
operator|=
name|packlen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|outip
argument_list|)
operator|-
name|optlen
expr_stmt|;
name|outip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|packlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|outip
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: malloc: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outip
argument_list|,
literal|0
argument_list|,
name|packlen
argument_list|)
expr_stmt|;
name|outip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|outip
operator|->
name|ip_tos
operator|=
name|tos
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTESWAP_IP_LEN
name|outip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|packlen
argument_list|)
expr_stmt|;
else|#
directive|else
name|outip
operator|->
name|ip_len
operator|=
name|packlen
expr_stmt|;
endif|#
directive|endif
name|outip
operator|->
name|ip_p
operator|=
name|proto
operator|->
name|num
expr_stmt|;
name|outprot
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|outip
operator|+
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RAW_OPTIONS
if|if
condition|(
name|lsrr
operator|>
literal|0
condition|)
block|{
specifier|register
name|u_char
modifier|*
name|optlist
decl_stmt|;
name|optlist
operator|=
operator|(
name|u_char
operator|*
operator|)
name|outprot
expr_stmt|;
operator|(
name|u_char
operator|*
operator|)
name|outprot
operator|+=
name|optlen
expr_stmt|;
comment|/* final hop */
name|gwlist
index|[
name|lsrr
index|]
operator|=
name|to
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|outip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|gwlist
index|[
literal|0
index|]
expr_stmt|;
comment|/* force 4 byte alignment */
name|optlist
index|[
literal|0
index|]
operator|=
name|IPOPT_NOP
expr_stmt|;
comment|/* loose source route option */
name|optlist
index|[
literal|1
index|]
operator|=
name|IPOPT_LSRR
expr_stmt|;
name|i
operator|=
name|lsrr
operator|*
sizeof|sizeof
argument_list|(
name|gwlist
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|optlist
index|[
literal|2
index|]
operator|=
name|i
operator|+
literal|3
expr_stmt|;
comment|/* Pointer to LSRR addresses */
name|optlist
index|[
literal|3
index|]
operator|=
name|IPOPT_MINOFF
expr_stmt|;
name|memcpy
argument_list|(
name|optlist
operator|+
literal|4
argument_list|,
name|gwlist
operator|+
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|outip
operator|->
name|ip_dst
operator|=
name|to
operator|->
name|sin_addr
expr_stmt|;
name|outip
operator|->
name|ip_hl
operator|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|outprot
operator|-
operator|(
name|u_char
operator|*
operator|)
name|outip
operator|)
operator|>>
literal|2
expr_stmt|;
name|ident
operator|=
operator|(
name|getpid
argument_list|()
operator|&
literal|0xffff
operator|)
operator||
literal|0x8000
expr_stmt|;
if|if
condition|(
name|pe
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown protocol %s\n"
argument_list|,
name|prog
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|sockerrno
expr_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: icmp socket: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SO_DONTROUTE
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DONTROUTE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPSEC_POLICY_IPSEC
argument_list|)
if|if
condition|(
name|setpolicy
argument_list|(
name|s
argument_list|,
literal|"in bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|setpolicy
argument_list|(
name|s
argument_list|,
literal|"out bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(IPSEC)&& defined(IPSEC_POLICY_IPSEC) */
if|if
condition|(
name|sndsock
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|sockerrno
expr_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: raw socket: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|IP_OPTIONS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_RAW_OPTIONS
argument_list|)
if|if
condition|(
name|lsrr
operator|>
literal|0
condition|)
block|{
name|u_char
name|optlist
index|[
name|MAX_IPOPTLEN
index|]
decl_stmt|;
name|cp
operator|=
literal|"ip"
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|getprotobyname
argument_list|(
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown protocol %s\n"
argument_list|,
name|prog
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* final hop */
name|gwlist
index|[
name|lsrr
index|]
operator|=
name|to
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
operator|++
name|lsrr
expr_stmt|;
comment|/* force 4 byte alignment */
name|optlist
index|[
literal|0
index|]
operator|=
name|IPOPT_NOP
expr_stmt|;
comment|/* loose source route option */
name|optlist
index|[
literal|1
index|]
operator|=
name|IPOPT_LSRR
expr_stmt|;
name|i
operator|=
name|lsrr
operator|*
sizeof|sizeof
argument_list|(
name|gwlist
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|optlist
index|[
literal|2
index|]
operator|=
name|i
operator|+
literal|3
expr_stmt|;
comment|/* Pointer to LSRR addresses */
name|optlist
index|[
literal|3
index|]
operator|=
name|IPOPT_MINOFF
expr_stmt|;
name|memcpy
argument_list|(
name|optlist
operator|+
literal|4
argument_list|,
name|gwlist
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|pe
operator|->
name|p_proto
argument_list|,
name|IP_OPTIONS
argument_list|,
name|optlist
argument_list|,
name|i
operator|+
sizeof|sizeof
argument_list|(
name|gwlist
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: IP_OPTIONS: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_SNDBUF
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|packlen
argument_list|,
sizeof|sizeof
argument_list|(
name|packlen
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: SO_SNDBUF: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IP_HDRINCL
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_HDRINCL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: IP_HDRINCL: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SO_DONTROUTE
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DONTROUTE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|!=
name|NULL
condition|)
block|{
name|source
operator|=
name|savestr
argument_list|(
name|getsin
argument_list|(
operator|&
name|from
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|outip
operator|->
name|ip_src
operator|=
name|from
operator|.
name|sin_addr
expr_stmt|;
ifndef|#
directive|ifndef
name|IP_HDRINCL
if|if
condition|(
name|bind
argument_list|(
name|sndsock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bind: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPSEC_POLICY_IPSEC
argument_list|)
if|if
condition|(
name|setpolicy
argument_list|(
name|sndsock
argument_list|,
literal|"in bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|setpolicy
argument_list|(
name|sndsock
argument_list|,
literal|"out bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(IPSEC)&& defined(IPSEC_POLICY_IPSEC) */
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s to %s (%s)"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|to
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
condition|)
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|" from %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|", %d hops max, %d byte packets\n"
argument_list|,
name|max_ttl
argument_list|,
name|packlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|ttl
operator|=
name|min_ttl
init|;
name|ttl
operator|<=
name|max_ttl
condition|;
operator|++
name|ttl
control|)
block|{
name|u_int32_t
name|lastaddr
init|=
literal|0
decl_stmt|;
name|int
name|got_there
init|=
literal|0
decl_stmt|;
name|int
name|unreachable
init|=
literal|0
decl_stmt|;
name|int
name|loss
decl_stmt|;
name|Printf
argument_list|(
literal|"%2d "
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
for|for
control|(
name|probe
operator|=
literal|0
operator|,
name|loss
operator|=
literal|0
init|;
name|probe
operator|<
name|nprobes
condition|;
operator|++
name|probe
control|)
block|{
specifier|register
name|int
name|cc
decl_stmt|;
name|struct
name|timeval
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|outdata
name|outdata
decl_stmt|;
comment|/* Prepare outgoing data */
name|outdata
operator|.
name|seq
operator|=
operator|++
name|seq
expr_stmt|;
name|outdata
operator|.
name|ttl
operator|=
name|ttl
expr_stmt|;
comment|/* Avoid alignment problems by copying bytewise: */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|outdata
operator|.
name|tv
argument_list|,
operator|&
name|t1
argument_list|,
sizeof|sizeof
argument_list|(
name|outdata
operator|.
name|tv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finalize and send packet */
call|(
modifier|*
name|proto
operator|->
name|prepare
call|)
argument_list|(
operator|&
name|outdata
argument_list|)
expr_stmt|;
name|send_probe
argument_list|(
name|seq
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
comment|/* Wait for a reply */
while|while
condition|(
operator|(
name|cc
operator|=
name|wait_for_reply
argument_list|(
name|s
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|t1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|double
name|T
decl_stmt|;
name|int
name|precis
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|i
operator|=
name|packet_ok
argument_list|(
name|packet
argument_list|,
name|cc
argument_list|,
operator|&
name|from
argument_list|,
name|seq
argument_list|)
expr_stmt|;
comment|/* Skip short packet */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|lastaddr
condition|)
block|{
name|print
argument_list|(
name|packet
argument_list|,
name|cc
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
name|lastaddr
operator|=
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
name|T
operator|=
name|deltaT
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SANE_PRECISION
if|if
condition|(
name|T
operator|>=
literal|1000.0
condition|)
name|precis
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|T
operator|>=
literal|100.0
condition|)
name|precis
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|T
operator|>=
literal|10.0
condition|)
name|precis
operator|=
literal|2
expr_stmt|;
else|else
endif|#
directive|endif
name|precis
operator|=
literal|3
expr_stmt|;
name|Printf
argument_list|(
literal|"  %.*f ms"
argument_list|,
name|precis
argument_list|,
name|T
argument_list|)
expr_stmt|;
comment|/* time exceeded in transit */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
name|code
operator|=
name|i
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ICMP_UNREACH_PORT
case|:
ifndef|#
directive|ifndef
name|ARCHAIC
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|packet
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
literal|1
condition|)
name|Printf
argument_list|(
literal|" !"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|got_there
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NET
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !N"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_HOST
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !H"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_PROTOCOL
case|:
operator|++
name|got_there
expr_stmt|;
name|Printf
argument_list|(
literal|" !P"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NEEDFRAG
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !F"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_SRCFAIL
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !S"
argument_list|)
expr_stmt|;
break|break;
comment|/* rfc1716 */
ifndef|#
directive|ifndef
name|ICMP_UNREACH_FILTER_PROHIB
define|#
directive|define
name|ICMP_UNREACH_FILTER_PROHIB
value|13
comment|/* admin prohibited filter */
endif|#
directive|endif
case|case
name|ICMP_UNREACH_FILTER_PROHIB
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !X"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !<%d>"
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|loss
operator|++
expr_stmt|;
name|Printf
argument_list|(
literal|" *"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sump
condition|)
block|{
name|Printf
argument_list|(
literal|" (%d%% loss)"
argument_list|,
operator|(
name|loss
operator|*
literal|100
operator|)
operator|/
name|nprobes
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_there
operator|||
operator|(
name|unreachable
operator|>
literal|0
operator|&&
name|unreachable
operator|>=
name|nprobes
operator|-
literal|1
operator|)
condition|)
break|break;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|wait_for_reply
parameter_list|(
specifier|register
name|int
name|sock
parameter_list|,
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|fromp
parameter_list|,
specifier|register
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
block|{
name|fd_set
modifier|*
name|fdsp
decl_stmt|;
name|size_t
name|nfds
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|wait
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
specifier|register
name|int
name|cc
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
name|int
name|fromlen
init|=
sizeof|sizeof
argument_list|(
operator|*
name|fromp
argument_list|)
decl_stmt|;
name|nfds
operator|=
name|howmany
argument_list|(
name|sock
operator|+
literal|1
argument_list|,
name|NFDBITS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdsp
operator|=
name|malloc
argument_list|(
name|nfds
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fdsp
argument_list|,
literal|0
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sock
argument_list|,
name|fdsp
argument_list|)
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|=
name|tp
operator|->
name|tv_sec
operator|+
name|waittime
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
name|tp
operator|->
name|tv_usec
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|tvsub
argument_list|(
operator|&
name|wait
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|.
name|tv_sec
operator|<
literal|0
condition|)
block|{
name|wait
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|1
expr_stmt|;
block|}
name|error
operator|=
name|select
argument_list|(
name|sock
operator|+
literal|1
argument_list|,
name|fdsp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: botched select() args\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|>
literal|0
condition|)
name|cc
operator|=
name|recvfrom
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|fromp
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fdsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPSEC_POLICY_IPSEC
argument_list|)
end_if

begin_function
name|int
name|setpolicy
parameter_list|(
name|so
parameter_list|,
name|policy
parameter_list|)
name|int
name|so
decl_stmt|;
name|char
modifier|*
name|policy
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|ipsec_set_policy
argument_list|(
name|policy
argument_list|,
name|strlen
argument_list|(
name|policy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|so
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_IPSEC_POLICY
argument_list|,
name|buf
argument_list|,
name|ipsec_get_policylen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|send_probe
parameter_list|(
name|int
name|seq
parameter_list|,
name|int
name|ttl
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|outip
operator|->
name|ip_ttl
operator|=
name|ttl
expr_stmt|;
name|outip
operator|->
name|ip_id
operator|=
name|htons
argument_list|(
name|ident
operator|+
name|seq
argument_list|)
expr_stmt|;
name|i
operator|=
name|sendto
argument_list|(
name|sndsock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outip
argument_list|,
name|packlen
argument_list|,
literal|0
argument_list|,
operator|&
name|whereto
argument_list|,
sizeof|sizeof
argument_list|(
name|whereto
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|!=
name|packlen
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: sendto: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%s: wrote %s %d chars, ret=%d\n"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|,
name|packlen
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|double
name|deltaT
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1p
parameter_list|,
name|struct
name|timeval
modifier|*
name|t2p
parameter_list|)
block|{
specifier|register
name|double
name|dt
decl_stmt|;
name|dt
operator|=
call|(
name|double
call|)
argument_list|(
name|t2p
operator|->
name|tv_sec
operator|-
name|t1p
operator|->
name|tv_sec
argument_list|)
operator|*
literal|1000.0
operator|+
call|(
name|double
call|)
argument_list|(
name|t2p
operator|->
name|tv_usec
operator|-
name|t1p
operator|->
name|tv_usec
argument_list|)
operator|/
literal|1000.0
expr_stmt|;
return|return
operator|(
name|dt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an ICMP "type" field to a printable string.  */
end_comment

begin_function
name|char
modifier|*
name|pr_type
parameter_list|(
specifier|register
name|u_char
name|t
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|ttab
index|[]
init|=
block|{
literal|"Echo Reply"
block|,
literal|"ICMP 1"
block|,
literal|"ICMP 2"
block|,
literal|"Dest Unreachable"
block|,
literal|"Source Quench"
block|,
literal|"Redirect"
block|,
literal|"ICMP 6"
block|,
literal|"ICMP 7"
block|,
literal|"Echo"
block|,
literal|"ICMP 9"
block|,
literal|"ICMP 10"
block|,
literal|"Time Exceeded"
block|,
literal|"Param Problem"
block|,
literal|"Timestamp"
block|,
literal|"Timestamp Reply"
block|,
literal|"Info Request"
block|,
literal|"Info Reply"
block|}
decl_stmt|;
if|if
condition|(
name|t
operator|>
literal|16
condition|)
return|return
operator|(
literal|"OUT-OF-RANGE"
operator|)
return|;
return|return
operator|(
name|ttab
index|[
name|t
index|]
operator|)
return|;
block|}
end_function

begin_function
name|int
name|packet_ok
parameter_list|(
specifier|register
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|cc
parameter_list|,
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|from
parameter_list|,
specifier|register
name|int
name|seq
parameter_list|)
block|{
specifier|register
name|struct
name|icmp
modifier|*
name|icp
decl_stmt|;
specifier|register
name|u_char
name|type
decl_stmt|,
name|code
decl_stmt|;
specifier|register
name|int
name|hlen
decl_stmt|;
ifndef|#
directive|ifndef
name|ARCHAIC
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|cc
operator|<
name|hlen
operator|+
name|ICMP_MINLEN
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|Printf
argument_list|(
literal|"packet too short (%d bytes) from %s\n"
argument_list|,
name|cc
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cc
operator|-=
name|hlen
expr_stmt|;
name|icp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
name|buf
operator|+
name|hlen
operator|)
expr_stmt|;
else|#
directive|else
name|icp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|buf
expr_stmt|;
endif|#
directive|endif
name|type
operator|=
name|icp
operator|->
name|icmp_type
expr_stmt|;
name|code
operator|=
name|icp
operator|->
name|icmp_code
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|ICMP_TIMXCEED
operator|&&
name|code
operator|==
name|ICMP_TIMXCEED_INTRANS
operator|)
operator|||
name|type
operator|==
name|ICMP_UNREACH
condition|)
block|{
name|struct
name|ip
modifier|*
name|hip
decl_stmt|;
name|u_char
modifier|*
name|inner
decl_stmt|;
name|hip
operator|=
operator|&
name|icp
operator|->
name|icmp_ip
expr_stmt|;
name|hlen
operator|=
name|hip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|inner
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|hip
operator|+
name|hlen
operator|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|+
literal|12
operator|<=
name|cc
operator|&&
name|hip
operator|->
name|ip_p
operator|==
name|proto
operator|->
name|num
operator|&&
call|(
modifier|*
name|proto
operator|->
name|check
call|)
argument_list|(
name|inner
argument_list|,
name|seq
argument_list|)
condition|)
return|return
operator|(
name|type
operator|==
name|ICMP_TIMXCEED
condition|?
operator|-
literal|1
else|:
name|code
operator|+
literal|1
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|ARCHAIC
if|if
condition|(
name|verbose
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|u_int32_t
modifier|*
name|lp
init|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|icp
operator|->
name|icmp_ip
decl_stmt|;
name|Printf
argument_list|(
literal|"\n%d bytes from %s to "
argument_list|,
name|cc
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%s: icmp type %d (%s) code %d\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|,
name|type
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|icp
operator|->
name|icmp_code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|cc
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
control|)
name|Printf
argument_list|(
literal|"%2d: x%8.8x\n"
argument_list|,
name|i
argument_list|,
operator|*
name|lp
operator|++
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|udp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
name|outdata
parameter_list|)
block|{
name|struct
name|udphdr
modifier|*
specifier|const
name|udp
init|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|outprot
decl_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_dport
operator|=
name|htons
argument_list|(
name|port
operator|+
name|outdata
operator|->
name|seq
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_ulen
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|protlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|udp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|udphdr
modifier|*
specifier|const
name|udp
init|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_sport
argument_list|)
operator|==
name|ident
operator|&&
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_dport
argument_list|)
operator|==
name|port
operator|+
name|seq
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tcp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
name|outdata
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
specifier|const
name|tcp
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|outprot
decl_stmt|;
name|tcp
operator|->
name|th_sport
operator|=
name|htons
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|th_dport
operator|=
name|htons
argument_list|(
name|port
operator|+
name|outdata
operator|->
name|seq
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|th_seq
operator|=
operator|(
name|tcp
operator|->
name|th_sport
operator|<<
literal|16
operator|)
operator||
name|tcp
operator|->
name|th_dport
expr_stmt|;
name|tcp
operator|->
name|th_ack
operator|=
literal|0
expr_stmt|;
name|tcp
operator|->
name|th_off
operator|=
literal|5
expr_stmt|;
name|tcp
operator|->
name|th_flags
operator|=
name|TH_SYN
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tcp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
specifier|const
name|tcp
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_sport
argument_list|)
operator|==
name|ident
operator|&&
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_dport
argument_list|)
operator|==
name|port
operator|+
name|seq
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gre_prep
parameter_list|(
name|struct
name|outdata
modifier|*
name|outdata
parameter_list|)
block|{
name|struct
name|grehdr
modifier|*
specifier|const
name|gre
init|=
operator|(
expr|struct
name|grehdr
operator|*
operator|)
name|outprot
decl_stmt|;
name|gre
operator|->
name|flags
operator|=
name|htons
argument_list|(
literal|0x2001
argument_list|)
expr_stmt|;
name|gre
operator|->
name|proto
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|gre
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|gre
operator|->
name|callId
operator|=
name|htons
argument_list|(
name|ident
operator|+
name|outdata
operator|->
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gre_check
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|grehdr
modifier|*
specifier|const
name|gre
init|=
operator|(
expr|struct
name|grehdr
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|ntohs
argument_list|(
name|gre
operator|->
name|proto
argument_list|)
operator|==
name|port
operator|&&
name|ntohs
argument_list|(
name|gre
operator|->
name|callId
argument_list|)
operator|==
name|ident
operator|+
name|seq
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gen_prep
parameter_list|(
name|struct
name|outdata
modifier|*
name|outdata
parameter_list|)
block|{
name|u_int16_t
modifier|*
specifier|const
name|ptr
decl_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|port
operator|+
name|outdata
operator|->
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gen_check
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|u_int16_t
modifier|*
specifier|const
name|ptr
init|=
operator|(
name|u_int16_t
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|ntohs
argument_list|(
name|ptr
index|[
literal|0
index|]
argument_list|)
operator|==
name|ident
operator|&&
name|ntohs
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|==
name|port
operator|+
name|seq
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print
parameter_list|(
specifier|register
name|u_char
modifier|*
name|buf
parameter_list|,
specifier|register
name|int
name|cc
parameter_list|,
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|from
parameter_list|)
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|hlen
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|cc
operator|-=
name|hlen
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|Printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Printf
argument_list|(
literal|" %s (%s)"
argument_list|,
name|inetname
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|Printf
argument_list|(
literal|" %d bytes to %s"
argument_list|,
name|cc
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * Checksum routine for Internet Protocol family headers (C Version)  */
end_comment

begin_macro
name|in_cksum
argument_list|(
argument|register u_short *addr
argument_list|,
argument|register int len
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|nleft
init|=
name|len
decl_stmt|;
specifier|register
name|u_short
modifier|*
name|w
init|=
name|addr
decl_stmt|;
specifier|register
name|u_short
name|answer
decl_stmt|;
specifier|register
name|int
name|sum
init|=
literal|0
decl_stmt|;
comment|/* 	 *  Our algorithm is simple, using a 32 bit accumulator (sum), 	 *  we add sequential 16 bit words to it, and at the end, fold 	 *  back all the carry bits from the top 16 bits into the lower 	 *  16 bits. 	 */
while|while
condition|(
name|nleft
operator|>
literal|1
condition|)
block|{
name|sum
operator|+=
operator|*
name|w
operator|++
expr_stmt|;
name|nleft
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* mop up an odd byte, if necessary */
if|if
condition|(
name|nleft
operator|==
literal|1
condition|)
name|sum
operator|+=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|w
expr_stmt|;
comment|/* 	 * add back carry outs from top 16 bits to low 16 bits 	 */
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* add hi 16 to low 16 */
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* add carry */
name|answer
operator|=
operator|~
name|sum
expr_stmt|;
comment|/* truncate to 16 bits */
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Subtract 2 timeval structs:  out = out - in.  * Out is assumed to be within about LONG_MAX seconds of in.  */
end_comment

begin_function
name|void
name|tvsub
parameter_list|(
specifier|register
name|struct
name|timeval
modifier|*
name|out
parameter_list|,
specifier|register
name|struct
name|timeval
modifier|*
name|in
parameter_list|)
block|{
if|if
condition|(
operator|(
name|out
operator|->
name|tv_usec
operator|-=
name|in
operator|->
name|tv_usec
operator|)
operator|<
literal|0
condition|)
block|{
operator|--
name|out
operator|->
name|tv_sec
expr_stmt|;
name|out
operator|->
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|out
operator|->
name|tv_sec
operator|-=
name|in
operator|->
name|tv_sec
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct an Internet address representation.  * If the nflag has been supplied, give  * numeric value, otherwise try for symbolic name.  */
end_comment

begin_function
name|char
modifier|*
name|inetname
parameter_list|(
name|struct
name|in_addr
name|in
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|static
name|char
name|domain
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|,
name|line
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|first
operator|&&
operator|!
name|nflag
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|domain
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|domain
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|domain
argument_list|,
name|cp
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|domain
index|[
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nflag
operator|&&
name|in
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|in
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|domain
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|line
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|line
operator|)
return|;
block|}
block|}
return|return
operator|(
name|inet_ntoa
argument_list|(
name|in
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getaddr
parameter_list|(
specifier|register
name|u_int32_t
modifier|*
name|ap
parameter_list|,
specifier|register
name|char
modifier|*
name|hostname
parameter_list|)
block|{
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
operator|*
name|ap
operator|=
name|inet_addr
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int32_t
operator|)
operator|*
name|ap
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|hostname
operator|)
return|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown host %s\n"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
operator|||
name|hp
operator|->
name|h_length
operator|!=
literal|4
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad host %s\n"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ap
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|hp
operator|->
name|h_name
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getsin
parameter_list|(
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|,
specifier|register
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|memset
argument_list|(
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
return|return
operator|(
name|getaddr
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hostname
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|savestr
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: strdup: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|__dead
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|char
name|version
index|[]
decl_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Version %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-Sdnrv] [-w wait] [-m max_ttl] [-M min_ttl] \ [-P proto]\n\t [-p port#] [-q nqueries] [-t tos] [-s src_addr] [-g gateway] \ \n\t host [data_size]\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

