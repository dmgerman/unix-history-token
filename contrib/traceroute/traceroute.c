begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1991, 1994, 1995, 1996, 1997, 1998, 1999, 2000  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988, 1989, 1991, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n\ The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char rcsid[] =     "@(#)$Id: traceroute.c,v 1.68 2000/12/14 08:04:33 leres Exp $ (LBL)";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * traceroute host  - trace the route ip packets follow going to "host".  *  * Attempt to trace the route an ip packet would follow to some  * internet host.  We find out intermediate hops by launching probe  * packets with a small ttl (time to live) then listening for an  * icmp "time exceeded" reply from a gateway.  We start our probes  * with a ttl of one and increase by one until we get an icmp "port  * unreachable" (which means we got to "host") or hit a max (which  * defaults to net.inet.ip.ttl hops& can be changed with the -m flag).  * Three probes (change with -q flag) are sent at each ttl setting and  * a line is printed showing the ttl, address of the gateway and  * round trip time of each probe.  If the probe answers come from  * different gateways, the address of each responding system will  * be printed.  If there is no response within a 5 sec. timeout  * interval (changed with the -w flag), a "*" is printed for that  * probe.  *  * Probe packets are UDP format.  We don't want the destination  * host to process them so the destination port is set to an  * unlikely value (if some clod on the destination is using that  * value, it can be changed with the -p flag).  *  * A sample use might be:  *  *     [yak 71]% traceroute nis.nsf.net.  *     traceroute to nis.nsf.net (35.1.1.48), 64 hops max, 56 byte packet  *      1  helios.ee.lbl.gov (128.3.112.1)  19 ms  19 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  39 ms  *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  39 ms  39 ms  39 ms  *      6  128.32.197.4 (128.32.197.4)  40 ms  59 ms  59 ms  *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  59 ms  *      8  129.140.70.13 (129.140.70.13)  99 ms  99 ms  80 ms  *      9  129.140.71.6 (129.140.71.6)  139 ms  239 ms  319 ms  *     10  129.140.81.7 (129.140.81.7)  220 ms  199 ms  199 ms  *     11  nic.merit.edu (35.1.1.48)  239 ms  239 ms  239 ms  *  * Note that lines 2& 3 are the same.  This is due to a buggy  * kernel on the 2nd hop system -- lbl-csam.arpa -- that forwards  * packets with a zero ttl.  *  * A more interesting example is:  *  *     [yak 72]% traceroute allspice.lcs.mit.edu.  *     traceroute to allspice.lcs.mit.edu (18.26.0.115), 64 hops max  *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  19 ms  19 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  19 ms  39 ms  39 ms  *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  20 ms  39 ms  39 ms  *      6  128.32.197.4 (128.32.197.4)  59 ms  119 ms  39 ms  *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  39 ms  *      8  129.140.70.13 (129.140.70.13)  80 ms  79 ms  99 ms  *      9  129.140.71.6 (129.140.71.6)  139 ms  139 ms  159 ms  *     10  129.140.81.7 (129.140.81.7)  199 ms  180 ms  300 ms  *     11  129.140.72.17 (129.140.72.17)  300 ms  239 ms  239 ms  *     12  * * *  *     13  128.121.54.72 (128.121.54.72)  259 ms  499 ms  279 ms  *     14  * * *  *     15  * * *  *     16  * * *  *     17  * * *  *     18  ALLSPICE.LCS.MIT.EDU (18.26.0.115)  339 ms  279 ms  279 ms  *  * (I start to see why I'm having so much trouble with mail to  * MIT.)  Note that the gateways 12, 14, 15, 16& 17 hops away  * either don't send ICMP "time exceeded" messages or send them  * with a ttl too small to reach us.  14 - 17 are running the  * MIT C Gateway code that doesn't send "time exceeded"s.  God  * only knows what's going on with 12.  *  * The silent gateway 12 in the above may be the result of a bug in  * the 4.[23]BSD network code (and its derivatives):  4.x (x<= 3)  * sends an unreachable message using whatever ttl remains in the  * original datagram.  Since, for gateways, the remaining ttl is  * zero, the icmp "time exceeded" is guaranteed to not make it back  * to us.  The behavior of this bug is slightly more interesting  * when it appears on the destination system:  *  *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  39 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  39 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  19 ms  *      5  ccn-nerif35.Berkeley.EDU (128.32.168.35)  39 ms  39 ms  39 ms  *      6  csgw.Berkeley.EDU (128.32.133.254)  39 ms  59 ms  39 ms  *      7  * * *  *      8  * * *  *      9  * * *  *     10  * * *  *     11  * * *  *     12  * * *  *     13  rip.Berkeley.EDU (128.32.131.22)  59 ms !  39 ms !  39 ms !  *  * Notice that there are 12 "gateways" (13 is the final  * destination) and exactly the last half of them are "missing".  * What's really happening is that rip (a Sun-3 running Sun OS3.5)  * is using the ttl from our arriving datagram as the ttl in its  * icmp reply.  So, the reply will time out on the return path  * (with no notice sent to anyone since icmp's aren't sent for  * icmp's) until we probe with a ttl that's at least twice the path  * length.  I.e., rip is really only 7 hops away.  A reply that  * returns with a ttl of 1 is a clue this problem exists.  * Traceroute prints a "!" after the time if the ttl is<= 1.  * Since vendors ship a lot of obsolete (DEC's Ultrix, Sun 3.x) or  * non-standard (HPUX) software, expect to see this problem  * frequently and/or take care picking the target host of your  * probes.  *  * Other possible annotations after the time are !H, !N, !P (got a host,  * network or protocol unreachable, respectively), !S or !F (source  * route failed or fragmentation needed -- neither of these should  * ever occur and the associated gateway is busted if you see one).  If  * almost all the probes result in some kind of unreachable, traceroute  * will give up and exit.  *  * Notes  * -----  * This program must be run by root or be setuid.  (I suggest that  * you *don't* make it setuid -- casual use could result in a lot  * of unnecessary traffic on our poor, congested nets.)  *  * This program requires a kernel mod that does not appear in any  * system available from Berkeley:  A raw ip socket using proto  * IPPROTO_RAW must interpret the data sent as an ip datagram (as  * opposed to data to be wrapped in a ip datagram).  See the README  * file that came with the source to this program for a description  * of the mods I made to /sys/netinet/raw_ip.c.  Your mileage may  * vary.  But, again, ANY 4.x (x< 4) BSD KERNEL WILL HAVE TO BE  * MODIFIED TO RUN THIS PROGRAM.  *  * The udp port usage may appear bizarre (well, ok, it is bizarre).  * The problem is that an icmp message only contains 8 bytes of  * data from the original datagram.  8 bytes is the size of a udp  * header so, if we want to associate replies with the original  * datagram, the necessary information must be encoded into the  * udp header (the ip id could be used but there's no way to  * interlock with the kernel's assignment of ip id's and, anyway,  * it would have taken a lot more kernel hacking to allow this  * code to set the ip id).  So, to allow two or more users to  * use traceroute simultaneously, we use this task's pid as the  * source port (the high bit is set to move the port number out  * of the "likely" range).  To keep track of which probe is being  * replied to (so times and/or hop counts don't get confused by a  * reply that was delayed in transit), we increment the destination  * port number before each probe.  *  * Don't use this as a coding example.  I was trying to find a  * routing problem and this code sort-of popped out after 48 hours  * without sleep.  I was amazed it ever compiled, much less ran.  *  * I stole the idea for this program from Steve Deering.  Since  * the first release, I've learned that had I attended the right  * IETF working group meetings, I also could have stolen it from Guy  * Almes or Matt Mathis.  I don't know (or care) who came up with  * the idea first.  I envy the originators' perspicacity and I'm  * glad they didn't keep the idea a secret.  *  * Tim Seaver, Ken Adelman and C. Philip Wood provided bug fixes and/or  * enhancements to the original distribution.  *  * I've hacked up a round-trip-route version of this that works by  * sending a loose-source-routed udp datagram through the destination  * back to yourself.  Unfortunately, SO many gateways botch source  * routing, the thing is almost worthless.  Maybe one day...  *  *  -- Van Jacobson (van@ee.lbl.gov)  *     Tue Dec 20 03:50:13 PST 1988  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SELECT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SYSCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPSEC */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MALLOC_H
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* rfc1716 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ICMP_UNREACH_FILTER_PROHIB
end_ifndef

begin_define
define|#
directive|define
name|ICMP_UNREACH_FILTER_PROHIB
value|13
end_define

begin_comment
comment|/* admin prohibited filter */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ICMP_UNREACH_HOST_PRECEDENCE
end_ifndef

begin_define
define|#
directive|define
name|ICMP_UNREACH_HOST_PRECEDENCE
value|14
end_define

begin_comment
comment|/* host precedence violation */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ICMP_UNREACH_PRECEDENCE_CUTOFF
end_ifndef

begin_define
define|#
directive|define
name|ICMP_UNREACH_PRECEDENCE_CUTOFF
value|15
end_define

begin_comment
comment|/* precedence cutoff */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"findsaddr.h"
end_include

begin_include
include|#
directive|include
file|"ifaddrlist.h"
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"traceroute.h"
end_include

begin_comment
comment|/* Maximum number of gateways (include room for one noop) */
end_comment

begin_define
define|#
directive|define
name|NGATEWAYS
value|((int)((MAX_IPOPTLEN - IPOPT_MINOFF - 1) / sizeof(u_int32_t)))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHOSTNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXHOSTNAMELEN
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Fprintf
value|(void)fprintf
end_define

begin_define
define|#
directive|define
name|Printf
value|(void)printf
end_define

begin_comment
comment|/* What a GRE packet header looks like */
end_comment

begin_struct
struct|struct
name|grehdr
block|{
name|u_int16_t
name|flags
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int16_t
name|length
decl_stmt|;
comment|/* PPTP version of these fields */
name|u_int16_t
name|callId
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|IPPROTO_GRE
end_ifndef

begin_define
define|#
directive|define
name|IPPROTO_GRE
value|47
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For GRE, we prepare what looks like a PPTP packet */
end_comment

begin_define
define|#
directive|define
name|GRE_PPTP_PROTO
value|0x880b
end_define

begin_comment
comment|/* Host name and address list */
end_comment

begin_struct
struct|struct
name|hostinfo
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int32_t
modifier|*
name|addrs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Data section of the probe packet */
end_comment

begin_struct
struct|struct
name|outdata
block|{
name|u_char
name|seq
decl_stmt|;
comment|/* sequence number of this packet */
name|u_char
name|ttl
decl_stmt|;
comment|/* ttl packet left with */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* time packet left */
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ICMP_NEXTMTU
end_ifndef

begin_comment
comment|/* Path MTU Discovery (RFC1191) */
end_comment

begin_struct
struct|struct
name|my_pmtu
block|{
name|u_short
name|ipm_void
decl_stmt|;
name|u_short
name|ipm_nextmtu
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|u_char
name|packet
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last inbound (icmp) packet */
end_comment

begin_decl_stmt
name|struct
name|ip
modifier|*
name|outip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last output ip packet */
end_comment

begin_decl_stmt
name|u_char
modifier|*
name|outp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last output inner protocol packet */
end_comment

begin_decl_stmt
name|struct
name|ip
modifier|*
name|hip
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Quoted IP header */
end_comment

begin_decl_stmt
name|int
name|hiplen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* loose source route gateway list (including room for final destination) */
end_comment

begin_decl_stmt
name|u_int32_t
name|gwlist
index|[
name|NGATEWAYS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receive (icmp) socket file descriptor */
end_comment

begin_decl_stmt
name|int
name|sndsock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send (udp) socket file descriptor */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
name|whereto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Who to try to reach */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
name|wherefrom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Who we are */
end_comment

begin_decl_stmt
name|int
name|packlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total length of packet */
end_comment

begin_decl_stmt
name|int
name|protlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of protocol part of packet */
end_comment

begin_decl_stmt
name|int
name|minpacket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min ip packet size */
end_comment

begin_decl_stmt
name|int
name|maxpacket
init|=
literal|32
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max ip packet size */
end_comment

begin_decl_stmt
name|int
name|pmtu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Path MTU Discovery (RFC1191) */
end_comment

begin_decl_stmt
name|u_int
name|pausemsecs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|source
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|devnull
index|[]
init|=
literal|"/dev/null"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nprobes
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_ttl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first_ttl
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|ident
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* protocol specific base "port" */
end_comment

begin_decl_stmt
name|int
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket options */
end_comment

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|waittime
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time to wait for response (in seconds) */
end_comment

begin_decl_stmt
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print addresses numerically */
end_comment

begin_decl_stmt
name|int
name|as_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print as numbers for each hop */
end_comment

begin_decl_stmt
name|char
modifier|*
name|as_server
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|asn
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CANT_HACK_IPCKSUM
end_ifdef

begin_decl_stmt
name|int
name|doipcksum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't calculate ip checksums by default */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|doipcksum
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calculate ip checksums by default */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|optlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of ip options */
end_comment

begin_decl_stmt
name|int
name|fixedPort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use fixed destination port for TCP and UDP */
end_comment

begin_decl_stmt
name|int
name|printdiff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the difference between sent and quoted */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|opterr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forwards */
end_comment

begin_function_decl
name|double
name|deltaT
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|freehostinfo
parameter_list|(
name|struct
name|hostinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|getaddr
parameter_list|(
name|u_int32_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|hostinfo
modifier|*
name|gethostinfo
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_short
name|in_cksum
parameter_list|(
name|u_short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|inetname
parameter_list|(
name|struct
name|in_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_short
name|p_cksum
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|u_short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|packet_ok
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|pr_type
parameter_list|(
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_decl_stmt
name|int
name|setpolicy
name|__P
argument_list|(
operator|(
name|int
name|so
operator|,
name|char
operator|*
name|policy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|send_probe
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|outproto
modifier|*
name|setproto
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|str2val
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tvsub
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wait_for_reply
parameter_list|(
name|int
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pkt_compare
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_USLEEP
end_ifndef

begin_function_decl
name|int
name|usleep
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|udp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|udp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tcp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tcp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gre_prep
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gre_check
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gen_prep
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gen_check
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|icmp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|icmp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Descriptor structure for each outgoing protocol we support */
end_comment

begin_struct
struct|struct
name|outproto
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of protocol */
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
comment|/* An ascii key for the bytes of the header */
name|u_char
name|num
decl_stmt|;
comment|/* IP protocol number */
name|u_short
name|hdrlen
decl_stmt|;
comment|/* max size of protocol header */
name|u_short
name|port
decl_stmt|;
comment|/* default base protocol-specific "port" */
name|void
function_decl|(
modifier|*
name|prepare
function_decl|)
parameter_list|(
name|struct
name|outdata
modifier|*
parameter_list|)
function_decl|;
comment|/* finish preparing an outgoing packet */
name|int
function_decl|(
modifier|*
name|check
function_decl|)
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* check an incoming packet */
block|}
struct|;
end_struct

begin_comment
comment|/* List of supported protocols. The first one is the default. The last    one is the handler for generic protocols not explicitly listed. */
end_comment

begin_decl_stmt
name|struct
name|outproto
name|protos
index|[]
init|=
block|{
block|{
literal|"udp"
block|,
literal|"spt dpt len sum"
block|,
name|IPPROTO_UDP
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
block|,
literal|32768
operator|+
literal|666
block|,
name|udp_prep
block|,
name|udp_check
block|}
block|,
block|{
literal|"tcp"
block|,
literal|"spt dpt seq     ack     xxflwin sum urp"
block|,
name|IPPROTO_TCP
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
block|,
literal|32768
operator|+
literal|666
block|,
name|tcp_prep
block|,
name|tcp_check
block|}
block|,
block|{
literal|"gre"
block|,
literal|"flg pro len clid"
block|,
name|IPPROTO_GRE
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|grehdr
argument_list|)
block|,
name|GRE_PPTP_PROTO
block|,
name|gre_prep
block|,
name|gre_check
block|}
block|,
block|{
literal|"icmp"
block|,
literal|"typ cod sum "
block|,
name|IPPROTO_ICMP
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
block|,
literal|0
block|,
name|icmp_prep
block|,
name|icmp_check
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
block|,
literal|0
block|,
name|gen_prep
block|,
name|gen_check
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|outproto
modifier|*
name|proto
init|=
operator|&
name|protos
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ip_hdr_key
init|=
literal|"vhtslen id  off tlprsum srcip   dstip   opts"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|register
name|int
name|op
decl_stmt|,
name|code
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
specifier|register
name|u_int32_t
modifier|*
name|ap
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|from
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|wherefrom
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|to
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|whereto
decl_stmt|;
specifier|register
name|struct
name|hostinfo
modifier|*
name|hi
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
specifier|register
name|struct
name|protoent
modifier|*
name|pe
decl_stmt|;
specifier|register
name|int
name|ttl
decl_stmt|,
name|probe
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|int
name|seq
init|=
literal|0
decl_stmt|;
name|int
name|tos
init|=
literal|0
decl_stmt|,
name|settos
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|lsrr
init|=
literal|0
decl_stmt|;
specifier|register
name|u_short
name|off
init|=
literal|0
decl_stmt|;
name|struct
name|ifaddrlist
modifier|*
name|al
decl_stmt|;
name|char
name|errbuf
index|[
literal|132
index|]
decl_stmt|;
name|int
name|requestPort
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|sump
init|=
literal|0
decl_stmt|;
name|int
name|sockerrno
decl_stmt|;
comment|/* Insure the socket fds won't be 0, 1 or 2 */
if|if
condition|(
name|open
argument_list|(
name|devnull
argument_list|,
name|O_RDONLY
argument_list|)
operator|<
literal|0
operator|||
name|open
argument_list|(
name|devnull
argument_list|,
name|O_RDONLY
argument_list|)
operator|<
literal|0
operator|||
name|open
argument_list|(
name|devnull
argument_list|,
name|O_RDONLY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: open \"%s\": %s\n"
argument_list|,
name|prog
argument_list|,
name|devnull
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do the setuid-required stuff first, then lose priveleges ASAP. 	 * Do error checking for these two calls where they appeared in 	 * the original code. 	 */
name|cp
operator|=
literal|"icmp"
expr_stmt|;
name|pe
operator|=
name|getprotobyname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|pe
operator|->
name|p_proto
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|sockerrno
operator|=
name|errno
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sndsock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_RAW
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|sockerrno
operator|=
name|errno
expr_stmt|;
block|}
if|if
condition|(
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"setuid()"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPCTL_DEFTTL
block|{
name|int
name|mib
index|[
literal|4
index|]
init|=
block|{
name|CTL_NET
block|,
name|PF_INET
block|,
name|IPPROTO_IP
block|,
name|IPCTL_DEFTTL
block|}
decl_stmt|;
name|size_t
name|sz
init|=
sizeof|sizeof
argument_list|(
name|max_ttl
argument_list|)
decl_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|4
argument_list|,
operator|&
name|max_ttl
argument_list|,
operator|&
name|sz
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"sysctl(net.inet.ip.ttl)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|max_ttl
operator|=
literal|30
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|prog
operator|=
literal|"traceroute"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|prog
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
else|else
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aA:edDFInrSvxf:g:i:M:m:P:p:q:s:t:w:z:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'a'
case|:
name|as_path
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|as_path
operator|=
literal|1
expr_stmt|;
name|as_server
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|options
operator||=
name|SO_DEBUG
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|printdiff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|fixedPort
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'M'
case|:
comment|/* FreeBSD compat. */
name|first_ttl
operator|=
name|str2val
argument_list|(
name|optarg
argument_list|,
literal|"first ttl"
argument_list|,
literal|1
argument_list|,
literal|255
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|off
operator|=
name|IP_DF
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|lsrr
operator|>=
name|NGATEWAYS
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: No more than %d gateways\n"
argument_list|,
name|prog
argument_list|,
name|NGATEWAYS
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|getaddr
argument_list|(
name|gwlist
operator|+
name|lsrr
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
operator|++
name|lsrr
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|device
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|proto
operator|=
name|setproto
argument_list|(
literal|"icmp"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|max_ttl
operator|=
name|str2val
argument_list|(
name|optarg
argument_list|,
literal|"max ttl"
argument_list|,
literal|1
argument_list|,
literal|255
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|++
name|nflag
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|proto
operator|=
name|setproto
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|requestPort
operator|=
operator|(
name|u_short
operator|)
name|str2val
argument_list|(
name|optarg
argument_list|,
literal|"port"
argument_list|,
literal|1
argument_list|,
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|nprobes
operator|=
name|str2val
argument_list|(
name|optarg
argument_list|,
literal|"nprobes"
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|options
operator||=
name|SO_DONTROUTE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* 			 * set the ip source address of the outbound 			 * probe (e.g., on a multi-homed host). 			 */
name|source
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|sump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tos
operator|=
name|str2val
argument_list|(
name|optarg
argument_list|,
literal|"tos"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
operator|++
name|settos
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|++
name|verbose
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|doipcksum
operator|=
operator|(
name|doipcksum
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|waittime
operator|=
name|str2val
argument_list|(
name|optarg
argument_list|,
literal|"wait time"
argument_list|,
literal|1
argument_list|,
literal|24
operator|*
literal|60
operator|*
literal|60
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|pausemsecs
operator|=
name|str2val
argument_list|(
name|optarg
argument_list|,
literal|"pause msecs"
argument_list|,
literal|0
argument_list|,
literal|60
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* Set requested port, if any, else default for this protocol */
name|port
operator|=
operator|(
name|requestPort
operator|!=
operator|-
literal|1
operator|)
condition|?
name|requestPort
else|:
name|proto
operator|->
name|port
expr_stmt|;
if|if
condition|(
name|nprobes
operator|==
operator|-
literal|1
condition|)
name|nprobes
operator|=
name|printdiff
condition|?
literal|1
else|:
literal|3
expr_stmt|;
if|if
condition|(
name|first_ttl
operator|>
name|max_ttl
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: first ttl (%d) may not be greater than max ttl (%d)\n"
argument_list|,
name|prog
argument_list|,
name|first_ttl
argument_list|,
name|max_ttl
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doipcksum
condition|)
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Warning: ip checksums disabled\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsrr
operator|>
literal|0
condition|)
name|optlen
operator|=
operator|(
name|lsrr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|gwlist
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|minpacket
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|outip
argument_list|)
operator|+
name|proto
operator|->
name|hdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|outdata
argument_list|)
operator|+
name|optlen
expr_stmt|;
name|packlen
operator|=
name|minpacket
expr_stmt|;
comment|/* minimum sized packet */
comment|/* Process destination and optional packet size */
switch|switch
condition|(
name|argc
operator|-
name|optind
condition|)
block|{
case|case
literal|2
case|:
name|packlen
operator|=
name|str2val
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
literal|"packet length"
argument_list|,
name|minpacket
argument_list|,
name|maxpacket
argument_list|)
expr_stmt|;
comment|/* Fall through */
case|case
literal|1
case|:
name|hostname
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|hi
operator|=
name|gethostinfo
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|setsin
argument_list|(
name|to
argument_list|,
name|hi
operator|->
name|addrs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|n
operator|>
literal|1
condition|)
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Warning: %s has multiple addresses; using %s\n"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|to
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|hi
operator|->
name|name
expr_stmt|;
name|hi
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|freehostinfo
argument_list|(
name|hi
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SETLINEBUF
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
else|#
directive|else
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|protlen
operator|=
name|packlen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|outip
argument_list|)
operator|-
name|optlen
expr_stmt|;
name|outip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|packlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|outip
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: malloc: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outip
argument_list|,
literal|0
argument_list|,
name|packlen
argument_list|)
expr_stmt|;
name|outip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
if|if
condition|(
name|settos
condition|)
name|outip
operator|->
name|ip_tos
operator|=
name|tos
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTESWAP_IP_HDR
name|outip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|packlen
argument_list|)
expr_stmt|;
name|outip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|off
argument_list|)
expr_stmt|;
else|#
directive|else
name|outip
operator|->
name|ip_len
operator|=
name|packlen
expr_stmt|;
name|outip
operator|->
name|ip_off
operator|=
name|off
expr_stmt|;
endif|#
directive|endif
name|outip
operator|->
name|ip_p
operator|=
name|proto
operator|->
name|num
expr_stmt|;
name|outp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|outip
operator|+
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RAW_OPTIONS
if|if
condition|(
name|lsrr
operator|>
literal|0
condition|)
block|{
specifier|register
name|u_char
modifier|*
name|optlist
decl_stmt|;
name|optlist
operator|=
name|outp
expr_stmt|;
name|outp
operator|+=
name|optlen
expr_stmt|;
comment|/* final hop */
name|gwlist
index|[
name|lsrr
index|]
operator|=
name|to
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|outip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|gwlist
index|[
literal|0
index|]
expr_stmt|;
comment|/* force 4 byte alignment */
name|optlist
index|[
literal|0
index|]
operator|=
name|IPOPT_NOP
expr_stmt|;
comment|/* loose source route option */
name|optlist
index|[
literal|1
index|]
operator|=
name|IPOPT_LSRR
expr_stmt|;
name|i
operator|=
name|lsrr
operator|*
sizeof|sizeof
argument_list|(
name|gwlist
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|optlist
index|[
literal|2
index|]
operator|=
name|i
operator|+
literal|3
expr_stmt|;
comment|/* Pointer to LSRR addresses */
name|optlist
index|[
literal|3
index|]
operator|=
name|IPOPT_MINOFF
expr_stmt|;
name|memcpy
argument_list|(
name|optlist
operator|+
literal|4
argument_list|,
name|gwlist
operator|+
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|outip
operator|->
name|ip_dst
operator|=
name|to
operator|->
name|sin_addr
expr_stmt|;
name|outip
operator|->
name|ip_hl
operator|=
operator|(
name|outp
operator|-
operator|(
name|u_char
operator|*
operator|)
name|outip
operator|)
operator|>>
literal|2
expr_stmt|;
name|ident
operator|=
operator|(
name|getpid
argument_list|()
operator|&
literal|0xffff
operator|)
operator||
literal|0x8000
expr_stmt|;
if|if
condition|(
name|pe
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown protocol %s\n"
argument_list|,
name|prog
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|sockerrno
expr_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: icmp socket: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SO_DONTROUTE
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DONTROUTE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPSEC_POLICY_IPSEC
argument_list|)
if|if
condition|(
name|setpolicy
argument_list|(
name|s
argument_list|,
literal|"in bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|setpolicy
argument_list|(
name|s
argument_list|,
literal|"out bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(IPSEC)&& defined(IPSEC_POLICY_IPSEC) */
if|if
condition|(
name|sndsock
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|sockerrno
expr_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: raw socket: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|IP_OPTIONS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_RAW_OPTIONS
argument_list|)
if|if
condition|(
name|lsrr
operator|>
literal|0
condition|)
block|{
name|u_char
name|optlist
index|[
name|MAX_IPOPTLEN
index|]
decl_stmt|;
name|cp
operator|=
literal|"ip"
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|getprotobyname
argument_list|(
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown protocol %s\n"
argument_list|,
name|prog
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* final hop */
name|gwlist
index|[
name|lsrr
index|]
operator|=
name|to
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
operator|++
name|lsrr
expr_stmt|;
comment|/* force 4 byte alignment */
name|optlist
index|[
literal|0
index|]
operator|=
name|IPOPT_NOP
expr_stmt|;
comment|/* loose source route option */
name|optlist
index|[
literal|1
index|]
operator|=
name|IPOPT_LSRR
expr_stmt|;
name|i
operator|=
name|lsrr
operator|*
sizeof|sizeof
argument_list|(
name|gwlist
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|optlist
index|[
literal|2
index|]
operator|=
name|i
operator|+
literal|3
expr_stmt|;
comment|/* Pointer to LSRR addresses */
name|optlist
index|[
literal|3
index|]
operator|=
name|IPOPT_MINOFF
expr_stmt|;
name|memcpy
argument_list|(
name|optlist
operator|+
literal|4
argument_list|,
name|gwlist
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|pe
operator|->
name|p_proto
argument_list|,
name|IP_OPTIONS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|optlist
argument_list|,
name|i
operator|+
sizeof|sizeof
argument_list|(
name|gwlist
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: IP_OPTIONS: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_SNDBUF
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|packlen
argument_list|,
sizeof|sizeof
argument_list|(
name|packlen
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: SO_SNDBUF: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IP_HDRINCL
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_HDRINCL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: IP_HDRINCL: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|IP_TOS
if|if
condition|(
name|settos
operator|&&
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TOS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tos
argument_list|,
sizeof|sizeof
argument_list|(
name|tos
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: setsockopt tos %d: %s\n"
argument_list|,
name|prog
argument_list|,
name|tos
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SO_DONTROUTE
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DONTROUTE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the interface address list */
name|n
operator|=
name|ifaddrlist
argument_list|(
operator|&
name|al
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ifaddrlist: %s\n"
argument_list|,
name|prog
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't find any network interfaces\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Look for a specific device */
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
operator|++
name|al
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|device
argument_list|,
name|al
operator|->
name|device
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't find interface %.32s\n"
argument_list|,
name|prog
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Determine our source address */
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If a device was specified, use the interface address. 		 * Otherwise, try to determine our source address. 		 */
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
name|setsin
argument_list|(
name|from
argument_list|,
name|al
operator|->
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|err
operator|=
name|findsaddr
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: findsaddr: %s\n"
argument_list|,
name|prog
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hi
operator|=
name|gethostinfo
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|source
operator|=
name|hi
operator|->
name|name
expr_stmt|;
name|hi
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * If the device was specified make sure it 		 * corresponds to the source address specified. 		 * Otherwise, use the first address (and warn if 		 * there are more than one). 		 */
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|hi
operator|->
name|n
operator|,
name|ap
operator|=
name|hi
operator|->
name|addrs
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
operator|++
name|ap
control|)
if|if
condition|(
operator|*
name|ap
operator|==
name|al
operator|->
name|addr
condition|)
break|break;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is not on interface %.32s\n"
argument_list|,
name|prog
argument_list|,
name|source
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setsin
argument_list|(
name|from
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setsin
argument_list|(
name|from
argument_list|,
name|hi
operator|->
name|addrs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|n
operator|>
literal|1
condition|)
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Warning: %s has multiple addresses; using %s\n"
argument_list|,
name|prog
argument_list|,
name|source
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|freehostinfo
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
name|outip
operator|->
name|ip_src
operator|=
name|from
operator|->
name|sin_addr
expr_stmt|;
comment|/* Check the source address (-s), if any, is valid */
if|if
condition|(
name|bind
argument_list|(
name|sndsock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bind: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|as_path
condition|)
block|{
name|asn
operator|=
name|as_setup
argument_list|(
name|as_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|asn
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: as_setup failed, AS# lookups"
literal|" disabled\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|as_path
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPSEC_POLICY_IPSEC
argument_list|)
if|if
condition|(
name|setpolicy
argument_list|(
name|sndsock
argument_list|,
literal|"in bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|setpolicy
argument_list|(
name|sndsock
argument_list|,
literal|"out bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(IPSEC)&& defined(IPSEC_POLICY_IPSEC) */
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s to %s (%s)"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|to
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
condition|)
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|" from %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|", %d hops max, %d byte packets\n"
argument_list|,
name|max_ttl
argument_list|,
name|packlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|ttl
operator|=
name|first_ttl
init|;
name|ttl
operator|<=
name|max_ttl
condition|;
operator|++
name|ttl
control|)
block|{
name|u_int32_t
name|lastaddr
init|=
literal|0
decl_stmt|;
name|int
name|gotlastaddr
init|=
literal|0
decl_stmt|;
name|int
name|got_there
init|=
literal|0
decl_stmt|;
name|int
name|unreachable
init|=
literal|0
decl_stmt|;
name|int
name|sentfirst
init|=
literal|0
decl_stmt|;
name|int
name|loss
decl_stmt|;
name|Printf
argument_list|(
literal|"%2d "
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
for|for
control|(
name|probe
operator|=
literal|0
operator|,
name|loss
operator|=
literal|0
init|;
name|probe
operator|<
name|nprobes
condition|;
operator|++
name|probe
control|)
block|{
specifier|register
name|int
name|cc
decl_stmt|;
name|struct
name|timeval
name|t1
decl_stmt|,
name|t2
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|outdata
name|outdata
decl_stmt|;
if|if
condition|(
name|sentfirst
operator|&&
name|pausemsecs
operator|>
literal|0
condition|)
name|usleep
argument_list|(
name|pausemsecs
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Prepare outgoing data */
name|outdata
operator|.
name|seq
operator|=
operator|++
name|seq
expr_stmt|;
name|outdata
operator|.
name|ttl
operator|=
name|ttl
expr_stmt|;
comment|/* Avoid alignment problems by copying bytewise: */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|outdata
operator|.
name|tv
argument_list|,
operator|&
name|t1
argument_list|,
sizeof|sizeof
argument_list|(
name|outdata
operator|.
name|tv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finalize and send packet */
call|(
modifier|*
name|proto
operator|->
name|prepare
call|)
argument_list|(
operator|&
name|outdata
argument_list|)
expr_stmt|;
name|send_probe
argument_list|(
name|seq
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
operator|++
name|sentfirst
expr_stmt|;
comment|/* Wait for a reply */
while|while
condition|(
operator|(
name|cc
operator|=
name|wait_for_reply
argument_list|(
name|s
argument_list|,
name|from
argument_list|,
operator|&
name|t1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|double
name|T
decl_stmt|;
name|int
name|precis
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|i
operator|=
name|packet_ok
argument_list|(
name|packet
argument_list|,
name|cc
argument_list|,
name|from
argument_list|,
name|seq
argument_list|)
expr_stmt|;
comment|/* Skip short packet */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|gotlastaddr
operator|||
name|from
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|lastaddr
condition|)
block|{
if|if
condition|(
name|gotlastaddr
condition|)
name|printf
argument_list|(
literal|"\n   "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|packet
argument_list|,
name|cc
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|lastaddr
operator|=
name|from
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
operator|++
name|gotlastaddr
expr_stmt|;
block|}
name|T
operator|=
name|deltaT
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SANE_PRECISION
if|if
condition|(
name|T
operator|>=
literal|1000.0
condition|)
name|precis
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|T
operator|>=
literal|100.0
condition|)
name|precis
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|T
operator|>=
literal|10.0
condition|)
name|precis
operator|=
literal|2
expr_stmt|;
else|else
endif|#
directive|endif
name|precis
operator|=
literal|3
expr_stmt|;
name|Printf
argument_list|(
literal|"  %.*f ms"
argument_list|,
name|precis
argument_list|,
name|T
argument_list|)
expr_stmt|;
if|if
condition|(
name|printdiff
condition|)
block|{
name|Printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%*.*s%s\n"
argument_list|,
operator|-
operator|(
name|outip
operator|->
name|ip_hl
operator|<<
literal|3
operator|)
argument_list|,
name|outip
operator|->
name|ip_hl
operator|<<
literal|3
argument_list|,
name|ip_hdr_key
argument_list|,
name|proto
operator|->
name|key
argument_list|)
expr_stmt|;
name|pkt_compare
argument_list|(
operator|(
name|void
operator|*
operator|)
name|outip
argument_list|,
name|packlen
argument_list|,
operator|(
name|void
operator|*
operator|)
name|hip
argument_list|,
name|hiplen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
block|{
ifndef|#
directive|ifndef
name|ARCHAIC
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|packet
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
literal|1
condition|)
name|Printf
argument_list|(
literal|" !"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|got_there
expr_stmt|;
break|break;
block|}
comment|/* time exceeded in transit */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
name|code
operator|=
name|i
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ICMP_UNREACH_PORT
case|:
ifndef|#
directive|ifndef
name|ARCHAIC
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|packet
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
literal|1
condition|)
name|Printf
argument_list|(
literal|" !"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|got_there
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NET
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !N"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_HOST
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !H"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_PROTOCOL
case|:
operator|++
name|got_there
expr_stmt|;
name|Printf
argument_list|(
literal|" !P"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NEEDFRAG
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !F-%d"
argument_list|,
name|pmtu
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_SRCFAIL
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !S"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NET_UNKNOWN
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !U"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_HOST_UNKNOWN
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !W"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_ISOLATED
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !I"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NET_PROHIB
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !A"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_HOST_PROHIB
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !Z"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_TOSNET
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !Q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_TOSHOST
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !T"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_FILTER_PROHIB
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !X"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_HOST_PRECEDENCE
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !V"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_PRECEDENCE_CUTOFF
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !C"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !<%d>"
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|loss
operator|++
expr_stmt|;
name|Printf
argument_list|(
literal|" *"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sump
condition|)
block|{
name|Printf
argument_list|(
literal|" (%d%% loss)"
argument_list|,
operator|(
name|loss
operator|*
literal|100
operator|)
operator|/
name|nprobes
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_there
operator|||
operator|(
name|unreachable
operator|>
literal|0
operator|&&
name|unreachable
operator|>=
name|nprobes
operator|-
literal|1
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|as_path
condition|)
name|as_shutdown
argument_list|(
name|asn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|wait_for_reply
parameter_list|(
specifier|register
name|int
name|sock
parameter_list|,
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|fromp
parameter_list|,
specifier|register
specifier|const
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
block|{
name|fd_set
modifier|*
name|fdsp
decl_stmt|;
name|size_t
name|nfds
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|wait
decl_stmt|;
specifier|register
name|int
name|cc
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
name|int
name|fromlen
init|=
sizeof|sizeof
argument_list|(
operator|*
name|fromp
argument_list|)
decl_stmt|;
name|nfds
operator|=
name|howmany
argument_list|(
name|sock
operator|+
literal|1
argument_list|,
name|NFDBITS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdsp
operator|=
name|malloc
argument_list|(
name|nfds
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fdsp
argument_list|,
literal|0
argument_list|,
name|nfds
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sock
argument_list|,
name|fdsp
argument_list|)
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|=
name|tp
operator|->
name|tv_sec
operator|+
name|waittime
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
name|tp
operator|->
name|tv_usec
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tvsub
argument_list|(
operator|&
name|wait
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|.
name|tv_sec
operator|<
literal|0
condition|)
block|{
name|wait
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|1
expr_stmt|;
block|}
name|error
operator|=
name|select
argument_list|(
name|sock
operator|+
literal|1
argument_list|,
name|fdsp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: botched select() args\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|>
literal|0
condition|)
name|cc
operator|=
name|recvfrom
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|fromp
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fdsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|send_probe
parameter_list|(
name|int
name|seq
parameter_list|,
name|int
name|ttl
parameter_list|)
block|{
specifier|register
name|int
name|cc
decl_stmt|;
name|outip
operator|->
name|ip_ttl
operator|=
name|ttl
expr_stmt|;
name|outip
operator|->
name|ip_id
operator|=
name|htons
argument_list|(
name|ident
operator|+
name|seq
argument_list|)
expr_stmt|;
comment|/* XXX undocumented debugging hack */
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
specifier|register
specifier|const
name|u_short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|nshorts
decl_stmt|,
name|i
decl_stmt|;
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|outip
expr_stmt|;
name|nshorts
operator|=
operator|(
name|u_int
operator|)
name|packlen
operator|/
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|Printf
argument_list|(
literal|"[ %d bytes"
argument_list|,
name|packlen
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nshorts
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|++
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|Printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|" %04x"
argument_list|,
name|ntohs
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|packlen
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|Printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
operator|(
name|u_char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IP_HDRINCL
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_TTL
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TTL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: setsockopt ttl %d: %s\n"
argument_list|,
name|prog
argument_list|,
name|ttl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cc
operator|=
name|sendto
argument_list|(
name|sndsock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outip
argument_list|,
name|packlen
argument_list|,
literal|0
argument_list|,
operator|&
name|whereto
argument_list|,
sizeof|sizeof
argument_list|(
name|whereto
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
operator|||
name|cc
operator|!=
name|packlen
condition|)
block|{
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: sendto: %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%s: wrote %s %d chars, ret=%d\n"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|,
name|packlen
argument_list|,
name|cc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPSEC_POLICY_IPSEC
argument_list|)
end_if

begin_function
name|int
name|setpolicy
parameter_list|(
name|so
parameter_list|,
name|policy
parameter_list|)
name|int
name|so
decl_stmt|;
name|char
modifier|*
name|policy
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|ipsec_set_policy
argument_list|(
name|policy
argument_list|,
name|strlen
argument_list|(
name|policy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|so
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_IPSEC_POLICY
argument_list|,
name|buf
argument_list|,
name|ipsec_get_policylen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|double
name|deltaT
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1p
parameter_list|,
name|struct
name|timeval
modifier|*
name|t2p
parameter_list|)
block|{
specifier|register
name|double
name|dt
decl_stmt|;
name|dt
operator|=
call|(
name|double
call|)
argument_list|(
name|t2p
operator|->
name|tv_sec
operator|-
name|t1p
operator|->
name|tv_sec
argument_list|)
operator|*
literal|1000.0
operator|+
call|(
name|double
call|)
argument_list|(
name|t2p
operator|->
name|tv_usec
operator|-
name|t1p
operator|->
name|tv_usec
argument_list|)
operator|/
literal|1000.0
expr_stmt|;
return|return
operator|(
name|dt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an ICMP "type" field to a printable string.  */
end_comment

begin_function
name|char
modifier|*
name|pr_type
parameter_list|(
specifier|register
name|u_char
name|t
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|ttab
index|[]
init|=
block|{
literal|"Echo Reply"
block|,
literal|"ICMP 1"
block|,
literal|"ICMP 2"
block|,
literal|"Dest Unreachable"
block|,
literal|"Source Quench"
block|,
literal|"Redirect"
block|,
literal|"ICMP 6"
block|,
literal|"ICMP 7"
block|,
literal|"Echo"
block|,
literal|"ICMP 9"
block|,
literal|"ICMP 10"
block|,
literal|"Time Exceeded"
block|,
literal|"Param Problem"
block|,
literal|"Timestamp"
block|,
literal|"Timestamp Reply"
block|,
literal|"Info Request"
block|,
literal|"Info Reply"
block|}
decl_stmt|;
if|if
condition|(
name|t
operator|>
literal|16
condition|)
return|return
operator|(
literal|"OUT-OF-RANGE"
operator|)
return|;
return|return
operator|(
name|ttab
index|[
name|t
index|]
operator|)
return|;
block|}
end_function

begin_function
name|int
name|packet_ok
parameter_list|(
specifier|register
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|cc
parameter_list|,
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|from
parameter_list|,
specifier|register
name|int
name|seq
parameter_list|)
block|{
specifier|register
name|struct
name|icmp
modifier|*
name|icp
decl_stmt|;
specifier|register
name|u_char
name|type
decl_stmt|,
name|code
decl_stmt|;
specifier|register
name|int
name|hlen
decl_stmt|;
ifndef|#
directive|ifndef
name|ARCHAIC
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|cc
operator|<
name|hlen
operator|+
name|ICMP_MINLEN
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|Printf
argument_list|(
literal|"packet too short (%d bytes) from %s\n"
argument_list|,
name|cc
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cc
operator|-=
name|hlen
expr_stmt|;
name|icp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
name|buf
operator|+
name|hlen
operator|)
expr_stmt|;
else|#
directive|else
name|icp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|buf
expr_stmt|;
endif|#
directive|endif
name|type
operator|=
name|icp
operator|->
name|icmp_type
expr_stmt|;
name|code
operator|=
name|icp
operator|->
name|icmp_code
expr_stmt|;
comment|/* Path MTU Discovery (RFC1191) */
if|if
condition|(
name|code
operator|!=
name|ICMP_UNREACH_NEEDFRAG
condition|)
name|pmtu
operator|=
literal|0
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_ICMP_NEXTMTU
name|pmtu
operator|=
name|ntohs
argument_list|(
name|icp
operator|->
name|icmp_nextmtu
argument_list|)
expr_stmt|;
else|#
directive|else
name|pmtu
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|my_pmtu
operator|*
operator|)
operator|&
name|icp
operator|->
name|icmp_void
operator|)
operator|->
name|ipm_nextmtu
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|type
operator|==
name|ICMP_ECHOREPLY
operator|&&
name|proto
operator|->
name|num
operator|==
name|IPPROTO_ICMP
operator|&&
call|(
modifier|*
name|proto
operator|->
name|check
call|)
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|icp
argument_list|,
operator|(
name|u_char
operator|)
name|seq
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
operator|(
name|type
operator|==
name|ICMP_TIMXCEED
operator|&&
name|code
operator|==
name|ICMP_TIMXCEED_INTRANS
operator|)
operator|||
name|type
operator|==
name|ICMP_UNREACH
condition|)
block|{
name|u_char
modifier|*
name|inner
decl_stmt|;
name|hip
operator|=
operator|&
name|icp
operator|->
name|icmp_ip
expr_stmt|;
name|hiplen
operator|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|icp
operator|+
name|cc
operator|)
operator|-
operator|(
name|u_char
operator|*
operator|)
name|hip
expr_stmt|;
name|hlen
operator|=
name|hip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|inner
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|hip
operator|+
name|hlen
operator|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|+
literal|12
operator|<=
name|cc
operator|&&
name|hip
operator|->
name|ip_p
operator|==
name|proto
operator|->
name|num
operator|&&
call|(
modifier|*
name|proto
operator|->
name|check
call|)
argument_list|(
name|inner
argument_list|,
operator|(
name|u_char
operator|)
name|seq
argument_list|)
condition|)
return|return
operator|(
name|type
operator|==
name|ICMP_TIMXCEED
condition|?
operator|-
literal|1
else|:
name|code
operator|+
literal|1
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|ARCHAIC
if|if
condition|(
name|verbose
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|u_int32_t
modifier|*
name|lp
init|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|icp
operator|->
name|icmp_ip
decl_stmt|;
name|Printf
argument_list|(
literal|"\n%d bytes from %s to "
argument_list|,
name|cc
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%s: icmp type %d (%s) code %d\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|,
name|type
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|icp
operator|->
name|icmp_code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|cc
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
control|)
name|Printf
argument_list|(
literal|"%2d: x%8.8x\n"
argument_list|,
name|i
argument_list|,
operator|*
name|lp
operator|++
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|icmp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
name|outdata
parameter_list|)
block|{
name|struct
name|icmp
modifier|*
specifier|const
name|icmpheader
init|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|outp
decl_stmt|;
name|icmpheader
operator|->
name|icmp_type
operator|=
name|ICMP_ECHO
expr_stmt|;
name|icmpheader
operator|->
name|icmp_id
operator|=
name|htons
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|icmpheader
operator|->
name|icmp_seq
operator|=
name|htons
argument_list|(
name|outdata
operator|->
name|seq
argument_list|)
expr_stmt|;
name|icmpheader
operator|->
name|icmp_cksum
operator|=
literal|0
expr_stmt|;
name|icmpheader
operator|->
name|icmp_cksum
operator|=
name|in_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|icmpheader
argument_list|,
name|protlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmpheader
operator|->
name|icmp_cksum
operator|==
literal|0
condition|)
name|icmpheader
operator|->
name|icmp_cksum
operator|=
literal|0xffff
expr_stmt|;
block|}
end_function

begin_function
name|int
name|icmp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|icmp
modifier|*
specifier|const
name|icmpheader
init|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|icmpheader
operator|->
name|icmp_id
operator|==
name|htons
argument_list|(
name|ident
argument_list|)
operator|&&
name|icmpheader
operator|->
name|icmp_seq
operator|==
name|htons
argument_list|(
name|seq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|udp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
name|outdata
parameter_list|)
block|{
name|struct
name|udphdr
modifier|*
specifier|const
name|outudp
init|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|outp
decl_stmt|;
name|outudp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|ident
operator|+
operator|(
name|fixedPort
condition|?
name|outdata
operator|->
name|seq
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|outudp
operator|->
name|uh_dport
operator|=
name|htons
argument_list|(
name|port
operator|+
operator|(
name|fixedPort
condition|?
literal|0
else|:
name|outdata
operator|->
name|seq
operator|)
argument_list|)
expr_stmt|;
name|outudp
operator|->
name|uh_ulen
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|protlen
argument_list|)
expr_stmt|;
name|outudp
operator|->
name|uh_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doipcksum
condition|)
block|{
name|u_short
name|sum
init|=
name|p_cksum
argument_list|(
name|outip
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|outudp
argument_list|,
name|protlen
argument_list|)
decl_stmt|;
name|outudp
operator|->
name|uh_sum
operator|=
operator|(
name|sum
operator|)
condition|?
name|sum
else|:
literal|0xffff
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|int
name|udp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|udphdr
modifier|*
specifier|const
name|udp
init|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_sport
argument_list|)
operator|==
name|ident
operator|+
operator|(
name|fixedPort
condition|?
name|seq
else|:
literal|0
operator|)
operator|&&
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_dport
argument_list|)
operator|==
name|port
operator|+
operator|(
name|fixedPort
condition|?
literal|0
else|:
name|seq
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tcp_prep
parameter_list|(
name|struct
name|outdata
modifier|*
name|outdata
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
specifier|const
name|tcp
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|outp
decl_stmt|;
name|tcp
operator|->
name|th_sport
operator|=
name|htons
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|th_dport
operator|=
name|htons
argument_list|(
name|port
operator|+
operator|(
name|fixedPort
condition|?
literal|0
else|:
name|outdata
operator|->
name|seq
operator|)
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|th_seq
operator|=
operator|(
name|tcp
operator|->
name|th_sport
operator|<<
literal|16
operator|)
operator||
name|tcp
operator|->
name|th_dport
expr_stmt|;
name|tcp
operator|->
name|th_ack
operator|=
literal|0
expr_stmt|;
name|tcp
operator|->
name|th_off
operator|=
literal|5
expr_stmt|;
name|tcp
operator|->
name|th_flags
operator|=
name|TH_SYN
expr_stmt|;
name|tcp
operator|->
name|th_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doipcksum
condition|)
block|{
name|u_short
name|sum
init|=
name|p_cksum
argument_list|(
name|outip
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|tcp
argument_list|,
name|protlen
argument_list|)
decl_stmt|;
name|tcp
operator|->
name|th_sum
operator|=
operator|(
name|sum
operator|)
condition|?
name|sum
else|:
literal|0xffff
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|tcp_check
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
specifier|const
name|tcp
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_sport
argument_list|)
operator|==
name|ident
operator|&&
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_dport
argument_list|)
operator|==
name|port
operator|+
operator|(
name|fixedPort
condition|?
literal|0
else|:
name|seq
operator|)
operator|&&
name|tcp
operator|->
name|th_seq
operator|==
call|(
name|tcp_seq
call|)
argument_list|(
operator|(
name|tcp
operator|->
name|th_sport
operator|<<
literal|16
operator|)
operator||
name|tcp
operator|->
name|th_dport
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gre_prep
parameter_list|(
name|struct
name|outdata
modifier|*
name|outdata
parameter_list|)
block|{
name|struct
name|grehdr
modifier|*
specifier|const
name|gre
init|=
operator|(
expr|struct
name|grehdr
operator|*
operator|)
name|outp
decl_stmt|;
name|gre
operator|->
name|flags
operator|=
name|htons
argument_list|(
literal|0x2001
argument_list|)
expr_stmt|;
name|gre
operator|->
name|proto
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|gre
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|gre
operator|->
name|callId
operator|=
name|htons
argument_list|(
name|ident
operator|+
name|outdata
operator|->
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gre_check
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|grehdr
modifier|*
specifier|const
name|gre
init|=
operator|(
expr|struct
name|grehdr
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|ntohs
argument_list|(
name|gre
operator|->
name|proto
argument_list|)
operator|==
name|port
operator|&&
name|ntohs
argument_list|(
name|gre
operator|->
name|callId
argument_list|)
operator|==
name|ident
operator|+
name|seq
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gen_prep
parameter_list|(
name|struct
name|outdata
modifier|*
name|outdata
parameter_list|)
block|{
name|u_int16_t
modifier|*
specifier|const
name|ptr
init|=
operator|(
name|u_int16_t
operator|*
operator|)
name|outp
decl_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|port
operator|+
name|outdata
operator|->
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gen_check
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|u_int16_t
modifier|*
specifier|const
name|ptr
init|=
operator|(
name|u_int16_t
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|ntohs
argument_list|(
name|ptr
index|[
literal|0
index|]
argument_list|)
operator|==
name|ident
operator|&&
name|ntohs
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|==
name|port
operator|+
name|seq
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print
parameter_list|(
specifier|register
name|u_char
modifier|*
name|buf
parameter_list|,
specifier|register
name|int
name|cc
parameter_list|,
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|from
parameter_list|)
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|hlen
decl_stmt|;
name|char
name|addr
index|[
name|INET_ADDRSTRLEN
index|]
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|cc
operator|-=
name|hlen
expr_stmt|;
name|strlcpy
argument_list|(
name|addr
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|as_path
condition|)
name|Printf
argument_list|(
literal|" [AS%u]"
argument_list|,
name|as_lookup
argument_list|(
name|asn
argument_list|,
name|addr
argument_list|,
name|AF_INET
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|Printf
argument_list|(
literal|" %s"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|Printf
argument_list|(
literal|" %s (%s)"
argument_list|,
name|inetname
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|Printf
argument_list|(
literal|" %d bytes to %s"
argument_list|,
name|cc
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Checksum routine for UDP and TCP headers.  */
end_comment

begin_function
name|u_short
name|p_cksum
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|u_short
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|static
name|struct
name|ipovly
name|ipo
decl_stmt|;
name|u_short
name|sum
index|[
literal|2
index|]
decl_stmt|;
name|ipo
operator|.
name|ih_pr
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|ipo
operator|.
name|ih_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ipo
operator|.
name|ih_src
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|ipo
operator|.
name|ih_dst
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|sum
index|[
literal|1
index|]
operator|=
name|in_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|ipo
argument_list|,
sizeof|sizeof
argument_list|(
name|ipo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pseudo ip hdr cksum */
name|sum
index|[
literal|0
index|]
operator|=
name|in_cksum
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* payload data cksum */
return|return
operator|~
name|in_cksum
argument_list|(
name|sum
argument_list|,
sizeof|sizeof
argument_list|(
name|sum
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checksum routine for Internet Protocol family headers (C Version)  */
end_comment

begin_function
name|u_short
name|in_cksum
parameter_list|(
specifier|register
name|u_short
modifier|*
name|addr
parameter_list|,
specifier|register
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|nleft
init|=
name|len
decl_stmt|;
specifier|register
name|u_short
modifier|*
name|w
init|=
name|addr
decl_stmt|;
specifier|register
name|u_short
name|answer
decl_stmt|;
specifier|register
name|int
name|sum
init|=
literal|0
decl_stmt|;
comment|/* 	 *  Our algorithm is simple, using a 32 bit accumulator (sum), 	 *  we add sequential 16 bit words to it, and at the end, fold 	 *  back all the carry bits from the top 16 bits into the lower 	 *  16 bits. 	 */
while|while
condition|(
name|nleft
operator|>
literal|1
condition|)
block|{
name|sum
operator|+=
operator|*
name|w
operator|++
expr_stmt|;
name|nleft
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* mop up an odd byte, if necessary */
if|if
condition|(
name|nleft
operator|==
literal|1
condition|)
name|sum
operator|+=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|w
expr_stmt|;
comment|/* 	 * add back carry outs from top 16 bits to low 16 bits 	 */
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* add hi 16 to low 16 */
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* add carry */
name|answer
operator|=
operator|~
name|sum
expr_stmt|;
comment|/* truncate to 16 bits */
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Subtract 2 timeval structs:  out = out - in.  * Out is assumed to be within about LONG_MAX seconds of in.  */
end_comment

begin_function
name|void
name|tvsub
parameter_list|(
specifier|register
name|struct
name|timeval
modifier|*
name|out
parameter_list|,
specifier|register
name|struct
name|timeval
modifier|*
name|in
parameter_list|)
block|{
if|if
condition|(
operator|(
name|out
operator|->
name|tv_usec
operator|-=
name|in
operator|->
name|tv_usec
operator|)
operator|<
literal|0
condition|)
block|{
operator|--
name|out
operator|->
name|tv_sec
expr_stmt|;
name|out
operator|->
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|out
operator|->
name|tv_sec
operator|-=
name|in
operator|->
name|tv_sec
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct an Internet address representation.  * If the nflag has been supplied, give  * numeric value, otherwise try for symbolic name.  */
end_comment

begin_function
name|char
modifier|*
name|inetname
parameter_list|(
name|struct
name|in_addr
name|in
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|static
name|char
name|domain
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|,
name|line
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|first
operator|&&
operator|!
name|nflag
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|domain
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
operator|++
name|cp
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|domain
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|domain
index|[
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|nflag
operator|&&
name|in
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|in
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|domain
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|line
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|line
operator|)
return|;
block|}
block|}
return|return
operator|(
name|inet_ntoa
argument_list|(
name|in
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|hostinfo
modifier|*
name|gethostinfo
parameter_list|(
specifier|register
name|char
modifier|*
name|hostname
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|hostinfo
modifier|*
name|hi
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|u_int32_t
name|addr
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|hostname
argument_list|)
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: hostname \"%.32s...\" is too long\n"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hi
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: calloc %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|inet_addr
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int32_t
operator|)
name|addr
operator|!=
operator|-
literal|1
condition|)
block|{
name|hi
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|hi
operator|->
name|n
operator|=
literal|1
expr_stmt|;
name|hi
operator|->
name|addrs
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|hi
operator|->
name|addrs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|addrs
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: calloc %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hi
operator|->
name|addrs
index|[
literal|0
index|]
operator|=
name|addr
expr_stmt|;
return|return
operator|(
name|hi
operator|)
return|;
block|}
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown host %s\n"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
operator|||
name|hp
operator|->
name|h_length
operator|!=
literal|4
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad host %s\n"
argument_list|,
name|prog
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hi
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|p
operator|=
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|n
operator|,
operator|++
name|p
control|)
continue|continue;
name|hi
operator|->
name|n
operator|=
name|n
expr_stmt|;
name|hi
operator|->
name|addrs
operator|=
name|calloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|hi
operator|->
name|addrs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|addrs
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: calloc %s\n"
argument_list|,
name|prog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ap
operator|=
name|hi
operator|->
name|addrs
operator|,
name|p
operator|=
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|ap
operator|,
operator|++
name|p
control|)
name|memcpy
argument_list|(
name|ap
argument_list|,
operator|*
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hi
operator|)
return|;
block|}
end_function

begin_function
name|void
name|freehostinfo
parameter_list|(
specifier|register
name|struct
name|hostinfo
modifier|*
name|hi
parameter_list|)
block|{
if|if
condition|(
name|hi
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|hi
operator|->
name|name
argument_list|)
expr_stmt|;
name|hi
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hi
operator|->
name|addrs
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getaddr
parameter_list|(
specifier|register
name|u_int32_t
modifier|*
name|ap
parameter_list|,
specifier|register
name|char
modifier|*
name|hostname
parameter_list|)
block|{
specifier|register
name|struct
name|hostinfo
modifier|*
name|hi
decl_stmt|;
name|hi
operator|=
name|gethostinfo
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|=
name|hi
operator|->
name|addrs
index|[
literal|0
index|]
expr_stmt|;
name|freehostinfo
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setsin
parameter_list|(
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|,
specifier|register
name|u_int32_t
name|addr
parameter_list|)
block|{
name|memset
argument_list|(
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOCKADDR_SA_LEN
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* String to value with optional min and max. Handles decimal and hex. */
end_comment

begin_function
name|int
name|str2val
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|register
name|int
name|mi
parameter_list|,
specifier|register
name|int
name|ma
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|cp
operator|=
name|str
operator|+
literal|2
expr_stmt|;
name|val
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: \"%s\" bad value for %s \n"
argument_list|,
name|prog
argument_list|,
name|str
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
name|mi
operator|&&
name|mi
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|mi
operator|==
literal|0
condition|)
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s must be>= %d\n"
argument_list|,
name|prog
argument_list|,
name|what
argument_list|,
name|mi
argument_list|)
expr_stmt|;
else|else
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s must be> %d\n"
argument_list|,
name|prog
argument_list|,
name|what
argument_list|,
name|mi
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|>
name|ma
operator|&&
name|ma
operator|>=
literal|0
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s must be<= %d\n"
argument_list|,
name|prog
argument_list|,
name|what
argument_list|,
name|ma
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|outproto
modifier|*
name|setproto
parameter_list|(
name|char
modifier|*
name|pname
parameter_list|)
block|{
name|struct
name|outproto
modifier|*
name|proto
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|protos
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|protos
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pname
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|proto
operator|=
operator|&
name|protos
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|proto
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* generic handler */
name|struct
name|protoent
modifier|*
name|pe
decl_stmt|;
name|u_long
name|pnum
decl_stmt|;
comment|/* Determine the IP protocol number */
if|if
condition|(
operator|(
name|pe
operator|=
name|getprotobyname
argument_list|(
name|pname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pnum
operator|=
name|pe
operator|->
name|p_proto
expr_stmt|;
else|else
name|pnum
operator|=
name|str2val
argument_list|(
name|optarg
argument_list|,
literal|"proto number"
argument_list|,
literal|1
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|proto
operator|->
name|num
operator|=
name|pnum
expr_stmt|;
block|}
return|return
name|proto
return|;
block|}
end_function

begin_function
name|void
name|pkt_compare
parameter_list|(
specifier|const
name|u_char
modifier|*
name|a
parameter_list|,
name|int
name|la
parameter_list|,
specifier|const
name|u_char
modifier|*
name|b
parameter_list|,
name|int
name|lb
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|la
condition|;
name|i
operator|++
control|)
name|Printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|l
operator|=
operator|(
name|la
operator|<=
name|lb
operator|)
condition|?
name|la
else|:
name|lb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|a
index|[
name|i
index|]
operator|==
name|b
index|[
name|i
index|]
condition|)
name|Printf
argument_list|(
literal|"__"
argument_list|)
expr_stmt|;
else|else
name|Printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|lb
condition|;
name|i
operator|++
control|)
name|Printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|char
name|version
index|[]
decl_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Version %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-adDeFInrSvx] [-f first_ttl] [-g gateway] [-i iface]\n"
literal|"\t[-m max_ttl] [-p port] [-P proto] [-q nqueries] [-s src_addr]\n"
literal|"\t[-t tos] [-w waittime] [-A as_server] [-z pausemsecs] host [packetlen]\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

