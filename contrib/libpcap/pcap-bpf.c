begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1998  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/pcap-bpf.c,v 1.86 2005/02/26 21:58:05 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* optionally get BSD define */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeb.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_comment
comment|/*  * Make "pcap.h" not include "pcap-bpf.h"; we are going to include the  * native OS version, as we need "struct bpf_config" from it.  */
end_comment

begin_define
define|#
directive|define
name|PCAP_DONT_INCLUDE_PCAP_BPF_H
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/*  * Prevent bpf.h from redefining the DLT_ values to their  * IFT_ values, as we're going to return the standard libpcap  * values, not IBM's non-standard IFT_ values.  */
end_comment

begin_undef
undef|#
directive|undef
name|_AIX
end_undef

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_define
define|#
directive|define
name|_AIX
end_define

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_comment
comment|/* for IFT_ values */
end_comment

begin_include
include|#
directive|include
file|<sys/sysconfig.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<odmi.h>
end_include

begin_include
include|#
directive|include
file|<cf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__64BIT__
end_ifdef

begin_define
define|#
directive|define
name|domakedev
value|makedev64
end_define

begin_define
define|#
directive|define
name|getmajor
value|major64
end_define

begin_define
define|#
directive|define
name|bpf_hdr
value|bpf_hdr32
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __64BIT__ */
end_comment

begin_define
define|#
directive|define
name|domakedev
value|makedev
end_define

begin_define
define|#
directive|define
name|getmajor
value|major
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __64BIT__ */
end_comment

begin_define
define|#
directive|define
name|BPF_NAME
value|"bpf"
end_define

begin_define
define|#
directive|define
name|BPF_MINORS
value|4
end_define

begin_define
define|#
directive|define
name|DRIVER_PATH
value|"/usr/lib/drivers"
end_define

begin_define
define|#
directive|define
name|BPF_NODE
value|"/dev/bpf"
end_define

begin_decl_stmt
specifier|static
name|int
name|bpfloadedflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|odmlockid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _AIX */
end_comment

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIX */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DAG_API
end_ifdef

begin_include
include|#
directive|include
file|"pcap-dag.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_DAG_API */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gencode.h"
end_include

begin_comment
comment|/* for "no_optimize" */
end_comment

begin_function_decl
specifier|static
name|int
name|pcap_setfilter_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_set_datalink_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|pcap_stats_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|bpf_stat
name|s
decl_stmt|;
comment|/* 	 * "ps_recv" counts packets handed to the filter, not packets 	 * that passed the filter.  This includes packets later dropped 	 * because we ran out of buffer space. 	 * 	 * "ps_drop" counts packets dropped inside the BPF device 	 * because we ran out of buffer space.  It doesn't count 	 * packets dropped by the interface driver.  It counts 	 * only packets that passed the filter. 	 * 	 * Both statistics include packets not yet read from the kernel 	 * by libpcap, and thus not yet seen by the application. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCGSTATS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGSTATS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ps
operator|->
name|ps_recv
operator|=
name|s
operator|.
name|bs_recv
expr_stmt|;
name|ps
operator|->
name|ps_drop
operator|=
name|s
operator|.
name|bs_drop
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_read_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|u_char
modifier|*
name|datap
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|fcode
decl_stmt|;
ifdef|#
directive|ifdef
name|PCAP_FDDIPAD
specifier|register
name|int
name|pad
decl_stmt|;
endif|#
directive|endif
name|fcode
operator|=
name|p
operator|->
name|md
operator|.
name|use_bpf
condition|?
name|NULL
else|:
name|p
operator|->
name|fcode
operator|.
name|bf_insns
expr_stmt|;
name|again
label|:
comment|/* 	 * Has "pcap_breakloop()" been called? 	 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 		 * Yes - clear the flag that indicates that it 		 * has, and return -2 to indicate that we were 		 * told to break out of the loop. 		 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|cc
operator|=
name|p
operator|->
name|cc
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|cc
operator|==
literal|0
condition|)
block|{
name|cc
operator|=
name|read
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|buffer
argument_list|,
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
comment|/* Don't choke when we get ptraced */
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINTR
case|:
goto|goto
name|again
goto|;
ifdef|#
directive|ifdef
name|_AIX
case|case
name|EFAULT
case|:
comment|/* 				 * Sigh.  More AIX wonderfulness. 				 * 				 * For some unknown reason the uiomove() 				 * operation in the bpf kernel extension 				 * used to copy the buffer into user  				 * space sometimes returns EFAULT. I have 				 * no idea why this is the case given that 				 * a kernel debugger shows the user buffer  				 * is correct. This problem appears to  				 * be mostly mitigated by the memset of  				 * the buffer before it is first used.  				 * Very strange.... Shaun Clowes 				 * 				 * In any case this means that we shouldn't  				 * treat EFAULT as a fatal error; as we 				 * don't have an API for returning 				 * a "some packets were dropped since 				 * the last packet you saw" indication, 				 * we just ignore EFAULT and keep reading. 				 */
goto|goto
name|again
goto|;
endif|#
directive|endif
case|case
name|EWOULDBLOCK
case|:
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BSD
argument_list|)
comment|/* 			 * Due to a SunOS bug, after 2^31 bytes, the kernel 			 * file offset overflows and read fails with EINVAL. 			 * The lseek() to 0 will fix things. 			 */
case|case
name|EINVAL
case|:
if|if
condition|(
name|lseek
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|+
name|p
operator|->
name|bufsize
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* fall through */
endif|#
directive|endif
block|}
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"read: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bp
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
block|}
else|else
name|bp
operator|=
name|p
operator|->
name|bp
expr_stmt|;
comment|/* 	 * Loop through each packet. 	 */
define|#
directive|define
name|bhp
value|((struct bpf_hdr *)bp)
name|ep
operator|=
name|bp
operator|+
name|cc
expr_stmt|;
ifdef|#
directive|ifdef
name|PCAP_FDDIPAD
name|pad
operator|=
name|p
operator|->
name|fddipad
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
block|{
specifier|register
name|int
name|caplen
decl_stmt|,
name|hdrlen
decl_stmt|;
comment|/* 		 * Has "pcap_breakloop()" been called? 		 * If so, return immediately - if we haven't read any 		 * packets, clear the flag and return -2 to indicate 		 * that we were told to break out of the loop, otherwise 		 * leave the flag set, so that the *next* call will break 		 * out of the loop without having read any packets, and 		 * return the number of packets we've processed so far. 		 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
else|else
block|{
name|p
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|p
operator|->
name|cc
operator|=
name|ep
operator|-
name|bp
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
name|caplen
operator|=
name|bhp
operator|->
name|bh_caplen
expr_stmt|;
name|hdrlen
operator|=
name|bhp
operator|->
name|bh_hdrlen
expr_stmt|;
name|datap
operator|=
name|bp
operator|+
name|hdrlen
expr_stmt|;
comment|/* 		 * Short-circuit evaluation: if using BPF filter 		 * in kernel, no need to do it now. 		 * #ifdef PCAP_FDDIPAD 		 * Note: the filter code was generated assuming 		 * that p->fddipad was the amount of padding 		 * before the header, as that's what's required 		 * in the kernel, so we run the filter before 		 * skipping that padding. #endif 		 */
if|if
condition|(
name|fcode
operator|==
name|NULL
operator|||
name|bpf_filter
argument_list|(
name|fcode
argument_list|,
name|datap
argument_list|,
name|bhp
operator|->
name|bh_datalen
argument_list|,
name|caplen
argument_list|)
condition|)
block|{
name|struct
name|pcap_pkthdr
name|pkthdr
decl_stmt|;
name|pkthdr
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|bhp
operator|->
name|bh_tstamp
operator|.
name|tv_sec
expr_stmt|;
ifdef|#
directive|ifdef
name|_AIX
comment|/* 			 * AIX's BPF returns seconds/nanoseconds time 			 * stamps, not seconds/microseconds time stamps. 			 */
name|pkthdr
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|bhp
operator|->
name|bh_tstamp
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
name|pkthdr
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|bhp
operator|->
name|bh_tstamp
operator|.
name|tv_usec
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCAP_FDDIPAD
if|if
condition|(
name|caplen
operator|>
name|pad
condition|)
name|pkthdr
operator|.
name|caplen
operator|=
name|caplen
operator|-
name|pad
expr_stmt|;
else|else
name|pkthdr
operator|.
name|caplen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bhp
operator|->
name|bh_datalen
operator|>
name|pad
condition|)
name|pkthdr
operator|.
name|len
operator|=
name|bhp
operator|->
name|bh_datalen
operator|-
name|pad
expr_stmt|;
else|else
name|pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|datap
operator|+=
name|pad
expr_stmt|;
else|#
directive|else
name|pkthdr
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pkthdr
operator|.
name|len
operator|=
name|bhp
operator|->
name|bh_datalen
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|callback
call|)
argument_list|(
name|user
argument_list|,
operator|&
name|pkthdr
argument_list|,
name|datap
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|BPF_WORDALIGN
argument_list|(
name|caplen
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|>=
name|cnt
operator|&&
name|cnt
operator|>
literal|0
condition|)
block|{
name|p
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|p
operator|->
name|cc
operator|=
name|ep
operator|-
name|bp
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * Skip this packet. 			 */
name|bp
operator|+=
name|BPF_WORDALIGN
argument_list|(
name|caplen
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|bhp
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_inject_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__APPLE__
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAFNOSUPPORT
condition|)
block|{
comment|/* 		 * In Mac OS X, there's a bug wherein setting the 		 * BIOCSHDRCMPLT flag causes writes to fail; see, 		 * for example: 		 * 		 *	http://cerberus.sourcefire.com/~jeff/archives/patches/macosx/BIOCSHDRCMPLT-10.3.3.patch 		 * 		 * So, if, on OS X, we get EAFNOSUPPORT from the write, we 		 * assume it's due to that bug, and turn off that flag 		 * and try again.  If we succeed, it either means that 		 * somebody applied the fix from that URL, or other patches 		 * for that bug from 		 * 		 *	http://cerberus.sourcefire.com/~jeff/archives/patches/macosx/ 		 * 		 * and are running a Darwin kernel with those fixes, or 		 * that Apple fixed the problem in some OS X release. 		 */
name|u_int
name|spoof_eth_src
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSHDRCMPLT
argument_list|,
operator|&
name|spoof_eth_src
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send: can't turn off BIOCSHDRCMPLT: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Now try the write again. 		 */
name|ret
operator|=
name|write
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __APPLE__ */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_function
specifier|static
name|int
name|bpf_odminit
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
modifier|*
name|errstr
decl_stmt|;
if|if
condition|(
name|odm_initialize
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|odm_err_msg
argument_list|(
name|odmerrno
argument_list|,
operator|&
name|errstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errstr
operator|=
literal|"Unknown error"
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: odm_initialize failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|odmlockid
operator|=
name|odm_lock
argument_list|(
literal|"/etc/objrepos/config_lock"
argument_list|,
name|ODM_WAIT
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|odm_err_msg
argument_list|(
name|odmerrno
argument_list|,
operator|&
name|errstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errstr
operator|=
literal|"Unknown error"
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: odm_lock of /etc/objrepos/config_lock failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_odmcleanup
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
modifier|*
name|errstr
decl_stmt|;
if|if
condition|(
name|odm_unlock
argument_list|(
name|odmlockid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|odm_err_msg
argument_list|(
name|odmerrno
argument_list|,
operator|&
name|errstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errstr
operator|=
literal|"Unknown error"
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: odm_unlock failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|odm_terminate
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|odm_err_msg
argument_list|(
name|odmerrno
argument_list|,
operator|&
name|errstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errstr
operator|=
literal|"Unknown error"
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: odm_terminate failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_load
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|long
name|major
decl_stmt|;
name|int
modifier|*
name|minors
decl_stmt|;
name|int
name|numminors
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|struct
name|bpf_config
name|cfg_bpf
decl_stmt|;
name|struct
name|cfg_load
name|cfg_ld
decl_stmt|;
name|struct
name|cfg_kmod
name|cfg_km
decl_stmt|;
comment|/* 	 * This is very very close to what happens in the real implementation 	 * but I've fixed some (unlikely) bug situations. 	 */
if|if
condition|(
name|bpfloadedflag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bpf_odminit
argument_list|(
name|errbuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|major
operator|=
name|genmajor
argument_list|(
name|BPF_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|major
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: genmajor failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|minors
operator|=
name|getminor
argument_list|(
name|major
argument_list|,
operator|&
name|numminors
argument_list|,
name|BPF_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|minors
condition|)
block|{
name|minors
operator|=
name|genminor
argument_list|(
literal|"bpf"
argument_list|,
name|major
argument_list|,
literal|0
argument_list|,
name|BPF_MINORS
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|minors
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: genminor failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bpf_odmcleanup
argument_list|(
name|errbuf
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|rc
operator|=
name|stat
argument_list|(
name|BPF_NODE
literal|"0"
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: can't stat %s: %s"
argument_list|,
name|BPF_NODE
literal|"0"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
operator|||
name|getmajor
argument_list|(
name|sbuf
operator|.
name|st_rdev
argument_list|)
operator|!=
name|major
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BPF_MINORS
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d"
argument_list|,
name|BPF_NODE
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|buf
argument_list|,
name|S_IRUSR
operator||
name|S_IFCHR
argument_list|,
name|domakedev
argument_list|(
name|major
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: can't mknod %s: %s"
argument_list|,
name|buf
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
comment|/* Check if the driver is loaded */
name|memset
argument_list|(
operator|&
name|cfg_ld
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_ld
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_ld
operator|.
name|path
operator|=
name|buf
expr_stmt|;
name|sprintf
argument_list|(
name|cfg_ld
operator|.
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|DRIVER_PATH
argument_list|,
name|BPF_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sysconfig
argument_list|(
name|SYS_QUERYLOAD
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cfg_ld
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_ld
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|cfg_ld
operator|.
name|kmid
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Driver isn't loaded, load it now */
if|if
condition|(
name|sysconfig
argument_list|(
name|SYS_SINGLELOAD
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cfg_ld
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_ld
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: could not load driver: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* Configure the driver */
name|cfg_km
operator|.
name|cmd
operator|=
name|CFG_INIT
expr_stmt|;
name|cfg_km
operator|.
name|kmid
operator|=
name|cfg_ld
operator|.
name|kmid
expr_stmt|;
name|cfg_km
operator|.
name|mdilen
operator|=
sizeof|sizeof
argument_list|(
name|cfg_bpf
argument_list|)
expr_stmt|;
name|cfg_km
operator|.
name|mdiptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cfg_bpf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BPF_MINORS
condition|;
name|i
operator|++
control|)
block|{
name|cfg_bpf
operator|.
name|devno
operator|=
name|domakedev
argument_list|(
name|major
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysconfig
argument_list|(
name|SYS_CFGKMOD
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cfg_km
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_km
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: could not configure driver: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|bpfloadedflag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|bpf_open
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
name|device
index|[
sizeof|sizeof
expr|"/dev/bpf0000000000"]
expr_stmt|;
ifdef|#
directive|ifdef
name|_AIX
comment|/* 	 * Load the bpf driver, if it isn't already loaded, 	 * and create the BPF device entries, if they don't 	 * already exist. 	 */
if|if
condition|(
name|bpf_load
argument_list|(
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Go through all the minors and find one that isn't in use. 	 */
do|do
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
literal|"/dev/bpf%d"
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
comment|/* 		 * Initially try a read/write open (to allow the inject 		 * method to work).  If that fails due to permission 		 * issues, fall back to read-only.  This allows a 		 * non-root user to be granted specific access to pcap 		 * capabilities via file permissions. 		 * 		 * XXX - we should have an API that has a flag that 		 * controls whether to open read-only or read-write, 		 * so that denial of permission to send (or inability 		 * to send, if sending packets isn't supported on 		 * the device in question) can be indicated at open 		 * time. 		 */
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fd
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EBUSY
condition|)
do|;
comment|/* 	 * XXX better message for all minors used 	 */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"(no devices found) %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We include the OS's<net/bpf.h>, not our "pcap-bpf.h", so we probably  * don't get DLT_DOCSIS defined.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DLT_DOCSIS
end_ifndef

begin_define
define|#
directive|define
name|DLT_DOCSIS
value|143
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|pcap_t
modifier|*
name|pcap_open_live
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|struct
name|bpf_version
name|bv
decl_stmt|;
ifdef|#
directive|ifdef
name|BIOCGDLTLIST
name|struct
name|bpf_dltlist
name|bdl
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|BIOCGHDRCMPLT
argument_list|)
operator|&&
name|defined
argument_list|(
name|BIOCSHDRCMPLT
argument_list|)
name|u_int
name|spoof_eth_src
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
name|u_int
name|v
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|struct
name|bpf_insn
name|total_insn
decl_stmt|;
name|struct
name|bpf_program
name|total_prog
decl_stmt|;
name|struct
name|utsname
name|osinfo
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_API
if|if
condition|(
name|strstr
argument_list|(
name|device
argument_list|,
literal|"dag"
argument_list|)
condition|)
block|{
return|return
name|dag_open_live
argument_list|(
name|device
argument_list|,
name|snaplen
argument_list|,
name|promisc
argument_list|,
name|to_ms
argument_list|,
name|ebuf
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_DAG_API */
ifdef|#
directive|ifdef
name|BIOCGDLTLIST
name|memset
argument_list|(
operator|&
name|bdl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bdl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|pcap_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|bpf_open
argument_list|(
name|p
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|p
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|p
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCVERSION
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCVERSION: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bv
operator|.
name|bv_major
operator|!=
name|BPF_MAJOR_VERSION
operator|||
name|bv
operator|.
name|bv_minor
operator|<
name|BPF_MINOR_VERSION
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"kernel bpf filter out of date"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Try finding a good size for the buffer; 32768 may be too 	 * big, so keep cutting it in half until we find a size 	 * that works, or run out of sizes to try.  If the default 	 * is larger, don't make it smaller. 	 * 	 * XXX - there should be a user-accessible hook to set the 	 * initial buffer size. 	 */
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|v
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|v
operator|<
literal|32768
condition|)
name|v
operator|=
literal|32768
expr_stmt|;
for|for
control|(
init|;
name|v
operator|!=
literal|0
condition|;
name|v
operator|>>=
literal|1
control|)
block|{
comment|/* Ignore the return value - this is because the call fails 		 * on BPF systems that don't have kernel malloc.  And if 		 * the call fails, it's no big deal, we just continue to 		 * use the standard buffer size. 		 */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|v
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|>=
literal|0
condition|)
break|break;
comment|/* that size worked; we're done */
if|if
condition|(
name|errno
operator|!=
name|ENOBUFS
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETIF: %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|v
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSBLEN: %s: No buffer size worked"
argument_list|,
name|device
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Get the data link layer type. */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGDLT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|v
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGDLT: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|_AIX
comment|/* 	 * AIX's BPF returns IFF_ types, not DLT_ types, in BIOCGDLT. 	 */
switch|switch
condition|(
name|v
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_ISO88023
case|:
name|v
operator|=
name|DLT_EN10MB
expr_stmt|;
break|break;
case|case
name|IFT_FDDI
case|:
name|v
operator|=
name|DLT_FDDI
expr_stmt|;
break|break;
case|case
name|IFT_ISO88025
case|:
name|v
operator|=
name|DLT_IEEE802
expr_stmt|;
break|break;
case|case
name|IFT_LOOP
case|:
name|v
operator|=
name|DLT_NULL
expr_stmt|;
break|break;
default|default:
comment|/* 		 * We don't know what to map this to yet. 		 */
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown interface type %u"
argument_list|,
name|v
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
if|#
directive|if
name|_BSDI_VERSION
operator|-
literal|0
operator|>=
literal|199510
comment|/* The SLIP and PPP link layer header changed in BSD/OS 2.1 */
switch|switch
condition|(
name|v
condition|)
block|{
case|case
name|DLT_SLIP
case|:
name|v
operator|=
name|DLT_SLIP_BSDOS
expr_stmt|;
break|break;
case|case
name|DLT_PPP
case|:
name|v
operator|=
name|DLT_PPP_BSDOS
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/*DLT_FR*/
name|v
operator|=
name|DLT_FRELAY
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/*DLT_C_HDLC*/
name|v
operator|=
name|DLT_CHDLC
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCAP_FDDIPAD
if|if
condition|(
name|v
operator|==
name|DLT_FDDI
condition|)
name|p
operator|->
name|fddipad
operator|=
name|PCAP_FDDIPAD
operator|:
else|else
name|p
operator|->
name|fddipad
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|linktype
operator|=
name|v
expr_stmt|;
ifdef|#
directive|ifdef
name|BIOCGDLTLIST
comment|/* 	 * We know the default link type -- now determine all the DLTs 	 * this interface supports.  If this fails with EINVAL, it's 	 * not fatal; we just don't get to use the feature later. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGDLTLIST
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bdl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|is_ethernet
decl_stmt|;
name|bdl
operator|.
name|bfl_list
operator|=
operator|(
name|u_int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|*
name|bdl
operator|.
name|bfl_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdl
operator|.
name|bfl_list
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGDLTLIST
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bdl
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGDLTLIST: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bdl
operator|.
name|bfl_list
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * OK, for real Ethernet devices, add DLT_DOCSIS to the 		 * list, so that an application can let you choose it, 		 * in case you're capturing DOCSIS traffic that a Cisco 		 * Cable Modem Termination System is putting out onto 		 * an Ethernet (it doesn't put an Ethernet header onto 		 * the wire, it puts raw DOCSIS frames out on the wire 		 * inside the low-level Ethernet framing). 		 * 		 * A "real Ethernet device" is defined here as a device 		 * that has a link-layer type of DLT_EN10MB and that has 		 * no alternate link-layer types; that's done to exclude 		 * 802.11 interfaces (which might or might not be the 		 * right thing to do, but I suspect it is - Ethernet<-> 		 * 802.11 bridges would probably badly mishandle frames 		 * that don't have Ethernet headers). 		 */
if|if
condition|(
name|p
operator|->
name|linktype
operator|==
name|DLT_EN10MB
condition|)
block|{
name|is_ethernet
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bdl
operator|.
name|bfl_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bdl
operator|.
name|bfl_list
index|[
name|i
index|]
operator|!=
name|DLT_EN10MB
condition|)
block|{
name|is_ethernet
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is_ethernet
condition|)
block|{
comment|/* 				 * We reserved one more slot at the end of 				 * the list. 				 */
name|bdl
operator|.
name|bfl_list
index|[
name|bdl
operator|.
name|bfl_len
index|]
operator|=
name|DLT_DOCSIS
expr_stmt|;
name|bdl
operator|.
name|bfl_len
operator|++
expr_stmt|;
block|}
block|}
name|p
operator|->
name|dlt_count
operator|=
name|bdl
operator|.
name|bfl_len
expr_stmt|;
name|p
operator|->
name|dlt_list
operator|=
name|bdl
operator|.
name|bfl_list
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGDLTLIST: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * If this is an Ethernet device, and we don't have a DLT_ list, 	 * give it a list with DLT_EN10MB and DLT_DOCSIS.  (That'd give 	 * 802.11 interfaces DLT_DOCSIS, which isn't the right thing to 	 * do, but there's not much we can do about that without finding 	 * some other way of determining whether it's an Ethernet or 802.11 	 * device.) 	 */
if|if
condition|(
name|p
operator|->
name|linktype
operator|==
name|DLT_EN10MB
operator|&&
name|p
operator|->
name|dlt_count
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|dlt_list
operator|=
operator|(
name|u_int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * If that fails, just leave the list empty. 		 */
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|=
name|DLT_EN10MB
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
literal|1
index|]
operator|=
name|DLT_DOCSIS
expr_stmt|;
name|p
operator|->
name|dlt_count
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|BIOCGHDRCMPLT
argument_list|)
operator|&&
name|defined
argument_list|(
name|BIOCSHDRCMPLT
argument_list|)
comment|/* 	 * Do a BIOCSHDRCMPLT, if defined, to turn that flag on, so 	 * the link-layer source address isn't forcibly overwritten. 	 * (Should we ignore errors?  Should we do this only if 	 * we're open for writing?) 	 * 	 * XXX - I seem to remember some packet-sending bug in some 	 * BSDs - check CVS log for "bpf.c"? 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSHDRCMPLT
argument_list|,
operator|&
name|spoof_eth_src
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSHDRCMPLT: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* set timeout */
if|if
condition|(
name|to_ms
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * XXX - is this seconds/nanoseconds in AIX? 		 * (Treating it as such doesn't fix the timeout 		 * problem described below.) 		 */
name|struct
name|timeval
name|to
decl_stmt|;
name|to
operator|.
name|tv_sec
operator|=
name|to_ms
operator|/
literal|1000
expr_stmt|;
name|to
operator|.
name|tv_usec
operator|=
operator|(
name|to_ms
operator|*
literal|1000
operator|)
operator|%
literal|1000000
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSRTIMEOUT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|to
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSRTIMEOUT: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|_AIX
ifdef|#
directive|ifdef
name|BIOCIMMEDIATE
comment|/* 	 * Darren Reed notes that 	 * 	 *	On AIX (4.2 at least), if BIOCIMMEDIATE is not set, the 	 *	timeout appears to be ignored and it waits until the buffer 	 *	is filled before returning.  The result of not having it 	 *	set is almost worse than useless if your BPF filter 	 *	is reducing things to only a few packets (i.e. one every 	 *	second or so). 	 * 	 * so we turn BIOCIMMEDIATE mode on if this is AIX. 	 * 	 * We don't turn it on for other platforms, as that means we 	 * get woken up for every packet, which may not be what we want; 	 * in the Winter 1993 USENIX paper on BPF, they say: 	 * 	 *	Since a process might want to look at every packet on a 	 *	network and the time between packets can be only a few 	 *	microseconds, it is not possible to do a read system call 	 *	per packet and BPF must collect the data from several 	 *	packets and return it as a unit when the monitoring 	 *	application does a read. 	 * 	 * which I infer is the reason for the timeout - it means we 	 * wait that amount of time, in the hopes that more packets 	 * will arrive and we'll get them all with one read. 	 * 	 * Setting BIOCIMMEDIATE mode on FreeBSD (and probably other 	 * BSDs) causes the timeout to be ignored. 	 * 	 * On the other hand, some platforms (e.g., Linux) don't support 	 * timeouts, they just hand stuff to you as soon as it arrives; 	 * if that doesn't cause a problem on those platforms, it may 	 * be OK to have BIOCIMMEDIATE mode on BSD as well. 	 * 	 * (Note, though, that applications may depend on the read 	 * completing, even if no packets have arrived, when the timeout 	 * expires, e.g. GUI applications that have to check for input 	 * while waiting for packets to arrive; a non-zero timeout 	 * prevents "select()" from working right on FreeBSD and 	 * possibly other BSDs, as the timer doesn't start until a 	 * "read()" is done, so the timer isn't in effect if the 	 * application is blocked on a "select()", and the "select()" 	 * doesn't get woken up for a BPF device until the buffer 	 * fills up.) 	 */
name|v
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCIMMEDIATE
argument_list|,
operator|&
name|v
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCIMMEDIATE: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* BIOCIMMEDIATE */
endif|#
directive|endif
comment|/* _AIX */
if|if
condition|(
name|promisc
condition|)
block|{
comment|/* set promiscuous mode, okay if it fails */
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCPROMISC
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCPROMISC: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|v
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGBLEN: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|p
operator|->
name|bufsize
operator|=
name|v
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|_AIX
comment|/* For some strange reason this seems to prevent the EFAULT  	 * problems we have experienced from AIX BPF. */
name|memset
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
literal|0x0
argument_list|,
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If there's no filter program installed, there's 	 * no indication to the kernel of what the snapshot 	 * length should be, so no snapshotting is done. 	 * 	 * Therefore, when we open the device, we install 	 * an "accept everything" filter with the specified 	 * snapshot length. 	 */
name|total_insn
operator|.
name|code
operator|=
call|(
name|u_short
call|)
argument_list|(
name|BPF_RET
operator||
name|BPF_K
argument_list|)
expr_stmt|;
name|total_insn
operator|.
name|jt
operator|=
literal|0
expr_stmt|;
name|total_insn
operator|.
name|jf
operator|=
literal|0
expr_stmt|;
name|total_insn
operator|.
name|k
operator|=
name|snaplen
expr_stmt|;
name|total_prog
operator|.
name|bf_len
operator|=
literal|1
expr_stmt|;
name|total_prog
operator|.
name|bf_insns
operator|=
operator|&
name|total_insn
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSETF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|total_prog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETF: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * On most BPF platforms, either you can do a "select()" or 	 * "poll()" on a BPF file descriptor and it works correctly, 	 * or you can do it and it will return "readable" if the 	 * hold buffer is full but not if the timeout expires *and* 	 * a non-blocking read will, if the hold buffer is empty 	 * but the store buffer isn't empty, rotate the buffers 	 * and return what packets are available. 	 * 	 * In the latter case, the fact that a non-blocking read 	 * will give you the available packets means you can work 	 * around the failure of "select()" and "poll()" to wake up 	 * and return "readable" when the timeout expires by using 	 * the timeout as the "select()" or "poll()" timeout, putting 	 * the BPF descriptor into non-blocking mode, and read from 	 * it regardless of whether "select()" reports it as readable 	 * or not. 	 * 	 * However, in FreeBSD 4.3 and 4.4, "select()" and "poll()" 	 * won't wake up and return "readable" if the timer expires 	 * and non-blocking reads return EWOULDBLOCK if the hold 	 * buffer is empty, even if the store buffer is non-empty. 	 * 	 * This means the workaround in question won't work. 	 * 	 * Therefore, on FreeBSD 4.3 and 4.4, we set "p->selectable_fd" 	 * to -1, which means "sorry, you can't use 'select()' or 'poll()' 	 * here".  On all other BPF platforms, we set it to the FD for 	 * the BPF device; in NetBSD, OpenBSD, and Darwin, a non-blocking 	 * read will, if the hold buffer is empty and the store buffer 	 * isn't empty, rotate the buffers and return what packets are 	 * there (and in sufficiently recent versions of OpenBSD 	 * "select()" and "poll()" should work correctly). 	 * 	 * XXX - what about AIX? 	 */
if|if
condition|(
name|uname
argument_list|(
operator|&
name|osinfo
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We can check what OS this is. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|osinfo
operator|.
name|sysname
argument_list|,
literal|"FreeBSD"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|strncmp
argument_list|(
name|osinfo
operator|.
name|release
argument_list|,
literal|"4.3-"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|osinfo
operator|.
name|release
argument_list|,
literal|"4.4-"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|p
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|p
operator|->
name|selectable_fd
operator|=
name|p
operator|->
name|fd
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We can't find out what OS this is, so assume we can 		 * do a "select()" or "poll()". 		 */
name|p
operator|->
name|selectable_fd
operator|=
name|p
operator|->
name|fd
expr_stmt|;
block|}
name|p
operator|->
name|read_op
operator|=
name|pcap_read_bpf
expr_stmt|;
name|p
operator|->
name|inject_op
operator|=
name|pcap_inject_bpf
expr_stmt|;
name|p
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_bpf
expr_stmt|;
name|p
operator|->
name|set_datalink_op
operator|=
name|pcap_set_datalink_bpf
expr_stmt|;
name|p
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|p
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_fd
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
name|pcap_stats_bpf
expr_stmt|;
name|p
operator|->
name|close_op
operator|=
name|pcap_close_common
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|bad
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|dlt_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_DAG_API
if|if
condition|(
name|dag_platform_finddevs
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_DAG_API */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setfilter_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
comment|/* 	 * It looks that BPF code generated by gen_protochain() is not 	 * compatible with some of kernel BPF code (for example BSD/OS 3.1). 	 * Take a safer side for now. 	 */
if|if
condition|(
name|no_optimize
condition|)
block|{
comment|/* 		 * XXX - what if we already have a filter in the kernel? 		 */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|->
name|md
operator|.
name|use_bpf
operator|=
literal|0
expr_stmt|;
comment|/* filtering in userland */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Free any user-mode filter we might happen to have installed. 	 */
name|pcap_freecode
argument_list|(
operator|&
name|p
operator|->
name|fcode
argument_list|)
expr_stmt|;
comment|/* 	 * Try to install the kernel filter. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSETF
argument_list|,
operator|(
name|caddr_t
operator|)
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETF: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|->
name|md
operator|.
name|use_bpf
operator|=
literal|1
expr_stmt|;
comment|/* filtering in the kernel */
comment|/* 	 * Discard any previously-received packets, as they might have 	 * passed whatever filter was formerly in effect, but might 	 * not pass this filter (BIOCSETF discards packets buffered 	 * in the kernel, so you can lose packets in any case). 	 */
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_set_datalink_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BIOCSDLT
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSDLT
argument_list|,
operator|&
name|dlt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"Cannot set DLT %d: %s"
argument_list|,
name|dlt
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

