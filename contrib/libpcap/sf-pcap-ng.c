begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * sf-pcap-ng.c - pcap-ng-file-format-specific code from savefile.c  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header$ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<pcap-stdinc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _WIN32 */
end_comment

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_STDINT_H
end_elif

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BITYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bitypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"pcap-common.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sf-pcap-ng.h"
end_include

begin_comment
comment|/*  * Block types.  */
end_comment

begin_comment
comment|/*  * Common part at the beginning of all blocks.  */
end_comment

begin_struct
struct|struct
name|block_header
block|{
name|bpf_u_int32
name|block_type
decl_stmt|;
name|bpf_u_int32
name|total_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Common trailer at the end of all blocks.  */
end_comment

begin_struct
struct|struct
name|block_trailer
block|{
name|bpf_u_int32
name|total_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Common options.  */
end_comment

begin_define
define|#
directive|define
name|OPT_ENDOFOPT
value|0
end_define

begin_comment
comment|/* end of options */
end_comment

begin_define
define|#
directive|define
name|OPT_COMMENT
value|1
end_define

begin_comment
comment|/* comment string */
end_comment

begin_comment
comment|/*  * Option header.  */
end_comment

begin_struct
struct|struct
name|option_header
block|{
name|u_short
name|option_code
decl_stmt|;
name|u_short
name|option_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Structures for the part of each block type following the common  * part.  */
end_comment

begin_comment
comment|/*  * Section Header Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_SHB
value|0x0A0D0D0A
end_define

begin_struct
struct|struct
name|section_header_block
block|{
name|bpf_u_int32
name|byte_order_magic
decl_stmt|;
name|u_short
name|major_version
decl_stmt|;
name|u_short
name|minor_version
decl_stmt|;
name|u_int64_t
name|section_length
decl_stmt|;
comment|/* followed by options and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Byte-order magic value.  */
end_comment

begin_define
define|#
directive|define
name|BYTE_ORDER_MAGIC
value|0x1A2B3C4D
end_define

begin_comment
comment|/*  * Current version number.  If major_version isn't PCAP_NG_VERSION_MAJOR,  * that means that this code can't read the file.  */
end_comment

begin_define
define|#
directive|define
name|PCAP_NG_VERSION_MAJOR
value|1
end_define

begin_define
define|#
directive|define
name|PCAP_NG_VERSION_MINOR
value|0
end_define

begin_comment
comment|/*  * Interface Description Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_IDB
value|0x00000001
end_define

begin_struct
struct|struct
name|interface_description_block
block|{
name|u_short
name|linktype
decl_stmt|;
name|u_short
name|reserved
decl_stmt|;
name|bpf_u_int32
name|snaplen
decl_stmt|;
comment|/* followed by options and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Options in the IDB.  */
end_comment

begin_define
define|#
directive|define
name|IF_NAME
value|2
end_define

begin_comment
comment|/* interface name string */
end_comment

begin_define
define|#
directive|define
name|IF_DESCRIPTION
value|3
end_define

begin_comment
comment|/* interface description string */
end_comment

begin_define
define|#
directive|define
name|IF_IPV4ADDR
value|4
end_define

begin_comment
comment|/* interface's IPv4 address and netmask */
end_comment

begin_define
define|#
directive|define
name|IF_IPV6ADDR
value|5
end_define

begin_comment
comment|/* interface's IPv6 address and prefix length */
end_comment

begin_define
define|#
directive|define
name|IF_MACADDR
value|6
end_define

begin_comment
comment|/* interface's MAC address */
end_comment

begin_define
define|#
directive|define
name|IF_EUIADDR
value|7
end_define

begin_comment
comment|/* interface's EUI address */
end_comment

begin_define
define|#
directive|define
name|IF_SPEED
value|8
end_define

begin_comment
comment|/* interface's speed, in bits/s */
end_comment

begin_define
define|#
directive|define
name|IF_TSRESOL
value|9
end_define

begin_comment
comment|/* interface's time stamp resolution */
end_comment

begin_define
define|#
directive|define
name|IF_TZONE
value|10
end_define

begin_comment
comment|/* interface's time zone */
end_comment

begin_define
define|#
directive|define
name|IF_FILTER
value|11
end_define

begin_comment
comment|/* filter used when capturing on interface */
end_comment

begin_define
define|#
directive|define
name|IF_OS
value|12
end_define

begin_comment
comment|/* string OS on which capture on this interface was done */
end_comment

begin_define
define|#
directive|define
name|IF_FCSLEN
value|13
end_define

begin_comment
comment|/* FCS length for this interface */
end_comment

begin_define
define|#
directive|define
name|IF_TSOFFSET
value|14
end_define

begin_comment
comment|/* time stamp offset for this interface */
end_comment

begin_comment
comment|/*  * Enhanced Packet Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_EPB
value|0x00000006
end_define

begin_struct
struct|struct
name|enhanced_packet_block
block|{
name|bpf_u_int32
name|interface_id
decl_stmt|;
name|bpf_u_int32
name|timestamp_high
decl_stmt|;
name|bpf_u_int32
name|timestamp_low
decl_stmt|;
name|bpf_u_int32
name|caplen
decl_stmt|;
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* followed by packet data, options, and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Simple Packet Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_SPB
value|0x00000003
end_define

begin_struct
struct|struct
name|simple_packet_block
block|{
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* followed by packet data and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Packet Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_PB
value|0x00000002
end_define

begin_struct
struct|struct
name|packet_block
block|{
name|u_short
name|interface_id
decl_stmt|;
name|u_short
name|drops_count
decl_stmt|;
name|bpf_u_int32
name|timestamp_high
decl_stmt|;
name|bpf_u_int32
name|timestamp_low
decl_stmt|;
name|bpf_u_int32
name|caplen
decl_stmt|;
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* followed by packet data, options, and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Block cursor - used when processing the contents of a block.  * Contains a pointer into the data being processed and a count  * of bytes remaining in the block.  */
end_comment

begin_struct
struct|struct
name|block_cursor
block|{
name|u_char
modifier|*
name|data
decl_stmt|;
name|size_t
name|data_remaining
decl_stmt|;
name|bpf_u_int32
name|block_type
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|PASS_THROUGH
block|,
name|SCALE_UP_DEC
block|,
name|SCALE_DOWN_DEC
block|,
name|SCALE_UP_BIN
block|,
name|SCALE_DOWN_BIN
block|}
name|tstamp_scale_type_t
typedef|;
end_typedef

begin_comment
comment|/*  * Per-interface information.  */
end_comment

begin_struct
struct|struct
name|pcap_ng_if
block|{
name|u_int
name|tsresol
decl_stmt|;
comment|/* time stamp resolution */
name|tstamp_scale_type_t
name|scale_type
decl_stmt|;
comment|/* how to scale */
name|u_int
name|scale_factor
decl_stmt|;
comment|/* time stamp scale factor for power-of-10 tsresol */
name|u_int64_t
name|tsoffset
decl_stmt|;
comment|/* time stamp offset */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pcap_ng_sf
block|{
name|u_int
name|user_tsresol
decl_stmt|;
comment|/* time stamp resolution requested by the user */
name|bpf_u_int32
name|ifcount
decl_stmt|;
comment|/* number of interfaces seen in this capture */
name|bpf_u_int32
name|ifaces_size
decl_stmt|;
comment|/* size of array below */
name|struct
name|pcap_ng_if
modifier|*
name|ifaces
decl_stmt|;
comment|/* array of interface information */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|pcap_ng_cleanup
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_ng_next_packet
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|read_bytes
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|bytes_to_read
parameter_list|,
name|int
name|fail_on_eof
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|size_t
name|amt_read
decl_stmt|;
name|amt_read
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|bytes_to_read
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
name|bytes_to_read
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|amt_read
operator|==
literal|0
operator|&&
operator|!
name|fail_on_eof
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* EOF */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %lu bytes, only got %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytes_to_read
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_block
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|block_header
name|bhdr
decl_stmt|;
name|u_char
modifier|*
name|bdata
decl_stmt|;
name|size_t
name|data_remaining
decl_stmt|;
name|status
operator|=
name|read_bytes
argument_list|(
name|fp
argument_list|,
operator|&
name|bhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
return|return
operator|(
name|status
operator|)
return|;
comment|/* error or EOF */
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
name|bhdr
operator|.
name|block_type
operator|=
name|SWAPLONG
argument_list|(
name|bhdr
operator|.
name|block_type
argument_list|)
expr_stmt|;
name|bhdr
operator|.
name|total_length
operator|=
name|SWAPLONG
argument_list|(
name|bhdr
operator|.
name|total_length
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Is this block "too big"? 	 * 	 * We choose 16MB as "too big", for now, so that we handle 	 * "reasonably" large buffers but don't chew up all the 	 * memory if we read a malformed file. 	 */
if|if
condition|(
name|bhdr
operator|.
name|total_length
operator|>
literal|16
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"pcap-ng block size %u> maximum %u"
argument_list|,
name|bhdr
operator|.
name|total_length
argument_list|,
literal|16
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Is this block "too small" - i.e., is it shorter than a block 	 * header plus a block trailer? 	 */
if|if
condition|(
name|bhdr
operator|.
name|total_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"block in pcap-ng dump file has a length of %u< %lu"
argument_list|,
name|bhdr
operator|.
name|total_length
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Is the buffer big enough? 	 */
if|if
condition|(
name|p
operator|->
name|bufsize
operator|<
name|bhdr
operator|.
name|total_length
condition|)
block|{
comment|/* 		 * No - make it big enough. 		 */
name|void
modifier|*
name|bigger_buffer
decl_stmt|;
name|bigger_buffer
operator|=
name|realloc
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
name|bhdr
operator|.
name|total_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bigger_buffer
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|->
name|buffer
operator|=
name|bigger_buffer
expr_stmt|;
block|}
comment|/* 	 * Copy the stuff we've read to the buffer, and read the rest 	 * of the block. 	 */
name|memcpy
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
operator|&
name|bhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
argument_list|)
expr_stmt|;
name|bdata
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
expr_stmt|;
name|data_remaining
operator|=
name|bhdr
operator|.
name|total_length
operator|-
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bytes
argument_list|(
name|fp
argument_list|,
name|bdata
argument_list|,
name|data_remaining
argument_list|,
literal|1
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Initialize the cursor. 	 */
name|cursor
operator|->
name|data
operator|=
name|bdata
expr_stmt|;
name|cursor
operator|->
name|data_remaining
operator|=
name|data_remaining
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
expr_stmt|;
name|cursor
operator|->
name|block_type
operator|=
name|bhdr
operator|.
name|block_type
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_from_block_data
parameter_list|(
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|size_t
name|chunk_size
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
comment|/* 	 * Make sure we have the specified amount of data remaining in 	 * the block data. 	 */
if|if
condition|(
name|cursor
operator|->
name|data_remaining
operator|<
name|chunk_size
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"block of type %u in pcap-ng dump file is too short"
argument_list|,
name|cursor
operator|->
name|block_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Return the current pointer, and skip past the chunk. 	 */
name|data
operator|=
name|cursor
operator|->
name|data
expr_stmt|;
name|cursor
operator|->
name|data
operator|+=
name|chunk_size
expr_stmt|;
name|cursor
operator|->
name|data_remaining
operator|-=
name|chunk_size
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|option_header
modifier|*
name|get_opthdr_from_block_data
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|option_header
modifier|*
name|opthdr
decl_stmt|;
name|opthdr
operator|=
name|get_from_block_data
argument_list|(
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opthdr
argument_list|)
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opthdr
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Option header is cut short. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Byte-swap it if necessary. 	 */
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
name|opthdr
operator|->
name|option_code
operator|=
name|SWAPSHORT
argument_list|(
name|opthdr
operator|->
name|option_code
argument_list|)
expr_stmt|;
name|opthdr
operator|->
name|option_length
operator|=
name|SWAPSHORT
argument_list|(
name|opthdr
operator|->
name|option_length
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|opthdr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_optvalue_from_block_data
parameter_list|(
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|struct
name|option_header
modifier|*
name|opthdr
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|size_t
name|padded_option_len
decl_stmt|;
name|void
modifier|*
name|optvalue
decl_stmt|;
comment|/* Pad option length to 4-byte boundary */
name|padded_option_len
operator|=
name|opthdr
operator|->
name|option_length
expr_stmt|;
name|padded_option_len
operator|=
operator|(
operator|(
name|padded_option_len
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
expr_stmt|;
name|optvalue
operator|=
name|get_from_block_data
argument_list|(
name|cursor
argument_list|,
name|padded_option_len
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|optvalue
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Option value is cut short. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|optvalue
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_idb_options
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|u_int
modifier|*
name|tsresol
parameter_list|,
name|u_int64_t
modifier|*
name|tsoffset
parameter_list|,
name|int
modifier|*
name|is_binary
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|option_header
modifier|*
name|opthdr
decl_stmt|;
name|void
modifier|*
name|optvalue
decl_stmt|;
name|int
name|saw_tsresol
decl_stmt|,
name|saw_tsoffset
decl_stmt|;
name|u_char
name|tsresol_opt
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|saw_tsresol
operator|=
literal|0
expr_stmt|;
name|saw_tsoffset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cursor
operator|->
name|data_remaining
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Get the option header. 		 */
name|opthdr
operator|=
name|get_opthdr_from_block_data
argument_list|(
name|p
argument_list|,
name|cursor
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opthdr
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Option header is cut short. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Get option value. 		 */
name|optvalue
operator|=
name|get_optvalue_from_block_data
argument_list|(
name|cursor
argument_list|,
name|opthdr
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|optvalue
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Option value is cut short. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|opthdr
operator|->
name|option_code
condition|)
block|{
case|case
name|OPT_ENDOFOPT
case|:
if|if
condition|(
name|opthdr
operator|->
name|option_length
operator|!=
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has opt_endofopt option with length %u != 0"
argument_list|,
name|opthdr
operator|->
name|option_length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
goto|goto
name|done
goto|;
case|case
name|IF_TSRESOL
case|:
if|if
condition|(
name|opthdr
operator|->
name|option_length
operator|!=
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has if_tsresol option with length %u != 1"
argument_list|,
name|opthdr
operator|->
name|option_length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|saw_tsresol
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has more than one if_tsresol option"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|saw_tsresol
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tsresol_opt
argument_list|,
name|optvalue
argument_list|,
sizeof|sizeof
argument_list|(
name|tsresol_opt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsresol_opt
operator|&
literal|0x80
condition|)
block|{
comment|/* 				 * Resolution is negative power of 2. 				 */
operator|*
name|is_binary
operator|=
literal|1
expr_stmt|;
operator|*
name|tsresol
operator|=
literal|1
operator|<<
operator|(
name|tsresol_opt
operator|&
literal|0x7F
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Resolution is negative power of 10. 				 */
operator|*
name|is_binary
operator|=
literal|0
expr_stmt|;
operator|*
name|tsresol
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tsresol_opt
condition|;
name|i
operator|++
control|)
operator|*
name|tsresol
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tsresol
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Resolution is too high. 				 */
if|if
condition|(
name|tsresol_opt
operator|&
literal|0x80
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block if_tsresol option resolution 2^-%u is too high"
argument_list|,
name|tsresol_opt
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block if_tsresol option resolution 10^-%u is too high"
argument_list|,
name|tsresol_opt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|IF_TSOFFSET
case|:
if|if
condition|(
name|opthdr
operator|->
name|option_length
operator|!=
literal|8
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has if_tsoffset option with length %u != 8"
argument_list|,
name|opthdr
operator|->
name|option_length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|saw_tsoffset
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has more than one if_tsoffset option"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|saw_tsoffset
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|tsoffset
argument_list|,
name|optvalue
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tsoffset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
operator|*
name|tsoffset
operator|=
name|SWAPLL
argument_list|(
operator|*
name|tsoffset
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|done
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_interface
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|pcap_ng_sf
modifier|*
name|ps
decl_stmt|;
name|u_int
name|tsresol
decl_stmt|;
name|u_int64_t
name|tsoffset
decl_stmt|;
name|int
name|is_binary
decl_stmt|;
name|ps
operator|=
name|p
operator|->
name|priv
expr_stmt|;
comment|/* 	 * Count this interface. 	 */
name|ps
operator|->
name|ifcount
operator|++
expr_stmt|;
comment|/* 	 * Grow the array of per-interface information as necessary. 	 */
if|if
condition|(
name|ps
operator|->
name|ifcount
operator|>
name|ps
operator|->
name|ifaces_size
condition|)
block|{
comment|/* 		 * We need to grow the array. 		 */
name|bpf_u_int32
name|new_ifaces_size
decl_stmt|;
name|struct
name|pcap_ng_if
modifier|*
name|new_ifaces
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|ifaces_size
operator|==
literal|0
condition|)
block|{
comment|/* 			 * It's currently empty. 			 * 			 * (The Clang static analyzer doesn't do enough, 			 * err, umm, dataflow *analysis* to realize that 			 * ps->ifaces_size == 0 if ps->ifaces == NULL, 			 * and so complains about a possible zero argument 			 * to realloc(), so we check for the former 			 * condition to shut it up. 			 * 			 * However, it doesn't complain that one of the 			 * multiplications below could overflow, which is 			 * a real, albeit extremely unlikely, problem (you'd 			 * need a pcap-ng file with tens of millions of 			 * interfaces).) 			 */
name|new_ifaces_size
operator|=
literal|1
expr_stmt|;
name|new_ifaces
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_ng_if
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * It's not currently empty; double its size. 			 * (Perhaps overkill once we have a lot of interfaces.) 			 * 			 * Check for overflow if we double it. 			 */
if|if
condition|(
name|ps
operator|->
name|ifaces_size
operator|*
literal|2
operator|<
name|ps
operator|->
name|ifaces_size
condition|)
block|{
comment|/* 				 * The maximum number of interfaces before 				 * ps->ifaces_size overflows is the largest 				 * possible 32-bit power of 2, as we do 				 * size doubling. 				 */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"more than %u interfaces in the file"
argument_list|,
literal|0x80000000U
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * ps->ifaces_size * 2 doesn't overflow, so it's 			 * safe to multiply. 			 */
name|new_ifaces_size
operator|=
name|ps
operator|->
name|ifaces_size
operator|*
literal|2
expr_stmt|;
comment|/* 			 * Now make sure that's not so big that it overflows 			 * if we multiply by sizeof (struct pcap_ng_if). 			 * 			 * That can happen on 32-bit platforms, with a 32-bit 			 * size_t; it shouldn't happen on 64-bit platforms, 			 * with a 64-bit size_t, as new_ifaces_size is 			 * 32 bits. 			 */
if|if
condition|(
name|new_ifaces_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_ng_if
argument_list|)
operator|<
name|new_ifaces_size
condition|)
block|{
comment|/* 				 * As this fails only with 32-bit size_t, 				 * the multiplication was 32x32->32, and 				 * the largest 32-bit value that can safely 				 * be multiplied by sizeof (struct pcap_ng_if) 				 * without overflow is the largest 32-bit 				 * (unsigned) value divided by 				 * sizeof (struct pcap_ng_if). 				 */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"more than %u interfaces in the file"
argument_list|,
literal|0xFFFFFFFFU
operator|/
operator|(
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_ng_if
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|new_ifaces
operator|=
name|realloc
argument_list|(
name|ps
operator|->
name|ifaces
argument_list|,
name|new_ifaces_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_ng_if
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_ifaces
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We ran out of memory. 			 * Give up. 			 */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"out of memory for per-interface information (%u interfaces)"
argument_list|,
name|ps
operator|->
name|ifcount
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ps
operator|->
name|ifaces_size
operator|=
name|new_ifaces_size
expr_stmt|;
name|ps
operator|->
name|ifaces
operator|=
name|new_ifaces
expr_stmt|;
block|}
comment|/* 	 * Set the default time stamp resolution and offset. 	 */
name|tsresol
operator|=
literal|1000000
expr_stmt|;
comment|/* microsecond resolution */
name|is_binary
operator|=
literal|0
expr_stmt|;
comment|/* which is a power of 10 */
name|tsoffset
operator|=
literal|0
expr_stmt|;
comment|/* absolute timestamps */
comment|/* 	 * Now look for various time stamp options, so we know 	 * how to interpret the time stamps for this interface. 	 */
if|if
condition|(
name|process_idb_options
argument_list|(
name|p
argument_list|,
name|cursor
argument_list|,
operator|&
name|tsresol
argument_list|,
operator|&
name|tsoffset
argument_list|,
operator|&
name|is_binary
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ps
operator|->
name|ifaces
index|[
name|ps
operator|->
name|ifcount
operator|-
literal|1
index|]
operator|.
name|tsresol
operator|=
name|tsresol
expr_stmt|;
name|ps
operator|->
name|ifaces
index|[
name|ps
operator|->
name|ifcount
operator|-
literal|1
index|]
operator|.
name|tsoffset
operator|=
name|tsoffset
expr_stmt|;
comment|/* 	 * Determine whether we're scaling up or down or not 	 * at all for this interface. 	 */
if|if
condition|(
name|tsresol
operator|==
name|ps
operator|->
name|user_tsresol
condition|)
block|{
comment|/* 		 * The resolution is the resolution the user wants, 		 * so we don't have to do scaling. 		 */
name|ps
operator|->
name|ifaces
index|[
name|ps
operator|->
name|ifcount
operator|-
literal|1
index|]
operator|.
name|scale_type
operator|=
name|PASS_THROUGH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsresol
operator|>
name|ps
operator|->
name|user_tsresol
condition|)
block|{
comment|/* 		 * The resolution is greater than what the user wants, 		 * so we have to scale the timestamps down. 		 */
if|if
condition|(
name|is_binary
condition|)
name|ps
operator|->
name|ifaces
index|[
name|ps
operator|->
name|ifcount
operator|-
literal|1
index|]
operator|.
name|scale_type
operator|=
name|SCALE_DOWN_BIN
expr_stmt|;
else|else
block|{
comment|/* 			 * Calculate the scale factor. 			 */
name|ps
operator|->
name|ifaces
index|[
name|ps
operator|->
name|ifcount
operator|-
literal|1
index|]
operator|.
name|scale_factor
operator|=
name|tsresol
operator|/
name|ps
operator|->
name|user_tsresol
expr_stmt|;
name|ps
operator|->
name|ifaces
index|[
name|ps
operator|->
name|ifcount
operator|-
literal|1
index|]
operator|.
name|scale_type
operator|=
name|SCALE_DOWN_DEC
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * The resolution is less than what the user wants, 		 * so we have to scale the timestamps up. 		 */
if|if
condition|(
name|is_binary
condition|)
name|ps
operator|->
name|ifaces
index|[
name|ps
operator|->
name|ifcount
operator|-
literal|1
index|]
operator|.
name|scale_type
operator|=
name|SCALE_UP_BIN
expr_stmt|;
else|else
block|{
comment|/* 			 * Calculate the scale factor. 			 */
name|ps
operator|->
name|ifaces
index|[
name|ps
operator|->
name|ifcount
operator|-
literal|1
index|]
operator|.
name|scale_factor
operator|=
name|ps
operator|->
name|user_tsresol
operator|/
name|tsresol
expr_stmt|;
name|ps
operator|->
name|ifaces
index|[
name|ps
operator|->
name|ifcount
operator|-
literal|1
index|]
operator|.
name|scale_type
operator|=
name|SCALE_UP_DEC
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether this is a pcap-ng savefile and, if it is, extract the  * relevant information from the header.  */
end_comment

begin_function
name|pcap_t
modifier|*
name|pcap_ng_check_header
parameter_list|(
name|bpf_u_int32
name|magic
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|u_int
name|precision
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|size_t
name|amt_read
decl_stmt|;
name|bpf_u_int32
name|total_length
decl_stmt|;
name|bpf_u_int32
name|byte_order_magic
decl_stmt|;
name|struct
name|block_header
modifier|*
name|bhdrp
decl_stmt|;
name|struct
name|section_header_block
modifier|*
name|shbp
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|int
name|swapped
init|=
literal|0
decl_stmt|;
name|struct
name|pcap_ng_sf
modifier|*
name|ps
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|block_cursor
name|cursor
decl_stmt|;
name|struct
name|interface_description_block
modifier|*
name|idbp
decl_stmt|;
comment|/* 	 * Assume no read errors. 	 */
operator|*
name|err
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check whether the first 4 bytes of the file are the block 	 * type for a pcap-ng savefile. 	 */
if|if
condition|(
name|magic
operator|!=
name|BT_SHB
condition|)
block|{
comment|/* 		 * XXX - check whether this looks like what the block 		 * type would be after being munged by mapping between 		 * UN*X and DOS/Windows text file format and, if it 		 * does, look for the byte-order magic number in 		 * the appropriate place and, if we find it, report 		 * this as possibly being a pcap-ng file transferred 		 * between UN*X and Windows in text file format? 		 */
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* nope */
block|}
comment|/* 	 * OK, they are.  However, that's just \n\r\r\n, so it could, 	 * conceivably, be an ordinary text file. 	 * 	 * It could not, however, conceivably be any other type of 	 * capture file, so we can read the rest of the putative 	 * Section Header Block; put the block type in the common 	 * header, read the rest of the common header and the 	 * fixed-length portion of the SHB, and look for the byte-order 	 * magic value. 	 */
name|amt_read
operator|=
name|fread
argument_list|(
operator|&
name|total_length
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|total_length
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|<
sizeof|sizeof
argument_list|(
name|total_length
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* fail */
block|}
comment|/* 		 * Possibly a weird short text file, so just say 		 * "not pcap-ng". 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|amt_read
operator|=
name|fread
argument_list|(
operator|&
name|byte_order_magic
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|byte_order_magic
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|<
sizeof|sizeof
argument_list|(
name|byte_order_magic
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* fail */
block|}
comment|/* 		 * Possibly a weird short text file, so just say 		 * "not pcap-ng". 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|byte_order_magic
operator|!=
name|BYTE_ORDER_MAGIC
condition|)
block|{
name|byte_order_magic
operator|=
name|SWAPLONG
argument_list|(
name|byte_order_magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_order_magic
operator|!=
name|BYTE_ORDER_MAGIC
condition|)
block|{
comment|/* 			 * Not a pcap-ng file. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|swapped
operator|=
literal|1
expr_stmt|;
name|total_length
operator|=
name|SWAPLONG
argument_list|(
name|total_length
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check the sanity of the total length. 	 */
if|if
condition|(
name|total_length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|bhdrp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|shbp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Section Header Block in pcap-ng dump file has a length of %u< %lu"
argument_list|,
name|total_length
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bhdrp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|shbp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * OK, this is a good pcap-ng file. 	 * Allocate a pcap_t for it. 	 */
name|p
operator|=
name|pcap_open_offline_common
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_ng_sf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* Allocation failed. */
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|swapped
operator|=
name|swapped
expr_stmt|;
name|ps
operator|=
name|p
operator|->
name|priv
expr_stmt|;
comment|/* 	 * What precision does the user want? 	 */
switch|switch
condition|(
name|precision
condition|)
block|{
case|case
name|PCAP_TSTAMP_PRECISION_MICRO
case|:
name|ps
operator|->
name|user_tsresol
operator|=
literal|1000000
expr_stmt|;
break|break;
case|case
name|PCAP_TSTAMP_PRECISION_NANO
case|:
name|ps
operator|->
name|user_tsresol
operator|=
literal|1000000000
expr_stmt|;
break|break;
default|default:
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown time stamp resolution %u"
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|=
name|precision
expr_stmt|;
comment|/* 	 * Allocate a buffer into which to read blocks.  We default to 	 * the maximum of: 	 * 	 *	the total length of the SHB for which we read the header; 	 * 	 *	2K, which should be more than large enough for an Enhanced 	 *	Packet Block containing a full-size Ethernet frame, and 	 *	leaving room for some options. 	 * 	 * If we find a bigger block, we reallocate the buffer. 	 */
name|p
operator|->
name|bufsize
operator|=
literal|2048
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bufsize
operator|<
name|total_length
condition|)
name|p
operator|->
name|bufsize
operator|=
name|total_length
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Copy the stuff we've read to the buffer, and read the rest 	 * of the SHB. 	 */
name|bhdrp
operator|=
operator|(
expr|struct
name|block_header
operator|*
operator|)
name|p
operator|->
name|buffer
expr_stmt|;
name|shbp
operator|=
operator|(
expr|struct
name|section_header_block
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|buffer
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
operator|)
expr_stmt|;
name|bhdrp
operator|->
name|block_type
operator|=
name|magic
expr_stmt|;
name|bhdrp
operator|->
name|total_length
operator|=
name|total_length
expr_stmt|;
name|shbp
operator|->
name|byte_order_magic
operator|=
name|byte_order_magic
expr_stmt|;
if|if
condition|(
name|read_bytes
argument_list|(
name|fp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|buffer
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|total_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|byte_order_magic
argument_list|)
operator|)
argument_list|,
name|total_length
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|total_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|byte_order_magic
argument_list|)
operator|)
argument_list|,
literal|1
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
comment|/* 		 * Byte-swap the fields we've read. 		 */
name|shbp
operator|->
name|major_version
operator|=
name|SWAPSHORT
argument_list|(
name|shbp
operator|->
name|major_version
argument_list|)
expr_stmt|;
name|shbp
operator|->
name|minor_version
operator|=
name|SWAPSHORT
argument_list|(
name|shbp
operator|->
name|minor_version
argument_list|)
expr_stmt|;
comment|/* 		 * XXX - we don't care about the section length. 		 */
block|}
comment|/* currently only SHB version 1.0 is supported */
if|if
condition|(
operator|!
operator|(
name|shbp
operator|->
name|major_version
operator|==
name|PCAP_NG_VERSION_MAJOR
operator|&&
name|shbp
operator|->
name|minor_version
operator|==
name|PCAP_NG_VERSION_MINOR
operator|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unsupported pcap-ng savefile version %u.%u"
argument_list|,
name|shbp
operator|->
name|major_version
argument_list|,
name|shbp
operator|->
name|minor_version
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|p
operator|->
name|version_major
operator|=
name|shbp
operator|->
name|major_version
expr_stmt|;
name|p
operator|->
name|version_minor
operator|=
name|shbp
operator|->
name|minor_version
expr_stmt|;
comment|/* 	 * Save the time stamp resolution the user requested. 	 */
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|=
name|precision
expr_stmt|;
comment|/* 	 * Now start looking for an Interface Description Block. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Read the next block. 		 */
name|status
operator|=
name|read_block
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
operator|&
name|cursor
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* EOF - no IDB in this file */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"the capture file has no Interface Description Blocks"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
goto|goto
name|fail
goto|;
comment|/* error */
switch|switch
condition|(
name|cursor
operator|.
name|block_type
condition|)
block|{
case|case
name|BT_IDB
case|:
comment|/* 			 * Get a pointer to the fixed-length portion of the 			 * IDB. 			 */
name|idbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|idbp
argument_list|)
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|idbp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* error */
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
name|idbp
operator|->
name|linktype
operator|=
name|SWAPSHORT
argument_list|(
name|idbp
operator|->
name|linktype
argument_list|)
expr_stmt|;
name|idbp
operator|->
name|snaplen
operator|=
name|SWAPLONG
argument_list|(
name|idbp
operator|->
name|snaplen
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Interface capture length sanity check 			 */
if|if
condition|(
name|idbp
operator|->
name|snaplen
operator|>
name|MAXIMUM_SNAPLEN
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"invalid interface capture length %u, "
literal|"bigger than maximum of %u"
argument_list|,
name|idbp
operator|->
name|snaplen
argument_list|,
name|MAXIMUM_SNAPLEN
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 			 * Try to add this interface. 			 */
if|if
condition|(
operator|!
name|add_interface
argument_list|(
name|p
argument_list|,
operator|&
name|cursor
argument_list|,
name|errbuf
argument_list|)
condition|)
goto|goto
name|fail
goto|;
goto|goto
name|done
goto|;
case|case
name|BT_EPB
case|:
case|case
name|BT_SPB
case|:
case|case
name|BT_PB
case|:
comment|/* 			 * Saw a packet before we saw any IDBs.  That's 			 * not valid, as we don't know what link-layer 			 * encapsulation the packet has. 			 */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"the capture file has a packet block before any Interface Description Blocks"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
default|default:
comment|/* 			 * Just ignore it. 			 */
break|break;
block|}
block|}
name|done
label|:
name|p
operator|->
name|tzoff
operator|=
literal|0
expr_stmt|;
comment|/* XXX - not used in pcap */
name|p
operator|->
name|snapshot
operator|=
name|idbp
operator|->
name|snaplen
expr_stmt|;
name|p
operator|->
name|linktype
operator|=
name|linktype_to_dlt
argument_list|(
name|idbp
operator|->
name|linktype
argument_list|)
expr_stmt|;
name|p
operator|->
name|linktype_ext
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next_packet_op
operator|=
name|pcap_ng_next_packet
expr_stmt|;
name|p
operator|->
name|cleanup_op
operator|=
name|pcap_ng_cleanup
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|fail
label|:
name|free
argument_list|(
name|ps
operator|->
name|ifaces
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcap_ng_cleanup
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_ng_sf
modifier|*
name|ps
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|free
argument_list|(
name|ps
operator|->
name|ifaces
argument_list|)
expr_stmt|;
name|sf_cleanup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read and return the next packet from the savefile.  Return the header  * in hdr and a pointer to the contents in data.  Return 0 on success, 1  * if there were no more packets, and -1 on an error.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_ng_next_packet
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|pcap_ng_sf
modifier|*
name|ps
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|struct
name|block_cursor
name|cursor
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|enhanced_packet_block
modifier|*
name|epbp
decl_stmt|;
name|struct
name|simple_packet_block
modifier|*
name|spbp
decl_stmt|;
name|struct
name|packet_block
modifier|*
name|pbp
decl_stmt|;
name|bpf_u_int32
name|interface_id
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|struct
name|interface_description_block
modifier|*
name|idbp
decl_stmt|;
name|struct
name|section_header_block
modifier|*
name|shbp
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|p
operator|->
name|rfile
decl_stmt|;
name|u_int64_t
name|t
decl_stmt|,
name|sec
decl_stmt|,
name|frac
decl_stmt|;
comment|/* 	 * Look for an Enhanced Packet Block, a Simple Packet Block, 	 * or a Packet Block. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Read the block type and length; those are common 		 * to all blocks. 		 */
name|status
operator|=
name|read_block
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
operator|&
name|cursor
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* EOF */
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
switch|switch
condition|(
name|cursor
operator|.
name|block_type
condition|)
block|{
case|case
name|BT_EPB
case|:
comment|/* 			 * Get a pointer to the fixed-length portion of the 			 * EPB. 			 */
name|epbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|epbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|epbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
comment|/* these were written in opposite byte order */
name|interface_id
operator|=
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|interface_id
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|caplen
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|len
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|timestamp_high
argument_list|)
operator|)
operator|<<
literal|32
operator||
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|timestamp_low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|interface_id
operator|=
name|epbp
operator|->
name|interface_id
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|epbp
operator|->
name|caplen
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|epbp
operator|->
name|len
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|epbp
operator|->
name|timestamp_high
operator|)
operator|<<
literal|32
operator||
name|epbp
operator|->
name|timestamp_low
expr_stmt|;
block|}
goto|goto
name|found
goto|;
case|case
name|BT_SPB
case|:
comment|/* 			 * Get a pointer to the fixed-length portion of the 			 * SPB. 			 */
name|spbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|spbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|spbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * SPB packets are assumed to have arrived on 			 * the first interface. 			 */
name|interface_id
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
comment|/* these were written in opposite byte order */
name|hdr
operator|->
name|len
operator|=
name|SWAPLONG
argument_list|(
name|spbp
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|hdr
operator|->
name|len
operator|=
name|spbp
operator|->
name|len
expr_stmt|;
comment|/* 			 * The SPB doesn't give the captured length; 			 * it's the minimum of the snapshot length 			 * and the packet length. 			 */
name|hdr
operator|->
name|caplen
operator|=
name|hdr
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|caplen
operator|>
operator|(
name|bpf_u_int32
operator|)
name|p
operator|->
name|snapshot
condition|)
name|hdr
operator|->
name|caplen
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
comment|/* no time stamps */
goto|goto
name|found
goto|;
case|case
name|BT_PB
case|:
comment|/* 			 * Get a pointer to the fixed-length portion of the 			 * PB. 			 */
name|pbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
comment|/* these were written in opposite byte order */
name|interface_id
operator|=
name|SWAPSHORT
argument_list|(
name|pbp
operator|->
name|interface_id
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|SWAPLONG
argument_list|(
name|pbp
operator|->
name|caplen
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|SWAPLONG
argument_list|(
name|pbp
operator|->
name|len
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|SWAPLONG
argument_list|(
name|pbp
operator|->
name|timestamp_high
argument_list|)
operator|)
operator|<<
literal|32
operator||
name|SWAPLONG
argument_list|(
name|pbp
operator|->
name|timestamp_low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|interface_id
operator|=
name|pbp
operator|->
name|interface_id
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|pbp
operator|->
name|caplen
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|pbp
operator|->
name|len
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|pbp
operator|->
name|timestamp_high
operator|)
operator|<<
literal|32
operator||
name|pbp
operator|->
name|timestamp_low
expr_stmt|;
block|}
goto|goto
name|found
goto|;
case|case
name|BT_IDB
case|:
comment|/* 			 * Interface Description Block.  Get a pointer 			 * to its fixed-length portion. 			 */
name|idbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|idbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|idbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
name|idbp
operator|->
name|linktype
operator|=
name|SWAPSHORT
argument_list|(
name|idbp
operator|->
name|linktype
argument_list|)
expr_stmt|;
name|idbp
operator|->
name|snaplen
operator|=
name|SWAPLONG
argument_list|(
name|idbp
operator|->
name|snaplen
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If the link-layer type or snapshot length 			 * differ from the ones for the first IDB we 			 * saw, quit. 			 * 			 * XXX - just discard packets from those 			 * interfaces? 			 */
if|if
condition|(
name|p
operator|->
name|linktype
operator|!=
name|idbp
operator|->
name|linktype
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"an interface has a type %u different from the type of the first interface"
argument_list|,
name|idbp
operator|->
name|linktype
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bpf_u_int32
operator|)
name|p
operator|->
name|snapshot
operator|!=
name|idbp
operator|->
name|snaplen
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"an interface has a snapshot length %u different from the type of the first interface"
argument_list|,
name|idbp
operator|->
name|snaplen
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * Try to add this interface. 			 */
if|if
condition|(
operator|!
name|add_interface
argument_list|(
name|p
argument_list|,
operator|&
name|cursor
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|BT_SHB
case|:
comment|/* 			 * Section Header Block.  Get a pointer 			 * to its fixed-length portion. 			 */
name|shbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|shbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|shbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * Assume the byte order of this section is 			 * the same as that of the previous section. 			 * We'll check for that later. 			 */
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
name|shbp
operator|->
name|byte_order_magic
operator|=
name|SWAPLONG
argument_list|(
name|shbp
operator|->
name|byte_order_magic
argument_list|)
expr_stmt|;
name|shbp
operator|->
name|major_version
operator|=
name|SWAPSHORT
argument_list|(
name|shbp
operator|->
name|major_version
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Make sure the byte order doesn't change; 			 * pcap_is_swapped() shouldn't change its 			 * return value in the middle of reading a capture. 			 */
switch|switch
condition|(
name|shbp
operator|->
name|byte_order_magic
condition|)
block|{
case|case
name|BYTE_ORDER_MAGIC
case|:
comment|/* 				 * OK. 				 */
break|break;
case|case
name|SWAPLONG
argument_list|(
name|BYTE_ORDER_MAGIC
argument_list|)
case|:
comment|/* 				 * Byte order changes. 				 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"the file has sections with different byte orders"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
comment|/* 				 * Not a valid SHB. 				 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"the file has a section with a bad byte order magic field"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * Make sure the major version is the version 			 * we handle. 			 */
if|if
condition|(
name|shbp
operator|->
name|major_version
operator|!=
name|PCAP_NG_VERSION_MAJOR
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown pcap-ng savefile major version number %u"
argument_list|,
name|shbp
operator|->
name|major_version
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * Reset the interface count; this section should 			 * have its own set of IDBs.  If any of them 			 * don't have the same interface type, snapshot 			 * length, or resolution as the first interface 			 * we saw, we'll fail.  (And if we don't see 			 * any IDBs, we'll fail when we see a packet 			 * block.) 			 */
name|ps
operator|->
name|ifcount
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Not a packet block, IDB, or SHB; ignore it. 			 */
break|break;
block|}
block|}
name|found
label|:
comment|/* 	 * Is the interface ID an interface we know? 	 */
if|if
condition|(
name|interface_id
operator|>=
name|ps
operator|->
name|ifcount
condition|)
block|{
comment|/* 		 * Yes.  Fail. 		 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"a packet arrived on interface %u, but there's no Interface Description Block for that interface"
argument_list|,
name|interface_id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Convert the time stamp to seconds and fractions of a second, 	 * with the fractions being in units of the file-supplied resolution. 	 */
name|sec
operator|=
name|t
operator|/
name|ps
operator|->
name|ifaces
index|[
name|interface_id
index|]
operator|.
name|tsresol
operator|+
name|ps
operator|->
name|ifaces
index|[
name|interface_id
index|]
operator|.
name|tsoffset
expr_stmt|;
name|frac
operator|=
name|t
operator|%
name|ps
operator|->
name|ifaces
index|[
name|interface_id
index|]
operator|.
name|tsresol
expr_stmt|;
comment|/* 	 * Convert the fractions from units of the file-supplied resolution 	 * to units of the user-requested resolution. 	 */
switch|switch
condition|(
name|ps
operator|->
name|ifaces
index|[
name|interface_id
index|]
operator|.
name|scale_type
condition|)
block|{
case|case
name|PASS_THROUGH
case|:
comment|/* 		 * The interface resolution is what the user wants, 		 * so we're done. 		 */
break|break;
case|case
name|SCALE_UP_DEC
case|:
comment|/* 		 * The interface resolution is less than what the user 		 * wants; scale the fractional part up to the units of 		 * the resolution the user requested by multiplying by 		 * the quotient of the user-requested resolution and the 		 * file-supplied resolution. 		 * 		 * Those resolutions are both powers of 10, and the user- 		 * requested resolution is greater than the file-supplied 		 * resolution, so the quotient in question is an integer. 		 * We've calculated that quotient already, so we just 		 * multiply by it. 		 */
name|frac
operator|*=
name|ps
operator|->
name|ifaces
index|[
name|interface_id
index|]
operator|.
name|scale_factor
expr_stmt|;
break|break;
case|case
name|SCALE_UP_BIN
case|:
comment|/* 		 * The interface resolution is less than what the user 		 * wants; scale the fractional part up to the units of 		 * the resolution the user requested by multiplying by 		 * the quotient of the user-requested resolution and the 		 * file-supplied resolution. 		 * 		 * The file-supplied resolution is a power of 2, so the 		 * quotient is not an integer, so, in order to do this 		 * entirely with integer arithmetic, we multiply by the 		 * user-requested resolution and divide by the file- 		 * supplied resolution. 		 * 		 * XXX - Is there something clever we could do here, 		 * given that we know that the file-supplied resolution 		 * is a power of 2?  Doing a multiplication followed by 		 * a division runs the risk of overflowing, and involves 		 * two non-simple arithmetic operations. 		 */
name|frac
operator|*=
name|ps
operator|->
name|user_tsresol
expr_stmt|;
name|frac
operator|/=
name|ps
operator|->
name|ifaces
index|[
name|interface_id
index|]
operator|.
name|tsresol
expr_stmt|;
break|break;
case|case
name|SCALE_DOWN_DEC
case|:
comment|/* 		 * The interface resolution is greater than what the user 		 * wants; scale the fractional part up to the units of 		 * the resolution the user requested by multiplying by 		 * the quotient of the user-requested resolution and the 		 * file-supplied resolution. 		 * 		 * Those resolutions are both powers of 10, and the user- 		 * requested resolution is less than the file-supplied 		 * resolution, so the quotient in question isn't an 		 * integer, but its reciprocal is, and we can just divide 		 * by the reciprocal of the quotient.  We've calculated 		 * the reciprocal of that quotient already, so we must 		 * divide by it. 		 */
name|frac
operator|/=
name|ps
operator|->
name|ifaces
index|[
name|interface_id
index|]
operator|.
name|scale_factor
expr_stmt|;
break|break;
case|case
name|SCALE_DOWN_BIN
case|:
comment|/* 		 * The interface resolution is greater than what the user 		 * wants; convert the fractional part to units of the 		 * resolution the user requested by multiplying by the 		 * quotient of the user-requested resolution and the 		 * file-supplied resolution.  We do that by multiplying 		 * by the user-requested resolution and dividing by the 		 * file-supplied resolution, as the quotient might not 		 * fit in an integer. 		 * 		 * The file-supplied resolution is a power of 2, so the 		 * quotient is not an integer, and neither is its 		 * reciprocal, so, in order to do this entirely with 		 * integer arithmetic, we multiply by the user-requested 		 * resolution and divide by the file-supplied resolution. 		 * 		 * XXX - Is there something clever we could do here, 		 * given that we know that the file-supplied resolution 		 * is a power of 2?  Doing a multiplication followed by 		 * a division runs the risk of overflowing, and involves 		 * two non-simple arithmetic operations. 		 */
name|frac
operator|*=
name|ps
operator|->
name|user_tsresol
expr_stmt|;
name|frac
operator|/=
name|ps
operator|->
name|ifaces
index|[
name|interface_id
index|]
operator|.
name|tsresol
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|_WIN32
comment|/* 	 * tv_sec and tv_used in the Windows struct timeval are both 	 * longs. 	 */
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|sec
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
operator|(
name|long
operator|)
name|frac
expr_stmt|;
else|#
directive|else
comment|/* 	 * tv_sec in the UN*X struct timeval is a time_t; tv_usec is 	 * suseconds_t in UN*Xes that work the way the current Single 	 * UNIX Standard specify - but not all older UN*Xes necessarily 	 * support that type, so just cast to int. 	 */
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|sec
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
operator|(
name|int
operator|)
name|frac
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Get a pointer to the packet data. 	 */
operator|*
name|data
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
name|swap_pseudo_headers
argument_list|(
name|p
operator|->
name|linktype
argument_list|,
name|hdr
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

