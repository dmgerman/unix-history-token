begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * sf-pcap-ng.c - pcap-ng-file-format-specific code from savefile.c  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header$ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_include
include|#
directive|include
file|<pcap-stdinc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* WIN32 */
end_comment

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_STDINT_H
end_elif

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BITYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bitypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"pcap-common.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sf-pcap-ng.h"
end_include

begin_comment
comment|/*  * Block types.  */
end_comment

begin_comment
comment|/*  * Common part at the beginning of all blocks.  */
end_comment

begin_struct
struct|struct
name|block_header
block|{
name|bpf_u_int32
name|block_type
decl_stmt|;
name|bpf_u_int32
name|total_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Common trailer at the end of all blocks.  */
end_comment

begin_struct
struct|struct
name|block_trailer
block|{
name|bpf_u_int32
name|total_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Common options.  */
end_comment

begin_define
define|#
directive|define
name|OPT_ENDOFOPT
value|0
end_define

begin_comment
comment|/* end of options */
end_comment

begin_define
define|#
directive|define
name|OPT_COMMENT
value|1
end_define

begin_comment
comment|/* comment string */
end_comment

begin_comment
comment|/*  * Option header.  */
end_comment

begin_struct
struct|struct
name|option_header
block|{
name|u_short
name|option_code
decl_stmt|;
name|u_short
name|option_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Structures for the part of each block type following the common  * part.  */
end_comment

begin_comment
comment|/*  * Section Header Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_SHB
value|0x0A0D0D0A
end_define

begin_struct
struct|struct
name|section_header_block
block|{
name|bpf_u_int32
name|byte_order_magic
decl_stmt|;
name|u_short
name|major_version
decl_stmt|;
name|u_short
name|minor_version
decl_stmt|;
name|u_int64_t
name|section_length
decl_stmt|;
comment|/* followed by options and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Byte-order magic value.  */
end_comment

begin_define
define|#
directive|define
name|BYTE_ORDER_MAGIC
value|0x1A2B3C4D
end_define

begin_comment
comment|/*  * Current version number.  If major_version isn't PCAP_NG_VERSION_MAJOR,  * that means that this code can't read the file.  */
end_comment

begin_define
define|#
directive|define
name|PCAP_NG_VERSION_MAJOR
value|1
end_define

begin_comment
comment|/*  * Interface Description Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_IDB
value|0x00000001
end_define

begin_struct
struct|struct
name|interface_description_block
block|{
name|u_short
name|linktype
decl_stmt|;
name|u_short
name|reserved
decl_stmt|;
name|bpf_u_int32
name|snaplen
decl_stmt|;
comment|/* followed by options and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Options in the IDB.  */
end_comment

begin_define
define|#
directive|define
name|IF_NAME
value|2
end_define

begin_comment
comment|/* interface name string */
end_comment

begin_define
define|#
directive|define
name|IF_DESCRIPTION
value|3
end_define

begin_comment
comment|/* interface description string */
end_comment

begin_define
define|#
directive|define
name|IF_IPV4ADDR
value|4
end_define

begin_comment
comment|/* interface's IPv4 address and netmask */
end_comment

begin_define
define|#
directive|define
name|IF_IPV6ADDR
value|5
end_define

begin_comment
comment|/* interface's IPv6 address and prefix length */
end_comment

begin_define
define|#
directive|define
name|IF_MACADDR
value|6
end_define

begin_comment
comment|/* interface's MAC address */
end_comment

begin_define
define|#
directive|define
name|IF_EUIADDR
value|7
end_define

begin_comment
comment|/* interface's EUI address */
end_comment

begin_define
define|#
directive|define
name|IF_SPEED
value|8
end_define

begin_comment
comment|/* interface's speed, in bits/s */
end_comment

begin_define
define|#
directive|define
name|IF_TSRESOL
value|9
end_define

begin_comment
comment|/* interface's time stamp resolution */
end_comment

begin_define
define|#
directive|define
name|IF_TZONE
value|10
end_define

begin_comment
comment|/* interface's time zone */
end_comment

begin_define
define|#
directive|define
name|IF_FILTER
value|11
end_define

begin_comment
comment|/* filter used when capturing on interface */
end_comment

begin_define
define|#
directive|define
name|IF_OS
value|12
end_define

begin_comment
comment|/* string OS on which capture on this interface was done */
end_comment

begin_define
define|#
directive|define
name|IF_FCSLEN
value|13
end_define

begin_comment
comment|/* FCS length for this interface */
end_comment

begin_define
define|#
directive|define
name|IF_TSOFFSET
value|14
end_define

begin_comment
comment|/* time stamp offset for this interface */
end_comment

begin_comment
comment|/*  * Enhanced Packet Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_EPB
value|0x00000006
end_define

begin_struct
struct|struct
name|enhanced_packet_block
block|{
name|bpf_u_int32
name|interface_id
decl_stmt|;
name|bpf_u_int32
name|timestamp_high
decl_stmt|;
name|bpf_u_int32
name|timestamp_low
decl_stmt|;
name|bpf_u_int32
name|caplen
decl_stmt|;
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* followed by packet data, options, and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Simple Packet Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_SPB
value|0x00000003
end_define

begin_struct
struct|struct
name|simple_packet_block
block|{
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* followed by packet data and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Packet Block.  */
end_comment

begin_define
define|#
directive|define
name|BT_PB
value|0x00000002
end_define

begin_struct
struct|struct
name|packet_block
block|{
name|u_short
name|interface_id
decl_stmt|;
name|u_short
name|drops_count
decl_stmt|;
name|bpf_u_int32
name|timestamp_high
decl_stmt|;
name|bpf_u_int32
name|timestamp_low
decl_stmt|;
name|bpf_u_int32
name|caplen
decl_stmt|;
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* followed by packet data, options, and trailer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Block cursor - used when processing the contents of a block.  * Contains a pointer into the data being processed and a count  * of bytes remaining in the block.  */
end_comment

begin_struct
struct|struct
name|block_cursor
block|{
name|u_char
modifier|*
name|data
decl_stmt|;
name|size_t
name|data_remaining
decl_stmt|;
name|bpf_u_int32
name|block_type
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|pcap_ng_next_packet
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|read_bytes
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|bytes_to_read
parameter_list|,
name|int
name|fail_on_eof
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|size_t
name|amt_read
decl_stmt|;
name|amt_read
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|bytes_to_read
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
name|bytes_to_read
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|amt_read
operator|==
literal|0
operator|&&
operator|!
name|fail_on_eof
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* EOF */
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %lu bytes, only got %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytes_to_read
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_block
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|block_header
name|bhdr
decl_stmt|;
name|status
operator|=
name|read_bytes
argument_list|(
name|fp
argument_list|,
operator|&
name|bhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
return|return
operator|(
name|status
operator|)
return|;
comment|/* error or EOF */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
name|bhdr
operator|.
name|block_type
operator|=
name|SWAPLONG
argument_list|(
name|bhdr
operator|.
name|block_type
argument_list|)
expr_stmt|;
name|bhdr
operator|.
name|total_length
operator|=
name|SWAPLONG
argument_list|(
name|bhdr
operator|.
name|total_length
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Is this block "too big"? 	 * 	 * We choose 16MB as "too big", for now, so that we handle 	 * "reasonably" large buffers but don't chew up all the 	 * memory if we read a malformed file. 	 */
if|if
condition|(
name|bhdr
operator|.
name|total_length
operator|>
literal|16
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"pcap-ng block size %u> maximum %u"
argument_list|,
name|bhdr
operator|.
name|total_length
argument_list|,
literal|16
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Is this block "too small" - i.e., is it shorter than a block 	 * header plus a block trailer? 	 */
if|if
condition|(
name|bhdr
operator|.
name|total_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"block in pcap-ng dump file has a length of %u< %lu"
argument_list|,
name|bhdr
operator|.
name|total_length
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Is the buffer big enough? 	 */
if|if
condition|(
name|p
operator|->
name|bufsize
operator|<
name|bhdr
operator|.
name|total_length
condition|)
block|{
comment|/* 		 * No - make it big enough. 		 */
name|p
operator|->
name|buffer
operator|=
name|realloc
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
name|bhdr
operator|.
name|total_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Copy the stuff we've read to the buffer, and read the rest 	 * of the block. 	 */
name|memcpy
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
operator|&
name|bhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bytes
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
argument_list|,
name|bhdr
operator|.
name|total_length
operator|-
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Initialize the cursor. 	 */
name|cursor
operator|->
name|data
operator|=
name|p
operator|->
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
expr_stmt|;
name|cursor
operator|->
name|data_remaining
operator|=
name|bhdr
operator|.
name|total_length
operator|-
sizeof|sizeof
argument_list|(
name|bhdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
expr_stmt|;
name|cursor
operator|->
name|block_type
operator|=
name|bhdr
operator|.
name|block_type
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_from_block_data
parameter_list|(
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|size_t
name|chunk_size
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
comment|/* 	 * Make sure we have the specified amount of data remaining in 	 * the block data. 	 */
if|if
condition|(
name|cursor
operator|->
name|data_remaining
operator|<
name|chunk_size
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"block of type %u in pcap-ng dump file is too short"
argument_list|,
name|cursor
operator|->
name|block_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Return the current pointer, and skip past the chunk. 	 */
name|data
operator|=
name|cursor
operator|->
name|data
expr_stmt|;
name|cursor
operator|->
name|data
operator|+=
name|chunk_size
expr_stmt|;
name|cursor
operator|->
name|data_remaining
operator|-=
name|chunk_size
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|option_header
modifier|*
name|get_opthdr_from_block_data
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|option_header
modifier|*
name|opthdr
decl_stmt|;
name|opthdr
operator|=
name|get_from_block_data
argument_list|(
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opthdr
argument_list|)
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opthdr
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Option header is cut short. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Byte-swap it if necessary. 	 */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
name|opthdr
operator|->
name|option_code
operator|=
name|SWAPSHORT
argument_list|(
name|opthdr
operator|->
name|option_code
argument_list|)
expr_stmt|;
name|opthdr
operator|->
name|option_length
operator|=
name|SWAPSHORT
argument_list|(
name|opthdr
operator|->
name|option_length
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|opthdr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_optvalue_from_block_data
parameter_list|(
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|struct
name|option_header
modifier|*
name|opthdr
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|size_t
name|padded_option_len
decl_stmt|;
name|void
modifier|*
name|optvalue
decl_stmt|;
comment|/* Pad option length to 4-byte boundary */
name|padded_option_len
operator|=
name|opthdr
operator|->
name|option_length
expr_stmt|;
name|padded_option_len
operator|=
operator|(
operator|(
name|padded_option_len
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
expr_stmt|;
name|optvalue
operator|=
name|get_from_block_data
argument_list|(
name|cursor
argument_list|,
name|padded_option_len
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|optvalue
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Option value is cut short. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|optvalue
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_idb_options
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|block_cursor
modifier|*
name|cursor
parameter_list|,
name|u_int
modifier|*
name|tsresol
parameter_list|,
name|u_int64_t
modifier|*
name|tsoffset
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|option_header
modifier|*
name|opthdr
decl_stmt|;
name|void
modifier|*
name|optvalue
decl_stmt|;
name|int
name|saw_tsresol
decl_stmt|,
name|saw_tsoffset
decl_stmt|;
name|u_char
name|tsresol_opt
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|saw_tsresol
operator|=
literal|0
expr_stmt|;
name|saw_tsoffset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cursor
operator|->
name|data_remaining
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Get the option header. 		 */
name|opthdr
operator|=
name|get_opthdr_from_block_data
argument_list|(
name|p
argument_list|,
name|cursor
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opthdr
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Option header is cut short. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Get option value. 		 */
name|optvalue
operator|=
name|get_optvalue_from_block_data
argument_list|(
name|cursor
argument_list|,
name|opthdr
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|optvalue
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Option value is cut short. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|opthdr
operator|->
name|option_code
condition|)
block|{
case|case
name|OPT_ENDOFOPT
case|:
if|if
condition|(
name|opthdr
operator|->
name|option_length
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has opt_endofopt option with length %u != 0"
argument_list|,
name|opthdr
operator|->
name|option_length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
goto|goto
name|done
goto|;
case|case
name|IF_TSRESOL
case|:
if|if
condition|(
name|opthdr
operator|->
name|option_length
operator|!=
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has if_tsresol option with length %u != 1"
argument_list|,
name|opthdr
operator|->
name|option_length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|saw_tsresol
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has more than one if_tsresol option"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|saw_tsresol
operator|=
literal|1
expr_stmt|;
name|tsresol_opt
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|optvalue
expr_stmt|;
if|if
condition|(
name|tsresol_opt
operator|&
literal|0x80
condition|)
block|{
comment|/* 				 * Resolution is negative power of 2. 				 */
operator|*
name|tsresol
operator|=
literal|1
operator|<<
operator|(
name|tsresol_opt
operator|&
literal|0x7F
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Resolution is negative power of 10. 				 */
operator|*
name|tsresol
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tsresol_opt
condition|;
name|i
operator|++
control|)
operator|*
name|tsresol
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tsresol
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Resolution is too high. 				 */
if|if
condition|(
name|tsresol_opt
operator|&
literal|0x80
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block if_tsresol option resolution 2^-%u is too high"
argument_list|,
name|tsresol_opt
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block if_tsresol option resolution 10^-%u is too high"
argument_list|,
name|tsresol_opt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|IF_TSOFFSET
case|:
if|if
condition|(
name|opthdr
operator|->
name|option_length
operator|!=
literal|8
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has if_tsoffset option with length %u != 8"
argument_list|,
name|opthdr
operator|->
name|option_length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|saw_tsoffset
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface Description Block has more than one if_tsoffset option"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|saw_tsoffset
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|tsoffset
argument_list|,
name|optvalue
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tsoffset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
operator|*
name|tsoffset
operator|=
name|SWAPLL
argument_list|(
operator|*
name|tsoffset
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|done
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether this is a pcap-ng savefile and, if it is, extract the  * relevant information from the header.  */
end_comment

begin_function
name|int
name|pcap_ng_check_header
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|magic
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|size_t
name|amt_read
decl_stmt|;
name|bpf_u_int32
name|total_length
decl_stmt|;
name|bpf_u_int32
name|byte_order_magic
decl_stmt|;
name|struct
name|block_header
modifier|*
name|bhdrp
decl_stmt|;
name|struct
name|section_header_block
modifier|*
name|shbp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|block_cursor
name|cursor
decl_stmt|;
name|struct
name|interface_description_block
modifier|*
name|idbp
decl_stmt|;
comment|/* 	 * Check whether the first 4 bytes of the file are the block 	 * type for a pcap-ng savefile.  	 */
if|if
condition|(
name|magic
operator|!=
name|BT_SHB
condition|)
block|{
comment|/* 		 * XXX - check whether this looks like what the block 		 * type would be after being munged by mapping between 		 * UN*X and DOS/Windows text file format and, if it 		 * does, look for the byte-order magic number in 		 * the appropriate place and, if we find it, report 		 * this as possibly being a pcap-ng file transferred 		 * between UN*X and Windows in text file format? 		 */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nope */
block|}
comment|/* 	 * OK, they are.  However, that's just \n\r\r\n, so it could, 	 * conceivably, be an ordinary text file. 	 * 	 * It could not, however, conceivably be any other type of 	 * capture file, so we can read the rest of the putative 	 * Section Header Block; put the block type in the common 	 * header, read the rest of the common header and the 	 * fixed-length portion of the SHB, and look for the byte-order 	 * magic value. 	 */
name|amt_read
operator|=
name|fread
argument_list|(
operator|&
name|total_length
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|total_length
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|<
sizeof|sizeof
argument_list|(
name|total_length
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* fail */
block|}
comment|/* 		 * Possibly a weird short text file, so just say 		 * "not pcap-ng". 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|amt_read
operator|=
name|fread
argument_list|(
operator|&
name|byte_order_magic
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|byte_order_magic
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|<
sizeof|sizeof
argument_list|(
name|byte_order_magic
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* fail */
block|}
comment|/* 		 * Possibly a weird short text file, so just say 		 * "not pcap-ng". 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|byte_order_magic
operator|!=
name|BYTE_ORDER_MAGIC
condition|)
block|{
name|byte_order_magic
operator|=
name|SWAPLONG
argument_list|(
name|byte_order_magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_order_magic
operator|!=
name|BYTE_ORDER_MAGIC
condition|)
block|{
comment|/* 			 * Not a pcap-ng file. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|->
name|sf
operator|.
name|swapped
operator|=
literal|1
expr_stmt|;
name|total_length
operator|=
name|SWAPLONG
argument_list|(
name|total_length
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check the sanity of the total length. 	 */
if|if
condition|(
name|total_length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|bhdrp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|shbp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Section Header Block in pcap-ng dump file has a length of %u< %lu"
argument_list|,
name|total_length
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bhdrp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|shbp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_trailer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Allocate a buffer into which to read blocks.  We default to 	 * the maximum of: 	 * 	 *	the total length of the SHB for which we read the header; 	 * 	 *	2K, which should be more than large enough for an Enhanced 	 *	Packet Block containing a full-size Ethernet frame, and 	 *	leaving room for some options. 	 * 	 * If we find a bigger block, we reallocate the buffer. 	 */
name|p
operator|->
name|bufsize
operator|=
literal|2048
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bufsize
operator|<
name|total_length
condition|)
name|p
operator|->
name|bufsize
operator|=
name|total_length
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Copy the stuff we've read to the buffer, and read the rest 	 * of the SHB. 	 */
name|bhdrp
operator|=
operator|(
expr|struct
name|block_header
operator|*
operator|)
name|p
operator|->
name|buffer
expr_stmt|;
name|shbp
operator|=
operator|(
expr|struct
name|section_header_block
operator|*
operator|)
operator|(
name|p
operator|->
name|buffer
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
operator|)
expr_stmt|;
name|bhdrp
operator|->
name|block_type
operator|=
name|magic
expr_stmt|;
name|bhdrp
operator|->
name|total_length
operator|=
name|total_length
expr_stmt|;
name|shbp
operator|->
name|byte_order_magic
operator|=
name|byte_order_magic
expr_stmt|;
if|if
condition|(
name|read_bytes
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|buffer
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|total_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|byte_order_magic
argument_list|)
operator|)
argument_list|,
name|total_length
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|total_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|byte_order_magic
argument_list|)
operator|)
argument_list|,
literal|1
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
comment|/* 		 * Byte-swap the fields we've read. 		 */
name|shbp
operator|->
name|major_version
operator|=
name|SWAPSHORT
argument_list|(
name|shbp
operator|->
name|major_version
argument_list|)
expr_stmt|;
name|shbp
operator|->
name|minor_version
operator|=
name|SWAPSHORT
argument_list|(
name|shbp
operator|->
name|minor_version
argument_list|)
expr_stmt|;
comment|/* 		 * XXX - we don't care about the section length. 		 */
block|}
if|if
condition|(
name|shbp
operator|->
name|major_version
operator|!=
name|PCAP_NG_VERSION_MAJOR
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown pcap-ng savefile major version number %u"
argument_list|,
name|shbp
operator|->
name|major_version
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|p
operator|->
name|sf
operator|.
name|version_major
operator|=
name|shbp
operator|->
name|major_version
expr_stmt|;
name|p
operator|->
name|sf
operator|.
name|version_minor
operator|=
name|shbp
operator|->
name|minor_version
expr_stmt|;
comment|/* 	 * Set the default time stamp resolution and offset. 	 */
name|p
operator|->
name|sf
operator|.
name|tsresol
operator|=
literal|1000000
expr_stmt|;
comment|/* microsecond resolution */
name|p
operator|->
name|sf
operator|.
name|tsscale
operator|=
literal|1
expr_stmt|;
comment|/* multiply by 1 to scale to microseconds */
name|p
operator|->
name|sf
operator|.
name|tsoffset
operator|=
literal|0
expr_stmt|;
comment|/* absolute timestamps */
comment|/* 	 * Now start looking for an Interface Description Block. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Read the next block. 		 */
name|status
operator|=
name|read_block
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
operator|&
name|cursor
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* EOF - no IDB in this file */
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"the capture file has no Interface Description Blocks"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
goto|goto
name|fail
goto|;
comment|/* error */
switch|switch
condition|(
name|cursor
operator|.
name|block_type
condition|)
block|{
case|case
name|BT_IDB
case|:
comment|/* 			 * Get a pointer to the fixed-length portion of the 			 * IDB. 			 */
name|idbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|idbp
argument_list|)
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|idbp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* error */
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
name|idbp
operator|->
name|linktype
operator|=
name|SWAPSHORT
argument_list|(
name|idbp
operator|->
name|linktype
argument_list|)
expr_stmt|;
name|idbp
operator|->
name|snaplen
operator|=
name|SWAPLONG
argument_list|(
name|idbp
operator|->
name|snaplen
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Count this interface. 			 */
name|p
operator|->
name|sf
operator|.
name|ifcount
operator|++
expr_stmt|;
comment|/* 			 * Now look for various time stamp options, so 			 * we know how to interpret the time stamps. 			 */
if|if
condition|(
name|process_idb_options
argument_list|(
name|p
argument_list|,
operator|&
name|cursor
argument_list|,
operator|&
name|p
operator|->
name|sf
operator|.
name|tsresol
argument_list|,
operator|&
name|p
operator|->
name|sf
operator|.
name|tsoffset
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|fail
goto|;
comment|/* 			 * Compute the scaling factor to convert the 			 * sub-second part of the time stamp to 			 * microseconds. 			 */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|tsresol
operator|>
literal|1000000
condition|)
block|{
comment|/* 				 * Higher than microsecond resolution; 				 * scale down to microseconds. 				 */
name|p
operator|->
name|sf
operator|.
name|tsscale
operator|=
operator|(
name|p
operator|->
name|sf
operator|.
name|tsresol
operator|/
literal|1000000
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Lower than microsecond resolution; 				 * scale up to microseconds. 				 */
name|p
operator|->
name|sf
operator|.
name|tsscale
operator|=
operator|(
literal|1000000
operator|/
name|p
operator|->
name|sf
operator|.
name|tsresol
operator|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
case|case
name|BT_EPB
case|:
case|case
name|BT_SPB
case|:
case|case
name|BT_PB
case|:
comment|/* 			 * Saw a packet before we saw any IDBs.  That's 			 * not valid, as we don't know what link-layer 			 * encapsulation the packet has. 			 */
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"the capture file has a packet block before any Interface Description Blocks"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
default|default:
comment|/* 			 * Just ignore it. 			 */
break|break;
block|}
block|}
name|done
label|:
name|p
operator|->
name|tzoff
operator|=
literal|0
expr_stmt|;
comment|/* XXX - not used in pcap */
name|p
operator|->
name|snapshot
operator|=
name|idbp
operator|->
name|snaplen
expr_stmt|;
name|p
operator|->
name|linktype
operator|=
name|idbp
operator|->
name|linktype
expr_stmt|;
name|p
operator|->
name|linktype_ext
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sf
operator|.
name|next_packet_op
operator|=
name|pcap_ng_next_packet
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|fail
label|:
name|free
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read and return the next packet from the savefile.  Return the header  * in hdr and a pointer to the contents in data.  Return 0 on success, 1  * if there were no more packets, and -1 on an error.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_ng_next_packet
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|block_cursor
name|cursor
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|enhanced_packet_block
modifier|*
name|epbp
decl_stmt|;
name|struct
name|simple_packet_block
modifier|*
name|spbp
decl_stmt|;
name|struct
name|packet_block
modifier|*
name|pbp
decl_stmt|;
name|bpf_u_int32
name|interface_id
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|size_t
name|pblock_len
decl_stmt|;
name|struct
name|interface_description_block
modifier|*
name|idbp
decl_stmt|;
name|struct
name|section_header_block
modifier|*
name|shbp
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|p
operator|->
name|sf
operator|.
name|rfile
decl_stmt|;
name|u_int
name|tsresol
decl_stmt|;
name|u_int64_t
name|tsoffset
decl_stmt|;
name|u_int64_t
name|t
decl_stmt|,
name|sec
decl_stmt|,
name|frac
decl_stmt|;
comment|/* 	 * Look for an Enhanced Packet Block, a Simple Packet Block, 	 * or a Packet Block. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Read the block type and length; those are common 		 * to all blocks. 		 */
name|status
operator|=
name|read_block
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
operator|&
name|cursor
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* EOF */
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
switch|switch
condition|(
name|cursor
operator|.
name|block_type
condition|)
block|{
case|case
name|BT_EPB
case|:
comment|/* 			 * Get a pointer to the fixed-length portion of the 			 * EPB. 			 */
name|epbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|epbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|epbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
comment|/* these were written in opposite byte order */
name|interface_id
operator|=
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|interface_id
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|caplen
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|len
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|timestamp_high
argument_list|)
operator|)
operator|<<
literal|32
operator||
name|SWAPLONG
argument_list|(
name|epbp
operator|->
name|timestamp_low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|interface_id
operator|=
name|epbp
operator|->
name|interface_id
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|epbp
operator|->
name|caplen
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|epbp
operator|->
name|len
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|epbp
operator|->
name|timestamp_high
operator|)
operator|<<
literal|32
operator||
name|epbp
operator|->
name|timestamp_low
expr_stmt|;
block|}
name|pblock_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|epbp
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
case|case
name|BT_SPB
case|:
comment|/* 			 * Get a pointer to the fixed-length portion of the 			 * SPB. 			 */
name|spbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|spbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|spbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * SPB packets are assumed to have arrived on 			 * the first interface. 			 */
name|interface_id
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
comment|/* these were written in opposite byte order */
name|hdr
operator|->
name|len
operator|=
name|SWAPLONG
argument_list|(
name|spbp
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|hdr
operator|->
name|len
operator|=
name|spbp
operator|->
name|len
expr_stmt|;
comment|/* 			 * The SPB doesn't give the captured length; 			 * it's the minimum of the snapshot length 			 * and the packet length. 			 */
name|hdr
operator|->
name|caplen
operator|=
name|hdr
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|caplen
operator|>
name|p
operator|->
name|snapshot
condition|)
name|hdr
operator|->
name|caplen
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
comment|/* no time stamps */
name|pblock_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|spbp
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
case|case
name|BT_PB
case|:
comment|/* 			 * Get a pointer to the fixed-length portion of the 			 * PB. 			 */
name|pbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
comment|/* these were written in opposite byte order */
name|interface_id
operator|=
name|SWAPSHORT
argument_list|(
name|pbp
operator|->
name|interface_id
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|SWAPLONG
argument_list|(
name|pbp
operator|->
name|caplen
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|SWAPLONG
argument_list|(
name|pbp
operator|->
name|len
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|SWAPLONG
argument_list|(
name|pbp
operator|->
name|timestamp_high
argument_list|)
operator|)
operator|<<
literal|32
operator||
name|SWAPLONG
argument_list|(
name|pbp
operator|->
name|timestamp_low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|interface_id
operator|=
name|pbp
operator|->
name|interface_id
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|pbp
operator|->
name|caplen
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|pbp
operator|->
name|len
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|pbp
operator|->
name|timestamp_high
operator|)
operator|<<
literal|32
operator||
name|pbp
operator|->
name|timestamp_low
expr_stmt|;
block|}
name|pblock_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pbp
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
case|case
name|BT_IDB
case|:
comment|/* 			 * Interface Description Block.  Get a pointer 			 * to its fixed-length portion. 			 */
name|idbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|idbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|idbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * Byte-swap it if necessary. 			 */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
name|idbp
operator|->
name|linktype
operator|=
name|SWAPSHORT
argument_list|(
name|idbp
operator|->
name|linktype
argument_list|)
expr_stmt|;
name|idbp
operator|->
name|snaplen
operator|=
name|SWAPLONG
argument_list|(
name|idbp
operator|->
name|snaplen
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If the link-layer type or snapshot length 			 * differ from the ones for the first IDB we 			 * saw, quit. 			 * 			 * XXX - just discard packets from those 			 * interfaces? 			 */
if|if
condition|(
name|p
operator|->
name|linktype
operator|!=
name|idbp
operator|->
name|linktype
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"an interface has a type %u different from the type of the first interface"
argument_list|,
name|idbp
operator|->
name|linktype
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|snapshot
operator|!=
name|idbp
operator|->
name|snaplen
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"an interface has a snapshot length %u different from the type of the first interface"
argument_list|,
name|idbp
operator|->
name|snaplen
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * Count this interface. 			 */
name|p
operator|->
name|sf
operator|.
name|ifcount
operator|++
expr_stmt|;
comment|/* 			 * Set the default time stamp resolution and offset. 			 */
name|tsresol
operator|=
literal|1000000
expr_stmt|;
comment|/* microsecond resolution */
name|tsoffset
operator|=
literal|0
expr_stmt|;
comment|/* absolute timestamps */
comment|/* 			 * Now look for various time stamp options, to 			 * make sure they're the same. 			 * 			 * XXX - we could, in theory, handle multiple 			 * different resolutions and offsets, but we 			 * don't do so for now. 			 */
if|if
condition|(
name|process_idb_options
argument_list|(
name|p
argument_list|,
operator|&
name|cursor
argument_list|,
operator|&
name|tsresol
argument_list|,
operator|&
name|tsoffset
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tsresol
operator|!=
name|p
operator|->
name|sf
operator|.
name|tsresol
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"an interface has a time stamp resolution different from the time stamp resolution of the first interface"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|tsoffset
operator|!=
name|p
operator|->
name|sf
operator|.
name|tsoffset
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"an interface has a time stamp offset different from the time stamp offset of the first interface"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|BT_SHB
case|:
comment|/* 			 * Section Header Block.  Get a pointer 			 * to its fixed-length portion. 			 */
name|shbp
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|shbp
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|shbp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
comment|/* 			 * Assume the byte order of this section is 			 * the same as that of the previous section. 			 * We'll check for that later. 			 */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
name|shbp
operator|->
name|byte_order_magic
operator|=
name|SWAPLONG
argument_list|(
name|shbp
operator|->
name|byte_order_magic
argument_list|)
expr_stmt|;
name|shbp
operator|->
name|major_version
operator|=
name|SWAPSHORT
argument_list|(
name|shbp
operator|->
name|major_version
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Make sure the byte order doesn't change; 			 * pcap_is_swapped() shouldn't change its 			 * return value in the middle of reading a capture. 			 */
switch|switch
condition|(
name|shbp
operator|->
name|byte_order_magic
condition|)
block|{
case|case
name|BYTE_ORDER_MAGIC
case|:
comment|/* 				 * OK. 				 */
break|break;
case|case
name|SWAPLONG
argument_list|(
name|BYTE_ORDER_MAGIC
argument_list|)
case|:
comment|/* 				 * Byte order changes. 				 */
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"the file has sections with different byte orders"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
comment|/* 				 * Not a valid SHB. 				 */
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"the file has a section with a bad byte order magic field"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * Make sure the major version is the version 			 * we handle. 			 */
if|if
condition|(
name|shbp
operator|->
name|major_version
operator|!=
name|PCAP_NG_VERSION_MAJOR
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown pcap-ng savefile major version number %u"
argument_list|,
name|shbp
operator|->
name|major_version
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * Reset the interface count; this section should 			 * have its own set of IDBs.  If any of them 			 * don't have the same interface type, snapshot 			 * length, or resolution as the first interface 			 * we saw, we'll fail.  (And if we don't see 			 * any IDBs, we'll fail when we see a packet 			 * block.) 			 */
name|p
operator|->
name|sf
operator|.
name|ifcount
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Not a packet block, IDB, or SHB; ignore it. 			 */
break|break;
block|}
block|}
name|found
label|:
comment|/* 	 * Is the interface ID an interface we know? 	 */
if|if
condition|(
name|interface_id
operator|>
name|p
operator|->
name|sf
operator|.
name|ifcount
condition|)
block|{
comment|/* 		 * Yes.  Fail. 		 */
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"a packet arrived on interface %u, but there's no Interface Description Block for that interface"
argument_list|,
name|interface_id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Convert the time stamp to a struct timeval. 	 */
name|sec
operator|=
name|t
operator|/
name|p
operator|->
name|sf
operator|.
name|tsresol
operator|+
name|p
operator|->
name|sf
operator|.
name|tsoffset
expr_stmt|;
name|frac
operator|=
name|t
operator|%
name|p
operator|->
name|sf
operator|.
name|tsresol
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|tsresol
operator|>
literal|1000000
condition|)
block|{
comment|/* 		 * Higher than microsecond resolution; scale down to 		 * microseconds. 		 */
name|frac
operator|/=
name|p
operator|->
name|sf
operator|.
name|tsscale
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Lower than microsecond resolution; scale up to 		 * microseconds. 		 */
name|frac
operator|*=
name|p
operator|->
name|sf
operator|.
name|tsscale
expr_stmt|;
block|}
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|sec
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
name|frac
expr_stmt|;
comment|/* 	 * Get a pointer to the packet data. 	 */
operator|*
name|data
operator|=
name|get_from_block_data
argument_list|(
operator|&
name|cursor
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
comment|/* 		 * Convert pseudo-headers from the byte order of 		 * the host on which the file was saved to our 		 * byte order, as necessary. 		 */
switch|switch
condition|(
name|p
operator|->
name|linktype
condition|)
block|{
case|case
name|DLT_USB_LINUX
case|:
name|swap_linux_usb_header
argument_list|(
name|hdr
argument_list|,
operator|*
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DLT_USB_LINUX_MMAPPED
case|:
name|swap_linux_usb_header
argument_list|(
name|hdr
argument_list|,
operator|*
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

