begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * pcap-dag.c: Packet capture interface for Endace DAG card.  *  * The functionality of this code attempts to mimic that of pcap-linux as much  * as possible.  This code is compiled in several different ways depending on  * whether DAG_ONLY and HAVE_DAG_API are defined.  If HAVE_DAG_API is not  * defined it should not get compiled in, otherwise if DAG_ONLY is defined then  * the 'dag_' function calls are renamed to 'pcap_' equivalents.  If DAG_ONLY  * is not defined then nothing is altered - the dag_ functions will be  * called as required from their pcap-linux/bpf equivalents.  *  * Author: Richard Littin, Sean Irvine ({richard,sean}@reeltwo.com)  *  * Modifications:  *   2003 May - Jesper Peterson<support@endace.com>  *              Code shuffled around to suit fad-xxx.c structure  *              Added atexit() handler to stop DAG if application is too lazy  *   2003 September - Koryn Grant<koryn@endace.com>  *              Added support for nonblocking operation.  *              Added support for processing more than a single packet in pcap_dispatch().  *              Fixed bug in loss counter code.  *              Improved portability of loss counter code (e.g. use UINT_MAX instead of 0xffff).  *              Removed unused local variables.  *              Added required headers (ctype.h, limits.h, unistd.h, netinet/in.h).  *   2003 October - Koryn Grant<koryn@endace.com.>  *              Changed semantics to match those of standard pcap on linux.  *                - packets rejected by the filter are not counted.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/pcap-dag.c,v 1.10.2.4 2003/11/21 10:20:45 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* optionally get BSD define */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_struct_decl
struct_decl|struct
name|mbuf
struct_decl|;
end_struct_decl

begin_comment
comment|/* Squelch compiler warnings on some platforms for */
end_comment

begin_struct_decl
struct_decl|struct
name|rtentry
struct_decl|;
end_struct_decl

begin_comment
comment|/* declarations in<net/if.h> */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<dagnew.h>
end_include

begin_include
include|#
directive|include
file|<dagapi.h>
end_include

begin_define
define|#
directive|define
name|MIN_DAG_SNAPLEN
value|12
end_define

begin_define
define|#
directive|define
name|MAX_DAG_SNAPLEN
value|2040
end_define

begin_define
define|#
directive|define
name|ATM_SNAPLEN
value|48
end_define

begin_typedef
typedef|typedef
struct|struct
name|pcap_dag_node
block|{
name|struct
name|pcap_dag_node
modifier|*
name|next
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
block|}
name|pcap_dag_node_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|pcap_dag_node_t
modifier|*
name|pcap_dags
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atexit_handler_installed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|short
name|endian_test_word
init|=
literal|0x0100
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_BIGENDIAN
parameter_list|()
value|(*((unsigned char *)&endian_test_word))
end_define

begin_comment
comment|/*  * Swap byte ordering of unsigned long long timestamp on a big endian  * machine.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_TS
parameter_list|(
name|ull
parameter_list|)
value|((ull& 0xff00000000000000LL)>> 56) | \                       ((ull& 0x00ff000000000000LL)>> 40) | \                       ((ull& 0x0000ff0000000000LL)>> 24) | \                       ((ull& 0x000000ff00000000LL)>> 8)  | \                       ((ull& 0x00000000ff000000LL)<< 8)  | \                       ((ull& 0x0000000000ff0000LL)<< 24) | \                       ((ull& 0x000000000000ff00LL)<< 40) | \                       ((ull& 0x00000000000000ffLL)<< 56)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DAG_ONLY
end_ifdef

begin_comment
comment|/* This code is required when compiling for a DAG device only. */
end_comment

begin_include
include|#
directive|include
file|"pcap-dag.h"
end_include

begin_comment
comment|/* Replace dag function names with pcap equivalent. */
end_comment

begin_define
define|#
directive|define
name|dag_open_live
value|pcap_open_live
end_define

begin_define
define|#
directive|define
name|dag_platform_finddevs
value|pcap_platform_finddevs
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DAG_ONLY */
end_comment

begin_function_decl
specifier|static
name|int
name|dag_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_set_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_get_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|delete_pcap_dag
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|pcap_dag_node_t
modifier|*
name|curr
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|curr
operator|=
name|pcap_dags
init|;
name|curr
operator|!=
name|NULL
operator|&&
name|curr
operator|->
name|p
operator|!=
name|p
condition|;
name|prev
operator|=
name|curr
operator|,
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
comment|/* empty */
block|}
if|if
condition|(
name|curr
operator|!=
name|NULL
operator|&&
name|curr
operator|->
name|p
operator|==
name|p
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|pcap_dags
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Performs a graceful shutdown of the DAG card, frees dynamic memory held  * in the pcap_t structure, and closes the file descriptor for the DAG card.  */
end_comment

begin_function
specifier|static
name|void
name|dag_platform_close
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|linux
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|md
operator|.
name|device
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dag_stop
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_stop %s: %s\n"
argument_list|,
name|p
operator|->
name|md
operator|.
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dag_close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_close %s: %s\n"
argument_list|,
name|p
operator|->
name|md
operator|.
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|md
operator|.
name|device
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dag_stop
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_stop: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dag_close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_close: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|delete_pcap_dag
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Note: don't need to call close(p->fd) here as dag_close(p->fd) does this. */
block|}
end_function

begin_function
specifier|static
name|void
name|atexit_handler
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|pcap_dags
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pcap_dags
operator|->
name|pid
operator|==
name|getpid
argument_list|()
condition|)
block|{
name|dag_platform_close
argument_list|(
name|pcap_dags
operator|->
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delete_pcap_dag
argument_list|(
name|pcap_dags
operator|->
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|new_pcap_dag
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|pcap_dag_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_dag_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|atexit_handler_installed
condition|)
block|{
name|atexit
argument_list|(
name|atexit_handler
argument_list|)
expr_stmt|;
name|atexit_handler_installed
operator|=
literal|1
expr_stmt|;
block|}
name|node
operator|->
name|next
operator|=
name|pcap_dags
expr_stmt|;
name|node
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|node
operator|->
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|pcap_dags
operator|=
name|node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Read at most max_packets from the capture stream and call the callback  *  for each of them. Returns the number of packets handled, -1 if an  *  error occured, or -2 if we were told to break out of the loop.  */
end_comment

begin_function
specifier|static
name|int
name|dag_read
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|unsigned
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
name|p
operator|->
name|md
operator|.
name|dag_offset_flags
decl_stmt|;
name|unsigned
name|int
name|nonblocking
init|=
name|flags
operator|&
name|DAGF_NONBLOCK
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Get the next bufferful of packets (if necessary). */
while|while
condition|(
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|-
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|<
name|dag_record_size
condition|)
block|{
comment|/* 			 * Has "pcap_breakloop()" been called? 			 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 				 * Yes - clear the flag that indicates that 				 * it has, and return -2 to indicate that 				 * we were told to break out of the loop. 				 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|=
name|dag_offset
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|&
operator|(
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|-
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|<
name|dag_record_size
operator|)
operator|&&
name|nonblocking
condition|)
block|{
comment|/* Pcap is configured to process only available packets, and there aren't any. */
return|return
literal|0
return|;
block|}
block|}
comment|/* Process the packets. */
while|while
condition|(
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|-
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|>=
name|dag_record_size
condition|)
block|{
name|unsigned
name|short
name|packet_len
init|=
literal|0
decl_stmt|;
name|int
name|caplen
init|=
literal|0
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
name|dag_record_t
modifier|*
name|header
init|=
operator|(
name|dag_record_t
operator|*
operator|)
operator|(
name|p
operator|->
name|md
operator|.
name|dag_mem_base
operator|+
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|)
decl_stmt|;
name|u_char
modifier|*
name|dp
init|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|header
operator|)
operator|+
name|dag_record_size
decl_stmt|;
name|unsigned
name|short
name|rlen
decl_stmt|;
comment|/* 			 * Has "pcap_breakloop()" been called? 			 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 				 * Yes - clear the flag that indicates that 				 * it has, and return -2 to indicate that 				 * we were told to break out of the loop. 				 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|IS_BIGENDIAN
argument_list|()
condition|)
block|{
name|rlen
operator|=
name|header
operator|->
name|rlen
expr_stmt|;
block|}
else|else
block|{
name|rlen
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|rlen
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|+=
name|rlen
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|type
condition|)
block|{
case|case
name|TYPE_ATM
case|:
name|packet_len
operator|=
name|ATM_SNAPLEN
expr_stmt|;
name|caplen
operator|=
name|ATM_SNAPLEN
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPE_ETH
case|:
if|if
condition|(
name|IS_BIGENDIAN
argument_list|()
condition|)
block|{
name|packet_len
operator|=
name|header
operator|->
name|wlen
expr_stmt|;
block|}
else|else
block|{
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
block|}
name|packet_len
operator|-=
operator|(
name|p
operator|->
name|md
operator|.
name|dag_fcs_bits
operator|>>
literal|3
operator|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
name|dp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TYPE_HDLC_POS
case|:
if|if
condition|(
name|IS_BIGENDIAN
argument_list|()
condition|)
block|{
name|packet_len
operator|=
name|header
operator|->
name|wlen
expr_stmt|;
block|}
else|else
block|{
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
block|}
name|packet_len
operator|-=
operator|(
name|p
operator|->
name|md
operator|.
name|dag_fcs_bits
operator|>>
literal|3
operator|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|caplen
operator|>
name|p
operator|->
name|snapshot
condition|)
name|caplen
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
comment|/* Count lost packets. */
if|if
condition|(
name|header
operator|->
name|lctr
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_drop
operator|>
operator|(
name|UINT_MAX
operator|-
name|header
operator|->
name|lctr
operator|)
condition|)
block|{
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_drop
operator|=
name|UINT_MAX
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_drop
operator|+=
name|header
operator|->
name|lctr
expr_stmt|;
block|}
block|}
comment|/* Run the packet filter if there is one. */
if|if
condition|(
operator|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
operator|)
operator|||
name|bpf_filter
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|dp
argument_list|,
name|packet_len
argument_list|,
name|caplen
argument_list|)
condition|)
block|{
comment|/* convert between timestamp formats */
specifier|register
name|unsigned
name|long
name|long
name|ts
decl_stmt|;
if|if
condition|(
name|IS_BIGENDIAN
argument_list|()
condition|)
block|{
name|ts
operator|=
name|SWAP_TS
argument_list|(
name|header
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ts
operator|=
name|header
operator|->
name|ts
expr_stmt|;
block|}
name|pcap_header
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|ts
operator|>>
literal|32
expr_stmt|;
name|ts
operator|=
operator|(
name|ts
operator|&
literal|0xffffffffULL
operator|)
operator|*
literal|1000000
expr_stmt|;
name|ts
operator|+=
literal|0x80000000
expr_stmt|;
comment|/* rounding */
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|ts
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
name|pcap_header
operator|.
name|ts
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
comment|/* Fill in our own header data */
name|pcap_header
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pcap_header
operator|.
name|len
operator|=
name|packet_len
expr_stmt|;
comment|/* Count the packet. */
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_recv
operator|++
expr_stmt|;
comment|/* Call the user supplied callback function */
name|callback
argument_list|(
name|user
argument_list|,
operator|&
name|pcap_header
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* Only count packets that pass the filter, for consistency with standard Linux behaviour. */
name|processed
operator|++
expr_stmt|;
if|if
condition|(
name|processed
operator|==
name|cnt
condition|)
block|{
comment|/* Reached the user-specified limit. */
return|return
name|cnt
return|;
block|}
block|}
block|}
if|if
condition|(
name|nonblocking
operator|||
name|processed
condition|)
block|{
return|return
name|processed
return|;
block|}
block|}
return|return
name|processed
return|;
block|}
end_function

begin_comment
comment|/*  *  Get a handle for a live capture from the given DAG device.  Passing a NULL  *  device will result in a failure.  The promisc flag is ignored because DAG  *  cards are always promiscuous.  The to_ms parameter is also ignored as it is  *  not supported in hardware.  *    *  See also pcap(3).  */
end_comment

begin_function
name|pcap_t
modifier|*
name|dag_open_live
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|char
name|conf
index|[
literal|30
index|]
decl_stmt|;
comment|/* dag configure string */
name|pcap_t
modifier|*
name|handle
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"device is NULL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Allocate a handle for this session. */
name|handle
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Initialize some components of the pcap structure. */
name|memset
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|device
argument_list|,
literal|"/dev"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|newDev
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|device
argument_list|)
operator|+
literal|6
argument_list|)
decl_stmt|;
name|newDev
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|newDev
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newDev
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|device
operator|=
name|newDev
expr_stmt|;
block|}
else|else
block|{
name|device
operator|=
name|strdup
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"str_dup: %s\n"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* setup device parameters */
if|if
condition|(
operator|(
name|handle
operator|->
name|fd
operator|=
name|dag_open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|device
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_open %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* set the card snap length to the specified snaplen parameter */
if|if
condition|(
name|snaplen
operator|==
literal|0
operator|||
name|snaplen
operator|>
name|MAX_DAG_SNAPLEN
condition|)
block|{
name|snaplen
operator|=
name|MAX_DAG_SNAPLEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|snaplen
operator|<
name|MIN_DAG_SNAPLEN
condition|)
block|{
name|snaplen
operator|=
name|MIN_DAG_SNAPLEN
expr_stmt|;
block|}
comment|/* snap len has to be a multiple of 4 */
name|snprintf
argument_list|(
name|conf
argument_list|,
literal|30
argument_list|,
literal|"varlen slen=%d"
argument_list|,
operator|(
name|snaplen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Configuring DAG with '%s'.\n"
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dag_configure
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|conf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_configure %s: %s\n"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|handle
operator|->
name|md
operator|.
name|dag_mem_base
operator|=
name|dag_mmap
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_mmap %s: %s\n"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|dag_start
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_start %s: %s\n"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/*    * Important! You have to ensure bottom is properly    * initialized to zero on startup, it won't give you    * a compiler warning if you make this mistake!    */
name|handle
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|=
literal|0
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|dag_mem_top
operator|=
literal|0
expr_stmt|;
comment|/* TODO: query the card */
name|handle
operator|->
name|md
operator|.
name|dag_fcs_bits
operator|=
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"ERF_FCS_BITS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|n
operator|==
literal|16
operator|||
name|n
operator|==
literal|32
condition|)
block|{
name|handle
operator|->
name|md
operator|.
name|dag_fcs_bits
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"pcap_open_live %s: bad ERF_FCS_BITS value (%d) in environment\n"
argument_list|,
name|device
argument_list|,
name|n
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|handle
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
comment|/*handle->md.timeout	= to_ms; */
if|if
condition|(
operator|(
name|handle
operator|->
name|linktype
operator|=
name|dag_get_datalink
argument_list|(
name|handle
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_get_linktype %s: unknown linktype\n"
argument_list|,
name|device
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|handle
operator|->
name|bufsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_pcap_dag
argument_list|(
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"new_pcap_dag %s: %s\n"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/*    * "select()" and "poll()" don't (yet) work on DAG device descriptors.    */
name|handle
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|linux
name|handle
operator|->
name|md
operator|.
name|device
operator|=
operator|(
name|char
operator|*
operator|)
name|device
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|device
argument_list|)
expr_stmt|;
name|device
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|handle
operator|->
name|read_op
operator|=
name|dag_read
expr_stmt|;
name|handle
operator|->
name|setfilter_op
operator|=
name|dag_setfilter
expr_stmt|;
name|handle
operator|->
name|set_datalink_op
operator|=
name|dag_set_datalink
expr_stmt|;
name|handle
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|handle
operator|->
name|setnonblock_op
operator|=
name|dag_setnonblock
expr_stmt|;
name|handle
operator|->
name|stats_op
operator|=
name|dag_stats
expr_stmt|;
name|handle
operator|->
name|close_op
operator|=
name|dag_platform_close
expr_stmt|;
return|return
name|handle
return|;
name|fail
label|:
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handle
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
comment|/* This needs to be filled out correctly.  Hopefully a dagapi call will      provide all necessary information.   */
comment|/*p->md.stat.ps_recv = 0;*/
comment|/*p->md.stat.ps_drop = 0;*/
operator|*
name|ps
operator|=
name|p
operator|->
name|md
operator|.
name|stat
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get from "/proc/dag" all interfaces listed there; if they're  * already in the list of interfaces we have, that won't add another  * instance, but if they're not, that'll add them.  *  * We don't bother getting any addresses for them.  *  * We also don't fail if we couldn't open "/proc/dag"; we just leave  * the list of interfaces as is.  */
end_comment

begin_function
name|int
name|dag_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|devlistp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|FILE
modifier|*
name|proc_dag_f
decl_stmt|;
name|char
name|linebuf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|linenum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|name
index|[
literal|512
index|]
decl_stmt|;
comment|/* XXX - pick a size */
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Quick exit if /proc/dag not readable */
name|proc_dag_f
operator|=
name|fopen
argument_list|(
literal|"/proc/dag"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_dag_f
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|dev
index|[
literal|16
index|]
init|=
literal|"dagx"
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|ret
operator|==
literal|0
operator|&&
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
block|{
name|dev
index|[
literal|3
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|pcap_add_if
argument_list|(
name|devlistp
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/*          * Failure.          */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|linenum
operator|=
literal|1
init|;
name|fgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
name|linebuf
argument_list|,
name|proc_dag_f
argument_list|)
operator|!=
name|NULL
condition|;
name|linenum
operator|++
control|)
block|{
comment|/*      * Skip the first two lines - they're headers.      */
if|if
condition|(
name|linenum
operator|<=
literal|2
condition|)
continue|continue;
name|p
operator|=
operator|&
name|linebuf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|!=
literal|'D'
condition|)
continue|continue;
comment|/* not a Dag line */
comment|/*      * Get the interface name.      */
name|q
operator|=
operator|&
name|name
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
operator|*
name|q
operator|++
operator|=
name|tolower
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Add an entry for this interface, with no addresses.      */
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get rid of \n */
if|if
condition|(
name|pcap_add_if
argument_list|(
name|devlistp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|strdup
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/*        * Failure.        */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*      * Well, we didn't fail for any other reason; did we      * fail due to an error reading the file?      */
if|if
condition|(
name|ferror
argument_list|(
name|proc_dag_f
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error reading /proc/dag: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|proc_dag_f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Installs the given bpf filter program in the given pcap structure.  There is  * no attempt to store the filter in kernel memory as that is not supported  * with DAG cards.  */
end_comment

begin_function
specifier|static
name|int
name|dag_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|strncpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"setfilter: No filter specified"
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make our private copy of the filter */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p
operator|->
name|md
operator|.
name|use_bpf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_set_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* 	 * Set non-blocking mode on the FD. 	 * XXX - is that necessary?  If not, don't bother calling it, 	 * and have a "dag_getnonblock()" function that looks at 	 * "p->md.dag_offset_flags". 	 */
if|if
condition|(
name|pcap_setnonblock_fd
argument_list|(
name|p
argument_list|,
name|nonblock
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|nonblock
condition|)
block|{
name|p
operator|->
name|md
operator|.
name|dag_offset_flags
operator||=
name|DAGF_NONBLOCK
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|md
operator|.
name|dag_offset_flags
operator|&=
operator|~
name|DAGF_NONBLOCK
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_get_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|int
name|linktype
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Check the type through a dagapi call.   */
switch|switch
condition|(
name|dag_linktype
argument_list|(
name|p
operator|->
name|fd
argument_list|)
condition|)
block|{
case|case
name|TYPE_HDLC_POS
case|:
block|{
name|dag_record_t
modifier|*
name|record
decl_stmt|;
comment|/* peek at the first available record to see if it is PPP */
while|while
condition|(
operator|(
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|-
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|)
operator|<
operator|(
name|dag_record_size
operator|+
literal|4
operator|)
condition|)
block|{
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|=
name|dag_offset
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|&
operator|(
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|record
operator|=
operator|(
name|dag_record_t
operator|*
operator|)
operator|(
name|p
operator|->
name|md
operator|.
name|dag_mem_base
operator|+
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|record
operator|->
name|rec
operator|.
name|pos
operator|.
name|hdlc
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xff030000
condition|)
block|{
name|linktype
operator|=
name|DLT_PPP_SERIAL
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Set DAG linktype to %d (DLT_PPP_SERIAL)\n"
argument_list|,
name|linktype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|linktype
operator|=
name|DLT_CHDLC
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Set DAG linktype to %d (DLT_CHDLC)\n"
argument_list|,
name|linktype
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TYPE_ETH
case|:
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Set DAG linktype to %d (DLT_EN10MB)\n"
argument_list|,
name|linktype
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_ATM
case|:
name|linktype
operator|=
name|DLT_ATM_RFC1483
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Set DAG linktype to %d (DLT_ATM_RFC1483)\n"
argument_list|,
name|linktype
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_LEGACY
case|:
name|linktype
operator|=
name|DLT_NULL
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Set DAG linktype to %d (DLT_NULL)\n"
argument_list|,
name|linktype
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown DAG linktype %d\n"
argument_list|,
name|dag_linktype
argument_list|(
name|p
operator|->
name|fd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|linktype
return|;
block|}
end_function

end_unit

