begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * pcap-dag.c: Packet capture interface for Endace DAG card.  *  * The functionality of this code attempts to mimic that of pcap-linux as much  * as possible.  This code is compiled in several different ways depending on  * whether DAG_ONLY and HAVE_DAG_API are defined.  If HAVE_DAG_API is not  * defined it should not get compiled in, otherwise if DAG_ONLY is defined then  * the 'dag_' function calls are renamed to 'pcap_' equivalents.  If DAG_ONLY  * is not defined then nothing is altered - the dag_ functions will be  * called as required from their pcap-linux/bpf equivalents.  *  * Authors: Richard Littin, Sean Irvine ({richard,sean}@reeltwo.com)  * Modifications: Jesper Peterson, Koryn Grant<support@endace.com>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/pcap-dag.c,v 1.21 2005/04/03 23:56:47 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* optionally get BSD define */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_struct_decl
struct_decl|struct
name|mbuf
struct_decl|;
end_struct_decl

begin_comment
comment|/* Squelch compiler warnings on some platforms for */
end_comment

begin_struct_decl
struct_decl|struct
name|rtentry
struct_decl|;
end_struct_decl

begin_comment
comment|/* declarations in<net/if.h> */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|"dagnew.h"
end_include

begin_include
include|#
directive|include
file|"dagapi.h"
end_include

begin_define
define|#
directive|define
name|MIN_DAG_SNAPLEN
value|12
end_define

begin_define
define|#
directive|define
name|MAX_DAG_SNAPLEN
value|2040
end_define

begin_define
define|#
directive|define
name|ATM_CELL_SIZE
value|52
end_define

begin_define
define|#
directive|define
name|ATM_HDR_SIZE
value|4
end_define

begin_comment
comment|/* SunATM pseudo header */
end_comment

begin_struct
struct|struct
name|sunatm_hdr
block|{
name|unsigned
name|char
name|flags
decl_stmt|;
comment|/* destination and traffic type */
name|unsigned
name|char
name|vpi
decl_stmt|;
comment|/* VPI */
name|unsigned
name|short
name|vci
decl_stmt|;
comment|/* VCI */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|pcap_dag_node
block|{
name|struct
name|pcap_dag_node
modifier|*
name|next
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
block|}
name|pcap_dag_node_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|pcap_dag_node_t
modifier|*
name|pcap_dags
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atexit_handler_installed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|short
name|endian_test_word
init|=
literal|0x0100
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_BIGENDIAN
parameter_list|()
value|(*((unsigned char *)&endian_test_word))
end_define

begin_comment
comment|/*  * Swap byte ordering of unsigned long long timestamp on a big endian  * machine.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_TS
parameter_list|(
name|ull
parameter_list|)
value|((ull& 0xff00000000000000LL)>> 56) | \                       ((ull& 0x00ff000000000000LL)>> 40) | \                       ((ull& 0x0000ff0000000000LL)>> 24) | \                       ((ull& 0x000000ff00000000LL)>> 8)  | \                       ((ull& 0x00000000ff000000LL)<< 8)  | \                       ((ull& 0x0000000000ff0000LL)<< 24) | \                       ((ull& 0x000000000000ff00LL)<< 40) | \                       ((ull& 0x00000000000000ffLL)<< 56)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DAG_ONLY
end_ifdef

begin_comment
comment|/* This code is required when compiling for a DAG device only. */
end_comment

begin_include
include|#
directive|include
file|"pcap-dag.h"
end_include

begin_comment
comment|/* Replace dag function names with pcap equivalent. */
end_comment

begin_define
define|#
directive|define
name|dag_open_live
value|pcap_open_live
end_define

begin_define
define|#
directive|define
name|dag_platform_finddevs
value|pcap_platform_finddevs
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DAG_ONLY */
end_comment

begin_function_decl
specifier|static
name|int
name|dag_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_set_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_get_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|delete_pcap_dag
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|pcap_dag_node_t
modifier|*
name|curr
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|curr
operator|=
name|pcap_dags
init|;
name|curr
operator|!=
name|NULL
operator|&&
name|curr
operator|->
name|p
operator|!=
name|p
condition|;
name|prev
operator|=
name|curr
operator|,
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
comment|/* empty */
block|}
if|if
condition|(
name|curr
operator|!=
name|NULL
operator|&&
name|curr
operator|->
name|p
operator|==
name|p
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|pcap_dags
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Performs a graceful shutdown of the DAG card, frees dynamic memory held  * in the pcap_t structure, and closes the file descriptor for the DAG card.  */
end_comment

begin_function
specifier|static
name|void
name|dag_platform_close
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|linux
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|md
operator|.
name|device
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dag_stop
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_stop %s: %s\n"
argument_list|,
name|p
operator|->
name|md
operator|.
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dag_close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_close %s: %s\n"
argument_list|,
name|p
operator|->
name|md
operator|.
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|md
operator|.
name|device
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dag_stop
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_stop: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dag_close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_close: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|delete_pcap_dag
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Note: don't need to call close(p->fd) here as dag_close(p->fd) does this. */
block|}
end_function

begin_function
specifier|static
name|void
name|atexit_handler
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|pcap_dags
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pcap_dags
operator|->
name|pid
operator|==
name|getpid
argument_list|()
condition|)
block|{
name|dag_platform_close
argument_list|(
name|pcap_dags
operator|->
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delete_pcap_dag
argument_list|(
name|pcap_dags
operator|->
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|new_pcap_dag
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|pcap_dag_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_dag_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|atexit_handler_installed
condition|)
block|{
name|atexit
argument_list|(
name|atexit_handler
argument_list|)
expr_stmt|;
name|atexit_handler_installed
operator|=
literal|1
expr_stmt|;
block|}
name|node
operator|->
name|next
operator|=
name|pcap_dags
expr_stmt|;
name|node
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|node
operator|->
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|pcap_dags
operator|=
name|node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Read at most max_packets from the capture stream and call the callback  *  for each of them. Returns the number of packets handled, -1 if an  *  error occured, or -2 if we were told to break out of the loop.  */
end_comment

begin_function
specifier|static
name|int
name|dag_read
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|unsigned
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
name|p
operator|->
name|md
operator|.
name|dag_offset_flags
decl_stmt|;
name|unsigned
name|int
name|nonblocking
init|=
name|flags
operator|&
name|DAGF_NONBLOCK
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Get the next bufferful of packets (if necessary). */
while|while
condition|(
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|-
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|<
name|dag_record_size
condition|)
block|{
comment|/* 			 * Has "pcap_breakloop()" been called? 			 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 				 * Yes - clear the flag that indicates that 				 * it has, and return -2 to indicate that 				 * we were told to break out of the loop. 				 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|=
name|dag_offset
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|&
operator|(
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonblocking
operator|&&
operator|(
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|-
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|<
name|dag_record_size
operator|)
condition|)
block|{
comment|/* Pcap is configured to process only available packets, and there aren't any. */
return|return
literal|0
return|;
block|}
block|}
comment|/* Process the packets. */
while|while
condition|(
name|p
operator|->
name|md
operator|.
name|dag_mem_top
operator|-
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|>=
name|dag_record_size
condition|)
block|{
name|unsigned
name|short
name|packet_len
init|=
literal|0
decl_stmt|;
name|int
name|caplen
init|=
literal|0
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
name|dag_record_t
modifier|*
name|header
init|=
operator|(
name|dag_record_t
operator|*
operator|)
operator|(
name|p
operator|->
name|md
operator|.
name|dag_mem_base
operator|+
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|)
decl_stmt|;
name|u_char
modifier|*
name|dp
init|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|header
operator|)
operator|+
name|dag_record_size
decl_stmt|;
name|unsigned
name|short
name|rlen
decl_stmt|;
comment|/* 			 * Has "pcap_breakloop()" been called? 			 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 				 * Yes - clear the flag that indicates that 				 * it has, and return -2 to indicate that 				 * we were told to break out of the loop. 				 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|rlen
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|<
name|dag_record_size
condition|)
block|{
name|strncpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"dag_read: record too small"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|+=
name|rlen
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|type
condition|)
block|{
case|case
name|TYPE_AAL5
case|:
case|case
name|TYPE_ATM
case|:
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|TYPE_AAL5
condition|)
block|{
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
expr_stmt|;
block|}
else|else
block|{
name|caplen
operator|=
name|packet_len
operator|=
name|ATM_CELL_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|linktype
operator|==
name|DLT_SUNATM
condition|)
block|{
name|struct
name|sunatm_hdr
modifier|*
name|sunatm
init|=
operator|(
expr|struct
name|sunatm_hdr
operator|*
operator|)
name|dp
decl_stmt|;
name|unsigned
name|long
name|rawatm
decl_stmt|;
name|rawatm
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dp
operator|)
argument_list|)
expr_stmt|;
name|sunatm
operator|->
name|vci
operator|=
name|htons
argument_list|(
operator|(
name|rawatm
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|sunatm
operator|->
name|vpi
operator|=
operator|(
name|rawatm
operator|>>
literal|20
operator|)
operator|&
literal|0x00ff
expr_stmt|;
name|sunatm
operator|->
name|flags
operator|=
operator|(
operator|(
name|header
operator|->
name|flags
operator|.
name|iface
operator|&
literal|1
operator|)
condition|?
literal|0x80
else|:
literal|0x00
operator|)
operator||
operator|(
operator|(
name|sunatm
operator|->
name|vpi
operator|==
literal|0
operator|&&
name|sunatm
operator|->
name|vci
operator|==
name|htons
argument_list|(
literal|5
argument_list|)
operator|)
condition|?
literal|6
else|:
operator|(
operator|(
name|sunatm
operator|->
name|vpi
operator|==
literal|0
operator|&&
name|sunatm
operator|->
name|vci
operator|==
name|htons
argument_list|(
literal|16
argument_list|)
operator|)
condition|?
literal|5
else|:
operator|(
operator|(
name|dp
index|[
name|ATM_HDR_SIZE
index|]
operator|==
literal|0xaa
operator|&&
name|dp
index|[
name|ATM_HDR_SIZE
operator|+
literal|1
index|]
operator|==
literal|0xaa
operator|&&
name|dp
index|[
name|ATM_HDR_SIZE
operator|+
literal|2
index|]
operator|==
literal|0x03
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|packet_len
operator|-=
name|ATM_HDR_SIZE
expr_stmt|;
name|caplen
operator|-=
name|ATM_HDR_SIZE
expr_stmt|;
name|dp
operator|+=
name|ATM_HDR_SIZE
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_ETH
case|:
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|packet_len
operator|-=
operator|(
name|p
operator|->
name|md
operator|.
name|dag_fcs_bits
operator|>>
literal|3
operator|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
name|dp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TYPE_HDLC_POS
case|:
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|packet_len
operator|-=
operator|(
name|p
operator|->
name|md
operator|.
name|dag_fcs_bits
operator|>>
literal|3
operator|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|caplen
operator|>
name|p
operator|->
name|snapshot
condition|)
name|caplen
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
comment|/* Count lost packets. */
if|if
condition|(
name|header
operator|->
name|lctr
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_drop
operator|>
operator|(
name|UINT_MAX
operator|-
name|ntohs
argument_list|(
name|header
operator|->
name|lctr
argument_list|)
operator|)
condition|)
block|{
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_drop
operator|=
name|UINT_MAX
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_drop
operator|+=
name|ntohs
argument_list|(
name|header
operator|->
name|lctr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Run the packet filter if there is one. */
if|if
condition|(
operator|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
operator|)
operator|||
name|bpf_filter
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|dp
argument_list|,
name|packet_len
argument_list|,
name|caplen
argument_list|)
condition|)
block|{
comment|/* convert between timestamp formats */
specifier|register
name|unsigned
name|long
name|long
name|ts
decl_stmt|;
if|if
condition|(
name|IS_BIGENDIAN
argument_list|()
condition|)
block|{
name|ts
operator|=
name|SWAP_TS
argument_list|(
name|header
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ts
operator|=
name|header
operator|->
name|ts
expr_stmt|;
block|}
name|pcap_header
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|ts
operator|>>
literal|32
expr_stmt|;
name|ts
operator|=
operator|(
name|ts
operator|&
literal|0xffffffffULL
operator|)
operator|*
literal|1000000
expr_stmt|;
name|ts
operator|+=
literal|0x80000000
expr_stmt|;
comment|/* rounding */
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|ts
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
name|pcap_header
operator|.
name|ts
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
comment|/* Fill in our own header data */
name|pcap_header
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pcap_header
operator|.
name|len
operator|=
name|packet_len
expr_stmt|;
comment|/* Count the packet. */
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_recv
operator|++
expr_stmt|;
comment|/* Call the user supplied callback function */
name|callback
argument_list|(
name|user
argument_list|,
operator|&
name|pcap_header
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* Only count packets that pass the filter, for consistency with standard Linux behaviour. */
name|processed
operator|++
expr_stmt|;
if|if
condition|(
name|processed
operator|==
name|cnt
condition|)
block|{
comment|/* Reached the user-specified limit. */
return|return
name|cnt
return|;
block|}
block|}
block|}
if|if
condition|(
name|nonblocking
operator|||
name|processed
condition|)
block|{
return|return
name|processed
return|;
block|}
block|}
return|return
name|processed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_inject
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
name|_U_
parameter_list|,
name|size_t
name|size
name|_U_
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"Sending packets isn't supported on DAG cards"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Get a handle for a live capture from the given DAG device.  Passing a NULL  *  device will result in a failure.  The promisc flag is ignored because DAG  *  cards are always promiscuous.  The to_ms parameter is also ignored as it is  *  not supported in hardware.  *    *  See also pcap(3).  */
end_comment

begin_function
name|pcap_t
modifier|*
name|dag_open_live
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|char
name|conf
index|[
literal|30
index|]
decl_stmt|;
comment|/* dag configure string */
name|pcap_t
modifier|*
name|handle
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
name|daginf_t
modifier|*
name|daginf
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"device is NULL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Allocate a handle for this session. */
name|handle
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Initialize some components of the pcap structure. */
name|memset
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|device
argument_list|,
literal|"/dev"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|newDev
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|device
argument_list|)
operator|+
literal|6
argument_list|)
decl_stmt|;
name|newDev
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|newDev
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newDev
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|device
operator|=
name|newDev
expr_stmt|;
block|}
else|else
block|{
name|device
operator|=
name|strdup
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"str_dup: %s\n"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* setup device parameters */
if|if
condition|(
operator|(
name|handle
operator|->
name|fd
operator|=
name|dag_open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|device
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_open %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* set the card snap length to the specified snaplen parameter */
if|if
condition|(
name|snaplen
operator|==
literal|0
operator|||
name|snaplen
operator|>
name|MAX_DAG_SNAPLEN
condition|)
block|{
name|snaplen
operator|=
name|MAX_DAG_SNAPLEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|snaplen
operator|<
name|MIN_DAG_SNAPLEN
condition|)
block|{
name|snaplen
operator|=
name|MIN_DAG_SNAPLEN
expr_stmt|;
block|}
comment|/* snap len has to be a multiple of 4 */
name|snprintf
argument_list|(
name|conf
argument_list|,
literal|30
argument_list|,
literal|"varlen slen=%d"
argument_list|,
operator|(
name|snaplen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|dag_configure
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|conf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_configure %s: %s\n"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|handle
operator|->
name|md
operator|.
name|dag_mem_base
operator|=
name|dag_mmap
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_mmap %s: %s\n"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|dag_start
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_start %s: %s\n"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Important! You have to ensure bottom is properly 	 * initialized to zero on startup, it won't give you 	 * a compiler warning if you make this mistake! 	 */
name|handle
operator|->
name|md
operator|.
name|dag_mem_bottom
operator|=
literal|0
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|dag_mem_top
operator|=
literal|0
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|dag_fcs_bits
operator|=
literal|32
expr_stmt|;
comment|/* Query the card first for special cases. */
name|daginf
operator|=
name|dag_info
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0x4200
operator|==
name|daginf
operator|->
name|device_code
operator|)
operator|||
operator|(
literal|0x4230
operator|==
name|daginf
operator|->
name|device_code
operator|)
condition|)
block|{
comment|/* DAG 4.2S and 4.23S already strip the FCS.  Stripping the final word again truncates the packet. */
name|handle
operator|->
name|md
operator|.
name|dag_fcs_bits
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Then allow an environment variable to override. */
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"ERF_FCS_BITS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|n
operator|==
literal|16
operator|||
name|n
operator|==
literal|32
condition|)
block|{
name|handle
operator|->
name|md
operator|.
name|dag_fcs_bits
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"pcap_open_live %s: bad ERF_FCS_BITS value (%d) in environment\n"
argument_list|,
name|device
argument_list|,
name|n
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|handle
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
comment|/*handle->md.timeout	= to_ms; */
name|handle
operator|->
name|linktype
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dag_get_datalink
argument_list|(
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|ebuf
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|handle
operator|->
name|bufsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_pcap_dag
argument_list|(
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"new_pcap_dag %s: %s\n"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * "select()" and "poll()" don't (yet) work on DAG device descriptors. 	 */
name|handle
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|linux
name|handle
operator|->
name|md
operator|.
name|device
operator|=
operator|(
name|char
operator|*
operator|)
name|device
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|device
argument_list|)
expr_stmt|;
name|device
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|handle
operator|->
name|read_op
operator|=
name|dag_read
expr_stmt|;
name|handle
operator|->
name|inject_op
operator|=
name|dag_inject
expr_stmt|;
name|handle
operator|->
name|setfilter_op
operator|=
name|dag_setfilter
expr_stmt|;
name|handle
operator|->
name|set_datalink_op
operator|=
name|dag_set_datalink
expr_stmt|;
name|handle
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|handle
operator|->
name|setnonblock_op
operator|=
name|dag_setnonblock
expr_stmt|;
name|handle
operator|->
name|stats_op
operator|=
name|dag_stats
expr_stmt|;
name|handle
operator|->
name|close_op
operator|=
name|dag_platform_close
expr_stmt|;
return|return
name|handle
return|;
name|fail
label|:
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handle
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Get rid of any link-layer type list we allocated. 		 */
if|if
condition|(
name|handle
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|handle
operator|->
name|dlt_list
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
comment|/* This needs to be filled out correctly.  Hopefully a dagapi call will 		 provide all necessary information. 	*/
comment|/*p->md.stat.ps_recv = 0;*/
comment|/*p->md.stat.ps_drop = 0;*/
operator|*
name|ps
operator|=
name|p
operator|->
name|md
operator|.
name|stat
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get from "/proc/dag" all interfaces listed there; if they're  * already in the list of interfaces we have, that won't add another  * instance, but if they're not, that'll add them.  *  * We don't bother getting any addresses for them.  *  * We also don't fail if we couldn't open "/proc/dag"; we just leave  * the list of interfaces as is.  */
end_comment

begin_function
name|int
name|dag_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|devlistp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|FILE
modifier|*
name|proc_dag_f
decl_stmt|;
name|char
name|linebuf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|linenum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|name
index|[
literal|512
index|]
decl_stmt|;
comment|/* XXX - pick a size */
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Quick exit if /proc/dag not readable */
name|proc_dag_f
operator|=
name|fopen
argument_list|(
literal|"/proc/dag"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_dag_f
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|dev
index|[
literal|16
index|]
init|=
literal|"dagx"
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|ret
operator|==
literal|0
operator|&&
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
block|{
name|dev
index|[
literal|3
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|pcap_add_if
argument_list|(
name|devlistp
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Failure. 				 */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|linenum
operator|=
literal|1
init|;
name|fgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
name|linebuf
argument_list|,
name|proc_dag_f
argument_list|)
operator|!=
name|NULL
condition|;
name|linenum
operator|++
control|)
block|{
comment|/* 		 * Skip the first two lines - they're headers. 		 */
if|if
condition|(
name|linenum
operator|<=
literal|2
condition|)
continue|continue;
name|p
operator|=
operator|&
name|linebuf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|!=
literal|'D'
condition|)
continue|continue;
comment|/* not a Dag line */
comment|/* 		 * Get the interface name. 		 */
name|q
operator|=
operator|&
name|name
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
operator|*
name|q
operator|++
operator|=
name|tolower
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Add an entry for this interface, with no addresses. 		 */
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get rid of \n */
if|if
condition|(
name|pcap_add_if
argument_list|(
name|devlistp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|strdup
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Failure. 			 */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Well, we didn't fail for any other reason; did we 		 * fail due to an error reading the file? 		 */
if|if
condition|(
name|ferror
argument_list|(
name|proc_dag_f
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error reading /proc/dag: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|proc_dag_f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Installs the given bpf filter program in the given pcap structure.  There is  * no attempt to store the filter in kernel memory as that is not supported  * with DAG cards.  */
end_comment

begin_function
specifier|static
name|int
name|dag_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|strncpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"setfilter: No filter specified"
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make our private copy of the filter */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|->
name|md
operator|.
name|use_bpf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_set_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
block|{
name|p
operator|->
name|linktype
operator|=
name|dlt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* 	 * Set non-blocking mode on the FD. 	 * XXX - is that necessary?  If not, don't bother calling it, 	 * and have a "dag_getnonblock()" function that looks at 	 * "p->md.dag_offset_flags". 	 */
if|if
condition|(
name|pcap_setnonblock_fd
argument_list|(
name|p
argument_list|,
name|nonblock
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|nonblock
condition|)
block|{
name|p
operator|->
name|md
operator|.
name|dag_offset_flags
operator||=
name|DAGF_NONBLOCK
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|md
operator|.
name|dag_offset_flags
operator|&=
operator|~
name|DAGF_NONBLOCK
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_get_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|int
name|daglinktype
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|==
name|NULL
operator|&&
operator|(
name|p
operator|->
name|dlt_list
operator|=
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|p
operator|->
name|dlt_list
operator|)
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Check the type through a dagapi call. */
name|daglinktype
operator|=
name|dag_linktype
argument_list|(
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|daglinktype
condition|)
block|{
case|case
name|TYPE_HDLC_POS
case|:
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_count
operator|=
literal|2
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|=
name|DLT_CHDLC
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
literal|1
index|]
operator|=
name|DLT_PPP_SERIAL
expr_stmt|;
block|}
name|p
operator|->
name|linktype
operator|=
name|DLT_CHDLC
expr_stmt|;
break|break;
case|case
name|TYPE_ETH
case|:
comment|/* 		 * This is (presumably) a real Ethernet capture; give it a 		 * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so 		 * that an application can let you choose it, in case you're 		 * capturing DOCSIS traffic that a Cisco Cable Modem 		 * Termination System is putting out onto an Ethernet (it 		 * doesn't put an Ethernet header onto the wire, it puts raw 		 * DOCSIS frames out on the wire inside the low-level 		 * Ethernet framing). 		 */
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_count
operator|=
literal|2
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|=
name|DLT_EN10MB
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
literal|1
index|]
operator|=
name|DLT_DOCSIS
expr_stmt|;
block|}
name|p
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
break|break;
case|case
name|TYPE_AAL5
case|:
case|case
name|TYPE_ATM
case|:
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_count
operator|=
literal|2
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|=
name|DLT_ATM_RFC1483
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
literal|1
index|]
operator|=
name|DLT_SUNATM
expr_stmt|;
block|}
name|p
operator|->
name|linktype
operator|=
name|DLT_ATM_RFC1483
expr_stmt|;
break|break;
case|case
name|TYPE_LEGACY
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_NULL
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"unknown DAG linktype %d\n"
argument_list|,
name|daglinktype
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
name|p
operator|->
name|linktype
return|;
block|}
end_function

end_unit

