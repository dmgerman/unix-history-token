begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  pcap-sita.c: Packet capture interface additions for SITA ACN devices  *  *  Copyright (c) 2007 Fulko Hew, SITA INC Canada, Inc<fulko.hew@sita.aero>  *  *  License: BSD  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  3. The names of the authors may not be used to endorse or promote  *     products derived from this software without specific prior  *     written permission.  *  *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  *  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"pcap-sita.h"
end_include

begin_comment
comment|/* non-configureable manifests follow */
end_comment

begin_define
define|#
directive|define
name|IOP_SNIFFER_PORT
value|49152
end_define

begin_comment
comment|/* TCP port on the IOP used for 'distributed pcap' usage */
end_comment

begin_define
define|#
directive|define
name|MAX_LINE_SIZE
value|255
end_define

begin_comment
comment|/* max size of a buffer/line in /etc/hosts we allow */
end_comment

begin_define
define|#
directive|define
name|MAX_CHASSIS
value|8
end_define

begin_comment
comment|/* number of chassis in an ACN site */
end_comment

begin_define
define|#
directive|define
name|MAX_GEOSLOT
value|8
end_define

begin_comment
comment|/* max number of access units in an ACN site */
end_comment

begin_define
define|#
directive|define
name|FIND
value|0
end_define

begin_define
define|#
directive|define
name|LIVE
value|1
end_define

begin_typedef
typedef|typedef
struct|struct
name|iface
block|{
name|struct
name|iface
modifier|*
name|next
decl_stmt|;
comment|/* a pointer to the next interface */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* this interface's name */
name|char
modifier|*
name|IOPname
decl_stmt|;
comment|/* this interface's name on an IOP */
name|uint32_t
name|iftype
decl_stmt|;
comment|/* the type of interface (DLT values) */
block|}
name|iface_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|unit
block|{
name|char
modifier|*
name|ip
decl_stmt|;
comment|/* this unit's IP address (as extracted from /etc/hosts) */
name|int
name|fd
decl_stmt|;
comment|/* the connection to this unit (if it exists) */
name|int
name|find_fd
decl_stmt|;
comment|/* a big kludge to avoid my programming limitations since I could have this unit open for findalldevs purposes */
name|int
name|first_time
decl_stmt|;
comment|/* 0 = just opened via acn_open_live(),  ie. the first time, NZ = nth time */
name|struct
name|sockaddr_in
modifier|*
name|serv_addr
decl_stmt|;
comment|/* the address control block for comms to this unit */
name|int
name|chassis
decl_stmt|;
name|int
name|geoslot
decl_stmt|;
name|iface_t
modifier|*
name|iface
decl_stmt|;
comment|/* a pointer to a linked list of interface structures */
name|char
modifier|*
name|imsg
decl_stmt|;
comment|/* a pointer to an inbound message */
name|int
name|len
decl_stmt|;
comment|/* the current size of the inbound message */
block|}
name|unit_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|unit_t
name|units
index|[
name|MAX_CHASSIS
operator|+
literal|1
index|]
index|[
name|MAX_GEOSLOT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we use indexes of 1 through 8, but we reserve/waste index 0 */
end_comment

begin_decl_stmt
specifier|static
name|fd_set
name|readfds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a place to store the file descriptors for the connections to the IOPs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pcap_if_t
modifier|*
name|acn_if_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcap's list of available interfaces */
end_comment

begin_function
specifier|static
name|void
name|dump_interface_list
parameter_list|(
name|void
parameter_list|)
block|{
name|pcap_if_t
modifier|*
name|iff
decl_stmt|;
name|pcap_addr_t
modifier|*
name|addr
decl_stmt|;
name|int
name|longest_name_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|int
name|if_number
init|=
literal|0
decl_stmt|;
name|iff
operator|=
name|acn_if_list
expr_stmt|;
while|while
condition|(
name|iff
condition|)
block|{
if|if
condition|(
name|iff
operator|->
name|name
operator|&&
operator|(
name|strlen
argument_list|(
name|iff
operator|->
name|name
argument_list|)
operator|>
name|longest_name_len
operator|)
condition|)
name|longest_name_len
operator|=
name|strlen
argument_list|(
name|iff
operator|->
name|name
argument_list|)
expr_stmt|;
name|iff
operator|=
name|iff
operator|->
name|next
expr_stmt|;
block|}
name|iff
operator|=
name|acn_if_list
expr_stmt|;
name|printf
argument_list|(
literal|"Interface List:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|iff
condition|)
block|{
name|n
operator|=
operator|(
name|iff
operator|->
name|name
operator|)
condition|?
name|iff
operator|->
name|name
else|:
literal|""
expr_stmt|;
name|d
operator|=
operator|(
name|iff
operator|->
name|description
operator|)
condition|?
name|iff
operator|->
name|description
else|:
literal|""
expr_stmt|;
name|f
operator|=
operator|(
name|iff
operator|->
name|flags
operator|==
name|PCAP_IF_LOOPBACK
operator|)
condition|?
literal|"L"
else|:
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|"%3d: %*s %s '%s'\n"
argument_list|,
name|if_number
operator|++
argument_list|,
name|longest_name_len
argument_list|,
name|n
argument_list|,
name|f
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|addr
operator|=
name|iff
operator|->
name|addresses
expr_stmt|;
while|while
condition|(
name|addr
condition|)
block|{
name|printf
argument_list|(
literal|"%*s "
argument_list|,
operator|(
literal|5
operator|+
name|longest_name_len
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* add some indentation */
name|printf
argument_list|(
literal|"%15s  "
argument_list|,
operator|(
name|addr
operator|->
name|addr
operator|)
condition|?
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|->
name|addr
operator|)
operator|->
name|sin_addr
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%15s  "
argument_list|,
operator|(
name|addr
operator|->
name|netmask
operator|)
condition|?
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|->
name|netmask
operator|)
operator|->
name|sin_addr
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%15s  "
argument_list|,
operator|(
name|addr
operator|->
name|broadaddr
operator|)
condition|?
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|->
name|broadaddr
operator|)
operator|->
name|sin_addr
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%15s  "
argument_list|,
operator|(
name|addr
operator|->
name|dstaddr
operator|)
condition|?
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|->
name|dstaddr
operator|)
operator|->
name|sin_addr
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|addr
operator|->
name|next
expr_stmt|;
block|}
name|iff
operator|=
name|iff
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump
parameter_list|(
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s"
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%2.2x "
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_interface_list_p
parameter_list|(
name|void
parameter_list|)
block|{
name|pcap_if_t
modifier|*
name|iff
decl_stmt|;
name|pcap_addr_t
modifier|*
name|addr
decl_stmt|;
name|int
name|if_number
init|=
literal|0
decl_stmt|;
name|iff
operator|=
name|acn_if_list
expr_stmt|;
name|printf
argument_list|(
literal|"Interface Pointer @ %p is %p:\n"
argument_list|,
operator|&
name|acn_if_list
argument_list|,
name|iff
argument_list|)
expr_stmt|;
while|while
condition|(
name|iff
condition|)
block|{
name|printf
argument_list|(
literal|"%3d: %p %p next: %p\n"
argument_list|,
name|if_number
operator|++
argument_list|,
name|iff
operator|->
name|name
argument_list|,
name|iff
operator|->
name|description
argument_list|,
name|iff
operator|->
name|next
argument_list|)
expr_stmt|;
name|dump
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|iff
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap_if_t
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|addr
operator|=
name|iff
operator|->
name|addresses
expr_stmt|;
while|while
condition|(
name|addr
condition|)
block|{
name|printf
argument_list|(
literal|"          %p %p %p %p, next: %p\n"
argument_list|,
name|addr
operator|->
name|addr
argument_list|,
name|addr
operator|->
name|netmask
argument_list|,
name|addr
operator|->
name|broadaddr
argument_list|,
name|addr
operator|->
name|dstaddr
argument_list|,
name|addr
operator|->
name|next
argument_list|)
expr_stmt|;
name|dump
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap_addr_t
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|addr
operator|=
name|addr
operator|->
name|next
expr_stmt|;
block|}
name|iff
operator|=
name|iff
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_unit_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|iface_t
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"%c:%c %s %s\n"
argument_list|,
literal|'C'
argument_list|,
literal|'S'
argument_list|,
literal|"fd"
argument_list|,
literal|"IP Address"
argument_list|)
expr_stmt|;
for|for
control|(
name|chassis
operator|=
literal|0
init|;
name|chassis
operator|<=
name|MAX_CHASSIS
condition|;
name|chassis
operator|++
control|)
block|{
for|for
control|(
name|geoslot
operator|=
literal|0
init|;
name|geoslot
operator|<=
name|MAX_GEOSLOT
condition|;
name|geoslot
operator|++
control|)
block|{
if|if
condition|(
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|ip
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d:%d %2d %s\n"
argument_list|,
name|chassis
argument_list|,
name|geoslot
argument_list|,
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|fd
argument_list|,
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|ip
argument_list|)
expr_stmt|;
name|p
operator|=
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|iface
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|char
modifier|*
name|n
init|=
operator|(
name|p
operator|->
name|name
operator|)
condition|?
name|p
operator|->
name|name
else|:
literal|""
decl_stmt|;
name|char
modifier|*
name|i
init|=
operator|(
name|p
operator|->
name|IOPname
operator|)
condition|?
name|p
operator|->
name|IOPname
else|:
literal|""
decl_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|printf
argument_list|(
literal|"   %12s    -> %12s\n"
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|find_unit_by_fd
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
modifier|*
name|chassis
parameter_list|,
name|int
modifier|*
name|geoslot
parameter_list|,
name|unit_t
modifier|*
modifier|*
name|unit_ptr
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<=
name|MAX_CHASSIS
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|MAX_GEOSLOT
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|units
index|[
name|c
index|]
index|[
name|s
index|]
operator|.
name|fd
operator|==
name|fd
operator|||
name|units
index|[
name|c
index|]
index|[
name|s
index|]
operator|.
name|find_fd
operator|==
name|fd
condition|)
block|{
if|if
condition|(
name|chassis
condition|)
operator|*
name|chassis
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|geoslot
condition|)
operator|*
name|geoslot
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|unit_ptr
condition|)
operator|*
name|unit_ptr
operator|=
operator|&
name|units
index|[
name|c
index|]
index|[
name|s
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_client_nbytes
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|count
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unit_t
modifier|*
name|u
decl_stmt|;
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|int
name|len
decl_stmt|;
name|find_unit_by_fd
argument_list|(
name|fd
argument_list|,
operator|&
name|chassis
argument_list|,
operator|&
name|geoslot
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|recv
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* read in whatever data was sent to us */
name|count
operator|-=
name|len
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
block|}
comment|/* till we have everything we are looking for */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|empty_unit_iface
parameter_list|(
name|unit_t
modifier|*
name|u
parameter_list|)
block|{
name|iface_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|cur
operator|=
name|u
operator|->
name|iface
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
comment|/* loop over all the interface entries */
if|if
condition|(
name|cur
operator|->
name|name
condition|)
name|free
argument_list|(
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* throwing away the contents if they exist */
if|if
condition|(
name|cur
operator|->
name|IOPname
condition|)
name|free
argument_list|(
name|cur
operator|->
name|IOPname
argument_list|)
expr_stmt|;
name|p
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cur
argument_list|)
expr_stmt|;
comment|/* then throw away the structure itself */
name|cur
operator|=
name|p
expr_stmt|;
block|}
name|u
operator|->
name|iface
operator|=
literal|0
expr_stmt|;
comment|/* and finally remember that there are no remaining structure */
block|}
end_function

begin_function
specifier|static
name|void
name|empty_unit
parameter_list|(
name|int
name|chassis
parameter_list|,
name|int
name|geoslot
parameter_list|)
block|{
name|unit_t
modifier|*
name|u
init|=
operator|&
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
decl_stmt|;
name|empty_unit_iface
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|imsg
condition|)
block|{
comment|/* then if an inbound message buffer exists */
name|void
modifier|*
name|bigger_buffer
decl_stmt|;
name|bigger_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|u
operator|->
name|imsg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* and re-allocate the old large buffer into a new small one */
if|if
condition|(
name|bigger_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* oops, realloc call failed */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning...call to realloc() failed, value of errno is %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return;
block|}
name|u
operator|->
name|imsg
operator|=
name|bigger_buffer
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|empty_unit_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
for|for
control|(
name|chassis
operator|=
literal|0
init|;
name|chassis
operator|<=
name|MAX_CHASSIS
condition|;
name|chassis
operator|++
control|)
block|{
for|for
control|(
name|geoslot
operator|=
literal|0
init|;
name|geoslot
operator|<=
name|MAX_GEOSLOT
condition|;
name|geoslot
operator|++
control|)
block|{
if|if
condition|(
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|ip
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|ip
argument_list|)
expr_stmt|;
comment|/* get rid of the malloc'ed space that holds the IP address */
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|ip
operator|=
literal|0
expr_stmt|;
comment|/* then set the pointer to NULL */
block|}
name|empty_unit
argument_list|(
name|chassis
argument_list|,
name|geoslot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|find_nth_interface_name
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|iface_t
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|last_name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
comment|/* ensure we are working with a valid number */
for|for
control|(
name|chassis
operator|=
literal|0
init|;
name|chassis
operator|<=
name|MAX_CHASSIS
condition|;
name|chassis
operator|++
control|)
block|{
comment|/* scan the table... */
for|for
control|(
name|geoslot
operator|=
literal|0
init|;
name|geoslot
operator|<=
name|MAX_GEOSLOT
condition|;
name|geoslot
operator|++
control|)
block|{
if|if
condition|(
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|ip
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|iface
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
comment|/* and all interfaces... */
if|if
condition|(
name|p
operator|->
name|IOPname
condition|)
name|last_name
operator|=
name|p
operator|->
name|name
expr_stmt|;
comment|/* remembering the last name found */
if|if
condition|(
name|n
operator|--
operator|==
literal|0
condition|)
return|return
name|last_name
return|;
comment|/* and if we hit the instance requested */
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* if we couldn't fine the selected entry */
if|if
condition|(
name|last_name
condition|)
return|return
name|last_name
return|;
comment|/* ... but we did have at least one entry... return the last entry found */
return|return
literal|""
return|;
comment|/* ... but if there wasn't any entry... return an empty string instead */
block|}
end_function

begin_function
name|int
name|acn_parse_hosts_file
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* returns: -1 = error, 0 = OK */
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
name|MAX_LINE_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|unit_t
modifier|*
name|u
decl_stmt|;
name|empty_unit_table
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
literal|"/etc/hosts"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* try to open the hosts file and if it fails */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Cannot open '/etc/hosts' for reading."
argument_list|)
expr_stmt|;
comment|/* return the nohostsfile error response */
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|MAX_LINE_SIZE
operator|-
literal|1
argument_list|,
name|fp
argument_list|)
condition|)
block|{
comment|/* while looping over the file */
name|pos
operator|=
name|strcspn
argument_list|(
name|buf
argument_list|,
literal|"#\n\r"
argument_list|)
expr_stmt|;
comment|/* find the first comment character or EOL */
operator|*
operator|(
name|buf
operator|+
name|pos
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* and clobber it and anything that follows it */
name|pos
operator|=
name|strspn
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
comment|/* then find the first non-white space */
if|if
condition|(
name|pos
operator|==
name|strlen
argument_list|(
name|buf
argument_list|)
condition|)
comment|/* if there is nothing but white space on the line */
continue|continue;
comment|/* ignore that empty line */
name|ptr
operator|=
name|buf
operator|+
name|pos
expr_stmt|;
comment|/* and skip over any of that leading whitespace */
if|if
condition|(
operator|(
name|ptr2
operator|=
name|strstr
argument_list|(
name|ptr
argument_list|,
literal|"_I_"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* skip any lines that don't have names that look like they belong to IOPs */
continue|continue;
if|if
condition|(
operator|*
operator|(
name|ptr2
operator|+
literal|4
operator|)
operator|!=
literal|'_'
condition|)
comment|/* and skip other lines that have names that don't look like ACN components */
continue|continue;
operator|*
operator|(
name|ptr
operator|+
name|strcspn
argument_list|(
name|ptr
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate the IP address so its a standalone string */
name|chassis
operator|=
operator|*
operator|(
name|ptr2
operator|+
literal|3
operator|)
operator|-
literal|'0'
expr_stmt|;
comment|/* extract the chassis number */
name|geoslot
operator|=
operator|*
operator|(
name|ptr2
operator|+
literal|5
operator|)
operator|-
literal|'0'
expr_stmt|;
comment|/* and geo-slot number */
if|if
condition|(
name|chassis
operator|<
literal|1
operator|||
name|chassis
operator|>
name|MAX_CHASSIS
operator|||
name|geoslot
operator|<
literal|1
operator|||
name|geoslot
operator|>
name|MAX_GEOSLOT
condition|)
block|{
comment|/* if the chassis and/or slot numbers appear to be bad... */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Invalid ACN name in '/etc/hosts'."
argument_list|)
expr_stmt|;
comment|/* warn the user */
continue|continue;
comment|/* and ignore the entry */
block|}
if|if
condition|(
operator|(
name|ptr2
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|strcpy
argument_list|(
name|ptr2
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* copy the IP address into our malloc'ed memory */
name|u
operator|=
operator|&
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
expr_stmt|;
name|u
operator|->
name|ip
operator|=
name|ptr2
expr_stmt|;
comment|/* and remember the whole shebang */
name|u
operator|->
name|chassis
operator|=
name|chassis
expr_stmt|;
name|u
operator|->
name|geoslot
operator|=
name|geoslot
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errbuf
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|open_with_IOP
parameter_list|(
name|unit_t
modifier|*
name|u
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|sockfd
decl_stmt|;
name|char
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|u
operator|->
name|serv_addr
operator|==
name|NULL
condition|)
block|{
name|u
operator|->
name|serv_addr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
comment|/* since we called malloc(), lets check to see if we actually got the memory	*/
if|if
condition|(
name|u
operator|->
name|serv_addr
operator|==
name|NULL
condition|)
block|{
comment|/* oops, we didn't get the memory requested	*/
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malloc() request for u->serv_addr failed, value of errno is: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|ip
operator|=
name|u
operator|->
name|ip
expr_stmt|;
comment|/* bzero() is deprecated, replaced with memset()	*/
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|u
operator|->
name|serv_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|->
name|serv_addr
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|u
operator|->
name|serv_addr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|u
operator|->
name|serv_addr
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|IOP_SNIFFER_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pcap can't open a socket for connecting to IOP at %s\n"
argument_list|,
name|ip
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|u
operator|->
name|serv_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pcap can't connect to IOP at %s\n"
argument_list|,
name|ip
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flag
operator|==
name|LIVE
condition|)
name|u
operator|->
name|fd
operator|=
name|sockfd
expr_stmt|;
else|else
name|u
operator|->
name|find_fd
operator|=
name|sockfd
expr_stmt|;
name|u
operator|->
name|first_time
operator|=
literal|0
expr_stmt|;
return|return
name|sockfd
return|;
comment|/* return the non-zero file descriptor as a 'success' indicator */
block|}
end_function

begin_function
specifier|static
name|void
name|close_with_IOP
parameter_list|(
name|int
name|chassis
parameter_list|,
name|int
name|geoslot
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
modifier|*
name|id
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|LIVE
condition|)
name|id
operator|=
operator|&
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|fd
expr_stmt|;
else|else
name|id
operator|=
operator|&
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|find_fd
expr_stmt|;
if|if
condition|(
operator|*
name|id
condition|)
block|{
comment|/* this was the last time, so... if we are connected... */
name|close
argument_list|(
operator|*
name|id
argument_list|)
expr_stmt|;
comment|/* disconnect us */
operator|*
name|id
operator|=
literal|0
expr_stmt|;
comment|/* and forget that the descriptor exists because we are not open */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pcap_cleanup_acn
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|unit_t
modifier|*
name|u
decl_stmt|;
if|if
condition|(
name|find_unit_by_fd
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
operator|&
name|chassis
argument_list|,
operator|&
name|geoslot
argument_list|,
operator|&
name|u
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|close_with_IOP
argument_list|(
name|chassis
argument_list|,
name|geoslot
argument_list|,
name|LIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
condition|)
name|u
operator|->
name|first_time
operator|=
literal|0
expr_stmt|;
name|pcap_cleanup_live_common
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_to_fd
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|nwritten
decl_stmt|;
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nwritten
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|find_unit_by_fd
argument_list|(
name|fd
argument_list|,
operator|&
name|chassis
argument_list|,
operator|&
name|geoslot
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|fd
operator|==
name|fd
condition|)
name|close_with_IOP
argument_list|(
name|chassis
argument_list|,
name|geoslot
argument_list|,
name|LIVE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
operator|.
name|find_fd
operator|==
name|fd
condition|)
name|close_with_IOP
argument_list|(
name|chassis
argument_list|,
name|geoslot
argument_list|,
name|FIND
argument_list|)
expr_stmt|;
name|empty_unit
argument_list|(
name|chassis
argument_list|,
name|geoslot
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|-=
name|nwritten
expr_stmt|;
name|str
operator|+=
name|nwritten
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acn_freealldevs
parameter_list|(
name|void
parameter_list|)
block|{
name|pcap_if_t
modifier|*
name|iff
decl_stmt|,
modifier|*
name|next_iff
decl_stmt|;
name|pcap_addr_t
modifier|*
name|addr
decl_stmt|,
modifier|*
name|next_addr
decl_stmt|;
for|for
control|(
name|iff
operator|=
name|acn_if_list
init|;
name|iff
operator|!=
name|NULL
condition|;
name|iff
operator|=
name|next_iff
control|)
block|{
name|next_iff
operator|=
name|iff
operator|->
name|next
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|iff
operator|->
name|addresses
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|next_addr
control|)
block|{
name|next_addr
operator|=
name|addr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|addr
condition|)
name|free
argument_list|(
name|addr
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|netmask
condition|)
name|free
argument_list|(
name|addr
operator|->
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|broadaddr
condition|)
name|free
argument_list|(
name|addr
operator|->
name|broadaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|dstaddr
condition|)
name|free
argument_list|(
name|addr
operator|->
name|dstaddr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iff
operator|->
name|name
condition|)
name|free
argument_list|(
name|iff
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|iff
operator|->
name|description
condition|)
name|free
argument_list|(
name|iff
operator|->
name|description
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nonUnified_IOP_port_name
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|,
name|unit_t
modifier|*
name|u
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"%s_%d_%d"
argument_list|,
name|proto
argument_list|,
name|u
operator|->
name|chassis
argument_list|,
name|u
operator|->
name|geoslot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unified_IOP_port_name
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|,
name|unit_t
modifier|*
name|u
parameter_list|,
name|int
name|IOPportnum
parameter_list|)
block|{
name|int
name|portnum
decl_stmt|;
name|portnum
operator|=
operator|(
operator|(
name|u
operator|->
name|chassis
operator|-
literal|1
operator|)
operator|*
literal|64
operator|)
operator|+
operator|(
operator|(
name|u
operator|->
name|geoslot
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
operator|+
name|IOPportnum
operator|+
literal|1
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"%s_%d"
argument_list|,
name|proto
argument_list|,
name|portnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|translate_IOP_to_pcap_name
parameter_list|(
name|unit_t
modifier|*
name|u
parameter_list|,
name|char
modifier|*
name|IOPname
parameter_list|,
name|bpf_u_int32
name|iftype
parameter_list|)
block|{
name|iface_t
modifier|*
name|iface_ptr
decl_stmt|,
modifier|*
name|iface
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|proto
decl_stmt|;
name|char
modifier|*
name|port
decl_stmt|;
name|int
name|IOPportnum
init|=
literal|0
decl_stmt|;
name|iface
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iface_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get memory for a structure */
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
comment|/* oops, we didn't get the memory requested	*/
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error...couldn't allocate memory for interface structure...value of errno is: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iface
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iface_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bzero is deprecated(), replaced with memset() */
name|iface
operator|->
name|iftype
operator|=
name|iftype
expr_stmt|;
comment|/* remember the interface type of this interface */
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|IOPname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* get memory for the IOP's name */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* oops, we didn't get the memory requested     */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error...couldn't allocate memory for IOPname...value of errno is: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|IOPname
argument_list|)
expr_stmt|;
comment|/* and copy it in */
name|iface
operator|->
name|IOPname
operator|=
name|name
expr_stmt|;
comment|/* and stick it into the structure */
if|if
condition|(
name|strncmp
argument_list|(
name|IOPname
argument_list|,
literal|"lo"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IOPportnum
operator|=
name|atoi
argument_list|(
operator|&
name|IOPname
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iftype
condition|)
block|{
case|case
name|DLT_EN10MB
case|:
name|nonUnified_IOP_port_name
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"lo"
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unified_IOP_port_name
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"???"
argument_list|,
name|u
argument_list|,
name|IOPportnum
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|IOPname
argument_list|,
literal|"eth"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IOPportnum
operator|=
name|atoi
argument_list|(
operator|&
name|IOPname
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iftype
condition|)
block|{
case|case
name|DLT_EN10MB
case|:
name|nonUnified_IOP_port_name
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"eth"
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unified_IOP_port_name
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"???"
argument_list|,
name|u
argument_list|,
name|IOPportnum
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|IOPname
argument_list|,
literal|"wan"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IOPportnum
operator|=
name|atoi
argument_list|(
operator|&
name|IOPname
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iftype
condition|)
block|{
case|case
name|DLT_SITA
case|:
name|unified_IOP_port_name
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"wan"
argument_list|,
name|u
argument_list|,
name|IOPportnum
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unified_IOP_port_name
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"???"
argument_list|,
name|u
argument_list|,
name|IOPportnum
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error... invalid IOP name %s\n"
argument_list|,
name|IOPname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* get memory for that name */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* oops, we didn't get the memory requested     */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error...couldn't allocate memory for IOP port name...value of errno is: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* and copy it in */
name|iface
operator|->
name|name
operator|=
name|name
expr_stmt|;
comment|/* and stick it into the structure */
if|if
condition|(
name|u
operator|->
name|iface
operator|==
literal|0
condition|)
block|{
comment|/* if this is the first name */
name|u
operator|->
name|iface
operator|=
name|iface
expr_stmt|;
comment|/* stick this entry at the head of the list */
block|}
else|else
block|{
name|iface_ptr
operator|=
name|u
operator|->
name|iface
expr_stmt|;
while|while
condition|(
name|iface_ptr
operator|->
name|next
condition|)
block|{
comment|/* othewise scan the list */
name|iface_ptr
operator|=
name|iface_ptr
operator|->
name|next
expr_stmt|;
comment|/* till we're at the last entry */
block|}
name|iface_ptr
operator|->
name|next
operator|=
name|iface
expr_stmt|;
comment|/* then tack this entry on the end of the list */
block|}
return|return
name|iface
operator|->
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|if_sort
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|char
modifier|*
name|s1_p2
decl_stmt|,
modifier|*
name|s2_p2
decl_stmt|;
name|char
name|str1
index|[
name|MAX_LINE_SIZE
index|]
decl_stmt|,
name|str2
index|[
name|MAX_LINE_SIZE
index|]
decl_stmt|;
name|int
name|s1_p1_len
decl_stmt|,
name|s2_p1_len
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|(
name|s1_p2
operator|=
name|strchr
argument_list|(
name|s1
argument_list|,
literal|'_'
argument_list|)
operator|)
condition|)
block|{
comment|/* if an underscore is found... */
name|s1_p1_len
operator|=
name|s1_p2
operator|-
name|s1
expr_stmt|;
comment|/* the prefix length is the difference in pointers */
name|s1_p2
operator|++
expr_stmt|;
comment|/* the suffix actually starts _after_ the underscore */
block|}
else|else
block|{
comment|/* otherwise... */
name|s1_p1_len
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
comment|/* the prefix length is the length of the string itself */
name|s1_p2
operator|=
literal|0
expr_stmt|;
comment|/* and there is no suffix */
block|}
if|if
condition|(
operator|(
name|s2_p2
operator|=
name|strchr
argument_list|(
name|s2
argument_list|,
literal|'_'
argument_list|)
operator|)
condition|)
block|{
comment|/* now do the same for the second string */
name|s2_p1_len
operator|=
name|s2_p2
operator|-
name|s2
expr_stmt|;
name|s2_p2
operator|++
expr_stmt|;
block|}
else|else
block|{
name|s2_p1_len
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|s2_p2
operator|=
literal|0
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|str1
argument_list|,
name|s1
argument_list|,
operator|(
name|s1_p1_len
operator|>
sizeof|sizeof
argument_list|(
name|str1
argument_list|)
operator|)
condition|?
name|s1_p1_len
else|:
sizeof|sizeof
argument_list|(
name|str1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|str1
operator|+
name|s1_p1_len
operator|)
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|str2
argument_list|,
name|s2
argument_list|,
operator|(
name|s2_p1_len
operator|>
sizeof|sizeof
argument_list|(
name|str2
argument_list|)
operator|)
condition|?
name|s2_p1_len
else|:
sizeof|sizeof
argument_list|(
name|str2
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|str2
operator|+
name|s2_p1_len
operator|)
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|strcmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
return|return
name|retval
return|;
comment|/* if they are not identical, then we can quit now and return the indication */
return|return
name|strcmp
argument_list|(
name|s1_p2
argument_list|,
name|s2_p2
argument_list|)
return|;
comment|/* otherwise we return the result of comparing the 2nd half of the string */
block|}
end_function

begin_function
specifier|static
name|void
name|sort_if_table
parameter_list|(
name|void
parameter_list|)
block|{
name|pcap_if_t
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|has_swapped
decl_stmt|;
if|if
condition|(
operator|!
name|acn_if_list
condition|)
return|return;
comment|/* nothing to do if the list is empty */
while|while
condition|(
literal|1
condition|)
block|{
name|p1
operator|=
name|acn_if_list
expr_stmt|;
comment|/* start at the head of the list */
name|prev
operator|=
literal|0
expr_stmt|;
name|has_swapped
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p2
operator|=
name|p1
operator|->
name|next
operator|)
condition|)
block|{
if|if
condition|(
name|if_sort
argument_list|(
name|p1
operator|->
name|name
argument_list|,
name|p2
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
comment|/* we are swapping things that are _not_ at the head of the list */
name|temp
operator|=
name|p2
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|p2
expr_stmt|;
name|p2
operator|->
name|next
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|next
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
comment|/* special treatment if we are swapping with the head of the list */
name|temp
operator|=
name|p2
operator|->
name|next
expr_stmt|;
name|acn_if_list
operator|=
name|p2
expr_stmt|;
name|p2
operator|->
name|next
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|next
operator|=
name|temp
expr_stmt|;
block|}
name|p1
operator|=
name|p2
expr_stmt|;
name|prev
operator|=
name|p1
expr_stmt|;
name|has_swapped
operator|=
literal|1
expr_stmt|;
block|}
name|prev
operator|=
name|p1
expr_stmt|;
name|p1
operator|=
name|p1
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|has_swapped
operator|==
literal|0
condition|)
return|return;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|process_client_data
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* returns: -1 = error, 0 = OK */
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|unit_t
modifier|*
name|u
decl_stmt|;
name|pcap_if_t
modifier|*
name|iff
decl_stmt|,
modifier|*
name|prev_iff
decl_stmt|;
name|pcap_addr_t
modifier|*
name|addr
decl_stmt|,
modifier|*
name|prev_addr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|address_count
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|bpf_u_int32
name|interfaceType
decl_stmt|;
name|unsigned
name|char
name|flags
decl_stmt|;
name|void
modifier|*
name|bigger_buffer
decl_stmt|;
name|prev_iff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|chassis
operator|=
literal|0
init|;
name|chassis
operator|<=
name|MAX_CHASSIS
condition|;
name|chassis
operator|++
control|)
block|{
for|for
control|(
name|geoslot
operator|=
literal|0
init|;
name|geoslot
operator|<=
name|MAX_GEOSLOT
condition|;
name|geoslot
operator|++
control|)
block|{
comment|/* now loop over all the devices */
name|u
operator|=
operator|&
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
expr_stmt|;
name|empty_unit_iface
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|u
operator|->
name|imsg
expr_stmt|;
comment|/* point to the start of the msg for this IOP */
while|while
condition|(
name|ptr
operator|<
operator|(
name|u
operator|->
name|imsg
operator|+
name|u
operator|->
name|len
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|iff
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_if_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iff
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap_if_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bzero() is deprecated, replaced with memset() */
if|if
condition|(
name|acn_if_list
operator|==
literal|0
condition|)
name|acn_if_list
operator|=
name|iff
expr_stmt|;
comment|/* remember the head of the list */
if|if
condition|(
name|prev_iff
condition|)
name|prev_iff
operator|->
name|next
operator|=
name|iff
expr_stmt|;
comment|/* insert a forward link */
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
comment|/* if there is a count for the name */
if|if
condition|(
operator|(
name|iff
operator|->
name|name
operator|=
name|malloc
argument_list|(
operator|*
name|ptr
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* get that amount of space */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|iff
operator|->
name|name
argument_list|,
operator|(
name|ptr
operator|+
literal|1
operator|)
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
comment|/* copy the name into the malloc'ed space */
operator|*
operator|(
name|iff
operator|->
name|name
operator|+
operator|*
name|ptr
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* and null terminate the string */
name|ptr
operator|+=
operator|*
name|ptr
expr_stmt|;
comment|/* now move the pointer forwards by the length of the count plus the length of the string */
block|}
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
comment|/* if there is a count for the description */
if|if
condition|(
operator|(
name|iff
operator|->
name|description
operator|=
name|malloc
argument_list|(
operator|*
name|ptr
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* get that amount of space */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|iff
operator|->
name|description
argument_list|,
operator|(
name|ptr
operator|+
literal|1
operator|)
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
comment|/* copy the name into the malloc'ed space */
operator|*
operator|(
name|iff
operator|->
name|description
operator|+
operator|*
name|ptr
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* and null terminate the string */
name|ptr
operator|+=
operator|*
name|ptr
expr_stmt|;
comment|/* now move the pointer forwards by the length of the count plus the length of the string */
block|}
name|ptr
operator|++
expr_stmt|;
name|interfaceType
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|bpf_u_int32
operator|*
operator|)
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
comment|/* skip over the interface type */
name|flags
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|flags
condition|)
name|iff
operator|->
name|flags
operator|=
name|PCAP_IF_LOOPBACK
expr_stmt|;
comment|/* if this is a loopback style interface, lets mark it as such */
name|address_count
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|prev_addr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|address_count
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|addr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_addr_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap_addr_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bzero() is deprecated, replaced with memset() */
if|if
condition|(
name|iff
operator|->
name|addresses
operator|==
literal|0
condition|)
name|iff
operator|->
name|addresses
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|prev_addr
condition|)
name|prev_addr
operator|->
name|next
operator|=
name|addr
expr_stmt|;
comment|/* insert a forward link */
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
comment|/* if there is a count for the address */
if|if
condition|(
operator|(
name|s
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* get that amount of space */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bzero() is deprecated, replaced with memset() */
name|addr
operator|->
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|s
expr_stmt|;
name|s
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|s
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
operator|(
name|bpf_u_int32
operator|*
operator|)
operator|(
name|ptr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy the address in */
name|ptr
operator|+=
operator|*
name|ptr
expr_stmt|;
comment|/* now move the pointer forwards according to the specified length of the address */
block|}
name|ptr
operator|++
expr_stmt|;
comment|/* then forwards one more for the 'length of the address' field */
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
comment|/* process any netmask */
if|if
condition|(
operator|(
name|s
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* bzero() is deprecated, replaced with memset() */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|->
name|netmask
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|s
expr_stmt|;
name|s
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|s
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
operator|(
name|bpf_u_int32
operator|*
operator|)
operator|(
name|ptr
operator|+
literal|1
operator|)
expr_stmt|;
name|ptr
operator|+=
operator|*
name|ptr
expr_stmt|;
block|}
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
comment|/* process any broadcast address */
if|if
condition|(
operator|(
name|s
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* bzero() is deprecated, replaced with memset() */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|->
name|broadaddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|s
expr_stmt|;
name|s
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|s
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
operator|(
name|bpf_u_int32
operator|*
operator|)
operator|(
name|ptr
operator|+
literal|1
operator|)
expr_stmt|;
name|ptr
operator|+=
operator|*
name|ptr
expr_stmt|;
block|}
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
comment|/* process any destination address */
if|if
condition|(
operator|(
name|s
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* bzero() is deprecated, replaced with memset() */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|->
name|dstaddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|s
expr_stmt|;
name|s
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|s
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
operator|(
name|bpf_u_int32
operator|*
operator|)
operator|(
name|ptr
operator|+
literal|1
operator|)
expr_stmt|;
name|ptr
operator|+=
operator|*
name|ptr
expr_stmt|;
block|}
name|ptr
operator|++
expr_stmt|;
name|prev_addr
operator|=
name|addr
expr_stmt|;
block|}
name|prev_iff
operator|=
name|iff
expr_stmt|;
name|newname
operator|=
name|translate_IOP_to_pcap_name
argument_list|(
name|u
argument_list|,
name|iff
operator|->
name|name
argument_list|,
name|interfaceType
argument_list|)
expr_stmt|;
comment|/* add a translation entry and get a point to the mangled name */
name|bigger_buffer
operator|=
name|realloc
argument_list|(
name|iff
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|newname
argument_list|)
operator|+
literal|1
argument_list|)
block|)
empty_stmt|;
if|if
condition|(
name|bigger_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* we now re-write the name stored in the interface list */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"realloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|iff
operator|->
name|name
operator|=
name|bigger_buffer
expr_stmt|;
name|strcpy
argument_list|(
name|iff
operator|->
name|name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
comment|/* to this new name */
block|}
block|}
block|}
end_function

begin_return
return|return
literal|0
return|;
end_return

begin_function
unit|}  static
name|int
name|read_client_data
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|unit_t
modifier|*
name|u
decl_stmt|;
name|int
name|len
decl_stmt|;
name|find_unit_by_fd
argument_list|(
name|fd
argument_list|,
operator|&
name|chassis
argument_list|,
operator|&
name|geoslot
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|recv
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* read in whatever data was sent to us */
if|if
condition|(
operator|(
name|u
operator|->
name|imsg
operator|=
name|realloc
argument_list|(
name|u
operator|->
name|imsg
argument_list|,
operator|(
name|u
operator|->
name|len
operator|+
name|len
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* extend the buffer for the new data */
return|return
literal|0
return|;
name|memcpy
argument_list|(
operator|(
name|u
operator|->
name|imsg
operator|+
name|u
operator|->
name|len
operator|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* append the new data */
name|u
operator|->
name|len
operator|+=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wait_for_all_answers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|2
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|fd_set
name|working_set
decl_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<=
name|max_fs
condition|;
name|fd
operator|++
control|)
block|{
comment|/* scan the list of descriptors we may be listening to */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
comment|/* and see if there are any still set */
block|}
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
return|return;
comment|/* we are done, when they are all gone */
name|memcpy
argument_list|(
operator|&
name|working_set
argument_list|,
operator|&
name|readfds
argument_list|,
sizeof|sizeof
argument_list|(
name|readfds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* otherwise, we still have to listen for more stuff, till we timeout */
name|retval
operator|=
name|select
argument_list|(
name|max_fs
operator|+
literal|1
argument_list|,
operator|&
name|working_set
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* an error occured !!!!! */
return|return;
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
comment|/* timeout occured, so process what we've got sofar and return */
name|printf
argument_list|(
literal|"timeout\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<=
name|max_fs
condition|;
name|fd
operator|++
control|)
block|{
comment|/* scan the list of things to do, and do them */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|working_set
argument_list|)
condition|)
block|{
if|if
condition|(
name|read_client_data
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* if the socket has closed */
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
comment|/* and descriptors we listen to for errors */
name|find_unit_by_fd
argument_list|(
name|fd
argument_list|,
operator|&
name|chassis
argument_list|,
operator|&
name|geoslot
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|close_with_IOP
argument_list|(
name|chassis
argument_list|,
name|geoslot
argument_list|,
name|FIND
argument_list|)
expr_stmt|;
comment|/* and close out connection to him */
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_error_response
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* return a pointer on error, NULL on no error */
name|char
name|byte
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|recv
argument_list|(
name|fd
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read another byte in */
if|if
condition|(
name|errbuf
operator|&&
operator|(
name|len
operator|++
operator|<
name|PCAP_ERRBUF_SIZE
operator|)
condition|)
block|{
comment|/* and if there is still room in the buffer */
operator|*
name|errbuf
operator|++
operator|=
name|byte
expr_stmt|;
comment|/* stick it in */
operator|*
name|errbuf
operator|=
literal|'\0'
expr_stmt|;
comment|/* ensure the string is null terminated just in case we might exceed the buffer's size */
block|}
if|if
condition|(
name|byte
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
return|return
name|errbuf
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|acn_findalldevs
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* returns: -1 = error, 0 = OK */
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|unit_t
modifier|*
name|u
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|max_fs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|chassis
operator|=
literal|0
init|;
name|chassis
operator|<=
name|MAX_CHASSIS
condition|;
name|chassis
operator|++
control|)
block|{
for|for
control|(
name|geoslot
operator|=
literal|0
init|;
name|geoslot
operator|<=
name|MAX_GEOSLOT
condition|;
name|geoslot
operator|++
control|)
block|{
name|u
operator|=
operator|&
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|ip
operator|&&
operator|(
name|open_with_IOP
argument_list|(
name|u
argument_list|,
name|FIND
argument_list|)
operator|)
condition|)
block|{
comment|/* connect to the remote IOP */
name|send_to_fd
argument_list|(
name|u
operator|->
name|find_fd
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"\0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_error_response
argument_list|(
name|u
operator|->
name|find_fd
argument_list|,
name|errbuf
argument_list|)
condition|)
name|close_with_IOP
argument_list|(
name|chassis
argument_list|,
name|geoslot
argument_list|,
name|FIND
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|u
operator|->
name|find_fd
operator|>
name|max_fs
condition|)
name|max_fs
operator|=
name|u
operator|->
name|find_fd
expr_stmt|;
comment|/* remember the highest number currently in use */
name|FD_SET
argument_list|(
name|u
operator|->
name|find_fd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
comment|/* we are going to want to read this guy's response to */
name|u
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|send_to_fd
argument_list|(
name|u
operator|->
name|find_fd
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"Q"
argument_list|)
expr_stmt|;
comment|/* this interface query request */
block|}
block|}
block|}
block|}
name|wait_for_all_answers
argument_list|()
expr_stmt|;
if|if
condition|(
name|process_client_data
argument_list|(
name|errbuf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|sort_if_table
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_stats_acn
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|send_to_fd
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"S"
argument_list|)
expr_stmt|;
comment|/* send the get_stats command to the IOP */
if|if
condition|(
name|read_client_nbytes
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* try reading the required bytes */
name|ps
operator|->
name|ps_recv
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* break the buffer into its three 32 bit components */
name|ps
operator|->
name|ps_drop
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ps_ifdrop
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|buf
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acn_open_live
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
modifier|*
name|linktype
parameter_list|)
block|{
comment|/* returns 0 on error, else returns the file descriptor */
name|int
name|chassis
decl_stmt|,
name|geoslot
decl_stmt|;
name|unit_t
modifier|*
name|u
decl_stmt|;
name|iface_t
modifier|*
name|p
decl_stmt|;
name|pcap_if_t
modifier|*
name|alldevsp
decl_stmt|;
name|pcap_platform_finddevs
argument_list|(
operator|&
name|alldevsp
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|chassis
operator|=
literal|0
init|;
name|chassis
operator|<=
name|MAX_CHASSIS
condition|;
name|chassis
operator|++
control|)
block|{
comment|/* scan the table... */
for|for
control|(
name|geoslot
operator|=
literal|0
init|;
name|geoslot
operator|<=
name|MAX_GEOSLOT
condition|;
name|geoslot
operator|++
control|)
block|{
name|u
operator|=
operator|&
name|units
index|[
name|chassis
index|]
index|[
name|geoslot
index|]
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|ip
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|u
operator|->
name|iface
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
comment|/* and all interfaces... */
if|if
condition|(
name|p
operator|->
name|IOPname
operator|&&
name|p
operator|->
name|name
operator|&&
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* and if we found the interface we want... */
operator|*
name|linktype
operator|=
name|p
operator|->
name|iftype
expr_stmt|;
name|open_with_IOP
argument_list|(
name|u
argument_list|,
name|LIVE
argument_list|)
expr_stmt|;
comment|/* start a connection with that IOP */
name|send_to_fd
argument_list|(
name|u
operator|->
name|fd
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|IOPname
argument_list|)
operator|+
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|IOPname
argument_list|)
expr_stmt|;
comment|/* send the IOP's interface name, and a terminating null */
if|if
condition|(
name|get_error_response
argument_list|(
name|u
operator|->
name|fd
argument_list|,
name|errbuf
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|u
operator|->
name|fd
return|;
comment|/* and return that open descriptor */
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|/* if the interface wasn't found, return an error */
block|}
end_function

begin_function
specifier|static
name|void
name|acn_start_monitor
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|promiscuous
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|unit_t
modifier|*
name|u
decl_stmt|;
comment|//printf("acn_start_monitor()\n");				// fulko
name|find_unit_by_fd
argument_list|(
name|fd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|first_time
operator|==
literal|0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'M'
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|buf
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|snaplen
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|timeout
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|promiscuous
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
name|direction
expr_stmt|;
comment|//printf("acn_start_monitor() first time\n");				// fulko
name|send_to_fd
argument_list|(
name|fd
argument_list|,
literal|8
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* send the start monitor command with its parameters to the IOP */
name|u
operator|->
name|first_time
operator|=
literal|1
expr_stmt|;
block|}
comment|//printf("acn_start_monitor() complete\n");				// fulko
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_inject_acn
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
name|_U_
parameter_list|,
name|size_t
name|size
name|_U_
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"Sending packets isn't supported on ACN adapters"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setfilter_acn
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|bpf
parameter_list|)
block|{
name|int
name|fd
init|=
name|handle
operator|->
name|fd
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|p
decl_stmt|;
name|uint16_t
name|shortInt
decl_stmt|;
name|uint32_t
name|longInt
decl_stmt|;
name|send_to_fd
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"F"
argument_list|)
expr_stmt|;
comment|/* BPF filter follows command */
name|count
operator|=
name|bpf
operator|->
name|bf_len
expr_stmt|;
name|longInt
operator|=
name|htonl
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|send_to_fd
argument_list|(
name|fd
argument_list|,
literal|4
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|longInt
argument_list|)
expr_stmt|;
comment|/* send the instruction sequence count */
name|p
operator|=
name|bpf
operator|->
name|bf_insns
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
comment|/* followed by the list of instructions */
name|shortInt
operator|=
name|htons
argument_list|(
name|p
operator|->
name|code
argument_list|)
expr_stmt|;
name|longInt
operator|=
name|htonl
argument_list|(
name|p
operator|->
name|k
argument_list|)
expr_stmt|;
name|send_to_fd
argument_list|(
name|fd
argument_list|,
literal|2
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|shortInt
argument_list|)
expr_stmt|;
name|send_to_fd
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|p
operator|->
name|jt
argument_list|)
expr_stmt|;
name|send_to_fd
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|p
operator|->
name|jf
argument_list|)
expr_stmt|;
name|send_to_fd
argument_list|(
name|fd
argument_list|,
literal|4
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|longInt
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|get_error_response
argument_list|(
name|fd
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setdirection_acn
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|pcap_direction_t
name|d
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"Setting direction is not supported on ACN adapters"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acn_read_n_bytes_with_timeout
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|fd
decl_stmt|;
name|fd_set
name|r_fds
decl_stmt|;
name|fd_set
name|w_fds
decl_stmt|;
name|u_char
modifier|*
name|bp
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
name|handle
operator|->
name|fd
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|r_fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|r_fds
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|w_fds
argument_list|,
operator|&
name|r_fds
argument_list|,
sizeof|sizeof
argument_list|(
name|r_fds
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|handle
operator|->
name|bp
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|retval
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|w_fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* an error occured !!!!! */
comment|//			fprintf(stderr, "error during packet data read\n");
return|return
operator|-
literal|1
return|;
comment|/* but we need to return a good indication to prevent unneccessary popups */
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
comment|/* timeout occured, so process what we've got sofar and return */
comment|//			fprintf(stderr, "timeout during packet data read\n");
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|recv
argument_list|(
name|fd
argument_list|,
operator|(
name|bp
operator|+
name|offset
operator|)
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|//				fprintf(stderr, "premature exit during packet data rx\n");
return|return
operator|-
literal|1
return|;
block|}
name|count
operator|-=
name|len
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_read_acn
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
define|#
directive|define
name|HEADER_SIZE
value|(4 * 4)
name|unsigned
name|char
name|packet_header
index|[
name|HEADER_SIZE
index|]
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
comment|//printf("pcap_read_acn()\n");			// fulko
name|acn_start_monitor
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|handle
operator|->
name|snapshot
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|timeout
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|promisc
argument_list|,
name|handle
operator|->
name|direction
argument_list|)
expr_stmt|;
comment|/* maybe tell him to start monitoring */
comment|//printf("pcap_read_acn() after start monitor\n");			// fulko
name|handle
operator|->
name|bp
operator|=
name|packet_header
expr_stmt|;
if|if
condition|(
name|acn_read_n_bytes_with_timeout
argument_list|(
name|handle
argument_list|,
name|HEADER_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* try to read a packet header in so we can get the sizeof the packet data */
name|pcap_header
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|packet_header
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* tv_sec */
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|packet_header
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* tv_usec */
name|pcap_header
operator|.
name|caplen
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|packet_header
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
comment|/* caplen */
name|pcap_header
operator|.
name|len
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|packet_header
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
comment|/* len */
name|handle
operator|->
name|bp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|handle
operator|->
name|buffer
operator|+
name|handle
operator|->
name|offset
expr_stmt|;
comment|/* start off the receive pointer at the right spot */
if|if
condition|(
name|acn_read_n_bytes_with_timeout
argument_list|(
name|handle
argument_list|,
name|pcap_header
operator|.
name|caplen
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* then try to read in the rest of the data */
name|callback
argument_list|(
name|user
argument_list|,
operator|&
name|pcap_header
argument_list|,
name|handle
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* call the user supplied callback function */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_activate_sita
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 		 * No monitor mode on SITA devices (they're not Wi-Fi 		 * devices). 		 */
return|return
name|PCAP_ERROR_RFMON_NOTSUP
return|;
block|}
comment|/* Initialize some components of the pcap structure. */
name|handle
operator|->
name|inject_op
operator|=
name|pcap_inject_acn
expr_stmt|;
name|handle
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_acn
expr_stmt|;
name|handle
operator|->
name|setdirection_op
operator|=
name|pcap_setdirection_acn
expr_stmt|;
name|handle
operator|->
name|set_datalink_op
operator|=
name|NULL
expr_stmt|;
comment|/* can't change data link type */
name|handle
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|handle
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_fd
expr_stmt|;
name|handle
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_acn
expr_stmt|;
name|handle
operator|->
name|read_op
operator|=
name|pcap_read_acn
expr_stmt|;
name|handle
operator|->
name|stats_op
operator|=
name|pcap_stats_acn
expr_stmt|;
name|fd
operator|=
name|acn_open_live
argument_list|(
name|handle
operator|->
name|opt
operator|.
name|device
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|,
operator|&
name|handle
operator|->
name|linktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
name|PCAP_ERROR
return|;
name|handle
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|handle
operator|->
name|bufsize
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
comment|/* Allocate the buffer */
name|handle
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|handle
operator|->
name|bufsize
operator|+
name|handle
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
operator|->
name|buffer
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|pcap_cleanup_acn
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
comment|/* 	 * "handle->fd" is a socket, so "select()" and "poll()" 	 * should work on it. 	 */
name|handle
operator|->
name|selectable_fd
operator|=
name|handle
operator|->
name|fd
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|device
name|_U_
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|->
name|activate_op
operator|=
name|pcap_activate_sita
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|//printf("pcap_findalldevs()\n");				// fulko
operator|*
name|alldevsp
operator|=
literal|0
expr_stmt|;
comment|/* initialize the returned variables before we do anything */
name|strcpy
argument_list|(
name|errbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|acn_parse_hosts_file
argument_list|(
name|errbuf
argument_list|)
condition|)
comment|/* scan the hosts file for potential IOPs */
block|{
comment|//printf("pcap_findalldevs() returning BAD after parsehosts\n");				// fulko
return|return
operator|-
literal|1
return|;
block|}
comment|//printf("pcap_findalldevs() got hostlist now finding devs\n");				// fulko
if|if
condition|(
name|acn_findalldevs
argument_list|(
name|errbuf
argument_list|)
condition|)
comment|/* then ask the IOPs for their monitorable devices */
block|{
comment|//printf("pcap_findalldevs() returning BAD after findalldevs\n");				// fulko
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|alldevsp
operator|=
name|acn_if_list
expr_stmt|;
name|acn_if_list
operator|=
literal|0
expr_stmt|;
comment|/* then forget our list head, because someone will call pcap_freealldevs() to empty the malloc'ed stuff */
comment|//printf("pcap_findalldevs() returning ZERO OK\n");				// fulko
return|return
literal|0
return|;
block|}
end_function

end_unit

