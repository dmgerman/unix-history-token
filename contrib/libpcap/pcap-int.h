begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the Computer Systems  *	Engineering Group at Lawrence Berkeley Laboratory.  * 4. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#) $Header: /tcpdump/master/libpcap/pcap-int.h,v 1.94 2008-09-16 00:20:23 guy Exp $ (LBL)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|pcap_int_h
end_ifndef

begin_define
define|#
directive|define
name|pcap_int_h
end_define

begin_include
include|#
directive|include
file|<pcap/pcap.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LIBDLPI
include|#
directive|include
file|<libdlpi.h>
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
include|#
directive|include
file|<Packet32.h>
specifier|extern
name|CRITICAL_SECTION
name|g_PcapCompileCriticalSection
decl_stmt|;
endif|#
directive|endif
comment|/* WIN32 */
ifdef|#
directive|ifdef
name|MSDOS
include|#
directive|include
file|<fcntl.h>
include|#
directive|include
file|<io.h>
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SNF_API
include|#
directive|include
file|<snf.h>
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|_MSC_VER
operator|<=
literal|1200
operator|)
operator|)
comment|/* we are compiling with Visual Studio 6, that doesn't support the LL suffix*/
comment|/*  * Swap byte ordering of unsigned long long timestamp on a big endian  * machine.  */
define|#
directive|define
name|SWAPLL
parameter_list|(
name|ull
parameter_list|)
value|((ull& 0xff00000000000000)>> 56) | \                       ((ull& 0x00ff000000000000)>> 40) | \                       ((ull& 0x0000ff0000000000)>> 24) | \                       ((ull& 0x000000ff00000000)>> 8)  | \                       ((ull& 0x00000000ff000000)<< 8)  | \                       ((ull& 0x0000000000ff0000)<< 24) | \                       ((ull& 0x000000000000ff00)<< 40) | \                       ((ull& 0x00000000000000ff)<< 56)
else|#
directive|else
comment|/* A recent Visual studio compiler or not VC */
comment|/*  * Swap byte ordering of unsigned long long timestamp on a big endian  * machine.  */
define|#
directive|define
name|SWAPLL
parameter_list|(
name|ull
parameter_list|)
value|((ull& 0xff00000000000000LL)>> 56) | \                       ((ull& 0x00ff000000000000LL)>> 40) | \                       ((ull& 0x0000ff0000000000LL)>> 24) | \                       ((ull& 0x000000ff00000000LL)>> 8)  | \                       ((ull& 0x00000000ff000000LL)<< 8)  | \                       ((ull& 0x0000000000ff0000LL)<< 24) | \                       ((ull& 0x000000000000ff00LL)<< 40) | \                       ((ull& 0x00000000000000ffLL)<< 56)
endif|#
directive|endif
comment|/* _MSC_VER */
comment|/*  * Savefile  */
typedef|typedef
enum|enum
block|{
name|NOT_SWAPPED
block|,
name|SWAPPED
block|,
name|MAYBE_SWAPPED
block|}
name|swapped_type_t
typedef|;
comment|/*  * Used when reading a savefile.  */
struct|struct
name|pcap_sf
block|{
name|FILE
modifier|*
name|rfile
decl_stmt|;
name|int
function_decl|(
modifier|*
name|next_packet_op
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
parameter_list|,
name|u_char
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|int
name|swapped
decl_stmt|;
name|size_t
name|hdrsize
decl_stmt|;
name|swapped_type_t
name|lengths_swapped
decl_stmt|;
name|int
name|version_major
decl_stmt|;
name|int
name|version_minor
decl_stmt|;
name|bpf_u_int32
name|ifcount
decl_stmt|;
comment|/* number of interfaces seen in this capture */
name|u_int
name|tsresol
decl_stmt|;
comment|/* time stamp resolution */
name|u_int
name|tsscale
decl_stmt|;
comment|/* scaling factor for resolution -> microseconds */
name|u_int64_t
name|tsoffset
decl_stmt|;
comment|/* time stamp offset */
block|}
struct|;
comment|/*  * Used when doing a live capture.  */
struct|struct
name|pcap_md
block|{
name|struct
name|pcap_stat
name|stat
decl_stmt|;
comment|/*XXX*/
name|int
name|use_bpf
decl_stmt|;
comment|/* using kernel filter */
name|u_long
name|TotPkts
decl_stmt|;
comment|/* can't oflow for 79 hrs on ether */
name|u_long
name|TotAccepted
decl_stmt|;
comment|/* count accepted by filter */
name|u_long
name|TotDrops
decl_stmt|;
comment|/* count of dropped packets */
name|long
name|TotMissed
decl_stmt|;
comment|/* missed by i/f during this run */
name|long
name|OrigMissed
decl_stmt|;
comment|/* missed by i/f before this run */
name|char
modifier|*
name|device
decl_stmt|;
comment|/* device name */
name|int
name|timeout
decl_stmt|;
comment|/* timeout for buffering */
name|int
name|must_do_on_close
decl_stmt|;
comment|/* stuff we must do when we close */
name|struct
name|pcap
modifier|*
name|next
decl_stmt|;
comment|/* list of open pcaps that need stuff cleared on close */
ifdef|#
directive|ifdef
name|linux
name|int
name|sock_packet
decl_stmt|;
comment|/* using Linux 2.0 compatible interface */
name|int
name|cooked
decl_stmt|;
comment|/* using SOCK_DGRAM rather than SOCK_RAW */
name|int
name|ifindex
decl_stmt|;
comment|/* interface index of device we're bound to */
name|int
name|lo_ifindex
decl_stmt|;
comment|/* interface index of the loopback device */
name|u_int
name|packets_read
decl_stmt|;
comment|/* count of packets read with recvfrom() */
name|bpf_u_int32
name|oldmode
decl_stmt|;
comment|/* mode to restore when turning monitor mode off */
name|char
modifier|*
name|mondevice
decl_stmt|;
comment|/* mac80211 monitor device we created */
name|u_char
modifier|*
name|mmapbuf
decl_stmt|;
comment|/* memory-mapped region pointer */
name|size_t
name|mmapbuflen
decl_stmt|;
comment|/* size of region */
name|int
name|vlan_offset
decl_stmt|;
comment|/* offset at which to insert vlan tags; if -1, don't insert */
name|u_int
name|tp_version
decl_stmt|;
comment|/* version of tpacket_hdr for mmaped ring */
name|u_int
name|tp_hdrlen
decl_stmt|;
comment|/* hdrlen of tpacket_hdr for mmaped ring */
name|u_char
modifier|*
name|oneshot_buffer
decl_stmt|;
comment|/* buffer for copy of packet */
name|long
name|proc_dropped
decl_stmt|;
comment|/* packets reported dropped by /proc/net/dev */
endif|#
directive|endif
comment|/* linux */
ifdef|#
directive|ifdef
name|HAVE_DAG_API
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
name|u_char
modifier|*
name|dag_mem_bottom
decl_stmt|;
comment|/* DAG card current memory bottom pointer */
name|u_char
modifier|*
name|dag_mem_top
decl_stmt|;
comment|/* DAG card current memory top pointer */
else|#
directive|else
comment|/* HAVE_DAG_STREAMS_API */
name|void
modifier|*
name|dag_mem_base
decl_stmt|;
comment|/* DAG card memory base address */
name|u_int
name|dag_mem_bottom
decl_stmt|;
comment|/* DAG card current memory bottom offset */
name|u_int
name|dag_mem_top
decl_stmt|;
comment|/* DAG card current memory top offset */
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
name|int
name|dag_fcs_bits
decl_stmt|;
comment|/* Number of checksum bits from link layer */
name|int
name|dag_offset_flags
decl_stmt|;
comment|/* Flags to pass to dag_offset(). */
name|int
name|dag_stream
decl_stmt|;
comment|/* DAG stream number */
name|int
name|dag_timeout
decl_stmt|;
comment|/* timeout specified to pcap_open_live. 				 * Same as in linux above, introduce 				 * generally? */
endif|#
directive|endif
comment|/* HAVE_DAG_API */
ifdef|#
directive|ifdef
name|HAVE_SNF_API
name|snf_handle_t
name|snf_handle
decl_stmt|;
comment|/* opaque device handle */
name|snf_ring_t
name|snf_ring
decl_stmt|;
comment|/* opaque device ring handle */
name|int
name|snf_timeout
decl_stmt|;
name|int
name|snf_boardnum
decl_stmt|;
endif|#
directive|endif
comment|/*HAVE_SNF_API*/
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
comment|/*         * Zero-copy read buffer -- for zero-copy BPF.  'buffer' above will         * alternative between these two actual mmap'd buffers as required.         * As there is a header on the front size of the mmap'd buffer, only         * some of the buffer is exposed to libpcap as a whole via bufsize;         * zbufsize is the true size.  zbuffer tracks the current zbuf         * assocated with buffer so that it can be used to decide which the         * next buffer to read will be.         */
name|u_char
modifier|*
name|zbuf1
decl_stmt|,
modifier|*
name|zbuf2
decl_stmt|,
modifier|*
name|zbuffer
decl_stmt|;
name|u_int
name|zbufsize
decl_stmt|;
name|u_int
name|zerocopy
decl_stmt|;
name|u_int
name|interrupted
decl_stmt|;
name|struct
name|timespec
name|firstsel
decl_stmt|;
comment|/*         * If there's currently a buffer being actively processed, then it is         * referenced here; 'buffer' is also pointed at it, but offset by the         * size of the header.         */
name|struct
name|bpf_zbuf_header
modifier|*
name|bzh
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_ZEROCOPY_BPF */
block|}
struct|;
comment|/*  * Stuff to do when we close.  */
define|#
directive|define
name|MUST_CLEAR_PROMISC
value|0x00000001
comment|/* clear promiscuous mode */
define|#
directive|define
name|MUST_CLEAR_RFMON
value|0x00000002
comment|/* clear rfmon (monitor) mode */
define|#
directive|define
name|MUST_DELETE_MONIF
value|0x00000004
comment|/* delete monitor-mode interface */
struct|struct
name|pcap_opt
block|{
name|int
name|buffer_size
decl_stmt|;
name|char
modifier|*
name|source
decl_stmt|;
name|int
name|promisc
decl_stmt|;
name|int
name|rfmon
decl_stmt|;
name|int
name|tstamp_type
decl_stmt|;
block|}
struct|;
comment|/*  * Ultrix, DEC OSF/1^H^H^H^H^H^H^H^H^HDigital UNIX^H^H^H^H^H^H^H^H^H^H^H^H  * Tru64 UNIX, and some versions of NetBSD pad FDDI packets to make everything  * line up on a nice boundary.  */
ifdef|#
directive|ifdef
name|__NetBSD__
include|#
directive|include
file|<sys/param.h>
comment|/* needed to declare __NetBSD_Version__ */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ultrix
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
name|__NetBSD_Version__
operator|>
literal|106000000
operator|)
define|#
directive|define
name|PCAP_FDDIPAD
value|3
endif|#
directive|endif
typedef|typedef
name|int
function_decl|(
modifier|*
name|activate_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|can_set_rfmon_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|read_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|inject_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setfilter_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setdirection_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|pcap_direction_t
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|set_datalink_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|getnonblock_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setnonblock_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|stats_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|pcap_stat
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|WIN32
typedef|typedef
name|int
function_decl|(
modifier|*
name|setbuff_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setmode_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setmintocopy_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
endif|#
directive|endif
typedef|typedef
name|void
function_decl|(
modifier|*
name|cleanup_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
struct|struct
name|pcap
block|{
ifdef|#
directive|ifdef
name|WIN32
name|ADAPTER
modifier|*
name|adapter
decl_stmt|;
name|LPPACKET
name|Packet
decl_stmt|;
name|int
name|nonblock
decl_stmt|;
else|#
directive|else
name|int
name|fd
decl_stmt|;
name|int
name|selectable_fd
decl_stmt|;
name|int
name|send_fd
decl_stmt|;
endif|#
directive|endif
comment|/* WIN32 */
ifdef|#
directive|ifdef
name|HAVE_LIBDLPI
name|dlpi_handle_t
name|dlpi_hd
decl_stmt|;
endif|#
directive|endif
name|int
name|snapshot
decl_stmt|;
name|int
name|linktype
decl_stmt|;
comment|/* Network linktype */
name|int
name|linktype_ext
decl_stmt|;
comment|/* Extended information stored in the linktype field of a file */
name|int
name|tzoff
decl_stmt|;
comment|/* timezone offset */
name|int
name|offset
decl_stmt|;
comment|/* offset for proper alignment */
name|int
name|activated
decl_stmt|;
comment|/* true if the capture is really started */
name|int
name|oldstyle
decl_stmt|;
comment|/* if we're opening with pcap_open_live() */
name|int
name|break_loop
decl_stmt|;
comment|/* flag set to force break from packet-reading loop */
ifdef|#
directive|ifdef
name|PCAP_FDDIPAD
name|int
name|fddipad
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MSDOS
name|void
function_decl|(
modifier|*
name|wait_proc
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*          call proc while waiting */
endif|#
directive|endif
name|struct
name|pcap_sf
name|sf
decl_stmt|;
name|struct
name|pcap_md
name|md
decl_stmt|;
name|struct
name|pcap_opt
name|opt
decl_stmt|;
comment|/* 	 * Read buffer. 	 */
name|int
name|bufsize
decl_stmt|;
name|u_char
modifier|*
name|buffer
decl_stmt|;
name|u_char
modifier|*
name|bp
decl_stmt|;
name|int
name|cc
decl_stmt|;
comment|/* 	 * Place holder for pcap_next(). 	 */
name|u_char
modifier|*
name|pkt
decl_stmt|;
comment|/* We're accepting only packets in this direction/these directions. */
name|pcap_direction_t
name|direction
decl_stmt|;
comment|/* 	 * Methods. 	 */
name|activate_op_t
name|activate_op
decl_stmt|;
name|can_set_rfmon_op_t
name|can_set_rfmon_op
decl_stmt|;
name|read_op_t
name|read_op
decl_stmt|;
name|inject_op_t
name|inject_op
decl_stmt|;
name|setfilter_op_t
name|setfilter_op
decl_stmt|;
name|setdirection_op_t
name|setdirection_op
decl_stmt|;
name|set_datalink_op_t
name|set_datalink_op
decl_stmt|;
name|getnonblock_op_t
name|getnonblock_op
decl_stmt|;
name|setnonblock_op_t
name|setnonblock_op
decl_stmt|;
name|stats_op_t
name|stats_op
decl_stmt|;
comment|/* 	 * Routine to use as callback for pcap_next()/pcap_next_ex(). 	 */
name|pcap_handler
name|oneshot_callback
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
comment|/* 	 * These are, at least currently, specific to the Win32 NPF 	 * driver. 	 */
name|setbuff_op_t
name|setbuff_op
decl_stmt|;
name|setmode_op_t
name|setmode_op
decl_stmt|;
name|setmintocopy_op_t
name|setmintocopy_op
decl_stmt|;
endif|#
directive|endif
name|cleanup_op_t
name|cleanup_op
decl_stmt|;
comment|/* 	 * Placeholder for filter code if bpf not in kernel. 	 */
name|struct
name|bpf_program
name|fcode
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|dlt_count
decl_stmt|;
name|u_int
modifier|*
name|dlt_list
decl_stmt|;
name|int
name|tstamp_type_count
decl_stmt|;
name|u_int
modifier|*
name|tstamp_type_list
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
comment|/* This is needed for the pcap_next_ex() to work */
block|}
struct|;
comment|/*  * This is a timeval as stored in a savefile.  * It has to use the same types everywhere, independent of the actual  * `struct timeval'; `struct timeval' has 32-bit tv_sec values on some  * platforms and 64-bit tv_sec values on other platforms, and writing  * out native `struct timeval' values would mean files could only be  * read on systems with the same tv_sec size as the system on which  * the file was written.  */
struct|struct
name|pcap_timeval
block|{
name|bpf_int32
name|tv_sec
decl_stmt|;
comment|/* seconds */
name|bpf_int32
name|tv_usec
decl_stmt|;
comment|/* microseconds */
block|}
struct|;
comment|/*  * This is a `pcap_pkthdr' as actually stored in a savefile.  *  * Do not change the format of this structure, in any way (this includes  * changes that only affect the length of fields in this structure),  * and do not make the time stamp anything other than seconds and  * microseconds (e.g., seconds and nanoseconds).  Instead:  *  *	introduce a new structure for the new format;  *  *	send mail to "tcpdump-workers@lists.tcpdump.org", requesting  *	a new magic number for your new capture file format, and, when  *	you get the new magic number, put it in "savefile.c";  *  *	use that magic number for save files with the changed record  *	header;  *  *	make the code in "savefile.c" capable of reading files with  *	the old record header as well as files with the new record header  *	(using the magic number to determine the header format).  *  * Then supply the changes by forking the branch at  *  *	https://github.com/mcr/libpcap/issues  *  * and issuing a pull request, so that future versions of libpcap and  * programs that use it (such as tcpdump) will be able to read your new  * capture file format.  */
struct|struct
name|pcap_sf_pkthdr
block|{
name|struct
name|pcap_timeval
name|ts
decl_stmt|;
comment|/* time stamp */
name|bpf_u_int32
name|caplen
decl_stmt|;
comment|/* length of portion present */
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* length this packet (off wire) */
block|}
struct|;
comment|/*  * How a `pcap_pkthdr' is actually stored in savefiles written  * by some patched versions of libpcap (e.g. the ones in Red  * Hat Linux 6.1 and 6.2).  *  * Do not change the format of this structure, in any way (this includes  * changes that only affect the length of fields in this structure).  * Instead, introduce a new structure, as per the above.  */
struct|struct
name|pcap_sf_patched_pkthdr
block|{
name|struct
name|pcap_timeval
name|ts
decl_stmt|;
comment|/* time stamp */
name|bpf_u_int32
name|caplen
decl_stmt|;
comment|/* length of portion present */
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* length this packet (off wire) */
name|int
name|index
decl_stmt|;
name|unsigned
name|short
name|protocol
decl_stmt|;
name|unsigned
name|char
name|pkt_type
decl_stmt|;
block|}
struct|;
comment|/*  * User data structure for the one-shot callback used for pcap_next()  * and pcap_next_ex().  */
struct|struct
name|oneshot_userdata
block|{
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|u_char
modifier|*
modifier|*
name|pkt
decl_stmt|;
name|pcap_t
modifier|*
name|pd
decl_stmt|;
block|}
struct|;
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|min
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (b) : (a))
endif|#
directive|endif
comment|/* XXX should these be in pcap.h? */
name|int
name|pcap_offline_read
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_read
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|HAVE_STRLCPY
define|#
directive|define
name|strlcpy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
define|\
value|(strncpy((x), (y), (z)), \ 	 ((z)<= 0 ? 0 : ((x)[(z) - 1] = '\0')), \ 	 strlen((y)))
endif|#
directive|endif
include|#
directive|include
file|<stdarg.h>
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SNPRINTF
argument_list|)
define|#
directive|define
name|snprintf
value|pcap_snprintf
specifier|extern
name|int
name|snprintf
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_VSNPRINTF
argument_list|)
define|#
directive|define
name|vsnprintf
value|pcap_vsnprintf
specifier|extern
name|int
name|vsnprintf
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/*  * Routines that most pcap implementations can use for non-blocking mode.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|int
name|pcap_getnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_setnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/*  * Internal interfaces for "pcap_create()".  *  * "pcap_create_interface()" is the routine to do a pcap_create on  * a regular network interface.  There are multiple implementations  * of this, one for each platform type (Linux, BPF, DLPI, etc.),  * with the one used chosen by the configure script.  *  * "pcap_create_common()" allocates and fills in a pcap_t, for use  * by pcap_create routines.  */
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|pcap_t
modifier|*
name|pcap_create_common
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_do_addexit
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|pcap_add_to_pcaps_to_close
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|pcap_remove_from_pcaps_to_close
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|pcap_cleanup_live_common
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_not_initialized
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_check_activated
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Internal interfaces for "pcap_findalldevs()".  *  * "pcap_findalldevs_interfaces()" finds interfaces using the  * "standard" mechanisms (SIOCGIFCONF, "getifaddrs()", etc.).  *  * "pcap_platform_finddevs()" is a platform-dependent routine to  * add devices not found by the "standard" mechanisms.  *  * "pcap_add_if()" adds an interface to the list of interfaces, for  * use by various "find interfaces" routines.  */
name|int
name|pcap_findalldevs_interfaces
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|add_addr_to_iflist
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_add_if
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|struct
name|sockaddr
modifier|*
name|dup_sockaddr
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|int
name|add_or_find_if
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|WIN32
name|char
modifier|*
name|pcap_win32strerror
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
name|int
name|install_bpf_program
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_strcasecmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

