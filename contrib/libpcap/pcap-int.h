begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the Computer Systems  *	Engineering Group at Lawrence Berkeley Laboratory.  * 4. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|pcap_int_h
end_ifndef

begin_define
define|#
directive|define
name|pcap_int_h
end_define

begin_include
include|#
directive|include
file|<pcap/pcap.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
comment|/*    * Make sure Packet32.h doesn't define BPF structures that we've    * probably already defined as a result of including<pcap/pcap.h>.    */
define|#
directive|define
name|BPF_MAJOR_VERSION
include|#
directive|include
file|<Packet32.h>
elif|#
directive|elif
name|defined
argument_list|(
name|MSDOS
argument_list|)
include|#
directive|include
file|<fcntl.h>
include|#
directive|include
file|<io.h>
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|_MSC_VER
operator|<=
literal|1200
operator|)
operator|)
comment|/* we are compiling with Visual Studio 6, that doesn't support the LL suffix*/
comment|/*  * Swap byte ordering of unsigned long long timestamp on a big endian  * machine.  */
define|#
directive|define
name|SWAPLL
parameter_list|(
name|ull
parameter_list|)
value|((ull& 0xff00000000000000)>> 56) | \                       ((ull& 0x00ff000000000000)>> 40) | \                       ((ull& 0x0000ff0000000000)>> 24) | \                       ((ull& 0x000000ff00000000)>> 8)  | \                       ((ull& 0x00000000ff000000)<< 8)  | \                       ((ull& 0x0000000000ff0000)<< 24) | \                       ((ull& 0x000000000000ff00)<< 40) | \                       ((ull& 0x00000000000000ff)<< 56)
else|#
directive|else
comment|/* A recent Visual studio compiler or not VC */
comment|/*  * Swap byte ordering of unsigned long long timestamp on a big endian  * machine.  */
define|#
directive|define
name|SWAPLL
parameter_list|(
name|ull
parameter_list|)
value|((ull& 0xff00000000000000LL)>> 56) | \                       ((ull& 0x00ff000000000000LL)>> 40) | \                       ((ull& 0x0000ff0000000000LL)>> 24) | \                       ((ull& 0x000000ff00000000LL)>> 8)  | \                       ((ull& 0x00000000ff000000LL)<< 8)  | \                       ((ull& 0x0000000000ff0000LL)<< 24) | \                       ((ull& 0x000000000000ff00LL)<< 40) | \                       ((ull& 0x00000000000000ffLL)<< 56)
endif|#
directive|endif
comment|/* _MSC_VER */
comment|/*  * Maximum snapshot length.  *  * Somewhat arbitrary, but chosen to be:  *  *    1) big enough for maximum-size Linux loopback packets (65549)  *       and some USB packets captured with USBPcap:  *  *           http://desowin.org/usbpcap/  *  *       (> 131072,< 262144)  *  * and  *  *    2) small enough not to cause attempts to allocate huge amounts of  *       memory; some applications might use the snapshot length in a  *       savefile header to control the size of the buffer they allocate,  *       so a size of, say, 2^31-1 might not work well.  *  * We don't enforce this in pcap_set_snaplen(), but we use it internally.  */
define|#
directive|define
name|MAXIMUM_SNAPLEN
value|262144
struct|struct
name|pcap_opt
block|{
name|char
modifier|*
name|device
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* timeout for buffering */
name|u_int
name|buffer_size
decl_stmt|;
name|int
name|promisc
decl_stmt|;
name|int
name|rfmon
decl_stmt|;
comment|/* monitor mode */
name|int
name|immediate
decl_stmt|;
comment|/* immediate mode - deliver packets as soon as they arrive */
name|int
name|tstamp_type
decl_stmt|;
name|int
name|tstamp_precision
decl_stmt|;
block|}
struct|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|activate_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|can_set_rfmon_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|read_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|inject_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setfilter_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setdirection_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|pcap_direction_t
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|set_datalink_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|getnonblock_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setnonblock_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|stats_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|pcap_stat
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|_WIN32
typedef|typedef
name|struct
name|pcap_stat
modifier|*
function_decl|(
modifier|*
name|stats_ex_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setbuff_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setmode_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setmintocopy_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|HANDLE
function_decl|(
modifier|*
name|getevent_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|oid_get_request_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|bpf_u_int32
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|oid_set_request_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|bpf_u_int32
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|u_int
function_decl|(
modifier|*
name|sendqueue_transmit_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|pcap_send_queue
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|setuserbuffer_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|live_dump_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|live_dump_ended_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|PAirpcapHandle
function_decl|(
modifier|*
name|get_airpcap_handle_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
typedef|typedef
name|void
function_decl|(
modifier|*
name|cleanup_op_t
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * We put all the stuff used in the read code path at the beginning,  * to try to keep it together in the same cache line or lines.  */
struct|struct
name|pcap
block|{
comment|/* 	 * Method to call to read packets on a live capture. 	 */
name|read_op_t
name|read_op
decl_stmt|;
comment|/* 	 * Method to call to read packets from a savefile. 	 */
name|int
function_decl|(
modifier|*
name|next_packet_op
function_decl|)
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
parameter_list|,
name|u_char
modifier|*
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|_WIN32
name|ADAPTER
modifier|*
name|adapter
decl_stmt|;
else|#
directive|else
name|int
name|fd
decl_stmt|;
name|int
name|selectable_fd
decl_stmt|;
endif|#
directive|endif
comment|/* _WIN32 */
comment|/* 	 * Read buffer. 	 */
name|u_int
name|bufsize
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|u_char
modifier|*
name|bp
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|int
name|break_loop
decl_stmt|;
comment|/* flag set to force break from packet-reading loop */
name|void
modifier|*
name|priv
decl_stmt|;
comment|/* private data for methods */
name|int
name|swapped
decl_stmt|;
name|FILE
modifier|*
name|rfile
decl_stmt|;
comment|/* null if live capture, non-null if savefile */
name|u_int
name|fddipad
decl_stmt|;
name|struct
name|pcap
modifier|*
name|next
decl_stmt|;
comment|/* list of open pcaps that need stuff cleared on close */
comment|/* 	 * File version number; meaningful only for a savefile, but we 	 * keep it here so that apps that (mistakenly) ask for the 	 * version numbers will get the same zero values that they 	 * always did. 	 */
name|int
name|version_major
decl_stmt|;
name|int
name|version_minor
decl_stmt|;
name|int
name|snapshot
decl_stmt|;
name|int
name|linktype
decl_stmt|;
comment|/* Network linktype */
name|int
name|linktype_ext
decl_stmt|;
comment|/* Extended information stored in the linktype field of a file */
name|int
name|tzoff
decl_stmt|;
comment|/* timezone offset */
name|int
name|offset
decl_stmt|;
comment|/* offset for proper alignment */
name|int
name|activated
decl_stmt|;
comment|/* true if the capture is really started */
name|int
name|oldstyle
decl_stmt|;
comment|/* if we're opening with pcap_open_live() */
name|struct
name|pcap_opt
name|opt
decl_stmt|;
comment|/* 	 * Place holder for pcap_next(). 	 */
name|u_char
modifier|*
name|pkt
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|struct
name|pcap_stat
name|stat
decl_stmt|;
comment|/* used for pcap_stats_ex() */
endif|#
directive|endif
comment|/* We're accepting only packets in this direction/these directions. */
name|pcap_direction_t
name|direction
decl_stmt|;
comment|/* 	 * Flags to affect BPF code generation. 	 */
name|int
name|bpf_codegen_flags
decl_stmt|;
comment|/* 	 * Placeholder for filter code if bpf not in kernel. 	 */
name|struct
name|bpf_program
name|fcode
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|dlt_count
decl_stmt|;
name|u_int
modifier|*
name|dlt_list
decl_stmt|;
name|int
name|tstamp_type_count
decl_stmt|;
name|u_int
modifier|*
name|tstamp_type_list
decl_stmt|;
name|int
name|tstamp_precision_count
decl_stmt|;
name|u_int
modifier|*
name|tstamp_precision_list
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
comment|/* This is needed for the pcap_next_ex() to work */
comment|/* 	 * More methods. 	 */
name|activate_op_t
name|activate_op
decl_stmt|;
name|can_set_rfmon_op_t
name|can_set_rfmon_op
decl_stmt|;
name|inject_op_t
name|inject_op
decl_stmt|;
name|setfilter_op_t
name|setfilter_op
decl_stmt|;
name|setdirection_op_t
name|setdirection_op
decl_stmt|;
name|set_datalink_op_t
name|set_datalink_op
decl_stmt|;
name|getnonblock_op_t
name|getnonblock_op
decl_stmt|;
name|setnonblock_op_t
name|setnonblock_op
decl_stmt|;
name|stats_op_t
name|stats_op
decl_stmt|;
comment|/* 	 * Routine to use as callback for pcap_next()/pcap_next_ex(). 	 */
name|pcap_handler
name|oneshot_callback
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
comment|/* 	 * These are, at least currently, specific to the Win32 NPF 	 * driver. 	 */
name|stats_ex_op_t
name|stats_ex_op
decl_stmt|;
name|setbuff_op_t
name|setbuff_op
decl_stmt|;
name|setmode_op_t
name|setmode_op
decl_stmt|;
name|setmintocopy_op_t
name|setmintocopy_op
decl_stmt|;
name|getevent_op_t
name|getevent_op
decl_stmt|;
name|oid_get_request_op_t
name|oid_get_request_op
decl_stmt|;
name|oid_set_request_op_t
name|oid_set_request_op
decl_stmt|;
name|sendqueue_transmit_op_t
name|sendqueue_transmit_op
decl_stmt|;
name|setuserbuffer_op_t
name|setuserbuffer_op
decl_stmt|;
name|live_dump_op_t
name|live_dump_op
decl_stmt|;
name|live_dump_ended_op_t
name|live_dump_ended_op
decl_stmt|;
name|get_airpcap_handle_op_t
name|get_airpcap_handle_op
decl_stmt|;
endif|#
directive|endif
name|cleanup_op_t
name|cleanup_op
decl_stmt|;
block|}
struct|;
comment|/*  * BPF code generation flags.  */
define|#
directive|define
name|BPF_SPECIAL_VLAN_HANDLING
value|0x00000001
comment|/* special VLAN handling for Linux */
comment|/*  * This is a timeval as stored in a savefile.  * It has to use the same types everywhere, independent of the actual  * `struct timeval'; `struct timeval' has 32-bit tv_sec values on some  * platforms and 64-bit tv_sec values on other platforms, and writing  * out native `struct timeval' values would mean files could only be  * read on systems with the same tv_sec size as the system on which  * the file was written.  */
struct|struct
name|pcap_timeval
block|{
name|bpf_int32
name|tv_sec
decl_stmt|;
comment|/* seconds */
name|bpf_int32
name|tv_usec
decl_stmt|;
comment|/* microseconds */
block|}
struct|;
comment|/*  * This is a `pcap_pkthdr' as actually stored in a savefile.  *  * Do not change the format of this structure, in any way (this includes  * changes that only affect the length of fields in this structure),  * and do not make the time stamp anything other than seconds and  * microseconds (e.g., seconds and nanoseconds).  Instead:  *  *	introduce a new structure for the new format;  *  *	send mail to "tcpdump-workers@lists.tcpdump.org", requesting  *	a new magic number for your new capture file format, and, when  *	you get the new magic number, put it in "savefile.c";  *  *	use that magic number for save files with the changed record  *	header;  *  *	make the code in "savefile.c" capable of reading files with  *	the old record header as well as files with the new record header  *	(using the magic number to determine the header format).  *  * Then supply the changes by forking the branch at  *  *	https://github.com/the-tcpdump-group/libpcap/issues  *  * and issuing a pull request, so that future versions of libpcap and  * programs that use it (such as tcpdump) will be able to read your new  * capture file format.  */
struct|struct
name|pcap_sf_pkthdr
block|{
name|struct
name|pcap_timeval
name|ts
decl_stmt|;
comment|/* time stamp */
name|bpf_u_int32
name|caplen
decl_stmt|;
comment|/* length of portion present */
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* length this packet (off wire) */
block|}
struct|;
comment|/*  * How a `pcap_pkthdr' is actually stored in savefiles written  * by some patched versions of libpcap (e.g. the ones in Red  * Hat Linux 6.1 and 6.2).  *  * Do not change the format of this structure, in any way (this includes  * changes that only affect the length of fields in this structure).  * Instead, introduce a new structure, as per the above.  */
struct|struct
name|pcap_sf_patched_pkthdr
block|{
name|struct
name|pcap_timeval
name|ts
decl_stmt|;
comment|/* time stamp */
name|bpf_u_int32
name|caplen
decl_stmt|;
comment|/* length of portion present */
name|bpf_u_int32
name|len
decl_stmt|;
comment|/* length this packet (off wire) */
name|int
name|index
decl_stmt|;
name|unsigned
name|short
name|protocol
decl_stmt|;
name|unsigned
name|char
name|pkt_type
decl_stmt|;
block|}
struct|;
comment|/*  * User data structure for the one-shot callback used for pcap_next()  * and pcap_next_ex().  */
struct|struct
name|oneshot_userdata
block|{
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|u_char
modifier|*
modifier|*
name|pkt
decl_stmt|;
name|pcap_t
modifier|*
name|pd
decl_stmt|;
block|}
struct|;
ifndef|#
directive|ifndef
name|min
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (b) : (a))
endif|#
directive|endif
name|int
name|pcap_offline_read
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
include|#
directive|include
file|<stdarg.h>
include|#
directive|include
file|"portability.h"
comment|/*  * Does the packet count argument to a module's read routine say  * "supply packets until you run out of packets"?  */
define|#
directive|define
name|PACKET_COUNT_IS_UNLIMITED
parameter_list|(
name|count
parameter_list|)
value|((count)<= 0)
comment|/*  * Routines that most pcap implementations can use for non-blocking mode.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|int
name|pcap_getnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_setnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/*  * Internal interfaces for "pcap_create()".  *  * "pcap_create_interface()" is the routine to do a pcap_create on  * a regular network interface.  There are multiple implementations  * of this, one for each platform type (Linux, BPF, DLPI, etc.),  * with the one used chosen by the configure script.  *  * "pcap_create_common()" allocates and fills in a pcap_t, for use  * by pcap_create routines.  */
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|pcap_t
modifier|*
name|pcap_create_common
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|int
name|pcap_do_addexit
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|pcap_add_to_pcaps_to_close
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|pcap_remove_from_pcaps_to_close
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|pcap_cleanup_live_common
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_check_activated
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Internal interfaces for "pcap_findalldevs()".  *  * "pcap_platform_finddevs()" is a platform-dependent routine to  * find local network interfaces.  *  * "pcap_findalldevs_interfaces()" is a helper to find those interfaces  * using the "standard" mechanisms (SIOCGIFCONF, "getifaddrs()", etc.).  *  * "pcap_add_if()" adds an interface to the list of interfaces, for  * use by various "find interfaces" routines.  */
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|int
name|pcap_findalldevs_interfaces
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
endif|#
directive|endif
name|int
name|add_addr_to_iflist
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bpf_u_int32
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|add_addr_to_dev
parameter_list|(
name|pcap_if_t
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dstaddr
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
function_decl|;
name|int
name|pcap_add_if
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bpf_u_int32
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|add_or_find_if
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bpf_u_int32
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|_WIN32
name|bpf_u_int32
name|if_flags_to_pcap_flags
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/*  * Internal interfaces for "pcap_open_offline()".  *  * "pcap_open_offline_common()" allocates and fills in a pcap_t, for use  * by pcap_open_offline routines.  *  * "sf_cleanup()" closes the file handle associated with a pcap_t, if  * appropriate, and frees all data common to all modules for handling  * savefile types.  */
name|pcap_t
modifier|*
name|pcap_open_offline_common
parameter_list|(
name|char
modifier|*
name|ebuf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|sf_cleanup
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
comment|/*  * Internal interfaces for both "pcap_create()" and routines that  * open savefiles.  *  * "pcap_oneshot()" is the standard one-shot callback for "pcap_next()"  * and "pcap_next_ex()".  */
name|void
name|pcap_oneshot
parameter_list|(
name|u_char
modifier|*
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
parameter_list|,
specifier|const
name|u_char
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|_WIN32
name|void
name|pcap_win32_err_to_str
parameter_list|(
name|DWORD
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
name|int
name|install_bpf_program
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|)
function_decl|;
name|int
name|pcap_strcasecmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

