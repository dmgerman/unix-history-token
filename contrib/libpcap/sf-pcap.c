begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * sf-pcap.c - libpcap-file-format-specific code from savefile.c  *	Extraction/creation by Jeffrey Mogul, DECWRL  *	Modified by Steve McCanne, LBL.  *  * Used to save the received packet headers, after filtering, to  * a file, and then read them later.  * The first record in the file contains saved values for the machine  * dependent values so we can print the dump file on any architecture.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header$ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_include
include|#
directive|include
file|<pcap-stdinc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* WIN32 */
end_comment

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_STDINT_H
end_elif

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BITYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bitypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"pcap-common.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sf-pcap.h"
end_include

begin_comment
comment|/*  * Setting O_BINARY on DOS/Windows is a bit tricky  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_define
define|#
directive|define
name|SET_BINMODE
parameter_list|(
name|f
parameter_list|)
value|_setmode(_fileno(f), _O_BINARY)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_elif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__HIGHC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|SET_BINMODE
parameter_list|(
name|f
parameter_list|)
value|setmode(f, O_BINARY)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_BINMODE
parameter_list|(
name|f
parameter_list|)
value|setmode(fileno(f), O_BINARY)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Standard libpcap format.  */
end_comment

begin_define
define|#
directive|define
name|TCPDUMP_MAGIC
value|0xa1b2c3d4
end_define

begin_comment
comment|/*  * Alexey Kuznetzov's modified libpcap format.  */
end_comment

begin_define
define|#
directive|define
name|KUZNETZOV_TCPDUMP_MAGIC
value|0xa1b2cd34
end_define

begin_comment
comment|/*  * Reserved for Francisco Mesquita<francisco.mesquita@radiomovel.pt>  * for another modified format.  */
end_comment

begin_define
define|#
directive|define
name|FMESQUITA_TCPDUMP_MAGIC
value|0xa1b234cd
end_define

begin_comment
comment|/*  * Navtel Communcations' format, with nanosecond timestamps,  * as per a request from Dumas Hwang<dumas.hwang@navtelcom.com>.  */
end_comment

begin_define
define|#
directive|define
name|NAVTEL_TCPDUMP_MAGIC
value|0xa12b3c4d
end_define

begin_comment
comment|/*  * Normal libpcap format, except for seconds/nanoseconds timestamps,  * as per a request by Ulf Lamping<ulf.lamping@web.de>  */
end_comment

begin_define
define|#
directive|define
name|NSEC_TCPDUMP_MAGIC
value|0xa1b23c4d
end_define

begin_comment
comment|/*  * Mechanism for storing information about a capture in the upper  * 6 bits of a linktype value in a capture file.  *  * LT_LINKTYPE_EXT(x) extracts the additional information.  *  * The rest of the bits are for a value describing the link-layer  * value.  LT_LINKTYPE(x) extracts that value.  */
end_comment

begin_define
define|#
directive|define
name|LT_LINKTYPE
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x03FFFFFF)
end_define

begin_define
define|#
directive|define
name|LT_LINKTYPE_EXT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xFC000000)
end_define

begin_function_decl
specifier|static
name|int
name|pcap_next_packet
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
modifier|*
name|datap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Check whether this is a pcap savefile and, if it is, extract the  * relevant information from the header.  */
end_comment

begin_function
name|int
name|pcap_check_header
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|magic
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|pcap_file_header
name|hdr
decl_stmt|;
name|size_t
name|amt_read
decl_stmt|;
comment|/* 	 * Check whether the first 4 bytes of the file are the magic 	 * number for a pcap savefile, or for a byte-swapped pcap 	 * savefile. 	 */
if|if
condition|(
name|magic
operator|!=
name|TCPDUMP_MAGIC
operator|&&
name|magic
operator|!=
name|KUZNETZOV_TCPDUMP_MAGIC
condition|)
block|{
name|magic
operator|=
name|SWAPLONG
argument_list|(
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|TCPDUMP_MAGIC
operator|&&
name|magic
operator|!=
name|KUZNETZOV_TCPDUMP_MAGIC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nope */
name|p
operator|->
name|sf
operator|.
name|swapped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * They are.  Put the magic number in the header, and read 	 * the rest of the header. 	 */
name|hdr
operator|.
name|magic
operator|=
name|magic
expr_stmt|;
name|amt_read
operator|=
name|fread
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
operator|)
operator|+
sizeof|sizeof
name|hdr
operator|.
name|magic
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|magic
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|magic
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %lu file header bytes, only got %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If it's a byte-swapped capture file, byte-swap the header. 	 */
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
name|hdr
operator|.
name|version_major
operator|=
name|SWAPSHORT
argument_list|(
name|hdr
operator|.
name|version_major
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|version_minor
operator|=
name|SWAPSHORT
argument_list|(
name|hdr
operator|.
name|version_minor
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|thiszone
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|.
name|thiszone
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|sigfigs
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|.
name|sigfigs
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|snaplen
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|.
name|snaplen
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|linktype
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|.
name|linktype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr
operator|.
name|version_major
operator|<
name|PCAP_VERSION_MAJOR
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"archaic pcap savefile format"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|->
name|sf
operator|.
name|version_major
operator|=
name|hdr
operator|.
name|version_major
expr_stmt|;
name|p
operator|->
name|sf
operator|.
name|version_minor
operator|=
name|hdr
operator|.
name|version_minor
expr_stmt|;
name|p
operator|->
name|tzoff
operator|=
name|hdr
operator|.
name|thiszone
expr_stmt|;
name|p
operator|->
name|snapshot
operator|=
name|hdr
operator|.
name|snaplen
expr_stmt|;
name|p
operator|->
name|linktype
operator|=
name|linktype_to_dlt
argument_list|(
name|LT_LINKTYPE
argument_list|(
name|hdr
operator|.
name|linktype
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|linktype_ext
operator|=
name|LT_LINKTYPE_EXT
argument_list|(
name|hdr
operator|.
name|linktype
argument_list|)
expr_stmt|;
name|p
operator|->
name|sf
operator|.
name|next_packet_op
operator|=
name|pcap_next_packet
expr_stmt|;
comment|/* 	 * We interchanged the caplen and len fields at version 2.3, 	 * in order to match the bpf header layout.  But unfortunately 	 * some files were written with version 2.3 in their headers 	 * but without the interchanged fields. 	 * 	 * In addition, DG/UX tcpdump writes out files with a version 	 * number of 543.0, and with the caplen and len fields in the 	 * pre-2.3 order. 	 */
switch|switch
condition|(
name|hdr
operator|.
name|version_major
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|hdr
operator|.
name|version_minor
operator|<
literal|3
condition|)
name|p
operator|->
name|sf
operator|.
name|lengths_swapped
operator|=
name|SWAPPED
expr_stmt|;
elseif|else
if|if
condition|(
name|hdr
operator|.
name|version_minor
operator|==
literal|3
condition|)
name|p
operator|->
name|sf
operator|.
name|lengths_swapped
operator|=
name|MAYBE_SWAPPED
expr_stmt|;
else|else
name|p
operator|->
name|sf
operator|.
name|lengths_swapped
operator|=
name|NOT_SWAPPED
expr_stmt|;
break|break;
case|case
literal|543
case|:
name|p
operator|->
name|sf
operator|.
name|lengths_swapped
operator|=
name|SWAPPED
expr_stmt|;
break|break;
default|default:
name|p
operator|->
name|sf
operator|.
name|lengths_swapped
operator|=
name|NOT_SWAPPED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|magic
operator|==
name|KUZNETZOV_TCPDUMP_MAGIC
condition|)
block|{
comment|/* 		 * XXX - the patch that's in some versions of libpcap 		 * changes the packet header but not the magic number, 		 * and some other versions with this magic number have 		 * some extra debugging information in the packet header; 		 * we'd have to use some hacks^H^H^H^H^Hheuristics to 		 * detect those variants. 		 * 		 * Ethereal does that, but it does so by trying to read 		 * the first two packets of the file with each of the 		 * record header formats.  That currently means it seeks 		 * backwards and retries the reads, which doesn't work 		 * on pipes.  We want to be able to read from a pipe, so 		 * that strategy won't work; we'd have to buffer some 		 * data ourselves and read from that buffer in order to 		 * make that work. 		 */
name|p
operator|->
name|sf
operator|.
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_sf_patched_pkthdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|linktype
operator|==
name|DLT_EN10MB
condition|)
block|{
comment|/* 			 * This capture might have been done in raw mode 			 * or cooked mode. 			 * 			 * If it was done in cooked mode, p->snapshot was 			 * passed to recvfrom() as the buffer size, meaning 			 * that the most packet data that would be copied 			 * would be p->snapshot.  However, a faked Ethernet 			 * header would then have been added to it, so the 			 * most data that would be in a packet in the file 			 * would be p->snapshot + 14. 			 * 			 * We can't easily tell whether the capture was done 			 * in raw mode or cooked mode, so we'll assume it was 			 * cooked mode, and add 14 to the snapshot length. 			 * That means that, for a raw capture, the snapshot 			 * length will be misleading if you use it to figure 			 * out why a capture doesn't have all the packet data, 			 * but there's not much we can do to avoid that. 			 */
name|p
operator|->
name|snapshot
operator|+=
literal|14
expr_stmt|;
block|}
block|}
else|else
name|p
operator|->
name|sf
operator|.
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_sf_pkthdr
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a buffer for the packet data. 	 */
name|p
operator|->
name|bufsize
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bufsize
operator|<=
literal|0
condition|)
block|{
comment|/* 		 * Bogus snapshot length; use 64KiB as a fallback. 		 */
name|p
operator|->
name|bufsize
operator|=
literal|65536
expr_stmt|;
block|}
name|p
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read and return the next packet from the savefile.  Return the header  * in hdr and a pointer to the contents in data.  Return 0 on success, 1  * if there were no more packets, and -1 on an error.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_next_packet
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|pcap_sf_patched_pkthdr
name|sf_hdr
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|p
operator|->
name|sf
operator|.
name|rfile
decl_stmt|;
name|size_t
name|amt_read
decl_stmt|;
name|bpf_u_int32
name|t
decl_stmt|;
comment|/* 	 * Read the packet header; the structure we use as a buffer 	 * is the longer structure for files generated by the patched 	 * libpcap, but if the file has the magic number for an 	 * unpatched libpcap we only read as many bytes as the regular 	 * header has. 	 */
name|amt_read
operator|=
name|fread
argument_list|(
operator|&
name|sf_hdr
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|sf
operator|.
name|hdrsize
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
name|p
operator|->
name|sf
operator|.
name|hdrsize
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|amt_read
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %lu header bytes, only got %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|p
operator|->
name|sf
operator|.
name|hdrsize
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* EOF */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
comment|/* these were written in opposite byte order */
name|hdr
operator|->
name|caplen
operator|=
name|SWAPLONG
argument_list|(
name|sf_hdr
operator|.
name|caplen
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|SWAPLONG
argument_list|(
name|sf_hdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|SWAPLONG
argument_list|(
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
name|SWAPLONG
argument_list|(
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|caplen
operator|=
name|sf_hdr
operator|.
name|caplen
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|sf_hdr
operator|.
name|len
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_usec
expr_stmt|;
block|}
comment|/* Swap the caplen and len fields, if necessary. */
switch|switch
condition|(
name|p
operator|->
name|sf
operator|.
name|lengths_swapped
condition|)
block|{
case|case
name|NOT_SWAPPED
case|:
break|break;
case|case
name|MAYBE_SWAPPED
case|:
if|if
condition|(
name|hdr
operator|->
name|caplen
operator|<=
name|hdr
operator|->
name|len
condition|)
block|{
comment|/* 			 * The captured length is<= the actual length, 			 * so presumably they weren't swapped. 			 */
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|SWAPPED
case|:
name|t
operator|=
name|hdr
operator|->
name|caplen
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|hdr
operator|->
name|len
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|t
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hdr
operator|->
name|caplen
operator|>
name|p
operator|->
name|bufsize
condition|)
block|{
comment|/* 		 * This can happen due to Solaris 2.3 systems tripping 		 * over the BUFMOD problem and not setting the snapshot 		 * correctly in the savefile header.  If the caplen isn't 		 * grossly wrong, try to salvage. 		 */
specifier|static
name|u_char
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|tsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|caplen
operator|>
literal|65535
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bogus savefile header"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|tsize
operator|<
name|hdr
operator|->
name|caplen
condition|)
block|{
name|tsize
operator|=
operator|(
operator|(
name|hdr
operator|->
name|caplen
operator|+
literal|1023
operator|)
operator|/
literal|1024
operator|)
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|tsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|tsize
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BUFMOD hack malloc"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|amt_read
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tp
argument_list|,
literal|1
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
name|hdr
operator|->
name|caplen
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %u captured bytes, only got %lu"
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * We can only keep up to p->bufsize bytes.  Since 		 * caplen> p->bufsize is exactly how we got here, 		 * we know we can only keep the first p->bufsize bytes 		 * and must drop the remainder.  Adjust caplen accordingly, 		 * so we don't get confused later as to how many bytes we 		 * have to play with. 		 */
name|hdr
operator|->
name|caplen
operator|=
name|p
operator|->
name|bufsize
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tp
argument_list|,
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* read the packet itself */
name|amt_read
operator|=
name|fread
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
literal|1
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
name|hdr
operator|->
name|caplen
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %u captured bytes, only got %lu"
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|data
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|swapped
condition|)
block|{
comment|/* 		 * Convert pseudo-headers from the byte order of 		 * the host on which the file was saved to our 		 * byte order, as necessary. 		 */
switch|switch
condition|(
name|p
operator|->
name|linktype
condition|)
block|{
case|case
name|DLT_USB_LINUX
case|:
name|swap_linux_usb_header
argument_list|(
name|hdr
argument_list|,
operator|*
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DLT_USB_LINUX_MMAPPED
case|:
name|swap_linux_usb_header
argument_list|(
name|hdr
argument_list|,
operator|*
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_write_header
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|linktype
parameter_list|,
name|int
name|thiszone
parameter_list|,
name|int
name|snaplen
parameter_list|)
block|{
name|struct
name|pcap_file_header
name|hdr
decl_stmt|;
name|hdr
operator|.
name|magic
operator|=
name|TCPDUMP_MAGIC
expr_stmt|;
name|hdr
operator|.
name|version_major
operator|=
name|PCAP_VERSION_MAJOR
expr_stmt|;
name|hdr
operator|.
name|version_minor
operator|=
name|PCAP_VERSION_MINOR
expr_stmt|;
name|hdr
operator|.
name|thiszone
operator|=
name|thiszone
expr_stmt|;
name|hdr
operator|.
name|snaplen
operator|=
name|snaplen
expr_stmt|;
name|hdr
operator|.
name|sigfigs
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|linktype
operator|=
name|linktype
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output a packet to the initialized dump file.  */
end_comment

begin_function
name|void
name|pcap_dump
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|sp
parameter_list|)
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|pcap_sf_pkthdr
name|sf_hdr
decl_stmt|;
name|f
operator|=
operator|(
name|FILE
operator|*
operator|)
name|user
expr_stmt|;
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|h
operator|->
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|h
operator|->
name|ts
operator|.
name|tv_usec
expr_stmt|;
name|sf_hdr
operator|.
name|caplen
operator|=
name|h
operator|->
name|caplen
expr_stmt|;
name|sf_hdr
operator|.
name|len
operator|=
name|h
operator|->
name|len
expr_stmt|;
comment|/* XXX we should check the return status */
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|&
name|sf_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sf_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|sp
argument_list|,
name|h
operator|->
name|caplen
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pcap_dumper_t
modifier|*
name|pcap_setup_dump
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|linktype
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
comment|/* 	 * If we're writing to the standard output, put it in binary 	 * mode, as savefiles are binary files. 	 * 	 * Otherwise, we turn off buffering. 	 * XXX - why?  And why not on the standard output? 	 */
if|if
condition|(
name|f
operator|==
name|stdout
condition|)
name|SET_BINMODE
argument_list|(
name|f
argument_list|)
expr_stmt|;
else|else
name|setbuf
argument_list|(
name|f
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sf_write_header
argument_list|(
name|f
argument_list|,
name|linktype
argument_list|,
name|p
operator|->
name|tzoff
argument_list|,
name|p
operator|->
name|snapshot
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't write to %s: %s"
argument_list|,
name|fname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|stdout
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|pcap_dumper_t
operator|*
operator|)
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize so that sf_write() will output to the file named 'fname'.  */
end_comment

begin_function
name|pcap_dumper_t
modifier|*
name|pcap_dump_open
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|linktype
decl_stmt|;
comment|/* 	 * If this pcap_t hasn't been activated, it doesn't have a 	 * link-layer type, so we can't use it. 	 */
if|if
condition|(
operator|!
name|p
operator|->
name|activated
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: not-yet-activated pcap_t passed to pcap_dump_open"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|linktype
operator|=
name|dlt_to_linktype
argument_list|(
name|p
operator|->
name|linktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: link-layer type %d isn't supported in savefiles"
argument_list|,
name|fname
argument_list|,
name|p
operator|->
name|linktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|linktype
operator||=
name|p
operator|->
name|linktype_ext
expr_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|fname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|f
operator|=
name|stdout
expr_stmt|;
name|fname
operator|=
literal|"standard output"
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|#
directive|else
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|fname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|pcap_setup_dump
argument_list|(
name|p
argument_list|,
name|linktype
argument_list|,
name|f
argument_list|,
name|fname
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize so that sf_write() will output to the given stream.  */
end_comment

begin_function
name|pcap_dumper_t
modifier|*
name|pcap_dump_fopen
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|int
name|linktype
decl_stmt|;
name|linktype
operator|=
name|dlt_to_linktype
argument_list|(
name|p
operator|->
name|linktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"stream: link-layer type %d isn't supported in savefiles"
argument_list|,
name|p
operator|->
name|linktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|linktype
operator||=
name|p
operator|->
name|linktype_ext
expr_stmt|;
return|return
operator|(
name|pcap_setup_dump
argument_list|(
name|p
argument_list|,
name|linktype
argument_list|,
name|f
argument_list|,
literal|"stream"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|pcap_dump_file
parameter_list|(
name|pcap_dumper_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|long
name|pcap_dump_ftell
parameter_list|(
name|pcap_dumper_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|ftell
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_dump_flush
parameter_list|(
name|pcap_dumper_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|fflush
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcap_dump_close
parameter_list|(
name|pcap_dumper_t
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ferror
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
argument_list|)
condition|)
return|return
operator|-
name|an
operator|-
name|error
return|;
comment|/* XXX should check return from fclose() too */
endif|#
directive|endif
operator|(
name|void
operator|)
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

