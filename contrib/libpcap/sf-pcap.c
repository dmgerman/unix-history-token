begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * sf-pcap.c - libpcap-file-format-specific code from savefile.c  *	Extraction/creation by Jeffrey Mogul, DECWRL  *	Modified by Steve McCanne, LBL.  *  * Used to save the received packet headers, after filtering, to  * a file, and then read them later.  * The first record in the file contains saved values for the machine  * dependent values so we can print the dump file on any architecture.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header$ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<pcap-stdinc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _WIN32 */
end_comment

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_STDINT_H
end_elif

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BITYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bitypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"pcap-common.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sf-pcap.h"
end_include

begin_comment
comment|/*  * Setting O_BINARY on DOS/Windows is a bit tricky  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_define
define|#
directive|define
name|SET_BINMODE
parameter_list|(
name|f
parameter_list|)
value|_setmode(_fileno(f), _O_BINARY)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_elif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__HIGHC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|SET_BINMODE
parameter_list|(
name|f
parameter_list|)
value|setmode(f, O_BINARY)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_BINMODE
parameter_list|(
name|f
parameter_list|)
value|setmode(fileno(f), O_BINARY)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Standard libpcap format.  */
end_comment

begin_define
define|#
directive|define
name|TCPDUMP_MAGIC
value|0xa1b2c3d4
end_define

begin_comment
comment|/*  * Alexey Kuznetzov's modified libpcap format.  */
end_comment

begin_define
define|#
directive|define
name|KUZNETZOV_TCPDUMP_MAGIC
value|0xa1b2cd34
end_define

begin_comment
comment|/*  * Reserved for Francisco Mesquita<francisco.mesquita@radiomovel.pt>  * for another modified format.  */
end_comment

begin_define
define|#
directive|define
name|FMESQUITA_TCPDUMP_MAGIC
value|0xa1b234cd
end_define

begin_comment
comment|/*  * Navtel Communcations' format, with nanosecond timestamps,  * as per a request from Dumas Hwang<dumas.hwang@navtelcom.com>.  */
end_comment

begin_define
define|#
directive|define
name|NAVTEL_TCPDUMP_MAGIC
value|0xa12b3c4d
end_define

begin_comment
comment|/*  * Normal libpcap format, except for seconds/nanoseconds timestamps,  * as per a request by Ulf Lamping<ulf.lamping@web.de>  */
end_comment

begin_define
define|#
directive|define
name|NSEC_TCPDUMP_MAGIC
value|0xa1b23c4d
end_define

begin_comment
comment|/*  * Mechanism for storing information about a capture in the upper  * 6 bits of a linktype value in a capture file.  *  * LT_LINKTYPE_EXT(x) extracts the additional information.  *  * The rest of the bits are for a value describing the link-layer  * value.  LT_LINKTYPE(x) extracts that value.  */
end_comment

begin_define
define|#
directive|define
name|LT_LINKTYPE
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x03FFFFFF)
end_define

begin_define
define|#
directive|define
name|LT_LINKTYPE_EXT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xFC000000)
end_define

begin_function_decl
specifier|static
name|int
name|pcap_next_packet
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
modifier|*
name|datap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Private data for reading pcap savefiles.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|NOT_SWAPPED
block|,
name|SWAPPED
block|,
name|MAYBE_SWAPPED
block|}
name|swapped_type_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|PASS_THROUGH
block|,
name|SCALE_UP
block|,
name|SCALE_DOWN
block|}
name|tstamp_scale_type_t
typedef|;
end_typedef

begin_struct
struct|struct
name|pcap_sf
block|{
name|size_t
name|hdrsize
decl_stmt|;
name|swapped_type_t
name|lengths_swapped
decl_stmt|;
name|tstamp_scale_type_t
name|scale_type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Check whether this is a pcap savefile and, if it is, extract the  * relevant information from the header.  */
end_comment

begin_function
name|pcap_t
modifier|*
name|pcap_check_header
parameter_list|(
name|bpf_u_int32
name|magic
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|u_int
name|precision
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|pcap_file_header
name|hdr
decl_stmt|;
name|size_t
name|amt_read
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|int
name|swapped
init|=
literal|0
decl_stmt|;
name|struct
name|pcap_sf
modifier|*
name|ps
decl_stmt|;
comment|/* 	 * Assume no read errors. 	 */
operator|*
name|err
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check whether the first 4 bytes of the file are the magic 	 * number for a pcap savefile, or for a byte-swapped pcap 	 * savefile. 	 */
if|if
condition|(
name|magic
operator|!=
name|TCPDUMP_MAGIC
operator|&&
name|magic
operator|!=
name|KUZNETZOV_TCPDUMP_MAGIC
operator|&&
name|magic
operator|!=
name|NSEC_TCPDUMP_MAGIC
condition|)
block|{
name|magic
operator|=
name|SWAPLONG
argument_list|(
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|TCPDUMP_MAGIC
operator|&&
name|magic
operator|!=
name|KUZNETZOV_TCPDUMP_MAGIC
operator|&&
name|magic
operator|!=
name|NSEC_TCPDUMP_MAGIC
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* nope */
name|swapped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * They are.  Put the magic number in the header, and read 	 * the rest of the header. 	 */
name|hdr
operator|.
name|magic
operator|=
name|magic
expr_stmt|;
name|amt_read
operator|=
name|fread
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
operator|)
operator|+
sizeof|sizeof
name|hdr
operator|.
name|magic
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|magic
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|magic
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %lu file header bytes, only got %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
block|}
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If it's a byte-swapped capture file, byte-swap the header. 	 */
if|if
condition|(
name|swapped
condition|)
block|{
name|hdr
operator|.
name|version_major
operator|=
name|SWAPSHORT
argument_list|(
name|hdr
operator|.
name|version_major
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|version_minor
operator|=
name|SWAPSHORT
argument_list|(
name|hdr
operator|.
name|version_minor
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|thiszone
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|.
name|thiszone
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|sigfigs
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|.
name|sigfigs
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|snaplen
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|.
name|snaplen
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|linktype
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|.
name|linktype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr
operator|.
name|version_major
operator|<
name|PCAP_VERSION_MAJOR
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"archaic pcap savefile format"
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * currently only versions 2.[0-4] are supported with 	 * the exception of 543.0 for DG/UX tcpdump. 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|hdr
operator|.
name|version_major
operator|==
name|PCAP_VERSION_MAJOR
operator|&&
name|hdr
operator|.
name|version_minor
operator|<=
name|PCAP_VERSION_MINOR
operator|)
operator|||
operator|(
name|hdr
operator|.
name|version_major
operator|==
literal|543
operator|&&
name|hdr
operator|.
name|version_minor
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unsupported pcap savefile version %u.%u"
argument_list|,
name|hdr
operator|.
name|version_major
argument_list|,
name|hdr
operator|.
name|version_minor
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|hdr
operator|.
name|snaplen
operator|>
name|MAXIMUM_SNAPLEN
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"invalid file capture length %u, bigger than "
literal|"maximum of %u"
argument_list|,
name|hdr
operator|.
name|snaplen
argument_list|,
name|MAXIMUM_SNAPLEN
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * OK, this is a good pcap file. 	 * Allocate a pcap_t for it. 	 */
name|p
operator|=
name|pcap_open_offline_common
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_sf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* Allocation failed. */
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|swapped
operator|=
name|swapped
expr_stmt|;
name|p
operator|->
name|version_major
operator|=
name|hdr
operator|.
name|version_major
expr_stmt|;
name|p
operator|->
name|version_minor
operator|=
name|hdr
operator|.
name|version_minor
expr_stmt|;
name|p
operator|->
name|tzoff
operator|=
name|hdr
operator|.
name|thiszone
expr_stmt|;
name|p
operator|->
name|snapshot
operator|=
name|hdr
operator|.
name|snaplen
expr_stmt|;
name|p
operator|->
name|linktype
operator|=
name|linktype_to_dlt
argument_list|(
name|LT_LINKTYPE
argument_list|(
name|hdr
operator|.
name|linktype
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|linktype_ext
operator|=
name|LT_LINKTYPE_EXT
argument_list|(
name|hdr
operator|.
name|linktype
argument_list|)
expr_stmt|;
name|p
operator|->
name|next_packet_op
operator|=
name|pcap_next_packet
expr_stmt|;
name|ps
operator|=
name|p
operator|->
name|priv
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|=
name|precision
expr_stmt|;
comment|/* 	 * Will we need to scale the timestamps to match what the 	 * user wants? 	 */
switch|switch
condition|(
name|precision
condition|)
block|{
case|case
name|PCAP_TSTAMP_PRECISION_MICRO
case|:
if|if
condition|(
name|magic
operator|==
name|NSEC_TCPDUMP_MAGIC
condition|)
block|{
comment|/* 			 * The file has nanoseconds, the user 			 * wants microseconds; scale the 			 * precision down. 			 */
name|ps
operator|->
name|scale_type
operator|=
name|SCALE_DOWN
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The file has microseconds, the 			 * user wants microseconds; nothing to do. 			 */
name|ps
operator|->
name|scale_type
operator|=
name|PASS_THROUGH
expr_stmt|;
block|}
break|break;
case|case
name|PCAP_TSTAMP_PRECISION_NANO
case|:
if|if
condition|(
name|magic
operator|==
name|NSEC_TCPDUMP_MAGIC
condition|)
block|{
comment|/* 			 * The file has nanoseconds, the 			 * user wants nanoseconds; nothing to do. 			 */
name|ps
operator|->
name|scale_type
operator|=
name|PASS_THROUGH
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The file has microoseconds, the user 			 * wants nanoseconds; scale the 			 * precision up. 			 */
name|ps
operator|->
name|scale_type
operator|=
name|SCALE_UP
expr_stmt|;
block|}
break|break;
default|default:
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown time stamp resolution %u"
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * We interchanged the caplen and len fields at version 2.3, 	 * in order to match the bpf header layout.  But unfortunately 	 * some files were written with version 2.3 in their headers 	 * but without the interchanged fields. 	 * 	 * In addition, DG/UX tcpdump writes out files with a version 	 * number of 543.0, and with the caplen and len fields in the 	 * pre-2.3 order. 	 */
switch|switch
condition|(
name|hdr
operator|.
name|version_major
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|hdr
operator|.
name|version_minor
operator|<
literal|3
condition|)
name|ps
operator|->
name|lengths_swapped
operator|=
name|SWAPPED
expr_stmt|;
elseif|else
if|if
condition|(
name|hdr
operator|.
name|version_minor
operator|==
literal|3
condition|)
name|ps
operator|->
name|lengths_swapped
operator|=
name|MAYBE_SWAPPED
expr_stmt|;
else|else
name|ps
operator|->
name|lengths_swapped
operator|=
name|NOT_SWAPPED
expr_stmt|;
break|break;
case|case
literal|543
case|:
name|ps
operator|->
name|lengths_swapped
operator|=
name|SWAPPED
expr_stmt|;
break|break;
default|default:
name|ps
operator|->
name|lengths_swapped
operator|=
name|NOT_SWAPPED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|magic
operator|==
name|KUZNETZOV_TCPDUMP_MAGIC
condition|)
block|{
comment|/* 		 * XXX - the patch that's in some versions of libpcap 		 * changes the packet header but not the magic number, 		 * and some other versions with this magic number have 		 * some extra debugging information in the packet header; 		 * we'd have to use some hacks^H^H^H^H^Hheuristics to 		 * detect those variants. 		 * 		 * Ethereal does that, but it does so by trying to read 		 * the first two packets of the file with each of the 		 * record header formats.  That currently means it seeks 		 * backwards and retries the reads, which doesn't work 		 * on pipes.  We want to be able to read from a pipe, so 		 * that strategy won't work; we'd have to buffer some 		 * data ourselves and read from that buffer in order to 		 * make that work. 		 */
name|ps
operator|->
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_sf_patched_pkthdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|linktype
operator|==
name|DLT_EN10MB
condition|)
block|{
comment|/* 			 * This capture might have been done in raw mode 			 * or cooked mode. 			 * 			 * If it was done in cooked mode, p->snapshot was 			 * passed to recvfrom() as the buffer size, meaning 			 * that the most packet data that would be copied 			 * would be p->snapshot.  However, a faked Ethernet 			 * header would then have been added to it, so the 			 * most data that would be in a packet in the file 			 * would be p->snapshot + 14. 			 * 			 * We can't easily tell whether the capture was done 			 * in raw mode or cooked mode, so we'll assume it was 			 * cooked mode, and add 14 to the snapshot length. 			 * That means that, for a raw capture, the snapshot 			 * length will be misleading if you use it to figure 			 * out why a capture doesn't have all the packet data, 			 * but there's not much we can do to avoid that. 			 */
name|p
operator|->
name|snapshot
operator|+=
literal|14
expr_stmt|;
block|}
block|}
else|else
name|ps
operator|->
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_sf_pkthdr
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a buffer for the packet data. 	 */
name|p
operator|->
name|bufsize
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bufsize
operator|<=
literal|0
condition|)
block|{
comment|/* 		 * Bogus snapshot length; use the maximum as a fallback. 		 */
name|p
operator|->
name|bufsize
operator|=
name|MAXIMUM_SNAPLEN
expr_stmt|;
block|}
name|p
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|cleanup_op
operator|=
name|sf_cleanup
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read and return the next packet from the savefile.  Return the header  * in hdr and a pointer to the contents in data.  Return 0 on success, 1  * if there were no more packets, and -1 on an error.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_next_packet
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|pcap_sf
modifier|*
name|ps
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|struct
name|pcap_sf_patched_pkthdr
name|sf_hdr
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|p
operator|->
name|rfile
decl_stmt|;
name|size_t
name|amt_read
decl_stmt|;
name|bpf_u_int32
name|t
decl_stmt|;
comment|/* 	 * Read the packet header; the structure we use as a buffer 	 * is the longer structure for files generated by the patched 	 * libpcap, but if the file has the magic number for an 	 * unpatched libpcap we only read as many bytes as the regular 	 * header has. 	 */
name|amt_read
operator|=
name|fread
argument_list|(
operator|&
name|sf_hdr
argument_list|,
literal|1
argument_list|,
name|ps
operator|->
name|hdrsize
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
name|ps
operator|->
name|hdrsize
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|amt_read
operator|!=
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %lu header bytes, only got %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ps
operator|->
name|hdrsize
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* EOF */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
block|{
comment|/* these were written in opposite byte order */
name|hdr
operator|->
name|caplen
operator|=
name|SWAPLONG
argument_list|(
name|sf_hdr
operator|.
name|caplen
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|SWAPLONG
argument_list|(
name|sf_hdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|SWAPLONG
argument_list|(
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
name|SWAPLONG
argument_list|(
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|caplen
operator|=
name|sf_hdr
operator|.
name|caplen
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|sf_hdr
operator|.
name|len
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_usec
expr_stmt|;
block|}
switch|switch
condition|(
name|ps
operator|->
name|scale_type
condition|)
block|{
case|case
name|PASS_THROUGH
case|:
comment|/* 		 * Just pass the time stamp through. 		 */
break|break;
case|case
name|SCALE_UP
case|:
comment|/* 		 * File has microseconds, user wants nanoseconds; convert 		 * it. 		 */
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
break|break;
case|case
name|SCALE_DOWN
case|:
comment|/* 		 * File has nanoseconds, user wants microseconds; convert 		 * it. 		 */
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
break|break;
block|}
comment|/* Swap the caplen and len fields, if necessary. */
switch|switch
condition|(
name|ps
operator|->
name|lengths_swapped
condition|)
block|{
case|case
name|NOT_SWAPPED
case|:
break|break;
case|case
name|MAYBE_SWAPPED
case|:
if|if
condition|(
name|hdr
operator|->
name|caplen
operator|<=
name|hdr
operator|->
name|len
condition|)
block|{
comment|/* 			 * The captured length is<= the actual length, 			 * so presumably they weren't swapped. 			 */
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|SWAPPED
case|:
name|t
operator|=
name|hdr
operator|->
name|caplen
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|hdr
operator|->
name|len
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|t
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hdr
operator|->
name|caplen
operator|>
name|p
operator|->
name|bufsize
condition|)
block|{
comment|/* 		 * This can happen due to Solaris 2.3 systems tripping 		 * over the BUFMOD problem and not setting the snapshot 		 * correctly in the savefile header. 		 * This can also happen with a corrupted savefile or a 		 * savefile built/modified by a fuzz tester. 		 * If the caplen isn't grossly wrong, try to salvage. 		 */
name|size_t
name|bytes_to_discard
decl_stmt|;
name|size_t
name|bytes_to_read
decl_stmt|,
name|bytes_read
decl_stmt|;
name|char
name|discard_buf
index|[
literal|4096
index|]
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|caplen
operator|>
name|MAXIMUM_SNAPLEN
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"invalid packet capture length %u, bigger than "
literal|"maximum of %u"
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
name|MAXIMUM_SNAPLEN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * XXX - we don't grow the buffer here because some 		 * program might assume that it will never get packets 		 * bigger than the snapshot length; for example, it might 		 * copy data from our buffer to a buffer of its own, 		 * allocated based on the return value of pcap_snapshot(). 		 * 		 * Read the first p->bufsize bytes into the buffer. 		 */
name|amt_read
operator|=
name|fread
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|bufsize
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
name|p
operator|->
name|bufsize
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Yes, this uses hdr->caplen; technically, 				 * it's true, because we would try to read 				 * and discard the rest of those bytes, and 				 * that would fail because we got EOF before 				 * the read finished. 				 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %u captured bytes, only got %lu"
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Now read and discard what's left. 		 */
name|bytes_to_discard
operator|=
name|hdr
operator|->
name|caplen
operator|-
name|p
operator|->
name|bufsize
expr_stmt|;
name|bytes_read
operator|=
name|amt_read
expr_stmt|;
while|while
condition|(
name|bytes_to_discard
operator|!=
literal|0
condition|)
block|{
name|bytes_to_read
operator|=
name|bytes_to_discard
expr_stmt|;
if|if
condition|(
name|bytes_to_read
operator|>
sizeof|sizeof
argument_list|(
name|discard_buf
argument_list|)
condition|)
name|bytes_to_read
operator|=
sizeof|sizeof
argument_list|(
name|discard_buf
argument_list|)
expr_stmt|;
name|amt_read
operator|=
name|fread
argument_list|(
name|discard_buf
argument_list|,
literal|1
argument_list|,
name|bytes_to_read
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|bytes_read
operator|+=
name|amt_read
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
name|bytes_to_read
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %u captured bytes, only got %lu"
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytes_read
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bytes_to_discard
operator|-=
name|amt_read
expr_stmt|;
block|}
comment|/* 		 * Adjust caplen accordingly, so we don't get confused later 		 * as to how many bytes we have to play with. 		 */
name|hdr
operator|->
name|caplen
operator|=
name|p
operator|->
name|bufsize
expr_stmt|;
block|}
else|else
block|{
comment|/* read the packet itself */
name|amt_read
operator|=
name|fread
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
literal|1
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
name|hdr
operator|->
name|caplen
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %u captured bytes, only got %lu"
argument_list|,
name|hdr
operator|->
name|caplen
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|data
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|swapped
condition|)
name|swap_pseudo_headers
argument_list|(
name|p
operator|->
name|linktype
argument_list|,
name|hdr
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_write_header
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|linktype
parameter_list|,
name|int
name|thiszone
parameter_list|,
name|int
name|snaplen
parameter_list|)
block|{
name|struct
name|pcap_file_header
name|hdr
decl_stmt|;
name|hdr
operator|.
name|magic
operator|=
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|==
name|PCAP_TSTAMP_PRECISION_NANO
condition|?
name|NSEC_TCPDUMP_MAGIC
else|:
name|TCPDUMP_MAGIC
expr_stmt|;
name|hdr
operator|.
name|version_major
operator|=
name|PCAP_VERSION_MAJOR
expr_stmt|;
name|hdr
operator|.
name|version_minor
operator|=
name|PCAP_VERSION_MINOR
expr_stmt|;
name|hdr
operator|.
name|thiszone
operator|=
name|thiszone
expr_stmt|;
name|hdr
operator|.
name|snaplen
operator|=
name|snaplen
expr_stmt|;
name|hdr
operator|.
name|sigfigs
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|linktype
operator|=
name|linktype
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output a packet to the initialized dump file.  */
end_comment

begin_function
name|void
name|pcap_dump
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|sp
parameter_list|)
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|pcap_sf_pkthdr
name|sf_hdr
decl_stmt|;
name|f
operator|=
operator|(
name|FILE
operator|*
operator|)
name|user
expr_stmt|;
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|h
operator|->
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|sf_hdr
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|h
operator|->
name|ts
operator|.
name|tv_usec
expr_stmt|;
name|sf_hdr
operator|.
name|caplen
operator|=
name|h
operator|->
name|caplen
expr_stmt|;
name|sf_hdr
operator|.
name|len
operator|=
name|h
operator|->
name|len
expr_stmt|;
comment|/* XXX we should check the return status */
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|&
name|sf_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sf_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|sp
argument_list|,
name|h
operator|->
name|caplen
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pcap_dumper_t
modifier|*
name|pcap_setup_dump
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|linktype
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
comment|/* 	 * If we're writing to the standard output, put it in binary 	 * mode, as savefiles are binary files. 	 * 	 * Otherwise, we turn off buffering. 	 * XXX - why?  And why not on the standard output? 	 */
if|if
condition|(
name|f
operator|==
name|stdout
condition|)
name|SET_BINMODE
argument_list|(
name|f
argument_list|)
expr_stmt|;
else|else
name|setbuf
argument_list|(
name|f
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sf_write_header
argument_list|(
name|p
argument_list|,
name|f
argument_list|,
name|linktype
argument_list|,
name|p
operator|->
name|tzoff
argument_list|,
name|p
operator|->
name|snapshot
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't write to %s: %s"
argument_list|,
name|fname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|stdout
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|pcap_dumper_t
operator|*
operator|)
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize so that sf_write() will output to the file named 'fname'.  */
end_comment

begin_function
name|pcap_dumper_t
modifier|*
name|pcap_dump_open
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|linktype
decl_stmt|;
comment|/* 	 * If this pcap_t hasn't been activated, it doesn't have a 	 * link-layer type, so we can't use it. 	 */
if|if
condition|(
operator|!
name|p
operator|->
name|activated
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: not-yet-activated pcap_t passed to pcap_dump_open"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|linktype
operator|=
name|dlt_to_linktype
argument_list|(
name|p
operator|->
name|linktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: link-layer type %d isn't supported in savefiles"
argument_list|,
name|fname
argument_list|,
name|p
operator|->
name|linktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|linktype
operator||=
name|p
operator|->
name|linktype_ext
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"A null pointer was supplied as the file name"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|fname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|f
operator|=
name|stdout
expr_stmt|;
name|fname
operator|=
literal|"standard output"
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|#
directive|else
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|fname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|pcap_setup_dump
argument_list|(
name|p
argument_list|,
name|linktype
argument_list|,
name|f
argument_list|,
name|fname
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize so that sf_write() will output to the given stream.  */
end_comment

begin_function
name|pcap_dumper_t
modifier|*
name|pcap_dump_fopen
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|int
name|linktype
decl_stmt|;
name|linktype
operator|=
name|dlt_to_linktype
argument_list|(
name|p
operator|->
name|linktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"stream: link-layer type %d isn't supported in savefiles"
argument_list|,
name|p
operator|->
name|linktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|linktype
operator||=
name|p
operator|->
name|linktype_ext
expr_stmt|;
return|return
operator|(
name|pcap_setup_dump
argument_list|(
name|p
argument_list|,
name|linktype
argument_list|,
name|f
argument_list|,
literal|"stream"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|pcap_dumper_t
modifier|*
name|pcap_dump_open_append
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|linktype
decl_stmt|;
name|size_t
name|amt_read
decl_stmt|;
name|struct
name|pcap_file_header
name|ph
decl_stmt|;
name|linktype
operator|=
name|dlt_to_linktype
argument_list|(
name|p
operator|->
name|linktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: link-layer type %d isn't supported in savefiles"
argument_list|,
name|fname
argument_list|,
name|linktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"A null pointer was supplied as the file name"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|fname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|pcap_setup_dump
argument_list|(
name|p
argument_list|,
name|linktype
argument_list|,
name|stdout
argument_list|,
literal|"standard output"
argument_list|)
operator|)
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
else|#
directive|else
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"rb+"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|fname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Try to read a pcap header. 	 */
name|amt_read
operator|=
name|fread
argument_list|(
operator|&
name|ph
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ph
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
sizeof|sizeof
argument_list|(
name|ph
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|fname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|feof
argument_list|(
name|f
argument_list|)
operator|&&
name|amt_read
operator|>
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: truncated pcap file header"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
comment|/* 	 * We turn off buffering. 	 * XXX - why?  And why not on the standard output? 	 */
name|setbuf
argument_list|(
name|f
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If a header is already present and: 	 * 	 *	it's not for a pcap file of the appropriate resolution 	 *	and the right byte order for this machine; 	 * 	 *	the link-layer header types don't match; 	 * 	 *	the snapshot lengths don't match; 	 * 	 * return an error. 	 */
if|if
condition|(
name|amt_read
operator|>
literal|0
condition|)
block|{
comment|/* 		 * A header is already present. 		 * Do the checks. 		 */
switch|switch
condition|(
name|ph
operator|.
name|magic
condition|)
block|{
case|case
name|TCPDUMP_MAGIC
case|:
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|!=
name|PCAP_TSTAMP_PRECISION_MICRO
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: different time stamp precision, cannot append to file"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|NSEC_TCPDUMP_MAGIC
case|:
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|!=
name|PCAP_TSTAMP_PRECISION_NANO
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: different time stamp precision, cannot append to file"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|SWAPLONG
argument_list|(
name|TCPDUMP_MAGIC
argument_list|)
case|:
case|case
name|SWAPLONG
argument_list|(
name|NSEC_TCPDUMP_MAGIC
argument_list|)
case|:
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: different byte order, cannot append to file"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|KUZNETZOV_TCPDUMP_MAGIC
case|:
case|case
name|SWAPLONG
argument_list|(
name|KUZNETZOV_TCPDUMP_MAGIC
argument_list|)
case|:
case|case
name|NAVTEL_TCPDUMP_MAGIC
case|:
case|case
name|SWAPLONG
argument_list|(
name|NAVTEL_TCPDUMP_MAGIC
argument_list|)
case|:
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: not a pcap file to which we can append"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
default|default:
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: not a pcap file"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Good version? 		 */
if|if
condition|(
name|ph
operator|.
name|version_major
operator|!=
name|PCAP_VERSION_MAJOR
operator|||
name|ph
operator|.
name|version_minor
operator|!=
name|PCAP_VERSION_MINOR
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: version is %u.%u, cannot append to file"
argument_list|,
name|fname
argument_list|,
name|ph
operator|.
name|version_major
argument_list|,
name|ph
operator|.
name|version_minor
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bpf_u_int32
operator|)
name|linktype
operator|!=
name|ph
operator|.
name|linktype
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: different linktype, cannot append to file"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bpf_u_int32
operator|)
name|p
operator|->
name|snapshot
operator|!=
name|ph
operator|.
name|snaplen
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: different snaplen, cannot append to file"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * A header isn't present; attempt to write it. 		 */
if|if
condition|(
name|sf_write_header
argument_list|(
name|p
argument_list|,
name|f
argument_list|,
name|linktype
argument_list|,
name|p
operator|->
name|tzoff
argument_list|,
name|p
operator|->
name|snapshot
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't write to %s: %s"
argument_list|,
name|fname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * Start writing at the end of the file. 	 */
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't seek to end of %s: %s"
argument_list|,
name|fname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|pcap_dumper_t
operator|*
operator|)
name|f
operator|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|pcap_dump_file
parameter_list|(
name|pcap_dumper_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|long
name|pcap_dump_ftell
parameter_list|(
name|pcap_dumper_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|ftell
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_dump_flush
parameter_list|(
name|pcap_dumper_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|fflush
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcap_dump_close
parameter_list|(
name|pcap_dumper_t
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ferror
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
argument_list|)
condition|)
return|return
operator|-
name|an
operator|-
name|error
return|;
comment|/* XXX should check return from fclose() too */
endif|#
directive|endif
operator|(
name|void
operator|)
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

