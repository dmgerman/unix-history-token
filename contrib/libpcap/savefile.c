begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * savefile.c - supports offline use of tcpdump  *	Extraction/creation by Jeffrey Mogul, DECWRL  *	Modified by Steve McCanne, LBL.  *  * Used to save the received packet headers, after filtering, to  * a file, and then read them later.  * The first record in the file contains saved values for the machine  * dependent values so we can print the dump file on any architecture.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<pcap-stdinc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _WIN32 */
end_comment

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_STDINT_H
end_elif

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BITYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bitypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sf-pcap.h"
end_include

begin_include
include|#
directive|include
file|"sf-pcap-ng.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_comment
comment|/*  * These aren't exported on Windows, because they would only work if both  * WinPcap and the code using it were to use the Universal CRT; otherwise,  * a FILE structure in WinPcap and a FILE structure in the code using it  * could be different if they're using different versions of the C runtime.  *  * Instead, pcap/pcap.h defines them as macros that wrap the hopen versions,  * with the wrappers calling _fileno() and _get_osfhandle() themselves,  * so that they convert the appropriate CRT version's FILE structure to  * a HANDLE (which is OS-defined, not CRT-defined, and is part of the Win32  * and Win64 ABIs).  */
end_comment

begin_function_decl
specifier|static
name|pcap_t
modifier|*
name|pcap_fopen_offline_with_tstamp_precision
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pcap_t
modifier|*
name|pcap_fopen_offline
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Setting O_BINARY on DOS/Windows is a bit tricky  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_define
define|#
directive|define
name|SET_BINMODE
parameter_list|(
name|f
parameter_list|)
value|_setmode(_fileno(f), _O_BINARY)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_elif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__HIGHC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|SET_BINMODE
parameter_list|(
name|f
parameter_list|)
value|setmode(f, O_BINARY)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_BINMODE
parameter_list|(
name|f
parameter_list|)
value|setmode(fileno(f), O_BINARY)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sf_getnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* 	 * This is a savefile, not a live capture file, so never say 	 * it's in non-blocking mode. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* 	 * This is a savefile, not a live capture file, so reject 	 * requests to put it in non-blocking mode.  (If it's a 	 * pipe, it could be put in non-blocking mode, but that 	 * would significantly complicate the code to read packets, 	 * as it would have to handle reading partial packets and 	 * keeping the state of the read.) 	 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Savefiles cannot be put into non-blocking mode"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Statistics aren't available from savefiles"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
specifier|static
name|struct
name|pcap_stat
modifier|*
name|sf_stats_ex
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|size
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Statistics aren't available from savefiles"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_setbuff
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dim
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The kernel buffer size cannot be set while reading from a file"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_setmode
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"impossible to set mode while reading from a file"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_setmintocopy
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The mintocopy parameter cannot be set while reading from a file"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|HANDLE
name|sf_getevent
parameter_list|(
name|pcap_t
modifier|*
name|pcap
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"The read event cannot be retrieved while reading from a file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|INVALID_HANDLE_VALUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_oid_get_request
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|oid
name|_U_
parameter_list|,
name|void
modifier|*
name|data
name|_U_
parameter_list|,
name|size_t
modifier|*
name|lenp
name|_U_
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"An OID get request cannot be performed on a file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_oid_set_request
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|oid
name|_U_
parameter_list|,
specifier|const
name|void
modifier|*
name|data
name|_U_
parameter_list|,
name|size_t
modifier|*
name|lenp
name|_U_
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"An OID set request cannot be performed on a file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|sf_sendqueue_transmit
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_send_queue
modifier|*
name|queue
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"Sending packets isn't supported on savefiles"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_setuserbuffer
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The user buffer cannot be set when reading from a file"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_live_dump
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|maxsize
parameter_list|,
name|int
name|maxpacks
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Live packet dumping cannot be performed when reading from a file"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sf_live_dump_ended
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Live packet dumping cannot be performed on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|PAirpcapHandle
name|sf_get_airpcap_handle
parameter_list|(
name|pcap_t
modifier|*
name|pcap
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sf_inject
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
name|_U_
parameter_list|,
name|size_t
name|size
name|_U_
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"Sending packets isn't supported on savefiles"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set direction flag: Which packets do we accept on a forwarding  * single device? IN, OUT or both?  */
end_comment

begin_function
specifier|static
name|int
name|sf_setdirection
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_direction_t
name|d
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"Setting direction is not supported on savefiles"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sf_cleanup
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|rfile
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|p
operator|->
name|rfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|pcap_freecode
argument_list|(
operator|&
name|p
operator|->
name|fcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * fopen's safe version on Windows. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_function
name|FILE
modifier|*
name|fopen_safe
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|errno_t
name|errno
decl_stmt|;
name|errno
operator|=
name|fopen_s
argument_list|(
operator|&
name|fp
argument_list|,
name|filename
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|fp
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|pcap_t
modifier|*
name|pcap_open_offline_with_tstamp_precision
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|u_int
name|precision
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"A null pointer was supplied as the file name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|fname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
comment|/* 		 * We're reading from the standard input, so put it in binary 		 * mode, as savefiles are binary files. 		 */
name|SET_BINMODE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|fname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|p
operator|=
name|pcap_fopen_offline_with_tstamp_precision
argument_list|(
name|fp
argument_list|,
name|precision
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fp
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_offline
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
return|return
operator|(
name|pcap_open_offline_with_tstamp_precision
argument_list|(
name|fname
argument_list|,
name|PCAP_TSTAMP_PRECISION_MICRO
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
name|pcap_t
modifier|*
name|pcap_hopen_offline_with_tstamp_precision
parameter_list|(
name|intptr_t
name|osfd
parameter_list|,
name|u_int
name|precision
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|fd
operator|=
name|_open_osfhandle
argument_list|(
name|osfd
argument_list|,
name|_O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|file
operator|=
name|_fdopen
argument_list|(
name|fd
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|pcap_fopen_offline_with_tstamp_precision
argument_list|(
name|file
argument_list|,
name|precision
argument_list|,
name|errbuf
argument_list|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_hopen_offline
parameter_list|(
name|intptr_t
name|osfd
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
return|return
name|pcap_hopen_offline_with_tstamp_precision
argument_list|(
name|osfd
argument_list|,
name|PCAP_TSTAMP_PRECISION_MICRO
argument_list|,
name|errbuf
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|pcap_t
modifier|*
function_decl|(
modifier|*
name|check_headers
index|[]
function_decl|)
parameter_list|(
name|bpf_u_int32
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
init|=
block|{
name|pcap_check_header
operator|,
function_decl|pcap_ng_check_header
end_function_decl

begin_define
unit|};
define|#
directive|define
name|N_FILE_TYPES
value|(sizeof check_headers / sizeof check_headers[0])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
specifier|static
endif|#
directive|endif
name|pcap_t
modifier|*
name|pcap_fopen_offline_with_tstamp_precision
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|u_int
name|precision
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
specifier|register
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|bpf_u_int32
name|magic
decl_stmt|;
name|size_t
name|amt_read
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Read the first 4 bytes of the file; the network analyzer dump 	 * file formats we support (pcap and pcap-ng), and several other 	 * formats we might support in the future (such as snoop, DOS and 	 * Windows Sniffer, and Microsoft Network Monitor) all have magic 	 * numbers that are unique in their first 4 bytes. 	 */
name|amt_read
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|magic
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt_read
operator|!=
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"error reading dump file: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"truncated dump file; tried to read %lu file header bytes, only got %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|amt_read
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Try all file types. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_FILE_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
call|(
modifier|*
name|check_headers
index|[
name|i
index|]
call|)
argument_list|(
name|magic
argument_list|,
name|fp
argument_list|,
name|precision
argument_list|,
name|errbuf
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* Yup, that's it. */
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * Error trying to read the header. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * Well, who knows what this mess is.... 	 */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown file format"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|found
label|:
name|p
operator|->
name|rfile
operator|=
name|fp
expr_stmt|;
comment|/* Padding only needed for live capture fcode */
name|p
operator|->
name|fddipad
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
comment|/* 	 * You can do "select()" and "poll()" on plain files on most 	 * platforms, and should be able to do so on pipes. 	 * 	 * You can't do "select()" on anything other than sockets in 	 * Windows, so, on Win32 systems, we don't have "selectable_fd". 	 */
name|p
operator|->
name|selectable_fd
operator|=
name|fileno
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|read_op
operator|=
name|pcap_offline_read
expr_stmt|;
name|p
operator|->
name|inject_op
operator|=
name|sf_inject
expr_stmt|;
name|p
operator|->
name|setfilter_op
operator|=
name|install_bpf_program
expr_stmt|;
name|p
operator|->
name|setdirection_op
operator|=
name|sf_setdirection
expr_stmt|;
name|p
operator|->
name|set_datalink_op
operator|=
name|NULL
expr_stmt|;
comment|/* we don't support munging link-layer headers */
name|p
operator|->
name|getnonblock_op
operator|=
name|sf_getnonblock
expr_stmt|;
name|p
operator|->
name|setnonblock_op
operator|=
name|sf_setnonblock
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
name|sf_stats
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|p
operator|->
name|stats_ex_op
operator|=
name|sf_stats_ex
expr_stmt|;
name|p
operator|->
name|setbuff_op
operator|=
name|sf_setbuff
expr_stmt|;
name|p
operator|->
name|setmode_op
operator|=
name|sf_setmode
expr_stmt|;
name|p
operator|->
name|setmintocopy_op
operator|=
name|sf_setmintocopy
expr_stmt|;
name|p
operator|->
name|getevent_op
operator|=
name|sf_getevent
expr_stmt|;
name|p
operator|->
name|oid_get_request_op
operator|=
name|sf_oid_get_request
expr_stmt|;
name|p
operator|->
name|oid_set_request_op
operator|=
name|sf_oid_set_request
expr_stmt|;
name|p
operator|->
name|sendqueue_transmit_op
operator|=
name|sf_sendqueue_transmit
expr_stmt|;
name|p
operator|->
name|setuserbuffer_op
operator|=
name|sf_setuserbuffer
expr_stmt|;
name|p
operator|->
name|live_dump_op
operator|=
name|sf_live_dump
expr_stmt|;
name|p
operator|->
name|live_dump_ended_op
operator|=
name|sf_live_dump_ended
expr_stmt|;
name|p
operator|->
name|get_airpcap_handle_op
operator|=
name|sf_get_airpcap_handle
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * For offline captures, the standard one-shot callback can 	 * be used for pcap_next()/pcap_next_ex(). 	 */
name|p
operator|->
name|oneshot_callback
operator|=
name|pcap_oneshot
expr_stmt|;
comment|/* 	 * Savefiles never require special BPF code generation. 	 */
name|p
operator|->
name|bpf_codegen_flags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|activated
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
specifier|static
endif|#
directive|endif
name|pcap_t
modifier|*
name|pcap_fopen_offline
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
return|return
operator|(
name|pcap_fopen_offline_with_tstamp_precision
argument_list|(
name|fp
argument_list|,
name|PCAP_TSTAMP_PRECISION_MICRO
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read packets from a capture file, and call the callback for each  * packet.  * If cnt> 0, return after 'cnt' packets, otherwise continue until eof.  */
end_comment

begin_function
name|int
name|pcap_offline_read
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|bpf_insn
modifier|*
name|fcode
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
while|while
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|struct
name|pcap_pkthdr
name|h
decl_stmt|;
comment|/* 		 * Has "pcap_breakloop()" been called? 		 * If so, return immediately - if we haven't read any 		 * packets, clear the flag and return -2 to indicate 		 * that we were told to break out of the loop, otherwise 		 * leave the flag set, so that the *next* call will break 		 * out of the loop without having read any packets, and 		 * return the number of packets we've processed so far. 		 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
else|else
return|return
operator|(
name|n
operator|)
return|;
block|}
name|status
operator|=
name|p
operator|->
name|next_packet_op
argument_list|(
name|p
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|status
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fcode
operator|=
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|)
operator|==
name|NULL
operator|||
name|bpf_filter
argument_list|(
name|fcode
argument_list|,
name|data
argument_list|,
name|h
operator|.
name|len
argument_list|,
name|h
operator|.
name|caplen
argument_list|)
condition|)
block|{
call|(
modifier|*
name|callback
call|)
argument_list|(
name|user
argument_list|,
operator|&
name|h
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|>=
name|cnt
operator|&&
name|cnt
operator|>
literal|0
condition|)
break|break;
block|}
block|}
comment|/*XXX this breaks semantics tcpslice expects */
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

end_unit

