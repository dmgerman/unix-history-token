begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997, 1998  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the Computer Systems  *	Engineering Group at Lawrence Berkeley Laboratory.  * 4. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<pcap-stdinc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _WIN32 */
end_comment

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_STDINT_H
end_elif

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BITYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bitypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|"pcap-dos.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DAG_API
end_ifdef

begin_include
include|#
directive|include
file|"pcap-dag.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_DAG_API */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SEPTEL_API
end_ifdef

begin_include
include|#
directive|include
file|"pcap-septel.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SEPTEL_API */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SNF_API
end_ifdef

begin_include
include|#
directive|include
file|"pcap-snf.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SNF_API */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TC_API
end_ifdef

begin_include
include|#
directive|include
file|"pcap-tc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TC_API */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_USB
end_ifdef

begin_include
include|#
directive|include
file|"pcap-usb-linux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_BT
end_ifdef

begin_include
include|#
directive|include
file|"pcap-bt-linux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_BT_MONITOR
end_ifdef

begin_include
include|#
directive|include
file|"pcap-bt-monitor-linux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_NETFILTER
end_ifdef

begin_include
include|#
directive|include
file|"pcap-netfilter-linux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_NETMAP
end_ifdef

begin_function_decl
name|pcap_t
modifier|*
name|pcap_netmap_create
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|,
name|int
modifier|*
name|is_ours
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_DBUS
end_ifdef

begin_include
include|#
directive|include
file|"pcap-dbus.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pcap_not_initialized
parameter_list|(
name|pcap_t
modifier|*
name|pcap
parameter_list|)
block|{
comment|/* in case the caller doesn't check for PCAP_ERROR_NOT_ACTIVATED */
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"This handle hasn't been activated yet"
argument_list|)
expr_stmt|;
comment|/* this means 'not initialized' */
return|return
operator|(
name|PCAP_ERROR_NOT_ACTIVATED
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
specifier|static
name|void
modifier|*
name|pcap_not_initialized_ptr
parameter_list|(
name|pcap_t
modifier|*
name|pcap
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"This handle hasn't been activated yet"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|HANDLE
name|pcap_getevent_not_initialized
parameter_list|(
name|pcap_t
modifier|*
name|pcap
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"This handle hasn't been activated yet"
argument_list|)
expr_stmt|;
return|return
operator|(
name|INVALID_HANDLE_VALUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|pcap_sendqueue_transmit_not_initialized
parameter_list|(
name|pcap_t
modifier|*
name|pcap
parameter_list|,
name|pcap_send_queue
modifier|*
name|queue
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"This handle hasn't been activated yet"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|PAirpcapHandle
name|pcap_get_airpcap_handle_not_initialized
parameter_list|(
name|pcap_t
modifier|*
name|pcap
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"This handle hasn't been activated yet"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Returns 1 if rfmon mode can be set on the pcap_t, 0 if it can't,  * a PCAP_ERROR value on an error.  */
end_comment

begin_function
name|int
name|pcap_can_set_rfmon
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|can_set_rfmon_op
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For systems where rfmon mode is never supported.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_cant_set_rfmon
parameter_list|(
name|pcap_t
modifier|*
name|p
name|_U_
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sets *tstamp_typesp to point to an array 1 or more supported time stamp  * types; the return value is the number of supported time stamp types.  * The list should be freed by a call to pcap_free_tstamp_types() when  * you're done with it.  *  * A return value of 0 means "you don't get a choice of time stamp type",  * in which case *tstamp_typesp is set to null.  *  * PCAP_ERROR is returned on error.  */
end_comment

begin_function
name|int
name|pcap_list_tstamp_types
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
modifier|*
name|tstamp_typesp
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|tstamp_type_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We don't support multiple time stamp types. 		 */
operator|*
name|tstamp_typesp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tstamp_typesp
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|tstamp_typesp
argument_list|)
argument_list|,
name|p
operator|->
name|tstamp_type_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tstamp_typesp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|*
name|tstamp_typesp
argument_list|,
name|p
operator|->
name|tstamp_type_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|tstamp_typesp
argument_list|)
operator|*
name|p
operator|->
name|tstamp_type_count
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|->
name|tstamp_type_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In Windows, you might have a library built with one version of the  * C runtime library and an application built with another version of  * the C runtime library, which means that the library might use one  * version of malloc() and free() and the application might use another  * version of malloc() and free().  If so, that means something  * allocated by the library cannot be freed by the application, so we  * need to have a pcap_free_tstamp_types() routine to free up the list  * allocated by pcap_list_tstamp_types(), even though it's just a wrapper  * around free().  */
end_comment

begin_function
name|void
name|pcap_free_tstamp_types
parameter_list|(
name|int
modifier|*
name|tstamp_type_list
parameter_list|)
block|{
name|free
argument_list|(
name|tstamp_type_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Default one-shot callback; overridden for capture types where the  * packet data cannot be guaranteed to be available after the callback  * returns, so that a copy must be made.  */
end_comment

begin_function
name|void
name|pcap_oneshot
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|oneshot_userdata
modifier|*
name|sp
init|=
operator|(
expr|struct
name|oneshot_userdata
operator|*
operator|)
name|user
decl_stmt|;
operator|*
name|sp
operator|->
name|hdr
operator|=
operator|*
name|h
expr_stmt|;
operator|*
name|sp
operator|->
name|pkt
operator|=
name|pkt
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|u_char
modifier|*
name|pcap_next
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|oneshot_userdata
name|s
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|pkt
decl_stmt|;
name|s
operator|.
name|hdr
operator|=
name|h
expr_stmt|;
name|s
operator|.
name|pkt
operator|=
operator|&
name|pkt
expr_stmt|;
name|s
operator|.
name|pd
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|pcap_dispatch
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|oneshot_callback
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|s
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pkt
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_next_ex
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
modifier|*
name|pkt_header
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
name|pkt_data
parameter_list|)
block|{
name|struct
name|oneshot_userdata
name|s
decl_stmt|;
name|s
operator|.
name|hdr
operator|=
operator|&
name|p
operator|->
name|pcap_header
expr_stmt|;
name|s
operator|.
name|pkt
operator|=
name|pkt_data
expr_stmt|;
name|s
operator|.
name|pd
operator|=
name|p
expr_stmt|;
comment|/* Saves a pointer to the packet headers */
operator|*
name|pkt_header
operator|=
operator|&
name|p
operator|->
name|pcap_header
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rfile
operator|!=
name|NULL
condition|)
block|{
name|int
name|status
decl_stmt|;
comment|/* We are on an offline capture */
name|status
operator|=
name|pcap_offline_read
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|oneshot_callback
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * Return codes for pcap_offline_read() are: 		 *   -  0: EOF 		 *   - -1: error 		 *   ->1: OK 		 * The first one ('0') conflicts with the return code of 		 * 0 from pcap_read() meaning "no packets arrived before 		 * the timeout expired", so we map it to -2 so you can 		 * distinguish between an EOF from a savefile and a 		 * "no packets arrived before the timeout expired, try 		 * again" from a live capture. 		 */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|else
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Return codes for pcap_read() are: 	 *   -  0: timeout 	 *   - -1: error 	 *   - -2: loop was broken out of with pcap_breakloop() 	 *   ->1: OK 	 * The first one ('0') conflicts with the return code of 0 from 	 * pcap_offline_read() meaning "end of file". 	*/
return|return
operator|(
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|oneshot_callback
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|capture_source_type
block|{
name|int
function_decl|(
modifier|*
name|findalldevs_op
function_decl|)
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|pcap_t
modifier|*
function_decl|(
modifier|*
name|create_op
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
block|}
name|capture_source_types
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_NETMAP
block|{
name|NULL
block|,
name|pcap_netmap_create
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_DAG_API
block|{
name|dag_findalldevs
block|,
name|dag_create
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SEPTEL_API
block|{
name|septel_findalldevs
block|,
name|septel_create
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SNF_API
block|{
name|snf_findalldevs
block|,
name|snf_create
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TC_API
block|{
name|TcFindAllDevs
block|,
name|TcCreate
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_BT
block|{
name|bt_findalldevs
block|,
name|bt_create
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_BT_MONITOR
block|{
name|bt_monitor_findalldevs
block|,
name|bt_monitor_create
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_USB
block|{
name|usb_findalldevs
block|,
name|usb_create
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_NETFILTER
block|{
name|netfilter_findalldevs
block|,
name|netfilter_create
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_DBUS
block|{
name|dbus_findalldevs
block|,
name|dbus_create
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Get a list of all capture sources that are up and that we can open.  * Returns -1 on error, 0 otherwise.  * The list, as returned through "alldevsp", may be null if no interfaces  * were up and could be opened.  */
end_comment

begin_function
name|int
name|pcap_findalldevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* 	 * Find all the local network interfaces on which we 	 * can capture. 	 */
if|if
condition|(
name|pcap_platform_finddevs
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Ask each of the non-local-network-interface capture 	 * source types what interfaces they have. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|capture_source_types
index|[
name|i
index|]
operator|.
name|findalldevs_op
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|capture_source_types
index|[
name|i
index|]
operator|.
name|findalldevs_op
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * We had an error; free the list we've been 			 * constructing. 			 */
if|if
condition|(
operator|*
name|alldevsp
operator|!=
name|NULL
condition|)
block|{
name|pcap_freealldevs
argument_list|(
operator|*
name|alldevsp
argument_list|)
expr_stmt|;
operator|*
name|alldevsp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_create
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|is_theirs
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|device_str
decl_stmt|;
comment|/* 	 * A null device name is equivalent to the "any" device - 	 * which might not be supported on this platform, but 	 * this means that you'll get a "not supported" error 	 * rather than, say, a crash when we try to dereference 	 * the null pointer. 	 */
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
name|device_str
operator|=
name|strdup
argument_list|(
literal|"any"
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|_WIN32
comment|/* 		 * If the string appears to be little-endian UCS-2/UTF-16, 		 * convert it to ASCII. 		 * 		 * XXX - to UTF-8 instead?  Or report an error if any 		 * character isn't ASCII? 		 */
if|if
condition|(
name|device
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|device
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|size_t
name|length
decl_stmt|;
name|length
operator|=
name|wcslen
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|device
argument_list|)
expr_stmt|;
name|device_str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_str
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pcap_snprintf
argument_list|(
name|device_str
argument_list|,
name|length
operator|+
literal|1
argument_list|,
literal|"%ws"
argument_list|,
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|device
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|device_str
operator|=
name|strdup
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|device_str
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Try each of the non-local-network-interface capture 	 * source types until we find one that works for this 	 * device or run out of types. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|capture_source_types
index|[
name|i
index|]
operator|.
name|create_op
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|is_theirs
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|capture_source_types
index|[
name|i
index|]
operator|.
name|create_op
argument_list|(
name|device_str
argument_list|,
name|errbuf
argument_list|,
operator|&
name|is_theirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_theirs
condition|)
block|{
comment|/* 			 * The device name refers to a device of the 			 * type in question; either it succeeded, 			 * in which case p refers to a pcap_t to 			 * later activate for the device, or it 			 * failed, in which case p is null and we 			 * should return that to report the failure 			 * to create. 			 */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * We assume the caller filled in errbuf. 				 */
name|free
argument_list|(
name|device_str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|opt
operator|.
name|device
operator|=
name|device_str
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
comment|/* 	 * OK, try it as a regular network interface. 	 */
name|p
operator|=
name|pcap_create_interface
argument_list|(
name|device_str
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We assume the caller filled in errbuf. 		 */
name|free
argument_list|(
name|device_str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|opt
operator|.
name|device
operator|=
name|device_str
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_ops
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * Set operation pointers for operations that only work on 	 * an activated pcap_t to point to a routine that returns 	 * a "this isn't activated" error. 	 */
name|p
operator|->
name|read_op
operator|=
operator|(
name|read_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|inject_op
operator|=
operator|(
name|inject_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setfilter_op
operator|=
operator|(
name|setfilter_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setdirection_op
operator|=
operator|(
name|setdirection_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|set_datalink_op
operator|=
operator|(
name|set_datalink_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|getnonblock_op
operator|=
operator|(
name|getnonblock_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setnonblock_op
operator|=
operator|(
name|setnonblock_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
operator|(
name|stats_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|p
operator|->
name|stats_ex_op
operator|=
operator|(
name|stats_ex_op_t
operator|)
name|pcap_not_initialized_ptr
expr_stmt|;
name|p
operator|->
name|setbuff_op
operator|=
operator|(
name|setbuff_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setmode_op
operator|=
operator|(
name|setmode_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setmintocopy_op
operator|=
operator|(
name|setmintocopy_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|getevent_op
operator|=
name|pcap_getevent_not_initialized
expr_stmt|;
name|p
operator|->
name|oid_get_request_op
operator|=
operator|(
name|oid_get_request_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|oid_set_request_op
operator|=
operator|(
name|oid_set_request_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|sendqueue_transmit_op
operator|=
name|pcap_sendqueue_transmit_not_initialized
expr_stmt|;
name|p
operator|->
name|setuserbuffer_op
operator|=
operator|(
name|setuserbuffer_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|live_dump_op
operator|=
operator|(
name|live_dump_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|live_dump_ended_op
operator|=
operator|(
name|live_dump_ended_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|get_airpcap_handle_op
operator|=
name|pcap_get_airpcap_handle_not_initialized
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Default cleanup operation - implementations can override 	 * this, but should call pcap_cleanup_live_common() after 	 * doing their own additional cleanup. 	 */
name|p
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_live_common
expr_stmt|;
comment|/* 	 * In most cases, the standard one-shot callback can 	 * be used for pcap_next()/pcap_next_ex(). 	 */
name|p
operator|->
name|oneshot_callback
operator|=
name|pcap_oneshot
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pcap_t
modifier|*
name|pcap_alloc_pcap_t
parameter_list|(
name|char
modifier|*
name|ebuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|chunk
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Allocate a chunk of memory big enough for a pcap_t 	 * plus a structure following it of size "size".  The 	 * structure following it is a private data structure 	 * for the routines that handle this pcap_t. 	 */
name|chunk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_t
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|chunk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap_t
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * Get a pointer to the pcap_t at the beginning. 	 */
name|p
operator|=
operator|(
name|pcap_t
operator|*
operator|)
name|chunk
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|p
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* not opened yet */
name|p
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* No private data was requested. */
name|p
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Set the pointer to the private data; that's the structure 		 * of size "size" following the pcap_t. 		 */
name|p
operator|->
name|priv
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|chunk
operator|+
sizeof|sizeof
argument_list|(
name|pcap_t
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_create_common
parameter_list|(
name|char
modifier|*
name|ebuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pcap_alloc_pcap_t
argument_list|(
name|ebuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Default to "can't set rfmon mode"; if it's supported by 	 * a platform, the create routine that called us can set 	 * the op to its routine to check whether a particular 	 * device supports it. 	 */
name|p
operator|->
name|can_set_rfmon_op
operator|=
name|pcap_cant_set_rfmon
expr_stmt|;
name|initialize_ops
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* put in some defaults*/
name|p
operator|->
name|snapshot
operator|=
name|MAXIMUM_SNAPLEN
expr_stmt|;
comment|/* max packet size */
name|p
operator|->
name|opt
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* no timeout specified */
name|p
operator|->
name|opt
operator|.
name|buffer_size
operator|=
literal|0
expr_stmt|;
comment|/* use the platform's default */
name|p
operator|->
name|opt
operator|.
name|promisc
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|rfmon
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|immediate
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|tstamp_type
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* default to not setting time stamp type */
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|=
name|PCAP_TSTAMP_PRECISION_MICRO
expr_stmt|;
comment|/* 	 * Start out with no BPF code generation flags set. 	 */
name|p
operator|->
name|bpf_codegen_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_check_activated
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|activated
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't perform "
literal|" operation on activated capture"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_snaplen
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|snaplen
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
comment|/* 	 * Turn invalid values, or excessively large values, into 	 * the maximum allowed value. 	 * 	 * If some application really *needs* a bigger snapshot 	 * length, we should just increase MAXIMUM_SNAPLEN. 	 */
if|if
condition|(
name|snaplen
operator|<=
literal|0
operator|||
name|snaplen
operator|>
name|MAXIMUM_SNAPLEN
condition|)
name|snaplen
operator|=
name|MAXIMUM_SNAPLEN
expr_stmt|;
name|p
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_promisc
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|promisc
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|p
operator|->
name|opt
operator|.
name|promisc
operator|=
name|promisc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_rfmon
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|rfmon
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|p
operator|->
name|opt
operator|.
name|rfmon
operator|=
name|rfmon
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_timeout
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|timeout_ms
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|p
operator|->
name|opt
operator|.
name|timeout
operator|=
name|timeout_ms
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_tstamp_type
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|tstamp_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
comment|/* 	 * The argument should have been u_int, but that's too late 	 * to change now - it's an API. 	 */
if|if
condition|(
name|tstamp_type
operator|<
literal|0
condition|)
return|return
operator|(
name|PCAP_WARNING_TSTAMP_TYPE_NOTSUP
operator|)
return|;
comment|/* 	 * If p->tstamp_type_count is 0, we only support PCAP_TSTAMP_HOST; 	 * the default time stamp type is PCAP_TSTAMP_HOST. 	 */
if|if
condition|(
name|p
operator|->
name|tstamp_type_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tstamp_type
operator|==
name|PCAP_TSTAMP_HOST
condition|)
block|{
name|p
operator|->
name|opt
operator|.
name|tstamp_type
operator|=
name|tstamp_type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Check whether we claim to support this type of time stamp. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|tstamp_type_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tstamp_type_list
index|[
name|i
index|]
operator|==
operator|(
name|u_int
operator|)
name|tstamp_type
condition|)
block|{
comment|/* 				 * Yes. 				 */
name|p
operator|->
name|opt
operator|.
name|tstamp_type
operator|=
name|tstamp_type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * We don't support this type of time stamp. 	 */
return|return
operator|(
name|PCAP_WARNING_TSTAMP_TYPE_NOTSUP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_immediate_mode
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|immediate
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|p
operator|->
name|opt
operator|.
name|immediate
operator|=
name|immediate
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_buffer_size
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|buffer_size
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
if|if
condition|(
name|buffer_size
operator|<=
literal|0
condition|)
block|{
comment|/* 		 * Silently ignore invalid values. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|->
name|opt
operator|.
name|buffer_size
operator|=
name|buffer_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_tstamp_precision
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|tstamp_precision
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
comment|/* 	 * The argument should have been u_int, but that's too late 	 * to change now - it's an API. 	 */
if|if
condition|(
name|tstamp_precision
operator|<
literal|0
condition|)
return|return
operator|(
name|PCAP_ERROR_TSTAMP_PRECISION_NOTSUP
operator|)
return|;
comment|/* 	 * If p->tstamp_precision_count is 0, we only support setting 	 * the time stamp precision to microsecond precision; every 	 * pcap module *MUST* support microsecond precision, even if 	 * it does so by converting the native precision to 	 * microseconds. 	 */
if|if
condition|(
name|p
operator|->
name|tstamp_precision_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tstamp_precision
operator|==
name|PCAP_TSTAMP_PRECISION_MICRO
condition|)
block|{
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|=
name|tstamp_precision
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Check whether we claim to support this precision of 		 * time stamp. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|tstamp_precision_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tstamp_precision_list
index|[
name|i
index|]
operator|==
operator|(
name|u_int
operator|)
name|tstamp_precision
condition|)
block|{
comment|/* 				 * Yes. 				 */
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|=
name|tstamp_precision
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * We don't support this time stamp precision. 	 */
return|return
operator|(
name|PCAP_ERROR_TSTAMP_PRECISION_NOTSUP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_get_tstamp_precision
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_activate
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
comment|/* 	 * Catch attempts to re-activate an already-activated 	 * pcap_t; this should, for example, catch code that 	 * calls pcap_open_live() followed by pcap_activate(), 	 * as some code that showed up in a Stack Exchange 	 * question did. 	 */
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|status
operator|=
name|p
operator|->
name|activate_op
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
name|p
operator|->
name|activated
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|errbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 			 * No error message supplied by the activate routine; 			 * for the benefit of programs that don't specially 			 * handle errors other than PCAP_ERROR, return the 			 * error message corresponding to the status. 			 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s"
argument_list|,
name|pcap_statustostr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Undo any operation pointer setting, etc. done by 		 * the activate operation. 		 */
name|initialize_ops
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_live
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|int
name|status
decl_stmt|;
name|p
operator|=
name|pcap_create
argument_list|(
name|device
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|status
operator|=
name|pcap_set_snaplen
argument_list|(
name|p
argument_list|,
name|snaplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|pcap_set_promisc
argument_list|(
name|p
argument_list|,
name|promisc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|pcap_set_timeout
argument_list|(
name|p
argument_list|,
name|to_ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Mark this as opened with pcap_open_live(), so that, for 	 * example, we show the full list of DLT_ values, rather 	 * than just the ones that are compatible with capturing 	 * when not in monitor mode.  That allows existing applications 	 * to work the way they used to work, but allows new applications 	 * that know about the new open API to, for example, find out the 	 * DLT_ values that they can select without changing whether 	 * the adapter is in monitor mode or not. 	 */
name|p
operator|->
name|oldstyle
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|pcap_activate
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
name|p
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|status
operator|==
name|PCAP_ERROR
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|device
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|||
name|status
operator|==
name|PCAP_ERROR_PERM_DENIED
operator|||
name|status
operator|==
name|PCAP_ERROR_PROMISC_PERM_DENIED
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s (%s)"
argument_list|,
name|device
argument_list|,
name|pcap_statustostr
argument_list|(
name|status
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
else|else
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_statustostr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|pcap_close
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_offline_common
parameter_list|(
name|char
modifier|*
name|ebuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pcap_alloc_pcap_t
argument_list|(
name|ebuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|=
name|PCAP_TSTAMP_PRECISION_MICRO
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_dispatch
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_loop
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|->
name|rfile
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * 0 means EOF, so don't loop if we get 0. 			 */
name|n
operator|=
name|pcap_offline_read
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXX keep reading until we get something 			 * (or an error occurs) 			 */
do|do
block|{
name|n
operator|=
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
if|if
condition|(
operator|!
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|cnt
argument_list|)
condition|)
block|{
name|cnt
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Force the loop in "pcap_read()" or "pcap_read_offline()" to terminate.  */
end_comment

begin_function
name|void
name|pcap_breakloop
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|p
operator|->
name|break_loop
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcap_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|activated
condition|)
return|return
operator|(
name|PCAP_ERROR_NOT_ACTIVATED
operator|)
return|;
return|return
operator|(
name|p
operator|->
name|linktype
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_datalink_ext
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|activated
condition|)
return|return
operator|(
name|PCAP_ERROR_NOT_ACTIVATED
operator|)
return|;
return|return
operator|(
name|p
operator|->
name|linktype_ext
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_list_datalinks
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
modifier|*
name|dlt_buffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|activated
condition|)
return|return
operator|(
name|PCAP_ERROR_NOT_ACTIVATED
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|dlt_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We couldn't fetch the list of DLTs, which means 		 * this platform doesn't support changing the 		 * DLT for an interface.  Return a list of DLTs 		 * containing only the DLT this device supports. 		 */
operator|*
name|dlt_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dlt_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dlt_buffer
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
operator|*
operator|*
name|dlt_buffer
operator|=
name|p
operator|->
name|linktype
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|*
name|dlt_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dlt_buffer
argument_list|)
argument_list|,
name|p
operator|->
name|dlt_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dlt_buffer
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|*
name|dlt_buffer
argument_list|,
name|p
operator|->
name|dlt_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dlt_buffer
argument_list|)
operator|*
name|p
operator|->
name|dlt_count
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|dlt_count
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * In Windows, you might have a library built with one version of the  * C runtime library and an application built with another version of  * the C runtime library, which means that the library might use one  * version of malloc() and free() and the application might use another  * version of malloc() and free().  If so, that means something  * allocated by the library cannot be freed by the application, so we  * need to have a pcap_free_datalinks() routine to free up the list  * allocated by pcap_list_datalinks(), even though it's just a wrapper  * around free().  */
end_comment

begin_function
name|void
name|pcap_free_datalinks
parameter_list|(
name|int
modifier|*
name|dlt_list
parameter_list|)
block|{
name|free
argument_list|(
name|dlt_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcap_set_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|dlt_name
decl_stmt|;
if|if
condition|(
name|dlt
operator|<
literal|0
condition|)
goto|goto
name|unsupported
goto|;
if|if
condition|(
name|p
operator|->
name|dlt_count
operator|==
literal|0
operator|||
name|p
operator|->
name|set_datalink_op
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We couldn't fetch the list of DLTs, or we don't 		 * have a "set datalink" operation, which means 		 * this platform doesn't support changing the 		 * DLT for an interface.  Check whether the new 		 * DLT is the one this interface supports. 		 */
if|if
condition|(
name|p
operator|->
name|linktype
operator|!=
name|dlt
condition|)
goto|goto
name|unsupported
goto|;
comment|/* 		 * It is, so there's nothing we need to do here. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|dlt_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dlt_list
index|[
name|i
index|]
operator|==
operator|(
name|u_int
operator|)
name|dlt
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|p
operator|->
name|dlt_count
condition|)
goto|goto
name|unsupported
goto|;
if|if
condition|(
name|p
operator|->
name|dlt_count
operator|==
literal|2
operator|&&
name|p
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|==
name|DLT_EN10MB
operator|&&
name|dlt
operator|==
name|DLT_DOCSIS
condition|)
block|{
comment|/* 		 * This is presumably an Ethernet device, as the first 		 * link-layer type it offers is DLT_EN10MB, and the only 		 * other type it offers is DLT_DOCSIS.  That means that 		 * we can't tell the driver to supply DOCSIS link-layer 		 * headers - we're just pretending that's what we're 		 * getting, as, presumably, we're capturing on a dedicated 		 * link to a Cisco Cable Modem Termination System, and 		 * it's putting raw DOCSIS frames on the wire inside low-level 		 * Ethernet framing. 		 */
name|p
operator|->
name|linktype
operator|=
name|dlt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|set_datalink_op
argument_list|(
name|p
argument_list|,
name|dlt
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|->
name|linktype
operator|=
name|dlt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|unsupported
label|:
name|dlt_name
operator|=
name|pcap_datalink_val_to_name
argument_list|(
name|dlt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlt_name
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"%s is not one of the DLTs supported by this device"
argument_list|,
name|dlt_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"DLT %d is not one of the DLTs supported by this device"
argument_list|,
name|dlt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This array is designed for mapping upper and lower case letter  * together for a case independent comparison.  The mappings are  * based upon ascii character sequences.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|charmap
index|[]
init|=
block|{
operator|(
name|u_char
operator|)
literal|'\000'
block|,
operator|(
name|u_char
operator|)
literal|'\001'
block|,
operator|(
name|u_char
operator|)
literal|'\002'
block|,
operator|(
name|u_char
operator|)
literal|'\003'
block|,
operator|(
name|u_char
operator|)
literal|'\004'
block|,
operator|(
name|u_char
operator|)
literal|'\005'
block|,
operator|(
name|u_char
operator|)
literal|'\006'
block|,
operator|(
name|u_char
operator|)
literal|'\007'
block|,
operator|(
name|u_char
operator|)
literal|'\010'
block|,
operator|(
name|u_char
operator|)
literal|'\011'
block|,
operator|(
name|u_char
operator|)
literal|'\012'
block|,
operator|(
name|u_char
operator|)
literal|'\013'
block|,
operator|(
name|u_char
operator|)
literal|'\014'
block|,
operator|(
name|u_char
operator|)
literal|'\015'
block|,
operator|(
name|u_char
operator|)
literal|'\016'
block|,
operator|(
name|u_char
operator|)
literal|'\017'
block|,
operator|(
name|u_char
operator|)
literal|'\020'
block|,
operator|(
name|u_char
operator|)
literal|'\021'
block|,
operator|(
name|u_char
operator|)
literal|'\022'
block|,
operator|(
name|u_char
operator|)
literal|'\023'
block|,
operator|(
name|u_char
operator|)
literal|'\024'
block|,
operator|(
name|u_char
operator|)
literal|'\025'
block|,
operator|(
name|u_char
operator|)
literal|'\026'
block|,
operator|(
name|u_char
operator|)
literal|'\027'
block|,
operator|(
name|u_char
operator|)
literal|'\030'
block|,
operator|(
name|u_char
operator|)
literal|'\031'
block|,
operator|(
name|u_char
operator|)
literal|'\032'
block|,
operator|(
name|u_char
operator|)
literal|'\033'
block|,
operator|(
name|u_char
operator|)
literal|'\034'
block|,
operator|(
name|u_char
operator|)
literal|'\035'
block|,
operator|(
name|u_char
operator|)
literal|'\036'
block|,
operator|(
name|u_char
operator|)
literal|'\037'
block|,
operator|(
name|u_char
operator|)
literal|'\040'
block|,
operator|(
name|u_char
operator|)
literal|'\041'
block|,
operator|(
name|u_char
operator|)
literal|'\042'
block|,
operator|(
name|u_char
operator|)
literal|'\043'
block|,
operator|(
name|u_char
operator|)
literal|'\044'
block|,
operator|(
name|u_char
operator|)
literal|'\045'
block|,
operator|(
name|u_char
operator|)
literal|'\046'
block|,
operator|(
name|u_char
operator|)
literal|'\047'
block|,
operator|(
name|u_char
operator|)
literal|'\050'
block|,
operator|(
name|u_char
operator|)
literal|'\051'
block|,
operator|(
name|u_char
operator|)
literal|'\052'
block|,
operator|(
name|u_char
operator|)
literal|'\053'
block|,
operator|(
name|u_char
operator|)
literal|'\054'
block|,
operator|(
name|u_char
operator|)
literal|'\055'
block|,
operator|(
name|u_char
operator|)
literal|'\056'
block|,
operator|(
name|u_char
operator|)
literal|'\057'
block|,
operator|(
name|u_char
operator|)
literal|'\060'
block|,
operator|(
name|u_char
operator|)
literal|'\061'
block|,
operator|(
name|u_char
operator|)
literal|'\062'
block|,
operator|(
name|u_char
operator|)
literal|'\063'
block|,
operator|(
name|u_char
operator|)
literal|'\064'
block|,
operator|(
name|u_char
operator|)
literal|'\065'
block|,
operator|(
name|u_char
operator|)
literal|'\066'
block|,
operator|(
name|u_char
operator|)
literal|'\067'
block|,
operator|(
name|u_char
operator|)
literal|'\070'
block|,
operator|(
name|u_char
operator|)
literal|'\071'
block|,
operator|(
name|u_char
operator|)
literal|'\072'
block|,
operator|(
name|u_char
operator|)
literal|'\073'
block|,
operator|(
name|u_char
operator|)
literal|'\074'
block|,
operator|(
name|u_char
operator|)
literal|'\075'
block|,
operator|(
name|u_char
operator|)
literal|'\076'
block|,
operator|(
name|u_char
operator|)
literal|'\077'
block|,
operator|(
name|u_char
operator|)
literal|'\100'
block|,
operator|(
name|u_char
operator|)
literal|'\141'
block|,
operator|(
name|u_char
operator|)
literal|'\142'
block|,
operator|(
name|u_char
operator|)
literal|'\143'
block|,
operator|(
name|u_char
operator|)
literal|'\144'
block|,
operator|(
name|u_char
operator|)
literal|'\145'
block|,
operator|(
name|u_char
operator|)
literal|'\146'
block|,
operator|(
name|u_char
operator|)
literal|'\147'
block|,
operator|(
name|u_char
operator|)
literal|'\150'
block|,
operator|(
name|u_char
operator|)
literal|'\151'
block|,
operator|(
name|u_char
operator|)
literal|'\152'
block|,
operator|(
name|u_char
operator|)
literal|'\153'
block|,
operator|(
name|u_char
operator|)
literal|'\154'
block|,
operator|(
name|u_char
operator|)
literal|'\155'
block|,
operator|(
name|u_char
operator|)
literal|'\156'
block|,
operator|(
name|u_char
operator|)
literal|'\157'
block|,
operator|(
name|u_char
operator|)
literal|'\160'
block|,
operator|(
name|u_char
operator|)
literal|'\161'
block|,
operator|(
name|u_char
operator|)
literal|'\162'
block|,
operator|(
name|u_char
operator|)
literal|'\163'
block|,
operator|(
name|u_char
operator|)
literal|'\164'
block|,
operator|(
name|u_char
operator|)
literal|'\165'
block|,
operator|(
name|u_char
operator|)
literal|'\166'
block|,
operator|(
name|u_char
operator|)
literal|'\167'
block|,
operator|(
name|u_char
operator|)
literal|'\170'
block|,
operator|(
name|u_char
operator|)
literal|'\171'
block|,
operator|(
name|u_char
operator|)
literal|'\172'
block|,
operator|(
name|u_char
operator|)
literal|'\133'
block|,
operator|(
name|u_char
operator|)
literal|'\134'
block|,
operator|(
name|u_char
operator|)
literal|'\135'
block|,
operator|(
name|u_char
operator|)
literal|'\136'
block|,
operator|(
name|u_char
operator|)
literal|'\137'
block|,
operator|(
name|u_char
operator|)
literal|'\140'
block|,
operator|(
name|u_char
operator|)
literal|'\141'
block|,
operator|(
name|u_char
operator|)
literal|'\142'
block|,
operator|(
name|u_char
operator|)
literal|'\143'
block|,
operator|(
name|u_char
operator|)
literal|'\144'
block|,
operator|(
name|u_char
operator|)
literal|'\145'
block|,
operator|(
name|u_char
operator|)
literal|'\146'
block|,
operator|(
name|u_char
operator|)
literal|'\147'
block|,
operator|(
name|u_char
operator|)
literal|'\150'
block|,
operator|(
name|u_char
operator|)
literal|'\151'
block|,
operator|(
name|u_char
operator|)
literal|'\152'
block|,
operator|(
name|u_char
operator|)
literal|'\153'
block|,
operator|(
name|u_char
operator|)
literal|'\154'
block|,
operator|(
name|u_char
operator|)
literal|'\155'
block|,
operator|(
name|u_char
operator|)
literal|'\156'
block|,
operator|(
name|u_char
operator|)
literal|'\157'
block|,
operator|(
name|u_char
operator|)
literal|'\160'
block|,
operator|(
name|u_char
operator|)
literal|'\161'
block|,
operator|(
name|u_char
operator|)
literal|'\162'
block|,
operator|(
name|u_char
operator|)
literal|'\163'
block|,
operator|(
name|u_char
operator|)
literal|'\164'
block|,
operator|(
name|u_char
operator|)
literal|'\165'
block|,
operator|(
name|u_char
operator|)
literal|'\166'
block|,
operator|(
name|u_char
operator|)
literal|'\167'
block|,
operator|(
name|u_char
operator|)
literal|'\170'
block|,
operator|(
name|u_char
operator|)
literal|'\171'
block|,
operator|(
name|u_char
operator|)
literal|'\172'
block|,
operator|(
name|u_char
operator|)
literal|'\173'
block|,
operator|(
name|u_char
operator|)
literal|'\174'
block|,
operator|(
name|u_char
operator|)
literal|'\175'
block|,
operator|(
name|u_char
operator|)
literal|'\176'
block|,
operator|(
name|u_char
operator|)
literal|'\177'
block|,
operator|(
name|u_char
operator|)
literal|'\200'
block|,
operator|(
name|u_char
operator|)
literal|'\201'
block|,
operator|(
name|u_char
operator|)
literal|'\202'
block|,
operator|(
name|u_char
operator|)
literal|'\203'
block|,
operator|(
name|u_char
operator|)
literal|'\204'
block|,
operator|(
name|u_char
operator|)
literal|'\205'
block|,
operator|(
name|u_char
operator|)
literal|'\206'
block|,
operator|(
name|u_char
operator|)
literal|'\207'
block|,
operator|(
name|u_char
operator|)
literal|'\210'
block|,
operator|(
name|u_char
operator|)
literal|'\211'
block|,
operator|(
name|u_char
operator|)
literal|'\212'
block|,
operator|(
name|u_char
operator|)
literal|'\213'
block|,
operator|(
name|u_char
operator|)
literal|'\214'
block|,
operator|(
name|u_char
operator|)
literal|'\215'
block|,
operator|(
name|u_char
operator|)
literal|'\216'
block|,
operator|(
name|u_char
operator|)
literal|'\217'
block|,
operator|(
name|u_char
operator|)
literal|'\220'
block|,
operator|(
name|u_char
operator|)
literal|'\221'
block|,
operator|(
name|u_char
operator|)
literal|'\222'
block|,
operator|(
name|u_char
operator|)
literal|'\223'
block|,
operator|(
name|u_char
operator|)
literal|'\224'
block|,
operator|(
name|u_char
operator|)
literal|'\225'
block|,
operator|(
name|u_char
operator|)
literal|'\226'
block|,
operator|(
name|u_char
operator|)
literal|'\227'
block|,
operator|(
name|u_char
operator|)
literal|'\230'
block|,
operator|(
name|u_char
operator|)
literal|'\231'
block|,
operator|(
name|u_char
operator|)
literal|'\232'
block|,
operator|(
name|u_char
operator|)
literal|'\233'
block|,
operator|(
name|u_char
operator|)
literal|'\234'
block|,
operator|(
name|u_char
operator|)
literal|'\235'
block|,
operator|(
name|u_char
operator|)
literal|'\236'
block|,
operator|(
name|u_char
operator|)
literal|'\237'
block|,
operator|(
name|u_char
operator|)
literal|'\240'
block|,
operator|(
name|u_char
operator|)
literal|'\241'
block|,
operator|(
name|u_char
operator|)
literal|'\242'
block|,
operator|(
name|u_char
operator|)
literal|'\243'
block|,
operator|(
name|u_char
operator|)
literal|'\244'
block|,
operator|(
name|u_char
operator|)
literal|'\245'
block|,
operator|(
name|u_char
operator|)
literal|'\246'
block|,
operator|(
name|u_char
operator|)
literal|'\247'
block|,
operator|(
name|u_char
operator|)
literal|'\250'
block|,
operator|(
name|u_char
operator|)
literal|'\251'
block|,
operator|(
name|u_char
operator|)
literal|'\252'
block|,
operator|(
name|u_char
operator|)
literal|'\253'
block|,
operator|(
name|u_char
operator|)
literal|'\254'
block|,
operator|(
name|u_char
operator|)
literal|'\255'
block|,
operator|(
name|u_char
operator|)
literal|'\256'
block|,
operator|(
name|u_char
operator|)
literal|'\257'
block|,
operator|(
name|u_char
operator|)
literal|'\260'
block|,
operator|(
name|u_char
operator|)
literal|'\261'
block|,
operator|(
name|u_char
operator|)
literal|'\262'
block|,
operator|(
name|u_char
operator|)
literal|'\263'
block|,
operator|(
name|u_char
operator|)
literal|'\264'
block|,
operator|(
name|u_char
operator|)
literal|'\265'
block|,
operator|(
name|u_char
operator|)
literal|'\266'
block|,
operator|(
name|u_char
operator|)
literal|'\267'
block|,
operator|(
name|u_char
operator|)
literal|'\270'
block|,
operator|(
name|u_char
operator|)
literal|'\271'
block|,
operator|(
name|u_char
operator|)
literal|'\272'
block|,
operator|(
name|u_char
operator|)
literal|'\273'
block|,
operator|(
name|u_char
operator|)
literal|'\274'
block|,
operator|(
name|u_char
operator|)
literal|'\275'
block|,
operator|(
name|u_char
operator|)
literal|'\276'
block|,
operator|(
name|u_char
operator|)
literal|'\277'
block|,
operator|(
name|u_char
operator|)
literal|'\300'
block|,
operator|(
name|u_char
operator|)
literal|'\341'
block|,
operator|(
name|u_char
operator|)
literal|'\342'
block|,
operator|(
name|u_char
operator|)
literal|'\343'
block|,
operator|(
name|u_char
operator|)
literal|'\344'
block|,
operator|(
name|u_char
operator|)
literal|'\345'
block|,
operator|(
name|u_char
operator|)
literal|'\346'
block|,
operator|(
name|u_char
operator|)
literal|'\347'
block|,
operator|(
name|u_char
operator|)
literal|'\350'
block|,
operator|(
name|u_char
operator|)
literal|'\351'
block|,
operator|(
name|u_char
operator|)
literal|'\352'
block|,
operator|(
name|u_char
operator|)
literal|'\353'
block|,
operator|(
name|u_char
operator|)
literal|'\354'
block|,
operator|(
name|u_char
operator|)
literal|'\355'
block|,
operator|(
name|u_char
operator|)
literal|'\356'
block|,
operator|(
name|u_char
operator|)
literal|'\357'
block|,
operator|(
name|u_char
operator|)
literal|'\360'
block|,
operator|(
name|u_char
operator|)
literal|'\361'
block|,
operator|(
name|u_char
operator|)
literal|'\362'
block|,
operator|(
name|u_char
operator|)
literal|'\363'
block|,
operator|(
name|u_char
operator|)
literal|'\364'
block|,
operator|(
name|u_char
operator|)
literal|'\365'
block|,
operator|(
name|u_char
operator|)
literal|'\366'
block|,
operator|(
name|u_char
operator|)
literal|'\367'
block|,
operator|(
name|u_char
operator|)
literal|'\370'
block|,
operator|(
name|u_char
operator|)
literal|'\371'
block|,
operator|(
name|u_char
operator|)
literal|'\372'
block|,
operator|(
name|u_char
operator|)
literal|'\333'
block|,
operator|(
name|u_char
operator|)
literal|'\334'
block|,
operator|(
name|u_char
operator|)
literal|'\335'
block|,
operator|(
name|u_char
operator|)
literal|'\336'
block|,
operator|(
name|u_char
operator|)
literal|'\337'
block|,
operator|(
name|u_char
operator|)
literal|'\340'
block|,
operator|(
name|u_char
operator|)
literal|'\341'
block|,
operator|(
name|u_char
operator|)
literal|'\342'
block|,
operator|(
name|u_char
operator|)
literal|'\343'
block|,
operator|(
name|u_char
operator|)
literal|'\344'
block|,
operator|(
name|u_char
operator|)
literal|'\345'
block|,
operator|(
name|u_char
operator|)
literal|'\346'
block|,
operator|(
name|u_char
operator|)
literal|'\347'
block|,
operator|(
name|u_char
operator|)
literal|'\350'
block|,
operator|(
name|u_char
operator|)
literal|'\351'
block|,
operator|(
name|u_char
operator|)
literal|'\352'
block|,
operator|(
name|u_char
operator|)
literal|'\353'
block|,
operator|(
name|u_char
operator|)
literal|'\354'
block|,
operator|(
name|u_char
operator|)
literal|'\355'
block|,
operator|(
name|u_char
operator|)
literal|'\356'
block|,
operator|(
name|u_char
operator|)
literal|'\357'
block|,
operator|(
name|u_char
operator|)
literal|'\360'
block|,
operator|(
name|u_char
operator|)
literal|'\361'
block|,
operator|(
name|u_char
operator|)
literal|'\362'
block|,
operator|(
name|u_char
operator|)
literal|'\363'
block|,
operator|(
name|u_char
operator|)
literal|'\364'
block|,
operator|(
name|u_char
operator|)
literal|'\365'
block|,
operator|(
name|u_char
operator|)
literal|'\366'
block|,
operator|(
name|u_char
operator|)
literal|'\367'
block|,
operator|(
name|u_char
operator|)
literal|'\370'
block|,
operator|(
name|u_char
operator|)
literal|'\371'
block|,
operator|(
name|u_char
operator|)
literal|'\372'
block|,
operator|(
name|u_char
operator|)
literal|'\373'
block|,
operator|(
name|u_char
operator|)
literal|'\374'
block|,
operator|(
name|u_char
operator|)
literal|'\375'
block|,
operator|(
name|u_char
operator|)
literal|'\376'
block|,
operator|(
name|u_char
operator|)
literal|'\377'
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcap_strcasecmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
specifier|register
specifier|const
name|u_char
modifier|*
name|cm
init|=
name|charmap
decl_stmt|,
modifier|*
name|us1
init|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|s1
decl_stmt|,
modifier|*
name|us2
init|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|cm
index|[
operator|*
name|us1
index|]
operator|==
name|cm
index|[
operator|*
name|us2
operator|++
index|]
condition|)
if|if
condition|(
operator|*
name|us1
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|cm
index|[
operator|*
name|us1
index|]
operator|-
name|cm
index|[
operator|*
operator|--
name|us2
index|]
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|dlt_choice
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
name|int
name|dlt
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DLT_CHOICE
parameter_list|(
name|code
parameter_list|,
name|description
parameter_list|)
value|{ #code, description, DLT_ ## code }
end_define

begin_define
define|#
directive|define
name|DLT_CHOICE_SENTINEL
value|{ NULL, NULL, 0 }
end_define

begin_decl_stmt
specifier|static
name|struct
name|dlt_choice
name|dlt_choices
index|[]
init|=
block|{
name|DLT_CHOICE
argument_list|(
name|NULL
argument_list|,
literal|"BSD loopback"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|EN10MB
argument_list|,
literal|"Ethernet"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802
argument_list|,
literal|"Token ring"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ARCNET
argument_list|,
literal|"BSD ARCNET"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|SLIP
argument_list|,
literal|"SLIP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PPP
argument_list|,
literal|"PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|FDDI
argument_list|,
literal|"FDDI"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ATM_RFC1483
argument_list|,
literal|"RFC 1483 LLC-encapsulated ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|RAW
argument_list|,
literal|"Raw IP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|SLIP_BSDOS
argument_list|,
literal|"BSD/OS SLIP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PPP_BSDOS
argument_list|,
literal|"BSD/OS PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ATM_CLIP
argument_list|,
literal|"Linux Classical IP-over-ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PPP_SERIAL
argument_list|,
literal|"PPP over serial"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PPP_ETHER
argument_list|,
literal|"PPPoE"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|SYMANTEC_FIREWALL
argument_list|,
literal|"Symantec Firewall"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|C_HDLC
argument_list|,
literal|"Cisco HDLC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802_11
argument_list|,
literal|"802.11"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|FRELAY
argument_list|,
literal|"Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|LOOP
argument_list|,
literal|"OpenBSD loopback"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ENC
argument_list|,
literal|"OpenBSD encapsulated IP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|LINUX_SLL
argument_list|,
literal|"Linux cooked"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|LTALK
argument_list|,
literal|"Localtalk"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PFLOG
argument_list|,
literal|"OpenBSD pflog file"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PFSYNC
argument_list|,
literal|"Packet filter state syncing"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PRISM_HEADER
argument_list|,
literal|"802.11 plus Prism header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IP_OVER_FC
argument_list|,
literal|"RFC 2625 IP-over-Fibre Channel"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|SUNATM
argument_list|,
literal|"Sun raw ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802_11_RADIO
argument_list|,
literal|"802.11 plus radiotap header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ARCNET_LINUX
argument_list|,
literal|"Linux ARCNET"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_MLPPP
argument_list|,
literal|"Juniper Multi-Link PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_MLFR
argument_list|,
literal|"Juniper Multi-Link Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_ES
argument_list|,
literal|"Juniper Encryption Services PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_GGSN
argument_list|,
literal|"Juniper GGSN PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_MFR
argument_list|,
literal|"Juniper FRF.16 Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_ATM2
argument_list|,
literal|"Juniper ATM2 PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_SERVICES
argument_list|,
literal|"Juniper Advanced Services PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_ATM1
argument_list|,
literal|"Juniper ATM1 PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|APPLE_IP_OVER_IEEE1394
argument_list|,
literal|"Apple IP-over-IEEE 1394"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|MTP2_WITH_PHDR
argument_list|,
literal|"SS7 MTP2 with Pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|MTP2
argument_list|,
literal|"SS7 MTP2"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|MTP3
argument_list|,
literal|"SS7 MTP3"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|SCCP
argument_list|,
literal|"SS7 SCCP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DOCSIS
argument_list|,
literal|"DOCSIS"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|LINUX_IRDA
argument_list|,
literal|"Linux IrDA"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802_11_RADIO_AVS
argument_list|,
literal|"802.11 plus AVS radio information header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_MONITOR
argument_list|,
literal|"Juniper Passive Monitor PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|BACNET_MS_TP
argument_list|,
literal|"BACnet MS/TP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PPP_PPPD
argument_list|,
literal|"PPP for pppd, with direction flag"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_PPPOE
argument_list|,
literal|"Juniper PPPoE"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_PPPOE_ATM
argument_list|,
literal|"Juniper PPPoE/ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|GPRS_LLC
argument_list|,
literal|"GPRS LLC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|GPF_T
argument_list|,
literal|"GPF-T"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|GPF_F
argument_list|,
literal|"GPF-F"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_PIC_PEER
argument_list|,
literal|"Juniper PIC Peer"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ERF_ETH
argument_list|,
literal|"Ethernet with Endace ERF header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ERF_POS
argument_list|,
literal|"Packet-over-SONET with Endace ERF header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|LINUX_LAPD
argument_list|,
literal|"Linux vISDN LAPD"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_ETHER
argument_list|,
literal|"Juniper Ethernet"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_PPP
argument_list|,
literal|"Juniper PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_FRELAY
argument_list|,
literal|"Juniper Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_CHDLC
argument_list|,
literal|"Juniper C-HDLC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|MFR
argument_list|,
literal|"FRF.16 Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_VP
argument_list|,
literal|"Juniper Voice PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|A429
argument_list|,
literal|"Arinc 429"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|A653_ICM
argument_list|,
literal|"Arinc 653 Interpartition Communication"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|USB_FREEBSD
argument_list|,
literal|"USB with FreeBSD header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|BLUETOOTH_HCI_H4
argument_list|,
literal|"Bluetooth HCI UART transport layer"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802_16_MAC_CPS
argument_list|,
literal|"IEEE 802.16 MAC Common Part Sublayer"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|USB_LINUX
argument_list|,
literal|"USB with Linux header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|CAN20B
argument_list|,
literal|"Controller Area Network (CAN) v. 2.0B"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802_15_4_LINUX
argument_list|,
literal|"IEEE 802.15.4 with Linux padding"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PPI
argument_list|,
literal|"Per-Packet Information"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802_16_MAC_CPS_RADIO
argument_list|,
literal|"IEEE 802.16 MAC Common Part Sublayer plus radiotap header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_ISM
argument_list|,
literal|"Juniper Integrated Service Module"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802_15_4
argument_list|,
literal|"IEEE 802.15.4 with FCS"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|SITA
argument_list|,
literal|"SITA pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ERF
argument_list|,
literal|"Endace ERF header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|RAIF1
argument_list|,
literal|"Ethernet with u10 Networks pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IPMB
argument_list|,
literal|"IPMB"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_ST
argument_list|,
literal|"Juniper Secure Tunnel"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|BLUETOOTH_HCI_H4_WITH_PHDR
argument_list|,
literal|"Bluetooth HCI UART transport layer plus pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|AX25_KISS
argument_list|,
literal|"AX.25 with KISS header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802_15_4_NONASK_PHY
argument_list|,
literal|"IEEE 802.15.4 with non-ASK PHY data"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|MPLS
argument_list|,
literal|"MPLS with label as link-layer header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|LINUX_EVDEV
argument_list|,
literal|"Linux evdev events"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|USB_LINUX_MMAPPED
argument_list|,
literal|"USB with padded Linux header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DECT
argument_list|,
literal|"DECT"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|AOS
argument_list|,
literal|"AOS Space Data Link protocol"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|WIHART
argument_list|,
literal|"Wireless HART"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|FC_2
argument_list|,
literal|"Fibre Channel FC-2"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|FC_2_WITH_FRAME_DELIMS
argument_list|,
literal|"Fibre Channel FC-2 with frame delimiters"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IPNET
argument_list|,
literal|"Solaris ipnet"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|CAN_SOCKETCAN
argument_list|,
literal|"CAN-bus with SocketCAN headers"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IPV4
argument_list|,
literal|"Raw IPv4"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IPV6
argument_list|,
literal|"Raw IPv6"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IEEE802_15_4_NOFCS
argument_list|,
literal|"IEEE 802.15.4 without FCS"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DBUS
argument_list|,
literal|"D-Bus"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_VS
argument_list|,
literal|"Juniper Virtual Server"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_SRX_E2E
argument_list|,
literal|"Juniper SRX E2E"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_FIBRECHANNEL
argument_list|,
literal|"Juniper Fibre Channel"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DVB_CI
argument_list|,
literal|"DVB-CI"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|MUX27010
argument_list|,
literal|"MUX27010"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|STANAG_5066_D_PDU
argument_list|,
literal|"STANAG 5066 D_PDUs"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|JUNIPER_ATM_CEMIC
argument_list|,
literal|"Juniper ATM CEMIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|NFLOG
argument_list|,
literal|"Linux netfilter log messages"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|NETANALYZER
argument_list|,
literal|"Ethernet with Hilscher netANALYZER pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|NETANALYZER_TRANSPARENT
argument_list|,
literal|"Ethernet with Hilscher netANALYZER pseudo-header and with preamble and SFD"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IPOIB
argument_list|,
literal|"RFC 4391 IP-over-Infiniband"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|MPEG_2_TS
argument_list|,
literal|"MPEG-2 transport stream"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|NG40
argument_list|,
literal|"ng40 protocol tester Iub/Iur"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|NFC_LLCP
argument_list|,
literal|"NFC LLCP PDUs with pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|INFINIBAND
argument_list|,
literal|"InfiniBand"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|SCTP
argument_list|,
literal|"SCTP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|USBPCAP
argument_list|,
literal|"USB with USBPcap header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|RTAC_SERIAL
argument_list|,
literal|"Schweitzer Engineering Laboratories RTAC packets"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|BLUETOOTH_LE_LL
argument_list|,
literal|"Bluetooth Low Energy air interface"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|NETLINK
argument_list|,
literal|"Linux netlink"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|BLUETOOTH_LINUX_MONITOR
argument_list|,
literal|"Bluetooth Linux Monitor"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|BLUETOOTH_BREDR_BB
argument_list|,
literal|"Bluetooth Basic Rate/Enhanced Data Rate baseband packets"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|BLUETOOTH_LE_LL_WITH_PHDR
argument_list|,
literal|"Bluetooth Low Energy air interface with pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PROFIBUS_DL
argument_list|,
literal|"PROFIBUS data link layer"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|PKTAP
argument_list|,
literal|"Apple DLT_PKTAP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|EPON
argument_list|,
literal|"Ethernet with 802.3 Clause 65 EPON preamble"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|IPMI_HPM_2
argument_list|,
literal|"IPMI trace packets"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ZWAVE_R1_R2
argument_list|,
literal|"Z-Wave RF profile R1 and R2 packets"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ZWAVE_R3
argument_list|,
literal|"Z-Wave RF profile R3 packets"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|WATTSTOPPER_DLM
argument_list|,
literal|"WattStopper Digital Lighting Management (DLM) and Legrand Nitoo Open protocol"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|ISO_14443
argument_list|,
literal|"ISO 14443 messages"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|RDS
argument_list|,
literal|"IEC 62106 Radio Data System groups"
argument_list|)
block|,
name|DLT_CHOICE_SENTINEL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcap_datalink_name_to_val
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcap_strcasecmp
argument_list|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|dlt
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_datalink_val_to_name
parameter_list|(
name|int
name|dlt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|dlt
operator|==
name|dlt
condition|)
return|return
operator|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_datalink_val_to_description
parameter_list|(
name|int
name|dlt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|dlt
operator|==
name|dlt
condition|)
return|return
operator|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|description
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|tstamp_type_choice
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|tstamp_type_choice
name|tstamp_type_choices
index|[]
init|=
block|{
block|{
literal|"host"
block|,
literal|"Host"
block|,
name|PCAP_TSTAMP_HOST
block|}
block|,
block|{
literal|"host_lowprec"
block|,
literal|"Host, low precision"
block|,
name|PCAP_TSTAMP_HOST_LOWPREC
block|}
block|,
block|{
literal|"host_hiprec"
block|,
literal|"Host, high precision"
block|,
name|PCAP_TSTAMP_HOST_HIPREC
block|}
block|,
block|{
literal|"adapter"
block|,
literal|"Adapter"
block|,
name|PCAP_TSTAMP_ADAPTER
block|}
block|,
block|{
literal|"adapter_unsynced"
block|,
literal|"Adapter, not synced with system time"
block|,
name|PCAP_TSTAMP_ADAPTER_UNSYNCED
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcap_tstamp_type_name_to_val
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcap_strcasecmp
argument_list|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|type
operator|)
return|;
block|}
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_tstamp_type_val_to_name
parameter_list|(
name|int
name|tstamp_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|type
operator|==
name|tstamp_type
condition|)
return|return
operator|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_tstamp_type_val_to_description
parameter_list|(
name|int
name|tstamp_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|type
operator|==
name|tstamp_type
condition|)
return|return
operator|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|description
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_snapshot
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|activated
condition|)
return|return
operator|(
name|PCAP_ERROR_NOT_ACTIVATED
operator|)
return|;
return|return
operator|(
name|p
operator|->
name|snapshot
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_is_swapped
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|activated
condition|)
return|return
operator|(
name|PCAP_ERROR_NOT_ACTIVATED
operator|)
return|;
return|return
operator|(
name|p
operator|->
name|swapped
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_major_version
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|activated
condition|)
return|return
operator|(
name|PCAP_ERROR_NOT_ACTIVATED
operator|)
return|;
return|return
operator|(
name|p
operator|->
name|version_major
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_minor_version
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|activated
condition|)
return|return
operator|(
name|PCAP_ERROR_NOT_ACTIVATED
operator|)
return|;
return|return
operator|(
name|p
operator|->
name|version_minor
operator|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|pcap_file
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|rfile
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_fileno
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_WIN32
return|return
operator|(
name|p
operator|->
name|fd
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|p
operator|->
name|adapter
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
name|int
operator|)
operator|(
name|DWORD
operator|)
name|p
operator|->
name|adapter
operator|->
name|hFile
operator|)
return|;
else|else
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_function
name|int
name|pcap_get_selectable_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|selectable_fd
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pcap_perror
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|prefix
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|pcap_geterr
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|errbuf
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_getnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|p
operator|->
name|getnonblock_op
argument_list|(
name|p
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * In case somebody depended on the bug wherein 		 * the error message was put into p->errbuf 		 * by pcap_getnonblock_fd(). 		 */
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current non-blocking mode setting, under the assumption that  * it's just the standard POSIX non-blocking flag.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_function
name|int
name|pcap_getnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fdflags
decl_stmt|;
name|fdflags
operator|=
name|fcntl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdflags
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"F_GETFL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fdflags
operator|&
name|O_NONBLOCK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pcap_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|p
operator|->
name|setnonblock_op
argument_list|(
name|p
argument_list|,
name|nonblock
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * In case somebody depended on the bug wherein 		 * the error message was put into p->errbuf 		 * by pcap_setnonblock_fd(). 		 */
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_comment
comment|/*  * Set non-blocking mode, under the assumption that it's just the  * standard POSIX non-blocking flag.  (This can be called by the  * per-platform non-blocking-mode routine if that routine also  * needs to do some additional work.)  */
end_comment

begin_function
name|int
name|pcap_setnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fdflags
decl_stmt|;
name|fdflags
operator|=
name|fcntl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdflags
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"F_GETFL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nonblock
condition|)
name|fdflags
operator||=
name|O_NONBLOCK
expr_stmt|;
else|else
name|fdflags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|fdflags
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"F_SETFL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_comment
comment|/*  * Generate a string for a Win32-specific error (i.e. an error generated when  * calling a Win32 API).  * For errors occurred during standard C calls, we still use pcap_strerror()  */
end_comment

begin_function
name|void
name|pcap_win32_err_to_str
parameter_list|(
name|DWORD
name|error
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|size_t
name|errlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|,
literal|0
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * "FormatMessage()" "helpfully" sticks CR/LF at the end of the 	 * message.  Get rid of it. 	 */
name|errlen
operator|=
name|strlen
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errlen
operator|>=
literal|2
condition|)
block|{
name|errbuf
index|[
name|errlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|errbuf
index|[
name|errlen
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|errbuf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
argument_list|,
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
operator|-
operator|(
name|p
operator|-
name|errbuf
operator|)
argument_list|,
literal|" (%lu)"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Generate error strings for PCAP_ERROR_ and PCAP_WARNING_ values.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pcap_statustostr
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
specifier|static
name|char
name|ebuf
index|[
literal|15
operator|+
literal|10
operator|+
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|errnum
condition|)
block|{
case|case
name|PCAP_WARNING
case|:
return|return
operator|(
literal|"Generic warning"
operator|)
return|;
case|case
name|PCAP_WARNING_TSTAMP_TYPE_NOTSUP
case|:
return|return
operator|(
literal|"That type of time stamp is not supported by that device"
operator|)
return|;
case|case
name|PCAP_WARNING_PROMISC_NOTSUP
case|:
return|return
operator|(
literal|"That device doesn't support promiscuous mode"
operator|)
return|;
case|case
name|PCAP_ERROR
case|:
return|return
operator|(
literal|"Generic error"
operator|)
return|;
case|case
name|PCAP_ERROR_BREAK
case|:
return|return
operator|(
literal|"Loop terminated by pcap_breakloop"
operator|)
return|;
case|case
name|PCAP_ERROR_NOT_ACTIVATED
case|:
return|return
operator|(
literal|"The pcap_t has not been activated"
operator|)
return|;
case|case
name|PCAP_ERROR_ACTIVATED
case|:
return|return
operator|(
literal|"The setting can't be changed after the pcap_t is activated"
operator|)
return|;
case|case
name|PCAP_ERROR_NO_SUCH_DEVICE
case|:
return|return
operator|(
literal|"No such device exists"
operator|)
return|;
case|case
name|PCAP_ERROR_RFMON_NOTSUP
case|:
return|return
operator|(
literal|"That device doesn't support monitor mode"
operator|)
return|;
case|case
name|PCAP_ERROR_NOT_RFMON
case|:
return|return
operator|(
literal|"That operation is supported only in monitor mode"
operator|)
return|;
case|case
name|PCAP_ERROR_PERM_DENIED
case|:
return|return
operator|(
literal|"You don't have permission to capture on that device"
operator|)
return|;
case|case
name|PCAP_ERROR_IFACE_NOT_UP
case|:
return|return
operator|(
literal|"That device is not up"
operator|)
return|;
case|case
name|PCAP_ERROR_CANTSET_TSTAMP_TYPE
case|:
return|return
operator|(
literal|"That device doesn't support setting the time stamp type"
operator|)
return|;
case|case
name|PCAP_ERROR_PROMISC_PERM_DENIED
case|:
return|return
operator|(
literal|"You don't have permission to capture in promiscuous mode on that device"
operator|)
return|;
case|case
name|PCAP_ERROR_TSTAMP_PRECISION_NOTSUP
case|:
return|return
operator|(
literal|"That device doesn't support that time stamp precision"
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
name|ebuf
argument_list|,
literal|"Unknown error: %d"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|ebuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Not all systems have strerror().  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pcap_strerror
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_STRERROR
ifdef|#
directive|ifdef
name|_WIN32
specifier|static
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
index|]
decl_stmt|;
name|errno_t
name|errno
decl_stmt|;
name|errno
operator|=
name|strerror_s
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
comment|/* errno = 0 if successful */
name|strlcpy
argument_list|(
name|errbuf
argument_list|,
literal|"strerror_s() error"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|errbuf
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|strerror
argument_list|(
name|errnum
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* _WIN32 */
else|#
directive|else
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_errlist
index|[]
decl_stmt|;
specifier|static
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|errnum
operator|<
name|sys_nerr
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|sys_errlist
index|[
name|errnum
index|]
operator|)
return|;
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
name|errbuf
argument_list|,
literal|"Unknown error: %d"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|errbuf
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|pcap_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setfilter_op
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set direction flag, which controls whether we accept only incoming  * packets, only outgoing packets, or both.  * Note that, depending on the platform, some or all direction arguments  * might not be supported.  */
end_comment

begin_function
name|int
name|pcap_setdirection
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_direction_t
name|d
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|setdirection_op
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Setting direction is not implemented on this platform"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|p
operator|->
name|setdirection_op
argument_list|(
name|p
argument_list|,
name|d
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|stats_op
argument_list|(
name|p
argument_list|,
name|ps
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_stats_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
name|_U_
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Statistics aren't available from a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
name|struct
name|pcap_stat
modifier|*
name|pcap_stats_ex
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|pcap_stat_size
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|stats_ex_op
argument_list|(
name|p
argument_list|,
name|pcap_stat_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_setbuff
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dim
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setbuff_op
argument_list|(
name|p
argument_list|,
name|dim
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setbuff_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dim
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The kernel buffer size cannot be set on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_setmode
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setmode_op
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setmode_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"impossible to set mode on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_setmintocopy
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setmintocopy_op
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setmintocopy_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The mintocopy parameter cannot be set on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|HANDLE
name|pcap_getevent
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|getevent_op
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|HANDLE
name|pcap_getevent_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"A pcap_open_dead pcap_t has no event handle"
argument_list|)
expr_stmt|;
return|return
operator|(
name|INVALID_HANDLE_VALUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_oid_get_request
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|oid
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|oid_get_request_op
argument_list|(
name|p
argument_list|,
name|oid
argument_list|,
name|data
argument_list|,
name|lenp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_oid_get_request_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|oid
name|_U_
parameter_list|,
name|void
modifier|*
name|data
name|_U_
parameter_list|,
name|size_t
modifier|*
name|lenp
name|_U_
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"An OID get request cannot be performed on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_oid_set_request
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|oid
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|oid_set_request_op
argument_list|(
name|p
argument_list|,
name|oid
argument_list|,
name|data
argument_list|,
name|lenp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_oid_set_request_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|oid
name|_U_
parameter_list|,
specifier|const
name|void
modifier|*
name|data
name|_U_
parameter_list|,
name|size_t
modifier|*
name|lenp
name|_U_
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"An OID set request cannot be performed on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
end_function

begin_function
name|pcap_send_queue
modifier|*
name|pcap_sendqueue_alloc
parameter_list|(
name|u_int
name|memsize
parameter_list|)
block|{
name|pcap_send_queue
modifier|*
name|tqueue
decl_stmt|;
comment|/* Allocate the queue */
name|tqueue
operator|=
operator|(
name|pcap_send_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_send_queue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tqueue
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Allocate the buffer */
name|tqueue
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|memsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|tqueue
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tqueue
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tqueue
operator|->
name|maxlen
operator|=
name|memsize
expr_stmt|;
name|tqueue
operator|->
name|len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|tqueue
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcap_sendqueue_destroy
parameter_list|(
name|pcap_send_queue
modifier|*
name|queue
parameter_list|)
block|{
name|free
argument_list|(
name|queue
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcap_sendqueue_queue
parameter_list|(
name|pcap_send_queue
modifier|*
name|queue
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|pkt_header
parameter_list|,
specifier|const
name|u_char
modifier|*
name|pkt_data
parameter_list|)
block|{
if|if
condition|(
name|queue
operator|->
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_pkthdr
argument_list|)
operator|+
name|pkt_header
operator|->
name|caplen
operator|>
name|queue
operator|->
name|maxlen
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Copy the pcap_pkthdr header*/
name|memcpy
argument_list|(
name|queue
operator|->
name|buffer
operator|+
name|queue
operator|->
name|len
argument_list|,
name|pkt_header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_pkthdr
argument_list|)
argument_list|)
expr_stmt|;
name|queue
operator|->
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_pkthdr
argument_list|)
expr_stmt|;
comment|/* copy the packet */
name|memcpy
argument_list|(
name|queue
operator|->
name|buffer
operator|+
name|queue
operator|->
name|len
argument_list|,
name|pkt_data
argument_list|,
name|pkt_header
operator|->
name|caplen
argument_list|)
expr_stmt|;
name|queue
operator|->
name|len
operator|+=
name|pkt_header
operator|->
name|caplen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|pcap_sendqueue_transmit
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_send_queue
modifier|*
name|queue
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|sendqueue_transmit_op
argument_list|(
name|p
argument_list|,
name|queue
argument_list|,
name|sync
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|pcap_sendqueue_transmit_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_send_queue
modifier|*
name|queue
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Packets cannot be transmitted on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_setuserbuffer
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setuserbuffer_op
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setuserbuffer_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The user buffer cannot be set on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_live_dump
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|maxsize
parameter_list|,
name|int
name|maxpacks
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|live_dump_op
argument_list|(
name|p
argument_list|,
name|filename
argument_list|,
name|maxsize
argument_list|,
name|maxpacks
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_live_dump_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|maxsize
parameter_list|,
name|int
name|maxpacks
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Live packet dumping cannot be performed on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_live_dump_ended
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|live_dump_ended_op
argument_list|(
name|p
argument_list|,
name|sync
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_live_dump_ended_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Live packet dumping cannot be performed on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|PAirpcapHandle
name|pcap_get_airpcap_handle
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|PAirpcapHandle
name|handle
decl_stmt|;
name|handle
operator|=
name|p
operator|->
name|get_airpcap_handle_op
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"This isn't an AirPcap device"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|handle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|PAirpcapHandle
name|pcap_get_airpcap_handle_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * On some platforms, we need to clean up promiscuous or monitor mode  * when we close a device - and we want that to happen even if the  * application just exits without explicitl closing devices.  * On those platforms, we need to register a "close all the pcaps"  * routine to be called when we exit, and need to maintain a list of  * pcaps that need to be closed to clean up modes.  *  * XXX - not thread-safe.  */
end_comment

begin_comment
comment|/*  * List of pcaps on which we've done something that needs to be  * cleaned up.  * If there are any such pcaps, we arrange to call "pcap_close_all()"  * when we exit, and have it close all of them.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcap
modifier|*
name|pcaps_to_close
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TRUE if we've already called "atexit()" to cause "pcap_close_all()" to  * be called on exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|did_atexit
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pcap_close_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pcap
modifier|*
name|handle
decl_stmt|;
while|while
condition|(
operator|(
name|handle
operator|=
name|pcaps_to_close
operator|)
operator|!=
name|NULL
condition|)
name|pcap_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcap_do_addexit
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * If we haven't already done so, arrange to have 	 * "pcap_close_all()" called when we exit. 	 */
if|if
condition|(
operator|!
name|did_atexit
condition|)
block|{
if|if
condition|(
name|atexit
argument_list|(
name|pcap_close_all
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * "atexit()" failed; let our caller know. 			 */
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"atexit failed"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|did_atexit
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcap_add_to_pcaps_to_close
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|p
operator|->
name|next
operator|=
name|pcaps_to_close
expr_stmt|;
name|pcaps_to_close
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pcap_remove_from_pcaps_to_close
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|pcap_t
modifier|*
name|pc
decl_stmt|,
modifier|*
name|prevpc
decl_stmt|;
for|for
control|(
name|pc
operator|=
name|pcaps_to_close
operator|,
name|prevpc
operator|=
name|NULL
init|;
name|pc
operator|!=
name|NULL
condition|;
name|prevpc
operator|=
name|pc
operator|,
name|pc
operator|=
name|pc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pc
operator|==
name|p
condition|)
block|{
comment|/* 			 * Found it.  Remove it from the list. 			 */
if|if
condition|(
name|prevpc
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * It was at the head of the list. 				 */
name|pcaps_to_close
operator|=
name|pc
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * It was in the middle of the list. 				 */
name|prevpc
operator|->
name|next
operator|=
name|pc
operator|->
name|next
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|pcap_cleanup_live_common
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|dlt_list
argument_list|)
expr_stmt|;
name|p
operator|->
name|dlt_list
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|dlt_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|tstamp_type_list
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|tstamp_type_list
argument_list|)
expr_stmt|;
name|p
operator|->
name|tstamp_type_list
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|tstamp_type_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|tstamp_precision_list
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|tstamp_precision_list
argument_list|)
expr_stmt|;
name|p
operator|->
name|tstamp_precision_list
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|tstamp_precision_count
operator|=
literal|0
expr_stmt|;
block|}
name|pcap_freecode
argument_list|(
operator|&
name|p
operator|->
name|fcode
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
if|if
condition|(
name|p
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|p
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|pcap_cleanup_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
name|_U_
parameter_list|)
block|{
comment|/* Nothing to do. */
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_dead_with_tstamp_precision
parameter_list|(
name|int
name|linktype
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|u_int
name|precision
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|precision
condition|)
block|{
case|case
name|PCAP_TSTAMP_PRECISION_MICRO
case|:
case|case
name|PCAP_TSTAMP_PRECISION_NANO
case|:
break|break;
default|default:
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
name|p
operator|->
name|linktype
operator|=
name|linktype
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|=
name|precision
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
name|pcap_stats_dead
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|p
operator|->
name|stats_ex_op
operator|=
operator|(
name|stats_ex_op_t
operator|)
name|pcap_not_initialized_ptr
expr_stmt|;
name|p
operator|->
name|setbuff_op
operator|=
name|pcap_setbuff_dead
expr_stmt|;
name|p
operator|->
name|setmode_op
operator|=
name|pcap_setmode_dead
expr_stmt|;
name|p
operator|->
name|setmintocopy_op
operator|=
name|pcap_setmintocopy_dead
expr_stmt|;
name|p
operator|->
name|getevent_op
operator|=
name|pcap_getevent_dead
expr_stmt|;
name|p
operator|->
name|oid_get_request_op
operator|=
name|pcap_oid_get_request_dead
expr_stmt|;
name|p
operator|->
name|oid_set_request_op
operator|=
name|pcap_oid_set_request_dead
expr_stmt|;
name|p
operator|->
name|sendqueue_transmit_op
operator|=
name|pcap_sendqueue_transmit_dead
expr_stmt|;
name|p
operator|->
name|setuserbuffer_op
operator|=
name|pcap_setuserbuffer_dead
expr_stmt|;
name|p
operator|->
name|live_dump_op
operator|=
name|pcap_live_dump_dead
expr_stmt|;
name|p
operator|->
name|live_dump_ended_op
operator|=
name|pcap_live_dump_ended_dead
expr_stmt|;
name|p
operator|->
name|get_airpcap_handle_op
operator|=
name|pcap_get_airpcap_handle_dead
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_dead
expr_stmt|;
comment|/* 	 * A "dead" pcap_t never requires special BPF code generation. 	 */
name|p
operator|->
name|bpf_codegen_flags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|activated
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_dead
parameter_list|(
name|int
name|linktype
parameter_list|,
name|int
name|snaplen
parameter_list|)
block|{
return|return
operator|(
name|pcap_open_dead_with_tstamp_precision
argument_list|(
name|linktype
argument_list|,
name|snaplen
argument_list|,
name|PCAP_TSTAMP_PRECISION_MICRO
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * API compatible with WinPcap's "send a packet" routine - returns -1  * on error, 0 otherwise.  *  * XXX - what if we get a short write?  */
end_comment

begin_function
name|int
name|pcap_sendpacket
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|inject_op
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * API compatible with OpenBSD's "send a packet" routine - returns -1 on  * error, number of bytes written otherwise.  */
end_comment

begin_function
name|int
name|pcap_inject
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|inject_op
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcap_close
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|device
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
expr_stmt|;
name|p
operator|->
name|cleanup_op
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a BPF program, a pcap_pkthdr structure for a packet, and the raw  * data for the packet, check whether the packet passes the filter.  * Returns the return value of the filter program, which will be zero if  * the packet doesn't pass and non-zero if the packet does pass.  */
end_comment

begin_function
name|int
name|pcap_offline_filter
parameter_list|(
specifier|const
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|pkt
parameter_list|)
block|{
specifier|const
name|struct
name|bpf_insn
modifier|*
name|fcode
init|=
name|fp
operator|->
name|bf_insns
decl_stmt|;
if|if
condition|(
name|fcode
operator|!=
name|NULL
condition|)
return|return
operator|(
name|bpf_filter
argument_list|(
name|fcode
argument_list|,
name|pkt
argument_list|,
name|h
operator|->
name|len
argument_list|,
name|h
operator|->
name|caplen
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"pcap_version.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|full_pcap_version_string
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VERSION_H
end_ifdef

begin_comment
comment|/*  * libpcap being built for Windows, as part of a WinPcap/Npcap source  * tree.  Include version.h from that source tree to get the WinPcap/Npcap  * version.  *  * XXX - it'd be nice if we could somehow generate the WinPcap version number  * when building WinPcap.  (It'd be nice to do so for the packet.dll version  * number as well.)  */
end_comment

begin_include
include|#
directive|include
file|"../../version.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|wpcap_version_string
index|[]
init|=
name|WINPCAP_VER_STRING
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcap_version_string_fmt
index|[]
init|=
name|WINPCAP_PRODUCT_NAME
literal|" version %s, based on %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcap_version_string_packet_dll_fmt
index|[]
init|=
name|WINPCAP_PRODUCT_NAME
literal|" version %s (packet.dll version %s), based on %s"
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|packet_version_string
decl_stmt|;
name|size_t
name|full_pcap_version_string_len
decl_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Generate the version string. 		 */
name|packet_version_string
operator|=
name|PacketGetVersion
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|wpcap_version_string
argument_list|,
name|packet_version_string
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * WinPcap version string and packet.dll version 			 * string are the same; just report the WinPcap 			 * version. 			 */
name|full_pcap_version_string_len
operator|=
operator|(
sizeof|sizeof
name|pcap_version_string_fmt
operator|-
literal|4
operator|)
operator|+
name|strlen
argument_list|(
name|wpcap_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pcap_snprintf
argument_list|(
name|full_pcap_version_string
argument_list|,
name|full_pcap_version_string_len
argument_list|,
name|pcap_version_string_fmt
argument_list|,
name|wpcap_version_string
argument_list|,
name|pcap_version_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * WinPcap version string and packet.dll version 			 * string are different; that shouldn't be the 			 * case (the two libraries should come from the 			 * same version of WinPcap), so we report both 			 * versions. 			 */
name|full_pcap_version_string_len
operator|=
operator|(
sizeof|sizeof
name|pcap_version_string_packet_dll_fmt
operator|-
literal|6
operator|)
operator|+
name|strlen
argument_list|(
name|wpcap_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|packet_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pcap_snprintf
argument_list|(
name|full_pcap_version_string
argument_list|,
name|full_pcap_version_string_len
argument_list|,
name|pcap_version_string_packet_dll_fmt
argument_list|,
name|wpcap_version_string
argument_list|,
name|packet_version_string
argument_list|,
name|pcap_version_string
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|full_pcap_version_string
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_VERSION_H */
end_comment

begin_comment
comment|/*  * libpcap being built for Windows, not as part of a WinPcap/Npcap source  * tree.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcap_version_string_packet_dll_fmt
index|[]
init|=
literal|"%s (packet.dll version %s)"
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|packet_version_string
decl_stmt|;
name|size_t
name|full_pcap_version_string_len
decl_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Generate the version string.  Report the packet.dll 		 * version. 		 */
name|packet_version_string
operator|=
name|PacketGetVersion
argument_list|()
expr_stmt|;
name|full_pcap_version_string_len
operator|=
operator|(
sizeof|sizeof
name|pcap_version_string_packet_dll_fmt
operator|-
literal|4
operator|)
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|packet_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pcap_snprintf
argument_list|(
name|full_pcap_version_string
argument_list|,
name|full_pcap_version_string_len
argument_list|,
name|pcap_version_string_packet_dll_fmt
argument_list|,
name|pcap_version_string
argument_list|,
name|packet_version_string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|full_pcap_version_string
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_VERSION_H */
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|full_pcap_version_string
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|packet_version_string
decl_stmt|;
name|size_t
name|full_pcap_version_string_len
decl_stmt|;
specifier|static
name|char
name|dospfx
index|[]
init|=
literal|"DOS-"
decl_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Generate the version string. 		 */
name|full_pcap_version_string_len
operator|=
sizeof|sizeof
name|dospfx
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strcpy
argument_list|(
name|full_pcap_version_string
argument_list|,
name|dospfx
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_pcap_version_string
argument_list|,
name|pcap_version_string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|full_pcap_version_string
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UN*X */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|pcap_version_string
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|YYDEBUG
end_ifdef

begin_comment
comment|/*  * Set the internal "debug printout" flag for the filter expression parser.  * The code to print that stuff is present only if YYDEBUG is defined, so  * the flag, and the routine to set it, are defined only if YYDEBUG is  * defined.  *  * This is intended for libpcap developers, not for general use.  * If you want to set these in a program, you'll have to declare this  * routine yourself, with the appropriate DLL import attribute on Windows;  * it's not declared in any header file, and won't be declared in any  * header file provided by libpcap.  */
end_comment

begin_function_decl
name|PCAP_API
name|void
name|pcap_set_parser_debug
parameter_list|(
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|PCAP_API_DEF
name|void
name|pcap_set_parser_debug
parameter_list|(
name|int
name|value
parameter_list|)
block|{
specifier|extern
name|int
name|pcap_debug
decl_stmt|;
name|pcap_debug
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_comment
comment|/*  * Set the internal "debug printout" flag for the filter expression optimizer.  * The code to print that stuff is present only if BDEBUG is defined, so  * the flag, and the routine to set it, are defined only if BDEBUG is  * defined.  *  * This is intended for libpcap developers, not for general use.  * If you want to set these in a program, you'll have to declare this  * routine yourself, with the appropriate DLL import attribute on Windows;  * it's not declared in any header file, and won't be declared in any  * header file provided by libpcap.  */
end_comment

begin_function_decl
name|PCAP_API
name|void
name|pcap_set_optimizer_debug
parameter_list|(
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|PCAP_API_DEF
name|void
name|pcap_set_optimizer_debug
parameter_list|(
name|int
name|value
parameter_list|)
block|{
specifier|extern
name|int
name|pcap_optimizer_debug
decl_stmt|;
name|pcap_optimizer_debug
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

