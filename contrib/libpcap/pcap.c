begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997, 1998  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the Computer Systems  *	Engineering Group at Lawrence Berkeley Laboratory.  * 4. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/pcap.c,v 1.88.2.3 2005/05/27 23:33:00 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_include
include|#
directive|include
file|<pcap-stdinc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* WIN32 */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|"pcap-dos.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DAG_API
end_ifdef

begin_include
include|#
directive|include
file|<dagnew.h>
end_include

begin_include
include|#
directive|include
file|<dagapi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pcap_dispatch
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
return|return
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX - is this necessary?  */
end_comment

begin_function
name|int
name|pcap_read
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
return|return
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_loop
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|rfile
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * 0 means EOF, so don't loop if we get 0. 			 */
name|n
operator|=
name|pcap_offline_read
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXX keep reading until we get something 			 * (or an error occurs) 			 */
do|do
block|{
name|n
operator|=
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|cnt
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_struct
struct|struct
name|singleton
block|{
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|pkt
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pcap_oneshot
parameter_list|(
name|u_char
modifier|*
name|userData
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|singleton
modifier|*
name|sp
init|=
operator|(
expr|struct
name|singleton
operator|*
operator|)
name|userData
decl_stmt|;
operator|*
name|sp
operator|->
name|hdr
operator|=
operator|*
name|h
expr_stmt|;
name|sp
operator|->
name|pkt
operator|=
name|pkt
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|u_char
modifier|*
name|pcap_next
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|singleton
name|s
decl_stmt|;
name|s
operator|.
name|hdr
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|pcap_dispatch
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|pcap_oneshot
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|s
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|s
operator|.
name|pkt
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|pkt_for_fakecallback
block|{
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|u_char
modifier|*
modifier|*
name|pkt
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pcap_fakecallback
parameter_list|(
name|u_char
modifier|*
name|userData
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|pkt_for_fakecallback
modifier|*
name|sp
init|=
operator|(
expr|struct
name|pkt_for_fakecallback
operator|*
operator|)
name|userData
decl_stmt|;
operator|*
name|sp
operator|->
name|hdr
operator|=
operator|*
name|h
expr_stmt|;
operator|*
name|sp
operator|->
name|pkt
operator|=
name|pkt
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcap_next_ex
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
modifier|*
name|pkt_header
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
name|pkt_data
parameter_list|)
block|{
name|struct
name|pkt_for_fakecallback
name|s
decl_stmt|;
name|s
operator|.
name|hdr
operator|=
operator|&
name|p
operator|->
name|pcap_header
expr_stmt|;
name|s
operator|.
name|pkt
operator|=
name|pkt_data
expr_stmt|;
comment|/* Saves a pointer to the packet headers */
operator|*
name|pkt_header
operator|=
operator|&
name|p
operator|->
name|pcap_header
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|rfile
operator|!=
name|NULL
condition|)
block|{
name|int
name|status
decl_stmt|;
comment|/* We are on an offline capture */
name|status
operator|=
name|pcap_offline_read
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|pcap_fakecallback
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * Return codes for pcap_offline_read() are: 		 *   -  0: EOF 		 *   - -1: error 		 *   ->1: OK 		 * The first one ('0') conflicts with the return code of 		 * 0 from pcap_read() meaning "no packets arrived before 		 * the timeout expired", so we map it to -2 so you can 		 * distinguish between an EOF from a savefile and a 		 * "no packets arrived before the timeout expired, try 		 * again" from a live capture. 		 */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|else
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Return codes for pcap_read() are: 	 *   -  0: timeout 	 *   - -1: error 	 *   - -2: loop was broken out of with pcap_breakloop() 	 *   ->1: OK 	 * The first one ('0') conflicts with the return code of 0 from 	 * pcap_offline_read() meaning "end of file". 	*/
return|return
operator|(
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|pcap_fakecallback
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Force the loop in "pcap_read()" or "pcap_read_offline()" to terminate.  */
end_comment

begin_function
name|void
name|pcap_breakloop
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|p
operator|->
name|break_loop
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcap_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|linktype
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_list_datalinks
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
modifier|*
name|dlt_buffer
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|dlt_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We couldn't fetch the list of DLTs, which means 		 * this platform doesn't support changing the 		 * DLT for an interface.  Return a list of DLTs 		 * containing only the DLT this device supports. 		 */
operator|*
name|dlt_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dlt_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dlt_buffer
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
operator|*
name|dlt_buffer
operator|=
name|p
operator|->
name|linktype
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|*
name|dlt_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dlt_buffer
argument_list|)
operator|*
name|p
operator|->
name|dlt_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dlt_buffer
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|*
name|dlt_buffer
argument_list|,
name|p
operator|->
name|dlt_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dlt_buffer
argument_list|)
operator|*
name|p
operator|->
name|dlt_count
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|dlt_count
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|pcap_set_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|dlt_name
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|dlt_count
operator|==
literal|0
operator|||
name|p
operator|->
name|set_datalink_op
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We couldn't fetch the list of DLTs, or we don't 		 * have a "set datalink" operation, which means 		 * this platform doesn't support changing the 		 * DLT for an interface.  Check whether the new 		 * DLT is the one this interface supports. 		 */
if|if
condition|(
name|p
operator|->
name|linktype
operator|!=
name|dlt
condition|)
goto|goto
name|unsupported
goto|;
comment|/* 		 * It is, so there's nothing we need to do here. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|dlt_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dlt_list
index|[
name|i
index|]
operator|==
name|dlt
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|p
operator|->
name|dlt_count
condition|)
goto|goto
name|unsupported
goto|;
if|if
condition|(
name|p
operator|->
name|dlt_count
operator|==
literal|2
operator|&&
name|p
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|==
name|DLT_EN10MB
operator|&&
name|dlt
operator|==
name|DLT_DOCSIS
condition|)
block|{
comment|/* 		 * This is presumably an Ethernet device, as the first 		 * link-layer type it offers is DLT_EN10MB, and the only 		 * other type it offers is DLT_DOCSIS.  That means that 		 * we can't tell the driver to supply DOCSIS link-layer 		 * headers - we're just pretending that's what we're 		 * getting, as, presumably, we're capturing on a dedicated 		 * link to a Cisco Cable Modem Termination System, and 		 * it's putting raw DOCSIS frames on the wire inside low-level 		 * Ethernet framing. 		 */
name|p
operator|->
name|linktype
operator|=
name|dlt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|set_datalink_op
argument_list|(
name|p
argument_list|,
name|dlt
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|->
name|linktype
operator|=
name|dlt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|unsupported
label|:
name|dlt_name
operator|=
name|pcap_datalink_val_to_name
argument_list|(
name|dlt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlt_name
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"%s is not one of the DLTs supported by this device"
argument_list|,
name|dlt_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"DLT %d is not one of the DLTs supported by this device"
argument_list|,
name|dlt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|dlt_choice
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
name|int
name|dlt
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DLT_CHOICE
parameter_list|(
name|code
parameter_list|,
name|description
parameter_list|)
value|{ #code, description, code }
end_define

begin_define
define|#
directive|define
name|DLT_CHOICE_SENTINEL
value|{ NULL, NULL, 0 }
end_define

begin_decl_stmt
specifier|static
name|struct
name|dlt_choice
name|dlt_choices
index|[]
init|=
block|{
name|DLT_CHOICE
argument_list|(
name|DLT_NULL
argument_list|,
literal|"BSD loopback"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_EN10MB
argument_list|,
literal|"Ethernet"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802
argument_list|,
literal|"Token ring"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ARCNET
argument_list|,
literal|"ARCNET"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SLIP
argument_list|,
literal|"SLIP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP
argument_list|,
literal|"PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_FDDI
argument_list|,
literal|"FDDI"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ATM_RFC1483
argument_list|,
literal|"RFC 1483 LLC-encapsulated ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_RAW
argument_list|,
literal|"Raw IP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SLIP_BSDOS
argument_list|,
literal|"BSD/OS SLIP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP_BSDOS
argument_list|,
literal|"BSD/OS PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ATM_CLIP
argument_list|,
literal|"Linux Classical IP-over-ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP_SERIAL
argument_list|,
literal|"PPP over serial"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP_ETHER
argument_list|,
literal|"PPPoE"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_C_HDLC
argument_list|,
literal|"Cisco HDLC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_11
argument_list|,
literal|"802.11"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_FRELAY
argument_list|,
literal|"Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_LOOP
argument_list|,
literal|"OpenBSD loopback"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ENC
argument_list|,
literal|"OpenBSD encapsulated IP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_LINUX_SLL
argument_list|,
literal|"Linux cooked"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_LTALK
argument_list|,
literal|"Localtalk"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PFLOG
argument_list|,
literal|"OpenBSD pflog file"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PRISM_HEADER
argument_list|,
literal|"802.11 plus Prism header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IP_OVER_FC
argument_list|,
literal|"RFC 2625 IP-over-Fibre Channel"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SUNATM
argument_list|,
literal|"Sun raw ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_11_RADIO
argument_list|,
literal|"802.11 plus BSD radio information header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_APPLE_IP_OVER_IEEE1394
argument_list|,
literal|"Apple IP-over-IEEE 1394"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ARCNET_LINUX
argument_list|,
literal|"Linux ARCNET"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_DOCSIS
argument_list|,
literal|"DOCSIS"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_LINUX_IRDA
argument_list|,
literal|"Linux IrDA"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_11_RADIO_AVS
argument_list|,
literal|"802.11 plus AVS radio information header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SYMANTEC_FIREWALL
argument_list|,
literal|"Symantec Firewall"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ATM1
argument_list|,
literal|"Juniper ATM1 PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ATM2
argument_list|,
literal|"Juniper ATM2 PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_MLPPP
argument_list|,
literal|"Juniper Multi-Link PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP_PPPD
argument_list|,
literal|"PPP for pppd, with direction flag"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_PPPOE
argument_list|,
literal|"Juniper PPPoE"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_PPPOE_ATM
argument_list|,
literal|"Juniper PPPoE/ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_GPRS_LLC
argument_list|,
literal|"GPRS LLC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_GPF_T
argument_list|,
literal|"GPF-T"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_GPF_F
argument_list|,
literal|"GPF-F"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_PIC_PEER
argument_list|,
literal|"Juniper PIC Peer"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_MLFR
argument_list|,
literal|"Juniper Multi-Link Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ERF_ETH
argument_list|,
literal|"Ethernet with Endace ERF header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ERF_POS
argument_list|,
literal|"Packet-over-SONET with Endace ERF header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_GGSN
argument_list|,
literal|"Juniper GGSN PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ES
argument_list|,
literal|"Juniper Encryption Services PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_MONITOR
argument_list|,
literal|"Juniper Passive Monitor PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_SERVICES
argument_list|,
literal|"Juniper Advanced Services PIC"
argument_list|)
block|,
name|DLT_CHOICE_SENTINEL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This array is designed for mapping upper and lower case letter  * together for a case independent comparison.  The mappings are  * based upon ascii character sequences.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|charmap
index|[]
init|=
block|{
operator|(
name|u_char
operator|)
literal|'\000'
block|,
operator|(
name|u_char
operator|)
literal|'\001'
block|,
operator|(
name|u_char
operator|)
literal|'\002'
block|,
operator|(
name|u_char
operator|)
literal|'\003'
block|,
operator|(
name|u_char
operator|)
literal|'\004'
block|,
operator|(
name|u_char
operator|)
literal|'\005'
block|,
operator|(
name|u_char
operator|)
literal|'\006'
block|,
operator|(
name|u_char
operator|)
literal|'\007'
block|,
operator|(
name|u_char
operator|)
literal|'\010'
block|,
operator|(
name|u_char
operator|)
literal|'\011'
block|,
operator|(
name|u_char
operator|)
literal|'\012'
block|,
operator|(
name|u_char
operator|)
literal|'\013'
block|,
operator|(
name|u_char
operator|)
literal|'\014'
block|,
operator|(
name|u_char
operator|)
literal|'\015'
block|,
operator|(
name|u_char
operator|)
literal|'\016'
block|,
operator|(
name|u_char
operator|)
literal|'\017'
block|,
operator|(
name|u_char
operator|)
literal|'\020'
block|,
operator|(
name|u_char
operator|)
literal|'\021'
block|,
operator|(
name|u_char
operator|)
literal|'\022'
block|,
operator|(
name|u_char
operator|)
literal|'\023'
block|,
operator|(
name|u_char
operator|)
literal|'\024'
block|,
operator|(
name|u_char
operator|)
literal|'\025'
block|,
operator|(
name|u_char
operator|)
literal|'\026'
block|,
operator|(
name|u_char
operator|)
literal|'\027'
block|,
operator|(
name|u_char
operator|)
literal|'\030'
block|,
operator|(
name|u_char
operator|)
literal|'\031'
block|,
operator|(
name|u_char
operator|)
literal|'\032'
block|,
operator|(
name|u_char
operator|)
literal|'\033'
block|,
operator|(
name|u_char
operator|)
literal|'\034'
block|,
operator|(
name|u_char
operator|)
literal|'\035'
block|,
operator|(
name|u_char
operator|)
literal|'\036'
block|,
operator|(
name|u_char
operator|)
literal|'\037'
block|,
operator|(
name|u_char
operator|)
literal|'\040'
block|,
operator|(
name|u_char
operator|)
literal|'\041'
block|,
operator|(
name|u_char
operator|)
literal|'\042'
block|,
operator|(
name|u_char
operator|)
literal|'\043'
block|,
operator|(
name|u_char
operator|)
literal|'\044'
block|,
operator|(
name|u_char
operator|)
literal|'\045'
block|,
operator|(
name|u_char
operator|)
literal|'\046'
block|,
operator|(
name|u_char
operator|)
literal|'\047'
block|,
operator|(
name|u_char
operator|)
literal|'\050'
block|,
operator|(
name|u_char
operator|)
literal|'\051'
block|,
operator|(
name|u_char
operator|)
literal|'\052'
block|,
operator|(
name|u_char
operator|)
literal|'\053'
block|,
operator|(
name|u_char
operator|)
literal|'\054'
block|,
operator|(
name|u_char
operator|)
literal|'\055'
block|,
operator|(
name|u_char
operator|)
literal|'\056'
block|,
operator|(
name|u_char
operator|)
literal|'\057'
block|,
operator|(
name|u_char
operator|)
literal|'\060'
block|,
operator|(
name|u_char
operator|)
literal|'\061'
block|,
operator|(
name|u_char
operator|)
literal|'\062'
block|,
operator|(
name|u_char
operator|)
literal|'\063'
block|,
operator|(
name|u_char
operator|)
literal|'\064'
block|,
operator|(
name|u_char
operator|)
literal|'\065'
block|,
operator|(
name|u_char
operator|)
literal|'\066'
block|,
operator|(
name|u_char
operator|)
literal|'\067'
block|,
operator|(
name|u_char
operator|)
literal|'\070'
block|,
operator|(
name|u_char
operator|)
literal|'\071'
block|,
operator|(
name|u_char
operator|)
literal|'\072'
block|,
operator|(
name|u_char
operator|)
literal|'\073'
block|,
operator|(
name|u_char
operator|)
literal|'\074'
block|,
operator|(
name|u_char
operator|)
literal|'\075'
block|,
operator|(
name|u_char
operator|)
literal|'\076'
block|,
operator|(
name|u_char
operator|)
literal|'\077'
block|,
operator|(
name|u_char
operator|)
literal|'\100'
block|,
operator|(
name|u_char
operator|)
literal|'\141'
block|,
operator|(
name|u_char
operator|)
literal|'\142'
block|,
operator|(
name|u_char
operator|)
literal|'\143'
block|,
operator|(
name|u_char
operator|)
literal|'\144'
block|,
operator|(
name|u_char
operator|)
literal|'\145'
block|,
operator|(
name|u_char
operator|)
literal|'\146'
block|,
operator|(
name|u_char
operator|)
literal|'\147'
block|,
operator|(
name|u_char
operator|)
literal|'\150'
block|,
operator|(
name|u_char
operator|)
literal|'\151'
block|,
operator|(
name|u_char
operator|)
literal|'\152'
block|,
operator|(
name|u_char
operator|)
literal|'\153'
block|,
operator|(
name|u_char
operator|)
literal|'\154'
block|,
operator|(
name|u_char
operator|)
literal|'\155'
block|,
operator|(
name|u_char
operator|)
literal|'\156'
block|,
operator|(
name|u_char
operator|)
literal|'\157'
block|,
operator|(
name|u_char
operator|)
literal|'\160'
block|,
operator|(
name|u_char
operator|)
literal|'\161'
block|,
operator|(
name|u_char
operator|)
literal|'\162'
block|,
operator|(
name|u_char
operator|)
literal|'\163'
block|,
operator|(
name|u_char
operator|)
literal|'\164'
block|,
operator|(
name|u_char
operator|)
literal|'\165'
block|,
operator|(
name|u_char
operator|)
literal|'\166'
block|,
operator|(
name|u_char
operator|)
literal|'\167'
block|,
operator|(
name|u_char
operator|)
literal|'\170'
block|,
operator|(
name|u_char
operator|)
literal|'\171'
block|,
operator|(
name|u_char
operator|)
literal|'\172'
block|,
operator|(
name|u_char
operator|)
literal|'\133'
block|,
operator|(
name|u_char
operator|)
literal|'\134'
block|,
operator|(
name|u_char
operator|)
literal|'\135'
block|,
operator|(
name|u_char
operator|)
literal|'\136'
block|,
operator|(
name|u_char
operator|)
literal|'\137'
block|,
operator|(
name|u_char
operator|)
literal|'\140'
block|,
operator|(
name|u_char
operator|)
literal|'\141'
block|,
operator|(
name|u_char
operator|)
literal|'\142'
block|,
operator|(
name|u_char
operator|)
literal|'\143'
block|,
operator|(
name|u_char
operator|)
literal|'\144'
block|,
operator|(
name|u_char
operator|)
literal|'\145'
block|,
operator|(
name|u_char
operator|)
literal|'\146'
block|,
operator|(
name|u_char
operator|)
literal|'\147'
block|,
operator|(
name|u_char
operator|)
literal|'\150'
block|,
operator|(
name|u_char
operator|)
literal|'\151'
block|,
operator|(
name|u_char
operator|)
literal|'\152'
block|,
operator|(
name|u_char
operator|)
literal|'\153'
block|,
operator|(
name|u_char
operator|)
literal|'\154'
block|,
operator|(
name|u_char
operator|)
literal|'\155'
block|,
operator|(
name|u_char
operator|)
literal|'\156'
block|,
operator|(
name|u_char
operator|)
literal|'\157'
block|,
operator|(
name|u_char
operator|)
literal|'\160'
block|,
operator|(
name|u_char
operator|)
literal|'\161'
block|,
operator|(
name|u_char
operator|)
literal|'\162'
block|,
operator|(
name|u_char
operator|)
literal|'\163'
block|,
operator|(
name|u_char
operator|)
literal|'\164'
block|,
operator|(
name|u_char
operator|)
literal|'\165'
block|,
operator|(
name|u_char
operator|)
literal|'\166'
block|,
operator|(
name|u_char
operator|)
literal|'\167'
block|,
operator|(
name|u_char
operator|)
literal|'\170'
block|,
operator|(
name|u_char
operator|)
literal|'\171'
block|,
operator|(
name|u_char
operator|)
literal|'\172'
block|,
operator|(
name|u_char
operator|)
literal|'\173'
block|,
operator|(
name|u_char
operator|)
literal|'\174'
block|,
operator|(
name|u_char
operator|)
literal|'\175'
block|,
operator|(
name|u_char
operator|)
literal|'\176'
block|,
operator|(
name|u_char
operator|)
literal|'\177'
block|,
operator|(
name|u_char
operator|)
literal|'\200'
block|,
operator|(
name|u_char
operator|)
literal|'\201'
block|,
operator|(
name|u_char
operator|)
literal|'\202'
block|,
operator|(
name|u_char
operator|)
literal|'\203'
block|,
operator|(
name|u_char
operator|)
literal|'\204'
block|,
operator|(
name|u_char
operator|)
literal|'\205'
block|,
operator|(
name|u_char
operator|)
literal|'\206'
block|,
operator|(
name|u_char
operator|)
literal|'\207'
block|,
operator|(
name|u_char
operator|)
literal|'\210'
block|,
operator|(
name|u_char
operator|)
literal|'\211'
block|,
operator|(
name|u_char
operator|)
literal|'\212'
block|,
operator|(
name|u_char
operator|)
literal|'\213'
block|,
operator|(
name|u_char
operator|)
literal|'\214'
block|,
operator|(
name|u_char
operator|)
literal|'\215'
block|,
operator|(
name|u_char
operator|)
literal|'\216'
block|,
operator|(
name|u_char
operator|)
literal|'\217'
block|,
operator|(
name|u_char
operator|)
literal|'\220'
block|,
operator|(
name|u_char
operator|)
literal|'\221'
block|,
operator|(
name|u_char
operator|)
literal|'\222'
block|,
operator|(
name|u_char
operator|)
literal|'\223'
block|,
operator|(
name|u_char
operator|)
literal|'\224'
block|,
operator|(
name|u_char
operator|)
literal|'\225'
block|,
operator|(
name|u_char
operator|)
literal|'\226'
block|,
operator|(
name|u_char
operator|)
literal|'\227'
block|,
operator|(
name|u_char
operator|)
literal|'\230'
block|,
operator|(
name|u_char
operator|)
literal|'\231'
block|,
operator|(
name|u_char
operator|)
literal|'\232'
block|,
operator|(
name|u_char
operator|)
literal|'\233'
block|,
operator|(
name|u_char
operator|)
literal|'\234'
block|,
operator|(
name|u_char
operator|)
literal|'\235'
block|,
operator|(
name|u_char
operator|)
literal|'\236'
block|,
operator|(
name|u_char
operator|)
literal|'\237'
block|,
operator|(
name|u_char
operator|)
literal|'\240'
block|,
operator|(
name|u_char
operator|)
literal|'\241'
block|,
operator|(
name|u_char
operator|)
literal|'\242'
block|,
operator|(
name|u_char
operator|)
literal|'\243'
block|,
operator|(
name|u_char
operator|)
literal|'\244'
block|,
operator|(
name|u_char
operator|)
literal|'\245'
block|,
operator|(
name|u_char
operator|)
literal|'\246'
block|,
operator|(
name|u_char
operator|)
literal|'\247'
block|,
operator|(
name|u_char
operator|)
literal|'\250'
block|,
operator|(
name|u_char
operator|)
literal|'\251'
block|,
operator|(
name|u_char
operator|)
literal|'\252'
block|,
operator|(
name|u_char
operator|)
literal|'\253'
block|,
operator|(
name|u_char
operator|)
literal|'\254'
block|,
operator|(
name|u_char
operator|)
literal|'\255'
block|,
operator|(
name|u_char
operator|)
literal|'\256'
block|,
operator|(
name|u_char
operator|)
literal|'\257'
block|,
operator|(
name|u_char
operator|)
literal|'\260'
block|,
operator|(
name|u_char
operator|)
literal|'\261'
block|,
operator|(
name|u_char
operator|)
literal|'\262'
block|,
operator|(
name|u_char
operator|)
literal|'\263'
block|,
operator|(
name|u_char
operator|)
literal|'\264'
block|,
operator|(
name|u_char
operator|)
literal|'\265'
block|,
operator|(
name|u_char
operator|)
literal|'\266'
block|,
operator|(
name|u_char
operator|)
literal|'\267'
block|,
operator|(
name|u_char
operator|)
literal|'\270'
block|,
operator|(
name|u_char
operator|)
literal|'\271'
block|,
operator|(
name|u_char
operator|)
literal|'\272'
block|,
operator|(
name|u_char
operator|)
literal|'\273'
block|,
operator|(
name|u_char
operator|)
literal|'\274'
block|,
operator|(
name|u_char
operator|)
literal|'\275'
block|,
operator|(
name|u_char
operator|)
literal|'\276'
block|,
operator|(
name|u_char
operator|)
literal|'\277'
block|,
operator|(
name|u_char
operator|)
literal|'\300'
block|,
operator|(
name|u_char
operator|)
literal|'\341'
block|,
operator|(
name|u_char
operator|)
literal|'\342'
block|,
operator|(
name|u_char
operator|)
literal|'\343'
block|,
operator|(
name|u_char
operator|)
literal|'\344'
block|,
operator|(
name|u_char
operator|)
literal|'\345'
block|,
operator|(
name|u_char
operator|)
literal|'\346'
block|,
operator|(
name|u_char
operator|)
literal|'\347'
block|,
operator|(
name|u_char
operator|)
literal|'\350'
block|,
operator|(
name|u_char
operator|)
literal|'\351'
block|,
operator|(
name|u_char
operator|)
literal|'\352'
block|,
operator|(
name|u_char
operator|)
literal|'\353'
block|,
operator|(
name|u_char
operator|)
literal|'\354'
block|,
operator|(
name|u_char
operator|)
literal|'\355'
block|,
operator|(
name|u_char
operator|)
literal|'\356'
block|,
operator|(
name|u_char
operator|)
literal|'\357'
block|,
operator|(
name|u_char
operator|)
literal|'\360'
block|,
operator|(
name|u_char
operator|)
literal|'\361'
block|,
operator|(
name|u_char
operator|)
literal|'\362'
block|,
operator|(
name|u_char
operator|)
literal|'\363'
block|,
operator|(
name|u_char
operator|)
literal|'\364'
block|,
operator|(
name|u_char
operator|)
literal|'\365'
block|,
operator|(
name|u_char
operator|)
literal|'\366'
block|,
operator|(
name|u_char
operator|)
literal|'\367'
block|,
operator|(
name|u_char
operator|)
literal|'\370'
block|,
operator|(
name|u_char
operator|)
literal|'\371'
block|,
operator|(
name|u_char
operator|)
literal|'\372'
block|,
operator|(
name|u_char
operator|)
literal|'\333'
block|,
operator|(
name|u_char
operator|)
literal|'\334'
block|,
operator|(
name|u_char
operator|)
literal|'\335'
block|,
operator|(
name|u_char
operator|)
literal|'\336'
block|,
operator|(
name|u_char
operator|)
literal|'\337'
block|,
operator|(
name|u_char
operator|)
literal|'\340'
block|,
operator|(
name|u_char
operator|)
literal|'\341'
block|,
operator|(
name|u_char
operator|)
literal|'\342'
block|,
operator|(
name|u_char
operator|)
literal|'\343'
block|,
operator|(
name|u_char
operator|)
literal|'\344'
block|,
operator|(
name|u_char
operator|)
literal|'\345'
block|,
operator|(
name|u_char
operator|)
literal|'\346'
block|,
operator|(
name|u_char
operator|)
literal|'\347'
block|,
operator|(
name|u_char
operator|)
literal|'\350'
block|,
operator|(
name|u_char
operator|)
literal|'\351'
block|,
operator|(
name|u_char
operator|)
literal|'\352'
block|,
operator|(
name|u_char
operator|)
literal|'\353'
block|,
operator|(
name|u_char
operator|)
literal|'\354'
block|,
operator|(
name|u_char
operator|)
literal|'\355'
block|,
operator|(
name|u_char
operator|)
literal|'\356'
block|,
operator|(
name|u_char
operator|)
literal|'\357'
block|,
operator|(
name|u_char
operator|)
literal|'\360'
block|,
operator|(
name|u_char
operator|)
literal|'\361'
block|,
operator|(
name|u_char
operator|)
literal|'\362'
block|,
operator|(
name|u_char
operator|)
literal|'\363'
block|,
operator|(
name|u_char
operator|)
literal|'\364'
block|,
operator|(
name|u_char
operator|)
literal|'\365'
block|,
operator|(
name|u_char
operator|)
literal|'\366'
block|,
operator|(
name|u_char
operator|)
literal|'\367'
block|,
operator|(
name|u_char
operator|)
literal|'\370'
block|,
operator|(
name|u_char
operator|)
literal|'\371'
block|,
operator|(
name|u_char
operator|)
literal|'\372'
block|,
operator|(
name|u_char
operator|)
literal|'\373'
block|,
operator|(
name|u_char
operator|)
literal|'\374'
block|,
operator|(
name|u_char
operator|)
literal|'\375'
block|,
operator|(
name|u_char
operator|)
literal|'\376'
block|,
operator|(
name|u_char
operator|)
literal|'\377'
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcap_strcasecmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
specifier|register
specifier|const
name|u_char
modifier|*
name|cm
init|=
name|charmap
decl_stmt|,
modifier|*
name|us1
init|=
operator|(
name|u_char
operator|*
operator|)
name|s1
decl_stmt|,
modifier|*
name|us2
init|=
operator|(
name|u_char
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|cm
index|[
operator|*
name|us1
index|]
operator|==
name|cm
index|[
operator|*
name|us2
operator|++
index|]
condition|)
if|if
condition|(
operator|*
name|us1
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|cm
index|[
operator|*
name|us1
index|]
operator|-
name|cm
index|[
operator|*
operator|--
name|us2
index|]
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_datalink_name_to_val
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcap_strcasecmp
argument_list|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|+
sizeof|sizeof
argument_list|(
literal|"DLT_"
argument_list|)
operator|-
literal|1
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|dlt
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_datalink_val_to_name
parameter_list|(
name|int
name|dlt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|dlt
operator|==
name|dlt
condition|)
return|return
operator|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|+
sizeof|sizeof
argument_list|(
literal|"DLT_"
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_datalink_val_to_description
parameter_list|(
name|int
name|dlt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|dlt
operator|==
name|dlt
condition|)
return|return
operator|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|description
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_snapshot
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|snapshot
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_is_swapped
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|sf
operator|.
name|swapped
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_major_version
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|sf
operator|.
name|version_major
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_minor_version
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|sf
operator|.
name|version_minor
operator|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|pcap_file
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|sf
operator|.
name|rfile
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_fileno
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|WIN32
return|return
operator|(
name|p
operator|->
name|fd
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|p
operator|->
name|adapter
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
name|int
operator|)
operator|(
name|DWORD
operator|)
name|p
operator|->
name|adapter
operator|->
name|hFile
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_function
name|int
name|pcap_get_selectable_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|selectable_fd
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pcap_perror
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|prefix
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|pcap_geterr
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|errbuf
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_getnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
return|return
name|p
operator|->
name|getnonblock_op
argument_list|(
name|p
argument_list|,
name|errbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current non-blocking mode setting, under the assumption that  * it's just the standard POSIX non-blocking flag.  *  * We don't look at "p->nonblock", in case somebody tweaked the FD  * directly.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_function
name|int
name|pcap_getnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fdflags
decl_stmt|;
name|fdflags
operator|=
name|fcntl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdflags
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"F_GETFL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fdflags
operator|&
name|O_NONBLOCK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pcap_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
return|return
name|p
operator|->
name|setnonblock_op
argument_list|(
name|p
argument_list|,
name|nonblock
argument_list|,
name|errbuf
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_comment
comment|/*  * Set non-blocking mode, under the assumption that it's just the  * standard POSIX non-blocking flag.  (This can be called by the  * per-platform non-blocking-mode routine if that routine also  * needs to do some additional work.)  */
end_comment

begin_function
name|int
name|pcap_setnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fdflags
decl_stmt|;
name|fdflags
operator|=
name|fcntl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdflags
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"F_GETFL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nonblock
condition|)
name|fdflags
operator||=
name|O_NONBLOCK
expr_stmt|;
else|else
name|fdflags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|fdflags
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"F_SETFL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/*  * Generate a string for the last Win32-specific error (i.e. an error generated when   * calling a Win32 API).  * For errors occurred during standard C calls, we still use pcap_strerror()  */
end_comment

begin_function
name|char
modifier|*
name|pcap_win32strerror
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|error
decl_stmt|;
specifier|static
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|errlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|error
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|,
literal|0
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * "FormatMessage()" "helpfully" sticks CR/LF at the end of the 	 * message.  Get rid of it. 	 */
name|errlen
operator|=
name|strlen
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errlen
operator|>=
literal|2
condition|)
block|{
name|errbuf
index|[
name|errlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|errbuf
index|[
name|errlen
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|errbuf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
operator|(
name|p
operator|-
name|errbuf
operator|)
argument_list|,
literal|" (%lu)"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|errbuf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Not all systems have strerror().  */
end_comment

begin_function
name|char
modifier|*
name|pcap_strerror
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_STRERROR
return|return
operator|(
name|strerror
argument_list|(
name|errnum
argument_list|)
operator|)
return|;
else|#
directive|else
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_errlist
index|[]
decl_stmt|;
specifier|static
name|char
name|ebuf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|errnum
operator|<
name|sys_nerr
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|sys_errlist
index|[
name|errnum
index|]
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
name|ebuf
argument_list|,
literal|"Unknown error: %d"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|ebuf
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|pcap_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
return|return
name|p
operator|->
name|setfilter_op
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set direction flag, which controls whether we accept only incoming  * packets, only outgoing packets, or both.  * Note that, depending on the platform, some or all direction arguments  * might not be supported.  */
end_comment

begin_function
name|int
name|pcap_setdirection
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|direction_t
name|d
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|setdirection_op
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Setting direction is not implemented on this platform"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
name|p
operator|->
name|setdirection_op
argument_list|(
name|p
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
return|return
name|p
operator|->
name|stats_op
argument_list|(
name|p
argument_list|,
name|ps
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_stats_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
name|_U_
parameter_list|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Statistics aren't available from a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcap_close_common
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
if|if
condition|(
name|p
operator|->
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|pcap_close_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
name|_U_
parameter_list|)
block|{
comment|/* Nothing to do. */
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_dead
parameter_list|(
name|int
name|linktype
parameter_list|,
name|int
name|snaplen
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
name|p
operator|->
name|linktype
operator|=
name|linktype
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
name|pcap_stats_dead
expr_stmt|;
name|p
operator|->
name|close_op
operator|=
name|pcap_close_dead
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * API compatible with WinPcap's "send a packet" routine - returns -1  * on error, 0 otherwise.  *  * XXX - what if we get a short write?  */
end_comment

begin_function
name|int
name|pcap_sendpacket
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|inject_op
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * API compatible with OpenBSD's "send a packet" routine - returns -1 on  * error, number of bytes written otherwise.  */
end_comment

begin_function
name|int
name|pcap_inject
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|inject_op
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcap_close
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|p
operator|->
name|close_op
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|dlt_list
argument_list|)
expr_stmt|;
name|pcap_freecode
argument_list|(
operator|&
name|p
operator|->
name|fcode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We make the version string static, and return a pointer to it, rather  * than exporting the version string directly.  On at least some UNIXes,  * if you import data from a shared library into an program, the data is  * bound into the program binary, so if the string in the version of the  * library with which the program was linked isn't the same as the  * string in the version of the library with which the program is being  * run, various undesirable things may happen (warnings, the string  * being the one from the version of the library with which the program  * was linked, or even weirder things, such as the string being the one  * from the library but being truncated).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VERSION_H
end_ifdef

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcap_version_string
index|[]
init|=
literal|"libpcap version 0.9[.x]"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/*  * XXX - it'd be nice if we could somehow generate the WinPcap and libpcap  * version numbers when building WinPcap.  (It'd be nice to do so for  * the packet.dll version number as well.)  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|wpcap_version_string
index|[]
init|=
literal|"3.1"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcap_version_string_fmt
index|[]
init|=
literal|"WinPcap version %s, based on %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcap_version_string_packet_dll_fmt
index|[]
init|=
literal|"WinPcap version %s (packet.dll version %s), based on %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|full_pcap_version_string
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|packet_version_string
decl_stmt|;
name|size_t
name|full_pcap_version_string_len
decl_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Generate the version string. 		 */
name|packet_version_string
operator|=
name|PacketGetVersion
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|wpcap_version_string
argument_list|,
name|packet_version_string
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * WinPcap version string and packet.dll version 			 * string are the same; just report the WinPcap 			 * version. 			 */
name|full_pcap_version_string_len
operator|=
operator|(
sizeof|sizeof
name|pcap_version_string_fmt
operator|-
literal|4
operator|)
operator|+
name|strlen
argument_list|(
name|wpcap_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|full_pcap_version_string
argument_list|,
name|pcap_version_string_fmt
argument_list|,
name|wpcap_version_string
argument_list|,
name|pcap_version_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * WinPcap version string and packet.dll version 			 * string are different; that shouldn't be the 			 * case (the two libraries should come from the 			 * same version of WinPcap), so we report both 			 * versions. 			 */
name|full_pcap_version_string_len
operator|=
operator|(
sizeof|sizeof
name|pcap_version_string_packet_dll_fmt
operator|-
literal|6
operator|)
operator|+
name|strlen
argument_list|(
name|wpcap_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|packet_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|full_pcap_version_string
argument_list|,
name|pcap_version_string_packet_dll_fmt
argument_list|,
name|wpcap_version_string
argument_list|,
name|packet_version_string
argument_list|,
name|pcap_version_string
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|full_pcap_version_string
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|full_pcap_version_string
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|packet_version_string
decl_stmt|;
name|size_t
name|full_pcap_version_string_len
decl_stmt|;
specifier|static
name|char
name|dospfx
index|[]
init|=
literal|"DOS-"
decl_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Generate the version string. 		 */
name|full_pcap_version_string_len
operator|=
sizeof|sizeof
name|dospfx
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_pcap_version_string
argument_list|,
name|dospfx
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_pcap_version_string
argument_list|,
name|pcap_version_string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|full_pcap_version_string
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UN*X */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|pcap_version_string
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

