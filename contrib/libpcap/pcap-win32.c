begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)  * Copyright (c) 2005 - 2010 CACE Technologies, Davis (California)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  * notice, this list of conditions and the following disclaimer in the  * documentation and/or other materials provided with the distribution.  * 3. Neither the name of the Politecnico di Torino, CACE Technologies  * nor the names of its contributors may be used to endorse or promote  * products derived from this software without specific prior written  * permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_define
define|#
directive|define
name|PCAP_DONT_INCLUDE_PCAP_BPF_H
end_define

begin_include
include|#
directive|include
file|<Packet32.h>
end_include

begin_include
include|#
directive|include
file|<pcap-int.h>
end_include

begin_include
include|#
directive|include
file|<pcap/dlt.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__MINGW32__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__MINGW64__
end_ifdef

begin_include
include|#
directive|include
file|<ntddndis.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*__MINGW64__*/
end_comment

begin_include
include|#
directive|include
file|<ddk/ntddndis.h>
end_include

begin_include
include|#
directive|include
file|<ddk/ndis.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*__MINGW64__*/
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*__MINGW32__*/
end_comment

begin_include
include|#
directive|include
file|<ntddndis.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*__MINGW32__*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DAG_API
end_ifdef

begin_include
include|#
directive|include
file|<dagnew.h>
end_include

begin_include
include|#
directive|include
file|<dagapi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_DAG_API */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MINGW32__
end_ifdef

begin_function_decl
name|int
modifier|*
name|_errno
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|errno
value|(*_errno())
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __MINGW32__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_REMOTE
end_ifdef

begin_include
include|#
directive|include
file|"pcap-rpcap.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_REMOTE */
end_comment

begin_function_decl
specifier|static
name|int
name|pcap_setfilter_win32_npf
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setfilter_win32_dag
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_getnonblock_win32
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setnonblock_win32
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*dimension of the buffer in the pcap_t structure*/
end_comment

begin_define
define|#
directive|define
name|WIN32_DEFAULT_USER_BUFFER_SIZE
value|256000
end_define

begin_comment
comment|/*dimension of the buffer in the kernel driver NPF */
end_comment

begin_define
define|#
directive|define
name|WIN32_DEFAULT_KERNEL_BUFFER_SIZE
value|1000000
end_define

begin_comment
comment|/* Equivalent to ntohs(), but a lot faster under Windows */
end_comment

begin_define
define|#
directive|define
name|SWAPS
parameter_list|(
name|_X
parameter_list|)
value|((_X& 0xff)<< 8) | (_X>> 8)
end_define

begin_comment
comment|/*  * Private data for capturing on WinPcap devices.  */
end_comment

begin_struct
struct|struct
name|pcap_win
block|{
name|int
name|nonblock
decl_stmt|;
name|int
name|rfmon_selfstart
decl_stmt|;
comment|/* a flag tells whether the monitor mode is set by itself */
name|int
name|filtering_in_kernel
decl_stmt|;
comment|/* using kernel filter */
ifdef|#
directive|ifdef
name|HAVE_DAG_API
name|int
name|dag_fcs_bits
decl_stmt|;
comment|/* Number of checksum bits from link layer */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_function
name|BOOL
name|WINAPI
name|DllMain
parameter_list|(
name|HANDLE
name|hinstDLL
parameter_list|,
name|DWORD
name|dwReason
parameter_list|,
name|LPVOID
name|lpvReserved
parameter_list|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define stub versions of the monitor-mode support routines if this  * isn't Npcap. HAVE_NPCAP_PACKET_API is defined by Npcap but not  * WinPcap.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_NPCAP_PACKET_API
end_ifndef

begin_function
specifier|static
name|int
name|PacketIsMonitorModeSupported
parameter_list|(
name|PCHAR
name|AdapterName
name|_U_
parameter_list|)
block|{
comment|/* 	 * We don't support monitor mode. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PacketSetMonitorMode
parameter_list|(
name|PCHAR
name|AdapterName
name|_U_
parameter_list|,
name|int
name|mode
name|_U_
parameter_list|)
block|{
comment|/* 	 * This should never be called, as PacketIsMonitorModeSupported() 	 * will return 0, meaning "we don't support monitor mode, so 	 * don't try to turn it on or off". 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PacketGetMonitorMode
parameter_list|(
name|PCHAR
name|AdapterName
name|_U_
parameter_list|)
block|{
comment|/* 	 * This should fail, so that pcap_activate_win32() returns 	 * PCAP_ERROR_RFMON_NOTSUP if our caller requested monitor 	 * mode. 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Start winsock */
end_comment

begin_function
name|int
name|wsockinit
parameter_list|(
name|void
parameter_list|)
block|{
name|WORD
name|wVersionRequested
decl_stmt|;
name|WSADATA
name|wsaData
decl_stmt|;
specifier|static
name|int
name|err
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|done
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|WSACleanup
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|err
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_wsockinit
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|wsockinit
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_stats_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|bpf_stat
name|bstats
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Try to get statistics. 	 * 	 * (Please note - "struct pcap_stat" is *not* the same as 	 * WinPcap's "struct bpf_stat". It might currently have the 	 * same layout, but let's not cheat. 	 * 	 * Note also that we don't fill in ps_capt, as we might have 	 * been called by code compiled against an earlier version of 	 * WinPcap that didn't have ps_capt, in which case filling it 	 * in would stomp on whatever comes after the structure passed 	 * to us. 	 */
if|if
condition|(
operator|!
name|PacketGetStats
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
operator|&
name|bstats
argument_list|)
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"PacketGetStats error: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ps
operator|->
name|ps_recv
operator|=
name|bstats
operator|.
name|bs_recv
expr_stmt|;
name|ps
operator|->
name|ps_drop
operator|=
name|bstats
operator|.
name|bs_drop
expr_stmt|;
comment|/* 	 * XXX - PacketGetStats() doesn't fill this in, so we just 	 * return 0. 	 */
if|#
directive|if
literal|0
block|ps->ps_ifdrop = bstats.ps_ifdrop;
else|#
directive|else
name|ps
operator|->
name|ps_ifdrop
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Win32-only routine for getting statistics.  *  * This way is definitely safer than passing the pcap_stat * from the userland.  * In fact, there could happen than the user allocates a variable which is not  * big enough for the new structure, and the library will write in a zone  * which is not allocated to this variable.  *  * In this way, we're pretty sure we are writing on memory allocated to this  * variable.  *  * XXX - but this is the wrong way to handle statistics.  Instead, we should  * have an API that returns data in a form like the Options section of a  * pcapng Interface Statistics Block:  *  *    http://xml2rfc.tools.ietf.org/cgi-bin/xml2rfc.cgi?url=https://raw.githubusercontent.com/pcapng/pcapng/master/draft-tuexen-opsawg-pcapng.xml&modeAsFormat=html/ascii&type=ascii#rfc.section.4.6  *  * which would let us add new statistics straightforwardly and indicate which  * statistics we are and are *not* providing, rather than having to provide  * possibly-bogus values for statistics we can't provide.  */
end_comment

begin_function
name|struct
name|pcap_stat
modifier|*
name|pcap_stats_ex_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|pcap_stat_size
parameter_list|)
block|{
name|struct
name|bpf_stat
name|bstats
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
operator|*
name|pcap_stat_size
operator|=
sizeof|sizeof
argument_list|(
name|p
operator|->
name|stat
argument_list|)
expr_stmt|;
comment|/* 	 * Try to get statistics. 	 * 	 * (Please note - "struct pcap_stat" is *not* the same as 	 * WinPcap's "struct bpf_stat". It might currently have the 	 * same layout, but let's not cheat.) 	 */
if|if
condition|(
operator|!
name|PacketGetStatsEx
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
operator|&
name|bstats
argument_list|)
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"PacketGetStatsEx error: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|stat
operator|.
name|ps_recv
operator|=
name|bstats
operator|.
name|bs_recv
expr_stmt|;
name|p
operator|->
name|stat
operator|.
name|ps_drop
operator|=
name|bstats
operator|.
name|bs_drop
expr_stmt|;
name|p
operator|->
name|stat
operator|.
name|ps_ifdrop
operator|=
name|bstats
operator|.
name|ps_ifdrop
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_REMOTE
name|p
operator|->
name|stat
operator|.
name|ps_capt
operator|=
name|bstats
operator|.
name|bs_capt
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|&
name|p
operator|->
name|stat
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the dimension of the kernel-level capture buffer */
end_comment

begin_function
specifier|static
name|int
name|pcap_setbuff_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dim
parameter_list|)
block|{
if|if
condition|(
name|PacketSetBuff
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|dim
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"driver error: not enough memory to allocate the kernel buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the driver working mode */
end_comment

begin_function
specifier|static
name|int
name|pcap_setmode_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|PacketSetMode
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|mode
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"driver error: working mode not recognized"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*set the minimum amount of data that will release a read call*/
end_comment

begin_function
specifier|static
name|int
name|pcap_setmintocopy_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|PacketSetMinToCopy
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|size
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"driver error: unable to set the requested mintocopy size"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|HANDLE
name|pcap_getevent_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|PacketGetReadEvent
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_oid_get_request_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|oid
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
name|PACKET_OID_DATA
modifier|*
name|oid_data_arg
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Allocate a PACKET_OID_DATA structure to hand to PacketRequest(). 	 * It should be big enough to hold "*lenp" bytes of data; it 	 * will actually be slightly larger, as PACKET_OID_DATA has a 	 * 1-byte data array at the end, standing in for the variable-length 	 * data that's actually there. 	 */
name|oid_data_arg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PACKET_OID_DATA
argument_list|)
operator|+
operator|*
name|lenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid_data_arg
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Couldn't allocate argument buffer for PacketRequest"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
comment|/* 	 * No need to copy the data - we're doing a fetch. 	 */
name|oid_data_arg
operator|->
name|Oid
operator|=
name|oid
expr_stmt|;
name|oid_data_arg
operator|->
name|Length
operator|=
call|(
name|ULONG
call|)
argument_list|(
operator|*
name|lenp
argument_list|)
expr_stmt|;
comment|/* XXX - check for ridiculously large value? */
if|if
condition|(
operator|!
name|PacketRequest
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|FALSE
argument_list|,
name|oid_data_arg
argument_list|)
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error calling PacketRequest: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid_data_arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
comment|/* 	 * Get the length actually supplied. 	 */
operator|*
name|lenp
operator|=
name|oid_data_arg
operator|->
name|Length
expr_stmt|;
comment|/* 	 * Copy back the data we fetched. 	 */
name|memcpy
argument_list|(
name|data
argument_list|,
name|oid_data_arg
operator|->
name|Data
argument_list|,
operator|*
name|lenp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid_data_arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_oid_set_request_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|oid
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
name|PACKET_OID_DATA
modifier|*
name|oid_data_arg
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Allocate a PACKET_OID_DATA structure to hand to PacketRequest(). 	 * It should be big enough to hold "*lenp" bytes of data; it 	 * will actually be slightly larger, as PACKET_OID_DATA has a 	 * 1-byte data array at the end, standing in for the variable-length 	 * data that's actually there. 	 */
name|oid_data_arg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PACKET_OID_DATA
argument_list|)
operator|+
operator|*
name|lenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid_data_arg
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Couldn't allocate argument buffer for PacketRequest"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|oid_data_arg
operator|->
name|Oid
operator|=
name|oid
expr_stmt|;
name|oid_data_arg
operator|->
name|Length
operator|=
call|(
name|ULONG
call|)
argument_list|(
operator|*
name|lenp
argument_list|)
expr_stmt|;
comment|/* XXX - check for ridiculously large value? */
name|memcpy
argument_list|(
name|oid_data_arg
operator|->
name|Data
argument_list|,
name|data
argument_list|,
operator|*
name|lenp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PacketRequest
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|TRUE
argument_list|,
name|oid_data_arg
argument_list|)
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error calling PacketRequest: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid_data_arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
comment|/* 	 * Get the length actually copied. 	 */
operator|*
name|lenp
operator|=
name|oid_data_arg
operator|->
name|Length
expr_stmt|;
comment|/* 	 * No need to copy the data - we're doing a set. 	 */
name|free
argument_list|(
name|oid_data_arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|pcap_sendqueue_transmit_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_send_queue
modifier|*
name|queue
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
name|u_int
name|res
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|adapter
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Cannot transmit a queue to an offline capture or to a TurboCap port"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|res
operator|=
name|PacketSendPackets
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|queue
operator|->
name|buffer
argument_list|,
name|queue
operator|->
name|len
argument_list|,
operator|(
name|BOOLEAN
operator|)
name|sync
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|queue
operator|->
name|len
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error opening adapter: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setuserbuffer_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|new_buff
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
comment|/* Bogus parameter */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error: invalid size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Allocate the buffer */
name|new_buff
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_buff
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error: not enough memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|new_buff
expr_stmt|;
name|p
operator|->
name|bufsize
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_live_dump_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|maxsize
parameter_list|,
name|int
name|maxpacks
parameter_list|)
block|{
name|BOOLEAN
name|res
decl_stmt|;
comment|/* Set the packet driver in dump mode */
name|res
operator|=
name|PacketSetMode
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|PACKET_MODE_DUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|FALSE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error setting dump mode"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Set the name of the dump file */
name|res
operator|=
name|PacketSetDumpName
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|filename
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|FALSE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error setting kernel dump file name"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Set the limits of the dump file */
name|res
operator|=
name|PacketSetDumpLimits
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|maxsize
argument_list|,
name|maxpacks
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_live_dump_ended_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
return|return
operator|(
name|PacketIsDumpEnded
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
operator|(
name|BOOLEAN
operator|)
name|sync
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|PAirpcapHandle
name|pcap_get_airpcap_handle_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_AIRPCAP_API
return|return
operator|(
name|PacketGetAirPcapHandle
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_AIRPCAP_API */
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_read_win32_npf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|PACKET
name|Packet
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|u_char
modifier|*
name|datap
decl_stmt|;
name|struct
name|pcap_win
modifier|*
name|pw
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|cc
operator|=
name|p
operator|->
name|cc
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|cc
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Has "pcap_breakloop()" been called? 		 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 			 * Yes - clear the flag that indicates that it 			 * has, and return PCAP_ERROR_BREAK to indicate 			 * that we were told to break out of the loop. 			 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_BREAK
operator|)
return|;
block|}
comment|/* 		 * Capture the packets. 		 * 		 * The PACKET structure had a bunch of extra stuff for 		 * Windows 9x/Me, but the only interesting data in it 		 * in the versions of Windows that we support is just 		 * a copy of p->buffer, a copy of p->buflen, and the 		 * actual number of bytes read returned from 		 * PacketReceivePacket(), none of which has to be 		 * retained from call to call, so we just keep one on 		 * the stack. 		 */
name|PacketInitPacket
argument_list|(
operator|&
name|Packet
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|p
operator|->
name|buffer
argument_list|,
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PacketReceivePacket
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
operator|&
name|Packet
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"read error: PacketReceivePacket failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|cc
operator|=
name|Packet
operator|.
name|ulBytesReceived
expr_stmt|;
name|bp
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
block|}
else|else
name|bp
operator|=
name|p
operator|->
name|bp
expr_stmt|;
comment|/* 	 * Loop through each packet. 	 */
define|#
directive|define
name|bhp
value|((struct bpf_hdr *)bp)
name|ep
operator|=
name|bp
operator|+
name|cc
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|caplen
decl_stmt|,
name|hdrlen
decl_stmt|;
comment|/* 		 * Has "pcap_breakloop()" been called? 		 * If so, return immediately - if we haven't read any 		 * packets, clear the flag and return PCAP_ERROR_BREAK 		 * to indicate that we were told to break out of the loop, 		 * otherwise leave the flag set, so that the *next* call 		 * will break out of the loop without having read any 		 * packets, and return the number of packets we've 		 * processed so far. 		 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_BREAK
operator|)
return|;
block|}
else|else
block|{
name|p
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|p
operator|->
name|cc
operator|=
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bp
operator|>=
name|ep
condition|)
break|break;
name|caplen
operator|=
name|bhp
operator|->
name|bh_caplen
expr_stmt|;
name|hdrlen
operator|=
name|bhp
operator|->
name|bh_hdrlen
expr_stmt|;
name|datap
operator|=
name|bp
operator|+
name|hdrlen
expr_stmt|;
comment|/* 		 * Short-circuit evaluation: if using BPF filter 		 * in kernel, no need to do it now - we already know 		 * the packet passed the filter. 		 * 		 * XXX - bpf_filter() should always return TRUE if 		 * handed a null pointer for the program, but it might 		 * just try to "run" the filter, so we check here. 		 */
if|if
condition|(
name|pw
operator|->
name|filtering_in_kernel
operator|||
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
operator|||
name|bpf_filter
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|datap
argument_list|,
name|bhp
operator|->
name|bh_datalen
argument_list|,
name|caplen
argument_list|)
condition|)
block|{
comment|/* 			 * XXX A bpf_hdr matches a pcap_pkthdr. 			 */
call|(
modifier|*
name|callback
call|)
argument_list|(
name|user
argument_list|,
operator|(
expr|struct
name|pcap_pkthdr
operator|*
operator|)
name|bp
argument_list|,
name|datap
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|Packet_WORDALIGN
argument_list|(
name|caplen
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|>=
name|cnt
operator|&&
operator|!
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|cnt
argument_list|)
condition|)
block|{
name|p
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|p
operator|->
name|cc
operator|=
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * Skip this packet. 			 */
name|bp
operator|+=
name|Packet_WORDALIGN
argument_list|(
name|caplen
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|bhp
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DAG_API
end_ifdef

begin_function
specifier|static
name|int
name|pcap_read_win32_dag
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|pcap_win
modifier|*
name|pw
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|PACKET
name|Packet
decl_stmt|;
name|u_char
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|int
name|packet_len
init|=
literal|0
decl_stmt|,
name|caplen
init|=
literal|0
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
name|u_char
modifier|*
name|endofbuf
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|dag_record_t
modifier|*
name|header
decl_stmt|;
name|unsigned
name|erf_record_len
decl_stmt|;
name|ULONGLONG
name|ts
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|unsigned
name|swt
decl_stmt|;
name|unsigned
name|dfp
init|=
name|p
operator|->
name|adapter
operator|->
name|DagFastProcess
decl_stmt|;
name|cc
operator|=
name|p
operator|->
name|cc
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
comment|/* Get new packets only if we have processed all the ones of the previous read */
block|{
comment|/* 		 * Get new packets from the network. 		 * 		 * The PACKET structure had a bunch of extra stuff for 		 * Windows 9x/Me, but the only interesting data in it 		 * in the versions of Windows that we support is just 		 * a copy of p->buffer, a copy of p->buflen, and the 		 * actual number of bytes read returned from 		 * PacketReceivePacket(), none of which has to be 		 * retained from call to call, so we just keep one on 		 * the stack. 		 */
name|PacketInitPacket
argument_list|(
operator|&
name|Packet
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|p
operator|->
name|buffer
argument_list|,
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PacketReceivePacket
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
operator|&
name|Packet
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"read error: PacketReceivePacket failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cc
operator|=
name|Packet
operator|.
name|ulBytesReceived
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
comment|/* The timeout has expired but we no packets arrived */
return|return
operator|(
literal|0
operator|)
return|;
name|header
operator|=
operator|(
name|dag_record_t
operator|*
operator|)
name|p
operator|->
name|adapter
operator|->
name|DagBuffer
expr_stmt|;
block|}
else|else
name|header
operator|=
operator|(
name|dag_record_t
operator|*
operator|)
name|p
operator|->
name|bp
expr_stmt|;
name|endofbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|header
operator|+
name|cc
expr_stmt|;
comment|/* 	 * Cycle through the packets 	 */
do|do
block|{
name|erf_record_len
operator|=
name|SWAPS
argument_list|(
name|header
operator|->
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|header
operator|+
name|erf_record_len
operator|>
name|endofbuf
condition|)
break|break;
comment|/* Increase the number of captured packets */
name|p
operator|->
name|stat
operator|.
name|ps_recv
operator|++
expr_stmt|;
comment|/* Find the beginning of the packet */
name|dp
operator|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|header
operator|)
operator|+
name|dag_record_size
expr_stmt|;
comment|/* Determine actual packet len */
switch|switch
condition|(
name|header
operator|->
name|type
condition|)
block|{
case|case
name|TYPE_ATM
case|:
name|packet_len
operator|=
name|ATM_SNAPLEN
expr_stmt|;
name|caplen
operator|=
name|ATM_SNAPLEN
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPE_ETH
case|:
name|swt
operator|=
name|SWAPS
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|packet_len
operator|=
name|swt
operator|-
operator|(
name|pw
operator|->
name|dag_fcs_bits
operator|)
expr_stmt|;
name|caplen
operator|=
name|erf_record_len
operator|-
name|dag_record_size
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
name|dp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TYPE_HDLC_POS
case|:
name|swt
operator|=
name|SWAPS
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|packet_len
operator|=
name|swt
operator|-
operator|(
name|pw
operator|->
name|dag_fcs_bits
operator|)
expr_stmt|;
name|caplen
operator|=
name|erf_record_len
operator|-
name|dag_record_size
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|caplen
operator|>
name|p
operator|->
name|snapshot
condition|)
name|caplen
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
comment|/* 		 * Has "pcap_breakloop()" been called? 		 * If so, return immediately - if we haven't read any 		 * packets, clear the flag and return -2 to indicate 		 * that we were told to break out of the loop, otherwise 		 * leave the flag set, so that the *next* call will break 		 * out of the loop without having read any packets, and 		 * return the number of packets we've processed so far. 		 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
else|else
block|{
name|p
operator|->
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|header
expr_stmt|;
name|p
operator|->
name|cc
operator|=
name|endofbuf
operator|-
operator|(
name|char
operator|*
operator|)
name|header
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|dfp
condition|)
block|{
comment|/* convert between timestamp formats */
name|ts
operator|=
name|header
operator|->
name|ts
expr_stmt|;
name|pcap_header
operator|.
name|ts
operator|.
name|tv_sec
operator|=
call|(
name|int
call|)
argument_list|(
name|ts
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|ts
operator|=
operator|(
name|ts
operator|&
literal|0xffffffffi64
operator|)
operator|*
literal|1000000
expr_stmt|;
name|ts
operator|+=
literal|0x80000000
expr_stmt|;
comment|/* rounding */
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|=
call|(
name|int
call|)
argument_list|(
name|ts
operator|>>
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
name|pcap_header
operator|.
name|ts
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
block|}
comment|/* No underlaying filtering system. We need to filter on our own */
if|if
condition|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
condition|)
block|{
if|if
condition|(
name|bpf_filter
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|dp
argument_list|,
name|packet_len
argument_list|,
name|caplen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Move to next packet */
name|header
operator|=
operator|(
name|dag_record_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|header
operator|+
name|erf_record_len
operator|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Fill the header for the user suppplied callback function */
name|pcap_header
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pcap_header
operator|.
name|len
operator|=
name|packet_len
expr_stmt|;
comment|/* Call the callback function */
call|(
modifier|*
name|callback
call|)
argument_list|(
name|user
argument_list|,
operator|&
name|pcap_header
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* Move to next packet */
name|header
operator|=
operator|(
name|dag_record_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|header
operator|+
name|erf_record_len
operator|)
expr_stmt|;
comment|/* Stop if the number of packets requested by user has been reached*/
if|if
condition|(
operator|++
name|n
operator|>=
name|cnt
operator|&&
operator|!
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|cnt
argument_list|)
condition|)
block|{
name|p
operator|->
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|header
expr_stmt|;
name|p
operator|->
name|cc
operator|=
name|endofbuf
operator|-
operator|(
name|char
operator|*
operator|)
name|header
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|(
name|u_char
operator|*
operator|)
name|header
operator|<
name|endofbuf
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_DAG_API */
end_comment

begin_comment
comment|/* Send a packet to the network */
end_comment

begin_function
specifier|static
name|int
name|pcap_inject_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|LPPACKET
name|PacketToSend
decl_stmt|;
name|PacketToSend
operator|=
name|PacketAllocatePacket
argument_list|()
expr_stmt|;
if|if
condition|(
name|PacketToSend
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send error: PacketAllocatePacket failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PacketInitPacket
argument_list|(
name|PacketToSend
argument_list|,
operator|(
name|PVOID
operator|)
name|buf
argument_list|,
operator|(
name|UINT
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|PacketSendPacket
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|PacketToSend
argument_list|,
name|TRUE
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send error: PacketSendPacket failed"
argument_list|)
expr_stmt|;
name|PacketFreePacket
argument_list|(
name|PacketToSend
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PacketFreePacket
argument_list|(
name|PacketToSend
argument_list|)
expr_stmt|;
comment|/* 	 * We assume it all got sent if "PacketSendPacket()" succeeded. 	 * "pcap_inject()" is expected to return the number of bytes 	 * sent. 	 */
return|return
operator|(
operator|(
name|int
operator|)
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcap_cleanup_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_win
modifier|*
name|pw
init|=
name|p
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|adapter
operator|!=
name|NULL
condition|)
block|{
name|PacketCloseAdapter
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|p
operator|->
name|adapter
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pw
operator|->
name|rfmon_selfstart
condition|)
block|{
name|PacketSetMonitorMode
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pcap_cleanup_live_common
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_activate_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_win
modifier|*
name|pw
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|NetType
name|type
decl_stmt|;
name|int
name|res
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_REMOTE
name|char
name|host
index|[
name|PCAP_BUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|port
index|[
name|PCAP_BUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|name
index|[
name|PCAP_BUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|srctype
decl_stmt|;
name|int
name|opensource_remote_result
decl_stmt|;
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
comment|/* 	Retrofit; we have to make older applications compatible with the remote capture 	So, we're calling the pcap_open_remote() from here, that is a very dirty thing. 	Obviously, we cannot exploit all the new features; for instance, we cannot 	send authentication, we cannot use a UDP data connection, and so on. 	*/
if|if
condition|(
name|pcap_parsesrcstr
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
operator|&
name|srctype
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|name
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
condition|)
return|return
name|PCAP_ERROR
return|;
if|if
condition|(
name|srctype
operator|==
name|PCAP_SRC_IFREMOTE
condition|)
block|{
name|opensource_remote_result
operator|=
name|pcap_opensource_remote
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|opensource_remote_result
operator|!=
literal|0
condition|)
return|return
name|opensource_remote_result
return|;
name|md
operator|->
name|rmt_flags
operator|=
operator|(
name|p
operator|->
name|opt
operator|.
name|promisc
operator|)
condition|?
name|PCAP_OPENFLAG_PROMISCUOUS
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|srctype
operator|==
name|PCAP_SRC_IFLOCAL
condition|)
block|{
comment|/* 		* If it starts with rpcap://, cut down the string 		*/
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|PCAP_SRC_IF_STRING
argument_list|,
name|strlen
argument_list|(
name|PCAP_SRC_IF_STRING
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
operator|-
name|strlen
argument_list|(
name|PCAP_SRC_IF_STRING
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|new_string
decl_stmt|;
comment|/* 			* allocate a new string and free the old one 			*/
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|new_string
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_string
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|strcpy_s
argument_list|(
name|new_string
argument_list|,
name|len
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
operator|+
name|strlen
argument_list|(
name|PCAP_SRC_IF_STRING
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|p
operator|->
name|opt
operator|.
name|device
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|device
operator|=
name|new_string
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_REMOTE */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 		 * Monitor mode is supported on Windows Vista and later. 		 */
if|if
condition|(
name|PacketGetMonitorMode
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
operator|==
literal|1
condition|)
block|{
name|pw
operator|->
name|rfmon_selfstart
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|PacketSetMonitorMode
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
name|pw
operator|->
name|rfmon_selfstart
operator|=
literal|0
expr_stmt|;
comment|// Monitor mode is not supported.
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
return|return
name|PCAP_ERROR_RFMON_NOTSUP
return|;
block|}
else|else
block|{
return|return
name|PCAP_ERROR
return|;
block|}
block|}
else|else
block|{
name|pw
operator|->
name|rfmon_selfstart
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Init WinSock */
name|wsockinit
argument_list|()
expr_stmt|;
name|p
operator|->
name|adapter
operator|=
name|PacketOpenAdapter
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|adapter
operator|==
name|NULL
condition|)
block|{
comment|/* Adapter detected but we are not able to open it. Return failure. */
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|rfmon_selfstart
condition|)
block|{
name|PacketSetMonitorMode
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error opening adapter: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
comment|/*get network type*/
if|if
condition|(
name|PacketGetNetType
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
operator|&
name|type
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Cannot determine the network type: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/*Set the linktype*/
switch|switch
condition|(
name|type
operator|.
name|LinkType
condition|)
block|{
case|case
name|NdisMediumWan
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
break|break;
case|case
name|NdisMedium802_3
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
comment|/* 		 * This is (presumably) a real Ethernet capture; give it a 		 * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so 		 * that an application can let you choose it, in case you're 		 * capturing DOCSIS traffic that a Cisco Cable Modem 		 * Termination System is putting out onto an Ethernet (it 		 * doesn't put an Ethernet header onto the wire, it puts raw 		 * DOCSIS frames out on the wire inside the low-level 		 * Ethernet framing). 		 */
name|p
operator|->
name|dlt_list
operator|=
operator|(
name|u_int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * If that fails, just leave the list empty. 		 */
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|=
name|DLT_EN10MB
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
literal|1
index|]
operator|=
name|DLT_DOCSIS
expr_stmt|;
name|p
operator|->
name|dlt_count
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|NdisMediumFddi
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_FDDI
expr_stmt|;
break|break;
case|case
name|NdisMedium802_5
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_IEEE802
expr_stmt|;
break|break;
case|case
name|NdisMediumArcnetRaw
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_ARCNET
expr_stmt|;
break|break;
case|case
name|NdisMediumArcnet878_2
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_ARCNET
expr_stmt|;
break|break;
case|case
name|NdisMediumAtm
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_ATM_RFC1483
expr_stmt|;
break|break;
case|case
name|NdisMediumCHDLC
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_CHDLC
expr_stmt|;
break|break;
case|case
name|NdisMediumPPPSerial
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_PPP_SERIAL
expr_stmt|;
break|break;
case|case
name|NdisMediumNull
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_NULL
expr_stmt|;
break|break;
case|case
name|NdisMediumBare80211
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_IEEE802_11
expr_stmt|;
break|break;
case|case
name|NdisMediumRadio80211
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_IEEE802_11_RADIO
expr_stmt|;
break|break;
case|case
name|NdisMediumPpi
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_PPI
expr_stmt|;
break|break;
default|default:
name|p
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
comment|/*an unknown adapter is assumed to be ethernet*/
break|break;
block|}
comment|/* Set promiscuous mode */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
if|if
condition|(
name|PacketSetHwFilter
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|NDIS_PACKET_TYPE_PROMISCUOUS
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"failed to set hardware filter to promiscuous mode"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|PacketSetHwFilter
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|NDIS_PACKET_TYPE_ALL_LOCAL
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"failed to set hardware filter to non-promiscuous mode"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* Set the buffer size */
name|p
operator|->
name|bufsize
operator|=
name|WIN32_DEFAULT_USER_BUFFER_SIZE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|adapter
operator|->
name|Flags
operator|&
name|INFO_FLAG_DAG_CARD
operator|)
condition|)
block|{
comment|/* 	 * Traditional Adapter 	 */
comment|/* 		 * If the buffer size wasn't explicitly set, default to 		 * WIN32_DEFAULT_KERNEL_BUFFER_SIZE. 		 */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|buffer_size
operator|==
literal|0
condition|)
name|p
operator|->
name|opt
operator|.
name|buffer_size
operator|=
name|WIN32_DEFAULT_KERNEL_BUFFER_SIZE
expr_stmt|;
if|if
condition|(
name|PacketSetBuff
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|p
operator|->
name|opt
operator|.
name|buffer_size
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"driver error: not enough memory to allocate the kernel buffer"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|p
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|immediate
condition|)
block|{
comment|/* tell the driver to copy the buffer as soon as data arrives */
if|if
condition|(
name|PacketSetMinToCopy
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
literal|0
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error calling PacketSetMinToCopy: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
comment|/* tell the driver to copy the buffer only if it contains at least 16K */
if|if
condition|(
name|PacketSetMinToCopy
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
literal|16000
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error calling PacketSetMinToCopy: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
else|else
ifdef|#
directive|ifdef
name|HAVE_DAG_API
block|{
comment|/* 	 * Dag Card 	 */
name|LONG
name|status
decl_stmt|;
name|HKEY
name|dagkey
decl_stmt|;
name|DWORD
name|lptype
decl_stmt|;
name|DWORD
name|lpcbdata
decl_stmt|;
name|int
name|postype
init|=
literal|0
decl_stmt|;
name|char
name|keyname
index|[
literal|512
index|]
decl_stmt|;
name|pcap_snprintf
argument_list|(
name|keyname
argument_list|,
sizeof|sizeof
argument_list|(
name|keyname
argument_list|)
argument_list|,
literal|"%s\\CardParams\\%s"
argument_list|,
literal|"SYSTEM\\CurrentControlSet\\Services\\DAG"
argument_list|,
name|strstr
argument_list|(
name|_strlwr
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
argument_list|,
literal|"dag"
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|status
operator|=
name|RegOpenKeyEx
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|keyname
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|dagkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ERROR_SUCCESS
condition|)
break|break;
name|status
operator|=
name|RegQueryValueEx
argument_list|(
name|dagkey
argument_list|,
literal|"PosType"
argument_list|,
name|NULL
argument_list|,
operator|&
name|lptype
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|postype
argument_list|,
operator|&
name|lpcbdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|postype
operator|=
literal|0
expr_stmt|;
block|}
name|RegCloseKey
argument_list|(
name|dagkey
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|FALSE
condition|)
do|;
name|p
operator|->
name|snapshot
operator|=
name|PacketSetSnapLen
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|snaplen
argument_list|)
expr_stmt|;
comment|/* Set the length of the FCS associated to any packet. This value 		 * will be subtracted to the packet length */
name|pw
operator|->
name|dag_fcs_bits
operator|=
name|p
operator|->
name|adapter
operator|->
name|DagFcsLen
expr_stmt|;
block|}
else|#
directive|else
goto|goto
name|bad
goto|;
endif|#
directive|endif
comment|/* HAVE_DAG_API */
name|PacketSetReadTimeout
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|p
operator|->
name|opt
operator|.
name|timeout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_API
if|if
condition|(
name|p
operator|->
name|adapter
operator|->
name|Flags
operator|&
name|INFO_FLAG_DAG_CARD
condition|)
block|{
comment|/* install dag specific handlers for read and setfilter */
name|p
operator|->
name|read_op
operator|=
name|pcap_read_win32_dag
expr_stmt|;
name|p
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_win32_dag
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* HAVE_DAG_API */
comment|/* install traditional npf handlers for read and setfilter */
name|p
operator|->
name|read_op
operator|=
name|pcap_read_win32_npf
expr_stmt|;
name|p
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_win32_npf
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_API
block|}
endif|#
directive|endif
comment|/* HAVE_DAG_API */
name|p
operator|->
name|setdirection_op
operator|=
name|NULL
expr_stmt|;
comment|/* Not implemented. */
comment|/* XXX - can this be implemented on some versions of Windows? */
name|p
operator|->
name|inject_op
operator|=
name|pcap_inject_win32
expr_stmt|;
name|p
operator|->
name|set_datalink_op
operator|=
name|NULL
expr_stmt|;
comment|/* can't change data link type */
name|p
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_win32
expr_stmt|;
name|p
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_win32
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
name|pcap_stats_win32
expr_stmt|;
name|p
operator|->
name|stats_ex_op
operator|=
name|pcap_stats_ex_win32
expr_stmt|;
name|p
operator|->
name|setbuff_op
operator|=
name|pcap_setbuff_win32
expr_stmt|;
name|p
operator|->
name|setmode_op
operator|=
name|pcap_setmode_win32
expr_stmt|;
name|p
operator|->
name|setmintocopy_op
operator|=
name|pcap_setmintocopy_win32
expr_stmt|;
name|p
operator|->
name|getevent_op
operator|=
name|pcap_getevent_win32
expr_stmt|;
name|p
operator|->
name|oid_get_request_op
operator|=
name|pcap_oid_get_request_win32
expr_stmt|;
name|p
operator|->
name|oid_set_request_op
operator|=
name|pcap_oid_set_request_win32
expr_stmt|;
name|p
operator|->
name|sendqueue_transmit_op
operator|=
name|pcap_sendqueue_transmit_win32
expr_stmt|;
name|p
operator|->
name|setuserbuffer_op
operator|=
name|pcap_setuserbuffer_win32
expr_stmt|;
name|p
operator|->
name|live_dump_op
operator|=
name|pcap_live_dump_win32
expr_stmt|;
name|p
operator|->
name|live_dump_ended_op
operator|=
name|pcap_live_dump_ended_win32
expr_stmt|;
name|p
operator|->
name|get_airpcap_handle_op
operator|=
name|pcap_get_airpcap_handle_win32
expr_stmt|;
name|p
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_win32
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|pcap_cleanup_win32
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* * Check if rfmon mode is supported on the pcap_t for Windows systems. */
end_comment

begin_function
specifier|static
name|int
name|pcap_can_set_rfmon_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|PacketIsMonitorModeSupported
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|device
name|_U_
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_REMOTE
name|p
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_md
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_REMOTE */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|->
name|activate_op
operator|=
name|pcap_activate_win32
expr_stmt|;
name|p
operator|->
name|can_set_rfmon_op
operator|=
name|pcap_can_set_rfmon_win32
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setfilter_win32_npf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|pcap_win
modifier|*
name|pw
init|=
name|p
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|PacketSetBpf
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|fp
argument_list|)
operator|==
name|FALSE
condition|)
block|{
comment|/* 		 * Kernel filter not installed. 		 * 		 * XXX - we don't know whether this failed because: 		 * 		 *  the kernel rejected the filter program as invalid, 		 *  in which case we should fall back on userland 		 *  filtering; 		 * 		 *  the kernel rejected the filter program as too big, 		 *  in which case we should again fall back on 		 *  userland filtering; 		 * 		 *  there was some other problem, in which case we 		 *  should probably report an error. 		 * 		 * For NPF devices, the Win32 status will be 		 * STATUS_INVALID_DEVICE_REQUEST for invalid 		 * filters, but I don't know what it'd be for 		 * other problems, and for some other devices 		 * it might not be set at all. 		 * 		 * So we just fall back on userland filtering in 		 * all cases. 		 */
comment|/* 		 * install_bpf_program() validates the program. 		 * 		 * XXX - what if we already have a filter in the kernel? 		 */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pw
operator|->
name|filtering_in_kernel
operator|=
literal|0
expr_stmt|;
comment|/* filtering in userland */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * It worked. 	 */
name|pw
operator|->
name|filtering_in_kernel
operator|=
literal|1
expr_stmt|;
comment|/* filtering in the kernel */
comment|/* 	 * Discard any previously-received packets, as they might have 	 * passed whatever filter was formerly in effect, but might 	 * not pass this filter (BIOCSETF discards packets buffered 	 * in the kernel, so you can lose packets in any case). 	 */
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We filter at user level, since the kernel driver does't process the packets  */
end_comment

begin_function
specifier|static
name|int
name|pcap_setfilter_win32_dag
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"setfilter: No filter specified"
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Install a user level filter */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"setfilter, unable to install the filter: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_getnonblock_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|pcap_win
modifier|*
name|pw
init|=
name|p
operator|->
name|priv
decl_stmt|;
comment|/* 	 * XXX - if there were a PacketGetReadTimeout() call, we 	 * would use it, and return 1 if the timeout is -1 	 * and 0 otherwise. 	 */
return|return
operator|(
name|pw
operator|->
name|nonblock
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setnonblock_win32
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|pcap_win
modifier|*
name|pw
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|int
name|newtimeout
decl_stmt|;
name|char
name|win_errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|nonblock
condition|)
block|{
comment|/* 		 * Set the read timeout to -1 for non-blocking mode. 		 */
name|newtimeout
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Restore the timeout set when the device was opened. 		 * (Note that this may be -1, in which case we're not 		 * really leaving non-blocking mode.  However, although 		 * the timeout argument to pcap_set_timeout() and 		 * pcap_open_live() is an int, you're not supposed to 		 * supply a negative value, so that "shouldn't happen".) 		 */
name|newtimeout
operator|=
name|p
operator|->
name|opt
operator|.
name|timeout
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PacketSetReadTimeout
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|newtimeout
argument_list|)
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|win_errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"PacketSetReadTimeout: %s"
argument_list|,
name|win_errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pw
operator|->
name|nonblock
operator|=
operator|(
name|newtimeout
operator|==
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_add_if_win32
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|devlist
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|bpf_u_int32
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|pcap_if_t
modifier|*
name|curdev
decl_stmt|;
name|npf_if_addr
name|if_addrs
index|[
name|MAX_NETWORK_ADDRESSES
index|]
decl_stmt|;
name|LONG
name|if_addr_size
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|if_addr_size
operator|=
name|MAX_NETWORK_ADDRESSES
expr_stmt|;
comment|/* 	 * Add an entry for this interface, with no addresses. 	 */
if|if
condition|(
name|add_or_find_if
argument_list|(
operator|&
name|curdev
argument_list|,
name|devlist
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|description
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Failure. 		 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get the list of addresses for the interface. 	 */
if|if
condition|(
operator|!
name|PacketGetNetInfoEx
argument_list|(
operator|(
name|void
operator|*
operator|)
name|name
argument_list|,
name|if_addrs
argument_list|,
operator|&
name|if_addr_size
argument_list|)
condition|)
block|{
comment|/* 		 * Failure. 		 * 		 * We don't return an error, because this can happen with 		 * NdisWan interfaces, and we want to supply them even 		 * if we can't supply their addresses. 		 * 		 * We return an entry with an empty address list. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now add the addresses. 	 */
while|while
condition|(
name|if_addr_size
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* 		 * "curdev" is an entry for this interface; add an entry for 		 * this address to its list of addresses. 		 */
if|if
condition|(
name|curdev
operator|==
name|NULL
condition|)
break|break;
name|res
operator|=
name|add_addr_to_dev
argument_list|(
name|curdev
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|if_addrs
index|[
name|if_addr_size
index|]
operator|.
name|IPAddress
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|if_addrs
index|[
name|if_addr_size
index|]
operator|.
name|SubnetMask
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|if_addrs
index|[
name|if_addr_size
index|]
operator|.
name|Broadcast
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Failure. 			 */
break|break;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|pcap_if_t
modifier|*
name|devlist
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
name|char
modifier|*
name|AdaptersName
decl_stmt|;
name|ULONG
name|NameLength
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|our_errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Find out how big a buffer we need. 	 * 	 * This call should always return FALSE; if the error is 	 * ERROR_INSUFFICIENT_BUFFER, NameLength will be set to 	 * the size of the buffer we need, otherwise there's a 	 * problem, and NameLength should be set to 0. 	 * 	 * It shouldn't require NameLength to be set, but, 	 * at least as of WinPcap 4.1.3, it checks whether 	 * NameLength is big enough before it checks for a 	 * NULL buffer argument, so, while it'll still do 	 * the right thing if NameLength is uninitialized and 	 * whatever junk happens to be there is big enough 	 * (because the pointer argument will be null), it's 	 * still reading an uninitialized variable. 	 */
name|NameLength
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|PacketGetAdapterNames
argument_list|(
name|NULL
argument_list|,
operator|&
name|NameLength
argument_list|)
condition|)
block|{
name|DWORD
name|last_error
init|=
name|GetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|last_error
operator|!=
name|ERROR_INSUFFICIENT_BUFFER
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|last_error
argument_list|,
name|our_errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"PacketGetAdapterNames: %s"
argument_list|,
name|our_errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|NameLength
operator|>
literal|0
condition|)
name|AdaptersName
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|NameLength
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|alldevsp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|AdaptersName
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Cannot allocate enough memory to list the adapters."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|PacketGetAdapterNames
argument_list|(
name|AdaptersName
argument_list|,
operator|&
name|NameLength
argument_list|)
condition|)
block|{
name|pcap_win32_err_to_str
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|our_errbuf
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"PacketGetAdapterNames: %s"
argument_list|,
name|our_errbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|AdaptersName
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * "PacketGetAdapterNames()" returned a list of 	 * null-terminated ASCII interface name strings, 	 * terminated by a null string, followed by a list 	 * of null-terminated ASCII interface description 	 * strings, terminated by a null string. 	 * This means there are two ASCII nulls at the end 	 * of the first list. 	 * 	 * Find the end of the first list; that's the 	 * beginning of the second list. 	 */
name|desc
operator|=
operator|&
name|AdaptersName
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|desc
operator|!=
literal|'\0'
operator|||
operator|*
operator|(
name|desc
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|desc
operator|++
expr_stmt|;
comment|/*  	 * Found it - "desc" points to the first of the two 	 * nulls at the end of the list of names, so the 	 * first byte of the list of descriptions is two bytes 	 * after it. 	 */
name|desc
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * Loop over the elements in the first list. 	 */
name|name
operator|=
operator|&
name|AdaptersName
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
name|bpf_u_int32
name|flags
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PACKET_IS_LOOPBACK_ADAPTER
comment|/* 		 * Is this a loopback interface? 		 */
if|if
condition|(
name|PacketIsLoopbackAdapter
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* Yes */
name|flags
operator||=
name|PCAP_IF_LOOPBACK
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Add an entry for this interface. 		 */
if|if
condition|(
name|pcap_add_if_win32
argument_list|(
operator|&
name|devlist
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|desc
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Failure. 			 */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|name
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|desc
operator|+=
name|strlen
argument_list|(
name|desc
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * We had an error; free the list we've been constructing. 		 */
if|if
condition|(
name|devlist
operator|!=
name|NULL
condition|)
block|{
name|pcap_freealldevs
argument_list|(
name|devlist
argument_list|)
expr_stmt|;
name|devlist
operator|=
name|NULL
expr_stmt|;
block|}
block|}
operator|*
name|alldevsp
operator|=
name|devlist
expr_stmt|;
name|free
argument_list|(
name|AdaptersName
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

