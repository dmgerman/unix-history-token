begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * This code contributed by Atanu Ghosh (atanu@cs.ucl.ac.uk),  * University College London, and subsequently modified by  * Guy Harris (guy@alum.mit.edu), Mark Pizzolato  *<List-tcpdump-workers@subscriptions.pizzolato.net>,  * Mark C. Brown (mbrown@hp.com), and Sagun Shakya<Sagun.Shakya@Sun.COM>.  */
end_comment

begin_comment
comment|/*  * Packet capture routine for DLPI under SunOS 5, HP-UX 9/10/11, and AIX.  *  * Notes:  *  *    - The DLIOCRAW ioctl() is specific to SunOS.  *  *    - There is a bug in bufmod(7) such that setting the snapshot  *      length results in data being left of the front of the packet.  *  *    - It might be desirable to use pfmod(7) to filter packets in the  *      kernel when possible.  *  *    - An older version of the HP-UX DLPI Programmer's Guide, which  *      I think was advertised as the 10.20 version, used to be available  *      at  *  *            http://docs.hp.com/hpux/onlinedocs/B2355-90093/B2355-90093.html  *  *      but is no longer available; it can still be found at  *  *            http://h21007.www2.hp.com/dspp/files/unprotected/Drivers/Docs/Refs/B2355-90093.pdf  *  *      in PDF form.  *  *    - The HP-UX 10.x, 11.0, and 11i v1.6 version of the HP-UX DLPI  *      Programmer's Guide, which I think was once advertised as the  *      11.00 version is available at  *  *            http://docs.hp.com/en/B2355-90139/index.html  *  *    - The HP-UX 11i v2 version of the HP-UX DLPI Programmer's Guide  *      is available at  *  *            http://docs.hp.com/en/B2355-90871/index.html  *  *    - All of the HP documents describe raw-mode services, which are  *      what we use if DL_HP_RAWDLS is defined.  XXX - we use __hpux  *      in some places to test for HP-UX, but use DL_HP_RAWDLS in  *      other places; do we support any versions of HP-UX without  *      DL_HP_RAWDLS?  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bufmod.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/dlpi.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_DLPI_EXT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/dlpi_ext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HPUX9
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DL_HP_PPA_REQ
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SOLARIS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_BUFMOD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systeminfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HPUX9
end_ifdef

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HPUX9
end_ifdef

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INT_MAX
value|2147483647
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"dlpisubs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCAP_DEV_PREFIX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_define
define|#
directive|define
name|PCAP_DEV_PREFIX
value|"/dev/dlpi"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PCAP_DEV_PREFIX
value|"/dev"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXDLBUF
value|8192
end_define

begin_comment
comment|/* Forwards */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|split_dname
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dl_doattach
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
end_ifdef

begin_function_decl
specifier|static
name|int
name|dl_dohpuxbind
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|dlpromiscon
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|bpf_u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlbindreq
parameter_list|(
name|int
parameter_list|,
name|bpf_u_int32
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlbindack
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlokack
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlinforeq
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlinfoack
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLPI_PASSIVE
end_ifdef

begin_function_decl
specifier|static
name|void
name|dlpassive
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
end_ifdef

begin_function_decl
specifier|static
name|int
name|dlrawdatareq
parameter_list|(
name|int
parameter_list|,
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|recv_ack
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dlstrerror
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|bpf_u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dlprim
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|bpf_u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SOLARIS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_BUFMOD_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|GET_RELEASE_BUFSIZE
value|32
end_define

begin_function_decl
specifier|static
name|void
name|get_release
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|bpf_u_int32
modifier|*
parameter_list|,
name|bpf_u_int32
modifier|*
parameter_list|,
name|bpf_u_int32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|send_request
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HPUX9
end_ifdef

begin_function_decl
specifier|static
name|int
name|dlpi_kread
parameter_list|(
name|int
parameter_list|,
name|off_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DEV_DLPI
end_ifdef

begin_function_decl
specifier|static
name|int
name|get_dlpi_ppa
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Cast a buffer to "union DL_primitives" without provoking warnings  * from the compiler.  */
end_comment

begin_define
define|#
directive|define
name|MAKE_DL_PRIMITIVES
parameter_list|(
name|ptr
parameter_list|)
value|((union DL_primitives *)(void *)(ptr))
end_define

begin_function
specifier|static
name|int
name|pcap_read_dlpi
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|u_char
modifier|*
name|bp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bpf_u_int32
name|ctlbuf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
name|struct
name|strbuf
name|ctl
init|=
block|{
name|MAXDLBUF
block|,
literal|0
block|,
operator|(
name|char
operator|*
operator|)
name|ctlbuf
block|}
decl_stmt|;
name|struct
name|strbuf
name|data
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|cc
operator|=
name|p
operator|->
name|cc
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|buffer
operator|+
name|p
operator|->
name|offset
expr_stmt|;
name|data
operator|.
name|maxlen
operator|=
name|p
operator|->
name|bufsize
expr_stmt|;
name|data
operator|.
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* 			 * Has "pcap_breakloop()" been called? 			 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 				 * Yes - clear the flag that indicates 				 * that it has, and return -2 to 				 * indicate that we were told to 				 * break out of the loop. 				 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* 			 * XXX - check for the DLPI primitive, which 			 * would be DL_HP_RAWDATA_IND on HP-UX 			 * if we're in raw mode? 			 */
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ctlbuf
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getmsg
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Don't choke when we get ptraced */
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINTR
case|:
name|cc
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|EAGAIN
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cc
operator|=
name|data
operator|.
name|len
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|==
literal|0
condition|)
do|;
name|bp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|buffer
operator|+
name|p
operator|->
name|offset
expr_stmt|;
block|}
else|else
name|bp
operator|=
name|p
operator|->
name|bp
expr_stmt|;
return|return
operator|(
name|pcap_process_pkts
argument_list|(
name|p
argument_list|,
name|callback
argument_list|,
name|user
argument_list|,
name|cnt
argument_list|,
name|bp
argument_list|,
name|cc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_inject_dlpi
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
name|struct
name|pcap_dlpi
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
endif|#
directive|endif
name|int
name|ret
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DLIOCRAW
argument_list|)
name|ret
operator|=
name|write
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|DL_HP_RAWDLS
argument_list|)
if|if
condition|(
name|pd
operator|->
name|send_fd
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send: Output FD couldn't be opened"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|dlrawdatareq
argument_list|(
name|pd
operator|->
name|send_fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * putmsg() returns either 0 or -1; it doesn't indicate how 	 * many bytes were written (presumably they were all written 	 * or none of them were written).  OpenBSD's pcap_inject() 	 * returns the number of bytes written, so, for API compatibility, 	 * we return the number of bytes we were told to write. 	 */
name|ret
operator|=
name|size
expr_stmt|;
else|#
directive|else
comment|/* no raw mode */
comment|/* 	 * XXX - this is a pain, because you might have to extract 	 * the address from the packet and use it in a DL_UNITDATA_REQ 	 * request.  That would be dependent on the link-layer type. 	 * 	 * I also don't know what SAP you'd have to bind the descriptor 	 * to, or whether you'd need separate "receive" and "send" FDs, 	 * nor do I know whether you'd need different bindings for 	 * D/I/X Ethernet and 802.3, or for {FDDI,Token Ring} plus 	 * 802.2 and {FDDI,Token Ring} plus 802.2 plus SNAP. 	 * 	 * So, for now, we just return a "you can't send" indication, 	 * and leave it up to somebody with a DLPI-based system lacking 	 * both DLIOCRAW and DL_HP_RAWDLS to supply code to implement 	 * packet transmission on that system.  If they do, they should 	 * send it to us - but should not send us code that assumes 	 * Ethernet; if the code doesn't work on non-Ethernet interfaces, 	 * it should check "p->linktype" and reject the send request if 	 * it's anything other than DLT_EN10MB. 	 */
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"send: Not supported on this version of this OS"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* raw mode */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|DL_IPATM
end_ifndef

begin_define
define|#
directive|define
name|DL_IPATM
value|0x12
end_define

begin_comment
comment|/* ATM Classical IP interface */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
end_ifdef

begin_comment
comment|/*  * For SunATM.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|A_GET_UNITS
end_ifndef

begin_define
define|#
directive|define
name|A_GET_UNITS
value|(('A'<<8)|118)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A_GET_UNITS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|A_PROMISCON_REQ
end_ifndef

begin_define
define|#
directive|define
name|A_PROMISCON_REQ
value|(('A'<<8)|121)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A_PROMISCON_REQ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SOLARIS */
end_comment

begin_function
specifier|static
name|void
name|pcap_cleanup_dlpi
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
name|struct
name|pcap_dlpi
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|pd
operator|->
name|send_fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|pd
operator|->
name|send_fd
argument_list|)
expr_stmt|;
name|pd
operator|->
name|send_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|pcap_cleanup_live_common
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|open_dlpi_device
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|ppa
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|char
name|dname
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|fd
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_DEV_DLPI
name|char
name|dname2
index|[
literal|100
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_DEV_DLPI
comment|/* 	** Remove any "/dev/" on the front of the device. 	*/
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|strlcpy
argument_list|(
name|dname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|dname
argument_list|,
name|cp
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Split the device name into a device type name and a unit number; 	 * chop off the unit number, so "dname" is just a device type name. 	 */
name|cp
operator|=
name|split_dname
argument_list|(
name|dname
argument_list|,
name|ppa
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|)
return|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Use "/dev/dlpi" as the device. 	 * 	 * XXX - HP's DLPI Programmer's Guide for HP-UX 11.00 says that 	 * the "dl_mjr_num" field is for the "major number of interface 	 * driver"; that's the major of "/dev/dlpi" on the system on 	 * which I tried this, but there may be DLPI devices that 	 * use a different driver, in which case we may need to 	 * search "/dev" for the appropriate device with that major 	 * device number, rather than hardwiring "/dev/dlpi". 	 */
name|cp
operator|=
literal|"/dev/dlpi"
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|cp
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
operator|||
name|errno
operator|==
name|EACCES
condition|)
name|status
operator|=
name|PCAP_ERROR_PERM_DENIED
expr_stmt|;
else|else
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|cp
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Get a table of all PPAs for that device, and search that 	 * table for the specified device type name and unit number. 	 */
operator|*
name|ppa
operator|=
name|get_dlpi_ppa
argument_list|(
name|fd
argument_list|,
name|dname
argument_list|,
operator|*
name|ppa
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ppa
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|ppa
operator|)
return|;
block|}
else|#
directive|else
comment|/* 	 * If the device name begins with "/", assume it begins with 	 * the pathname of the directory containing the device to open; 	 * otherwise, concatenate the device directory name and the 	 * device name. 	 */
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
condition|)
name|strlcpy
argument_list|(
name|dname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pcap_snprintf
argument_list|(
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|PCAP_DEV_PREFIX
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Get the unit number, and a pointer to the end of the device 	 * type name. 	 */
name|cp
operator|=
name|split_dname
argument_list|(
name|dname
argument_list|,
name|ppa
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|)
return|;
comment|/* 	 * Make a copy of the device pathname, and then remove the unit 	 * number from the device pathname. 	 */
name|strlcpy
argument_list|(
name|dname2
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Try device without unit number */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|dname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
operator|||
name|errno
operator|==
name|EACCES
condition|)
name|status
operator|=
name|PCAP_ERROR_PERM_DENIED
expr_stmt|;
else|else
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|dname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* Try again with unit number */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|dname2
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR_NO_SUCH_DEVICE
expr_stmt|;
comment|/* 				 * We provide an error message even 				 * for this error, for diagnostic 				 * purposes (so that, for example, 				 * the app can show the message if the 				 * user requests it). 				 * 				 * In it, we just report "No DLPI device 				 * found" with the device name, so people 				 * don't get confused and think, for example, 				 * that if they can't capture on "lo0" 				 * on Solaris prior to Solaris 11 the fix 				 * is to change libpcap (or the application 				 * that uses it) to look for something other 				 * than "/dev/lo0", as the fix is to use 				 * Solaris 11 or some operating system 				 * other than Solaris - you just *can't* 				 * capture on a loopback interface 				 * on Solaris prior to Solaris 11, the lack 				 * of a DLPI device for the loopback 				 * interface is just a symptom of that 				 * inability. 				 */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: No DLPI device found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
operator|||
name|errno
operator|==
name|EACCES
condition|)
name|status
operator|=
name|PCAP_ERROR_PERM_DENIED
expr_stmt|;
else|else
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|dname2
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* XXX Assume unit zero */
operator|*
name|ppa
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_activate_dlpi
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
name|struct
name|pcap_dlpi
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
endif|#
directive|endif
name|int
name|status
init|=
literal|0
decl_stmt|;
name|int
name|retv
decl_stmt|;
name|int
name|ppa
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
name|int
name|isatm
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
specifier|register
name|dl_info_ack_t
modifier|*
name|infop
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
name|bpf_u_int32
name|ss
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
name|char
name|release
index|[
name|GET_RELEASE_BUFSIZE
index|]
decl_stmt|;
name|bpf_u_int32
name|osmajor
decl_stmt|,
name|osminor
decl_stmt|,
name|osmicro
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|bpf_u_int32
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
name|p
operator|->
name|fd
operator|=
name|open_dlpi_device
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
operator|&
name|ppa
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|p
operator|->
name|fd
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
comment|/* 	 * XXX - HP-UX 10.20 and 11.xx don't appear to support sending and 	 * receiving packets on the same descriptor - you need separate 	 * descriptors for sending and receiving, bound to different SAPs. 	 * 	 * If the open fails, we just leave -1 in "pd->send_fd" and reject 	 * attempts to send packets, just as if, in pcap-bpf.c, we fail 	 * to open the BPF device for reading and writing, we just try 	 * to open it for reading only and, if that succeeds, just let 	 * the send attempts fail. 	 */
name|pd
operator|->
name|send_fd
operator|=
name|open
argument_list|(
literal|"/dev/dlpi"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Attach if "style 2" provider 	*/
if|if
condition|(
name|dlinforeq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
operator|||
name|dlinfoack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|infop
operator|=
operator|&
operator|(
name|MAKE_DL_PRIMITIVES
argument_list|(
name|buf
argument_list|)
operator|)
operator|->
name|info_ack
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
if|if
condition|(
name|infop
operator|->
name|dl_mac_type
operator|==
name|DL_IPATM
condition|)
name|isatm
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|infop
operator|->
name|dl_provider_style
operator|==
name|DL_STYLE2
condition|)
block|{
name|retv
operator|=
name|dl_doattach
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|ppa
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|retv
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
if|if
condition|(
name|pd
operator|->
name|send_fd
operator|>=
literal|0
condition|)
block|{
name|retv
operator|=
name|dl_doattach
argument_list|(
name|pd
operator|->
name|send_fd
argument_list|,
name|ppa
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|retv
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 		 * This device exists, but we don't support monitor mode 		 * any platforms that support DLPI. 		 */
name|status
operator|=
name|PCAP_ERROR_RFMON_NOTSUP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|HAVE_DLPI_PASSIVE
comment|/* 	 * Enable Passive mode to be able to capture on aggregated link. 	 * Not supported in all Solaris versions. 	 */
name|dlpassive
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Bind (defer if using HP-UX 9 or HP-UX 10.20 or later, totally 	** skip if using SINIX) 	*/
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_HPUX9
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_HPUX10_20_OR_LATER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sinix
argument_list|)
ifdef|#
directive|ifdef
name|_AIX
comment|/* 	** AIX. 	** According to IBM's AIX Support Line, the dl_sap value 	** should not be less than 0x600 (1536) for standard Ethernet. 	** However, we seem to get DL_BADADDR - "DLSAP addr in improper 	** format or invalid" - errors if we use 1537 on the "tr0" 	** device, which, given that its name starts with "tr" and that 	** it's IBM, probably means a Token Ring device.  (Perhaps we 	** need to use 1537 on "/dev/dlpi/en" because that device is for 	** D/I/X Ethernet, the "SAP" is actually an Ethernet type, and 	** it rejects invalid Ethernet types.) 	** 	** So if 1537 fails, we try 2, as Hyung Sik Yoon of IBM Korea 	** says that works on Token Ring (he says that 0 does *not* 	** work; perhaps that's considered an invalid LLC SAP value - I 	** assume the SAP value in a DLPI bind is an LLC SAP for network 	** types that use 802.2 LLC). 	*/
if|if
condition|(
operator|(
name|dlbindreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|1537
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
operator|&&
name|dlbindreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|2
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|dlbindack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|DL_HP_RAWDLS
argument_list|)
comment|/* 	** HP-UX 10.0x and 10.1x. 	*/
if|if
condition|(
name|dl_dohpuxbind
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|pd
operator|->
name|send_fd
operator|>=
literal|0
condition|)
block|{
comment|/* 		** XXX - if this fails, just close send_fd and 		** set it to -1, so that you can't send but can 		** still receive? 		*/
if|if
condition|(
name|dl_dohpuxbind
argument_list|(
name|pd
operator|->
name|send_fd
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|#
directive|else
comment|/* neither AIX nor HP-UX */
comment|/* 	** Not Sinix, and neither AIX nor HP-UX - Solaris, and any other 	** OS using DLPI. 	**/
if|if
condition|(
name|dlbindreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
operator|||
name|dlbindack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* AIX vs. HP-UX vs. other */
endif|#
directive|endif
comment|/* !HP-UX 9 and !HP-UX 10.20 or later and !SINIX */
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
if|if
condition|(
name|isatm
condition|)
block|{
comment|/* 		** Have to turn on some special ATM promiscuous mode 		** for SunATM. 		** Do *NOT* turn regular promiscuous mode on; it doesn't 		** help, and may break things. 		*/
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|A_PROMISCON_REQ
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"A_PROMISCON_REQ: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
comment|/* 		** Enable promiscuous (not necessary on send FD) 		*/
name|retv
operator|=
name|dlpromiscon
argument_list|(
name|p
argument_list|,
name|DL_PROMISC_PHYS
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|retv
operator|==
name|PCAP_ERROR_PERM_DENIED
condition|)
name|status
operator|=
name|PCAP_ERROR_PROMISC_PERM_DENIED
expr_stmt|;
else|else
name|status
operator|=
name|retv
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		** Try to enable multicast (you would have thought 		** promiscuous would be sufficient). (Skip if using 		** HP-UX or SINIX) (Not necessary on send FD) 		*/
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sinix
argument_list|)
name|retv
operator|=
name|dlpromiscon
argument_list|(
name|p
argument_list|,
name|DL_PROMISC_MULTI
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
name|status
operator|=
name|PCAP_WARNING
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	** Try to enable SAP promiscuity (when not in promiscuous mode 	** when using HP-UX, when not doing SunATM on Solaris, and never 	** under SINIX) (Not necessary on send FD) 	*/
ifndef|#
directive|ifndef
name|sinix
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
comment|/* HP-UX - only do this when not in promiscuous mode */
if|if
condition|(
operator|!
name|p
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SOLARIS
argument_list|)
comment|/* Solaris - don't do this on SunATM devices */
if|if
condition|(
operator|!
name|isatm
condition|)
block|{
else|#
directive|else
comment|/* Everything else (except for SINIX) - always do this */
block|{
endif|#
directive|endif
name|retv
operator|=
name|dlpromiscon
argument_list|(
name|p
argument_list|,
name|DL_PROMISC_SAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
comment|/* 				 * Not fatal, since the DL_PROMISC_PHYS mode 				 * worked. 				 * 				 * Report it as a warning, however. 				 */
name|status
operator|=
name|PCAP_WARNING
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Fatal. 				 */
name|status
operator|=
name|retv
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* sinix */
comment|/* 	** HP-UX 9, and HP-UX 10.20 or later, must bind after setting 	** promiscuous options. 	*/
if|#
directive|if
name|defined
argument_list|(
name|HAVE_HPUX9
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_HPUX10_20_OR_LATER
argument_list|)
if|if
condition|(
name|dl_dohpuxbind
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	** We don't set promiscuous mode on the send FD, but we'll defer 	** binding it anyway, just to keep the HP-UX 9/10.20 or later 	** code together. 	*/
if|if
condition|(
name|pd
operator|->
name|send_fd
operator|>=
literal|0
condition|)
block|{
comment|/* 		** XXX - if this fails, just close send_fd and 		** set it to -1, so that you can't send but can 		** still receive? 		*/
if|if
condition|(
name|dl_dohpuxbind
argument_list|(
name|pd
operator|->
name|send_fd
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* 	** Determine link type 	** XXX - get SAP length and address length as well, for use 	** when sending packets. 	*/
if|if
condition|(
name|dlinforeq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
operator|||
name|dlinfoack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|infop
operator|=
operator|&
operator|(
name|MAKE_DL_PRIMITIVES
argument_list|(
name|buf
argument_list|)
operator|)
operator|->
name|info_ack
expr_stmt|;
if|if
condition|(
name|pcap_process_mactype
argument_list|(
name|p
argument_list|,
name|infop
operator|->
name|dl_mac_type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|DLIOCRAW
comment|/* 	** This is a non standard SunOS hack to get the full raw link-layer 	** header. 	*/
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|DLIOCRAW
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"DLIOCRAW: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
name|ss
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
comment|/* 	** There is a bug in bufmod(7). When dealing with messages of 	** less than snaplen size it strips data from the beginning not 	** the end. 	** 	** This bug is fixed in 5.3.2. Also, there is a patch available. 	** Ask for bugid 1149065. 	*/
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
name|get_release
argument_list|(
name|release
argument_list|,
sizeof|sizeof
argument_list|(
name|release
argument_list|)
argument_list|,
operator|&
name|osmajor
argument_list|,
operator|&
name|osminor
argument_list|,
operator|&
name|osmicro
argument_list|)
expr_stmt|;
if|if
condition|(
name|osmajor
operator|==
literal|5
operator|&&
operator|(
name|osminor
operator|<=
literal|2
operator|||
operator|(
name|osminor
operator|==
literal|3
operator|&&
name|osmicro
operator|<
literal|2
operator|)
operator|)
operator|&&
name|getenv
argument_list|(
literal|"BUFMOD_FIXED"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"WARNING: bufmod is broken in SunOS %s; ignoring snaplen."
argument_list|,
name|release
argument_list|)
expr_stmt|;
name|ss
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|PCAP_WARNING
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Push and configure bufmod. */
if|if
condition|(
name|pcap_conf_bufmod
argument_list|(
name|p
argument_list|,
name|ss
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* 	** As the last operation flush the read side. 	*/
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|I_FLUSH
argument_list|,
name|FLUSHR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"FLUSHR: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Allocate data buffer. */
if|if
condition|(
name|pcap_alloc_databuf
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Success. 	 * 	 * "p->fd" is an FD for a STREAMS device, so "select()" and 	 * "poll()" should work on it. 	 */
name|p
operator|->
name|selectable_fd
operator|=
name|p
operator|->
name|fd
expr_stmt|;
name|p
operator|->
name|read_op
operator|=
name|pcap_read_dlpi
expr_stmt|;
name|p
operator|->
name|inject_op
operator|=
name|pcap_inject_dlpi
expr_stmt|;
name|p
operator|->
name|setfilter_op
operator|=
name|install_bpf_program
expr_stmt|;
comment|/* no kernel filtering */
name|p
operator|->
name|setdirection_op
operator|=
name|NULL
expr_stmt|;
comment|/* Not implemented.*/
name|p
operator|->
name|set_datalink_op
operator|=
name|NULL
expr_stmt|;
comment|/* can't change data link type */
name|p
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|p
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_fd
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
name|pcap_stats_dlpi
expr_stmt|;
name|p
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_dlpi
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
name|bad
label|:
name|pcap_cleanup_dlpi
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/*  * Split a device name into a device type name and a unit number;  * return the a pointer to the beginning of the unit number, which  * is the end of the device type name, and set "*unitp" to the unit  * number.  *  * Returns NULL on error, and fills "ebuf" with an error message.  */
specifier|static
name|char
modifier|*
name|split_dname
parameter_list|(
name|char
modifier|*
name|device
parameter_list|,
name|int
modifier|*
name|unitp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|eos
decl_stmt|;
name|long
name|unit
decl_stmt|;
comment|/* 	 * Look for a number at the end of the device name string. 	 */
name|cp
operator|=
name|device
operator|+
name|strlen
argument_list|(
name|device
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|<
literal|'0'
operator|||
operator|*
name|cp
operator|>
literal|'9'
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s missing unit number"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Digits at end of string are unit number */
while|while
condition|(
name|cp
operator|-
literal|1
operator|>=
name|device
operator|&&
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|>=
literal|'0'
operator|&&
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|<=
literal|'9'
condition|)
name|cp
operator|--
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eos
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eos
operator|!=
literal|'\0'
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s bad unit number"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ERANGE
operator|||
name|unit
operator|>
name|INT_MAX
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s unit number too large"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s unit number is negative"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|unitp
operator|=
operator|(
name|int
operator|)
name|unit
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
specifier|static
name|int
name|dl_doattach
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|ppa
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_attach_req_t
name|req
decl_stmt|;
name|bpf_u_int32
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_ATTACH_REQ
expr_stmt|;
name|req
operator|.
name|dl_ppa
operator|=
name|ppa
expr_stmt|;
if|if
condition|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"attach"
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
name|err
operator|=
name|dlokack
argument_list|(
name|fd
argument_list|,
literal|"attach"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
specifier|static
name|int
name|dl_dohpuxbind
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|int
name|hpsap
decl_stmt|;
name|int
name|uerror
decl_stmt|;
name|bpf_u_int32
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
comment|/* 	 * XXX - we start at 22 because we used to use only 22, but 	 * that was just because that was the value used in some 	 * sample code from HP.  With what value *should* we start? 	 * Does it matter, given that we're enabling SAP promiscuity 	 * on the input FD? 	 */
name|hpsap
operator|=
literal|22
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dlbindreq
argument_list|(
name|fd
argument_list|,
name|hpsap
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dlbindack
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|,
operator|&
name|uerror
argument_list|)
operator|>=
literal|0
condition|)
break|break;
comment|/* 		 * For any error other than a UNIX EBUSY, give up. 		 */
if|if
condition|(
name|uerror
operator|!=
name|EBUSY
condition|)
block|{
comment|/* 			 * dlbindack() has already filled in ebuf for 			 * this error. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * For EBUSY, try the next SAP value; that means that 		 * somebody else is using that SAP.  Clear ebuf so 		 * that application doesn't report the "Device busy" 		 * error as a warning. 		 */
operator|*
name|ebuf
operator|=
literal|'\0'
expr_stmt|;
name|hpsap
operator|++
expr_stmt|;
if|if
condition|(
name|hpsap
operator|>
literal|100
condition|)
block|{
name|strlcpy
argument_list|(
name|ebuf
argument_list|,
literal|"All SAPs from 22 through 100 are in use"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
define|#
directive|define
name|STRINGIFY
parameter_list|(
name|n
parameter_list|)
value|#n
specifier|static
name|int
name|dlpromiscon
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|level
parameter_list|)
block|{
name|dl_promiscon_req_t
name|req
decl_stmt|;
name|bpf_u_int32
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_PROMISCON_REQ
expr_stmt|;
name|req
operator|.
name|dl_level
operator|=
name|level
expr_stmt|;
if|if
condition|(
name|send_request
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"promiscon"
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
name|err
operator|=
name|dlokack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|"promiscon"
name|STRINGIFY
argument_list|(
name|level
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Not all interfaces are DLPI interfaces, and thus not all interfaces  * can be opened with DLPI (for example, the loopback interface is not  * a DLPI interface on Solaris prior to Solaris 11), so try to open  * the specified interface; return 0 if we fail with PCAP_ERROR_NO_SUCH_DEVICE  * and 1 otherwise.  */
specifier|static
name|int
name|is_dlpi_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|ppa
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
index|]
decl_stmt|;
name|fd
operator|=
name|open_dlpi_device
argument_list|(
name|name
argument_list|,
operator|&
name|ppa
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Error - was it PCAP_ERROR_NO_SUCH_DEVICE? 		 */
if|if
condition|(
name|fd
operator|==
name|PCAP_ERROR_NO_SUCH_DEVICE
condition|)
block|{
comment|/* 			 * Yes, so we can't open this because it's 			 * not a DLPI interface. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * No, so, in the case where there's a single DLPI 		 * device for all interfaces of this type ("style 		 * 2" providers?), we don't know whether it's a DLPI 		 * interface or not, as we didn't try an attach. 		 * Say it is a DLPI device, so that the user can at 		 * least try to open it and report the error (which 		 * is probably "you don't have permission to open that 		 * DLPI device"; reporting those interfaces means 		 * users will ask "why am I getting a permissions error 		 * when I try to capture" rather than "why am I not 		 * seeing any interfaces", making the underlying problem 		 * clearer). 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Success. 	 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
name|int
name|fd
decl_stmt|;
union|union
block|{
name|u_int
name|nunits
decl_stmt|;
name|char
name|pad
index|[
literal|516
index|]
decl_stmt|;
comment|/* XXX - must be at least 513; is 516 				   in "atmgetunits" */
block|}
name|buf
union|;
name|char
name|baname
index|[
literal|2
operator|+
literal|1
operator|+
literal|1
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Get the list of regular interfaces first. 	 */
if|if
condition|(
name|pcap_findalldevs_interfaces
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|,
name|is_dlpi_interface
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* failure */
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
comment|/* 	 * We may have to do special magic to get ATM devices. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/ba"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * We couldn't open the "ba" device. 		 * For now, just give up; perhaps we should 		 * return an error if the problem is neither 		 * a "that device doesn't exist" error (ENOENT, 		 * ENXIO, etc.) or a "you're not allowed to do 		 * that" error (EPERM, EACCES). 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strioctl
argument_list|(
name|fd
argument_list|,
name|A_GET_UNITS
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"A_GET_UNITS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buf
operator|.
name|nunits
condition|;
name|i
operator|++
control|)
block|{
name|pcap_snprintf
argument_list|(
name|baname
argument_list|,
sizeof|sizeof
name|baname
argument_list|,
literal|"ba%u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_add_if
argument_list|(
name|alldevsp
argument_list|,
name|baname
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|send_request
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|ptr
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send_request: putmsg \"%s\": %s"
argument_list|,
name|what
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|recv_ack
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|,
name|int
modifier|*
name|uerror
parameter_list|)
block|{
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
name|errmsgbuf
index|[
name|PCAP_ERRBUF_SIZE
index|]
decl_stmt|;
name|char
name|dlprimbuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* 	 * Clear out "*uerror", so it's only set for DL_ERROR_ACK/DL_SYSERR, 	 * making that the only place where EBUSY is treated specially. 	 */
if|if
condition|(
name|uerror
operator|!=
name|NULL
condition|)
operator|*
name|uerror
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|bufp
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s getmsg: %s"
argument_list|,
name|what
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|dlp
operator|=
name|MAKE_DL_PRIMITIVES
argument_list|(
name|ctl
operator|.
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dlp
operator|->
name|dl_primitive
condition|)
block|{
case|case
name|DL_INFO_ACK
case|:
case|case
name|DL_BIND_ACK
case|:
case|case
name|DL_OK_ACK
case|:
ifdef|#
directive|ifdef
name|DL_HP_PPA_ACK
case|case
name|DL_HP_PPA_ACK
case|:
endif|#
directive|endif
comment|/* These are OK */
break|break;
case|case
name|DL_ERROR_ACK
case|:
switch|switch
condition|(
name|dlp
operator|->
name|error_ack
operator|.
name|dl_errno
condition|)
block|{
case|case
name|DL_SYSERR
case|:
if|if
condition|(
name|uerror
operator|!=
name|NULL
condition|)
operator|*
name|uerror
operator|=
name|dlp
operator|->
name|error_ack
operator|.
name|dl_unix_errno
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s: UNIX error - %s"
argument_list|,
name|what
argument_list|,
name|pcap_strerror
argument_list|(
name|dlp
operator|->
name|error_ack
operator|.
name|dl_unix_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlp
operator|->
name|error_ack
operator|.
name|dl_unix_errno
operator|==
name|EPERM
operator|||
name|dlp
operator|->
name|error_ack
operator|.
name|dl_unix_errno
operator|==
name|EACCES
condition|)
return|return
operator|(
name|PCAP_ERROR_PERM_DENIED
operator|)
return|;
break|break;
default|default:
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s: %s"
argument_list|,
name|what
argument_list|,
name|dlstrerror
argument_list|(
name|errmsgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsgbuf
argument_list|)
argument_list|,
name|dlp
operator|->
name|error_ack
operator|.
name|dl_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlp
operator|->
name|error_ack
operator|.
name|dl_errno
operator|==
name|DL_BADPPA
condition|)
return|return
operator|(
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|)
return|;
elseif|else
if|if
condition|(
name|dlp
operator|->
name|error_ack
operator|.
name|dl_errno
operator|==
name|DL_ACCESS
condition|)
return|return
operator|(
name|PCAP_ERROR_PERM_DENIED
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
default|default:
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s: Unexpected primitive ack %s"
argument_list|,
name|what
argument_list|,
name|dlprim
argument_list|(
name|dlprimbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dlprimbuf
argument_list|)
argument_list|,
name|dlp
operator|->
name|dl_primitive
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
name|size
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s: Ack too small (%d< %d)"
argument_list|,
name|what
argument_list|,
name|ctl
operator|.
name|len
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|ctl
operator|.
name|len
operator|)
return|;
block|}
specifier|static
name|char
modifier|*
name|dlstrerror
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|,
name|size_t
name|errbufsize
parameter_list|,
name|bpf_u_int32
name|dl_errno
parameter_list|)
block|{
switch|switch
condition|(
name|dl_errno
condition|)
block|{
case|case
name|DL_ACCESS
case|:
return|return
operator|(
literal|"Improper permissions for request"
operator|)
return|;
case|case
name|DL_BADADDR
case|:
return|return
operator|(
literal|"DLSAP addr in improper format or invalid"
operator|)
return|;
case|case
name|DL_BADCORR
case|:
return|return
operator|(
literal|"Seq number not from outstand DL_CONN_IND"
operator|)
return|;
case|case
name|DL_BADDATA
case|:
return|return
operator|(
literal|"User data exceeded provider limit"
operator|)
return|;
case|case
name|DL_BADPPA
case|:
ifdef|#
directive|ifdef
name|HAVE_DEV_DLPI
comment|/* 		 * With a single "/dev/dlpi" device used for all 		 * DLPI providers, PPAs have nothing to do with 		 * unit numbers. 		 */
return|return
operator|(
literal|"Specified PPA was invalid"
operator|)
return|;
else|#
directive|else
comment|/* 		 * We have separate devices for separate devices; 		 * the PPA is just the unit number. 		 */
return|return
operator|(
literal|"Specified PPA (device unit) was invalid"
operator|)
return|;
endif|#
directive|endif
case|case
name|DL_BADPRIM
case|:
return|return
operator|(
literal|"Primitive received not known by provider"
operator|)
return|;
case|case
name|DL_BADQOSPARAM
case|:
return|return
operator|(
literal|"QOS parameters contained invalid values"
operator|)
return|;
case|case
name|DL_BADQOSTYPE
case|:
return|return
operator|(
literal|"QOS structure type is unknown/unsupported"
operator|)
return|;
case|case
name|DL_BADSAP
case|:
return|return
operator|(
literal|"Bad LSAP selector"
operator|)
return|;
case|case
name|DL_BADTOKEN
case|:
return|return
operator|(
literal|"Token used not an active stream"
operator|)
return|;
case|case
name|DL_BOUND
case|:
return|return
operator|(
literal|"Attempted second bind with dl_max_conind"
operator|)
return|;
case|case
name|DL_INITFAILED
case|:
return|return
operator|(
literal|"Physical link initialization failed"
operator|)
return|;
case|case
name|DL_NOADDR
case|:
return|return
operator|(
literal|"Provider couldn't allocate alternate address"
operator|)
return|;
case|case
name|DL_NOTINIT
case|:
return|return
operator|(
literal|"Physical link not initialized"
operator|)
return|;
case|case
name|DL_OUTSTATE
case|:
return|return
operator|(
literal|"Primitive issued in improper state"
operator|)
return|;
case|case
name|DL_SYSERR
case|:
return|return
operator|(
literal|"UNIX system error occurred"
operator|)
return|;
case|case
name|DL_UNSUPPORTED
case|:
return|return
operator|(
literal|"Requested service not supplied by provider"
operator|)
return|;
case|case
name|DL_UNDELIVERABLE
case|:
return|return
operator|(
literal|"Previous data unit could not be delivered"
operator|)
return|;
case|case
name|DL_NOTSUPPORTED
case|:
return|return
operator|(
literal|"Primitive is known but not supported"
operator|)
return|;
case|case
name|DL_TOOMANY
case|:
return|return
operator|(
literal|"Limit exceeded"
operator|)
return|;
case|case
name|DL_NOTENAB
case|:
return|return
operator|(
literal|"Promiscuous mode not enabled"
operator|)
return|;
case|case
name|DL_BUSY
case|:
return|return
operator|(
literal|"Other streams for PPA in post-attached"
operator|)
return|;
case|case
name|DL_NOAUTO
case|:
return|return
operator|(
literal|"Automatic handling XID&TEST not supported"
operator|)
return|;
case|case
name|DL_NOXIDAUTO
case|:
return|return
operator|(
literal|"Automatic handling of XID not supported"
operator|)
return|;
case|case
name|DL_NOTESTAUTO
case|:
return|return
operator|(
literal|"Automatic handling of TEST not supported"
operator|)
return|;
case|case
name|DL_XIDAUTO
case|:
return|return
operator|(
literal|"Automatic handling of XID response"
operator|)
return|;
case|case
name|DL_TESTAUTO
case|:
return|return
operator|(
literal|"Automatic handling of TEST response"
operator|)
return|;
case|case
name|DL_PENDING
case|:
return|return
operator|(
literal|"Pending outstanding connect indications"
operator|)
return|;
default|default:
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbufsize
argument_list|,
literal|"Error %02x"
argument_list|,
name|dl_errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|errbuf
operator|)
return|;
block|}
block|}
specifier|static
name|char
modifier|*
name|dlprim
parameter_list|(
name|char
modifier|*
name|primbuf
parameter_list|,
name|size_t
name|primbufsize
parameter_list|,
name|bpf_u_int32
name|prim
parameter_list|)
block|{
switch|switch
condition|(
name|prim
condition|)
block|{
case|case
name|DL_INFO_REQ
case|:
return|return
operator|(
literal|"DL_INFO_REQ"
operator|)
return|;
case|case
name|DL_INFO_ACK
case|:
return|return
operator|(
literal|"DL_INFO_ACK"
operator|)
return|;
case|case
name|DL_ATTACH_REQ
case|:
return|return
operator|(
literal|"DL_ATTACH_REQ"
operator|)
return|;
case|case
name|DL_DETACH_REQ
case|:
return|return
operator|(
literal|"DL_DETACH_REQ"
operator|)
return|;
case|case
name|DL_BIND_REQ
case|:
return|return
operator|(
literal|"DL_BIND_REQ"
operator|)
return|;
case|case
name|DL_BIND_ACK
case|:
return|return
operator|(
literal|"DL_BIND_ACK"
operator|)
return|;
case|case
name|DL_UNBIND_REQ
case|:
return|return
operator|(
literal|"DL_UNBIND_REQ"
operator|)
return|;
case|case
name|DL_OK_ACK
case|:
return|return
operator|(
literal|"DL_OK_ACK"
operator|)
return|;
case|case
name|DL_ERROR_ACK
case|:
return|return
operator|(
literal|"DL_ERROR_ACK"
operator|)
return|;
case|case
name|DL_SUBS_BIND_REQ
case|:
return|return
operator|(
literal|"DL_SUBS_BIND_REQ"
operator|)
return|;
case|case
name|DL_SUBS_BIND_ACK
case|:
return|return
operator|(
literal|"DL_SUBS_BIND_ACK"
operator|)
return|;
case|case
name|DL_UNITDATA_REQ
case|:
return|return
operator|(
literal|"DL_UNITDATA_REQ"
operator|)
return|;
case|case
name|DL_UNITDATA_IND
case|:
return|return
operator|(
literal|"DL_UNITDATA_IND"
operator|)
return|;
case|case
name|DL_UDERROR_IND
case|:
return|return
operator|(
literal|"DL_UDERROR_IND"
operator|)
return|;
case|case
name|DL_UDQOS_REQ
case|:
return|return
operator|(
literal|"DL_UDQOS_REQ"
operator|)
return|;
case|case
name|DL_CONNECT_REQ
case|:
return|return
operator|(
literal|"DL_CONNECT_REQ"
operator|)
return|;
case|case
name|DL_CONNECT_IND
case|:
return|return
operator|(
literal|"DL_CONNECT_IND"
operator|)
return|;
case|case
name|DL_CONNECT_RES
case|:
return|return
operator|(
literal|"DL_CONNECT_RES"
operator|)
return|;
case|case
name|DL_CONNECT_CON
case|:
return|return
operator|(
literal|"DL_CONNECT_CON"
operator|)
return|;
case|case
name|DL_TOKEN_REQ
case|:
return|return
operator|(
literal|"DL_TOKEN_REQ"
operator|)
return|;
case|case
name|DL_TOKEN_ACK
case|:
return|return
operator|(
literal|"DL_TOKEN_ACK"
operator|)
return|;
case|case
name|DL_DISCONNECT_REQ
case|:
return|return
operator|(
literal|"DL_DISCONNECT_REQ"
operator|)
return|;
case|case
name|DL_DISCONNECT_IND
case|:
return|return
operator|(
literal|"DL_DISCONNECT_IND"
operator|)
return|;
case|case
name|DL_RESET_REQ
case|:
return|return
operator|(
literal|"DL_RESET_REQ"
operator|)
return|;
case|case
name|DL_RESET_IND
case|:
return|return
operator|(
literal|"DL_RESET_IND"
operator|)
return|;
case|case
name|DL_RESET_RES
case|:
return|return
operator|(
literal|"DL_RESET_RES"
operator|)
return|;
case|case
name|DL_RESET_CON
case|:
return|return
operator|(
literal|"DL_RESET_CON"
operator|)
return|;
default|default:
name|pcap_snprintf
argument_list|(
name|primbuf
argument_list|,
name|primbufsize
argument_list|,
literal|"unknown primitive 0x%x"
argument_list|,
name|prim
argument_list|)
expr_stmt|;
return|return
operator|(
name|primbuf
operator|)
return|;
block|}
block|}
specifier|static
name|int
name|dlbindreq
parameter_list|(
name|int
name|fd
parameter_list|,
name|bpf_u_int32
name|sap
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_bind_req_t
name|req
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_BIND_REQ
expr_stmt|;
comment|/* XXX - what if neither of these are defined? */
if|#
directive|if
name|defined
argument_list|(
name|DL_HP_RAWDLS
argument_list|)
name|req
operator|.
name|dl_max_conind
operator|=
literal|1
expr_stmt|;
comment|/* XXX magic number */
name|req
operator|.
name|dl_service_mode
operator|=
name|DL_HP_RAWDLS
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|DL_CLDLS
argument_list|)
name|req
operator|.
name|dl_service_mode
operator|=
name|DL_CLDLS
expr_stmt|;
endif|#
directive|endif
name|req
operator|.
name|dl_sap
operator|=
name|sap
expr_stmt|;
return|return
operator|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"bind"
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
specifier|static
name|int
name|dlbindack
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|,
name|int
modifier|*
name|uerror
parameter_list|)
block|{
return|return
operator|(
name|recv_ack
argument_list|(
name|fd
argument_list|,
name|DL_BIND_ACK_SIZE
argument_list|,
literal|"bind"
argument_list|,
name|bufp
argument_list|,
name|ebuf
argument_list|,
name|uerror
argument_list|)
operator|)
return|;
block|}
specifier|static
name|int
name|dlokack
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
return|return
operator|(
name|recv_ack
argument_list|(
name|fd
argument_list|,
name|DL_OK_ACK_SIZE
argument_list|,
name|what
argument_list|,
name|bufp
argument_list|,
name|ebuf
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
specifier|static
name|int
name|dlinforeq
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_info_req_t
name|req
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_INFO_REQ
expr_stmt|;
return|return
operator|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"info"
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
specifier|static
name|int
name|dlinfoack
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
return|return
operator|(
name|recv_ack
argument_list|(
name|fd
argument_list|,
name|DL_INFO_ACK_SIZE
argument_list|,
literal|"info"
argument_list|,
name|bufp
argument_list|,
name|ebuf
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_DLPI_PASSIVE
comment|/*  * Enable DLPI passive mode. We do not care if this request fails, as this  * indicates the underlying DLPI device does not support link aggregation.  */
specifier|static
name|void
name|dlpassive
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_passive_req_t
name|req
decl_stmt|;
name|bpf_u_int32
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_PASSIVE_REQ
expr_stmt|;
if|if
condition|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"dlpassive"
argument_list|,
name|ebuf
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|dlokack
argument_list|(
name|fd
argument_list|,
literal|"dlpassive"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
comment|/*  * There's an ack *if* there's an error.  */
specifier|static
name|int
name|dlrawdatareq
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|u_char
modifier|*
name|datap
parameter_list|,
name|int
name|datalen
parameter_list|)
block|{
name|struct
name|strbuf
name|ctl
decl_stmt|,
name|data
decl_stmt|;
name|long
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
comment|/* XXX - char? */
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|int
name|dlen
decl_stmt|;
name|dlp
operator|=
name|MAKE_DL_PRIMITIVES
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|dlp
operator|->
name|dl_primitive
operator|=
name|DL_HP_RAWDATA_REQ
expr_stmt|;
name|dlen
operator|=
name|DL_HP_RAWDATA_REQ_SIZE
expr_stmt|;
comment|/* 	 * HP's documentation doesn't appear to show us supplying any 	 * address pointed to by the control part of the message. 	 * I think that's what raw mode means - you just send the raw 	 * packet, you don't specify where to send it to, as that's 	 * implied by the destination address. 	 */
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
name|dlen
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|data
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|datalen
expr_stmt|;
name|data
operator|.
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|datap
expr_stmt|;
return|return
operator|(
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* DL_HP_RAWDLS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SOLARIS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_BUFMOD_H
argument_list|)
specifier|static
name|void
name|get_release
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|bpf_u_int32
modifier|*
name|majorp
parameter_list|,
name|bpf_u_int32
modifier|*
name|minorp
parameter_list|,
name|bpf_u_int32
modifier|*
name|microp
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
operator|*
name|majorp
operator|=
literal|0
expr_stmt|;
operator|*
name|minorp
operator|=
literal|0
expr_stmt|;
operator|*
name|microp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sysinfo
argument_list|(
name|SI_RELEASE
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"?"
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return;
operator|*
name|majorp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
return|return;
operator|*
name|minorp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
return|return;
operator|*
name|microp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DL_HP_PPA_REQ
comment|/*  * Under HP-UX 10 and HP-UX 11, we can ask for the ppa  */
comment|/*  * Determine ppa number that specifies ifname.  *  * If the "dl_hp_ppa_info_t" doesn't have a "dl_module_id_1" member,  * the code that's used here is the old code for HP-UX 10.x.  *  * However, HP-UX 10.20, at least, appears to have such a member  * in its "dl_hp_ppa_info_t" structure, so the new code is used.  * The new code didn't work on an old 10.20 system on which Rick  * Jones of HP tried it, but with later patches installed, it  * worked - it appears that the older system had those members but  * didn't put anything in them, so, if the search by name fails, we  * do the old search.  *  * Rick suggests that making sure your system is "up on the latest  * lancommon/DLPI/driver patches" is probably a good idea; it'd fix  * that problem, as well as allowing libpcap to see packets sent  * from the system on which the libpcap application is being run.  * (On 10.20, in addition to getting the latest patches, you need  * to turn the kernel "lanc_outbound_promisc_flag" flag on with ADB;  * a posting to "comp.sys.hp.hpux" at  *  *	http://www.deja.com/[ST_rn=ps]/getdoc.xp?AN=558092266  *  * says that, to see the machine's outgoing traffic, you'd need to  * apply the right patches to your system, and also set that variable  * with:  echo 'lanc_outbound_promisc_flag/W1' | /usr/bin/adb -w /stand/vmunix /dev/kmem   * which could be put in, for example, "/sbin/init.d/lan".  *  * Setting the variable is not necessary on HP-UX 11.x.  */
specifier|static
name|int
name|get_dlpi_ppa
parameter_list|(
specifier|register
name|int
name|fd
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|device
parameter_list|,
specifier|register
name|int
name|unit
parameter_list|,
specifier|register
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
specifier|register
name|dl_hp_ppa_ack_t
modifier|*
name|ap
decl_stmt|;
specifier|register
name|dl_hp_ppa_info_t
modifier|*
name|ipstart
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|dname
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|u_long
name|majdev
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|dl_hp_ppa_req_t
name|req
decl_stmt|;
name|char
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
name|char
modifier|*
name|ppa_data_buf
decl_stmt|;
name|dl_hp_ppa_ack_t
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|ppa
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_HP_PPA_REQ
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"hpppa"
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
name|ctl
operator|.
name|maxlen
operator|=
name|DL_HP_PPA_ACK_SIZE
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * DLPI may return a big chunk of data for a DL_HP_PPA_REQ. The normal 	 * recv_ack will fail because it set the maxlen to MAXDLBUF (8192) 	 * which is NOT big enough for a DL_HP_PPA_REQ. 	 * 	 * This causes libpcap applications to fail on a system with HP-APA 	 * installed. 	 * 	 * To figure out how big the returned data is, we first call getmsg 	 * to get the small head and peek at the head to get the actual data 	 * length, and  then issue another getmsg to get the actual PPA data. 	 */
comment|/* get the head first */
if|if
condition|(
name|getmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"get_dlpi_ppa: hpppa getmsg: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|dlp
operator|=
operator|(
name|dl_hp_ppa_ack_t
operator|*
operator|)
name|ctl
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|dlp
operator|->
name|dl_primitive
operator|!=
name|DL_HP_PPA_ACK
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"get_dlpi_ppa: hpppa unexpected primitive ack 0x%x"
argument_list|,
operator|(
name|bpf_u_int32
operator|)
name|dlp
operator|->
name|dl_primitive
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
name|DL_HP_PPA_ACK_SIZE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"get_dlpi_ppa: hpppa ack too small (%d< %lu)"
argument_list|,
name|ctl
operator|.
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|DL_HP_PPA_ACK_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
comment|/* allocate buffer */
if|if
condition|(
operator|(
name|ppa_data_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dlp
operator|->
name|dl_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"get_dlpi_ppa: hpppa malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|ctl
operator|.
name|maxlen
operator|=
name|dlp
operator|->
name|dl_length
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ppa_data_buf
expr_stmt|;
comment|/* get the data */
if|if
condition|(
name|getmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"get_dlpi_ppa: hpppa getmsg: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppa_data_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
name|dlp
operator|->
name|dl_length
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"get_dlpi_ppa: hpppa ack too small (%d< %lu)"
argument_list|,
name|ctl
operator|.
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dlp
operator|->
name|dl_length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppa_data_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|ap
operator|=
operator|(
name|dl_hp_ppa_ack_t
operator|*
operator|)
name|buf
expr_stmt|;
name|ipstart
operator|=
operator|(
name|dl_hp_ppa_info_t
operator|*
operator|)
name|ppa_data_buf
expr_stmt|;
name|ip
operator|=
name|ipstart
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_HP_PPA_INFO_T_DL_MODULE_ID_1
comment|/* 	 * The "dl_hp_ppa_info_t" structure has a "dl_module_id_1" 	 * member that should, in theory, contain the part of the 	 * name for the device that comes before the unit number, 	 * and should also have a "dl_module_id_2" member that may 	 * contain an alternate name (e.g., I think Ethernet devices 	 * have both "lan", for "lanN", and "snap", for "snapN", with 	 * the former being for Ethernet packets and the latter being 	 * for 802.3/802.2 packets). 	 * 	 * Search for the device that has the specified name and 	 * instance number. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|dl_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ip
operator|->
name|dl_module_id_1
argument_list|,
name|device
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ip
operator|->
name|dl_module_id_2
argument_list|,
name|device
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|ip
operator|->
name|dl_instance_num
operator|==
name|unit
condition|)
break|break;
name|ip
operator|=
operator|(
name|dl_hp_ppa_info_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ipstart
operator|+
name|ip
operator|->
name|dl_next_offset
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	 * We don't have that member, so the search is impossible; make it 	 * look as if the search failed. 	 */
name|i
operator|=
name|ap
operator|->
name|dl_count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
name|ap
operator|->
name|dl_count
condition|)
block|{
comment|/* 		 * Well, we didn't, or can't, find the device by name. 		 * 		 * HP-UX 10.20, whilst it has "dl_module_id_1" and 		 * "dl_module_id_2" fields in the "dl_hp_ppa_info_t", 		 * doesn't seem to fill them in unless the system is 		 * at a reasonably up-to-date patch level. 		 * 		 * Older HP-UX 10.x systems might not have those fields 		 * at all. 		 * 		 * Therefore, we'll search for the entry with the major 		 * device number of a device with the name "/dev/<dev><unit>", 		 * if such a device exists, as the old code did. 		 */
name|pcap_snprintf
argument_list|(
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|,
literal|"/dev/%s%d"
argument_list|,
name|device
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"stat: %s: %s"
argument_list|,
name|dname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|majdev
operator|=
name|major
argument_list|(
name|statbuf
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
name|ip
operator|=
name|ipstart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|dl_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|dl_mjr_num
operator|==
name|majdev
operator|&&
name|ip
operator|->
name|dl_instance_num
operator|==
name|unit
condition|)
break|break;
name|ip
operator|=
operator|(
name|dl_hp_ppa_info_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ipstart
operator|+
name|ip
operator|->
name|dl_next_offset
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|ap
operator|->
name|dl_count
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't find /dev/dlpi PPA for %s%d"
argument_list|,
name|device
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|)
return|;
block|}
if|if
condition|(
name|ip
operator|->
name|dl_hdw_state
operator|==
name|HDW_DEAD
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s%d: hardware state: DOWN\n"
argument_list|,
name|device
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppa_data_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|ppa
operator|=
name|ip
operator|->
name|dl_ppa
expr_stmt|;
name|free
argument_list|(
name|ppa_data_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ppa
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_HPUX9
comment|/*  * Under HP-UX 9, there is no good way to determine the ppa.  * So punt and read it from /dev/kmem.  */
specifier|static
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
define|#
directive|define
name|NL_IFNET
value|0
block|{
literal|"ifnet"
block|}
block|,
block|{
literal|""
block|}
block|}
decl_stmt|;
specifier|static
name|char
name|path_vmunix
index|[]
init|=
literal|"/hp-ux"
decl_stmt|;
comment|/* Determine ppa number that specifies ifname */
specifier|static
name|int
name|get_dlpi_ppa
parameter_list|(
specifier|register
name|int
name|fd
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
specifier|register
name|int
name|unit
parameter_list|,
specifier|register
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|kd
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|struct
name|ifnet
name|ifnet
decl_stmt|;
name|char
name|if_name
index|[
sizeof|sizeof
argument_list|(
name|ifnet
operator|.
name|if_name
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|ifname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|ifname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nlist
argument_list|(
name|path_vmunix
argument_list|,
operator|&
name|nl
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"nlist %s failed"
argument_list|,
name|path_vmunix
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nl
index|[
name|NL_IFNET
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"could't find %s kernel symbol"
argument_list|,
name|nl
index|[
name|NL_IFNET
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|kd
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"kmem open: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dlpi_kread
argument_list|(
name|kd
argument_list|,
name|nl
index|[
name|NL_IFNET
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|kd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|ifnet
operator|.
name|if_next
control|)
block|{
if|if
condition|(
name|dlpi_kread
argument_list|(
name|kd
argument_list|,
operator|(
name|off_t
operator|)
name|addr
argument_list|,
operator|&
name|ifnet
argument_list|,
sizeof|sizeof
argument_list|(
name|ifnet
argument_list|)
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlpi_kread
argument_list|(
name|kd
argument_list|,
operator|(
name|off_t
operator|)
name|ifnet
operator|.
name|if_name
argument_list|,
name|if_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifnet
operator|.
name|if_name
argument_list|)
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|kd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_name
index|[
sizeof|sizeof
argument_list|(
name|ifnet
operator|.
name|if_name
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|if_name
argument_list|,
name|ifname
argument_list|)
operator|==
literal|0
operator|&&
name|ifnet
operator|.
name|if_unit
operator|==
name|unit
condition|)
return|return
operator|(
name|ifnet
operator|.
name|if_index
operator|)
return|;
block|}
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't find %s"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
specifier|static
name|int
name|dlpi_kread
parameter_list|(
specifier|register
name|int
name|fd
parameter_list|,
specifier|register
name|off_t
name|addr
parameter_list|,
specifier|register
name|void
modifier|*
name|buf
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
specifier|register
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
specifier|register
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"lseek: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"read: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|!=
name|len
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"short read (%d != %d)"
argument_list|,
name|cc
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|cc
operator|)
return|;
block|}
endif|#
directive|endif
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|device
name|_U_
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
name|struct
name|pcap_dlpi
modifier|*
name|pd
decl_stmt|;
endif|#
directive|endif
name|p
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_dlpi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
name|pd
operator|=
name|p
operator|->
name|priv
expr_stmt|;
name|pd
operator|->
name|send_fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* it hasn't been opened yet */
endif|#
directive|endif
name|p
operator|->
name|activate_op
operator|=
name|pcap_activate_dlpi
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

end_unit

