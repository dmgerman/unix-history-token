begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * This code contributed by Atanu Ghosh (atanu@cs.ucl.ac.uk),  * University College London.  */
end_comment

begin_comment
comment|/*  * Packet capture routine for dlpi under SunOS 5  *  * Notes:  *  *    - Apparently the DLIOCRAW ioctl() is specific to SunOS.  *  *    - There is a bug in bufmod(7) such that setting the snapshot  *      length results in data being left of the front of the packet.  *  *    - It might be desirable to use pfmod(7) to filter packets in the  *      kernel.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/pcap-dlpi.c,v 1.63 2000/11/22 05:32:55 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bufmod.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/dlpi.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_DLPI_EXT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/dlpi_ext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HPUX9
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DL_HP_PPA_ACK_OBS
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SOLARIS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_BUFMOD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systeminfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HPUX9
end_ifdef

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HPUX9
end_ifdef

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCAP_DEV_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|PCAP_DEV_PREFIX
value|"/dev"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXDLBUF
value|8192
end_define

begin_comment
comment|/* Forwards */
end_comment

begin_function_decl
specifier|static
name|int
name|dlattachreq
parameter_list|(
name|int
parameter_list|,
name|bpf_u_int32
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlbindack
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlbindreq
parameter_list|(
name|int
parameter_list|,
name|bpf_u_int32
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlinfoack
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlinforeq
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlokack
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|recv_ack
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlpromisconreq
parameter_list|(
name|int
parameter_list|,
name|bpf_u_int32
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SOLARIS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_BUFMOD_H
argument_list|)
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|get_release
parameter_list|(
name|bpf_u_int32
modifier|*
parameter_list|,
name|bpf_u_int32
modifier|*
parameter_list|,
name|bpf_u_int32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|send_request
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
end_ifdef

begin_function_decl
specifier|static
name|int
name|strioctl
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HPUX9
end_ifdef

begin_function_decl
specifier|static
name|int
name|dlpi_kread
parameter_list|(
name|int
parameter_list|,
name|off_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DEV_DLPI
end_ifdef

begin_function_decl
specifier|static
name|int
name|get_dlpi_ppa
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pcap_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
operator|*
name|ps
operator|=
name|p
operator|->
name|md
operator|.
name|stat
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX Needed by HP-UX (at least) */
end_comment

begin_decl_stmt
specifier|static
name|bpf_u_int32
name|ctlbuf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|strbuf
name|ctl
init|=
block|{
name|MAXDLBUF
block|,
literal|0
block|,
operator|(
name|char
operator|*
operator|)
name|ctlbuf
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcap_read
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
specifier|register
name|int
name|cc
decl_stmt|,
name|n
decl_stmt|,
name|caplen
decl_stmt|,
name|origlen
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|pk
decl_stmt|;
specifier|register
name|struct
name|bpf_insn
modifier|*
name|fcode
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
specifier|register
name|struct
name|sb_hdr
modifier|*
name|sbp
decl_stmt|;
ifdef|#
directive|ifdef
name|LBL_ALIGN
name|struct
name|sb_hdr
name|sbhdr
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|int
name|flags
decl_stmt|;
name|struct
name|strbuf
name|data
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pkthdr
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|cc
operator|=
name|p
operator|->
name|cc
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|buffer
operator|+
name|p
operator|->
name|offset
expr_stmt|;
name|data
operator|.
name|maxlen
operator|=
name|MAXDLBUF
expr_stmt|;
name|data
operator|.
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|getmsg
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Don't choke when we get ptraced */
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|cc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cc
operator|=
name|data
operator|.
name|len
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|==
literal|0
condition|)
do|;
name|bp
operator|=
name|p
operator|->
name|buffer
operator|+
name|p
operator|->
name|offset
expr_stmt|;
block|}
else|else
name|bp
operator|=
name|p
operator|->
name|bp
expr_stmt|;
comment|/* Loop through packets */
name|fcode
operator|=
name|p
operator|->
name|fcode
operator|.
name|bf_insns
expr_stmt|;
name|ep
operator|=
name|bp
operator|+
name|cc
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
block|{
ifdef|#
directive|ifdef
name|LBL_ALIGN
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|&
literal|3
condition|)
block|{
name|sbp
operator|=
operator|&
name|sbhdr
expr_stmt|;
name|memcpy
argument_list|(
name|sbp
argument_list|,
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sbp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|sbp
operator|=
operator|(
expr|struct
name|sb_hdr
operator|*
operator|)
name|bp
expr_stmt|;
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_drop
operator|+=
name|sbp
operator|->
name|sbh_drops
expr_stmt|;
name|pk
operator|=
name|bp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sbp
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sbp
operator|->
name|sbh_totlen
expr_stmt|;
name|origlen
operator|=
name|sbp
operator|->
name|sbh_origlen
expr_stmt|;
name|caplen
operator|=
name|sbp
operator|->
name|sbh_msglen
expr_stmt|;
else|#
directive|else
name|origlen
operator|=
name|cc
expr_stmt|;
name|caplen
operator|=
name|min
argument_list|(
name|p
operator|->
name|snapshot
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|pk
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|caplen
expr_stmt|;
endif|#
directive|endif
operator|++
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_recv
expr_stmt|;
if|if
condition|(
name|bpf_filter
argument_list|(
name|fcode
argument_list|,
name|pk
argument_list|,
name|origlen
argument_list|,
name|caplen
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
name|pkthdr
operator|.
name|ts
operator|=
name|sbp
operator|->
name|sbh_timestamp
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|pkthdr
operator|.
name|ts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pkthdr
operator|.
name|len
operator|=
name|origlen
expr_stmt|;
name|pkthdr
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
comment|/* Insure caplen does not exceed snapshot */
if|if
condition|(
name|pkthdr
operator|.
name|caplen
operator|>
name|p
operator|->
name|snapshot
condition|)
name|pkthdr
operator|.
name|caplen
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
call|(
modifier|*
name|callback
call|)
argument_list|(
name|user
argument_list|,
operator|&
name|pkthdr
argument_list|,
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|>=
name|cnt
operator|&&
name|cnt
operator|>=
literal|0
condition|)
block|{
name|p
operator|->
name|cc
operator|=
name|ep
operator|-
name|bp
expr_stmt|;
name|p
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
block|}
endif|#
directive|endif
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_live
parameter_list|(
name|char
modifier|*
name|device
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|eos
decl_stmt|;
specifier|register
name|pcap_t
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|ppa
decl_stmt|;
specifier|register
name|dl_info_ack_t
modifier|*
name|infop
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
name|bpf_u_int32
name|ss
decl_stmt|,
name|flag
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
specifier|register
name|char
modifier|*
name|release
decl_stmt|;
name|bpf_u_int32
name|osmajor
decl_stmt|,
name|osminor
decl_stmt|,
name|osmicro
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|bpf_u_int32
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
name|char
name|dname
index|[
literal|100
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_DEV_DLPI
name|char
name|dname2
index|[
literal|100
index|]
decl_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|pcap_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|ebuf
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DEV_DLPI
comment|/* 	** Remove any "/dev/" on the front of the device. 	*/
name|cp
operator|=
name|strrchr
argument_list|(
name|device
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|device
expr_stmt|;
else|else
name|cp
operator|++
expr_stmt|;
name|strlcpy
argument_list|(
name|dname
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Split the name into a device type and a unit number. 	 */
name|cp
operator|=
name|strpbrk
argument_list|(
name|dname
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s missing unit number"
argument_list|,
name|device
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ppa
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eos
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eos
operator|!=
literal|'\0'
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s bad unit number"
argument_list|,
name|device
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Use "/dev/dlpi" as the device. 	 * 	 * XXX - HP's DLPI Programmer's Guide for HP-UX 11.00 says that 	 * the "dl_mjr_num" field is for the "major number of interface 	 * driver"; that's the major of "/dev/dlpi" on the system on 	 * which I tried this, but there may be DLPI devices that 	 * use a different driver, in which case we may need to 	 * search "/dev" for the appropriate device with that major 	 * device number, rather than hardwiring "/dev/dlpi". 	 */
name|cp
operator|=
literal|"/dev/dlpi"
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|fd
operator|=
name|open
argument_list|(
name|cp
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|cp
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Get a table of all PPAs for that device, and search that 	 * table for the specified device type name and unit number. 	 */
name|ppa
operator|=
name|get_dlpi_ppa
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|dname
argument_list|,
name|ppa
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppa
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
else|#
directive|else
comment|/* 	** Determine device and ppa 	*/
name|cp
operator|=
name|strpbrk
argument_list|(
name|device
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s missing unit number"
argument_list|,
name|device
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ppa
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eos
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eos
operator|!=
literal|'\0'
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s bad unit number"
argument_list|,
name|device
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|*
name|device
operator|==
literal|'/'
condition|)
name|strlcpy
argument_list|(
name|dname
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|PCAP_DEV_PREFIX
argument_list|,
name|device
argument_list|)
expr_stmt|;
comment|/* Try device without unit number */
name|strlcpy
argument_list|(
name|dname2
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname2
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|dname
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|fd
operator|=
name|open
argument_list|(
name|dname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|dname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Try again with unit number */
if|if
condition|(
operator|(
name|p
operator|->
name|fd
operator|=
name|open
argument_list|(
name|dname2
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|dname2
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* XXX Assume unit zero */
name|ppa
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|p
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
comment|/* 	** Attach if "style 2" provider 	*/
if|if
condition|(
name|dlinforeq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlinfoack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|infop
operator|=
operator|&
operator|(
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|buf
operator|)
operator|->
name|info_ack
expr_stmt|;
if|if
condition|(
name|infop
operator|->
name|dl_provider_style
operator|==
name|DL_STYLE2
operator|&&
operator|(
name|dlattachreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|ppa
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlokack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|"attach"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|)
condition|)
goto|goto
name|bad
goto|;
comment|/* 	** Bind (defer if using HP-UX 9 or HP-UX 10.20, totally skip if 	** using SINIX) 	*/
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_HPUX9
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_HPUX10_20
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sinix
argument_list|)
ifdef|#
directive|ifdef
name|_AIX
comment|/* According to IBM's AIX Support Line, the dl_sap value         ** should not be less than 0x600 (1536) for standard ethernet           */
if|if
condition|(
name|dlbindreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|1537
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
else|#
directive|else
if|if
condition|(
name|dlbindreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
endif|#
directive|endif
name|dlbindack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
if|if
condition|(
name|promisc
condition|)
block|{
comment|/* 		** Enable promiscuous 		*/
if|if
condition|(
name|dlpromisconreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|DL_PROMISC_PHYS
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlokack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|"promisc_phys"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 		** Try to enable multicast (you would have thought 		** promiscuous would be sufficient). (Skip if using 		** HP-UX or SINIX) 		*/
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sinix
argument_list|)
if|if
condition|(
name|dlpromisconreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|DL_PROMISC_MULTI
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlokack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|"promisc_multi"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: DL_PROMISC_MULTI failed (%s)\n"
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	** Try to enable sap (when not in promiscuous mode when using 	** using HP-UX and never under SINIX) 	*/
ifndef|#
directive|ifndef
name|sinix
if|if
condition|(
ifdef|#
directive|ifdef
name|__hpux
operator|!
name|promisc
operator|&&
endif|#
directive|endif
operator|(
name|dlpromisconreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|DL_PROMISC_SAP
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlokack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|"promisc_sap"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* Not fatal if promisc since the DL_PROMISC_PHYS worked */
if|if
condition|(
name|promisc
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: DL_PROMISC_SAP failed (%s)\n"
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* 	** HP-UX 9 and HP-UX 10.20 must bind after setting promiscuous 	** options) 	*/
if|#
directive|if
name|defined
argument_list|(
name|HAVE_HPUX9
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_HPUX10_20
argument_list|)
if|if
condition|(
name|dlbindreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlbindack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
comment|/* 	** Determine link type 	*/
if|if
condition|(
name|dlinforeq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlinfoack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|infop
operator|=
operator|&
operator|(
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|buf
operator|)
operator|->
name|info_ack
expr_stmt|;
switch|switch
condition|(
name|infop
operator|->
name|dl_mac_type
condition|)
block|{
case|case
name|DL_CSMACD
case|:
case|case
name|DL_ETHER
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
name|p
operator|->
name|offset
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|DL_FDDI
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_FDDI
expr_stmt|;
name|p
operator|->
name|offset
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown mac type %lu"
argument_list|,
name|infop
operator|->
name|dl_mac_type
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|DLIOCRAW
comment|/* 	** This is a non standard SunOS hack to get the ethernet header. 	*/
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|DLIOCRAW
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"DLIOCRAW: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
comment|/* 	** Another non standard call to get the data nicely buffered 	*/
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|I_PUSH
argument_list|,
literal|"bufmod"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"I_PUSH bufmod: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	** Now that the bufmod is pushed lets configure it. 	** 	** There is a bug in bufmod(7). When dealing with messages of 	** less than snaplen size it strips data from the beginning not 	** the end. 	** 	** This bug is supposed to be fixed in 5.3.2. Also, there is a 	** patch available. Ask for bugid 1149065. 	*/
name|ss
operator|=
name|snaplen
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOLARIS
name|release
operator|=
name|get_release
argument_list|(
operator|&
name|osmajor
argument_list|,
operator|&
name|osminor
argument_list|,
operator|&
name|osmicro
argument_list|)
expr_stmt|;
if|if
condition|(
name|osmajor
operator|==
literal|5
operator|&&
operator|(
name|osminor
operator|<=
literal|2
operator|||
operator|(
name|osminor
operator|==
literal|3
operator|&&
name|osmicro
operator|<
literal|2
operator|)
operator|)
operator|&&
name|getenv
argument_list|(
literal|"BUFMOD_FIXED"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: bufmod is broken in SunOS %s; ignoring snaplen.\n"
argument_list|,
name|release
argument_list|)
expr_stmt|;
name|ss
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ss
operator|>
literal|0
operator|&&
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|SBIOCSSNAP
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ss
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SBIOCSSNAP: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	** Set up the bufmod flags 	*/
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|SBIOCGFLAGS
argument_list|,
sizeof|sizeof
argument_list|(
name|flag
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flag
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SBIOCGFLAGS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|flag
operator||=
name|SB_NO_DROPS
expr_stmt|;
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|SBIOCSFLAGS
argument_list|,
sizeof|sizeof
argument_list|(
name|flag
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SBIOCSFLAGS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	** Set up the bufmod timeout 	*/
if|if
condition|(
name|to_ms
operator|!=
literal|0
condition|)
block|{
name|struct
name|timeval
name|to
decl_stmt|;
name|to
operator|.
name|tv_sec
operator|=
name|to_ms
operator|/
literal|1000
expr_stmt|;
name|to
operator|.
name|tv_usec
operator|=
operator|(
name|to_ms
operator|*
literal|1000
operator|)
operator|%
literal|1000000
expr_stmt|;
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|SBIOCSTIME
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SBIOCSTIME: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* 	** As the last operation flush the read side. 	*/
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|I_FLUSH
argument_list|,
name|FLUSHR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"FLUSHR: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Allocate data buffer */
name|p
operator|->
name|bufsize
operator|=
name|MAXDLBUF
operator|*
sizeof|sizeof
argument_list|(
name|bpf_u_int32
argument_list|)
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|p
operator|->
name|bufsize
operator|+
name|p
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|install_bpf_program
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_request
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|ptr
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send_request: putmsg \"%s\": %s"
argument_list|,
name|what
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_ack
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|bufp
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s getmsg: %s"
argument_list|,
name|what
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|ctl
operator|.
name|buf
expr_stmt|;
switch|switch
condition|(
name|dlp
operator|->
name|dl_primitive
condition|)
block|{
case|case
name|DL_INFO_ACK
case|:
case|case
name|DL_BIND_ACK
case|:
case|case
name|DL_OK_ACK
case|:
ifdef|#
directive|ifdef
name|DL_HP_PPA_ACK
case|case
name|DL_HP_PPA_ACK
case|:
endif|#
directive|endif
comment|/* These are OK */
break|break;
case|case
name|DL_ERROR_ACK
case|:
switch|switch
condition|(
name|dlp
operator|->
name|error_ack
operator|.
name|dl_errno
condition|)
block|{
case|case
name|DL_BADPPA
case|:
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s bad ppa (device unit)"
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
case|case
name|DL_SYSERR
case|:
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s: %s"
argument_list|,
name|what
argument_list|,
name|pcap_strerror
argument_list|(
name|dlp
operator|->
name|error_ack
operator|.
name|dl_unix_errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DL_UNSUPPORTED
case|:
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s: Service not supplied by provider"
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s error 0x%x"
argument_list|,
name|what
argument_list|,
operator|(
name|bpf_u_int32
operator|)
name|dlp
operator|->
name|error_ack
operator|.
name|dl_errno
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s unexpected primitive ack 0x%x "
argument_list|,
name|what
argument_list|,
operator|(
name|bpf_u_int32
operator|)
name|dlp
operator|->
name|dl_primitive
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
name|size
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv_ack: %s ack too small (%d< %d)"
argument_list|,
name|what
argument_list|,
name|ctl
operator|.
name|len
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ctl
operator|.
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlattachreq
parameter_list|(
name|int
name|fd
parameter_list|,
name|bpf_u_int32
name|ppa
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_attach_req_t
name|req
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_ATTACH_REQ
expr_stmt|;
name|req
operator|.
name|dl_ppa
operator|=
name|ppa
expr_stmt|;
return|return
operator|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"attach"
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlbindreq
parameter_list|(
name|int
name|fd
parameter_list|,
name|bpf_u_int32
name|sap
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_bind_req_t
name|req
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_BIND_REQ
expr_stmt|;
ifdef|#
directive|ifdef
name|DL_HP_RAWDLS
name|req
operator|.
name|dl_max_conind
operator|=
literal|1
expr_stmt|;
comment|/* XXX magic number */
comment|/* 22 is INSAP as per the HP-UX DLPI Programmer's Guide */
name|req
operator|.
name|dl_sap
operator|=
literal|22
expr_stmt|;
name|req
operator|.
name|dl_service_mode
operator|=
name|DL_HP_RAWDLS
expr_stmt|;
else|#
directive|else
name|req
operator|.
name|dl_sap
operator|=
name|sap
expr_stmt|;
ifdef|#
directive|ifdef
name|DL_CLDLS
name|req
operator|.
name|dl_service_mode
operator|=
name|DL_CLDLS
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"bind"
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlbindack
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
return|return
operator|(
name|recv_ack
argument_list|(
name|fd
argument_list|,
name|DL_BIND_ACK_SIZE
argument_list|,
literal|"bind"
argument_list|,
name|bufp
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlpromisconreq
parameter_list|(
name|int
name|fd
parameter_list|,
name|bpf_u_int32
name|level
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_promiscon_req_t
name|req
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_PROMISCON_REQ
expr_stmt|;
name|req
operator|.
name|dl_level
operator|=
name|level
expr_stmt|;
return|return
operator|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"promiscon"
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlokack
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
return|return
operator|(
name|recv_ack
argument_list|(
name|fd
argument_list|,
name|DL_OK_ACK_SIZE
argument_list|,
name|what
argument_list|,
name|bufp
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlinforeq
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_info_req_t
name|req
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_INFO_REQ
expr_stmt|;
return|return
operator|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"info"
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlinfoack
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
return|return
operator|(
name|recv_ack
argument_list|(
name|fd
argument_list|,
name|DL_INFO_ACK_SIZE
argument_list|,
literal|"info"
argument_list|,
name|bufp
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BUFMOD_H
end_ifdef

begin_function
specifier|static
name|int
name|strioctl
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|strioctl
name|str
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|str
operator|.
name|ic_cmd
operator|=
name|cmd
expr_stmt|;
name|str
operator|.
name|ic_timout
operator|=
operator|-
literal|1
expr_stmt|;
name|str
operator|.
name|ic_len
operator|=
name|len
expr_stmt|;
name|str
operator|.
name|ic_dp
operator|=
name|dp
expr_stmt|;
name|rc
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
else|else
return|return
operator|(
name|str
operator|.
name|ic_len
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SOLARIS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_BUFMOD_H
argument_list|)
end_if

begin_function
specifier|static
name|char
modifier|*
name|get_release
parameter_list|(
name|bpf_u_int32
modifier|*
name|majorp
parameter_list|,
name|bpf_u_int32
modifier|*
name|minorp
parameter_list|,
name|bpf_u_int32
modifier|*
name|microp
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
operator|*
name|majorp
operator|=
literal|0
expr_stmt|;
operator|*
name|minorp
operator|=
literal|0
expr_stmt|;
operator|*
name|microp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sysinfo
argument_list|(
name|SI_RELEASE
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|"?"
operator|)
return|;
name|cp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
operator|(
name|buf
operator|)
return|;
operator|*
name|majorp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
return|return
operator|(
name|buf
operator|)
return|;
operator|*
name|minorp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
return|return
operator|(
name|buf
operator|)
return|;
operator|*
name|microp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DL_HP_PPA_ACK_OBS
end_ifdef

begin_comment
comment|/*  * Under HP-UX 10 and HP-UX 11, we can ask for the ppa  */
end_comment

begin_comment
comment|/*  * Determine ppa number that specifies ifname.  *  * If the "dl_hp_ppa_info_t" doesn't have a "dl_module_id_1" member,  * the code that's used here is the old code for HP-UX 10.x.  *  * However, HP-UX 10.20, at least, appears to have such a member  * in its "dl_hp_ppa_info_t" structure, so the new code is used.  * The new code didn't work on an old 10.20 system on which Rick  * Jones of HP tried it, but with later patches installed, it  * worked - it appears that the older system had those members but  * didn't put anything in them, so, if the search by name fails, we  * do the old search.  *  * Rick suggests that making sure your system is "up on the latest  * lancommon/DLPI/driver patches" is probably a good idea; it'd fix  * that problem, as well as allowing libpcap to see packets sent  * from the system on which the libpcap application is being run.  * (On 10.20, in addition to getting the latest patches, you need  * to turn the kernel "lanc_outbound_promisc_flag" flag on with ADB;  * a posting to "comp.sys.hp.hpux" at  *  *	http://www.deja.com/[ST_rn=ps]/getdoc.xp?AN=558092266  *  * says that, to see the machine's outgoing traffic, you'd need to  * apply the right patches to your system, and also set that variable  * with:   echo 'lanc_outbound_promisc_flag/W1' | /usr/bin/adb -w /stand/vmunix /dev/kmem   * which could be put in, for example, "/sbin/init.d/lan".  *  * Setting the variable is not necessary on HP-UX 11.x.  */
end_comment

begin_function
specifier|static
name|int
name|get_dlpi_ppa
parameter_list|(
specifier|register
name|int
name|fd
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|device
parameter_list|,
specifier|register
name|int
name|unit
parameter_list|,
specifier|register
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
specifier|register
name|dl_hp_ppa_ack_t
modifier|*
name|ap
decl_stmt|;
specifier|register
name|dl_hp_ppa_info_t
modifier|*
name|ipstart
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|dname
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|u_long
name|majdev
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|dl_hp_ppa_req_t
name|req
decl_stmt|;
name|bpf_u_int32
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_HP_PPA_REQ
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"hpppa"
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|recv_ack
argument_list|(
name|fd
argument_list|,
name|DL_HP_PPA_ACK_SIZE
argument_list|,
literal|"hpppa"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ap
operator|=
operator|(
name|dl_hp_ppa_ack_t
operator|*
operator|)
name|buf
expr_stmt|;
name|ipstart
operator|=
operator|(
name|dl_hp_ppa_info_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ap
operator|+
name|ap
operator|->
name|dl_offset
operator|)
expr_stmt|;
name|ip
operator|=
name|ipstart
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_HP_PPA_INFO_T_DL_MODULE_ID_1
comment|/* 	 * The "dl_hp_ppa_info_t" structure has a "dl_module_id_1" 	 * member that should, in theory, contain the part of the 	 * name for the device that comes before the unit number, 	 * and should also have a "dl_module_id_2" member that may 	 * contain an alternate name (e.g., I think Ethernet devices 	 * have both "lan", for "lanN", and "snap", for "snapN", with 	 * the former being for Ethernet packets and the latter being 	 * for 802.3/802.2 packets). 	 * 	 * Search for the device that has the specified name and 	 * instance number. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|dl_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|ip
operator|->
name|dl_module_id_1
argument_list|,
name|device
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ip
operator|->
name|dl_module_id_2
argument_list|,
name|device
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|ip
operator|->
name|dl_instance_num
operator|==
name|unit
condition|)
break|break;
name|ip
operator|=
operator|(
name|dl_hp_ppa_info_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ipstart
operator|+
name|ip
operator|->
name|dl_next_offset
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	 * We don't have that member, so the search is impossible; make it 	 * look as if the search failed. 	 */
name|i
operator|=
name|ap
operator|->
name|dl_count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
name|ap
operator|->
name|dl_count
condition|)
block|{
comment|/* 		 * Well, we didn't, or can't, find the device by name. 		 * 		 * HP-UX 10.20, whilst it has "dl_module_id_1" and 		 * "dl_module_id_2" fields in the "dl_hp_ppa_info_t", 		 * doesn't seem to fill them in unless the system is 		 * at a reasonably up-to-date patch level. 		 * 		 * Older HP-UX 10.x systems might not have those fields 		 * at all. 		 * 		 * Therefore, we'll search for the entry with the major 		 * device number of a device with the name "/dev/<dev><unit>", 		 * if such a device exists, as the old code did. 		 */
name|snprintf
argument_list|(
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|,
literal|"/dev/%s%d"
argument_list|,
name|device
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"stat: %s: %s"
argument_list|,
name|dname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|majdev
operator|=
name|major
argument_list|(
name|statbuf
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
name|ip
operator|=
name|ipstart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|dl_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|dl_mjr_num
operator|==
name|majdev
operator|&&
name|ip
operator|->
name|dl_instance_num
operator|==
name|unit
condition|)
break|break;
name|ip
operator|=
operator|(
name|dl_hp_ppa_info_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ipstart
operator|+
name|ip
operator|->
name|dl_next_offset
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|ap
operator|->
name|dl_count
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't find /dev/dlpi PPA for %s%d"
argument_list|,
name|device
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ip
operator|->
name|dl_hdw_state
operator|==
name|HDW_DEAD
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s%d: hardware state: DOWN\n"
argument_list|,
name|device
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|ip
operator|->
name|dl_ppa
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HPUX9
end_ifdef

begin_comment
comment|/*  * Under HP-UX 9, there is no good way to determine the ppa.  * So punt and read it from /dev/kmem.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
define|#
directive|define
name|NL_IFNET
value|0
block|{
literal|"ifnet"
block|}
block|,
block|{
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|path_vmunix
index|[]
init|=
literal|"/hp-ux"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine ppa number that specifies ifname */
end_comment

begin_function
specifier|static
name|int
name|get_dlpi_ppa
parameter_list|(
specifier|register
name|int
name|fd
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
specifier|register
name|int
name|unit
parameter_list|,
specifier|register
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|kd
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|struct
name|ifnet
name|ifnet
decl_stmt|;
name|char
name|if_name
index|[
sizeof|sizeof
argument_list|(
name|ifnet
operator|.
name|if_name
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|ifname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|ifname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nlist
argument_list|(
name|path_vmunix
argument_list|,
operator|&
name|nl
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"nlist %s failed"
argument_list|,
name|path_vmunix
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nl
index|[
name|NL_IFNET
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"could't find %s kernel symbol"
argument_list|,
name|nl
index|[
name|NL_IFNET
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|kd
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"kmem open: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dlpi_kread
argument_list|(
name|kd
argument_list|,
name|nl
index|[
name|NL_IFNET
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|kd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|ifnet
operator|.
name|if_next
control|)
block|{
if|if
condition|(
name|dlpi_kread
argument_list|(
name|kd
argument_list|,
operator|(
name|off_t
operator|)
name|addr
argument_list|,
operator|&
name|ifnet
argument_list|,
sizeof|sizeof
argument_list|(
name|ifnet
argument_list|)
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlpi_kread
argument_list|(
name|kd
argument_list|,
operator|(
name|off_t
operator|)
name|ifnet
operator|.
name|if_name
argument_list|,
name|if_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifnet
operator|.
name|if_name
argument_list|)
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|kd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_name
index|[
sizeof|sizeof
argument_list|(
name|ifnet
operator|.
name|if_name
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|if_name
argument_list|,
name|ifname
argument_list|)
operator|==
literal|0
operator|&&
name|ifnet
operator|.
name|if_unit
operator|==
name|unit
condition|)
return|return
operator|(
name|ifnet
operator|.
name|if_index
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't find %s"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlpi_kread
parameter_list|(
specifier|register
name|int
name|fd
parameter_list|,
specifier|register
name|off_t
name|addr
parameter_list|,
specifier|register
name|void
modifier|*
name|buf
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
specifier|register
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
specifier|register
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"lseek: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"read: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|!=
name|len
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"short read (%d != %d)"
argument_list|,
name|cc
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|cc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

