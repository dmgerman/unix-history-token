begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  This file is part of DOS-libpcap  *  Ported to DOS/DOSX by G. Vanem<gvanem@yahoo.no>  *  *  pcap-dos.c: Interface to PKTDRVR, NDIS2 and 32-bit pmode  *              network drivers.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_32BIT_DRIVERS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"msdos/pm_drvr/pmdrvr.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/pci.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/bios32.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/module.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/3c501.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/3c503.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/3c509.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/3c59x.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/3c515.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/3c90x.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/3c575_cb.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/ne.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/wd.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/accton.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/cs89x0.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/rtl8139.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/ne2k-pci.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap.h"
end_include

begin_include
include|#
directive|include
file|"pcap-dos.h"
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pktdrvr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_NDIS2
end_ifdef

begin_include
include|#
directive|include
file|"msdos/ndis2.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/if_packe.h>
end_include

begin_include
include|#
directive|include
file|<tcp.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_32BIT_DRIVERS
argument_list|)
end_if

begin_define
define|#
directive|define
name|FLUSHK
parameter_list|()
value|do { _printk_safe = 1; _printk_flush(); } while (0)
end_define

begin_define
define|#
directive|define
name|NDIS_NEXT_DEV
value|&rtl8139_dev
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rx_pool
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|init_32bit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pktq_init
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|num
parameter_list|,
name|char
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pktq_check
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pktq_inc_out
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|pktq_in_index
argument_list|(
expr|struct
name|rx_ringbuf
operator|*
name|q
argument_list|)
name|LOCKED_FUNC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pktq_clear
argument_list|(
expr|struct
name|rx_ringbuf
operator|*
name|q
argument_list|)
name|LOCKED_FUNC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rx_elem
modifier|*
name|pktq_in_elem
argument_list|(
expr|struct
name|rx_ringbuf
operator|*
name|q
argument_list|)
name|LOCKED_FUNC
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|rx_elem
modifier|*
name|pktq_out_elem
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FLUSHK
parameter_list|()
value|((void)0)
end_define

begin_define
define|#
directive|define
name|NDIS_NEXT_DEV
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Internal variables/functions in Watt-32  */
end_comment

begin_decl_stmt
specifier|extern
name|WORD
name|_pktdevclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|BOOL
name|_eth_is_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_w32_dynamic_host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_watt_do_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_watt_is_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_w32__bootp_on
decl_stmt|,
name|_w32__dhcp_on
decl_stmt|,
name|_w32__rarp_on
decl_stmt|,
name|_w32__do_mask_req
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|_w32_usr_post_init
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|_w32_print_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dbug_write
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Watt-32 lib, pcdbug.c */
end_comment

begin_function_decl
specifier|extern
name|int
name|pkt_get_mtu
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ref_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|mac_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|filter_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|BOOL
name|exc_occured
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|device
modifier|*
name|handle_to_device
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pcap_activate_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_read_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcap_cleanup_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_stats_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_sendpacket_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setfilter_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ndis_probe
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pkt_probe
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|close_driver
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_watt32
parameter_list|(
name|struct
name|pcap
modifier|*
name|pcap
parameter_list|,
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|,
name|char
modifier|*
name|err_buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|first_init
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|,
name|int
name|promisc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|watt32_recv_hook
parameter_list|(
name|u_char
modifier|*
name|dummy
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|pcap
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These are the device we always support  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|device
name|ndis_dev
init|=
block|{
literal|"ndis"
block|,
literal|"NDIS2 LanManager"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NDIS_NEXT_DEV
block|,
comment|/* NULL or a 32-bit device */
name|ndis_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|device
name|pkt_dev
init|=
block|{
literal|"pkt"
block|,
literal|"Packet-Driver"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|ndis_dev
block|,
name|pkt_probe
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|device
modifier|*
name|get_device
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|fd
operator|<=
literal|0
operator|||
name|fd
operator|>=
sizeof|sizeof
argument_list|(
name|handle_to_device
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|handle_to_device
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|handle_to_device
index|[
name|fd
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Private data for capturing on MS-DOS.  */
end_comment

begin_struct
struct|struct
name|pcap_dos
block|{
name|void
function_decl|(
modifier|*
name|wait_proc
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* call proc while waiting */
name|struct
name|pcap_stat
name|stat
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|device
name|_U_
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_dos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|->
name|activate_op
operator|=
name|pcap_activate_dos
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open MAC-driver with name 'device_name' for live capture of  * network packets.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_activate_dos
parameter_list|(
name|pcap_t
modifier|*
name|pcap
parameter_list|)
block|{
if|if
condition|(
name|pcap
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/*      * No monitor mode on DOS.      */
return|return
operator|(
name|PCAP_ERROR_RFMON_NOTSUP
operator|)
return|;
block|}
if|if
condition|(
name|pcap
operator|->
name|snapshot
operator|<
name|ETH_MIN
operator|+
literal|8
condition|)
name|pcap
operator|->
name|snapshot
operator|=
name|ETH_MIN
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|pcap
operator|->
name|snapshot
operator|>
name|ETH_MAX
condition|)
comment|/* silently accept and truncate large MTUs */
name|pcap
operator|->
name|snapshot
operator|=
name|ETH_MAX
expr_stmt|;
name|pcap
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
comment|/* !! */
name|pcap
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_dos
expr_stmt|;
name|pcap
operator|->
name|read_op
operator|=
name|pcap_read_dos
expr_stmt|;
name|pcap
operator|->
name|stats_op
operator|=
name|pcap_stats_dos
expr_stmt|;
name|pcap
operator|->
name|inject_op
operator|=
name|pcap_sendpacket_dos
expr_stmt|;
name|pcap
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_dos
expr_stmt|;
name|pcap
operator|->
name|setdirection_op
operator|=
name|NULL
expr_stmt|;
comment|/* Not implemented.*/
name|pcap
operator|->
name|fd
operator|=
operator|++
name|ref_count
expr_stmt|;
name|pcap
operator|->
name|bufsize
operator|=
name|ETH_MAX
operator|+
literal|100
expr_stmt|;
comment|/* add some margin */
name|pcap
operator|->
name|buffer
operator|=
name|calloc
argument_list|(
name|pcap
operator|->
name|bufsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap
operator|->
name|fd
operator|==
literal|1
condition|)
comment|/* first time we're called */
block|{
if|if
condition|(
operator|!
name|init_watt32
argument_list|(
name|pcap
argument_list|,
name|pcap
operator|->
name|opt
operator|.
name|device
argument_list|,
name|pcap
operator|->
name|errbuf
argument_list|)
operator|||
operator|!
name|first_init
argument_list|(
name|pcap
operator|->
name|opt
operator|.
name|device
argument_list|,
name|pcap
operator|->
name|errbuf
argument_list|,
name|pcap
operator|->
name|opt
operator|.
name|promisc
argument_list|)
condition|)
block|{
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|atexit
argument_list|(
name|close_driver
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|active_dev
operator|->
name|name
argument_list|,
name|pcap
operator|->
name|opt
operator|.
name|device
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|pcap
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Cannot use different devices simultaneously "
literal|"(`%s' vs. `%s')"
argument_list|,
name|active_dev
operator|->
name|name
argument_list|,
name|pcap
operator|->
name|opt
operator|.
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|handle_to_device
index|[
name|pcap
operator|->
name|fd
operator|-
literal|1
index|]
operator|=
name|active_dev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Poll the receiver queue and call the pcap callback-handler  * with the packet.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_read_one
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|pcap_dos
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|expiry
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|rx_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|timeout
operator|>
literal|0
condition|)
block|{
name|gettimeofday2
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expiry
operator|.
name|tv_usec
operator|=
name|now
operator|.
name|tv_usec
operator|+
literal|1000UL
operator|*
name|p
operator|->
name|opt
operator|.
name|timeout
expr_stmt|;
name|expiry
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
while|while
condition|(
name|expiry
operator|.
name|tv_usec
operator|>=
literal|1000000L
condition|)
block|{
name|expiry
operator|.
name|tv_usec
operator|-=
literal|1000000L
expr_stmt|;
name|expiry
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|exc_occured
condition|)
block|{
specifier|volatile
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
comment|/* might be reset by sig_handler */
name|dev
operator|=
name|get_device
argument_list|(
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
break|break;
name|PCAP_ASSERT
argument_list|(
name|dev
operator|->
name|copy_rx_buf
operator|||
name|dev
operator|->
name|peek_rx_buf
argument_list|)
expr_stmt|;
name|FLUSHK
argument_list|()
expr_stmt|;
comment|/* If driver has a zero-copy receive facility, peek at the queue,      * filter it, do the callback and release the buffer.      */
if|if
condition|(
name|dev
operator|->
name|peek_rx_buf
condition|)
block|{
name|PCAP_ASSERT
argument_list|(
name|dev
operator|->
name|release_rx_buf
argument_list|)
expr_stmt|;
name|rx_len
operator|=
call|(
modifier|*
name|dev
operator|->
name|peek_rx_buf
call|)
argument_list|(
operator|&
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rx_len
operator|=
call|(
modifier|*
name|dev
operator|->
name|copy_rx_buf
call|)
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
name|p
operator|->
name|snapshot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rx_len
operator|>
literal|0
condition|)
comment|/* got a packet */
block|{
name|mac_count
operator|++
expr_stmt|;
name|FLUSHK
argument_list|()
expr_stmt|;
name|pcap
operator|.
name|caplen
operator|=
name|min
argument_list|(
name|rx_len
argument_list|,
name|p
operator|->
name|snapshot
argument_list|)
expr_stmt|;
name|pcap
operator|.
name|len
operator|=
name|rx_len
expr_stmt|;
if|if
condition|(
name|callback
operator|&&
operator|(
operator|!
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|||
name|bpf_filter
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|p
operator|->
name|buffer
argument_list|,
name|pcap
operator|.
name|len
argument_list|,
name|pcap
operator|.
name|caplen
argument_list|)
operator|)
condition|)
block|{
name|filter_count
operator|++
expr_stmt|;
comment|/* Fix-me!! Should be time of arrival. Not time of          * capture.          */
name|gettimeofday2
argument_list|(
operator|&
name|pcap
operator|.
name|ts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callback
call|)
argument_list|(
name|data
argument_list|,
operator|&
name|pcap
argument_list|,
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|release_rx_buf
condition|)
call|(
modifier|*
name|dev
operator|->
name|release_rx_buf
call|)
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_pkt_debug
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|callback
operator|==
name|watt32_recv_hook
condition|)
name|dbug_write
argument_list|(
literal|"pcap_recv_hook\n"
argument_list|)
expr_stmt|;
else|else
name|dbug_write
argument_list|(
literal|"pcap_read_op\n"
argument_list|)
expr_stmt|;
block|}
name|FLUSHK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Has "pcap_breakloop()" been called?      */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/*        * Yes - clear the flag that indicates that it        * has, and return -2 to indicate that we were        * told to break out of the loop.        */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* If not to wait for a packet or pcap_cleanup_dos() called from      * e.g. SIGINT handler, exit loop now.      */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|timeout
operator|<=
literal|0
operator|||
operator|(
specifier|volatile
name|int
operator|)
name|p
operator|->
name|fd
operator|<=
literal|0
condition|)
break|break;
name|gettimeofday2
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|expiry
argument_list|,
operator|>
argument_list|)
condition|)
break|break;
ifndef|#
directive|ifndef
name|DJGPP
name|kbhit
argument_list|()
expr_stmt|;
comment|/* a real CPU hog */
endif|#
directive|endif
if|if
condition|(
name|pd
operator|->
name|wait_proc
condition|)
call|(
modifier|*
name|pd
operator|->
name|wait_proc
call|)
argument_list|()
expr_stmt|;
comment|/* call yield func */
block|}
if|if
condition|(
name|rx_len
operator|<
literal|0
condition|)
comment|/* receive error */
block|{
name|pd
operator|->
name|stat
operator|.
name|ps_drop
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
if|if
condition|(
name|pcap_pkt_debug
operator|>
literal|1
condition|)
name|printk
argument_list|(
literal|"pkt-err %s\n"
argument_list|,
name|pktInfo
operator|.
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_read_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|num
operator|<=
name|cnt
operator|||
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|cnt
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|fd
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|rc
operator|=
name|pcap_read_one
argument_list|(
name|p
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|num
operator|++
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
break|break;
name|_w32_os_yield
argument_list|()
expr_stmt|;
comment|/* allow SIGINT generation, yield to Win95/NT */
block|}
return|return
operator|(
name|num
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return network statistics  */
end_comment

begin_function
specifier|static
name|int
name|pcap_stats_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|net_device_stats
modifier|*
name|stats
decl_stmt|;
name|struct
name|pcap_dos
modifier|*
name|pd
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
init|=
name|p
condition|?
name|get_device
argument_list|(
name|p
operator|->
name|fd
argument_list|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
block|{
name|strcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"illegal pcap handle"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dev
operator|->
name|get_stats
operator|||
operator|(
name|stats
operator|=
call|(
modifier|*
name|dev
operator|->
name|get_stats
call|)
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"device statistics not available"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|FLUSHK
argument_list|()
expr_stmt|;
name|pd
operator|=
name|p
operator|->
name|priv
expr_stmt|;
name|pd
operator|->
name|stat
operator|.
name|ps_recv
operator|=
name|stats
operator|->
name|rx_packets
expr_stmt|;
name|pd
operator|->
name|stat
operator|.
name|ps_drop
operator|+=
name|stats
operator|->
name|rx_missed_errors
expr_stmt|;
name|pd
operator|->
name|stat
operator|.
name|ps_ifdrop
operator|=
name|stats
operator|->
name|rx_dropped
operator|+
comment|/* queue full */
name|stats
operator|->
name|rx_errors
expr_stmt|;
comment|/* HW errors */
if|if
condition|(
name|ps
condition|)
operator|*
name|ps
operator|=
name|pd
operator|->
name|stat
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return detailed network/device statistics.  * May be called after 'dev->close' is called.  */
end_comment

begin_function
name|int
name|pcap_stats_ex
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat_ex
modifier|*
name|se
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|dev
init|=
name|p
condition|?
name|get_device
argument_list|(
name|p
operator|->
name|fd
argument_list|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|||
operator|!
name|dev
operator|->
name|get_stats
condition|)
block|{
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"detailed device statistics not available"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|strnicmp
argument_list|(
name|dev
operator|->
name|name
argument_list|,
literal|"pkt"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"pktdrvr doesn't have detailed statistics"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|se
argument_list|,
call|(
modifier|*
name|dev
operator|->
name|get_stats
call|)
argument_list|(
name|dev
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|se
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simply store the filter-code for the pcap_read_dos() callback  * Some day the filter-code could be handed down to the active  * device (pkt_rx1.s or 32-bit device interrupt handler).  */
end_comment

begin_function
specifier|static
name|int
name|pcap_setfilter_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|->
name|fcode
operator|=
operator|*
name|fp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return # of packets received in pcap_read_dos()  */
end_comment

begin_function
name|u_long
name|pcap_mac_packets
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mac_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return # of packets passed through filter in pcap_read_dos()  */
end_comment

begin_function
name|u_long
name|pcap_filter_packets
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|filter_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close pcap device. Not called for offline captures.  */
end_comment

begin_function
specifier|static
name|void
name|pcap_cleanup_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_dos
modifier|*
name|pd
decl_stmt|;
if|if
condition|(
operator|!
name|exc_occured
condition|)
block|{
name|pd
operator|=
name|p
operator|->
name|priv
expr_stmt|;
if|if
condition|(
name|pcap_stats
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|pd
operator|->
name|stat
operator|.
name|ps_drop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|get_device
argument_list|(
name|p
operator|->
name|fd
argument_list|)
condition|)
return|return;
name|handle_to_device
index|[
name|p
operator|->
name|fd
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|fd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ref_count
operator|>
literal|0
condition|)
name|ref_count
operator|--
expr_stmt|;
if|if
condition|(
name|ref_count
operator|>
literal|0
condition|)
return|return;
block|}
name|close_driver
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the name of the 1st network interface,  * or NULL if none can be found.  */
end_comment

begin_function
name|char
modifier|*
name|pcap_lookupdev
parameter_list|(
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
name|init_32bit
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|dev
operator|=
operator|(
expr|struct
name|device
operator|*
operator|)
name|dev_base
init|;
name|dev
condition|;
name|dev
operator|=
name|dev
operator|->
name|next
control|)
block|{
name|PCAP_ASSERT
argument_list|(
name|dev
operator|->
name|probe
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|dev
operator|->
name|probe
call|)
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|FLUSHK
argument_list|()
expr_stmt|;
name|probed_dev
operator|=
operator|(
expr|struct
name|device
operator|*
operator|)
name|dev
expr_stmt|;
comment|/* remember last probed device */
return|return
operator|(
name|char
operator|*
operator|)
name|dev
operator|->
name|name
return|;
block|}
block|}
if|if
condition|(
name|ebuf
condition|)
name|strcpy
argument_list|(
name|ebuf
argument_list|,
literal|"No driver found"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Gets localnet& netmask from Watt-32.  */
end_comment

begin_function
name|int
name|pcap_lookupnet
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|bpf_u_int32
modifier|*
name|localnet
parameter_list|,
name|bpf_u_int32
modifier|*
name|netmask
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|DWORD
name|mask
decl_stmt|,
name|net
decl_stmt|;
if|if
condition|(
operator|!
name|_watt_is_init
condition|)
block|{
name|strcpy
argument_list|(
name|errbuf
argument_list|,
literal|"pcap_open_offline() or pcap_activate() must be "
literal|"called first"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mask
operator|=
name|_w32_sin_mask
expr_stmt|;
name|net
operator|=
name|my_ip_addr
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|net
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IN_CLASSA
argument_list|(
operator|*
name|netmask
argument_list|)
condition|)
name|net
operator|=
name|IN_CLASSA_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
operator|*
name|netmask
argument_list|)
condition|)
name|net
operator|=
name|IN_CLASSB_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSC
argument_list|(
operator|*
name|netmask
argument_list|)
condition|)
name|net
operator|=
name|IN_CLASSC_NET
expr_stmt|;
else|else
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"inet class for 0x%lx unknown"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|localnet
operator|=
name|htonl
argument_list|(
name|net
argument_list|)
expr_stmt|;
operator|*
name|netmask
operator|=
name|htonl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a list of all interfaces that are present and that we probe okay.  * Returns -1 on error, 0 otherwise.  * The list, as returned through "alldevsp", may be NULL if no interfaces  * were up and could be opened.  */
end_comment

begin_function
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
name|struct
name|sockaddr_in
name|sa_ll_1
decl_stmt|,
name|sa_ll_2
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|,
modifier|*
name|netmask
decl_stmt|,
modifier|*
name|broadaddr
decl_stmt|,
modifier|*
name|dstaddr
decl_stmt|;
name|pcap_if_t
modifier|*
name|devlist
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|addr_size
init|=
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
decl_stmt|;
for|for
control|(
name|dev
operator|=
operator|(
expr|struct
name|device
operator|*
operator|)
name|dev_base
init|;
name|dev
condition|;
name|dev
operator|=
name|dev
operator|->
name|next
control|)
block|{
name|PCAP_ASSERT
argument_list|(
name|dev
operator|->
name|probe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|dev
operator|->
name|probe
call|)
argument_list|(
name|dev
argument_list|)
condition|)
continue|continue;
name|PCAP_ASSERT
argument_list|(
name|dev
operator|->
name|close
argument_list|)
expr_stmt|;
comment|/* set by probe routine */
name|FLUSHK
argument_list|()
expr_stmt|;
call|(
modifier|*
name|dev
operator|->
name|close
call|)
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sa_ll_1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_ll_1
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sa_ll_2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_ll_2
argument_list|)
argument_list|)
expr_stmt|;
name|sa_ll_1
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sa_ll_2
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_ll_1
expr_stmt|;
name|netmask
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_ll_1
expr_stmt|;
name|dstaddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_ll_1
expr_stmt|;
name|broadaddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_ll_2
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sa_ll_2
operator|.
name|sin_addr
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_ll_2
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_add_if
argument_list|(
operator|&
name|devlist
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|dev
operator|->
name|flags
argument_list|,
name|dev
operator|->
name|long_name
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
comment|/* Pkt drivers should have no addresses */
block|if (add_addr_to_iflist(&devlist, dev->name, dev->flags, addr, addr_size,                            netmask, addr_size, broadaddr, addr_size,                            dstaddr, addr_size, errbuf)< 0)     {       ret = -1;       break;     }
endif|#
directive|endif
block|}
if|if
condition|(
name|devlist
operator|&&
name|ret
operator|<
literal|0
condition|)
block|{
name|pcap_freealldevs
argument_list|(
name|devlist
argument_list|)
expr_stmt|;
name|devlist
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|devlist
condition|)
name|strcpy
argument_list|(
name|errbuf
argument_list|,
literal|"No drivers found"
argument_list|)
expr_stmt|;
operator|*
name|alldevsp
operator|=
name|devlist
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pcap_assert() is mainly used for debugging  */
end_comment

begin_function
name|void
name|pcap_assert
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|line
parameter_list|)
block|{
name|FLUSHK
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (%u): Assertion \"%s\" failed\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|close_driver
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For pcap_offline_read(): wait and yield between printing packets  * to simulate the pace packets where actually recorded.  */
end_comment

begin_function
name|void
name|pcap_set_wait
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|yield
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
if|if
condition|(
name|p
condition|)
block|{
name|struct
name|pcap_dos
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|pd
operator|->
name|wait_proc
operator|=
name|yield
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|timeout
operator|=
name|wait
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialise a named network device.  */
end_comment

begin_function
specifier|static
name|struct
name|device
modifier|*
name|open_driver
parameter_list|(
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|,
name|int
name|promisc
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
for|for
control|(
name|dev
operator|=
operator|(
expr|struct
name|device
operator|*
operator|)
name|dev_base
init|;
name|dev
condition|;
name|dev
operator|=
name|dev
operator|->
name|next
control|)
block|{
name|PCAP_ASSERT
argument_list|(
name|dev
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dev_name
argument_list|,
name|dev
operator|->
name|name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|probed_dev
condition|)
comment|/* user didn't call pcap_lookupdev() first */
block|{
name|PCAP_ASSERT
argument_list|(
name|dev
operator|->
name|probe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|dev
operator|->
name|probe
call|)
argument_list|(
name|dev
argument_list|)
condition|)
comment|/* call the xx_probe() function */
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"failed to detect device `%s'"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|probed_dev
operator|=
name|dev
expr_stmt|;
comment|/* device is probed okay and may be used */
block|}
elseif|else
if|if
condition|(
name|dev
operator|!=
name|probed_dev
condition|)
block|{
goto|goto
name|not_probed
goto|;
block|}
name|FLUSHK
argument_list|()
expr_stmt|;
comment|/* Select what traffic to receive      */
if|if
condition|(
name|promisc
condition|)
name|dev
operator|->
name|flags
operator||=
operator|(
name|IFF_ALLMULTI
operator||
name|IFF_PROMISC
operator|)
expr_stmt|;
else|else
name|dev
operator|->
name|flags
operator|&=
operator|~
operator|(
name|IFF_ALLMULTI
operator||
name|IFF_PROMISC
operator|)
expr_stmt|;
name|PCAP_ASSERT
argument_list|(
name|dev
operator|->
name|open
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|dev
operator|->
name|open
call|)
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"failed to activate device `%s'"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktInfo
operator|.
name|error
operator|&&
operator|!
name|strncmp
argument_list|(
name|dev
operator|->
name|name
argument_list|,
literal|"pkt"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|ebuf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ebuf
argument_list|,
name|pktInfo
operator|.
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Some devices need this to operate in promiscous mode      */
if|if
condition|(
name|promisc
operator|&&
name|dev
operator|->
name|set_multicast_list
condition|)
call|(
modifier|*
name|dev
operator|->
name|set_multicast_list
call|)
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|active_dev
operator|=
name|dev
expr_stmt|;
comment|/* remember our active device */
break|break;
block|}
comment|/* 'dev_name' not matched in 'dev_base' list.    */
if|if
condition|(
operator|!
name|dev
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"device `%s' not supported"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|not_probed
label|:
if|if
condition|(
operator|!
name|probed_dev
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"device `%s' not probed"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deinitialise MAC driver.  * Set receive mode back to default mode.  */
end_comment

begin_function
specifier|static
name|void
name|close_driver
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* !!todo: loop over all 'handle_to_device[]' ? */
name|struct
name|device
modifier|*
name|dev
init|=
name|active_dev
decl_stmt|;
if|if
condition|(
name|dev
operator|&&
name|dev
operator|->
name|close
condition|)
block|{
call|(
modifier|*
name|dev
operator|->
name|close
call|)
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|FLUSHK
argument_list|()
expr_stmt|;
block|}
name|active_dev
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
if|if
condition|(
name|rx_pool
condition|)
block|{
name|k_free
argument_list|(
name|rx_pool
argument_list|)
expr_stmt|;
name|rx_pool
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dev
condition|)
name|pcibios_exit
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__DJGPP__
end_ifdef

begin_function
specifier|static
name|void
name|setup_signals
parameter_list|(
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|exc_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
if|if
condition|(
name|active_dev
operator|->
name|irq
operator|>
literal|0
condition|)
comment|/* excludes IRQ 0 */
block|{
name|disable_irq
argument_list|(
name|active_dev
operator|->
name|irq
argument_list|)
expr_stmt|;
name|irq_eoi_cmd
argument_list|(
name|active_dev
operator|->
name|irq
argument_list|)
expr_stmt|;
name|_printk_safe
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|SIGSEGV
case|:
name|fputs
argument_list|(
literal|"Catching SIGSEGV.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGILL
case|:
name|fputs
argument_list|(
literal|"Catching SIGILL.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGFPE
case|:
name|_fpreset
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"Catching SIGFPE.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Catching signal %d.\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
name|exc_occured
operator|=
literal|1
expr_stmt|;
name|close_driver
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __DJGPP__ */
end_comment

begin_comment
comment|/*  * Open the pcap device for the first client calling pcap_activate()  */
end_comment

begin_function
specifier|static
name|int
name|first_init
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|,
name|int
name|promisc
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
name|rx_pool
operator|=
name|k_calloc
argument_list|(
name|RECEIVE_BUF_SIZE
argument_list|,
name|RECEIVE_QUEUE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rx_pool
condition|)
block|{
name|strcpy
argument_list|(
name|ebuf
argument_list|,
literal|"Not enough memory (Rx pool)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__DJGPP__
name|setup_signals
argument_list|(
name|exc_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
name|init_32bit
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dev
operator|=
name|open_driver
argument_list|(
name|name
argument_list|,
name|ebuf
argument_list|,
name|promisc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
name|k_free
argument_list|(
name|rx_pool
argument_list|)
expr_stmt|;
name|rx_pool
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__DJGPP__
name|setup_signals
argument_list|(
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
comment|/*    * If driver is NOT a 16-bit "pkt/ndis" driver (having a 'copy_rx_buf'    * set in it's probe handler), initialise near-memory ring-buffer for    * the 32-bit device.    */
if|if
condition|(
name|dev
operator|->
name|copy_rx_buf
operator|==
name|NULL
condition|)
block|{
name|dev
operator|->
name|get_rx_buf
operator|=
name|get_rxbuf
expr_stmt|;
name|dev
operator|->
name|peek_rx_buf
operator|=
name|peek_rxbuf
expr_stmt|;
name|dev
operator|->
name|release_rx_buf
operator|=
name|release_rxbuf
expr_stmt|;
name|pktq_init
argument_list|(
operator|&
name|dev
operator|->
name|queue
argument_list|,
name|RECEIVE_BUF_SIZE
argument_list|,
name|RECEIVE_QUEUE_SIZE
argument_list|,
name|rx_pool
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
end_ifdef

begin_function
specifier|static
name|void
name|init_32bit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|init_pci
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|_printk_file
condition|)
name|_printk_init
argument_list|(
literal|64
operator|*
literal|1024
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* calls atexit(printk_exit) */
if|if
condition|(
operator|!
name|init_pci
condition|)
operator|(
name|void
operator|)
name|pci_init
argument_list|()
expr_stmt|;
comment|/* init BIOS32+PCI interface */
name|init_pci
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hook functions for using Watt-32 together with pcap  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rxbuf
index|[
name|ETH_MAX
operator|+
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rx-buffer with some margin */
end_comment

begin_decl_stmt
specifier|static
name|WORD
name|etype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcap_t
name|pcap_save
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|watt32_recv_hook
parameter_list|(
name|u_char
modifier|*
name|dummy
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|pcap
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
comment|/* Fix me: assumes Ethernet II only */
name|struct
name|ether_header
modifier|*
name|ep
init|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|buf
decl_stmt|;
name|memcpy
argument_list|(
name|rxbuf
argument_list|,
name|buf
argument_list|,
name|pcap
operator|->
name|caplen
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ep
operator|->
name|ether_type
expr_stmt|;
name|ARGSUSED
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|WATTCP_VER
operator|>=
literal|0x0224
operator|)
end_if

begin_comment
comment|/*  * This function is used by Watt-32 to poll for a packet.  * i.e. it's set to bypass _eth_arrived()  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|pcap_recv_hook
parameter_list|(
name|WORD
modifier|*
name|type
parameter_list|)
block|{
name|int
name|len
init|=
name|pcap_read_dos
argument_list|(
operator|&
name|pcap_save
argument_list|,
literal|1
argument_list|,
name|watt32_recv_hook
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|type
operator|=
name|etype
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|rxbuf
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called by Watt-32 (via _eth_xmit_hook).  * If dbug_init() was called, we should trace packets sent.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_xmit_hook
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcap_pkt_debug
operator|>
literal|0
condition|)
name|dbug_write
argument_list|(
literal|"pcap_xmit_hook: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_dev
operator|&&
name|active_dev
operator|->
name|xmit
condition|)
if|if
condition|(
call|(
modifier|*
name|active_dev
operator|->
name|xmit
call|)
argument_list|(
name|active_dev
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|>
literal|0
condition|)
name|rc
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|pcap_pkt_debug
operator|>
literal|0
condition|)
name|dbug_write
argument_list|(
name|rc
condition|?
literal|"ok\n"
else|:
literal|"fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pcap_sendpacket_dos
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|dev
init|=
name|p
condition|?
name|get_device
argument_list|(
name|p
operator|->
name|fd
argument_list|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|||
operator|!
name|dev
operator|->
name|xmit
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
call|(
modifier|*
name|dev
operator|->
name|xmit
call|)
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called by Watt-32 in tcp_post_init().  * We should prevent Watt-32 from using BOOTP/DHCP/RARP etc.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|prev_post_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|pcap_init_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|_w32__bootp_on
operator|=
name|_w32__dhcp_on
operator|=
name|_w32__rarp_on
operator|=
literal|0
expr_stmt|;
name|_w32__do_mask_req
operator|=
literal|0
expr_stmt|;
name|_w32_dynamic_host
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prev_post_hook
condition|)
call|(
modifier|*
name|prev_post_hook
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Supress PRINT message from Watt-32's sock_init()  */
end_comment

begin_function
specifier|static
name|void
name|null_print
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_comment
comment|/*  * To use features of Watt-32 (netdb functions and socket etc.)  * we must call sock_init(). But we set various hooks to prevent  * using normal PKTDRVR functions in pcpkt.c. This should hopefully  * make Watt-32 and pcap co-operate.  */
end_comment

begin_function
specifier|static
name|int
name|init_watt32
parameter_list|(
name|struct
name|pcap
modifier|*
name|pcap
parameter_list|,
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|,
name|char
modifier|*
name|err_buf
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|MTU
decl_stmt|,
name|has_ip_addr
decl_stmt|;
name|int
name|using_pktdrv
init|=
literal|1
decl_stmt|;
comment|/* If user called sock_init() first, we need to reinit in    * order to open debug/trace-file properly    */
if|if
condition|(
name|_watt_is_init
condition|)
name|sock_exit
argument_list|()
expr_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"PCAP_TRACE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|&&
name|atoi
argument_list|(
name|env
argument_list|)
operator|>
literal|0
operator|&&
name|pcap_pkt_debug
operator|<
literal|0
condition|)
comment|/* if not already set */
block|{
name|dbug_init
argument_list|()
expr_stmt|;
name|pcap_pkt_debug
operator|=
name|atoi
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
name|_watt_do_exit
operator|=
literal|0
expr_stmt|;
comment|/* prevent sock_init() calling exit() */
name|prev_post_hook
operator|=
name|_w32_usr_post_init
expr_stmt|;
name|_w32_usr_post_init
operator|=
name|pcap_init_hook
expr_stmt|;
name|_w32_print_hook
operator|=
name|null_print
expr_stmt|;
if|if
condition|(
name|dev_name
operator|&&
name|strncmp
argument_list|(
name|dev_name
argument_list|,
literal|"pkt"
argument_list|,
literal|3
argument_list|)
condition|)
name|using_pktdrv
operator|=
name|FALSE
expr_stmt|;
name|rc
operator|=
name|sock_init
argument_list|()
expr_stmt|;
name|has_ip_addr
operator|=
operator|(
name|rc
operator|!=
literal|8
operator|)
expr_stmt|;
comment|/* IP-address assignment failed */
comment|/* if pcap is using a 32-bit driver w/o a pktdrvr loaded, we    * just pretend Watt-32 is initialised okay.    *    * !! fix-me: The Watt-32 config isn't done if no pktdrvr    *            was found. In that case my_ip_addr + sin_mask    *            have default values. Should be taken from another    *            ini-file/environment in any case (ref. tcpdump.ini)    */
name|_watt_is_init
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|using_pktdrv
operator|||
operator|!
name|has_ip_addr
condition|)
comment|/* for now .... */
block|{
specifier|static
specifier|const
name|char
name|myip
index|[]
init|=
literal|"192.168.0.1"
decl_stmt|;
specifier|static
specifier|const
name|char
name|mask
index|[]
init|=
literal|"255.255.255.0"
decl_stmt|;
name|printf
argument_list|(
literal|"Just guessing, using IP %s and netmask %s\n"
argument_list|,
name|myip
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|my_ip_addr
operator|=
name|aton
argument_list|(
name|myip
argument_list|)
expr_stmt|;
name|_w32_sin_mask
operator|=
name|aton
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|&&
name|using_pktdrv
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|err_buf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"sock_init() failed, code %d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Set recv-hook for peeking in _eth_arrived().    */
if|#
directive|if
operator|(
name|WATTCP_VER
operator|>=
literal|0x0224
operator|)
name|_eth_recv_hook
operator|=
name|pcap_recv_hook
expr_stmt|;
name|_eth_xmit_hook
operator|=
name|pcap_xmit_hook
expr_stmt|;
endif|#
directive|endif
comment|/* Free the pkt-drvr handle allocated in pkt_init().    * The above hooks should thus use the handle reopened in open_driver()    */
if|if
condition|(
name|using_pktdrv
condition|)
block|{
name|_eth_release
argument_list|()
expr_stmt|;
comment|/*  _eth_is_init = 1; */
comment|/* hack to get Rx/Tx-hooks in Watt-32 working */
block|}
name|memcpy
argument_list|(
operator|&
name|pcap_save
argument_list|,
name|pcap
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap_save
argument_list|)
argument_list|)
expr_stmt|;
name|MTU
operator|=
name|pkt_get_mtu
argument_list|()
expr_stmt|;
name|pcap_save
operator|.
name|fcode
operator|.
name|bf_insns
operator|=
name|NULL
expr_stmt|;
name|pcap_save
operator|.
name|linktype
operator|=
name|_eth_get_hwtype
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pcap_save
operator|.
name|snapshot
operator|=
name|MTU
operator|>
literal|0
condition|?
name|MTU
else|:
name|ETH_MAX
expr_stmt|;
comment|/* assume 1514 */
if|#
directive|if
literal|1
comment|/* prevent use of resolve() and resolve_ip()    */
name|last_nameserver
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|EISA_bus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where is natural place for this? */
end_comment

begin_comment
comment|/*  * Application config hooks to set various driver parameters.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|config_table
name|debug_tab
index|[]
init|=
block|{
block|{
literal|"PKT.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|pcap_pkt_debug
block|}
block|,
block|{
literal|"PKT.VECTOR"
block|,
name|ARG_ATOX_W
block|,
name|NULL
block|}
block|,
block|{
literal|"NDIS.DEBUG"
block|,
name|ARG_ATOI
block|,
name|NULL
block|}
block|,
ifdef|#
directive|ifdef
name|USE_32BIT_DRIVERS
block|{
literal|"3C503.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|ei_debug
block|}
block|,
block|{
literal|"3C503.IO_BASE"
block|,
name|ARG_ATOX_W
block|,
operator|&
name|el2_dev
operator|.
name|base_addr
block|}
block|,
block|{
literal|"3C503.MEMORY"
block|,
name|ARG_ATOX_W
block|,
operator|&
name|el2_dev
operator|.
name|mem_start
block|}
block|,
block|{
literal|"3C503.IRQ"
block|,
name|ARG_ATOI
block|,
operator|&
name|el2_dev
operator|.
name|irq
block|}
block|,
block|{
literal|"3C505.DEBUG"
block|,
name|ARG_ATOI
block|,
name|NULL
block|}
block|,
block|{
literal|"3C505.BASE"
block|,
name|ARG_ATOX_W
block|,
name|NULL
block|}
block|,
block|{
literal|"3C507.DEBUG"
block|,
name|ARG_ATOI
block|,
name|NULL
block|}
block|,
block|{
literal|"3C509.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|el3_debug
block|}
block|,
block|{
literal|"3C509.ILOOP"
block|,
name|ARG_ATOI
block|,
operator|&
name|el3_max_loop
block|}
block|,
block|{
literal|"3C529.DEBUG"
block|,
name|ARG_ATOI
block|,
name|NULL
block|}
block|,
block|{
literal|"3C575.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|debug_3c575
block|}
block|,
block|{
literal|"3C59X.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|vortex_debug
block|}
block|,
block|{
literal|"3C59X.IFACE0"
block|,
name|ARG_ATOI
block|,
operator|&
name|vortex_options
index|[
literal|0
index|]
block|}
block|,
block|{
literal|"3C59X.IFACE1"
block|,
name|ARG_ATOI
block|,
operator|&
name|vortex_options
index|[
literal|1
index|]
block|}
block|,
block|{
literal|"3C59X.IFACE2"
block|,
name|ARG_ATOI
block|,
operator|&
name|vortex_options
index|[
literal|2
index|]
block|}
block|,
block|{
literal|"3C59X.IFACE3"
block|,
name|ARG_ATOI
block|,
operator|&
name|vortex_options
index|[
literal|3
index|]
block|}
block|,
block|{
literal|"3C90X.DEBUG"
block|,
name|ARG_ATOX_W
block|,
operator|&
name|tc90xbc_debug
block|}
block|,
block|{
literal|"ACCT.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|ethpk_debug
block|}
block|,
block|{
literal|"CS89.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|cs89_debug
block|}
block|,
block|{
literal|"RTL8139.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|rtl8139_debug
block|}
block|,
comment|/*  { "RTL8139.FDUPLEX", ARG_ATOI,&rtl8139_options   }, */
block|{
literal|"SMC.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|ei_debug
block|}
block|,
comment|/*  { "E100.DEBUG",      ARG_ATOI,&e100_debug        }, */
block|{
literal|"PCI.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|pci_debug
block|}
block|,
block|{
literal|"BIOS32.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|bios32_debug
block|}
block|,
block|{
literal|"IRQ.DEBUG"
block|,
name|ARG_ATOI
block|,
operator|&
name|irq_debug
block|}
block|,
block|{
literal|"TIMER.IRQ"
block|,
name|ARG_ATOI
block|,
operator|&
name|timer_irq
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pcap_config_hook() is an extension to application's config  * handling. Uses Watt-32's config-table function.  */
end_comment

begin_function
name|int
name|pcap_config_hook
parameter_list|(
specifier|const
name|char
modifier|*
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
return|return
name|parse_config_table
argument_list|(
name|debug_tab
argument_list|,
name|NULL
argument_list|,
name|keyword
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Linked list of supported devices  */
end_comment

begin_decl_stmt
name|struct
name|device
modifier|*
name|active_dev
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the device we have opened */
end_comment

begin_decl_stmt
name|struct
name|device
modifier|*
name|probed_dev
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the device we have probed */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|device
modifier|*
name|dev_base
init|=
operator|&
name|pkt_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of network devices */
end_comment

begin_comment
comment|/*  * PKTDRVR device functions  */
end_comment

begin_decl_stmt
name|int
name|pcap_pkt_debug
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pkt_close
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|BOOL
name|okay
init|=
name|PktExitDriver
argument_list|()
decl_stmt|;
if|if
condition|(
name|pcap_pkt_debug
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pkt_close(): %d\n"
argument_list|,
name|okay
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|priv
condition|)
name|free
argument_list|(
name|dev
operator|->
name|priv
argument_list|)
expr_stmt|;
name|dev
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pkt_open
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|PKT_RX_MODE
name|mode
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|IFF_PROMISC
condition|)
name|mode
operator|=
name|PDRX_ALL_PACKETS
expr_stmt|;
else|else
name|mode
operator|=
name|PDRX_BROADCAST
expr_stmt|;
if|if
condition|(
operator|!
name|PktInitDriver
argument_list|(
name|mode
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|PktResetStatistics
argument_list|(
name|pktInfo
operator|.
name|handle
argument_list|)
expr_stmt|;
name|PktQueueBusy
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pkt_xmit
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|net_device_stats
modifier|*
name|stats
init|=
operator|(
expr|struct
name|net_device_stats
operator|*
operator|)
name|dev
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|pcap_pkt_debug
operator|>
literal|0
condition|)
name|dbug_write
argument_list|(
literal|"pcap_xmit\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PktTransmit
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|stats
operator|->
name|tx_errors
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|pkt_stats
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|net_device_stats
modifier|*
name|stats
init|=
operator|(
expr|struct
name|net_device_stats
operator|*
operator|)
name|dev
operator|->
name|priv
decl_stmt|;
if|if
condition|(
operator|!
name|stats
operator|||
operator|!
name|PktSessStatistics
argument_list|(
name|pktInfo
operator|.
name|handle
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|stats
operator|->
name|rx_packets
operator|=
name|pktStat
operator|.
name|inPackets
expr_stmt|;
name|stats
operator|->
name|rx_errors
operator|=
name|pktStat
operator|.
name|lost
expr_stmt|;
name|stats
operator|->
name|rx_missed_errors
operator|=
name|PktRxDropped
argument_list|()
expr_stmt|;
return|return
operator|(
name|stats
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pkt_probe
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PktSearchDriver
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dev
operator|->
name|open
operator|=
name|pkt_open
expr_stmt|;
name|dev
operator|->
name|xmit
operator|=
name|pkt_xmit
expr_stmt|;
name|dev
operator|->
name|close
operator|=
name|pkt_close
expr_stmt|;
name|dev
operator|->
name|get_stats
operator|=
name|pkt_stats
expr_stmt|;
name|dev
operator|->
name|copy_rx_buf
operator|=
name|PktReceive
expr_stmt|;
comment|/* farmem peek and copy routine */
name|dev
operator|->
name|get_rx_buf
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|peek_rx_buf
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|release_rx_buf
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|priv
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|net_device_stats
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|priv
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NDIS device functions  */
end_comment

begin_function
specifier|static
name|void
name|ndis_close
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_NDIS2
name|NdisShutdown
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ARGSUSED
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ndis_open
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|promis
init|=
operator|(
name|dev
operator|->
name|flags
operator|&
name|IFF_PROMISC
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_NDIS2
if|if
condition|(
operator|!
name|NdisInit
argument_list|(
name|promis
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
name|ARGSUSED
argument_list|(
name|promis
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ndis_stats
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
specifier|static
name|struct
name|net_device_stats
name|stats
decl_stmt|;
comment|/* to-do */
name|ARGSUSED
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|stats
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ndis_probe
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_NDIS2
if|if
condition|(
operator|!
name|NdisOpen
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|dev
operator|->
name|open
operator|=
name|ndis_open
expr_stmt|;
name|dev
operator|->
name|xmit
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|close
operator|=
name|ndis_close
expr_stmt|;
name|dev
operator|->
name|get_stats
operator|=
name|ndis_stats
expr_stmt|;
name|dev
operator|->
name|copy_rx_buf
operator|=
name|NULL
expr_stmt|;
comment|/* to-do */
name|dev
operator|->
name|get_rx_buf
operator|=
name|NULL
expr_stmt|;
comment|/* upcall is from rmode driver */
name|dev
operator|->
name|peek_rx_buf
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|release_rx_buf
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search& probe for supported 32-bit (pmode) pcap devices  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_32BIT_DRIVERS
argument_list|)
end_if

begin_decl_stmt
name|struct
name|device
name|el2_dev
name|LOCKED_VAR
init|=
block|{
literal|"3c503"
block|,
literal|"EtherLink II"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|el2_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|device
name|el3_dev
name|LOCKED_VAR
init|=
block|{
literal|"3c509"
block|,
literal|"EtherLink III"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|el2_dev
block|,
name|el3_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|device
name|tc515_dev
name|LOCKED_VAR
init|=
block|{
literal|"3c515"
block|,
literal|"EtherLink PCI"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|el3_dev
block|,
name|tc515_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|device
name|tc59_dev
name|LOCKED_VAR
init|=
block|{
literal|"3c59x"
block|,
literal|"EtherLink PCI"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|tc515_dev
block|,
name|tc59x_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|device
name|tc90xbc_dev
name|LOCKED_VAR
init|=
block|{
literal|"3c90x"
block|,
literal|"EtherLink 90X"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|tc59_dev
block|,
name|tc90xbc_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|device
name|wd_dev
name|LOCKED_VAR
init|=
block|{
literal|"wd"
block|,
literal|"Westen Digital"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|tc90xbc_dev
block|,
name|wd_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|device
name|ne_dev
name|LOCKED_VAR
init|=
block|{
literal|"ne"
block|,
literal|"NEx000"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|wd_dev
block|,
name|ne_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|device
name|acct_dev
name|LOCKED_VAR
init|=
block|{
literal|"acct"
block|,
literal|"Accton EtherPocket"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|ne_dev
block|,
name|ethpk_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|device
name|cs89_dev
name|LOCKED_VAR
init|=
block|{
literal|"cs89"
block|,
literal|"Crystal Semiconductor"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|acct_dev
block|,
name|cs89x0_probe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|device
name|rtl8139_dev
name|LOCKED_VAR
init|=
block|{
literal|"rtl8139"
block|,
literal|"RealTek PCI"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|cs89_dev
block|,
name|rtl8139_probe
comment|/* dev->probe routine */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Dequeue routine is called by polling.  * NOTE: the queue-element is not copied, only a pointer is  * returned at '*buf'  */
end_comment

begin_function
name|int
name|peek_rxbuf
parameter_list|(
name|BYTE
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|rx_elem
modifier|*
name|tail
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|PCAP_ASSERT
argument_list|(
name|pktq_check
argument_list|(
operator|&
name|active_dev
operator|->
name|queue
argument_list|)
argument_list|)
expr_stmt|;
name|DISABLE
argument_list|()
expr_stmt|;
name|tail
operator|=
name|pktq_out_elem
argument_list|(
operator|&
name|active_dev
operator|->
name|queue
argument_list|)
expr_stmt|;
name|head
operator|=
name|pktq_in_elem
argument_list|(
operator|&
name|active_dev
operator|->
name|queue
argument_list|)
expr_stmt|;
name|ENABLE
argument_list|()
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
name|PCAP_ASSERT
argument_list|(
name|tail
operator|->
name|size
operator|<
name|active_dev
operator|->
name|queue
operator|.
name|elem_size
operator|-
literal|4
operator|-
literal|2
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
operator|&
name|tail
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|tail
operator|->
name|size
operator|)
return|;
block|}
operator|*
name|buf
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release buffer we peeked at above.  */
end_comment

begin_function
name|int
name|release_rxbuf
parameter_list|(
name|BYTE
modifier|*
name|buf
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|struct
name|rx_elem
modifier|*
name|tail
init|=
name|pktq_out_elem
argument_list|(
operator|&
name|active_dev
operator|->
name|queue
argument_list|)
decl_stmt|;
name|PCAP_ASSERT
argument_list|(
operator|&
name|tail
operator|->
name|data
index|[
literal|0
index|]
operator|==
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|ARGSUSED
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pktq_inc_out
argument_list|(
operator|&
name|active_dev
operator|->
name|queue
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get_rxbuf() routine (in locked code) is called from IRQ handler  * to request a buffer. Interrupts are disabled and we have a 32kB stack.  */
end_comment

begin_function
name|BYTE
modifier|*
name|get_rxbuf
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|ETH_MIN
operator|||
name|len
operator|>
name|ETH_MAX
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|idx
operator|=
name|pktq_in_index
argument_list|(
operator|&
name|active_dev
operator|->
name|queue
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
specifier|static
name|int
name|fan_idx
name|LOCKED_VAR
init|=
literal|0
decl_stmt|;
name|writew
argument_list|(
literal|"-\\|/"
index|[
name|fan_idx
operator|++
index|]
operator||
operator|(
literal|15
operator|<<
literal|8
operator|)
argument_list|,
comment|/* white on black colour */
literal|0xB8000
operator|+
literal|2
operator|*
literal|79
argument_list|)
expr_stmt|;
comment|/* upper-right corner, 80-col colour screen */
name|fan_idx
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* writew (idx + '0' + 0x0F00, 0xB8000 + 2*78); */
endif|#
directive|endif
if|if
condition|(
name|idx
operator|!=
name|active_dev
operator|->
name|queue
operator|.
name|out_index
condition|)
block|{
name|struct
name|rx_elem
modifier|*
name|head
init|=
name|pktq_in_elem
argument_list|(
operator|&
name|active_dev
operator|->
name|queue
argument_list|)
decl_stmt|;
name|head
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|active_dev
operator|->
name|queue
operator|.
name|in_index
operator|=
name|idx
expr_stmt|;
return|return
operator|(
operator|&
name|head
operator|->
name|data
index|[
literal|0
index|]
operator|)
return|;
block|}
comment|/* !!to-do: drop 25% of the oldest element    */
name|pktq_clear
argument_list|(
operator|&
name|active_dev
operator|->
name|queue
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Simple ring-buffer queue handler for reception of packets  *  from network driver.  */
end_comment

begin_define
define|#
directive|define
name|PKTQ_MARKER
value|0xDEADBEEF
end_define

begin_function
specifier|static
name|int
name|pktq_check
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|q
operator|||
operator|!
name|q
operator|->
name|num_elem
operator|||
operator|!
name|q
operator|->
name|buf_start
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifndef|#
directive|ifndef
name|NDEBUG
name|buf
operator|=
name|q
operator|->
name|buf_start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|num_elem
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|+=
name|q
operator|->
name|elem_size
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|DWORD
operator|*
operator|)
operator|(
name|buf
operator|-
sizeof|sizeof
argument_list|(
name|DWORD
argument_list|)
operator|)
operator|!=
name|PKTQ_MARKER
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pktq_init
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|num
parameter_list|,
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|q
operator|->
name|elem_size
operator|=
name|size
expr_stmt|;
name|q
operator|->
name|num_elem
operator|=
name|num
expr_stmt|;
name|q
operator|->
name|buf_start
operator|=
name|pool
expr_stmt|;
name|q
operator|->
name|in_index
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|out_index
operator|=
literal|0
expr_stmt|;
name|PCAP_ASSERT
argument_list|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|rx_elem
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|DWORD
argument_list|)
argument_list|)
expr_stmt|;
name|PCAP_ASSERT
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|PCAP_ASSERT
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|struct rx_elem *elem = (struct rx_elem*) pool;
comment|/* assert dword aligned elements      */
block|PCAP_ASSERT (((unsigned)(&elem->data[0])& 3) == 0);
endif|#
directive|endif
name|pool
operator|+=
name|size
expr_stmt|;
operator|*
operator|(
name|DWORD
operator|*
operator|)
operator|(
name|pool
operator|-
sizeof|sizeof
argument_list|(
name|DWORD
argument_list|)
operator|)
operator|=
name|PKTQ_MARKER
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Increment the queue 'out_index' (tail).  * Check for wraps.  */
end_comment

begin_function
specifier|static
name|int
name|pktq_inc_out
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|)
block|{
name|q
operator|->
name|out_index
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|out_index
operator|>=
name|q
operator|->
name|num_elem
condition|)
name|q
operator|->
name|out_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|q
operator|->
name|out_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the queue's next 'in_index' (head).  * Check for wraps.  */
end_comment

begin_function
specifier|static
name|int
name|pktq_in_index
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|)
block|{
specifier|volatile
name|int
name|index
init|=
name|q
operator|->
name|in_index
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|q
operator|->
name|num_elem
condition|)
name|index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the queue's head-buffer.  */
end_comment

begin_function
specifier|static
name|struct
name|rx_elem
modifier|*
name|pktq_in_elem
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|rx_elem
operator|*
operator|)
operator|(
name|q
operator|->
name|buf_start
operator|+
operator|(
name|q
operator|->
name|elem_size
operator|*
name|q
operator|->
name|in_index
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the queue's tail-buffer.  */
end_comment

begin_function
specifier|static
name|struct
name|rx_elem
modifier|*
name|pktq_out_elem
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|rx_elem
operator|*
operator|)
operator|(
name|q
operator|->
name|buf_start
operator|+
operator|(
name|q
operator|->
name|elem_size
operator|*
name|q
operator|->
name|out_index
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the queue ring-buffer by setting head=tail.  */
end_comment

begin_function
specifier|static
name|void
name|pktq_clear
parameter_list|(
name|struct
name|rx_ringbuf
modifier|*
name|q
parameter_list|)
block|{
name|q
operator|->
name|in_index
operator|=
name|q
operator|->
name|out_index
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Symbols that must be linkable for "gcc -O0"  */
end_comment

begin_undef
undef|#
directive|undef
name|__IOPORT_H
end_undef

begin_undef
undef|#
directive|undef
name|__DMA_H
end_undef

begin_define
define|#
directive|define
name|extern
end_define

begin_define
define|#
directive|define
name|__inline__
end_define

begin_include
include|#
directive|include
file|"msdos/pm_drvr/ioport.h"
end_include

begin_include
include|#
directive|include
file|"msdos/pm_drvr/dma.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_32BIT_DRIVERS */
end_comment

end_unit

