begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 - 2005 NetGroup, Politecnico di Torino (Italy)  * Copyright (c) 2005 - 2008 CACE Technologies, Davis (California)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  * notice, this list of conditions and the following disclaimer in the  * documentation and/or other materials provided with the distribution.  * 3. Neither the name of the Politecnico di Torino, CACE Technologies  * nor the names of its contributors may be used to endorse or promote  * products derived from this software without specific prior written  * permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* for strlen(), ... */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for malloc(), free(), ... */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_comment
comment|/* for functions with variable number of arguments */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* for the errno variable */
end_comment

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"pcap-rpcap.h"
end_include

begin_include
include|#
directive|include
file|"sockutils.h"
end_include

begin_comment
comment|/*  * \file pcap-rpcap.c  *  * This file keeps all the new funtions that are needed for the RPCAP protocol.  * Almost all the pcap functions need to be modified in order to become compatible  * with the RPCAP protocol. However, you can find here only the ones that are completely new.  *  * This file keeps also the functions that are 'private', i.e. are needed by the RPCAP  * protocol but are not exported to the user.  *  * \warning All the RPCAP functions that are allowed to return a buffer containing  * the error description can return max PCAP_ERRBUF_SIZE characters.  * However there is no guarantees that the string will be zero-terminated.  * Best practice is to define the errbuf variable as a char of size 'PCAP_ERRBUF_SIZE+1'  * and to insert manually a NULL character at the end of the buffer. This will  * guarantee that no buffer overflows occur even if we use the printf() to show  * the error on the screen.  */
end_comment

begin_define
define|#
directive|define
name|PCAP_STATS_STANDARD
value|0
end_define

begin_comment
comment|/* Used by pcap_stats_remote to see if we want standard or extended statistics */
end_comment

begin_define
define|#
directive|define
name|PCAP_STATS_EX
value|1
end_define

begin_comment
comment|/* Used by pcap_stats_remote to see if we want standard or extended statistics */
end_comment

begin_comment
comment|/* Keeps a list of all the opened connections in the active mode. */
end_comment

begin_decl_stmt
name|struct
name|activehosts
modifier|*
name|activeHosts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Private data for capturing on WinPcap devices.  */
end_comment

begin_struct
struct|struct
name|pcap_win
block|{
name|int
name|nonblock
decl_stmt|;
name|int
name|rfmon_selfstart
decl_stmt|;
comment|/* a flag tells whether the monitor mode is set by itself */
name|int
name|filtering_in_kernel
decl_stmt|;
comment|/* using kernel filter */
ifdef|#
directive|ifdef
name|HAVE_DAG_API
name|int
name|dag_fcs_bits
decl_stmt|;
comment|/* Number of checksum bits from link layer */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/****************************************************  *                                                  *  * Locally defined functions                        *  *                                                  *  ****************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|rpcap_checkver
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|struct
name|rpcap_header
modifier|*
name|header
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pcap_stat
modifier|*
name|rpcap_stats_remote
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_pack_bpffilter
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|sendbuf
parameter_list|,
name|int
modifier|*
name|sendbufidx
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|prog
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_createfilter_norpcappkt
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|prog
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_updatefilter_remote
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|prog
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setfilter_remote
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|prog
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setsampling_remote
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************  *                                                  *  * Function bodies                                  *  *                                                  *  ****************************************************/
end_comment

begin_comment
comment|/*  * \ingroup remote_pri_func  *  * \brief 	It traslates (i.e. de-serializes) a 'sockaddr_storage' structure from  * the network byte order to the host byte order.  *  * It accepts a 'sockaddr_storage' structure as it is received from the network and it  * converts it into the host byte order (by means of a set of ntoh() ).  * The function will allocate the 'sockaddrout' variable according to the address family  * in use. In case the address does not belong to the AF_INET nor AF_INET6 families,  * 'sockaddrout' is not allocated and a NULL pointer is returned.  * This usually happens because that address does not exist on the other host, so the  * RPCAP daemon sent a 'sockaddr_storage' structure containing all 'zero' values.  *  * \param sockaddrin: a 'sockaddr_storage' pointer to the variable that has to be  * de-serialized.  *  * \param sockaddrout: a 'sockaddr_storage' pointer to the variable that will contain  * the de-serialized data. The structure returned can be either a 'sockaddr_in' or 'sockaddr_in6'.  * This variable will be allocated automatically inside this function.  *  * \param errbuf: a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE)  * that will contain the error message (in case there is one).  *  * \return '0' if everything is fine, '-1' if some errors occurred. Basically, the error  * can be only the fact that the malloc() failed to allocate memory.  * The error message is returned in the 'errbuf' variable, while the deserialized address  * is returned into the 'sockaddrout' variable.  *  * \warning This function supports only AF_INET and AF_INET6 address families.  *  * \warning The sockaddrout (if not NULL) must be deallocated by the user.  */
end_comment

begin_function
name|int
name|rpcap_deseraddr
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|sockaddrin
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
modifier|*
name|sockaddrout
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* Warning: we support only AF_INET and AF_INET6 */
if|if
condition|(
name|ntohs
argument_list|(
name|sockaddrin
operator|->
name|ss_family
argument_list|)
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sockaddr
decl_stmt|;
name|sockaddr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sockaddrin
expr_stmt|;
name|sockaddr
operator|->
name|sin_family
operator|=
name|ntohs
argument_list|(
name|sockaddr
operator|->
name|sin_family
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sin_port
operator|=
name|ntohs
argument_list|(
name|sockaddr
operator|->
name|sin_port
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sockaddrout
operator|)
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sockaddrout
operator|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|sockaddrout
argument_list|,
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|sockaddrin
operator|->
name|ss_family
argument_list|)
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sockaddr
decl_stmt|;
name|sockaddr
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sockaddrin
expr_stmt|;
name|sockaddr
operator|->
name|sin6_family
operator|=
name|ntohs
argument_list|(
name|sockaddr
operator|->
name|sin6_family
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sin6_port
operator|=
name|ntohs
argument_list|(
name|sockaddr
operator|->
name|sin6_port
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sin6_flowinfo
operator|=
name|ntohl
argument_list|(
name|sockaddr
operator|->
name|sin6_flowinfo
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sin6_scope_id
operator|=
name|ntohl
argument_list|(
name|sockaddr
operator|->
name|sin6_scope_id
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sockaddrout
operator|)
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sockaddrout
operator|)
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|sockaddrout
argument_list|,
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* It is neither AF_INET nor AF_INET6 */
operator|*
name|sockaddrout
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief It reads a packet from the network socket. This does not make use of  * callback (hence the "nocb" string into its name).  *  * This function is called by the several pcap_next_ex() when they detect that  * we have a remote capture and they are the client side. In that case, they need  * to read packets from the socket.  *  * Parameters and return values are exactly the same of the pcap_next_ex().  *  * \warning By choice, this function does not make use of semaphores. A smarter  * implementation should put a semaphore into the data thread, and a signal will  * be raised as soon as there is data into the socket buffer.  * However this is complicated and it does not bring any advantages when reading  * from the network, in which network delays can be much more important than  * these optimizations. Therefore, we chose the following approach:  * - the 'timeout' chosen by the user is split in two (half on the server side,  * with the usual meaning, and half on the client side)  * - this function checks for packets; if there are no packets, it waits for  * timeout/2 and then it checks again. If packets are still missing, it returns,  * otherwise it reads packets.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_read_nocb_remote
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
modifier|*
name|pkt_header
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pkt_data
parameter_list|)
block|{
name|struct
name|rpcap_header
modifier|*
name|header
decl_stmt|;
comment|/* general header according to the RPCAP format */
name|struct
name|rpcap_pkthdr
modifier|*
name|net_pkt_header
decl_stmt|;
comment|/* header of the packet */
name|char
name|netbuf
index|[
name|RPCAP_NETBUF_SIZE
index|]
decl_stmt|;
comment|/* size of the network buffer in which the packet is copied, just for UDP */
name|uint32
name|totread
decl_stmt|;
comment|/* number of bytes (of payload) currently read from the network (referred to the current pkt) */
name|int
name|nread
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* generic return value */
comment|/* Structures needed for the select() call */
name|fd_set
name|rfds
decl_stmt|;
comment|/* set of socket descriptors we have to check */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* maximum time the select() can block waiting for data */
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Define the read timeout, to be used in the select() 	 * 'timeout', in pcap_t, is in milliseconds; we have to convert it into sec and microsec 	 */
name|tv
operator|.
name|tv_sec
operator|=
name|p
operator|->
name|opt
operator|.
name|timeout
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|p
operator|->
name|opt
operator|.
name|timeout
operator|-
name|tv
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
comment|/* Watch out sockdata to see if it has input */
name|FD_ZERO
argument_list|(
operator|&
name|rfds
argument_list|)
expr_stmt|;
comment|/* 	 * 'fp->rmt_sockdata' has always to be set before calling the select(), 	 * since it is cleared by the select() 	 */
name|FD_SET
argument_list|(
name|md
operator|->
name|rmt_sockdata
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|retval
operator|=
name|select
argument_list|(
operator|(
name|int
operator|)
name|md
operator|->
name|rmt_sockdata
operator|+
literal|1
argument_list|,
operator|&
name|rfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"select(): "
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* There is no data waiting, so return '0' */
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * data is here; so, let's copy it into the user buffer. 	 * I'm going to read a new packet; so I reset the number of bytes (payload only) read 	 */
name|totread
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We have to define 'header' as a pointer to a larger buffer, 	 * because in case of UDP we have to read all the message within a single call 	 */
name|header
operator|=
operator|(
expr|struct
name|rpcap_header
operator|*
operator|)
name|netbuf
expr_stmt|;
name|net_pkt_header
operator|=
operator|(
expr|struct
name|rpcap_pkthdr
operator|*
operator|)
operator|(
name|netbuf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_DATATX_UDP
condition|)
block|{
comment|/* Read the entire message from the network */
if|if
condition|(
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockdata
argument_list|,
name|netbuf
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCK_RECEIVEALL_NO
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockdata
argument_list|,
name|netbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Checks if the message is correct */
name|retval
operator|=
name|rpcap_checkmsg
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|md
operator|->
name|rmt_sockdata
argument_list|,
name|header
argument_list|,
name|RPCAP_MSG_PACKET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|RPCAP_MSG_PACKET
condition|)
comment|/* the message is not the one expected */
block|{
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
operator|-
literal|3
case|:
comment|/* Unrecoverable network error */
return|return
operator|-
literal|1
return|;
comment|/* Do nothing; just exit from here; the error code is already into the errbuf */
case|case
operator|-
literal|2
case|:
comment|/* The other endpoint sent a message that is not allowed here */
case|case
operator|-
literal|1
case|:
comment|/* The other endpoint has a version number that is not compatible with our */
return|return
literal|0
return|;
comment|/* Return 'no packets received' */
default|default:
name|SOCK_ASSERT
argument_list|(
literal|"Internal error"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Return 'no packets received' */
block|}
block|}
comment|/* In case of TCP, read the remaining of the packet from the socket */
if|if
condition|(
operator|!
operator|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_DATATX_UDP
operator|)
condition|)
block|{
comment|/* Read the RPCAP packet header from the network */
name|nread
operator|=
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockdata
argument_list|,
operator|(
name|char
operator|*
operator|)
name|net_pkt_header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_pkthdr
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|totread
operator|+=
name|nread
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|net_pkt_header
operator|->
name|caplen
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_pkthdr
argument_list|)
operator|)
operator|<=
name|p
operator|->
name|bufsize
condition|)
block|{
comment|/* Initialize returned structures */
operator|*
name|pkt_header
operator|=
operator|(
expr|struct
name|pcap_pkthdr
operator|*
operator|)
name|p
operator|->
name|buffer
expr_stmt|;
operator|*
name|pkt_data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|buffer
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_pkthdr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pkt_header
operator|)
operator|->
name|caplen
operator|=
name|ntohl
argument_list|(
name|net_pkt_header
operator|->
name|caplen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pkt_header
operator|)
operator|->
name|len
operator|=
name|ntohl
argument_list|(
name|net_pkt_header
operator|->
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pkt_header
operator|)
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|ntohl
argument_list|(
name|net_pkt_header
operator|->
name|timestamp_sec
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pkt_header
operator|)
operator|->
name|ts
operator|.
name|tv_usec
operator|=
name|ntohl
argument_list|(
name|net_pkt_header
operator|->
name|timestamp_usec
argument_list|)
expr_stmt|;
comment|/* 		 * I don't update the counter of the packets dropped by the network since we're using TCP, 		 * therefore no packets are dropped. Just update the number of packets received correctly 		 */
name|md
operator|->
name|TotCapt
operator|++
expr_stmt|;
comment|/* Copies the packet into the data buffer */
if|if
condition|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_DATATX_UDP
condition|)
block|{
name|unsigned
name|int
name|npkt
decl_stmt|;
comment|/* 			 * In case of UDP the packet has already been read, we have to copy it into 'buffer'. 			 * Another option should be to declare 'netbuf' as 'static'. However this prevents 			 * using several pcap instances within the same process (because the static buffer is shared among 			 * all processes) 			 */
name|memcpy
argument_list|(
operator|*
name|pkt_data
argument_list|,
name|netbuf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_pkthdr
argument_list|)
argument_list|,
operator|(
operator|*
name|pkt_header
operator|)
operator|->
name|caplen
argument_list|)
expr_stmt|;
comment|/* We're using UDP, so we need to update the counter of the packets dropped by the network */
name|npkt
operator|=
name|ntohl
argument_list|(
name|net_pkt_header
operator|->
name|npkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|TotCapt
operator|!=
name|npkt
condition|)
block|{
name|md
operator|->
name|TotNetDrops
operator|+=
operator|(
name|npkt
operator|-
name|md
operator|->
name|TotCapt
operator|)
expr_stmt|;
name|md
operator|->
name|TotCapt
operator|=
name|npkt
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* In case of TCP, read the remaining of the packet from the socket */
name|nread
operator|=
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockdata
argument_list|,
operator|*
name|pkt_data
argument_list|,
operator|(
operator|*
name|pkt_header
operator|)
operator|->
name|caplen
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|totread
operator|+=
name|nread
expr_stmt|;
comment|/* Checks if all the data has been read; if not, discard the data in excess */
comment|/* This check has to be done only on TCP connections */
if|if
condition|(
name|totread
operator|!=
name|ntohl
argument_list|(
name|header
operator|->
name|plen
argument_list|)
condition|)
name|sock_discard
argument_list|(
name|md
operator|->
name|rmt_sockdata
argument_list|,
name|ntohl
argument_list|(
name|header
operator|->
name|plen
argument_list|)
operator|-
name|totread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Packet read successfully */
return|return
literal|1
return|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Received a packet that is larger than the internal buffer size."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief It reads a packet from the network socket.  *  * This function is called by the several pcap_read() when they detect that  * we have a remote capture and they are the client side. In that case, they need  * to read packets from the socket.  *  * This function relies on the pcap_read_nocb_remote to deliver packets. The  * difference, here, is that as soon as a packet is read, it is delivered  * to the application by means of a callback function.  *  * Parameters and return values are exactly the same of the pcap_read().  */
end_comment

begin_function
specifier|static
name|int
name|pcap_read_remote
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|pcap_pkthdr
modifier|*
name|pkt_header
decl_stmt|;
name|u_char
modifier|*
name|pkt_data
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|<
name|cnt
operator|)
operator|||
operator|(
name|cnt
operator|<
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|pcap_read_nocb_remote
argument_list|(
name|p
argument_list|,
operator|&
name|pkt_header
argument_list|,
operator|&
name|pkt_data
argument_list|)
operator|==
literal|1
condition|)
block|{
call|(
modifier|*
name|callback
call|)
argument_list|(
name|user
argument_list|,
name|pkt_header
argument_list|,
name|pkt_data
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
else|else
return|return
name|n
return|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief It sends a CLOSE command to the capture server.  *  * This function is called when the user wants to close a pcap_t adapter.  * In case we're capturing from the network, it sends a command to the other  * peer that says 'ok, let's stop capturing'.  * This function is called automatically when the user calls the pcap_close().  *  * Parameters and return values are exactly the same of the pcap_close().  *  * \warning Since we're closing the connection, we do not check for errors.  */
end_comment

begin_function
specifier|static
name|void
name|pcap_cleanup_remote
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|rpcap_header
name|header
decl_stmt|;
comment|/* header of the RPCAP packet */
name|struct
name|activehosts
modifier|*
name|temp
decl_stmt|;
comment|/* temp var needed to scan the host list chain, to detect if we're in active mode */
name|int
name|active
init|=
literal|0
decl_stmt|;
comment|/* active mode or not? */
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|fp
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
comment|/* detect if we're in active mode */
name|temp
operator|=
name|activeHosts
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|sockctrl
operator|==
name|md
operator|->
name|rmt_sockctrl
condition|)
block|{
name|active
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|rpcap_createhdr
argument_list|(
operator|&
name|header
argument_list|,
name|RPCAP_MSG_CLOSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* I don't check for errors, since I'm going to close everything */
name|sock_send
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rpcap_createhdr
argument_list|(
operator|&
name|header
argument_list|,
name|RPCAP_MSG_ENDCAP_REQ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* I don't check for errors, since I'm going to close everything */
name|sock_send
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait for the answer */
comment|/* Don't check what we got, since the present libpcap does not uses this pcap_t anymore */
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|!=
literal|0
condition|)
name|sock_discard
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|->
name|rmt_sockdata
condition|)
block|{
name|sock_close
argument_list|(
name|md
operator|->
name|rmt_sockdata
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|->
name|rmt_sockdata
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|active
operator|)
operator|&&
operator|(
name|md
operator|->
name|rmt_sockctrl
operator|)
condition|)
name|sock_close
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md
operator|->
name|rmt_sockctrl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|currentfilter
condition|)
block|{
name|free
argument_list|(
name|md
operator|->
name|currentfilter
argument_list|)
expr_stmt|;
name|md
operator|->
name|currentfilter
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* To avoid inconsistencies in the number of sock_init() */
name|sock_cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief It retrieves network statistics from the other peer.  *  * This function is just a void cointainer, since the work is done by the rpcap_stats_remote().  * See that funcion for more details.  *  * Parameters and return values are exactly the same of the pcap_stats().  */
end_comment

begin_function
specifier|static
name|int
name|pcap_stats_remote
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|pcap_stat
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|rpcap_stats_remote
argument_list|(
name|p
argument_list|,
name|ps
argument_list|,
name|PCAP_STATS_STANDARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief It retrieves network statistics from the other peer.  *  * This function is just a void cointainer, since the work is done by the rpcap_stats_remote().  * See that funcion for more details.  *  * Parameters and return values are exactly the same of the pcap_stats_ex().  */
end_comment

begin_function
specifier|static
name|struct
name|pcap_stat
modifier|*
name|pcap_stats_ex_remote
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|pcap_stat_size
parameter_list|)
block|{
operator|*
name|pcap_stat_size
operator|=
sizeof|sizeof
argument_list|(
name|p
operator|->
name|stat
argument_list|)
expr_stmt|;
comment|/* PCAP_STATS_EX (third param) means 'extended pcap_stats()' */
return|return
operator|(
name|rpcap_stats_remote
argument_list|(
name|p
argument_list|,
operator|&
operator|(
name|p
operator|->
name|stat
operator|)
argument_list|,
name|PCAP_STATS_EX
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief It retrieves network statistics from the other peer.  *  * This function can be called in two modes:  * - PCAP_STATS_STANDARD: if we want just standard statistics (i.e. the pcap_stats() )  * - PCAP_STATS_EX: if we want extended statistics (i.e. the pcap_stats_ex() )  *  * This 'mode' parameter is needed because in the standard pcap_stats() the variable that keeps the  * statistics is allocated by the user. Unfortunately, this structure has been extended in order  * to keep new stats. However, if the user has a smaller structure and it passes it to the pcap_stats,  * thid function will try to fill in more data than the size of the structure, so that the application  * goes in memory overflow.  * So, we need to know it we have to copy just the standard fields, or the extended fields as well.  *  * In case we want to copy the extended fields as well, the problem of memory overflow does no  * longer exist because the structure pcap_stat is no longer allocated by the program;  * it is allocated by the library instead.  *  * \param p: the pcap_t structure related to the current instance.  *  * \param ps: a 'pcap_stat' structure, needed for compatibility with pcap_stat(), in which  * the structure is allocated by the user. In case of pcap_stats_ex, this structure and the  * function return value point to the same variable.  *  * \param mode: one of PCAP_STATS_STANDARD or PCAP_STATS_EX.  *  * \return The structure that keeps the statistics, or NULL in case of error.  * The error string is placed in the pcap_t structure.  */
end_comment

begin_function
specifier|static
name|struct
name|pcap_stat
modifier|*
name|rpcap_stats_remote
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|rpcap_header
name|header
decl_stmt|;
comment|/* header of the RPCAP packet */
name|struct
name|rpcap_stats
name|netstats
decl_stmt|;
comment|/* statistics sent on the network */
name|uint32
name|totread
init|=
literal|0
decl_stmt|;
comment|/* number of bytes of the payload read from the socket */
name|int
name|nread
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* temp variable which stores functions return value */
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * If the capture has still to start, we cannot ask statistics to the other peer, 	 * so we return a fake number 	 */
if|if
condition|(
operator|!
name|md
operator|->
name|rmt_capstarted
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|PCAP_STATS_STANDARD
condition|)
block|{
name|ps
operator|->
name|ps_drop
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|ps_ifdrop
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|ps_recv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|->
name|ps_capt
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|ps_drop
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|ps_ifdrop
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|ps_netdrop
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|ps_recv
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|ps_sent
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ps
return|;
block|}
name|rpcap_createhdr
argument_list|(
operator|&
name|header
argument_list|,
name|RPCAP_MSG_STATS_REQ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Send the PCAP_STATS command */
if|if
condition|(
name|sock_send
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Receive the RPCAP stats reply message */
if|if
condition|(
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
comment|/* Checks if the message is correct */
name|retval
operator|=
name|rpcap_checkmsg
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|&
name|header
argument_list|,
name|RPCAP_MSG_STATS_REPLY
argument_list|,
name|RPCAP_MSG_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|RPCAP_MSG_STATS_REPLY
condition|)
comment|/* the message is not the one expected */
block|{
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
operator|-
literal|3
case|:
comment|/* Unrecoverable network error */
case|case
operator|-
literal|2
case|:
comment|/* The other endpoint send a message that is not allowed here */
case|case
operator|-
literal|1
case|:
comment|/* The other endpoint has a version number that is not compatible with our */
goto|goto
name|error
goto|;
case|case
name|RPCAP_MSG_ERROR
case|:
comment|/* The other endpoint reported an error */
comment|/* Update totread, since the rpcap_checkmsg() already purged the buffer */
name|totread
operator|=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
expr_stmt|;
comment|/* Do nothing; just exit; the error code is already into the errbuf */
goto|goto
name|error
goto|;
default|default:
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Internal error"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|nread
operator|=
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|netstats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_stats
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|totread
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|PCAP_STATS_STANDARD
condition|)
block|{
name|ps
operator|->
name|ps_drop
operator|=
name|ntohl
argument_list|(
name|netstats
operator|.
name|krnldrop
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ps_ifdrop
operator|=
name|ntohl
argument_list|(
name|netstats
operator|.
name|ifdrop
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ps_recv
operator|=
name|ntohl
argument_list|(
name|netstats
operator|.
name|ifrecv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|->
name|ps_capt
operator|=
name|md
operator|->
name|TotCapt
expr_stmt|;
name|ps
operator|->
name|ps_drop
operator|=
name|ntohl
argument_list|(
name|netstats
operator|.
name|krnldrop
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ps_ifdrop
operator|=
name|ntohl
argument_list|(
name|netstats
operator|.
name|ifdrop
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ps_netdrop
operator|=
name|md
operator|->
name|TotNetDrops
expr_stmt|;
name|ps
operator|->
name|ps_recv
operator|=
name|ntohl
argument_list|(
name|netstats
operator|.
name|ifrecv
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ps_sent
operator|=
name|ntohl
argument_list|(
name|netstats
operator|.
name|svrcapt
argument_list|)
expr_stmt|;
block|}
comment|/* Checks if all the data has been read; if not, discard the data in excess */
if|if
condition|(
name|totread
operator|!=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock_discard
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|-
name|totread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|error
goto|;
block|}
return|return
name|ps
return|;
name|error
label|:
if|if
condition|(
name|totread
operator|!=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
condition|)
name|sock_discard
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|-
name|totread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief It opens a remote adapter by opening an RPCAP connection and so on.  *  * This function does basically the job of pcap_open_live() for a remote interface.  * In other words, we have a pcap_read for win32, which reads packets from NPF,  * another for LINUX, and so on. Now, we have a pcap_opensource_remote() as well.  * The difference, here, is the capture thread does not start until the  * pcap_startcapture_remote() is called.  *  * This is because, in remote capture, we cannot start capturing data as soon ad the  * 'open adapter' command is sent. Suppose the remote adapter is already overloaded;  * if we start a capture (which, by default, has a NULL filter) the new traffic can  * saturate the network.  *  * Instead, we want to "open" the adapter, then send a "start capture" command only  * when we're ready to start the capture.  * This funtion does this job: it sends a "open adapter" command (according to the  * RPCAP protocol), but it does not start the capture.  *  * Since the other libpcap functions do not share this way of life, we have to make  * some dirty things in order to make everyting working.  *  * \param fp: A pointer to a pcap_t structure that has been previously created with  * \ref pcap_create().  * \param source: see pcap_open().  * \param auth: see pcap_open().  *  * \return 0 in case of success, -1 otherwise. In case of success, the pcap_t pointer in fp can be  * used as a parameter to the following calls (pcap_compile() and so on). In case of  * problems, fp->errbuf contains a text explanation of error.  *  * \warning In case we call the pcap_compile() and the capture is not started, the filter  * will be saved into the pcap_t structure, and it will be sent to the other host later  * (when the pcap_startcapture_remote() is called).  */
end_comment

begin_function
name|int
name|pcap_opensource_remote
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|,
name|struct
name|pcap_rmtauth
modifier|*
name|auth
parameter_list|)
block|{
name|char
name|host
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|,
name|ctrlport
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|,
name|iface
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|;
name|char
name|sendbuf
index|[
name|RPCAP_NETBUF_SIZE
index|]
decl_stmt|;
comment|/* temporary buffer in which data to be sent is buffered */
name|int
name|sendbufidx
init|=
literal|0
decl_stmt|;
comment|/* index which keeps the number of bytes currently buffered */
name|uint32
name|totread
init|=
literal|0
decl_stmt|;
comment|/* number of bytes of the payload read from the socket */
name|int
name|nread
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* store the return value of the functions */
name|int
name|active
init|=
literal|0
decl_stmt|;
comment|/* '1' if we're in active mode */
comment|/* socket-related variables */
name|struct
name|addrinfo
name|hints
decl_stmt|;
comment|/* temp, needed to open a socket connection */
name|struct
name|addrinfo
modifier|*
name|addrinfo
decl_stmt|;
comment|/* temp, needed to open a socket connection */
name|SOCKET
name|sockctrl
init|=
literal|0
decl_stmt|;
comment|/* socket descriptor of the control connection */
comment|/* RPCAP-related variables */
name|struct
name|rpcap_header
name|header
decl_stmt|;
comment|/* header of the RPCAP packet */
name|struct
name|rpcap_openreply
name|openreply
decl_stmt|;
comment|/* open reply message */
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|fp
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * determine the type of the source (NULL, file, local, remote) 	 * You must have a valid source string even if we're in active mode, because otherwise 	 * the call to the following function will fail. 	 */
if|if
condition|(
name|pcap_parsesrcstr
argument_list|(
name|fp
operator|->
name|opt
operator|.
name|device
argument_list|,
operator|&
name|retval
argument_list|,
name|host
argument_list|,
name|ctrlport
argument_list|,
name|iface
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|retval
operator|!=
name|PCAP_SRC_IFREMOTE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"This function is able to open only remote interfaces"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|addrinfo
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Warning: this call can be the first one called by the user. 	 * For this reason, we have to initialize the WinSock support. 	 */
if|if
condition|(
name|sock_init
argument_list|(
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|sockctrl
operator|=
name|rpcap_remoteact_getsock
argument_list|(
name|host
argument_list|,
operator|&
name|active
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockctrl
operator|==
name|INVALID_SOCKET
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
comment|/* 		 * We're not in active mode; let's try to open a new 		 * control connection. 		 */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
if|if
condition|(
operator|(
name|ctrlport
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ctrlport
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* the user chose not to specify the port */
if|if
condition|(
name|sock_initaddress
argument_list|(
name|host
argument_list|,
name|RPCAP_DEFAULT_NETPORT
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* the user chose not to specify the port */
if|if
condition|(
name|sock_initaddress
argument_list|(
name|host
argument_list|,
name|ctrlport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|sockctrl
operator|=
name|sock_open
argument_list|(
name|addrinfo
argument_list|,
name|SOCKOPEN_CLIENT
argument_list|,
literal|0
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|)
operator|==
name|INVALID_SOCKET
condition|)
goto|goto
name|error
goto|;
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
name|addrinfo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rpcap_sendauth
argument_list|(
name|sockctrl
argument_list|,
name|auth
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Now it's time to start playing with the RPCAP protocol 	 * RPCAP open command: create the request message 	 */
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|rpcap_createhdr
argument_list|(
operator|(
expr|struct
name|rpcap_header
operator|*
operator|)
name|sendbuf
argument_list|,
name|RPCAP_MSG_OPEN_REQ
argument_list|,
literal|0
argument_list|,
operator|(
name|uint32
operator|)
name|strlen
argument_list|(
name|iface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|iface
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|iface
argument_list|)
argument_list|,
name|sendbuf
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_BUFFERIZE
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|sock_send
argument_list|(
name|sockctrl
argument_list|,
name|sendbuf
argument_list|,
name|sendbufidx
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Receive the RPCAP open reply message */
if|if
condition|(
name|sock_recv
argument_list|(
name|sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
comment|/* Checks if the message is correct */
name|retval
operator|=
name|rpcap_checkmsg
argument_list|(
name|fp
operator|->
name|errbuf
argument_list|,
name|sockctrl
argument_list|,
operator|&
name|header
argument_list|,
name|RPCAP_MSG_OPEN_REPLY
argument_list|,
name|RPCAP_MSG_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|RPCAP_MSG_OPEN_REPLY
condition|)
comment|/* the message is not the one expected */
block|{
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
operator|-
literal|3
case|:
comment|/* Unrecoverable network error */
case|case
operator|-
literal|2
case|:
comment|/* The other endpoint send a message that is not allowed here */
case|case
operator|-
literal|1
case|:
comment|/* The other endpoint has a version number that is not compatible with our */
goto|goto
name|error
goto|;
case|case
name|RPCAP_MSG_ERROR
case|:
comment|/* The other endpoint reported an error */
comment|/* Update totread, since the rpcap_checkmsg() already purged the buffer */
name|totread
operator|=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
expr_stmt|;
comment|/* Do nothing; just exit; the error code is already into the errbuf */
goto|goto
name|error
goto|;
default|default:
name|pcap_snprintf
argument_list|(
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Internal error"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|nread
operator|=
name|sock_recv
argument_list|(
name|sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|openreply
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_openreply
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|totread
operator|+=
name|nread
expr_stmt|;
comment|/* Set proper fields into the pcap_t struct */
name|fp
operator|->
name|linktype
operator|=
name|ntohl
argument_list|(
name|openreply
operator|.
name|linktype
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tzoff
operator|=
name|ntohl
argument_list|(
name|openreply
operator|.
name|tzoff
argument_list|)
expr_stmt|;
name|md
operator|->
name|rmt_sockctrl
operator|=
name|sockctrl
expr_stmt|;
name|md
operator|->
name|rmt_clientside
operator|=
literal|1
expr_stmt|;
comment|/* This code is duplicated from the end of this function */
name|fp
operator|->
name|read_op
operator|=
name|pcap_read_remote
expr_stmt|;
name|fp
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_remote
expr_stmt|;
name|fp
operator|->
name|getnonblock_op
operator|=
name|NULL
expr_stmt|;
comment|/* This is not implemented in remote capture */
name|fp
operator|->
name|setnonblock_op
operator|=
name|NULL
expr_stmt|;
comment|/* This is not implemented in remote capture */
name|fp
operator|->
name|stats_op
operator|=
name|pcap_stats_remote
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|fp
operator|->
name|stats_ex_op
operator|=
name|pcap_stats_ex_remote
expr_stmt|;
endif|#
directive|endif
name|fp
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_remote
expr_stmt|;
comment|/* Checks if all the data has been read; if not, discard the data in excess */
if|if
condition|(
name|totread
operator|!=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock_discard
argument_list|(
name|sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|-
name|totread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|error
goto|;
block|}
return|return
literal|0
return|;
name|error
label|:
comment|/* 	 * When the connection has been established, we have to close it. So, at the 	 * beginning of this function, if an error occur we return immediately with 	 * a return NULL; when the connection is established, we have to come here 	 * ('goto error;') in order to close everything properly. 	 * 	 * Checks if all the data has been read; if not, discard the data in excess 	 */
if|if
condition|(
name|totread
operator|!=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
condition|)
name|sock_discard
argument_list|(
name|sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|-
name|totread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrinfo
condition|)
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active
condition|)
name|sock_close
argument_list|(
name|sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief It starts a remote capture.  *  * This function is requires since the RPCAP protocol decouples the 'open' from the  * 'start capture' functions.  * This function takes all the parameters needed (which have been stored into the pcap_t structure)  * and sends them to the server.  * If everything is fine, it creates a new child thread that reads data from the network  * and puts data it into the user buffer.  * The pcap_read() will read data from the user buffer, as usual.  *  * The remote capture acts like a new "kernel", which puts packets directly into  * the buffer pointed by pcap_t.  * In fact, this function does not rely on a kernel that reads packets and put them  * into the user buffer; it has to do that on its own.  *  * \param fp: the pcap_t descriptor of the device currently open.  *  * \return '0' if everything is fine, '-1' otherwise. The error message (if one)  * is returned into the 'errbuf' field of the pcap_t structure.  */
end_comment

begin_function
name|int
name|pcap_startcapture_remote
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|)
block|{
name|char
name|sendbuf
index|[
name|RPCAP_NETBUF_SIZE
index|]
decl_stmt|;
comment|/* temporary buffer in which data to be sent is buffered */
name|int
name|sendbufidx
init|=
literal|0
decl_stmt|;
comment|/* index which keeps the number of bytes currently buffered */
name|char
name|portdata
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|;
comment|/* temp variable needed to keep the network port for the the data connection */
name|uint32
name|totread
init|=
literal|0
decl_stmt|;
comment|/* number of bytes of the payload read from the socket */
name|int
name|nread
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* store the return value of the functions */
name|int
name|active
init|=
literal|0
decl_stmt|;
comment|/* '1' if we're in active mode */
name|struct
name|activehosts
modifier|*
name|temp
decl_stmt|;
comment|/* temp var needed to scan the host list chain, to detect if we're in active mode */
name|char
name|host
index|[
name|INET6_ADDRSTRLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* numeric name of the other host */
comment|/* socket-related variables*/
name|struct
name|addrinfo
name|hints
decl_stmt|;
comment|/* temp, needed to open a socket connection */
name|struct
name|addrinfo
modifier|*
name|addrinfo
decl_stmt|;
comment|/* temp, needed to open a socket connection */
name|SOCKET
name|sockdata
init|=
literal|0
decl_stmt|;
comment|/* socket descriptor of the data connection */
name|struct
name|sockaddr_storage
name|saddr
decl_stmt|;
comment|/* temp, needed to retrieve the network data port chosen on the local machine */
name|socklen_t
name|saddrlen
decl_stmt|;
comment|/* temp, needed to retrieve the network data port chosen on the local machine */
name|int
name|ai_family
decl_stmt|;
comment|/* temp, keeps the address family used by the control connection */
comment|/* RPCAP-related variables*/
name|struct
name|rpcap_header
name|header
decl_stmt|;
comment|/* header of the RPCAP packet */
name|struct
name|rpcap_startcapreq
modifier|*
name|startcapreq
decl_stmt|;
comment|/* start capture request message */
name|struct
name|rpcap_startcapreply
name|startcapreply
decl_stmt|;
comment|/* start capture reply message */
comment|/* Variables related to the buffer setting */
name|int
name|res
decl_stmt|,
name|itemp
decl_stmt|;
name|int
name|sockbufsize
init|=
literal|0
decl_stmt|;
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|fp
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Let's check if sampling has been required. 	 * If so, let's set it first 	 */
if|if
condition|(
name|pcap_setsampling_remote
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* detect if we're in active mode */
name|temp
operator|=
name|activeHosts
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|sockctrl
operator|==
name|md
operator|->
name|rmt_sockctrl
condition|)
block|{
name|active
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
name|addrinfo
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Gets the complete sockaddr structure used in the ctrl connection 	 * This is needed to get the address family of the control socket 	 * Tip: I cannot save the ai_family of the ctrl sock in the pcap_t struct, 	 * since the ctrl socket can already be open in case of active mode; 	 * so I would have to call getpeername() anyway 	 */
name|saddrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
operator|&
name|saddrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getsockname(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ai_family
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|saddr
operator|)
operator|->
name|ss_family
expr_stmt|;
comment|/* Get the numeric address of the remote host we are connected to */
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
name|saddrlen
argument_list|,
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getnameinfo(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Data connection is opened by the server toward the client if: 	 * - we're using TCP, and the user wants us to be in active mode 	 * - we're using UDP 	 */
if|if
condition|(
operator|(
name|active
operator|)
operator|||
operator|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_DATATX_UDP
operator|)
condition|)
block|{
comment|/* 		 * We have to create a new socket to receive packets 		 * We have to do that immediately, since we have to tell the other 		 * end which network port we picked up 		 */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TEMP addrinfo is NULL in case of active */
name|hints
operator|.
name|ai_family
operator|=
name|ai_family
expr_stmt|;
comment|/* Use the same address family of the control socket */
name|hints
operator|.
name|ai_socktype
operator|=
operator|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_DATATX_UDP
operator|)
condition|?
name|SOCK_DGRAM
else|:
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
comment|/* Data connection is opened by the server toward the client */
comment|/* Let's the server pick up a free network port for us */
if|if
condition|(
name|sock_initaddress
argument_list|(
name|NULL
argument_list|,
literal|"0"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|sockdata
operator|=
name|sock_open
argument_list|(
name|addrinfo
argument_list|,
name|SOCKOPEN_SERVER
argument_list|,
literal|1
comment|/* max 1 connection in queue */
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|)
operator|==
name|INVALID_SOCKET
condition|)
goto|goto
name|error
goto|;
comment|/* addrinfo is no longer used */
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
name|addrinfo
operator|=
name|NULL
expr_stmt|;
comment|/* get the complete sockaddr structure used in the data connection */
name|saddrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sockdata
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
operator|&
name|saddrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getsockname(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Get the local port the system picked up */
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
name|saddrlen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|portdata
argument_list|,
sizeof|sizeof
argument_list|(
name|portdata
argument_list|)
argument_list|,
name|NI_NUMERICSERV
argument_list|)
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getnameinfo(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* 	 * Now it's time to start playing with the RPCAP protocol 	 * RPCAP start capture command: create the request message 	 */
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|rpcap_createhdr
argument_list|(
operator|(
expr|struct
name|rpcap_header
operator|*
operator|)
name|sendbuf
argument_list|,
name|RPCAP_MSG_STARTCAP_REQ
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_startcapreq
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_filter
argument_list|)
operator|+
name|fp
operator|->
name|fcode
operator|.
name|bf_len
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_filterbpf_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the structure needed to open an adapter remotely */
name|startcapreq
operator|=
operator|(
expr|struct
name|rpcap_startcapreq
operator|*
operator|)
operator|&
name|sendbuf
index|[
name|sendbufidx
index|]
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_startcapreq
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|memset
argument_list|(
name|startcapreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_startcapreq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* By default, apply half the timeout on one side, half of the other */
name|fp
operator|->
name|opt
operator|.
name|timeout
operator|=
name|fp
operator|->
name|opt
operator|.
name|timeout
operator|/
literal|2
expr_stmt|;
name|startcapreq
operator|->
name|read_timeout
operator|=
name|htonl
argument_list|(
name|fp
operator|->
name|opt
operator|.
name|timeout
argument_list|)
expr_stmt|;
comment|/* portdata on the openreq is meaningful only if we're in active mode */
if|if
condition|(
operator|(
name|active
operator|)
operator|||
operator|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_DATATX_UDP
operator|)
condition|)
block|{
name|sscanf
argument_list|(
name|portdata
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
operator|(
name|startcapreq
operator|->
name|portdata
operator|)
argument_list|)
expr_stmt|;
comment|/* cast to avoid a compiler warning */
name|startcapreq
operator|->
name|portdata
operator|=
name|htons
argument_list|(
name|startcapreq
operator|->
name|portdata
argument_list|)
expr_stmt|;
block|}
name|startcapreq
operator|->
name|snaplen
operator|=
name|htonl
argument_list|(
name|fp
operator|->
name|snapshot
argument_list|)
expr_stmt|;
name|startcapreq
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_PROMISCUOUS
condition|)
name|startcapreq
operator|->
name|flags
operator||=
name|RPCAP_STARTCAPREQ_FLAG_PROMISC
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_DATATX_UDP
condition|)
name|startcapreq
operator|->
name|flags
operator||=
name|RPCAP_STARTCAPREQ_FLAG_DGRAM
expr_stmt|;
if|if
condition|(
name|active
condition|)
name|startcapreq
operator|->
name|flags
operator||=
name|RPCAP_STARTCAPREQ_FLAG_SERVEROPEN
expr_stmt|;
name|startcapreq
operator|->
name|flags
operator|=
name|htons
argument_list|(
name|startcapreq
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* Pack the capture filter */
if|if
condition|(
name|pcap_pack_bpffilter
argument_list|(
name|fp
argument_list|,
operator|&
name|sendbuf
index|[
name|sendbufidx
index|]
argument_list|,
operator|&
name|sendbufidx
argument_list|,
operator|&
name|fp
operator|->
name|fcode
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|sock_send
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|sendbuf
argument_list|,
name|sendbufidx
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Receive the RPCAP start capture reply message */
if|if
condition|(
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
comment|/* Checks if the message is correct */
name|retval
operator|=
name|rpcap_checkmsg
argument_list|(
name|fp
operator|->
name|errbuf
argument_list|,
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|&
name|header
argument_list|,
name|RPCAP_MSG_STARTCAP_REPLY
argument_list|,
name|RPCAP_MSG_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|RPCAP_MSG_STARTCAP_REPLY
condition|)
comment|/* the message is not the one expected */
block|{
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
operator|-
literal|3
case|:
comment|/* Unrecoverable network error */
case|case
operator|-
literal|2
case|:
comment|/* The other endpoint send a message that is not allowed here */
case|case
operator|-
literal|1
case|:
comment|/* The other endpoint has a version number that is not compatible with our */
goto|goto
name|error
goto|;
case|case
name|RPCAP_MSG_ERROR
case|:
comment|/* The other endpoint reported an error */
comment|/* Update totread, since the rpcap_checkmsg() already purged the buffer */
name|totread
operator|=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
expr_stmt|;
comment|/* Do nothing; just exit; the error code is already into the errbuf */
goto|goto
name|error
goto|;
default|default:
name|pcap_snprintf
argument_list|(
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Internal error"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|nread
operator|=
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|startcapreply
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_startcapreply
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|totread
operator|+=
name|nread
expr_stmt|;
comment|/* 	 * In case of UDP data stream, the connection is always opened by the daemon 	 * So, this case is already covered by the code above. 	 * Now, we have still to handle TCP connections, because: 	 * - if we're in active mode, we have to wait for a remote connection 	 * - if we're in passive more, we have to start a connection 	 * 	 * We have to do he job in two steps because in case we're opening a TCP connection, we have 	 * to tell the port we're using to the remote side; in case we're accepting a TCP 	 * connection, we have to wait this info from the remote side. 	 */
if|if
condition|(
operator|!
operator|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_DATATX_UDP
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|ai_family
expr_stmt|;
comment|/* Use the same address family of the control socket */
name|hints
operator|.
name|ai_socktype
operator|=
operator|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_DATATX_UDP
operator|)
condition|?
name|SOCK_DGRAM
else|:
name|SOCK_STREAM
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|portdata
argument_list|,
name|PCAP_BUF_SIZE
argument_list|,
literal|"%d"
argument_list|,
name|ntohs
argument_list|(
name|startcapreply
operator|.
name|portdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Let's the server pick up a free network port for us */
if|if
condition|(
name|sock_initaddress
argument_list|(
name|host
argument_list|,
name|portdata
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|sockdata
operator|=
name|sock_open
argument_list|(
name|addrinfo
argument_list|,
name|SOCKOPEN_CLIENT
argument_list|,
literal|0
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|)
operator|==
name|INVALID_SOCKET
condition|)
goto|goto
name|error
goto|;
comment|/* addrinfo is no longer used */
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
name|addrinfo
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SOCKET
name|socktemp
decl_stmt|;
comment|/* We need another socket, since we're going to accept() a connection */
comment|/* Connection creation */
name|saddrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
name|socktemp
operator|=
name|accept
argument_list|(
name|sockdata
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
operator|&
name|saddrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|socktemp
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"accept(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Now that I accepted the connection, the server socket is no longer needed */
name|sock_close
argument_list|(
name|sockdata
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
name|sockdata
operator|=
name|socktemp
expr_stmt|;
block|}
block|}
comment|/* Let's save the socket of the data connection */
name|md
operator|->
name|rmt_sockdata
operator|=
name|sockdata
expr_stmt|;
comment|/* Allocates WinPcap/libpcap user buffer, which is a socket buffer in case of a remote capture */
comment|/* It has the same size of the one used on the other side of the connection */
name|fp
operator|->
name|bufsize
operator|=
name|ntohl
argument_list|(
name|startcapreply
operator|.
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Let's get the actual size of the socket buffer */
name|itemp
operator|=
sizeof|sizeof
argument_list|(
name|sockbufsize
argument_list|)
expr_stmt|;
name|res
operator|=
name|getsockopt
argument_list|(
name|sockdata
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sockbufsize
argument_list|,
operator|&
name|itemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"pcap_startcapture_remote()"
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
name|SOCK_ASSERT
argument_list|(
name|fp
operator|->
name|errbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Warning: on some kernels (e.g. Linux), the size of the user buffer does not take 	 * into account the pcap_header and such, and it is set equal to the snaplen. 	 * In my view, this is wrong (the meaning of the bufsize became a bit strange). 	 * So, here bufsize is the whole size of the user buffer. 	 * In case the bufsize returned is too small, let's adjust it accordingly. 	 */
if|if
condition|(
name|fp
operator|->
name|bufsize
operator|<=
operator|(
name|u_int
operator|)
name|fp
operator|->
name|snapshot
condition|)
name|fp
operator|->
name|bufsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_pkthdr
argument_list|)
expr_stmt|;
comment|/* if the current socket buffer is smaller than the desired one */
if|if
condition|(
operator|(
name|u_int
operator|)
name|sockbufsize
operator|<
name|fp
operator|->
name|bufsize
condition|)
block|{
comment|/* Loop until the buffer size is OK or the original socket buffer size is larger than this one */
while|while
condition|(
literal|1
condition|)
block|{
name|res
operator|=
name|setsockopt
argument_list|(
name|sockdata
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fp
operator|->
name|bufsize
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|bufsize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
comment|/* 			 * If something goes wrong, half the buffer size (checking that it does not become smaller than 			 * the current one) 			 */
name|fp
operator|->
name|bufsize
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|sockbufsize
operator|>=
name|fp
operator|->
name|bufsize
condition|)
block|{
name|fp
operator|->
name|bufsize
operator|=
name|sockbufsize
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * Let's allocate the packet; this is required in order to put the packet somewhere when 	 * extracting data from the socket 	 * Since buffering has already been done in the socket buffer, here we need just a buffer, 	 * whose size is equal to the pcap header plus the snapshot length 	 */
name|fp
operator|->
name|bufsize
operator|=
name|fp
operator|->
name|snapshot
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_pkthdr
argument_list|)
expr_stmt|;
name|fp
operator|->
name|buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|fp
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Checks if all the data has been read; if not, discard the data in excess */
if|if
condition|(
name|totread
operator|!=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock_discard
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|-
name|totread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* 	 * In case the user does not want to capture RPCAP packets, let's update the filter 	 * We have to update it here (instead of sending it into the 'StartCapture' message 	 * because when we generate the 'start capture' we do not know (yet) all the ports 	 * we're currently using. 	 */
if|if
condition|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_NOCAPTURE_RPCAP
condition|)
block|{
name|struct
name|bpf_program
name|fcode
decl_stmt|;
if|if
condition|(
name|pcap_createfilter_norpcappkt
argument_list|(
name|fp
argument_list|,
operator|&
name|fcode
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
comment|/* We cannot use 'pcap_setfilter_remote' because formally the capture has not been started yet */
comment|/* (the 'fp->rmt_capstarted' variable will be updated some lines below) */
if|if
condition|(
name|pcap_updatefilter_remote
argument_list|(
name|fp
argument_list|,
operator|&
name|fcode
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|pcap_freecode
argument_list|(
operator|&
name|fcode
argument_list|)
expr_stmt|;
block|}
name|md
operator|->
name|rmt_capstarted
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
comment|/* 	 * When the connection has been established, we have to close it. So, at the 	 * beginning of this function, if an error occur we return immediately with 	 * a return NULL; when the connection is established, we have to come here 	 * ('goto error;') in order to close everything properly. 	 * 	 * Checks if all the data has been read; if not, discard the data in excess 	 */
if|if
condition|(
name|totread
operator|!=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
condition|)
name|sock_discard
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|-
name|totread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sockdata
operator|)
operator|&&
operator|(
name|sockdata
operator|!=
operator|-
literal|1
operator|)
condition|)
comment|/* we can be here because sockdata said 'error' */
name|sock_close
argument_list|(
name|sockdata
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active
condition|)
name|sock_close
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * We do not have to call pcap_close() here, because this function is always called 	 * by the user in case something bad happens 	 */
comment|// 	if (fp)
comment|// 	{
comment|// 		pcap_close(fp);
comment|// 		fp= NULL;
comment|// 	}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * \brief Takes a bpf program and sends it to the other host.  *  * This function can be called in two cases:  * - the pcap_startcapture() is called (we have to send the filter along with  * the 'start capture' command)  * - we want to udpate the filter during a capture (i.e. the pcap_setfilter()  * is called when the capture is still on)  *  * This function serializes the filter into the sending buffer ('sendbuf', passed  * as a parameter) and return back. It does not send anything on the network.  *  * \param fp: the pcap_t descriptor of the device currently opened.  *  * \param sendbuf: the buffer on which the serialized data has to copied.  *  * \param sendbufidx: it is used to return the abounf of bytes copied into the buffer.  *  * \param prog: the bpf program we have to copy.  *  * \return '0' if everything is fine, '-1' otherwise. The error message (if one)  * is returned into the 'errbuf' field of the pcap_t structure.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_pack_bpffilter
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|sendbuf
parameter_list|,
name|int
modifier|*
name|sendbufidx
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|prog
parameter_list|)
block|{
name|struct
name|rpcap_filter
modifier|*
name|filter
decl_stmt|;
name|struct
name|rpcap_filterbpf_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|bf_insn
decl_stmt|;
name|struct
name|bpf_program
name|fake_prog
decl_stmt|;
comment|/* To be used just in case the user forgot to set a filter */
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|prog
operator|->
name|bf_len
operator|==
literal|0
condition|)
comment|/* No filters have been specified; so, let's apply a "fake" filter */
block|{
if|if
condition|(
name|pcap_compile
argument_list|(
name|fp
argument_list|,
operator|&
name|fake_prog
argument_list|,
name|NULL
comment|/* buffer */
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|prog
operator|=
operator|&
name|fake_prog
expr_stmt|;
block|}
name|filter
operator|=
operator|(
expr|struct
name|rpcap_filter
operator|*
operator|)
name|sendbuf
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_filter
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|filter
operator|->
name|filtertype
operator|=
name|htons
argument_list|(
name|RPCAP_UPDATEFILTER_BPF
argument_list|)
expr_stmt|;
name|filter
operator|->
name|nitems
operator|=
name|htonl
argument_list|(
operator|(
name|int32
operator|)
name|prog
operator|->
name|bf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
name|prog
operator|->
name|bf_len
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_filterbpf_insn
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|=
operator|(
expr|struct
name|rpcap_filterbpf_insn
operator|*
operator|)
operator|(
name|filter
operator|+
literal|1
operator|)
expr_stmt|;
name|bf_insn
operator|=
name|prog
operator|->
name|bf_insns
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prog
operator|->
name|bf_len
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|->
name|code
operator|=
name|htons
argument_list|(
name|bf_insn
operator|->
name|code
argument_list|)
expr_stmt|;
name|insn
operator|->
name|jf
operator|=
name|bf_insn
operator|->
name|jf
expr_stmt|;
name|insn
operator|->
name|jt
operator|=
name|bf_insn
operator|->
name|jt
expr_stmt|;
name|insn
operator|->
name|k
operator|=
name|htonl
argument_list|(
name|bf_insn
operator|->
name|k
argument_list|)
expr_stmt|;
name|insn
operator|++
expr_stmt|;
name|bf_insn
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief Update a filter on a remote host.  *  * This function is called when the user wants to update a filter.  * In case we're capturing from the network, it sends the filter to the other peer.  * This function is *not* called automatically when the user calls the pcap_setfilter().  * There will be two cases:  * - the capture is already on: in this case, pcap_setfilter() calls pcap_updatefilter_remote()  * - the capture has not started yet: in this case, pcap_setfilter() stores the filter into  * the pcap_t structure, and then the filter is sent with the pcap_startcap().  *  * Parameters and return values are exactly the same of the pcap_setfilter().  *  * \warning This function *does not* clear the packet currently into the buffers. Therefore,  * the user has to expect to receive some packets that are related to the previous filter.  * If you want to discard all the packets before applying a new filter, you have to close  * the current capture session and start a new one.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_updatefilter_remote
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|prog
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
comment|/* general variable used to keep the return value of other functions */
name|char
name|sendbuf
index|[
name|RPCAP_NETBUF_SIZE
index|]
decl_stmt|;
comment|/* temporary buffer in which data to be sent is buffered */
name|int
name|sendbufidx
init|=
literal|0
decl_stmt|;
comment|/* index which keeps the number of bytes currently buffered */
name|struct
name|rpcap_header
name|header
decl_stmt|;
comment|/* To keep the reply message */
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|fp
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|rpcap_createhdr
argument_list|(
operator|(
expr|struct
name|rpcap_header
operator|*
operator|)
name|sendbuf
argument_list|,
name|RPCAP_MSG_UPDATEFILTER_REQ
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_filter
argument_list|)
operator|+
name|prog
operator|->
name|bf_len
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_filterbpf_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_pack_bpffilter
argument_list|(
name|fp
argument_list|,
operator|&
name|sendbuf
index|[
name|sendbufidx
index|]
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|prog
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sock_send
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|sendbuf
argument_list|,
name|sendbufidx
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Waits for the answer */
if|if
condition|(
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Checks if the message is correct */
name|retval
operator|=
name|rpcap_checkmsg
argument_list|(
name|fp
operator|->
name|errbuf
argument_list|,
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|&
name|header
argument_list|,
name|RPCAP_MSG_UPDATEFILTER_REPLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|RPCAP_MSG_UPDATEFILTER_REPLY
condition|)
comment|/* the message is not the one expected */
block|{
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
operator|-
literal|3
case|:
comment|/* Unrecoverable network error */
case|case
operator|-
literal|2
case|:
comment|/* The other endpoint sent a message that is not allowed here */
case|case
operator|-
literal|1
case|:
comment|/* The other endpoint has a version number that is not compatible with our */
comment|/* Do nothing; just exit from here; the error code is already into the errbuf */
return|return
operator|-
literal|1
return|;
default|default:
name|SOCK_ASSERT
argument_list|(
literal|"Internal error"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|!=
literal|0
condition|)
comment|/* the message has an unexpected size */
block|{
if|if
condition|(
name|sock_discard
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \ingroup remote_pri_func  *  * \brief Send a filter to a remote host.  *  * This function is called when the user wants to set a filter.  * In case we're capturing from the network, it sends the filter to the other peer.  * This function is called automatically when the user calls the pcap_setfilter().  *  * Parameters and return values are exactly the same of the pcap_setfilter().  */
end_comment

begin_function
specifier|static
name|int
name|pcap_setfilter_remote
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|prog
parameter_list|)
block|{
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|fp
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|md
operator|->
name|rmt_capstarted
condition|)
block|{
comment|/* copy filter into the pcap_t structure */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|fp
argument_list|,
name|prog
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* we have to update a filter during run-time */
if|if
condition|(
name|pcap_updatefilter_remote
argument_list|(
name|fp
argument_list|,
name|prog
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \ingroup remote_pri_func  *  * \brief Update the current filter in order not to capture rpcap packets.  *  * This function is called *only* when the user wants exclude RPCAP packets  * related to the current session from the captured packets.  *  * \return '0' if everything is fine, '-1' otherwise. The error message (if one)  * is returned into the 'errbuf' field of the pcap_t structure.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_createfilter_norpcappkt
parameter_list|(
name|pcap_t
modifier|*
name|fp
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|prog
parameter_list|)
block|{
name|int
name|RetVal
init|=
literal|0
decl_stmt|;
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|fp
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
comment|/* We do not want to capture our RPCAP traffic. So, let's update the filter */
if|if
condition|(
name|md
operator|->
name|rmt_flags
operator|&
name|PCAP_OPENFLAG_NOCAPTURE_RPCAP
condition|)
block|{
name|struct
name|sockaddr_storage
name|saddr
decl_stmt|;
comment|/* temp, needed to retrieve the network data port chosen on the local machine */
name|socklen_t
name|saddrlen
decl_stmt|;
comment|/* temp, needed to retrieve the network data port chosen on the local machine */
name|char
name|myaddress
index|[
literal|128
index|]
decl_stmt|;
name|char
name|myctrlport
index|[
literal|128
index|]
decl_stmt|;
name|char
name|mydataport
index|[
literal|128
index|]
decl_stmt|;
name|char
name|peeraddress
index|[
literal|128
index|]
decl_stmt|;
name|char
name|peerctrlport
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|newfilter
decl_stmt|;
specifier|const
name|int
name|newstringsize
init|=
literal|1024
decl_stmt|;
name|size_t
name|currentfiltersize
decl_stmt|;
comment|/* Get the name/port of the other peer */
name|saddrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
operator|&
name|saddrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getpeername(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
name|saddrlen
argument_list|,
name|peeraddress
argument_list|,
sizeof|sizeof
argument_list|(
name|peeraddress
argument_list|)
argument_list|,
name|peerctrlport
argument_list|,
sizeof|sizeof
argument_list|(
name|peerctrlport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getnameinfo(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* We cannot check the data port, because this is available only in case of TCP sockets */
comment|/* Get the name/port of the current host */
if|if
condition|(
name|getsockname
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
operator|&
name|saddrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getsockname(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Get the local port the system picked up */
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
name|saddrlen
argument_list|,
name|myaddress
argument_list|,
sizeof|sizeof
argument_list|(
name|myaddress
argument_list|)
argument_list|,
name|myctrlport
argument_list|,
sizeof|sizeof
argument_list|(
name|myctrlport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getnameinfo(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Let's now check the data port */
if|if
condition|(
name|getsockname
argument_list|(
name|md
operator|->
name|rmt_sockdata
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
operator|&
name|saddrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getsockname(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Get the local port the system picked up */
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
name|saddrlen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mydataport
argument_list|,
sizeof|sizeof
argument_list|(
name|mydataport
argument_list|)
argument_list|,
name|NI_NUMERICSERV
argument_list|)
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getnameinfo(): "
argument_list|,
name|fp
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|currentfiltersize
operator|=
name|strlen
argument_list|(
name|md
operator|->
name|currentfilter
argument_list|)
expr_stmt|;
name|newfilter
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|currentfiltersize
operator|+
name|newstringsize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentfiltersize
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|newfilter
argument_list|,
name|currentfiltersize
operator|+
name|newstringsize
argument_list|,
literal|"(%s) and not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)"
argument_list|,
name|md
operator|->
name|currentfilter
argument_list|,
name|myaddress
argument_list|,
name|peeraddress
argument_list|,
name|myctrlport
argument_list|,
name|peerctrlport
argument_list|,
name|myaddress
argument_list|,
name|peeraddress
argument_list|,
name|mydataport
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|newfilter
argument_list|,
name|currentfiltersize
operator|+
name|newstringsize
argument_list|,
literal|"not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)"
argument_list|,
name|myaddress
argument_list|,
name|peeraddress
argument_list|,
name|myctrlport
argument_list|,
name|peerctrlport
argument_list|,
name|myaddress
argument_list|,
name|peeraddress
argument_list|,
name|mydataport
argument_list|)
expr_stmt|;
block|}
name|newfilter
index|[
name|currentfiltersize
operator|+
name|newstringsize
index|]
operator|=
literal|0
expr_stmt|;
comment|/* This is only an hack to make the pcap_compile() working properly */
name|md
operator|->
name|rmt_clientside
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pcap_compile
argument_list|(
name|fp
argument_list|,
name|prog
argument_list|,
name|newfilter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|RetVal
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This is only an hack to make the pcap_compile() working properly */
name|md
operator|->
name|rmt_clientside
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|newfilter
argument_list|)
expr_stmt|;
block|}
return|return
name|RetVal
return|;
block|}
end_function

begin_comment
comment|/*  * \ingroup remote_pri_func  *  * \brief Set sampling parameters in the remote host.  *  * This function is called when the user wants to set activate sampling on the remote host.  *  * Sampling parameters are defined into the 'pcap_t' structure.  *  * \param p: the pcap_t descriptor of the device currently opened.  *  * \return '0' if everything is OK, '-1' is something goes wrong. The error message is returned  * in the 'errbuf' member of the pcap_t structure.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_setsampling_remote
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
comment|/* general variable used to keep the return value of other functions */
name|char
name|sendbuf
index|[
name|RPCAP_NETBUF_SIZE
index|]
decl_stmt|;
comment|/* temporary buffer in which data to be sent is buffered */
name|int
name|sendbufidx
init|=
literal|0
decl_stmt|;
comment|/* index which keeps the number of bytes currently buffered */
name|struct
name|rpcap_header
name|header
decl_stmt|;
comment|/* To keep the reply message */
name|struct
name|rpcap_sampling
modifier|*
name|sampling_pars
decl_stmt|;
comment|/* Structure that is needed to send sampling parameters to the remote host */
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
comment|/* If no samping is requested, return 'ok' */
if|if
condition|(
name|md
operator|->
name|rmt_samp
operator|.
name|method
operator|==
name|PCAP_SAMP_NOSAMP
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|rpcap_createhdr
argument_list|(
operator|(
expr|struct
name|rpcap_header
operator|*
operator|)
name|sendbuf
argument_list|,
name|RPCAP_MSG_SETSAMPLING_REQ
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_sampling
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the structure needed to open an adapter remotely */
name|sampling_pars
operator|=
operator|(
expr|struct
name|rpcap_sampling
operator|*
operator|)
operator|&
name|sendbuf
index|[
name|sendbufidx
index|]
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_sampling
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|sampling_pars
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_sampling
argument_list|)
argument_list|)
expr_stmt|;
name|sampling_pars
operator|->
name|method
operator|=
name|md
operator|->
name|rmt_samp
operator|.
name|method
expr_stmt|;
name|sampling_pars
operator|->
name|value
operator|=
name|htonl
argument_list|(
name|md
operator|->
name|rmt_samp
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_send
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|sendbuf
argument_list|,
name|sendbufidx
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Waits for the answer */
if|if
condition|(
name|sock_recv
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Checks if the message is correct */
name|retval
operator|=
name|rpcap_checkmsg
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|md
operator|->
name|rmt_sockctrl
argument_list|,
operator|&
name|header
argument_list|,
name|RPCAP_MSG_SETSAMPLING_REPLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|RPCAP_MSG_SETSAMPLING_REPLY
condition|)
comment|/* the message is not the one expected */
block|{
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
operator|-
literal|3
case|:
comment|/* Unrecoverable network error */
case|case
operator|-
literal|2
case|:
comment|/* The other endpoint sent a message that is not allowed here */
case|case
operator|-
literal|1
case|:
comment|/* The other endpoint has a version number that is not compatible with our */
case|case
name|RPCAP_MSG_ERROR
case|:
comment|/* Do nothing; just exit from here; the error code is already into the errbuf */
return|return
operator|-
literal|1
return|;
default|default:
name|SOCK_ASSERT
argument_list|(
literal|"Internal error"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|!=
literal|0
condition|)
comment|/* the message has an unexpected size */
block|{
if|if
condition|(
name|sock_discard
argument_list|(
name|md
operator|->
name|rmt_sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*********************************************************  *                                                       *  * Miscellaneous functions                               *  *                                                       *  *********************************************************/
end_comment

begin_comment
comment|/* \ingroup remote_pri_func  * \brief It sends a RPCAP error to the other peer.  *  * This function has to be called when the main program detects an error. This function  * will send on the other peer the 'buffer' specified by the user.  * This function *does not* request a RPCAP CLOSE connection. A CLOSE command must be sent  * explicitly by the program, since we do not know it the error can be recovered in some  * way or it is a non-recoverable one.  *  * \param sock: the socket we are currently using.  *  * \param error: an user-allocated (and '0' terminated) buffer that contains the error  * description that has to be transmitted on the other peer. The error message cannot  * be longer than PCAP_ERRBUF_SIZE.  *  * \param errcode: a integer which tells the other party the type of error we had;  * currently is is not too much used.  *  * \param errbuf: a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE)  * that will contain the error message (in case there is one). It could be network problem.  *  * \return '0' if everything is fine, '-1' if some errors occurred. The error message is returned  * in the 'errbuf' variable.  */
end_comment

begin_function
name|int
name|rpcap_senderror
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|char
modifier|*
name|error
parameter_list|,
name|unsigned
name|short
name|errcode
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
name|sendbuf
index|[
name|RPCAP_NETBUF_SIZE
index|]
decl_stmt|;
comment|/* temporary buffer in which data to be sent is buffered */
name|int
name|sendbufidx
init|=
literal|0
decl_stmt|;
comment|/* index which keeps the number of bytes currently buffered */
name|uint16
name|length
decl_stmt|;
name|length
operator|=
operator|(
name|uint16
operator|)
name|strlen
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|PCAP_ERRBUF_SIZE
condition|)
name|length
operator|=
name|PCAP_ERRBUF_SIZE
expr_stmt|;
name|rpcap_createhdr
argument_list|(
operator|(
expr|struct
name|rpcap_header
operator|*
operator|)
name|sendbuf
argument_list|,
name|RPCAP_MSG_ERROR
argument_list|,
name|errcode
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|error
argument_list|,
name|length
argument_list|,
name|sendbuf
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_BUFFERIZE
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sock_send
argument_list|(
name|sock
argument_list|,
name|sendbuf
argument_list|,
name|sendbufidx
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  * \brief Sends the authentication message.  *  * It sends the authentication parameters on the control socket.  * This function is required in order to open the connection with the other end party.  *  * \param sock: the socket we are currently using.  *  * \param auth: authentication parameters that have to be sent.  *  * \param errbuf: a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE)  * that will contain the error message (in case there is one). It could be network problem  * of the fact that the authorization failed.  *  * \return '0' if everything is fine, '-1' if some errors occurred. The error message is returned  * in the 'errbuf' variable.  * The error message could be also 'the authentication failed'.  */
end_comment

begin_function
name|int
name|rpcap_sendauth
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|struct
name|pcap_rmtauth
modifier|*
name|auth
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
name|sendbuf
index|[
name|RPCAP_NETBUF_SIZE
index|]
decl_stmt|;
comment|/* temporary buffer in which data that has to be sent is buffered */
name|int
name|sendbufidx
init|=
literal|0
decl_stmt|;
comment|/* index which keeps the number of bytes currently buffered */
name|uint16
name|length
decl_stmt|;
comment|/* length of the payload of this message */
name|struct
name|rpcap_auth
modifier|*
name|rpauth
decl_stmt|;
name|uint16
name|auth_type
decl_stmt|;
name|struct
name|rpcap_header
name|header
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* temp variable which stores functions return value */
if|if
condition|(
name|auth
condition|)
block|{
name|auth_type
operator|=
name|auth
operator|->
name|type
expr_stmt|;
switch|switch
condition|(
name|auth
operator|->
name|type
condition|)
block|{
case|case
name|RPCAP_RMTAUTH_NULL
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_auth
argument_list|)
expr_stmt|;
break|break;
case|case
name|RPCAP_RMTAUTH_PWD
case|:
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
operator|->
name|username
condition|)
name|length
operator|+=
operator|(
name|uint16
operator|)
name|strlen
argument_list|(
name|auth
operator|->
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
operator|->
name|password
condition|)
name|length
operator|+=
operator|(
name|uint16
operator|)
name|strlen
argument_list|(
name|auth
operator|->
name|password
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Authentication type not recognized."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|auth_type
operator|=
name|RPCAP_RMTAUTH_NULL
expr_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_auth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|rpcap_createhdr
argument_list|(
operator|(
expr|struct
name|rpcap_header
operator|*
operator|)
name|sendbuf
argument_list|,
name|RPCAP_MSG_AUTH_REQ
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|rpauth
operator|=
operator|(
expr|struct
name|rpcap_auth
operator|*
operator|)
operator|&
name|sendbuf
index|[
name|sendbufidx
index|]
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_auth
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_CHECKONLY
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|rpauth
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_auth
argument_list|)
argument_list|)
expr_stmt|;
name|rpauth
operator|->
name|type
operator|=
name|htons
argument_list|(
name|auth_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_type
operator|==
name|RPCAP_RMTAUTH_PWD
condition|)
block|{
if|if
condition|(
name|auth
operator|->
name|username
condition|)
name|rpauth
operator|->
name|slen1
operator|=
operator|(
name|uint16
operator|)
name|strlen
argument_list|(
name|auth
operator|->
name|username
argument_list|)
expr_stmt|;
else|else
name|rpauth
operator|->
name|slen1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|auth
operator|->
name|username
argument_list|,
name|rpauth
operator|->
name|slen1
argument_list|,
name|sendbuf
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_BUFFERIZE
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|auth
operator|->
name|password
condition|)
name|rpauth
operator|->
name|slen2
operator|=
operator|(
name|uint16
operator|)
name|strlen
argument_list|(
name|auth
operator|->
name|password
argument_list|)
expr_stmt|;
else|else
name|rpauth
operator|->
name|slen2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sock_bufferize
argument_list|(
name|auth
operator|->
name|password
argument_list|,
name|rpauth
operator|->
name|slen2
argument_list|,
name|sendbuf
argument_list|,
operator|&
name|sendbufidx
argument_list|,
name|RPCAP_NETBUF_SIZE
argument_list|,
name|SOCKBUF_BUFFERIZE
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|rpauth
operator|->
name|slen1
operator|=
name|htons
argument_list|(
name|rpauth
operator|->
name|slen1
argument_list|)
expr_stmt|;
name|rpauth
operator|->
name|slen2
operator|=
name|htons
argument_list|(
name|rpauth
operator|->
name|slen2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sock_send
argument_list|(
name|sock
argument_list|,
name|sendbuf
argument_list|,
name|sendbufidx
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sock_recv
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|retval
operator|=
name|rpcap_checkmsg
argument_list|(
name|errbuf
argument_list|,
name|sock
argument_list|,
operator|&
name|header
argument_list|,
name|RPCAP_MSG_AUTH_REPLY
argument_list|,
name|RPCAP_MSG_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|RPCAP_MSG_AUTH_REPLY
condition|)
comment|/* the message is not the one expected */
block|{
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
operator|-
literal|3
case|:
comment|/* Unrecoverable network error */
case|case
operator|-
literal|2
case|:
comment|/* The other endpoint sent a message that is not allowed here */
case|case
operator|-
literal|1
case|:
comment|/* The other endpoint has a version number that is not compatible with our */
comment|/* Do nothing; just exit from here; the error code is already into the errbuf */
return|return
operator|-
literal|1
return|;
case|case
name|RPCAP_MSG_ERROR
case|:
return|return
operator|-
literal|1
return|;
default|default:
name|SOCK_ASSERT
argument_list|(
literal|"Internal error"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock_discard
argument_list|(
name|sock
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  * \brief Creates a structure of type rpcap_header.  *  * This function is provided just because the creation of an rpcap header is quite a common  * task. It accepts all the values that appears into an rpcap_header, and it puts them in  * place using the proper hton() calls.  *  * \param header: a pointer to a user-allocated buffer which will contain the serialized  * header, ready to be sent on the network.  *  * \param type: a value (in the host by order) which will be placed into the header.type  * field and that represents the type of the current message.  *  * \param value: a value (in the host by order) which will be placed into the header.value  * field and that has a message-dependent meaning.  *  * \param length: a value (in the host by order) which will be placed into the header.length  * field and that represents the payload length of the message.  *  * \return Nothing. The serialized header is returned into the 'header' variable.  */
end_comment

begin_function
name|void
name|rpcap_createhdr
parameter_list|(
name|struct
name|rpcap_header
modifier|*
name|header
parameter_list|,
name|uint8
name|type
parameter_list|,
name|uint16
name|value
parameter_list|,
name|uint32
name|length
parameter_list|)
block|{
name|memset
argument_list|(
name|header
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|)
expr_stmt|;
name|header
operator|->
name|ver
operator|=
name|RPCAP_VERSION
expr_stmt|;
name|header
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|header
operator|->
name|value
operator|=
name|htons
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|header
operator|->
name|plen
operator|=
name|htonl
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ingroup remote_pri_func  * \brief Checks if the header of the received message is correct.  *  * This function is a way to easily check if the message received, in a certain  * state of the RPCAP protocol Finite State Machine, is valid. This function accepts,  * as a parameter, the list of message types that are allowed in a certain situation,  * and it returns the one which occurs.  *  * \param errbuf: a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE)  * that will contain the error message (in case there is one). It could be either problem  * occurred inside this function (e.g. a network problem in case it tries to send an  * error on the other peer and the send() call fails), an error message which has been  * sent to us from the other party, or a version error (the message receive has a version  * number that is incompatible with our).  *  * \param sock: the socket that has to be used to receive data. This function can  * read data from socket in case the version contained into the message is not compatible  * with our. In that case, all the message is purged from the socket, so that the following  * recv() calls will return a new message.  *  * \param header: a pointer to and 'rpcap_header' structure that keeps the data received from  * the network (still in network byte order) and that has to be checked.  *  * \param first: this function has a variable number of parameters. From this point on,  * all the messages that are valid in this context must be passed as parameters.  * The message type list must be terminated with a '0' value, the null message type,  * which means 'no more types to check'. The RPCAP protocol does not define anything with  * message type equal to zero, so there is no ambiguity in using this value as a list terminator.  *  * \return The message type of the message that has been detected. In case of errors (e.g. the  * header contains a type that is not listed among the allowed types), this function will  * return the following codes:  * - (-1) if the version is incompatible.  * - (-2) if the code is not among the one listed into the parameters list  * - (-3) if a network error (connection reset, ...)  * - RPCAP_MSG_ERROR if the message is an error message (it follow that the RPCAP_MSG_ERROR  * could not be present in the allowed message-types list, because this function checks  * for errors anyway)  *  * In case either the version is incompatible or nothing matches (i.e. it returns '-1' or '-2'),  * it discards the message body (i.e. it reads the remaining part of the message from the  * network and it discards it) so that the application is ready to receive a new message.  */
end_comment

begin_function
name|int
name|rpcap_checkmsg
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|,
name|SOCKET
name|sock
parameter_list|,
name|struct
name|rpcap_header
modifier|*
name|header
parameter_list|,
name|uint8
name|first
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|uint8
name|type
decl_stmt|;
name|int32
name|len
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|first
argument_list|)
expr_stmt|;
comment|/* Check if the present version of the protocol can handle this message */
if|if
condition|(
name|rpcap_checkver
argument_list|(
name|sock
argument_list|,
name|header
argument_list|,
name|errbuf
argument_list|)
condition|)
block|{
name|SOCK_ASSERT
argument_list|(
name|errbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|type
operator|=
name|first
expr_stmt|;
while|while
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The message matches with one of the types listed 		 * There is no need of conversions since both values are uint8 		 * 		 * Check if the other side reported an error. 		 * If yes, it retrieves it and it returns it back to the caller 		 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RPCAP_MSG_ERROR
condition|)
block|{
name|len
operator|=
name|ntohl
argument_list|(
name|header
operator|->
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|PCAP_ERRBUF_SIZE
condition|)
block|{
if|if
condition|(
name|sock_recv
argument_list|(
name|sock
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
operator|-
literal|1
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
name|sock_discard
argument_list|(
name|sock
argument_list|,
name|len
operator|-
operator|(
name|PCAP_ERRBUF_SIZE
operator|-
literal|1
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put '\0' at the end of the string */
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sock_recv
argument_list|(
name|sock
argument_list|,
name|errbuf
argument_list|,
name|len
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|3
return|;
comment|/* Put '\0' at the end of the string */
name|errbuf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|header
operator|->
name|type
return|;
block|}
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|type
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|header
operator|->
name|type
return|;
block|}
comment|/* get next argument */
name|type
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
comment|/* we already have an error, so please discard this one */
name|sock_discard
argument_list|(
name|sock
argument_list|,
name|ntohl
argument_list|(
name|header
operator|->
name|plen
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The other endpoint sent a message that is not allowed here."
argument_list|)
expr_stmt|;
name|SOCK_ASSERT
argument_list|(
name|errbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  * \brief Checks if the version contained into the message is compatible with  * the one handled by this implementation.  *  * Right now, this function does not have any sophisticated task: if the versions  * are different, it returns -1 and it discards the message.  * It is expected that in the future this message will become more complex.  *  * \param sock: the socket that has to be used to receive data. This function can  * read data from socket in case the version contained into the message is not compatible  * with our. In that case, all the message is purged from the socket, so that the following  * recv() calls will return a new (clean) message.  *  * \param header: a pointer to and 'rpcap_header' structure that keeps the data received from  * the network (still in network byte order) and that has to be checked.  *  * \param errbuf: a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE)  * that will contain the error message (in case there is one). The error message is  * "incompatible version".  *  * \return '0' if everything is fine, '-1' if some errors occurred. The error message is returned  * in the 'errbuf' variable.  */
end_comment

begin_function
specifier|static
name|int
name|rpcap_checkver
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|struct
name|rpcap_header
modifier|*
name|header
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* 	 * This is a sample function. 	 * 	 * In the real world, you have to check at the type code, 	 * and decide accordingly. 	 */
if|if
condition|(
name|header
operator|->
name|ver
operator|!=
name|RPCAP_VERSION
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Incompatible version number: message discarded."
argument_list|)
expr_stmt|;
comment|/* we already have an error, so please discard this one */
name|sock_discard
argument_list|(
name|sock
argument_list|,
name|ntohl
argument_list|(
name|header
operator|->
name|plen
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* \ingroup remote_pri_func  *  * \brief It returns the socket currently used for this active connection  * (active mode only) and provides an indication of whether this connection  * is in active mode or not.  *  * This function is just for internal use; it returns the socket ID of the  * active connection currently opened.  *  * \param host: a string that keeps the host name of the host for which we  * want to get the socket ID for that active connection.  *  * \param isactive: a pointer to an int that is set to 1 if there's an  * active connection to that host and 0 otherwise.  *  * \param errbuf: a pointer to a user-allocated buffer (of size  * PCAP_ERRBUF_SIZE) that will contain the error message (in case  * there is one).  *  * \return the socket identifier if everything is fine, '0' if this host  * is not in the active host list. An indication of whether this host  * is in the active host list is returned into the isactive variable.  * It returns 'INVALID_SOCKET' in case of error. The error message is  * returned into the errbuf variable.  */
end_comment

begin_function
name|SOCKET
name|rpcap_remoteact_getsock
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|int
modifier|*
name|isactive
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|activehosts
modifier|*
name|temp
decl_stmt|;
comment|/* temp var needed to scan the host list chain */
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|addrinfo
decl_stmt|,
modifier|*
name|ai_next
decl_stmt|;
comment|/* temp var needed to translate between hostname to its address */
name|int
name|retval
decl_stmt|;
comment|/* retrieve the network address corresponding to 'host' */
name|addrinfo
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|retval
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
literal|"0"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getaddrinfo() %s"
argument_list|,
name|gai_strerror
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|isactive
operator|=
literal|0
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
name|temp
operator|=
name|activeHosts
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|ai_next
operator|=
name|addrinfo
expr_stmt|;
while|while
condition|(
name|ai_next
condition|)
block|{
if|if
condition|(
name|sock_cmpaddr
argument_list|(
operator|&
name|temp
operator|->
name|host
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|ai_next
operator|->
name|ai_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|isactive
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|temp
operator|->
name|sockctrl
operator|)
return|;
block|}
name|ai_next
operator|=
name|ai_next
operator|->
name|ai_next
expr_stmt|;
block|}
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|addrinfo
condition|)
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
comment|/* 	 * The host for which you want to get the socket ID does not have an 	 * active connection. 	 */
operator|*
name|isactive
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

