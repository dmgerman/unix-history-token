begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * pcap-septel.c: Packet capture interface for Intel/Septel card.  *  * The functionality of this code attempts to mimic that of pcap-linux as much  * as possible.  This code is compiled in several different ways depending on  * whether SEPTEL_ONLY and HAVE_SEPTEL_API are defined.  If HAVE_SEPTEL_API is  * not defined it should not get compiled in, otherwise if SEPTEL_ONLY is  * defined then the 'septel_' function calls are renamed to 'pcap_'  * equivalents.  If SEPTEL_ONLY is not defined then nothing is altered - the  * septel_ functions will be called as required from their  * pcap-linux/equivalents.  *  * Authors: Gilbert HOYEK (gil_hoyek@hotmail.com), Elias M. KHOURY  * (+961 3 485243)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<msg.h>
end_include

begin_include
include|#
directive|include
file|<ss7_inc.h>
end_include

begin_include
include|#
directive|include
file|<sysgct.h>
end_include

begin_include
include|#
directive|include
file|<pack.h>
end_include

begin_include
include|#
directive|include
file|<system.h>
end_include

begin_include
include|#
directive|include
file|"pcap-septel.h"
end_include

begin_function_decl
specifier|static
name|int
name|septel_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|septel_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|septel_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Private data for capturing on Septel devices.  */
end_comment

begin_struct
struct|struct
name|pcap_septel
block|{
name|struct
name|pcap_stat
name|stat
decl_stmt|;
block|}
comment|/*  *  Read at most max_packets from the capture queue and call the callback  *  for each of them. Returns the number of packets handled, -1 if an  *  error occured, or -2 if we were told to break out of the loop.  */
decl|static
name|int
name|septel_read
argument_list|(
name|pcap_t
operator|*
name|p
argument_list|,
name|int
name|cnt
argument_list|,
name|pcap_handler
name|callback
argument_list|,
name|u_char
operator|*
name|user
argument_list|)
block|{
name|struct
name|pcap_septel
modifier|*
name|ps
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|HDR
modifier|*
name|h
decl_stmt|;
name|MSG
modifier|*
name|m
decl_stmt|;
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
comment|/* identifier for the message queue of the module(upe) from which we are capturing    * packets.These IDs are defined in system.txt . By default it is set to 0x2d    * so change it to 0xdd for technical reason and therefore the module id for upe becomes:    * LOCAL        0xdd           * upe - Example user part task */
name|unsigned
name|int
name|id
init|=
literal|0xdd
decl_stmt|;
comment|/* process the packets */
do|do
block|{
name|unsigned
name|short
name|packet_len
init|=
literal|0
decl_stmt|;
name|int
name|caplen
init|=
literal|0
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
name|u_char
modifier|*
name|dp
decl_stmt|;
comment|/*      * Has "pcap_breakloop()" been called?      */
name|loop
label|:
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/*        * Yes - clear the flag that indicates that        * it has, and return -2 to indicate that        * we were told to break out of the loop.        */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
comment|/*repeat until a packet is read      *a NULL message means :      * when no packet is in queue or all packets in queue already read */
do|do
block|{
comment|/* receive packet in non-blocking mode        * GCT_grab is defined in the septel library software */
name|h
operator|=
name|GCT_grab
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|MSG
operator|*
operator|)
name|h
expr_stmt|;
comment|/* a couter is added here to avoid an infinite loop        * that will cause our capture program GUI to freeze while waiting        * for a packet*/
name|counter
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|m
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|counter
operator|<
literal|100
operator|)
condition|)
do|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|t
operator|=
name|h
operator|->
name|type
expr_stmt|;
comment|/* catch only messages with type = 0xcf00 or 0x8f01 corrsponding to ss7 messages*/
comment|/* XXX = why not use API_MSG_TX_REQ for 0xcf00 and API_MSG_RX_IND        * for 0x8f01? */
if|if
condition|(
operator|(
name|t
operator|!=
literal|0xcf00
operator|)
operator|&&
operator|(
name|t
operator|!=
literal|0x8f01
operator|)
condition|)
block|{
name|relm
argument_list|(
name|h
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* XXX - is API_MSG_RX_IND for an MTP2 or MTP3 message? */
name|dp
operator|=
name|get_param
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* get pointer to MSG parameter area (m->param) */
name|packet_len
operator|=
name|m
operator|->
name|len
expr_stmt|;
name|caplen
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
comment|/* Run the packet filter if there is one. */
if|if
condition|(
operator|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
operator|)
operator|||
name|bpf_filter
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|dp
argument_list|,
name|packet_len
argument_list|,
name|caplen
argument_list|)
condition|)
block|{
comment|/*  get a time stamp , consisting of :          *          *  pcap_header.ts.tv_sec:          *  ----------------------          *   a UNIX format time-in-seconds when he packet was captured,          *   i.e. the number of seconds since Epoch time (January 1,1970, 00:00:00 GMT)          *          *  pcap_header.ts.tv_usec :          *  ------------------------          *   the number of microseconds since that second          *   when the packet was captured          */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|pcap_header
operator|.
name|ts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fill in our own header data */
name|pcap_header
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pcap_header
operator|.
name|len
operator|=
name|packet_len
expr_stmt|;
comment|/* Count the packet. */
name|ps
operator|->
name|stat
operator|.
name|ps_recv
operator|++
expr_stmt|;
comment|/* Call the user supplied callback function */
name|callback
argument_list|(
name|user
argument_list|,
operator|&
name|pcap_header
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|processed
operator|++
expr_stmt|;
block|}
comment|/* after being processed the packet must be        *released in order to receive another one */
name|relm
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
else|else
name|processed
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|processed
operator|<
name|cnt
condition|)
do|;
return|return
name|processed
return|;
block|}
decl|static
name|int
name|septel_inject
argument_list|(
name|pcap_t
operator|*
name|handle
argument_list|,
specifier|const
name|void
operator|*
name|buf
name|_U_
argument_list|,
name|size_t
name|size
name|_U_
argument_list|)
block|{
name|strlcpy
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
literal|"Sending packets isn't supported on Septel cards"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *  Activate a handle for a live capture from the given Septel device.  Always pass a NULL device  *  The promisc flag is ignored because Septel cards have built-in tracing.  *  The timeout is also ignored as it is not supported in hardware.  *  *  See also pcap(3).  */
decl|static
name|pcap_t
modifier|*
name|septel_activate
argument_list|(
name|pcap_t
operator|*
name|handle
argument_list|)
block|{
comment|/* Initialize some components of the pcap structure. */
name|handle
operator|->
name|linktype
operator|=
name|DLT_MTP2
expr_stmt|;
name|handle
operator|->
name|bufsize
operator|=
literal|0
expr_stmt|;
comment|/*    * "select()" and "poll()" don't work on Septel queues    */
name|handle
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|handle
operator|->
name|read_op
operator|=
name|septel_read
expr_stmt|;
name|handle
operator|->
name|inject_op
operator|=
name|septel_inject
expr_stmt|;
name|handle
operator|->
name|setfilter_op
operator|=
name|septel_setfilter
expr_stmt|;
name|handle
operator|->
name|set_datalink_op
operator|=
name|NULL
expr_stmt|;
comment|/* can't change data link type */
name|handle
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|handle
operator|->
name|setnonblock_op
operator|=
name|septel_setnonblock
expr_stmt|;
name|handle
operator|->
name|stats_op
operator|=
name|septel_stats
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pcap_t
modifier|*
name|septel_create
argument_list|(
specifier|const
name|char
operator|*
name|device
argument_list|,
name|char
operator|*
name|ebuf
argument_list|,
name|int
operator|*
name|is_ours
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
comment|/* Does this look like the Septel device? */
name|cp
operator|=
name|strrchr
argument_list|(
name|device
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|device
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"septel"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Nope, it's not "septel" */
operator|*
name|is_ours
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* OK, it's probably ours. */
operator|*
name|is_ours
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_septel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|->
name|activate_op
operator|=
name|septel_activate
expr_stmt|;
return|return
name|p
return|;
block|}
decl|static
name|int
name|septel_stats
argument_list|(
name|pcap_t
operator|*
name|p
argument_list|,
expr|struct
name|pcap_stat
operator|*
name|ps
argument_list|)
block|{
name|struct
name|pcap_septel
modifier|*
name|handlep
init|=
name|p
operator|->
name|priv
decl_stmt|;
comment|/*handlep->stat.ps_recv = 0;*/
comment|/*handlep->stat.ps_drop = 0;*/
operator|*
name|ps
operator|=
name|handlep
operator|->
name|stat
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|septel_findalldevs
argument_list|(
name|pcap_if_t
operator|*
operator|*
name|devlistp
argument_list|,
name|char
operator|*
name|errbuf
argument_list|)
block|{
return|return
operator|(
name|pcap_add_if
argument_list|(
name|devlistp
argument_list|,
literal|"septel"
argument_list|,
literal|0
argument_list|,
literal|"Intel/Septel device"
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/*  * Installs the given bpf filter program in the given pcap structure.  There is  * no attempt to store the filter in kernel memory as that is not supported  * with Septel cards.  */
decl|static
name|int
name|septel_setfilter
argument_list|(
name|pcap_t
operator|*
name|p
argument_list|,
expr|struct
name|bpf_program
operator|*
name|fp
argument_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|strncpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"setfilter: No filter specified"
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make our private copy of the filter */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
decl|static
name|int
name|septel_setnonblock
argument_list|(
name|pcap_t
operator|*
name|p
argument_list|,
name|int
name|nonblock
argument_list|,
name|char
operator|*
name|errbuf
argument_list|)
block|{
name|fprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Non-blocking mode not supported on Septel devices"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SEPTEL_ONLY
comment|/*  * This libpcap build supports only Septel cards, not regular network  * interfaces.  */
comment|/*  * There are no regular interfaces, just Septel interfaces.  */
name|int
name|pcap_platform_finddevs
argument_list|(
name|pcap_if_t
operator|*
operator|*
name|alldevsp
argument_list|,
name|char
operator|*
name|errbuf
argument_list|)
block|{
operator|*
name|alldevsp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Attempts to open a regular interface fail.  */
name|pcap_t
modifier|*
name|pcap_create_interface
argument_list|(
specifier|const
name|char
operator|*
name|device
argument_list|,
name|char
operator|*
name|errbuf
argument_list|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"This version of libpcap only supports Septel cards"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
end_struct

end_unit

