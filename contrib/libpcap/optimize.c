begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994, 1995, 1996  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *  Optimization module for tcpdump intermediate representation.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/optimize.c,v 1.67 2000/11/19 13:37:20 itojun Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"gencode.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|A_ATOM
value|BPF_MEMWORDS
end_define

begin_define
define|#
directive|define
name|X_ATOM
value|(BPF_MEMWORDS+1)
end_define

begin_define
define|#
directive|define
name|NOP
value|-1
end_define

begin_comment
comment|/*  * This define is used to represent *both* the accumulator and  * x register in use-def computations.  * Currently, the use-def code assumes only one definition per instruction.  */
end_comment

begin_define
define|#
directive|define
name|AX_ATOM
value|N_ATOMS
end_define

begin_comment
comment|/*  * A flag to indicate that further optimization is needed.  * Iterative passes are continued until a given pass yields no  * branch movement.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A block is marked if only if its mark equals the current mark.  * Rather than traverse the code array, marking each item, 'cur_mark' is  * incremented.  This automatically makes each element unmarked.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_mark
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|isMarked
parameter_list|(
name|p
parameter_list|)
value|((p)->mark == cur_mark)
end_define

begin_define
define|#
directive|define
name|unMarkAll
parameter_list|()
value|cur_mark += 1
end_define

begin_define
define|#
directive|define
name|Mark
parameter_list|(
name|p
parameter_list|)
value|((p)->mark = cur_mark)
end_define

begin_function_decl
specifier|static
name|void
name|opt_init
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_marks
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_code
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intern_blocks
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eq_slist
parameter_list|(
name|struct
name|slist
modifier|*
parameter_list|,
name|struct
name|slist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_levels_r
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_levels
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_dom
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propedom
parameter_list|(
name|struct
name|edge
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_edom
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_closure
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atomuse
parameter_list|(
name|struct
name|stmt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atomdef
parameter_list|(
name|struct
name|stmt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_local_ud
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_ud
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_val
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|F
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|vstore
parameter_list|(
name|struct
name|stmt
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_blk
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|use_conflict
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_j
parameter_list|(
name|struct
name|edge
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|or_pullup
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|and_pullup
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_blks
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|link_inedge
parameter_list|(
name|struct
name|edge
modifier|*
parameter_list|,
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_inedges
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_root
parameter_list|(
name|struct
name|block
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_loop
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fold_op
parameter_list|(
name|struct
name|stmt
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|slist
modifier|*
name|this_op
parameter_list|(
name|struct
name|slist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_not
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_peep
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_stmt
parameter_list|(
name|struct
name|stmt
modifier|*
parameter_list|,
name|int
index|[]
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|deadstmt
parameter_list|(
name|struct
name|stmt
modifier|*
parameter_list|,
name|struct
name|stmt
modifier|*
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_deadstores
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_blk
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|use_conflict
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_j
parameter_list|(
name|struct
name|edge
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|block
modifier|*
name|fold_edge
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|struct
name|edge
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|eq_blk
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|slength
parameter_list|(
name|struct
name|slist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_blocks
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|number_blks_r
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_stmts
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|convert_code_r
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|opt_dump
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|n_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|block
modifier|*
modifier|*
name|blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_edges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|edge
modifier|*
modifier|*
name|edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A bit vector set representation of the dominators.  * We round up the set size to the next power of two.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nodewords
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|edgewords
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|block
modifier|*
modifier|*
name|levels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bpf_u_int32
modifier|*
name|space
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BITS_PER_WORD
value|(8*sizeof(bpf_u_int32))
end_define

begin_comment
comment|/*  * True if a is in uset {p}  */
end_comment

begin_define
define|#
directive|define
name|SET_MEMBER
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
define|\
value|((p)[(unsigned)(a) / BITS_PER_WORD]& (1<< ((unsigned)(a) % BITS_PER_WORD)))
end_define

begin_comment
comment|/*  * Add 'a' to uset p.  */
end_comment

begin_define
define|#
directive|define
name|SET_INSERT
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
define|\
value|(p)[(unsigned)(a) / BITS_PER_WORD] |= (1<< ((unsigned)(a) % BITS_PER_WORD))
end_define

begin_comment
comment|/*  * Delete 'a' from uset p.  */
end_comment

begin_define
define|#
directive|define
name|SET_DELETE
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
define|\
value|(p)[(unsigned)(a) / BITS_PER_WORD]&= ~(1<< ((unsigned)(a) % BITS_PER_WORD))
end_define

begin_comment
comment|/*  * a := a intersect b  */
end_comment

begin_define
define|#
directive|define
name|SET_INTERSECT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|{\ 	register bpf_u_int32 *_x = a, *_y = b;\ 	register int _n = n;\ 	while (--_n>= 0) *_x++&= *_y++;\ }
end_define

begin_comment
comment|/*  * a := a - b  */
end_comment

begin_define
define|#
directive|define
name|SET_SUBTRACT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|{\ 	register bpf_u_int32 *_x = a, *_y = b;\ 	register int _n = n;\ 	while (--_n>= 0) *_x++&=~ *_y++;\ }
end_define

begin_comment
comment|/*  * a := a union b  */
end_comment

begin_define
define|#
directive|define
name|SET_UNION
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|{\ 	register bpf_u_int32 *_x = a, *_y = b;\ 	register int _n = n;\ 	while (--_n>= 0) *_x++ |= *_y++;\ }
end_define

begin_decl_stmt
specifier|static
name|uset
name|all_dom_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uset
name|all_closure_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uset
name|all_edge_sets
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b)?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|find_levels_r
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
if|if
condition|(
name|isMarked
argument_list|(
name|b
argument_list|)
condition|)
return|return;
name|Mark
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|find_levels_r
argument_list|(
name|JT
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|find_levels_r
argument_list|(
name|JF
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|level
operator|=
name|MAX
argument_list|(
name|JT
argument_list|(
name|b
argument_list|)
operator|->
name|level
argument_list|,
name|JF
argument_list|(
name|b
argument_list|)
operator|->
name|level
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|level
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|b
operator|->
name|link
operator|=
name|levels
index|[
name|level
index|]
expr_stmt|;
name|levels
index|[
name|level
index|]
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Level graph.  The levels go from 0 at the leaves to  * N_LEVELS at the root.  The levels[] array points to the  * first node of the level list, whose elements are linked  * with the 'link' field of the struct block.  */
end_comment

begin_function
specifier|static
name|void
name|find_levels
parameter_list|(
name|root
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|levels
argument_list|,
literal|0
argument_list|,
name|n_blocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|levels
argument_list|)
argument_list|)
expr_stmt|;
name|unMarkAll
argument_list|()
expr_stmt|;
name|find_levels_r
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find dominator relationships.  * Assumes graph has been leveled.  */
end_comment

begin_function
specifier|static
name|void
name|find_dom
parameter_list|(
name|root
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|bpf_u_int32
modifier|*
name|x
decl_stmt|;
comment|/* 	 * Initialize sets to contain all nodes. 	 */
name|x
operator|=
name|all_dom_sets
expr_stmt|;
name|i
operator|=
name|n_blocks
operator|*
name|nodewords
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|x
operator|++
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* Root starts off empty. */
for|for
control|(
name|i
operator|=
name|nodewords
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|root
operator|->
name|dom
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* root->level is the highest level no found. */
for|for
control|(
name|i
operator|=
name|root
operator|->
name|level
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
for|for
control|(
name|b
operator|=
name|levels
index|[
name|i
index|]
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link
control|)
block|{
name|SET_INSERT
argument_list|(
name|b
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|b
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|SET_INTERSECT
argument_list|(
name|JT
argument_list|(
name|b
argument_list|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|dom
argument_list|,
name|nodewords
argument_list|)
expr_stmt|;
name|SET_INTERSECT
argument_list|(
name|JF
argument_list|(
name|b
argument_list|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|dom
argument_list|,
name|nodewords
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|propedom
parameter_list|(
name|ep
parameter_list|)
name|struct
name|edge
modifier|*
name|ep
decl_stmt|;
block|{
name|SET_INSERT
argument_list|(
name|ep
operator|->
name|edom
argument_list|,
name|ep
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|succ
condition|)
block|{
name|SET_INTERSECT
argument_list|(
name|ep
operator|->
name|succ
operator|->
name|et
operator|.
name|edom
argument_list|,
name|ep
operator|->
name|edom
argument_list|,
name|edgewords
argument_list|)
expr_stmt|;
name|SET_INTERSECT
argument_list|(
name|ep
operator|->
name|succ
operator|->
name|ef
operator|.
name|edom
argument_list|,
name|ep
operator|->
name|edom
argument_list|,
name|edgewords
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute edge dominators.  * Assumes graph has been leveled and predecessors established.  */
end_comment

begin_function
specifier|static
name|void
name|find_edom
parameter_list|(
name|root
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|uset
name|x
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|x
operator|=
name|all_edge_sets
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_edges
operator|*
name|edgewords
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|x
index|[
name|i
index|]
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* root->level is the highest level no found. */
name|memset
argument_list|(
name|root
operator|->
name|et
operator|.
name|edom
argument_list|,
literal|0
argument_list|,
name|edgewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|uset
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|root
operator|->
name|ef
operator|.
name|edom
argument_list|,
literal|0
argument_list|,
name|edgewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|uset
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|root
operator|->
name|level
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
for|for
control|(
name|b
operator|=
name|levels
index|[
name|i
index|]
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|link
control|)
block|{
name|propedom
argument_list|(
operator|&
name|b
operator|->
name|et
argument_list|)
expr_stmt|;
name|propedom
argument_list|(
operator|&
name|b
operator|->
name|ef
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Find the backwards transitive closure of the flow graph.  These sets  * are backwards in the sense that we find the set of nodes that reach  * a given node, not the set of nodes that can be reached by a node.  *  * Assumes graph has been leveled.  */
end_comment

begin_function
specifier|static
name|void
name|find_closure
parameter_list|(
name|root
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
comment|/* 	 * Initialize sets to contain no nodes. 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|all_closure_sets
argument_list|,
literal|0
argument_list|,
name|n_blocks
operator|*
name|nodewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|all_closure_sets
argument_list|)
argument_list|)
expr_stmt|;
comment|/* root->level is the highest level no found. */
for|for
control|(
name|i
operator|=
name|root
operator|->
name|level
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
for|for
control|(
name|b
operator|=
name|levels
index|[
name|i
index|]
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link
control|)
block|{
name|SET_INSERT
argument_list|(
name|b
operator|->
name|closure
argument_list|,
name|b
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|b
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|SET_UNION
argument_list|(
name|JT
argument_list|(
name|b
argument_list|)
operator|->
name|closure
argument_list|,
name|b
operator|->
name|closure
argument_list|,
name|nodewords
argument_list|)
expr_stmt|;
name|SET_UNION
argument_list|(
name|JF
argument_list|(
name|b
argument_list|)
operator|->
name|closure
argument_list|,
name|b
operator|->
name|closure
argument_list|,
name|nodewords
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return the register number that is used by s.  If A and X are both  * used, return AX_ATOM.  If no register is used, return -1.  *  * The implementation should probably change to an array access.  */
end_comment

begin_function
specifier|static
name|int
name|atomuse
parameter_list|(
name|s
parameter_list|)
name|struct
name|stmt
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
name|s
operator|->
name|code
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NOP
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|BPF_CLASS
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|BPF_RET
case|:
return|return
operator|(
name|BPF_RVAL
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_A
operator|)
condition|?
name|A_ATOM
else|:
operator|(
name|BPF_RVAL
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_X
operator|)
condition|?
name|X_ATOM
else|:
operator|-
literal|1
return|;
case|case
name|BPF_LD
case|:
case|case
name|BPF_LDX
case|:
return|return
operator|(
name|BPF_MODE
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_IND
operator|)
condition|?
name|X_ATOM
else|:
operator|(
name|BPF_MODE
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_MEM
operator|)
condition|?
name|s
operator|->
name|k
else|:
operator|-
literal|1
return|;
case|case
name|BPF_ST
case|:
return|return
name|A_ATOM
return|;
case|case
name|BPF_STX
case|:
return|return
name|X_ATOM
return|;
case|case
name|BPF_JMP
case|:
case|case
name|BPF_ALU
case|:
if|if
condition|(
name|BPF_SRC
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_X
condition|)
return|return
name|AX_ATOM
return|;
return|return
name|A_ATOM
return|;
case|case
name|BPF_MISC
case|:
return|return
name|BPF_MISCOP
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_TXA
condition|?
name|X_ATOM
else|:
name|A_ATOM
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Return the register number that is defined by 's'.  We assume that  * a single stmt cannot define more than one register.  If no register  * is defined, return -1.  *  * The implementation should probably change to an array access.  */
end_comment

begin_function
specifier|static
name|int
name|atomdef
parameter_list|(
name|s
parameter_list|)
name|struct
name|stmt
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|code
operator|==
name|NOP
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|BPF_CLASS
argument_list|(
name|s
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_LD
case|:
case|case
name|BPF_ALU
case|:
return|return
name|A_ATOM
return|;
case|case
name|BPF_LDX
case|:
return|return
name|X_ATOM
return|;
case|case
name|BPF_ST
case|:
case|case
name|BPF_STX
case|:
return|return
name|s
operator|->
name|k
return|;
case|case
name|BPF_MISC
case|:
return|return
name|BPF_MISCOP
argument_list|(
name|s
operator|->
name|code
argument_list|)
operator|==
name|BPF_TAX
condition|?
name|X_ATOM
else|:
name|A_ATOM
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|compute_local_ud
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
name|atomset
name|def
init|=
literal|0
decl_stmt|,
name|use
init|=
literal|0
decl_stmt|,
name|kill
init|=
literal|0
decl_stmt|;
name|int
name|atom
decl_stmt|;
for|for
control|(
name|s
operator|=
name|b
operator|->
name|stmts
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
continue|continue;
name|atom
operator|=
name|atomuse
argument_list|(
operator|&
name|s
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|atom
operator|==
name|AX_ATOM
condition|)
block|{
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|X_ATOM
argument_list|)
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|X_ATOM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|A_ATOM
argument_list|)
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|A_ATOM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|<
name|N_ATOMS
condition|)
block|{
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|atom
argument_list|)
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|atom
operator|=
name|atomdef
argument_list|(
operator|&
name|s
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|use
argument_list|,
name|atom
argument_list|)
condition|)
name|kill
operator||=
name|ATOMMASK
argument_list|(
name|atom
argument_list|)
expr_stmt|;
name|def
operator||=
name|ATOMMASK
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|A_ATOM
argument_list|)
operator|&&
name|BPF_CLASS
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_JMP
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|A_ATOM
argument_list|)
expr_stmt|;
name|b
operator|->
name|def
operator|=
name|def
expr_stmt|;
name|b
operator|->
name|kill
operator|=
name|kill
expr_stmt|;
name|b
operator|->
name|in_use
operator|=
name|use
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assume graph is already leveled.  */
end_comment

begin_function
specifier|static
name|void
name|find_ud
parameter_list|(
name|root
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|maxlevel
decl_stmt|;
name|struct
name|block
modifier|*
name|p
decl_stmt|;
comment|/* 	 * root->level is the highest level no found; 	 * count down from there. 	 */
name|maxlevel
operator|=
name|root
operator|->
name|level
expr_stmt|;
for|for
control|(
name|i
operator|=
name|maxlevel
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
for|for
control|(
name|p
operator|=
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|compute_local_ud
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|out_use
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxlevel
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|p
operator|=
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|p
operator|->
name|out_use
operator||=
name|JT
argument_list|(
name|p
argument_list|)
operator|->
name|in_use
operator||
name|JF
argument_list|(
name|p
argument_list|)
operator|->
name|in_use
expr_stmt|;
name|p
operator|->
name|in_use
operator||=
name|p
operator|->
name|out_use
operator|&
operator|~
name|p
operator|->
name|kill
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * These data structures are used in a Cocke and Shwarz style  * value numbering scheme.  Since the flowgraph is acyclic,  * exit values can be propagated from a node's predecessors  * provided it is uniquely defined.  */
end_comment

begin_struct
struct|struct
name|valnode
block|{
name|int
name|code
decl_stmt|;
name|int
name|v0
decl_stmt|,
name|v1
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|valnode
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MODULUS
value|213
end_define

begin_decl_stmt
specifier|static
name|struct
name|valnode
modifier|*
name|hashtbl
index|[
name|MODULUS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Integer constants mapped with the load immediate opcode. */
end_comment

begin_define
define|#
directive|define
name|K
parameter_list|(
name|i
parameter_list|)
value|F(BPF_LD|BPF_IMM|BPF_W, i, 0L)
end_define

begin_struct
struct|struct
name|vmapinfo
block|{
name|int
name|is_const
decl_stmt|;
name|bpf_int32
name|const_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|vmapinfo
modifier|*
name|vmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|valnode
modifier|*
name|vnode_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|valnode
modifier|*
name|next_vnode
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_val
parameter_list|()
block|{
name|curval
operator|=
literal|0
expr_stmt|;
name|next_vnode
operator|=
name|vnode_base
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vmap
argument_list|,
literal|0
argument_list|,
name|maxval
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vmap
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hashtbl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|hashtbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Because we really don't have an IR, this stuff is a little messy. */
end_comment

begin_function
specifier|static
name|int
name|F
parameter_list|(
name|code
parameter_list|,
name|v0
parameter_list|,
name|v1
parameter_list|)
name|int
name|code
decl_stmt|;
name|int
name|v0
decl_stmt|,
name|v1
decl_stmt|;
block|{
name|u_int
name|hash
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|valnode
modifier|*
name|p
decl_stmt|;
name|hash
operator|=
operator|(
name|u_int
operator|)
name|code
operator|^
operator|(
name|v0
operator|<<
literal|4
operator|)
operator|^
operator|(
name|v1
operator|<<
literal|8
operator|)
expr_stmt|;
name|hash
operator|%=
name|MODULUS
expr_stmt|;
for|for
control|(
name|p
operator|=
name|hashtbl
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|code
operator|==
name|code
operator|&&
name|p
operator|->
name|v0
operator|==
name|v0
operator|&&
name|p
operator|->
name|v1
operator|==
name|v1
condition|)
return|return
name|p
operator|->
name|val
return|;
name|val
operator|=
operator|++
name|curval
expr_stmt|;
if|if
condition|(
name|BPF_MODE
argument_list|(
name|code
argument_list|)
operator|==
name|BPF_IMM
operator|&&
operator|(
name|BPF_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|BPF_LD
operator|||
name|BPF_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|BPF_LDX
operator|)
condition|)
block|{
name|vmap
index|[
name|val
index|]
operator|.
name|const_val
operator|=
name|v0
expr_stmt|;
name|vmap
index|[
name|val
index|]
operator|.
name|is_const
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|next_vnode
operator|++
expr_stmt|;
name|p
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|p
operator|->
name|v0
operator|=
name|v0
expr_stmt|;
name|p
operator|->
name|v1
operator|=
name|v1
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|hashtbl
index|[
name|hash
index|]
expr_stmt|;
name|hashtbl
index|[
name|hash
index|]
operator|=
name|p
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|vstore
parameter_list|(
name|s
parameter_list|,
name|valp
parameter_list|,
name|newval
parameter_list|,
name|alter
parameter_list|)
name|struct
name|stmt
modifier|*
name|s
decl_stmt|;
name|int
modifier|*
name|valp
decl_stmt|;
name|int
name|newval
decl_stmt|;
name|int
name|alter
decl_stmt|;
block|{
if|if
condition|(
name|alter
operator|&&
operator|*
name|valp
operator|==
name|newval
condition|)
name|s
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
else|else
operator|*
name|valp
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fold_op
parameter_list|(
name|s
parameter_list|,
name|v0
parameter_list|,
name|v1
parameter_list|)
name|struct
name|stmt
modifier|*
name|s
decl_stmt|;
name|int
name|v0
decl_stmt|,
name|v1
decl_stmt|;
block|{
name|bpf_int32
name|a
decl_stmt|,
name|b
decl_stmt|;
name|a
operator|=
name|vmap
index|[
name|v0
index|]
operator|.
name|const_val
expr_stmt|;
name|b
operator|=
name|vmap
index|[
name|v1
index|]
operator|.
name|const_val
expr_stmt|;
switch|switch
condition|(
name|BPF_OP
argument_list|(
name|s
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_ADD
case|:
name|a
operator|+=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_SUB
case|:
name|a
operator|-=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_MUL
case|:
name|a
operator|*=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_DIV
case|:
if|if
condition|(
name|b
operator|==
literal|0
condition|)
name|bpf_error
argument_list|(
literal|"division by zero"
argument_list|)
expr_stmt|;
name|a
operator|/=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_AND
case|:
name|a
operator|&=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_OR
case|:
name|a
operator||=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_LSH
case|:
name|a
operator|<<=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_RSH
case|:
name|a
operator|>>=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_NEG
case|:
name|a
operator|=
operator|-
name|a
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|s
operator|->
name|k
operator|=
name|a
expr_stmt|;
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|slist
modifier|*
name|this_op
parameter_list|(
name|s
parameter_list|)
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
name|s
operator|!=
literal|0
operator|&&
name|s
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_not
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|block
modifier|*
name|tmp
init|=
name|JT
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|JT
argument_list|(
name|b
argument_list|)
operator|=
name|JF
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|JF
argument_list|(
name|b
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_peep
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
name|struct
name|slist
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|val
decl_stmt|;
name|s
operator|=
name|b
operator|->
name|stmts
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
name|last
operator|=
name|s
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|s
operator|=
name|this_op
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
break|break;
name|next
operator|=
name|this_op
argument_list|(
name|s
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
break|break;
name|last
operator|=
name|next
expr_stmt|;
comment|/* 		 * st  M[k]	-->	st  M[k] 		 * ldx M[k]		tax 		 */
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|==
name|BPF_ST
operator|&&
name|next
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_LDX
operator||
name|BPF_MEM
operator|)
operator|&&
name|s
operator|->
name|s
operator|.
name|k
operator|==
name|next
operator|->
name|s
operator|.
name|k
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_MISC
operator||
name|BPF_TAX
expr_stmt|;
block|}
comment|/* 		 * ld  #k	-->	ldx  #k 		 * tax			txa 		 */
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_LD
operator||
name|BPF_IMM
operator|)
operator|&&
name|next
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_MISC
operator||
name|BPF_TAX
operator|)
condition|)
block|{
name|s
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_LDX
operator||
name|BPF_IMM
expr_stmt|;
name|next
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_MISC
operator||
name|BPF_TXA
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * This is an ugly special case, but it happens 		 * when you say tcp[k] or udp[k] where k is a constant. 		 */
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_LD
operator||
name|BPF_IMM
operator|)
condition|)
block|{
name|struct
name|slist
modifier|*
name|add
decl_stmt|,
modifier|*
name|tax
decl_stmt|,
modifier|*
name|ild
decl_stmt|;
comment|/* 			 * Check that X isn't used on exit from this 			 * block (which the optimizer might cause). 			 * We know the code generator won't generate 			 * any local dependencies. 			 */
if|if
condition|(
name|ATOMELEM
argument_list|(
name|b
operator|->
name|out_use
argument_list|,
name|X_ATOM
argument_list|)
condition|)
break|break;
if|if
condition|(
name|next
operator|->
name|s
operator|.
name|code
operator|!=
operator|(
name|BPF_LDX
operator||
name|BPF_MSH
operator||
name|BPF_B
operator|)
condition|)
name|add
operator|=
name|next
expr_stmt|;
else|else
name|add
operator|=
name|this_op
argument_list|(
name|next
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|==
literal|0
operator|||
name|add
operator|->
name|s
operator|.
name|code
operator|!=
operator|(
name|BPF_ALU
operator||
name|BPF_ADD
operator||
name|BPF_X
operator|)
condition|)
break|break;
name|tax
operator|=
name|this_op
argument_list|(
name|add
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tax
operator|==
literal|0
operator|||
name|tax
operator|->
name|s
operator|.
name|code
operator|!=
operator|(
name|BPF_MISC
operator||
name|BPF_TAX
operator|)
condition|)
break|break;
name|ild
operator|=
name|this_op
argument_list|(
name|tax
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ild
operator|==
literal|0
operator|||
name|BPF_CLASS
argument_list|(
name|ild
operator|->
name|s
operator|.
name|code
argument_list|)
operator|!=
name|BPF_LD
operator|||
name|BPF_MODE
argument_list|(
name|ild
operator|->
name|s
operator|.
name|code
argument_list|)
operator|!=
name|BPF_IND
condition|)
break|break;
comment|/* 			 * XXX We need to check that X is not 			 * subsequently used.  We know we can eliminate the 			 * accumulator modifications since it is defined 			 * by the last stmt of this sequence. 			 * 			 * We want to turn this sequence: 			 * 			 * (004) ldi     #0x2		{s} 			 * (005) ldxms   [14]		{next}  -- optional 			 * (006) addx			{add} 			 * (007) tax			{tax} 			 * (008) ild     [x+0]		{ild} 			 * 			 * into this sequence: 			 * 			 * (004) nop 			 * (005) ldxms   [14] 			 * (006) nop 			 * (007) nop 			 * (008) ild     [x+2] 			 * 			 */
name|ild
operator|->
name|s
operator|.
name|k
operator|+=
name|s
operator|->
name|s
operator|.
name|k
expr_stmt|;
name|s
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|add
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|tax
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	 * If we have a subtract to do a comparison, and the X register 	 * is a known constant, we can merge this value into the 	 * comparison. 	 */
if|if
condition|(
name|last
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_ALU
operator||
name|BPF_SUB
operator||
name|BPF_X
operator|)
operator|&&
operator|!
name|ATOMELEM
argument_list|(
name|b
operator|->
name|out_use
argument_list|,
name|A_ATOM
argument_list|)
condition|)
block|{
name|val
operator|=
name|b
operator|->
name|val
index|[
name|X_ATOM
index|]
expr_stmt|;
if|if
condition|(
name|vmap
index|[
name|val
index|]
operator|.
name|is_const
condition|)
block|{
name|int
name|op
decl_stmt|;
name|b
operator|->
name|s
operator|.
name|k
operator|+=
name|vmap
index|[
name|val
index|]
operator|.
name|const_val
expr_stmt|;
name|op
operator|=
name|BPF_OP
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|BPF_JGT
operator|||
name|op
operator|==
name|BPF_JGE
condition|)
block|{
name|struct
name|block
modifier|*
name|t
init|=
name|JT
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|JT
argument_list|(
name|b
argument_list|)
operator|=
name|JF
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|JF
argument_list|(
name|b
argument_list|)
operator|=
name|t
expr_stmt|;
name|b
operator|->
name|s
operator|.
name|k
operator|+=
literal|0x80000000
expr_stmt|;
block|}
name|last
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|s
operator|.
name|k
operator|==
literal|0
condition|)
block|{
comment|/* 			 * sub x  ->	nop 			 * j  #0	j  x 			 */
name|last
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|b
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_CLASS
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator||
name|BPF_OP
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator||
name|BPF_X
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Likewise, a constant subtract can be simplified. 	 */
elseif|else
if|if
condition|(
name|last
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_ALU
operator||
name|BPF_SUB
operator||
name|BPF_K
operator|)
operator|&&
operator|!
name|ATOMELEM
argument_list|(
name|b
operator|->
name|out_use
argument_list|,
name|A_ATOM
argument_list|)
condition|)
block|{
name|int
name|op
decl_stmt|;
name|b
operator|->
name|s
operator|.
name|k
operator|+=
name|last
operator|->
name|s
operator|.
name|k
expr_stmt|;
name|last
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|op
operator|=
name|BPF_OP
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|BPF_JGT
operator|||
name|op
operator|==
name|BPF_JGE
condition|)
block|{
name|struct
name|block
modifier|*
name|t
init|=
name|JT
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|JT
argument_list|(
name|b
argument_list|)
operator|=
name|JF
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|JF
argument_list|(
name|b
argument_list|)
operator|=
name|t
expr_stmt|;
name|b
operator|->
name|s
operator|.
name|k
operator|+=
literal|0x80000000
expr_stmt|;
block|}
name|done
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * and #k	nop 	 * jeq #0  ->	jset #k 	 */
if|if
condition|(
name|last
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_ALU
operator||
name|BPF_AND
operator||
name|BPF_K
operator|)
operator|&&
operator|!
name|ATOMELEM
argument_list|(
name|b
operator|->
name|out_use
argument_list|,
name|A_ATOM
argument_list|)
operator|&&
name|b
operator|->
name|s
operator|.
name|k
operator|==
literal|0
condition|)
block|{
name|b
operator|->
name|s
operator|.
name|k
operator|=
name|last
operator|->
name|s
operator|.
name|k
expr_stmt|;
name|b
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_JMP
operator||
name|BPF_K
operator||
name|BPF_JSET
expr_stmt|;
name|last
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|opt_not
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the accumulator is a known constant, we can compute the 	 * comparison result. 	 */
name|val
operator|=
name|b
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
if|if
condition|(
name|vmap
index|[
name|val
index|]
operator|.
name|is_const
operator|&&
name|BPF_SRC
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_K
condition|)
block|{
name|bpf_int32
name|v
init|=
name|vmap
index|[
name|val
index|]
operator|.
name|const_val
decl_stmt|;
switch|switch
condition|(
name|BPF_OP
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_JEQ
case|:
name|v
operator|=
name|v
operator|==
name|b
operator|->
name|s
operator|.
name|k
expr_stmt|;
break|break;
case|case
name|BPF_JGT
case|:
name|v
operator|=
operator|(
name|unsigned
operator|)
name|v
operator|>
name|b
operator|->
name|s
operator|.
name|k
expr_stmt|;
break|break;
case|case
name|BPF_JGE
case|:
name|v
operator|=
operator|(
name|unsigned
operator|)
name|v
operator|>=
name|b
operator|->
name|s
operator|.
name|k
expr_stmt|;
break|break;
case|case
name|BPF_JSET
case|:
name|v
operator|&=
name|b
operator|->
name|s
operator|.
name|k
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|JF
argument_list|(
name|b
argument_list|)
operator|!=
name|JT
argument_list|(
name|b
argument_list|)
condition|)
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|JF
argument_list|(
name|b
argument_list|)
operator|=
name|JT
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
name|JT
argument_list|(
name|b
argument_list|)
operator|=
name|JF
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the symbolic value of expression of 's', and update  * anything it defines in the value table 'val'.  If 'alter' is true,  * do various optimizations.  This code would be cleaner if symbolic  * evaluation and code transformations weren't folded together.  */
end_comment

begin_function
specifier|static
name|void
name|opt_stmt
parameter_list|(
name|s
parameter_list|,
name|val
parameter_list|,
name|alter
parameter_list|)
name|struct
name|stmt
modifier|*
name|s
decl_stmt|;
name|int
name|val
index|[]
decl_stmt|;
name|int
name|alter
decl_stmt|;
block|{
name|int
name|op
decl_stmt|;
name|int
name|v
decl_stmt|;
switch|switch
condition|(
name|s
operator|->
name|code
condition|)
block|{
case|case
name|BPF_LD
operator||
name|BPF_ABS
operator||
name|BPF_W
case|:
case|case
name|BPF_LD
operator||
name|BPF_ABS
operator||
name|BPF_H
case|:
case|case
name|BPF_LD
operator||
name|BPF_ABS
operator||
name|BPF_B
case|:
name|v
operator|=
name|F
argument_list|(
name|s
operator|->
name|code
argument_list|,
name|s
operator|->
name|k
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LD
operator||
name|BPF_IND
operator||
name|BPF_W
case|:
case|case
name|BPF_LD
operator||
name|BPF_IND
operator||
name|BPF_H
case|:
case|case
name|BPF_LD
operator||
name|BPF_IND
operator||
name|BPF_B
case|:
name|v
operator|=
name|val
index|[
name|X_ATOM
index|]
expr_stmt|;
if|if
condition|(
name|alter
operator|&&
name|vmap
index|[
name|v
index|]
operator|.
name|is_const
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_ABS
operator||
name|BPF_SIZE
argument_list|(
name|s
operator|->
name|code
argument_list|)
expr_stmt|;
name|s
operator|->
name|k
operator|+=
name|vmap
index|[
name|v
index|]
operator|.
name|const_val
expr_stmt|;
name|v
operator|=
name|F
argument_list|(
name|s
operator|->
name|code
argument_list|,
name|s
operator|->
name|k
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|v
operator|=
name|F
argument_list|(
name|s
operator|->
name|code
argument_list|,
name|s
operator|->
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LD
operator||
name|BPF_LEN
case|:
name|v
operator|=
name|F
argument_list|(
name|s
operator|->
name|code
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LD
operator||
name|BPF_IMM
case|:
name|v
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LDX
operator||
name|BPF_IMM
case|:
name|v
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LDX
operator||
name|BPF_MSH
operator||
name|BPF_B
case|:
name|v
operator|=
name|F
argument_list|(
name|s
operator|->
name|code
argument_list|,
name|s
operator|->
name|k
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_ALU
operator||
name|BPF_NEG
case|:
if|if
condition|(
name|alter
operator|&&
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|is_const
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|s
operator|->
name|k
operator|=
operator|-
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|const_val
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
block|}
else|else
name|val
index|[
name|A_ATOM
index|]
operator|=
name|F
argument_list|(
name|s
operator|->
name|code
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_ALU
operator||
name|BPF_ADD
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_SUB
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_MUL
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_DIV
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_AND
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_OR
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_LSH
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_RSH
operator||
name|BPF_K
case|:
name|op
operator|=
name|BPF_OP
argument_list|(
name|s
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|alter
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|k
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|BPF_ADD
operator|||
name|op
operator|==
name|BPF_SUB
operator|||
name|op
operator|==
name|BPF_LSH
operator|||
name|op
operator|==
name|BPF_RSH
operator|||
name|op
operator|==
name|BPF_OR
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op
operator|==
name|BPF_MUL
operator|||
name|op
operator|==
name|BPF_AND
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|is_const
condition|)
block|{
name|fold_op
argument_list|(
name|s
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|val
index|[
name|A_ATOM
index|]
operator|=
name|F
argument_list|(
name|s
operator|->
name|code
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_ALU
operator||
name|BPF_ADD
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_SUB
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_MUL
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_DIV
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_AND
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_OR
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_LSH
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_RSH
operator||
name|BPF_X
case|:
name|op
operator|=
name|BPF_OP
argument_list|(
name|s
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|alter
operator|&&
name|vmap
index|[
name|val
index|[
name|X_ATOM
index|]
index|]
operator|.
name|is_const
condition|)
block|{
if|if
condition|(
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|is_const
condition|)
block|{
name|fold_op
argument_list|(
name|s
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|)
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|code
operator|=
name|BPF_ALU
operator||
name|BPF_K
operator||
name|op
expr_stmt|;
name|s
operator|->
name|k
operator|=
name|vmap
index|[
name|val
index|[
name|X_ATOM
index|]
index|]
operator|.
name|const_val
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|F
argument_list|(
name|s
operator|->
name|code
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Check if we're doing something to an accumulator 		 * that is 0, and simplify.  This may not seem like 		 * much of a simplification but it could open up further 		 * optimizations. 		 * XXX We could also check for mul by 1, and -1, etc. 		 */
if|if
condition|(
name|alter
operator|&&
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|is_const
operator|&&
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|const_val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|BPF_ADD
operator|||
name|op
operator|==
name|BPF_OR
operator|||
name|op
operator|==
name|BPF_LSH
operator|||
name|op
operator|==
name|BPF_RSH
operator|||
name|op
operator|==
name|BPF_SUB
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_MISC
operator||
name|BPF_TXA
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|BPF_MUL
operator|||
name|op
operator|==
name|BPF_DIV
operator|||
name|op
operator|==
name|BPF_AND
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|s
operator|->
name|k
operator|=
literal|0
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|BPF_NEG
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
break|break;
block|}
block|}
name|val
index|[
name|A_ATOM
index|]
operator|=
name|F
argument_list|(
name|s
operator|->
name|code
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_MISC
operator||
name|BPF_TXA
case|:
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LD
operator||
name|BPF_MEM
case|:
name|v
operator|=
name|val
index|[
name|s
operator|->
name|k
index|]
expr_stmt|;
if|if
condition|(
name|alter
operator|&&
name|vmap
index|[
name|v
index|]
operator|.
name|is_const
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|s
operator|->
name|k
operator|=
name|vmap
index|[
name|v
index|]
operator|.
name|const_val
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_MISC
operator||
name|BPF_TAX
case|:
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LDX
operator||
name|BPF_MEM
case|:
name|v
operator|=
name|val
index|[
name|s
operator|->
name|k
index|]
expr_stmt|;
if|if
condition|(
name|alter
operator|&&
name|vmap
index|[
name|v
index|]
operator|.
name|is_const
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LDX
operator||
name|BPF_IMM
expr_stmt|;
name|s
operator|->
name|k
operator|=
name|vmap
index|[
name|v
index|]
operator|.
name|const_val
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_ST
case|:
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|s
operator|->
name|k
index|]
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_STX
case|:
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|s
operator|->
name|k
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|deadstmt
parameter_list|(
name|s
parameter_list|,
name|last
parameter_list|)
specifier|register
name|struct
name|stmt
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|stmt
modifier|*
name|last
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|atom
decl_stmt|;
name|atom
operator|=
name|atomuse
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|atom
operator|==
name|AX_ATOM
condition|)
block|{
name|last
index|[
name|X_ATOM
index|]
operator|=
literal|0
expr_stmt|;
name|last
index|[
name|A_ATOM
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|last
index|[
name|atom
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|atom
operator|=
name|atomdef
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|last
index|[
name|atom
index|]
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
name|last
index|[
name|atom
index|]
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
block|}
name|last
index|[
name|atom
index|]
operator|=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|opt_deadstores
parameter_list|(
name|b
parameter_list|)
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|atom
decl_stmt|;
name|struct
name|stmt
modifier|*
name|last
index|[
name|N_ATOMS
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|last
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|last
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|b
operator|->
name|stmts
init|;
name|s
operator|!=
literal|0
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|deadstmt
argument_list|(
operator|&
name|s
operator|->
name|s
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|deadstmt
argument_list|(
operator|&
name|b
operator|->
name|s
argument_list|,
name|last
argument_list|)
expr_stmt|;
for|for
control|(
name|atom
operator|=
literal|0
init|;
name|atom
operator|<
name|N_ATOMS
condition|;
operator|++
name|atom
control|)
if|if
condition|(
name|last
index|[
name|atom
index|]
operator|&&
operator|!
name|ATOMELEM
argument_list|(
name|b
operator|->
name|out_use
argument_list|,
name|atom
argument_list|)
condition|)
block|{
name|last
index|[
name|atom
index|]
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|opt_blk
parameter_list|(
name|b
parameter_list|,
name|do_stmts
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|do_stmts
decl_stmt|;
block|{
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
name|struct
name|edge
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bpf_int32
name|aval
decl_stmt|;
if|#
directive|if
literal|0
block|for (s = b->stmts; s&& s->next; s = s->next) 		if (BPF_CLASS(s->s.code) == BPF_JMP) { 			do_stmts = 0; 			break; 		}
endif|#
directive|endif
comment|/* 	 * Initialize the atom values. 	 * If we have no predecessors, everything is undefined. 	 * Otherwise, we inherent our values from our predecessors. 	 * If any register has an ambiguous value (i.e. control paths are 	 * merging) give it the undefined value of 0. 	 */
name|p
operator|=
name|b
operator|->
name|in_edges
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|val
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|pred
operator|->
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_ATOMS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|b
operator|->
name|val
index|[
name|i
index|]
operator|!=
name|p
operator|->
name|pred
operator|->
name|val
index|[
name|i
index|]
condition|)
name|b
operator|->
name|val
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|aval
operator|=
name|b
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
for|for
control|(
name|s
operator|=
name|b
operator|->
name|stmts
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|opt_stmt
argument_list|(
operator|&
name|s
operator|->
name|s
argument_list|,
name|b
operator|->
name|val
argument_list|,
name|do_stmts
argument_list|)
expr_stmt|;
comment|/* 	 * This is a special case: if we don't use anything from this 	 * block, and we load the accumulator with value that is 	 * already there, or if this block is a return, 	 * eliminate all the statements. 	 */
if|if
condition|(
name|do_stmts
operator|&&
operator|(
operator|(
name|b
operator|->
name|out_use
operator|==
literal|0
operator|&&
name|aval
operator|!=
literal|0
operator|&&
name|b
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|==
name|aval
operator|)
operator|||
name|BPF_CLASS
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_RET
operator|)
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|stmts
operator|!=
literal|0
condition|)
block|{
name|b
operator|->
name|stmts
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|opt_peep
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|opt_deadstores
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up values for branch optimizer. 	 */
if|if
condition|(
name|BPF_SRC
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_K
condition|)
name|b
operator|->
name|oval
operator|=
name|K
argument_list|(
name|b
operator|->
name|s
operator|.
name|k
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|oval
operator|=
name|b
operator|->
name|val
index|[
name|X_ATOM
index|]
expr_stmt|;
name|b
operator|->
name|et
operator|.
name|code
operator|=
name|b
operator|->
name|s
operator|.
name|code
expr_stmt|;
name|b
operator|->
name|ef
operator|.
name|code
operator|=
operator|-
name|b
operator|->
name|s
operator|.
name|code
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return true if any register that is used on exit from 'succ', has  * an exit value that is different from the corresponding exit value  * from 'b'.  */
end_comment

begin_function
specifier|static
name|int
name|use_conflict
parameter_list|(
name|b
parameter_list|,
name|succ
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|,
decl|*
name|succ
decl_stmt|;
end_function

begin_block
block|{
name|int
name|atom
decl_stmt|;
name|atomset
name|use
init|=
name|succ
operator|->
name|out_use
decl_stmt|;
if|if
condition|(
name|use
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|atom
operator|=
literal|0
init|;
name|atom
operator|<
name|N_ATOMS
condition|;
operator|++
name|atom
control|)
if|if
condition|(
name|ATOMELEM
argument_list|(
name|use
argument_list|,
name|atom
argument_list|)
condition|)
if|if
condition|(
name|b
operator|->
name|val
index|[
name|atom
index|]
operator|!=
name|succ
operator|->
name|val
index|[
name|atom
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|struct
name|block
modifier|*
name|fold_edge
parameter_list|(
name|child
parameter_list|,
name|ep
parameter_list|)
name|struct
name|block
modifier|*
name|child
decl_stmt|;
name|struct
name|edge
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|sense
decl_stmt|;
name|int
name|aval0
decl_stmt|,
name|aval1
decl_stmt|,
name|oval0
decl_stmt|,
name|oval1
decl_stmt|;
name|int
name|code
init|=
name|ep
operator|->
name|code
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
name|code
operator|=
operator|-
name|code
expr_stmt|;
name|sense
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sense
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|s
operator|.
name|code
operator|!=
name|code
condition|)
return|return
literal|0
return|;
name|aval0
operator|=
name|child
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
name|oval0
operator|=
name|child
operator|->
name|oval
expr_stmt|;
name|aval1
operator|=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
name|oval1
operator|=
name|ep
operator|->
name|pred
operator|->
name|oval
expr_stmt|;
if|if
condition|(
name|aval0
operator|!=
name|aval1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|oval0
operator|==
name|oval1
condition|)
comment|/* 		 * The operands are identical, so the 		 * result is true if a true branch was 		 * taken to get here, otherwise false. 		 */
return|return
name|sense
condition|?
name|JT
argument_list|(
name|child
argument_list|)
else|:
name|JF
argument_list|(
name|child
argument_list|)
return|;
if|if
condition|(
name|sense
operator|&&
name|code
operator|==
operator|(
name|BPF_JMP
operator||
name|BPF_JEQ
operator||
name|BPF_K
operator|)
condition|)
comment|/* 		 * At this point, we only know the comparison if we 		 * came down the true branch, and it was an equality 		 * comparison with a constant.  We rely on the fact that 		 * distinct constants have distinct value numbers. 		 */
return|return
name|JF
argument_list|(
name|child
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_j
parameter_list|(
name|ep
parameter_list|)
name|struct
name|edge
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|ep
operator|->
name|succ
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
name|ep
operator|->
name|succ
argument_list|)
operator|==
name|JF
argument_list|(
name|ep
operator|->
name|succ
argument_list|)
condition|)
block|{
comment|/* 		 * Common branch targets can be eliminated, provided 		 * there is no data dependency. 		 */
if|if
condition|(
operator|!
name|use_conflict
argument_list|(
name|ep
operator|->
name|pred
argument_list|,
name|ep
operator|->
name|succ
operator|->
name|et
operator|.
name|succ
argument_list|)
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|succ
operator|=
name|JT
argument_list|(
name|ep
operator|->
name|succ
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For each edge dominator that matches the successor of this 	 * edge, promote the edge successor to the its grandchild. 	 * 	 * XXX We violate the set abstraction here in favor a reasonably 	 * efficient loop. 	 */
name|top
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edgewords
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|bpf_u_int32
name|x
init|=
name|ep
operator|->
name|edom
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|k
operator|=
name|ffs
argument_list|(
name|x
argument_list|)
operator|-
literal|1
expr_stmt|;
name|x
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|k
operator|)
expr_stmt|;
name|k
operator|+=
name|i
operator|*
name|BITS_PER_WORD
expr_stmt|;
name|target
operator|=
name|fold_edge
argument_list|(
name|ep
operator|->
name|succ
argument_list|,
name|edges
index|[
name|k
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * Check that there is no data dependency between 			 * nodes that will be violated if we move the edge. 			 */
if|if
condition|(
name|target
operator|!=
literal|0
operator|&&
operator|!
name|use_conflict
argument_list|(
name|ep
operator|->
name|pred
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|succ
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|target
argument_list|)
operator|!=
literal|0
condition|)
comment|/* 					 * Start over unless we hit a leaf. 					 */
goto|goto
name|top
goto|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|or_pullup
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|val
decl_stmt|,
name|at_top
decl_stmt|;
name|struct
name|block
modifier|*
name|pull
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|diffp
decl_stmt|,
modifier|*
modifier|*
name|samep
decl_stmt|;
name|struct
name|edge
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|b
operator|->
name|in_edges
expr_stmt|;
if|if
condition|(
name|ep
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Make sure each predecessor loads the same value. 	 * XXX why? 	 */
name|val
operator|=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|ep
operator|->
name|next
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
if|if
condition|(
name|val
operator|!=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
operator|==
name|b
condition|)
name|diffp
operator|=
operator|&
name|JT
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
expr_stmt|;
else|else
name|diffp
operator|=
operator|&
name|JF
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
expr_stmt|;
name|at_top
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|diffp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
operator|*
name|diffp
argument_list|)
operator|!=
name|JT
argument_list|(
name|b
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|SET_MEMBER
argument_list|(
operator|(
operator|*
name|diffp
operator|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|diffp
operator|)
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|!=
name|val
condition|)
break|break;
name|diffp
operator|=
operator|&
name|JF
argument_list|(
operator|*
name|diffp
argument_list|)
expr_stmt|;
name|at_top
operator|=
literal|0
expr_stmt|;
block|}
name|samep
operator|=
operator|&
name|JF
argument_list|(
operator|*
name|diffp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|samep
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
operator|*
name|samep
argument_list|)
operator|!=
name|JT
argument_list|(
name|b
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|SET_MEMBER
argument_list|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|==
name|val
condition|)
break|break;
comment|/* XXX Need to check that there are no data dependencies 		   between dp0 and dp1.  Currently, the code generator 		   will not produce such dependencies. */
name|samep
operator|=
operator|&
name|JF
argument_list|(
operator|*
name|samep
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* XXX This doesn't cover everything. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_ATOMS
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|val
index|[
name|i
index|]
operator|!=
name|pred
operator|->
name|val
index|[
name|i
index|]
condition|)
return|return;
endif|#
directive|endif
comment|/* Pull up the node. */
name|pull
operator|=
operator|*
name|samep
expr_stmt|;
operator|*
name|samep
operator|=
name|JF
argument_list|(
name|pull
argument_list|)
expr_stmt|;
name|JF
argument_list|(
name|pull
argument_list|)
operator|=
operator|*
name|diffp
expr_stmt|;
comment|/* 	 * At the top of the chain, each predecessor needs to point at the 	 * pulled up node.  Inside the chain, there is only one predecessor 	 * to worry about. 	 */
if|if
condition|(
name|at_top
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|b
operator|->
name|in_edges
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
block|{
if|if
condition|(
name|JT
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|==
name|b
condition|)
name|JT
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|=
name|pull
expr_stmt|;
else|else
name|JF
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|=
name|pull
expr_stmt|;
block|}
block|}
else|else
operator|*
name|diffp
operator|=
name|pull
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|and_pullup
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|val
decl_stmt|,
name|at_top
decl_stmt|;
name|struct
name|block
modifier|*
name|pull
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|diffp
decl_stmt|,
modifier|*
modifier|*
name|samep
decl_stmt|;
name|struct
name|edge
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|b
operator|->
name|in_edges
expr_stmt|;
if|if
condition|(
name|ep
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Make sure each predecessor loads the same value. 	 */
name|val
operator|=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|ep
operator|->
name|next
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
if|if
condition|(
name|val
operator|!=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
operator|==
name|b
condition|)
name|diffp
operator|=
operator|&
name|JT
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
expr_stmt|;
else|else
name|diffp
operator|=
operator|&
name|JF
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
expr_stmt|;
name|at_top
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|diffp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JF
argument_list|(
operator|*
name|diffp
argument_list|)
operator|!=
name|JF
argument_list|(
name|b
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|SET_MEMBER
argument_list|(
operator|(
operator|*
name|diffp
operator|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|diffp
operator|)
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|!=
name|val
condition|)
break|break;
name|diffp
operator|=
operator|&
name|JT
argument_list|(
operator|*
name|diffp
argument_list|)
expr_stmt|;
name|at_top
operator|=
literal|0
expr_stmt|;
block|}
name|samep
operator|=
operator|&
name|JT
argument_list|(
operator|*
name|diffp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|samep
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JF
argument_list|(
operator|*
name|samep
argument_list|)
operator|!=
name|JF
argument_list|(
name|b
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|SET_MEMBER
argument_list|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|==
name|val
condition|)
break|break;
comment|/* XXX Need to check that there are no data dependencies 		   between diffp and samep.  Currently, the code generator 		   will not produce such dependencies. */
name|samep
operator|=
operator|&
name|JT
argument_list|(
operator|*
name|samep
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* XXX This doesn't cover everything. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_ATOMS
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|val
index|[
name|i
index|]
operator|!=
name|pred
operator|->
name|val
index|[
name|i
index|]
condition|)
return|return;
endif|#
directive|endif
comment|/* Pull up the node. */
name|pull
operator|=
operator|*
name|samep
expr_stmt|;
operator|*
name|samep
operator|=
name|JT
argument_list|(
name|pull
argument_list|)
expr_stmt|;
name|JT
argument_list|(
name|pull
argument_list|)
operator|=
operator|*
name|diffp
expr_stmt|;
comment|/* 	 * At the top of the chain, each predecessor needs to point at the 	 * pulled up node.  Inside the chain, there is only one predecessor 	 * to worry about. 	 */
if|if
condition|(
name|at_top
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|b
operator|->
name|in_edges
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
block|{
if|if
condition|(
name|JT
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|==
name|b
condition|)
name|JT
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|=
name|pull
expr_stmt|;
else|else
name|JF
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|=
name|pull
expr_stmt|;
block|}
block|}
else|else
operator|*
name|diffp
operator|=
name|pull
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_blks
parameter_list|(
name|root
parameter_list|,
name|do_stmts
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
name|int
name|do_stmts
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|maxlevel
decl_stmt|;
name|struct
name|block
modifier|*
name|p
decl_stmt|;
name|init_val
argument_list|()
expr_stmt|;
name|maxlevel
operator|=
name|root
operator|->
name|level
expr_stmt|;
name|find_inedges
argument_list|(
name|root
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|maxlevel
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
for|for
control|(
name|p
operator|=
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
name|opt_blk
argument_list|(
name|p
argument_list|,
name|do_stmts
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_stmts
condition|)
comment|/* 		 * No point trying to move branches; it can't possibly 		 * make a difference at this point. 		 */
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxlevel
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|p
operator|=
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|opt_j
argument_list|(
operator|&
name|p
operator|->
name|et
argument_list|)
expr_stmt|;
name|opt_j
argument_list|(
operator|&
name|p
operator|->
name|ef
argument_list|)
expr_stmt|;
block|}
block|}
name|find_inedges
argument_list|(
name|root
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxlevel
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|p
operator|=
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|or_pullup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|and_pullup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|link_inedge
parameter_list|(
name|parent
parameter_list|,
name|child
parameter_list|)
name|struct
name|edge
modifier|*
name|parent
decl_stmt|;
name|struct
name|block
modifier|*
name|child
decl_stmt|;
block|{
name|parent
operator|->
name|next
operator|=
name|child
operator|->
name|in_edges
expr_stmt|;
name|child
operator|->
name|in_edges
operator|=
name|parent
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_inedges
parameter_list|(
name|root
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_blocks
condition|;
operator|++
name|i
control|)
name|blocks
index|[
name|i
index|]
operator|->
name|in_edges
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Traverse the graph, adding each edge to the predecessor 	 * list of its successors.  Skip the leaves (i.e. level 0). 	 */
for|for
control|(
name|i
operator|=
name|root
operator|->
name|level
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
for|for
control|(
name|b
operator|=
name|levels
index|[
name|i
index|]
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|link
control|)
block|{
name|link_inedge
argument_list|(
operator|&
name|b
operator|->
name|et
argument_list|,
name|JT
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|link_inedge
argument_list|(
operator|&
name|b
operator|->
name|ef
argument_list|,
name|JF
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|opt_root
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|slist
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|BPF_CLASS
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_JMP
operator|&&
name|JT
argument_list|(
operator|*
name|b
argument_list|)
operator|==
name|JF
argument_list|(
operator|*
name|b
argument_list|)
condition|)
operator|*
name|b
operator|=
name|JT
argument_list|(
operator|*
name|b
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
name|sappend
argument_list|(
name|s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
operator|=
name|s
expr_stmt|;
comment|/* 	 * If the root node is a return, then there is no 	 * point executing any statements (since the bpf machine 	 * has no side effects). 	 */
if|if
condition|(
name|BPF_CLASS
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_RET
condition|)
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_loop
parameter_list|(
name|root
parameter_list|,
name|do_stmts
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
name|int
name|do_stmts
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BDEBUG
if|if
condition|(
name|dflag
operator|>
literal|1
condition|)
name|opt_dump
argument_list|(
name|root
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|done
operator|=
literal|1
expr_stmt|;
name|find_levels
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|find_dom
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|find_closure
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|find_ud
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|find_edom
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|opt_blks
argument_list|(
name|root
argument_list|,
name|do_stmts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BDEBUG
if|if
condition|(
name|dflag
operator|>
literal|1
condition|)
name|opt_dump
argument_list|(
name|root
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Optimize the filter code in its dag representation.  */
end_comment

begin_function
name|void
name|bpf_optimize
parameter_list|(
name|rootp
parameter_list|)
name|struct
name|block
modifier|*
modifier|*
name|rootp
decl_stmt|;
block|{
name|struct
name|block
modifier|*
name|root
decl_stmt|;
name|root
operator|=
operator|*
name|rootp
expr_stmt|;
name|opt_init
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|opt_loop
argument_list|(
name|root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opt_loop
argument_list|(
name|root
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intern_blocks
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|opt_root
argument_list|(
name|rootp
argument_list|)
expr_stmt|;
name|opt_cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_marks
parameter_list|(
name|p
parameter_list|)
name|struct
name|block
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|isMarked
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|Mark
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|BPF_CLASS
argument_list|(
name|p
operator|->
name|s
operator|.
name|code
argument_list|)
operator|!=
name|BPF_RET
condition|)
block|{
name|make_marks
argument_list|(
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|make_marks
argument_list|(
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Mark code array such that isMarked(i) is true  * only for nodes that are alive.  */
end_comment

begin_function
specifier|static
name|void
name|mark_code
parameter_list|(
name|p
parameter_list|)
name|struct
name|block
modifier|*
name|p
decl_stmt|;
block|{
name|cur_mark
operator|+=
literal|1
expr_stmt|;
name|make_marks
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * True iff the two stmt lists load the same value from the packet into  * the accumulator.  */
end_comment

begin_function
specifier|static
name|int
name|eq_slist
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|struct
name|slist
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|x
operator|&&
name|x
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
name|x
operator|=
name|x
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|y
operator|&&
name|y
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
name|y
operator|=
name|y
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|y
operator|==
literal|0
return|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
return|return
name|x
operator|==
literal|0
return|;
if|if
condition|(
name|x
operator|->
name|s
operator|.
name|code
operator|!=
name|y
operator|->
name|s
operator|.
name|code
operator|||
name|x
operator|->
name|s
operator|.
name|k
operator|!=
name|y
operator|->
name|s
operator|.
name|k
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|x
operator|->
name|next
expr_stmt|;
name|y
operator|=
name|y
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
specifier|inline
name|int
name|eq_blk
parameter_list|(
name|b0
parameter_list|,
name|b1
parameter_list|)
name|struct
name|block
modifier|*
name|b0
decl_stmt|,
decl|*
name|b1
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|b0
operator|->
name|s
operator|.
name|code
operator|==
name|b1
operator|->
name|s
operator|.
name|code
operator|&&
name|b0
operator|->
name|s
operator|.
name|k
operator|==
name|b1
operator|->
name|s
operator|.
name|k
operator|&&
name|b0
operator|->
name|et
operator|.
name|succ
operator|==
name|b1
operator|->
name|et
operator|.
name|succ
operator|&&
name|b0
operator|->
name|ef
operator|.
name|succ
operator|==
name|b1
operator|->
name|ef
operator|.
name|succ
condition|)
return|return
name|eq_slist
argument_list|(
name|b0
operator|->
name|stmts
argument_list|,
name|b1
operator|->
name|stmts
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|intern_blocks
parameter_list|(
name|root
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
block|{
name|struct
name|block
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|done
decl_stmt|;
name|top
label|:
name|done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_blocks
condition|;
operator|++
name|i
control|)
name|blocks
index|[
name|i
index|]
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|mark_code
argument_list|(
name|root
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_blocks
operator|-
literal|1
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|isMarked
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_blocks
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|isMarked
argument_list|(
name|blocks
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|eq_blk
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|,
name|blocks
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|blocks
index|[
name|i
index|]
operator|->
name|link
operator|=
name|blocks
index|[
name|j
index|]
operator|->
name|link
condition|?
name|blocks
index|[
name|j
index|]
operator|->
name|link
else|:
name|blocks
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_blocks
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
name|blocks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|JT
argument_list|(
name|p
argument_list|)
operator|->
name|link
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
name|JT
argument_list|(
name|p
argument_list|)
operator|=
name|JT
argument_list|(
name|p
argument_list|)
operator|->
name|link
expr_stmt|;
block|}
if|if
condition|(
name|JF
argument_list|(
name|p
argument_list|)
operator|->
name|link
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
name|JF
argument_list|(
name|p
argument_list|)
operator|=
name|JF
argument_list|(
name|p
argument_list|)
operator|->
name|link
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
goto|goto
name|top
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_cleanup
parameter_list|()
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vnode_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|space
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|levels
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of stmts in 's'.  */
end_comment

begin_function
specifier|static
name|int
name|slength
parameter_list|(
name|s
parameter_list|)
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|!=
name|NOP
condition|)
operator|++
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of nodes reachable by 'p'.  * All nodes should be initially unmarked.  */
end_comment

begin_function
specifier|static
name|int
name|count_blocks
parameter_list|(
name|p
parameter_list|)
name|struct
name|block
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|isMarked
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|Mark
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|count_blocks
argument_list|(
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
operator|+
name|count_blocks
argument_list|(
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Do a depth first search on the flow graph, numbering the  * the basic blocks, and entering them into the 'blocks' array.`  */
end_comment

begin_function
specifier|static
name|void
name|number_blks_r
parameter_list|(
name|p
parameter_list|)
name|struct
name|block
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|isMarked
argument_list|(
name|p
argument_list|)
condition|)
return|return;
name|Mark
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|n_blocks
operator|++
expr_stmt|;
name|p
operator|->
name|id
operator|=
name|n
expr_stmt|;
name|blocks
index|[
name|n
index|]
operator|=
name|p
expr_stmt|;
name|number_blks_r
argument_list|(
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|number_blks_r
argument_list|(
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of stmts in the flowgraph reachable by 'p'.  * The nodes should be unmarked before calling.  *  * Note that "stmts" means "instructions", and that this includes  *  *	side-effect statements in 'p' (slength(p->stmts));  *  *	statements in the true branch from 'p' (count_stmts(JT(p)));  *  *	statements in the false branch from 'p' (count_stmts(JF(p)));  *  *	the conditional jump itself (1);  *  *	an extra long jump if the true branch requires it (p->longjt);  *  *	an extra long jump if the false branch requires it (p->longjf).  */
end_comment

begin_function
specifier|static
name|int
name|count_stmts
parameter_list|(
name|p
parameter_list|)
name|struct
name|block
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|isMarked
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|Mark
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|count_stmts
argument_list|(
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
operator|+
name|count_stmts
argument_list|(
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|slength
argument_list|(
name|p
operator|->
name|stmts
argument_list|)
operator|+
name|n
operator|+
literal|1
operator|+
name|p
operator|->
name|longjt
operator|+
name|p
operator|->
name|longjf
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate memory.  All allocation is done before optimization  * is begun.  A linear bound on the size of all data structures is computed  * from the total number of blocks and/or statements.  */
end_comment

begin_function
specifier|static
name|void
name|opt_init
parameter_list|(
name|root
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
block|{
name|bpf_u_int32
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|max_stmts
decl_stmt|;
comment|/* 	 * First, count the blocks, so we can malloc an array to map 	 * block number to block.  Then, put the blocks into the array. 	 */
name|unMarkAll
argument_list|()
expr_stmt|;
name|n
operator|=
name|count_blocks
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|blocks
operator|=
operator|(
expr|struct
name|block
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
name|unMarkAll
argument_list|()
expr_stmt|;
name|n_blocks
operator|=
literal|0
expr_stmt|;
name|number_blks_r
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|n_edges
operator|=
literal|2
operator|*
name|n_blocks
expr_stmt|;
name|edges
operator|=
operator|(
expr|struct
name|edge
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|n_edges
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|edges
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The number of levels is bounded by the number of nodes. 	 */
name|levels
operator|=
operator|(
expr|struct
name|block
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|n_blocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|levels
argument_list|)
argument_list|)
expr_stmt|;
name|edgewords
operator|=
name|n_edges
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|bpf_u_int32
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|nodewords
operator|=
name|n_blocks
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|bpf_u_int32
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* XXX */
name|space
operator|=
operator|(
name|bpf_u_int32
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|n_blocks
operator|*
name|nodewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|space
argument_list|)
operator|+
name|n_edges
operator|*
name|edgewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|space
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|space
expr_stmt|;
name|all_dom_sets
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|blocks
index|[
name|i
index|]
operator|->
name|dom
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|nodewords
expr_stmt|;
block|}
name|all_closure_sets
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|blocks
index|[
name|i
index|]
operator|->
name|closure
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|nodewords
expr_stmt|;
block|}
name|all_edge_sets
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
init|=
name|blocks
index|[
name|i
index|]
decl_stmt|;
name|b
operator|->
name|et
operator|.
name|edom
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|edgewords
expr_stmt|;
name|b
operator|->
name|ef
operator|.
name|edom
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|edgewords
expr_stmt|;
name|b
operator|->
name|et
operator|.
name|id
operator|=
name|i
expr_stmt|;
name|edges
index|[
name|i
index|]
operator|=
operator|&
name|b
operator|->
name|et
expr_stmt|;
name|b
operator|->
name|ef
operator|.
name|id
operator|=
name|n_blocks
operator|+
name|i
expr_stmt|;
name|edges
index|[
name|n_blocks
operator|+
name|i
index|]
operator|=
operator|&
name|b
operator|->
name|ef
expr_stmt|;
name|b
operator|->
name|et
operator|.
name|pred
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|ef
operator|.
name|pred
operator|=
name|b
expr_stmt|;
block|}
name|max_stmts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|max_stmts
operator|+=
name|slength
argument_list|(
name|blocks
index|[
name|i
index|]
operator|->
name|stmts
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * We allocate at most 3 value numbers per statement, 	 * so this is an upper bound on the number of valnodes 	 * we'll need. 	 */
name|maxval
operator|=
literal|3
operator|*
name|max_stmts
expr_stmt|;
name|vmap
operator|=
operator|(
expr|struct
name|vmapinfo
operator|*
operator|)
name|malloc
argument_list|(
name|maxval
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vmap
argument_list|)
argument_list|)
expr_stmt|;
name|vnode_base
operator|=
operator|(
expr|struct
name|valnode
operator|*
operator|)
name|malloc
argument_list|(
name|maxval
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vnode_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Some pointers used to convert the basic block form of the code,  * into the array form that BPF requires.  'fstart' will point to  * the malloc'd array while 'ftail' is used during the recursive traversal.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bpf_insn
modifier|*
name|fstart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bpf_insn
modifier|*
name|ftail
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_decl_stmt
name|int
name|bids
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Returns true if successful.  Returns false if a branch has  * an offset that is too large.  If so, we have marked that  * branch so that on a subsequent iteration, it will be treated  * properly.  */
end_comment

begin_function
specifier|static
name|int
name|convert_code_r
parameter_list|(
name|p
parameter_list|)
name|struct
name|block
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|bpf_insn
modifier|*
name|dst
decl_stmt|;
name|struct
name|slist
modifier|*
name|src
decl_stmt|;
name|int
name|slen
decl_stmt|;
name|u_int
name|off
decl_stmt|;
name|int
name|extrajmps
decl_stmt|;
comment|/* number of extra jumps inserted */
name|struct
name|slist
modifier|*
modifier|*
name|offset
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|isMarked
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|Mark
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_code_r
argument_list|(
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|convert_code_r
argument_list|(
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|slen
operator|=
name|slength
argument_list|(
name|p
operator|->
name|stmts
argument_list|)
expr_stmt|;
name|dst
operator|=
name|ftail
operator|-=
operator|(
name|slen
operator|+
literal|1
operator|+
name|p
operator|->
name|longjt
operator|+
name|p
operator|->
name|longjf
operator|)
expr_stmt|;
comment|/* inflate length by any extra jumps */
name|p
operator|->
name|offset
operator|=
name|dst
operator|-
name|fstart
expr_stmt|;
comment|/* generate offset[] for convenience  */
if|if
condition|(
name|slen
condition|)
block|{
name|offset
operator|=
operator|(
expr|struct
name|slist
operator|*
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|slist
operator|*
argument_list|)
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
block|{
name|bpf_error
argument_list|(
literal|"not enough core"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
name|src
operator|=
name|p
operator|->
name|stmts
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|slen
operator|&&
name|src
condition|;
name|off
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|printf("off=%d src=%x\n", off, src);
endif|#
directive|endif
name|offset
index|[
name|off
index|]
operator|=
name|src
expr_stmt|;
name|src
operator|=
name|src
operator|->
name|next
expr_stmt|;
block|}
name|off
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|src
operator|=
name|p
operator|->
name|stmts
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
block|{
if|if
condition|(
name|src
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
continue|continue;
name|dst
operator|->
name|code
operator|=
operator|(
name|u_short
operator|)
name|src
operator|->
name|s
operator|.
name|code
expr_stmt|;
name|dst
operator|->
name|k
operator|=
name|src
operator|->
name|s
operator|.
name|k
expr_stmt|;
comment|/* fill block-local relative jump */
if|if
condition|(
name|BPF_CLASS
argument_list|(
name|src
operator|->
name|s
operator|.
name|code
argument_list|)
operator|!=
name|BPF_JMP
operator|||
name|src
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_JMP
operator||
name|BPF_JA
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (src->s.jt || src->s.jf) { 				bpf_error("illegal jmp destination");
comment|/*NOTREACHED*/
block|}
endif|#
directive|endif
goto|goto
name|filled
goto|;
block|}
if|if
condition|(
name|off
operator|==
name|slen
operator|-
literal|2
condition|)
comment|/*???*/
goto|goto
name|filled
goto|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|jt
decl_stmt|,
name|jf
decl_stmt|;
name|char
modifier|*
name|ljerr
init|=
literal|"%s for block-local relative jump: off=%d"
decl_stmt|;
if|#
directive|if
literal|0
block|printf("code=%x off=%d %x %x\n", src->s.code, 			off, src->s.jt, src->s.jf);
endif|#
directive|endif
if|if
condition|(
operator|!
name|src
operator|->
name|s
operator|.
name|jt
operator|||
operator|!
name|src
operator|->
name|s
operator|.
name|jf
condition|)
block|{
name|bpf_error
argument_list|(
name|ljerr
argument_list|,
literal|"no jmp destination"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|jt
operator|=
name|jf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
index|[
name|i
index|]
operator|==
name|src
operator|->
name|s
operator|.
name|jt
condition|)
block|{
if|if
condition|(
name|jt
condition|)
block|{
name|bpf_error
argument_list|(
name|ljerr
argument_list|,
literal|"multiple matches"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|dst
operator|->
name|jt
operator|=
name|i
operator|-
name|off
operator|-
literal|1
expr_stmt|;
name|jt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|offset
index|[
name|i
index|]
operator|==
name|src
operator|->
name|s
operator|.
name|jf
condition|)
block|{
if|if
condition|(
name|jf
condition|)
block|{
name|bpf_error
argument_list|(
name|ljerr
argument_list|,
literal|"multiple matches"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|dst
operator|->
name|jf
operator|=
name|i
operator|-
name|off
operator|-
literal|1
expr_stmt|;
name|jf
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|jt
operator|||
operator|!
name|jf
condition|)
block|{
name|bpf_error
argument_list|(
name|ljerr
argument_list|,
literal|"no destination found"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
name|filled
label|:
operator|++
name|dst
expr_stmt|;
operator|++
name|off
expr_stmt|;
block|}
if|if
condition|(
name|offset
condition|)
name|free
argument_list|(
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BDEBUG
name|bids
index|[
name|dst
operator|-
name|fstart
index|]
operator|=
name|p
operator|->
name|id
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
name|dst
operator|->
name|code
operator|=
operator|(
name|u_short
operator|)
name|p
operator|->
name|s
operator|.
name|code
expr_stmt|;
name|dst
operator|->
name|k
operator|=
name|p
operator|->
name|s
operator|.
name|k
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|extrajmps
operator|=
literal|0
expr_stmt|;
name|off
operator|=
name|JT
argument_list|(
name|p
argument_list|)
operator|->
name|offset
operator|-
operator|(
name|p
operator|->
name|offset
operator|+
name|slen
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|off
operator|>=
literal|256
condition|)
block|{
comment|/* offset too large for branch, must add a jump */
if|if
condition|(
name|p
operator|->
name|longjt
operator|==
literal|0
condition|)
block|{
comment|/* mark this instruction and retry */
name|p
operator|->
name|longjt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* branch if T to following jump */
name|dst
operator|->
name|jt
operator|=
name|extrajmps
expr_stmt|;
name|extrajmps
operator|++
expr_stmt|;
name|dst
index|[
name|extrajmps
index|]
operator|.
name|code
operator|=
name|BPF_JMP
operator||
name|BPF_JA
expr_stmt|;
name|dst
index|[
name|extrajmps
index|]
operator|.
name|k
operator|=
name|off
operator|-
name|extrajmps
expr_stmt|;
block|}
else|else
name|dst
operator|->
name|jt
operator|=
name|off
expr_stmt|;
name|off
operator|=
name|JF
argument_list|(
name|p
argument_list|)
operator|->
name|offset
operator|-
operator|(
name|p
operator|->
name|offset
operator|+
name|slen
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|off
operator|>=
literal|256
condition|)
block|{
comment|/* offset too large for branch, must add a jump */
if|if
condition|(
name|p
operator|->
name|longjf
operator|==
literal|0
condition|)
block|{
comment|/* mark this instruction and retry */
name|p
operator|->
name|longjf
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* branch if F to following jump */
comment|/* if two jumps are inserted, F goes to second one */
name|dst
operator|->
name|jf
operator|=
name|extrajmps
expr_stmt|;
name|extrajmps
operator|++
expr_stmt|;
name|dst
index|[
name|extrajmps
index|]
operator|.
name|code
operator|=
name|BPF_JMP
operator||
name|BPF_JA
expr_stmt|;
name|dst
index|[
name|extrajmps
index|]
operator|.
name|k
operator|=
name|off
operator|-
name|extrajmps
expr_stmt|;
block|}
else|else
name|dst
operator|->
name|jf
operator|=
name|off
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert flowgraph intermediate representation to the  * BPF array representation.  Set *lenp to the number of instructions.  */
end_comment

begin_function
name|struct
name|bpf_insn
modifier|*
name|icode_to_fcode
parameter_list|(
name|root
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|fp
decl_stmt|;
comment|/* 	 * Loop doing convert_codr_r() until no branches remain 	 * with too-large offsets. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|unMarkAll
argument_list|()
expr_stmt|;
name|n
operator|=
operator|*
name|lenp
operator|=
name|count_stmts
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|fstart
operator|=
name|fp
expr_stmt|;
name|ftail
operator|=
name|fp
operator|+
name|n
expr_stmt|;
name|unMarkAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|convert_code_r
argument_list|(
name|root
argument_list|)
condition|)
break|break;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * Make a copy of a BPF program and put it in the "fcode" member of  * a "pcap_t".  *  * If we fail to allocate memory for the copy, fill in the "errbuf"  * member of the "pcap_t" with an error message, and return -1;  * otherwise, return 0.  */
end_comment

begin_function
name|int
name|install_bpf_program
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
name|size_t
name|prog_size
decl_stmt|;
comment|/* 	 * Free up any already installed program. 	 */
name|pcap_freecode
argument_list|(
operator|&
name|p
operator|->
name|fcode
argument_list|)
expr_stmt|;
name|prog_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|fp
operator|->
name|bf_insns
argument_list|)
operator|*
name|fp
operator|->
name|bf_len
expr_stmt|;
name|p
operator|->
name|fcode
operator|.
name|bf_len
operator|=
name|fp
operator|->
name|bf_len
expr_stmt|;
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
name|malloc
argument_list|(
name|prog_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|fp
operator|->
name|bf_insns
argument_list|,
name|prog_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_function
specifier|static
name|void
name|opt_dump
parameter_list|(
name|root
parameter_list|)
name|struct
name|block
modifier|*
name|root
decl_stmt|;
block|{
name|struct
name|bpf_program
name|f
decl_stmt|;
name|memset
argument_list|(
name|bids
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|bids
argument_list|)
expr_stmt|;
name|f
operator|.
name|bf_insns
operator|=
name|icode_to_fcode
argument_list|(
name|root
argument_list|,
operator|&
name|f
operator|.
name|bf_len
argument_list|)
expr_stmt|;
name|bpf_dump
argument_list|(
operator|&
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|.
name|bf_insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

