begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  pcap-linux.c: Packet capture interface to the Linux kernel  *  *  Copyright (c) 2000 Torsten Landschoff<torsten@debian.org>  *  		       Sebastian Krahmer<krahmer@cs.uni-potsdam.de>  *  *  License: BSD  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  3. The names of the authors may not be used to endorse or promote  *     products derived from this software without specific prior  *     written permission.  *  *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  *  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/pcap-linux.c,v 1.98.2.4 2003/11/21 10:20:46 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Known problems with 2.0[.x] kernels:  *  *   - The loopback device gives every packet twice; on 2.2[.x] kernels,  *     if we use PF_PACKET, we can filter out the transmitted version  *     of the packet by using data in the "sockaddr_ll" returned by  *     "recvfrom()", but, on 2.0[.x] kernels, we have to use  *     PF_INET/SOCK_PACKET, which means "recvfrom()" supplies a  *     "sockaddr_pkt" which doesn't give us enough information to let  *     us do that.  *  *   - We have to set the interface's IFF_PROMISC flag ourselves, if  *     we're to run in promiscuous mode, which means we have to turn  *     it off ourselves when we're done; the kernel doesn't keep track  *     of how many sockets are listening promiscuously, which means  *     it won't get turned off automatically when no sockets are  *     listening promiscuously.  We catch "pcap_close()" and, for  *     interfaces we put into promiscuous mode, take them out of  *     promiscuous mode - which isn't necessarily the right thing to  *     do, if another socket also requested promiscuous mode between  *     the time when we opened the socket and the time when we close  *     the socket.  *  *   - MSG_TRUNC isn't supported, so you can't specify that "recvfrom()"  *     return the amount of data that you could have read, rather than  *     the amount that was returned, so we can't just allocate a buffer  *     whose size is the snapshot length and pass the snapshot length  *     as the byte count, and also pass MSG_TRUNC, so that the return  *     value tells us how long the packet was on the wire.  *  *     This means that, if we want to get the actual size of the packet,  *     so we can return it in the "len" field of the packet header,  *     we have to read the entire packet, not just the part that fits  *     within the snapshot length, and thus waste CPU time copying data  *     from the kernel that our caller won't see.  *  *     We have to get the actual size, and supply it in "len", because  *     otherwise, the IP dissector in tcpdump, for example, will complain  *     about "truncated-ip", as the packet will appear to have been  *     shorter, on the wire, than the IP header said it should have been.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"sll.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DAG_API
end_ifdef

begin_include
include|#
directive|include
file|"pcap-dag.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_DAG_API */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_comment
comment|/*  * If PF_PACKET is defined, we can use {SOCK_RAW,SOCK_DGRAM}/PF_PACKET  * sockets rather than SOCK_PACKET sockets.  *  * To use them, we include<linux/if_packet.h> rather than  *<netpacket/packet.h>; we do so because  *  *	some Linux distributions (e.g., Slackware 4.0) have 2.2 or  *	later kernels and libc5, and don't provide a<netpacket/packet.h>  *	file;  *  *	not all versions of glibc2 have a<netpacket/packet.h> file  *	that defines stuff needed for some of the 2.4-or-later-kernel  *	features, so if the system has a 2.4 or later kernel, we  *	still can't use those features.  *  * We're already including a number of other<linux/XXX.h> headers, and  * this code is Linux-specific (no other OS has PF_PACKET sockets as  * a raw packet capture mechanism), so it's not as if you gain any  * useful portability by using<netpacket/packet.h>  *  * XXX - should we just include<linux/if_packet.h> even if PF_PACKET  * isn't defined?  It only defines one data structure in 2.0.x, so  * it shouldn't cause any problems.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PF_PACKET
end_ifdef

begin_include
include|#
directive|include
file|<linux/if_packet.h>
end_include

begin_comment
comment|/*   * On at least some Linux distributions (for example, Red Hat 5.2),   * there's no<netpacket/packet.h> file, but PF_PACKET is defined if   * you include<sys/socket.h>, but<linux/if_packet.h> doesn't define   * any of the PF_PACKET stuff such as "struct sockaddr_ll" or any of   * the PACKET_xxx stuff.   *   * So we check whether PACKET_HOST is defined, and assume that we have   * PF_PACKET sockets only if it is defined.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PACKET_HOST
end_ifdef

begin_define
define|#
directive|define
name|HAVE_PF_PACKET_SOCKETS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PACKET_HOST */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PF_PACKET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
end_ifdef

begin_include
include|#
directive|include
file|<linux/types.h>
end_include

begin_include
include|#
directive|include
file|<linux/filter.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GLIBC__
end_ifndef

begin_typedef
typedef|typedef
name|int
name|socklen_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSG_TRUNC
end_ifndef

begin_comment
comment|/*  * This is being compiled on a system that lacks MSG_TRUNC; define it  * with the value it has in the 2.2 and later kernels, so that, on  * those kernels, when we pass it in the flags argument to "recvfrom()"  * we're passing the right value and thus get the MSG_TRUNC behavior  * we want.  (We don't get that behavior on 2.0[.x] kernels, because  * they didn't support MSG_TRUNC.)  */
end_comment

begin_define
define|#
directive|define
name|MSG_TRUNC
value|0x20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOL_PACKET
end_ifndef

begin_comment
comment|/*  * This is being compiled on a system that lacks SOL_PACKET; define it  * with the value it has in the 2.2 and later kernels, so that we can  * set promiscuous mode in the good modern way rather than the old  * 2.0-kernel crappy way.  */
end_comment

begin_define
define|#
directive|define
name|SOL_PACKET
value|263
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_LINKHEADER_SIZE
value|256
end_define

begin_comment
comment|/*  * When capturing on all interfaces we use this as the buffer size.  * Should be bigger then all MTUs that occur in real life.  * 64kB should be enough for now.  */
end_comment

begin_define
define|#
directive|define
name|BIGGER_THAN_ALL_MTUS
value|(64*1024)
end_define

begin_comment
comment|/*  * Prototypes for internal functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|map_arphrd_to_dlt
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|live_open_old
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|live_open_new
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_read_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_read_packet
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_stats_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|pcap_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setfilter_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcap_close_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Wrap some ioctl calls  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_function_decl
specifier|static
name|int
name|iface_get_id
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|iface_get_mtu
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iface_get_arptype
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_function_decl
specifier|static
name|int
name|iface_bind
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|ifindex
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|iface_bind_old
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
end_ifdef

begin_function_decl
specifier|static
name|int
name|fix_program
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fix_offset
parameter_list|(
name|struct
name|bpf_insn
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_kernel_filter
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reset_kernel_filter
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|sock_filter
name|total_insn
init|=
name|BPF_STMT
argument_list|(
name|BPF_RET
operator||
name|BPF_K
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sock_fprog
name|total_fcode
init|=
block|{
literal|1
block|,
operator|&
name|total_insn
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Get a handle for a live capture from the given device. You can  *  pass NULL as device to get all packages (without link level  *  information of course). If you pass 1 as promisc the interface  *  will be set to promiscous mode (XXX: I think this usage should  *  be deprecated and functions be added to select that later allow  *  modification of that values -- Torsten).  *  *  See also pcap(3).  */
end_comment

begin_function
name|pcap_t
modifier|*
name|pcap_open_live
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|handle
decl_stmt|;
name|int
name|mtu
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|live_open_ok
init|=
literal|0
decl_stmt|;
name|struct
name|utsname
name|utsname
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_API
if|if
condition|(
name|strstr
argument_list|(
name|device
argument_list|,
literal|"dag"
argument_list|)
condition|)
block|{
return|return
name|dag_open_live
argument_list|(
name|device
argument_list|,
name|snaplen
argument_list|,
name|promisc
argument_list|,
name|to_ms
argument_list|,
name|ebuf
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_DAG_API */
comment|/* Allocate a handle for this session. */
name|handle
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Initialize some components of the pcap structure. */
name|memset
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
name|handle
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|timeout
operator|=
name|to_ms
expr_stmt|;
comment|/* 	 * NULL and "any" are special devices which give us the hint to 	 * monitor all devices. 	 */
if|if
condition|(
operator|!
name|device
operator|||
name|strcmp
argument_list|(
name|device
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device
operator|=
name|NULL
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|device
operator|=
name|strdup
argument_list|(
literal|"any"
argument_list|)
expr_stmt|;
if|if
condition|(
name|promisc
condition|)
block|{
name|promisc
operator|=
literal|0
expr_stmt|;
comment|/* Just a warning. */
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Promiscuous mode not supported on the \"any\" device"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|handle
operator|->
name|md
operator|.
name|device
operator|=
name|strdup
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|device
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"strdup: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Current Linux kernels use the protocol family PF_PACKET to 	 * allow direct access to all packets on the network while 	 * older kernels had a special socket type SOCK_PACKET to 	 * implement this feature. 	 * While this old implementation is kind of obsolete we need 	 * to be compatible with older kernels for a while so we are 	 * trying both methods with the newer method preferred. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|live_open_new
argument_list|(
name|handle
argument_list|,
name|device
argument_list|,
name|promisc
argument_list|,
name|to_ms
argument_list|,
name|ebuf
argument_list|)
operator|)
operator|==
literal|1
condition|)
name|live_open_ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
comment|/* Non-fatal error; try old way */
if|if
condition|(
name|live_open_old
argument_list|(
name|handle
argument_list|,
name|device
argument_list|,
name|promisc
argument_list|,
name|to_ms
argument_list|,
name|ebuf
argument_list|)
condition|)
name|live_open_ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|live_open_ok
condition|)
block|{
comment|/* 		 * Both methods to open the packet socket failed. Tidy 		 * up and report our failure (ebuf is expected to be 		 * set by the functions above). 		 */
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|device
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|handle
operator|->
name|md
operator|.
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Compute the buffer size. 	 * 	 * If we're using SOCK_PACKET, this might be a 2.0[.x] kernel, 	 * and might require special handling - check. 	 */
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|sock_packet
operator|&&
operator|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|<
literal|0
operator|||
name|strncmp
argument_list|(
name|utsname
operator|.
name|release
argument_list|,
literal|"2.0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We're using a SOCK_PACKET structure, and either 		 * we couldn't find out what kernel release this is, 		 * or it's a 2.0[.x] kernel. 		 * 		 * In the 2.0[.x] kernel, a "recvfrom()" on 		 * a SOCK_PACKET socket, with MSG_TRUNC set, will 		 * return the number of bytes read, so if we pass 		 * a length based on the snapshot length, it'll 		 * return the number of bytes from the packet 		 * copied to userland, not the actual length 		 * of the packet. 		 * 		 * This means that, for example, the IP dissector 		 * in tcpdump will get handed a packet length less 		 * than the length in the IP header, and will 		 * complain about "truncated-ip". 		 * 		 * So we don't bother trying to copy from the 		 * kernel only the bytes in which we're interested, 		 * but instead copy them all, just as the older 		 * versions of libpcap for Linux did. 		 * 		 * The buffer therefore needs to be big enough to 		 * hold the largest packet we can get from this 		 * device.  Unfortunately, we can't get the MRU 		 * of the network; we can only get the MTU.  The 		 * MTU may be too small, in which case a packet larger 		 * than the buffer size will be truncated *and* we 		 * won't get the actual packet size. 		 * 		 * However, if the snapshot length is larger than 		 * the buffer size based on the MTU, we use the 		 * snapshot length as the buffer size, instead; 		 * this means that with a sufficiently large snapshot 		 * length we won't artificially truncate packets 		 * to the MTU-based size. 		 * 		 * This mess just one of many problems with packet 		 * capture on 2.0[.x] kernels; you really want a 		 * 2.2[.x] or later kernel if you want packet capture 		 * to work well. 		 */
name|mtu
operator|=
name|iface_get_mtu
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_close_linux
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|handle
operator|->
name|bufsize
operator|=
name|MAX_LINKHEADER_SIZE
operator|+
name|mtu
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|bufsize
operator|<
name|handle
operator|->
name|snapshot
condition|)
name|handle
operator|->
name|bufsize
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a 2.2[.x] or later kernel (we know that 		 * either because we're not using a SOCK_PACKET 		 * socket - PF_PACKET is supported only in 2.2 		 * and later kernels - or because we checked the 		 * kernel version). 		 * 		 * We can safely pass "recvfrom()" a byte count 		 * based on the snapshot length. 		 */
name|handle
operator|->
name|bufsize
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
block|}
comment|/* Allocate the buffer */
name|handle
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|handle
operator|->
name|bufsize
operator|+
name|handle
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
operator|->
name|buffer
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|pcap_close_linux
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * "handle->fd" is a socket, so "select()" and "poll()" 	 * should work on it. 	 */
name|handle
operator|->
name|selectable_fd
operator|=
name|handle
operator|->
name|fd
expr_stmt|;
name|handle
operator|->
name|read_op
operator|=
name|pcap_read_linux
expr_stmt|;
name|handle
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_linux
expr_stmt|;
name|handle
operator|->
name|set_datalink_op
operator|=
name|NULL
expr_stmt|;
comment|/* can't change data link type */
name|handle
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|handle
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_fd
expr_stmt|;
name|handle
operator|->
name|stats_op
operator|=
name|pcap_stats_linux
expr_stmt|;
name|handle
operator|->
name|close_op
operator|=
name|pcap_close_linux
expr_stmt|;
return|return
name|handle
return|;
block|}
end_function

begin_comment
comment|/*  *  Read at most max_packets from the capture stream and call the callback  *  for each of them. Returns the number of packets handled or -1 if an  *  error occured.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_read_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
comment|/* 	 * Currently, on Linux only one packet is delivered per read, 	 * so we don't loop. 	 */
return|return
name|pcap_read_packet
argument_list|(
name|handle
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Read a packet from the socket calling the handler provided by  *  the user. Returns the number of packets received or -1 if an  *  error occured.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_read_packet
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|userdata
parameter_list|)
block|{
name|u_char
modifier|*
name|bp
decl_stmt|;
name|int
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
name|struct
name|sockaddr_ll
name|from
decl_stmt|;
name|struct
name|sll_header
modifier|*
name|hdrp
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr
name|from
decl_stmt|;
endif|#
directive|endif
name|socklen_t
name|fromlen
decl_stmt|;
name|int
name|packet_len
decl_stmt|,
name|caplen
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/* 	 * If this is a cooked device, leave extra room for a 	 * fake packet header. 	 */
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|cooked
condition|)
name|offset
operator|=
name|SLL_HDR_LEN
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* 	 * This system doesn't have PF_PACKET sockets, so it doesn't 	 * support cooked devices. 	 */
name|offset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Receive a single packet from the kernel */
name|bp
operator|=
name|handle
operator|->
name|buffer
operator|+
name|handle
operator|->
name|offset
expr_stmt|;
do|do
block|{
comment|/* 		 * Has "pcap_breakloop()" been called? 		 */
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
comment|/* 			 * Yes - clear the flag that indicates that it 			 * has, and return -2 as an indication that we 			 * were told to break out of the loop. 			 */
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|packet_len
operator|=
name|recvfrom
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|bp
operator|+
name|offset
argument_list|,
name|handle
operator|->
name|bufsize
operator|-
name|offset
argument_list|,
name|MSG_TRUNC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|packet_len
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
comment|/* Check if an error occured */
if|if
condition|(
name|packet_len
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|0
return|;
comment|/* no packet there */
else|else
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"recvfrom: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/* 	 * If this is from the loopback device, reject outgoing packets; 	 * we'll see the packet as an incoming packet as well, and 	 * we don't want to see it twice. 	 * 	 * We can only do this if we're using PF_PACKET; the address 	 * returned for SOCK_PACKET is a "sockaddr_pkt" which lacks 	 * the relevant packet type information. 	 */
if|if
condition|(
operator|!
name|handle
operator|->
name|md
operator|.
name|sock_packet
operator|&&
name|from
operator|.
name|sll_ifindex
operator|==
name|handle
operator|->
name|md
operator|.
name|lo_ifindex
operator|&&
name|from
operator|.
name|sll_pkttype
operator|==
name|PACKET_OUTGOING
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/* 	 * If this is a cooked device, fill in the fake packet header. 	 */
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|cooked
condition|)
block|{
comment|/* 		 * Add the length of the fake header to the length 		 * of packet data we read. 		 */
name|packet_len
operator|+=
name|SLL_HDR_LEN
expr_stmt|;
name|hdrp
operator|=
operator|(
expr|struct
name|sll_header
operator|*
operator|)
name|bp
expr_stmt|;
comment|/* 		 * Map the PACKET_ value to a LINUX_SLL_ value; we 		 * want the same numerical value to be used in 		 * the link-layer header even if the numerical values 		 * for the PACKET_ #defines change, so that programs 		 * that look at the packet type field will always be 		 * able to handle DLT_LINUX_SLL captures. 		 */
switch|switch
condition|(
name|from
operator|.
name|sll_pkttype
condition|)
block|{
case|case
name|PACKET_HOST
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_HOST
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_BROADCAST
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_BROADCAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_MULTICAST
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_MULTICAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_OTHERHOST
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_OTHERHOST
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_OUTGOING
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_OUTGOING
argument_list|)
expr_stmt|;
break|break;
default|default:
name|hdrp
operator|->
name|sll_pkttype
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|hdrp
operator|->
name|sll_hatype
operator|=
name|htons
argument_list|(
name|from
operator|.
name|sll_hatype
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_halen
operator|=
name|htons
argument_list|(
name|from
operator|.
name|sll_halen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hdrp
operator|->
name|sll_addr
argument_list|,
name|from
operator|.
name|sll_addr
argument_list|,
operator|(
name|from
operator|.
name|sll_halen
operator|>
name|SLL_ADDRLEN
operator|)
condition|?
name|SLL_ADDRLEN
else|:
name|from
operator|.
name|sll_halen
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_protocol
operator|=
name|from
operator|.
name|sll_protocol
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * XXX: According to the kernel source we should get the real 	 * packet len if calling recvfrom with MSG_TRUNC set. It does 	 * not seem to work here :(, but it is supported by this code 	 * anyway. 	 * To be honest the code RELIES on that feature so this is really 	 * broken with 2.2.x kernels. 	 * I spend a day to figure out what's going on and I found out 	 * that the following is happening: 	 * 	 * The packet comes from a random interface and the packet_rcv 	 * hook is called with a clone of the packet. That code inserts 	 * the packet into the receive queue of the packet socket. 	 * If a filter is attached to that socket that filter is run 	 * first - and there lies the problem. The default filter always 	 * cuts the packet at the snaplen: 	 * 	 * # tcpdump -d 	 * (000) ret      #68 	 * 	 * So the packet filter cuts down the packet. The recvfrom call 	 * says "hey, it's only 68 bytes, it fits into the buffer" with 	 * the result that we don't get the real packet length. This 	 * is valid at least until kernel 2.2.17pre6. 	 * 	 * We currently handle this by making a copy of the filter 	 * program, fixing all "ret" instructions with non-zero 	 * operands to have an operand of 65535 so that the filter 	 * doesn't truncate the packet, and supplying that modified 	 * filter to the kernel. 	 */
name|caplen
operator|=
name|packet_len
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|handle
operator|->
name|snapshot
condition|)
name|caplen
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
comment|/* Run the packet filter if not using kernel filter */
if|if
condition|(
operator|!
name|handle
operator|->
name|md
operator|.
name|use_bpf
operator|&&
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
condition|)
block|{
if|if
condition|(
name|bpf_filter
argument_list|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|bp
argument_list|,
name|packet_len
argument_list|,
name|caplen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* rejected by filter */
return|return
literal|0
return|;
block|}
block|}
comment|/* Fill in our own header data */
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGSTAMP
argument_list|,
operator|&
name|pcap_header
operator|.
name|ts
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pcap_header
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pcap_header
operator|.
name|len
operator|=
name|packet_len
expr_stmt|;
comment|/* 	 * Count the packet. 	 * 	 * Arguably, we should count them before we check the filter, 	 * as on many other platforms "ps_recv" counts packets 	 * handed to the filter rather than packets that passed 	 * the filter, but if filtering is done in the kernel, we 	 * can't get a count of packets that passed the filter, 	 * and that would mean the meaning of "ps_recv" wouldn't 	 * be the same on all Linux systems. 	 * 	 * XXX - it's not the same on all systems in any case; 	 * ideally, we should have a "get the statistics" call 	 * that supplies more counts and indicates which of them 	 * it supplies, so that we supply a count of packets 	 * handed to the filter only on platforms where that 	 * information is available. 	 * 	 * We count them here even if we can get the packet count 	 * from the kernel, as we can only determine at run time 	 * whether we'll be able to get it from the kernel (if 	 * HAVE_TPACKET_STATS isn't defined, we can't get it from 	 * the kernel, but if it is defined, the library might 	 * have been built with a 2.4 or later kernel, but we 	 * might be running on a 2.2[.x] kernel without Alexey 	 * Kuznetzov's turbopacket patches, and thus the kernel 	 * might not be able to supply those statistics).  We 	 * could, I guess, try, when opening the socket, to get 	 * the statistics, and if we can not increment the count 	 * here, but it's not clear that always incrementing 	 * the count is more expensive than always testing a flag 	 * in memory. 	 */
name|handle
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_recv
operator|++
expr_stmt|;
comment|/* Call the user supplied callback function */
name|callback
argument_list|(
name|userdata
argument_list|,
operator|&
name|pcap_header
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *  Get the statistics for the given packet capture handle.  *  Reports the number of dropped packets iff the kernel supports  *  the PACKET_STATISTICS "getsockopt()" argument (2.4 and later  *  kernels, and 2.2[.x] kernels with Alexey Kuznetzov's turbopacket  *  patches); otherwise, that information isn't available, and we lie  *  and report 0 as the count of dropped packets.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_stats_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|stats
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TPACKET_STATS
name|struct
name|tpacket_stats
name|kstats
decl_stmt|;
name|socklen_t
name|len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|tpacket_stats
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TPACKET_STATS
comment|/* 	 * Try to get the packet counts from the kernel. 	 */
if|if
condition|(
name|getsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_STATISTICS
argument_list|,
operator|&
name|kstats
argument_list|,
operator|&
name|len
argument_list|)
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* 		 * In "linux/net/packet/af_packet.c", at least in the 		 * 2.4.9 kernel, "tp_packets" is incremented for every 		 * packet that passes the packet filter *and* is 		 * successfully queued on the socket; "tp_drops" is 		 * incremented for every packet dropped because there's 		 * not enough free space in the socket buffer. 		 * 		 * When the statistics are returned for a PACKET_STATISTICS 		 * "getsockopt()" call, "tp_drops" is added to "tp_packets", 		 * so that "tp_packets" counts all packets handed to 		 * the PF_PACKET socket, including packets dropped because 		 * there wasn't room on the socket buffer - but not 		 * including packets that didn't pass the filter. 		 * 		 * In the BSD BPF, the count of received packets is 		 * incremented for every packet handed to BPF, regardless 		 * of whether it passed the filter. 		 * 		 * We can't make "pcap_stats()" work the same on both 		 * platforms, but the best approximation is to return 		 * "tp_packets" as the count of packets and "tp_drops" 		 * as the count of drops. 		 */
name|handle
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_recv
operator|=
name|kstats
operator|.
name|tp_packets
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_drop
operator|=
name|kstats
operator|.
name|tp_drops
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the error was EOPNOTSUPP, fall through, so that 		 * if you build the library on a system with 		 * "struct tpacket_stats" and run it on a system 		 * that doesn't, it works as it does if the library 		 * is built on a system without "struct tpacket_stats". 		 */
if|if
condition|(
name|errno
operator|!=
name|EOPNOTSUPP
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"pcap_stats: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * On systems where the PACKET_STATISTICS "getsockopt()" argument 	 * is supported on PF_PACKET sockets: 	 * 	 *	"ps_recv" counts only packets that *passed* the filter, 	 *	not packets that didn't pass the filter.  This includes 	 *	packets later dropped because we ran out of buffer space. 	 * 	 *	"ps_drop" counts packets dropped because we ran out of 	 *	buffer space.  It doesn't count packets dropped by the 	 *	interface driver.  It counts only packets that passed 	 *	the filter. 	 * 	 *	Both statistics include packets not yet read from the 	 *	kernel by libpcap, and thus not yet seen by the application. 	 * 	 * On systems where the PACKET_STATISTICS "getsockopt()" argument 	 * is not supported on PF_PACKET sockets: 	 * 	 *	"ps_recv" counts only packets that *passed* the filter, 	 *	not packets that didn't pass the filter.  It does not 	 *	count packets dropped because we ran out of buffer 	 *	space. 	 * 	 *	"ps_drop" is not supported. 	 * 	 *	"ps_recv" doesn't include packets not yet read from 	 *	the kernel by libpcap. 	 */
operator|*
name|stats
operator|=
name|handle
operator|->
name|md
operator|.
name|stat
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Description string for the "any" device.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|any_descr
index|[]
init|=
literal|"Pseudo-device that captures on all interfaces"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
if|if
condition|(
name|pcap_add_if
argument_list|(
name|alldevsp
argument_list|,
literal|"any"
argument_list|,
literal|0
argument_list|,
name|any_descr
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_DAG_API
if|if
condition|(
name|dag_platform_finddevs
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_DAG_API */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Attach the given BPF code to the packet capture device.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_setfilter_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|filter
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
name|struct
name|sock_fprog
name|fcode
decl_stmt|;
name|int
name|can_filter_in_kernel
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|handle
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|filter
condition|)
block|{
name|strncpy
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
literal|"setfilter: No filter specified"
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make our private copy of the filter */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|handle
argument_list|,
name|filter
argument_list|)
operator|<
literal|0
condition|)
comment|/* install_bpf_program() filled in errbuf */
return|return
operator|-
literal|1
return|;
comment|/* 	 * Run user level packet filter by default. Will be overriden if 	 * installing a kernel filter succeeds. 	 */
name|handle
operator|->
name|md
operator|.
name|use_bpf
operator|=
literal|0
expr_stmt|;
comment|/* Install kernel level filter if possible */
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
ifdef|#
directive|ifdef
name|USHRT_MAX
if|if
condition|(
name|handle
operator|->
name|fcode
operator|.
name|bf_len
operator|>
name|USHRT_MAX
condition|)
block|{
comment|/* 		 * fcode.len is an unsigned short for current kernel. 		 * I have yet to see BPF-Code with that much 		 * instructions but still it is possible. So for the 		 * sake of correctness I added this check. 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Filter too complex for kernel\n"
argument_list|)
expr_stmt|;
name|fcode
operator|.
name|filter
operator|=
name|NULL
expr_stmt|;
name|can_filter_in_kernel
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* USHRT_MAX */
block|{
comment|/* 		 * Oh joy, the Linux kernel uses struct sock_fprog instead 		 * of struct bpf_program and of course the length field is 		 * of different size. Pointed out by Sebastian 		 * 		 * Oh, and we also need to fix it up so that all "ret" 		 * instructions with non-zero operands have 65535 as the 		 * operand, and so that, if we're in cooked mode, all 		 * memory-reference instructions use special magic offsets 		 * in references to the link-layer header and assume that 		 * the link-layer payload begins at 0; "fix_program()" 		 * will do that. 		 */
switch|switch
condition|(
name|fix_program
argument_list|(
name|handle
argument_list|,
operator|&
name|fcode
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
default|default:
comment|/* 			 * Fatal error; just quit. 			 * (The "default" case shouldn't happen; we 			 * return -1 for that reason.) 			 */
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* 			 * The program performed checks that we can't make 			 * work in the kernel. 			 */
name|can_filter_in_kernel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 			 * We have a filter that'll work in the kernel. 			 */
name|can_filter_in_kernel
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|can_filter_in_kernel
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|set_kernel_filter
argument_list|(
name|handle
argument_list|,
operator|&
name|fcode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Installation succeded - using kernel filter. */
name|handle
operator|->
name|md
operator|.
name|use_bpf
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
comment|/* Non-fatal error */
block|{
comment|/* 			 * Print a warning if we weren't able to install 			 * the filter for a reason other than "this kernel 			 * isn't configured to support socket filters. 			 */
if|if
condition|(
name|errno
operator|!=
name|ENOPROTOOPT
operator|&&
name|errno
operator|!=
name|EOPNOTSUPP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Kernel filter failed: %s\n"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If we're not using the kernel filter, get rid of any kernel 	 * filter that might've been there before, e.g. because the 	 * previous filter could work in the kernel, or because some other 	 * code attached a filter to the socket by some means other than 	 * calling "pcap_setfilter()".  Otherwise, the kernel filter may 	 * filter out packets that would pass the new userland filter. 	 */
if|if
condition|(
operator|!
name|handle
operator|->
name|md
operator|.
name|use_bpf
condition|)
name|reset_kernel_filter
argument_list|(
name|handle
argument_list|)
expr_stmt|;
comment|/* 	 * Free up the copy of the filter that was made by "fix_program()". 	 */
if|if
condition|(
name|fcode
operator|.
name|filter
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fcode
operator|.
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|2
condition|)
comment|/* Fatal error */
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* SO_ATTACH_FILTER */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Linux uses the ARP hardware type to identify the type of an  *  interface. pcap uses the DLT_xxx constants for this. This  *  function takes a pointer to a "pcap_t", and an ARPHRD_xxx  *  constant, as arguments, and sets "handle->linktype" to the  *  appropriate DLT_XXX constant and sets "handle->offset" to  *  the appropriate value (to make "handle->offset" plus link-layer  *  header length be a multiple of 4, so that the link-layer payload  *  will be aligned on a 4-byte boundary when capturing packets).  *  (If the offset isn't set here, it'll be 0; add code as appropriate  *  for cases where it shouldn't be 0.)  *  *  If "cooked_ok" is non-zero, we can use DLT_LINUX_SLL and capture  *  in cooked mode; otherwise, we can't use cooked mode, so we have  *  to pick some type that works in raw mode, or fail.  *  *  Sets the link type to -1 if unable to map the type.  */
end_comment

begin_function
specifier|static
name|void
name|map_arphrd_to_dlt
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|arptype
parameter_list|,
name|int
name|cooked_ok
parameter_list|)
block|{
switch|switch
condition|(
name|arptype
condition|)
block|{
case|case
name|ARPHRD_ETHER
case|:
case|case
name|ARPHRD_METRICOM
case|:
case|case
name|ARPHRD_LOOPBACK
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ARPHRD_EETHER
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_EN3MB
expr_stmt|;
break|break;
case|case
name|ARPHRD_AX25
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_AX25
expr_stmt|;
break|break;
case|case
name|ARPHRD_PRONET
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_PRONET
expr_stmt|;
break|break;
case|case
name|ARPHRD_CHAOS
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_CHAOS
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_IEEE802_TR
define|#
directive|define
name|ARPHRD_IEEE802_TR
value|800
comment|/* From Linux 2.4 */
endif|#
directive|endif
case|case
name|ARPHRD_IEEE802_TR
case|:
case|case
name|ARPHRD_IEEE802
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_IEEE802
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ARPHRD_ARCNET
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_ARCNET_LINUX
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_FDDI
comment|/* From Linux 2.2.13 */
define|#
directive|define
name|ARPHRD_FDDI
value|774
endif|#
directive|endif
case|case
name|ARPHRD_FDDI
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_FDDI
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|3
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_ATM
comment|/* FIXME: How to #include this? */
define|#
directive|define
name|ARPHRD_ATM
value|19
endif|#
directive|endif
case|case
name|ARPHRD_ATM
case|:
comment|/* 		 * The Classical IP implementation in ATM for Linux 		 * supports both what RFC 1483 calls "LLC Encapsulation", 		 * in which each packet has an LLC header, possibly 		 * with a SNAP header as well, prepended to it, and 		 * what RFC 1483 calls "VC Based Multiplexing", in which 		 * different virtual circuits carry different network 		 * layer protocols, and no header is prepended to packets. 		 * 		 * They both have an ARPHRD_ type of ARPHRD_ATM, so 		 * you can't use the ARPHRD_ type to find out whether 		 * captured packets will have an LLC header, and, 		 * while there's a socket ioctl to *set* the encapsulation 		 * type, there's no ioctl to *get* the encapsulation type. 		 * 		 * This means that 		 * 		 *	programs that dissect Linux Classical IP frames 		 *	would have to check for an LLC header and, 		 *	depending on whether they see one or not, dissect 		 *	the frame as LLC-encapsulated or as raw IP (I 		 *	don't know whether there's any traffic other than 		 *	IP that would show up on the socket, or whether 		 *	there's any support for IPv6 in the Linux 		 *	Classical IP code); 		 * 		 *	filter expressions would have to compile into 		 *	code that checks for an LLC header and does 		 *	the right thing. 		 * 		 * Both of those are a nuisance - and, at least on systems 		 * that support PF_PACKET sockets, we don't have to put 		 * up with those nuisances; instead, we can just capture 		 * in cooked mode.  That's what we'll do, if we can. 		 * Otherwise, we'll just fail. 		 */
if|if
condition|(
name|cooked_ok
condition|)
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
else|else
name|handle
operator|->
name|linktype
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_IEEE80211
comment|/* From Linux 2.4.6 */
define|#
directive|define
name|ARPHRD_IEEE80211
value|801
endif|#
directive|endif
case|case
name|ARPHRD_IEEE80211
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_IEEE802_11
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_IEEE80211_PRISM
comment|/* From Linux 2.4.18 */
define|#
directive|define
name|ARPHRD_IEEE80211_PRISM
value|802
endif|#
directive|endif
case|case
name|ARPHRD_IEEE80211_PRISM
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_PRISM_HEADER
expr_stmt|;
break|break;
case|case
name|ARPHRD_PPP
case|:
comment|/* 		 * Some PPP code in the kernel supplies no link-layer 		 * header whatsoever to PF_PACKET sockets; other PPP 		 * code supplies PPP link-layer headers ("syncppp.c"); 		 * some PPP code might supply random link-layer 		 * headers (PPP over ISDN - there's code in Ethereal, 		 * for example, to cope with PPP-over-ISDN captures 		 * with which the Ethereal developers have had to cope, 		 * heuristically trying to determine which of the 		 * oddball link-layer headers particular packets have). 		 * 		 * As such, we just punt, and run all PPP interfaces 		 * in cooked mode, if we can; otherwise, we just treat 		 * it as DLT_RAW, for now - if somebody needs to capture, 		 * on a 2.0[.x] kernel, on PPP devices that supply a 		 * link-layer header, they'll have to add code here to 		 * map to the appropriate DLT_ type (possibly adding a 		 * new DLT_ type, if necessary). 		 */
if|if
condition|(
name|cooked_ok
condition|)
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
else|else
block|{
comment|/* 			 * XXX - handle ISDN types here?  We can't fall 			 * back on cooked sockets, so we'd have to 			 * figure out from the device name what type of 			 * link-layer encapsulation it's using, and map 			 * that to an appropriate DLT_ value, meaning 			 * we'd map "isdnN" devices to DLT_RAW (they 			 * supply raw IP packets with no link-layer 			 * header) and "isdY" devices to a new DLT_I4L_IP 			 * type that has only an Ethernet packet type as 			 * a link-layer header. 			 * 			 * But sometimes we seem to get random crap 			 * in the link-layer header when capturing on 			 * ISDN devices.... 			 */
name|handle
operator|->
name|linktype
operator|=
name|DLT_RAW
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_CISCO
define|#
directive|define
name|ARPHRD_CISCO
value|513
comment|/* previously ARPHRD_HDLC */
endif|#
directive|endif
case|case
name|ARPHRD_CISCO
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_C_HDLC
expr_stmt|;
break|break;
comment|/* Not sure if this is correct for all tunnels, but it 	 * works for CIPE */
case|case
name|ARPHRD_TUNNEL
case|:
ifndef|#
directive|ifndef
name|ARPHRD_SIT
define|#
directive|define
name|ARPHRD_SIT
value|776
comment|/* From Linux 2.2.13 */
endif|#
directive|endif
case|case
name|ARPHRD_SIT
case|:
case|case
name|ARPHRD_CSLIP
case|:
case|case
name|ARPHRD_SLIP6
case|:
case|case
name|ARPHRD_CSLIP6
case|:
case|case
name|ARPHRD_ADAPT
case|:
case|case
name|ARPHRD_SLIP
case|:
ifndef|#
directive|ifndef
name|ARPHRD_RAWHDLC
define|#
directive|define
name|ARPHRD_RAWHDLC
value|518
endif|#
directive|endif
case|case
name|ARPHRD_RAWHDLC
case|:
ifndef|#
directive|ifndef
name|ARPHRD_DLCI
define|#
directive|define
name|ARPHRD_DLCI
value|15
endif|#
directive|endif
case|case
name|ARPHRD_DLCI
case|:
comment|/* 		 * XXX - should some of those be mapped to DLT_LINUX_SLL 		 * instead?  Should we just map all of them to DLT_LINUX_SLL? 		 */
name|handle
operator|->
name|linktype
operator|=
name|DLT_RAW
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_FRAD
define|#
directive|define
name|ARPHRD_FRAD
value|770
endif|#
directive|endif
case|case
name|ARPHRD_FRAD
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_FRELAY
expr_stmt|;
break|break;
case|case
name|ARPHRD_LOCALTLK
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_LTALK
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_FCPP
define|#
directive|define
name|ARPHRD_FCPP
value|784
endif|#
directive|endif
case|case
name|ARPHRD_FCPP
case|:
ifndef|#
directive|ifndef
name|ARPHRD_FCAL
define|#
directive|define
name|ARPHRD_FCAL
value|785
endif|#
directive|endif
case|case
name|ARPHRD_FCAL
case|:
ifndef|#
directive|ifndef
name|ARPHRD_FCPL
define|#
directive|define
name|ARPHRD_FCPL
value|786
endif|#
directive|endif
case|case
name|ARPHRD_FCPL
case|:
ifndef|#
directive|ifndef
name|ARPHRD_FCFABRIC
define|#
directive|define
name|ARPHRD_FCFABRIC
value|787
endif|#
directive|endif
case|case
name|ARPHRD_FCFABRIC
case|:
comment|/* 		 * We assume that those all mean RFC 2625 IP-over- 		 * Fibre Channel, with the RFC 2625 header at 		 * the beginning of the packet. 		 */
name|handle
operator|->
name|linktype
operator|=
name|DLT_IP_OVER_FC
expr_stmt|;
break|break;
case|case
name|ARPHRD_IRDA
case|:
comment|/* Don't expect IP packet out of this interfaces... */
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_IRDA
expr_stmt|;
comment|/* We need to save packet direction for IrDA decoding, 		 * so let's use "Linux-cooked" mode. Jean II */
comment|//handle->md.cooked = 1;
break|break;
default|default:
name|handle
operator|->
name|linktype
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ===== Functions to interface to the newer kernels ================== */
end_comment

begin_comment
comment|/*  *  Try to open a packet socket using the new kernel interface.  *  Returns 0 on failure.  *  FIXME: 0 uses to mean success (Sebastian)  */
end_comment

begin_function
specifier|static
name|int
name|live_open_new
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
name|int
name|sock_fd
init|=
operator|-
literal|1
decl_stmt|,
name|device_id
decl_stmt|,
name|arptype
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|fatal_err
init|=
literal|0
decl_stmt|;
name|struct
name|packet_mreq
name|mr
decl_stmt|;
comment|/* One shot loop used for error handling - bail out with break */
do|do
block|{
comment|/* 		 * Open a socket with protocol family packet. If a device is 		 * given we try to open it in raw mode otherwise we use 		 * the cooked interface. 		 */
name|sock_fd
operator|=
name|device
condition|?
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_RAW
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
else|:
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* It seems the kernel supports the new interface. */
name|handle
operator|->
name|md
operator|.
name|sock_packet
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Get the interface index of the loopback device. 		 * If the attempt fails, don't fail, just set the 		 * "md.lo_ifindex" to -1. 		 * 		 * XXX - can there be more than one device that loops 		 * packets back, i.e. devices other than "lo"?  If so, 		 * we'd need to find them all, and have an array of 		 * indices for them, and check all of them in 		 * "pcap_read_packet()". 		 */
name|handle
operator|->
name|md
operator|.
name|lo_ifindex
operator|=
name|iface_get_id
argument_list|(
name|sock_fd
argument_list|,
literal|"lo"
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
comment|/* 		 * Default value for offset to align link-layer payload 		 * on a 4-byte boundary. 		 */
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* 		 * What kind of frames do we have to deal with? Fall back 		 * to cooked mode if we have an unknown interface type. 		 */
if|if
condition|(
name|device
condition|)
block|{
comment|/* Assume for now we don't need cooked mode. */
name|handle
operator|->
name|md
operator|.
name|cooked
operator|=
literal|0
expr_stmt|;
name|arptype
operator|=
name|iface_get_arptype
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|arptype
operator|==
operator|-
literal|1
condition|)
block|{
name|fatal_err
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|map_arphrd_to_dlt
argument_list|(
name|handle
argument_list|,
name|arptype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
operator|-
literal|1
operator|||
name|handle
operator|->
name|linktype
operator|==
name|DLT_LINUX_SLL
operator|||
name|handle
operator|->
name|linktype
operator|==
name|DLT_LINUX_IRDA
operator|||
operator|(
name|handle
operator|->
name|linktype
operator|==
name|DLT_EN10MB
operator|&&
operator|(
name|strncmp
argument_list|(
literal|"isdn"
argument_list|,
name|device
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
literal|"isdY"
argument_list|,
name|device
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 				 * Unknown interface type (-1), or a 				 * device we explicitly chose to run 				 * in cooked mode (e.g., PPP devices), 				 * or an ISDN device (whose link-layer 				 * type we can only determine by using 				 * APIs that may be different on different 				 * kernels) - reopen in cooked mode. 				 */
if|if
condition|(
name|close
argument_list|(
name|sock_fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"close: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|sock_fd
operator|=
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|handle
operator|->
name|md
operator|.
name|cooked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 					 * Warn that we're falling back on 					 * cooked mode; we may want to 					 * update "map_arphrd_to_dlt()" 					 * to handle the new type. 					 */
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"arptype %d not "
literal|"supported by libpcap - "
literal|"falling back to cooked "
literal|"socket"
argument_list|,
name|arptype
argument_list|)
expr_stmt|;
block|}
comment|/* IrDA capture is not a real "cooked" capture, 				 * it's IrLAP frames, not IP packets. */
if|if
condition|(
name|handle
operator|->
name|linktype
operator|!=
name|DLT_LINUX_IRDA
condition|)
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
block|}
name|device_id
operator|=
name|iface_get_id
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_id
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|iface_bind
argument_list|(
name|sock_fd
argument_list|,
name|device_id
argument_list|,
name|ebuf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
literal|2
condition|)
name|fatal_err
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * This is cooked mode. 			 */
name|handle
operator|->
name|md
operator|.
name|cooked
operator|=
literal|1
expr_stmt|;
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
comment|/* 			 * XXX - squelch GCC complaints about 			 * uninitialized variables; if we can't 			 * select promiscuous mode on all interfaces, 			 * we should move the code below into the 			 * "if (device)" branch of the "if" and 			 * get rid of the next statement. 			 */
name|device_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 		 * Select promiscuous mode on if "promisc" is set. 		 * 		 * Do not turn allmulti mode on if we don't select 		 * promiscuous mode - on some devices (e.g., Orinoco 		 * wireless interfaces), allmulti mode isn't supported 		 * and the driver implements it by turning promiscuous 		 * mode on, and that screws up the operation of the 		 * card as a normal networking interface, and on no 		 * other platform I know of does starting a non- 		 * promiscuous capture affect which multicast packets 		 * are received by the interface. 		 */
comment|/* 		 * Hmm, how can we set promiscuous mode on all interfaces? 		 * I am not sure if that is possible at all. 		 */
if|if
condition|(
name|device
operator|&&
name|promisc
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mr
argument_list|)
argument_list|)
expr_stmt|;
name|mr
operator|.
name|mr_ifindex
operator|=
name|device_id
expr_stmt|;
name|mr
operator|.
name|mr_type
operator|=
name|PACKET_MR_PROMISC
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock_fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_ADD_MEMBERSHIP
argument_list|,
operator|&
name|mr
argument_list|,
sizeof|sizeof
argument_list|(
name|mr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"setsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Save the socket FD in the pcap structure */
name|handle
operator|->
name|fd
operator|=
name|sock_fd
expr_stmt|;
return|return
literal|1
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|sock_fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal_err
condition|)
return|return
operator|-
literal|2
return|;
else|else
return|return
literal|0
return|;
else|#
directive|else
name|strncpy
argument_list|(
name|ebuf
argument_list|,
literal|"New packet capturing interface not supported by build "
literal|"environment"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_comment
comment|/*  *  Return the index of the given device name. Fill ebuf and return  *  -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|iface_get_id
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFINDEX
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ifr
operator|.
name|ifr_ifindex
return|;
block|}
end_function

begin_comment
comment|/*  *  Bind the socket associated with FD to the given device.  */
end_comment

begin_function
specifier|static
name|int
name|iface_bind
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|ifindex
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|sockaddr_ll
name|sll
decl_stmt|;
name|int
name|err
decl_stmt|;
name|socklen_t
name|errlen
init|=
sizeof|sizeof
argument_list|(
name|err
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sll
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sll
argument_list|)
argument_list|)
expr_stmt|;
name|sll
operator|.
name|sll_family
operator|=
name|AF_PACKET
expr_stmt|;
name|sll
operator|.
name|sll_ifindex
operator|=
name|ifindex
expr_stmt|;
name|sll
operator|.
name|sll_protocol
operator|=
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sll
argument_list|,
sizeof|sizeof
argument_list|(
name|sll
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Any pending errors, e.g., network is down? */
if|if
condition|(
name|getsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|errlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|err
operator|>
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===== Functions to interface to the older kernels ================== */
end_comment

begin_comment
comment|/*  * With older kernels promiscuous mode is kind of interesting because we  * have to reset the interface before exiting. The problem can't really  * be solved without some daemon taking care of managing usage counts.  * If we put the interface into promiscuous mode, we set a flag indicating  * that we must take it out of that mode when the interface is closed,  * and, when closing the interface, if that flag is set we take it out  * of promiscuous mode.  */
end_comment

begin_comment
comment|/*  * List of pcaps for which we turned promiscuous mode on by hand.  * If there are any such pcaps, we arrange to call "pcap_close_all()"  * when we exit, and have it close all of them to turn promiscuous mode  * off.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcap
modifier|*
name|pcaps_to_close
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TRUE if we've already called "atexit()" to cause "pcap_close_all()" to  * be called on exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|did_atexit
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pcap_close_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pcap
modifier|*
name|handle
decl_stmt|;
while|while
condition|(
operator|(
name|handle
operator|=
name|pcaps_to_close
operator|)
operator|!=
name|NULL
condition|)
name|pcap_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcap_close_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap
modifier|*
name|p
decl_stmt|,
modifier|*
name|prevp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|clear_promisc
condition|)
block|{
comment|/* 		 * We put the interface into promiscuous mode; take 		 * it out of promiscuous mode. 		 * 		 * XXX - if somebody else wants it in promiscuous mode, 		 * this code cannot know that, so it'll take it out 		 * of promiscuous mode.  That's not fixable in 2.0[.x] 		 * kernels. 		 */
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|handle
operator|->
name|md
operator|.
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface flags (SIOCGIFFLAGS failed: %s).\n"
literal|"Please adjust manually.\n"
literal|"Hint: This can't happen with Linux>= 2.2.0.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* 				 * Promiscuous mode is currently on; turn it 				 * off. 				 */
name|ifr
operator|.
name|ifr_flags
operator|&=
operator|~
name|IFF_PROMISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface flags (SIOCSIFFLAGS failed: %s).\n"
literal|"Please adjust manually.\n"
literal|"Hint: This can't happen with Linux>= 2.2.0.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Take this pcap out of the list of pcaps for which we 		 * have to take the interface out of promiscuous mode. 		 */
for|for
control|(
name|p
operator|=
name|pcaps_to_close
operator|,
name|prevp
operator|=
name|NULL
init|;
name|p
operator|!=
name|NULL
condition|;
name|prevp
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|md
operator|.
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|handle
condition|)
block|{
comment|/* 				 * Found it.  Remove it from the list. 				 */
if|if
condition|(
name|prevp
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * It was at the head of the list. 					 */
name|pcaps_to_close
operator|=
name|p
operator|->
name|md
operator|.
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * It was in the middle of the list. 					 */
name|prevp
operator|->
name|md
operator|.
name|next
operator|=
name|p
operator|->
name|md
operator|.
name|next
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|device
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|handle
operator|->
name|md
operator|.
name|device
argument_list|)
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|device
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|handle
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Try to open a packet socket using the old kernel interface.  *  Returns 0 on failure.  *  FIXME: 0 uses to mean success (Sebastian)  */
end_comment

begin_function
specifier|static
name|int
name|live_open_old
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|int
name|arptype
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
do|do
block|{
comment|/* Open the socket */
name|handle
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_PACKET
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* It worked - we are using the old interface */
name|handle
operator|->
name|md
operator|.
name|sock_packet
operator|=
literal|1
expr_stmt|;
comment|/* ...which means we get the link-layer header. */
name|handle
operator|->
name|md
operator|.
name|cooked
operator|=
literal|0
expr_stmt|;
comment|/* Bind to the given device */
if|if
condition|(
operator|!
name|device
condition|)
block|{
name|strncpy
argument_list|(
name|ebuf
argument_list|,
literal|"pcap_open_live: The \"any\" device isn't supported on 2.0[.x]-kernel systems"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|iface_bind_old
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* 		 * Try to get the link-layer type. 		 */
name|arptype
operator|=
name|iface_get_arptype
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|arptype
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* 		 * Try to find the DLT_ type corresponding to that 		 * link-layer type. 		 */
name|map_arphrd_to_dlt
argument_list|(
name|handle
argument_list|,
name|arptype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown arptype %d"
argument_list|,
name|arptype
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Go to promisc mode if requested */
if|if
condition|(
name|promisc
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_PROMISC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Promiscuous mode isn't currently on, 				 * so turn it on, and remember that 				 * we should turn it off when the 				 * pcap_t is closed. 				 */
comment|/* 				 * If we haven't already done so, arrange 				 * to have "pcap_close_all()" called when 				 * we exit. 				 */
if|if
condition|(
operator|!
name|did_atexit
condition|)
block|{
if|if
condition|(
name|atexit
argument_list|(
name|pcap_close_all
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 						 * "atexit()" failed; don't 						 * put the interface in 						 * promiscuous mode, just 						 * give up. 						 */
name|strncpy
argument_list|(
name|ebuf
argument_list|,
literal|"atexit failed"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
name|did_atexit
operator|=
literal|1
expr_stmt|;
block|}
name|ifr
operator|.
name|ifr_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|handle
operator|->
name|md
operator|.
name|clear_promisc
operator|=
literal|1
expr_stmt|;
comment|/* 				 * Add this to the list of pcaps 				 * to close when we exit. 				 */
name|handle
operator|->
name|md
operator|.
name|next
operator|=
name|pcaps_to_close
expr_stmt|;
name|pcaps_to_close
operator|=
name|handle
expr_stmt|;
block|}
block|}
comment|/* 		 * Default value for offset to align link-layer payload 		 * on a 4-byte boundary. 		 */
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|pcap_close_linux
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Bind the socket associated with FD to the given device using the  *  interface of the old kernels.  */
end_comment

begin_function
specifier|static
name|int
name|iface_bind_old
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|sockaddr
name|saddr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|socklen_t
name|errlen
init|=
sizeof|sizeof
argument_list|(
name|err
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|saddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|saddr
operator|.
name|sa_data
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
operator|.
name|sa_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Any pending errors, e.g., network is down? */
if|if
condition|(
name|getsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|errlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|err
operator|>
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ===== System calls available on all supported kernels ============== */
end_comment

begin_comment
comment|/*  *  Query the kernel for the MTU of the given interface.  */
end_comment

begin_function
specifier|static
name|int
name|iface_get_mtu
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
if|if
condition|(
operator|!
name|device
condition|)
return|return
name|BIGGER_THAN_ALL_MTUS
return|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFMTU
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ifr
operator|.
name|ifr_mtu
return|;
block|}
end_function

begin_comment
comment|/*  *  Get the hardware type of the given interface as ARPHRD_xxx constant.  */
end_comment

begin_function
specifier|static
name|int
name|iface_get_arptype
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFHWADDR
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ifr
operator|.
name|ifr_hwaddr
operator|.
name|sa_family
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
end_ifdef

begin_function
specifier|static
name|int
name|fix_program
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|)
block|{
name|size_t
name|prog_size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|bpf_insn
modifier|*
name|p
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|f
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * Make a copy of the filter, and modify that copy if 	 * necessary. 	 */
name|prog_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|)
operator|*
name|handle
operator|->
name|fcode
operator|.
name|bf_len
expr_stmt|;
name|len
operator|=
name|handle
operator|->
name|fcode
operator|.
name|bf_len
expr_stmt|;
name|f
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
name|malloc
argument_list|(
name|prog_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|f
argument_list|,
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|prog_size
argument_list|)
expr_stmt|;
name|fcode
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|fcode
operator|->
name|filter
operator|=
operator|(
expr|struct
name|sock_filter
operator|*
operator|)
name|f
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|&
name|f
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * What type of instruction is this? 		 */
switch|switch
condition|(
name|BPF_CLASS
argument_list|(
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_RET
case|:
comment|/* 			 * It's a return instruction; is the snapshot 			 * length a constant, rather than the contents 			 * of the accumulator? 			 */
if|if
condition|(
name|BPF_MODE
argument_list|(
name|p
operator|->
name|code
argument_list|)
operator|==
name|BPF_K
condition|)
block|{
comment|/* 				 * Yes - if the value to be returned, 				 * i.e. the snapshot length, is anything 				 * other than 0, make it 65535, so that 				 * the packet is truncated by "recvfrom()", 				 * not by the filter. 				 * 				 * XXX - there's nothing we can easily do 				 * if it's getting the value from the 				 * accumulator; we'd have to insert 				 * code to force non-zero values to be 				 * 65535. 				 */
if|if
condition|(
name|p
operator|->
name|k
operator|!=
literal|0
condition|)
name|p
operator|->
name|k
operator|=
literal|65535
expr_stmt|;
block|}
break|break;
case|case
name|BPF_LD
case|:
case|case
name|BPF_LDX
case|:
comment|/* 			 * It's a load instruction; is it loading 			 * from the packet? 			 */
switch|switch
condition|(
name|BPF_MODE
argument_list|(
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_ABS
case|:
case|case
name|BPF_IND
case|:
case|case
name|BPF_MSH
case|:
comment|/* 				 * Yes; are we in cooked mode? 				 */
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|cooked
condition|)
block|{
comment|/* 					 * Yes, so we need to fix this 					 * instruction. 					 */
if|if
condition|(
name|fix_offset
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 						 * We failed to do so. 						 * Return 0, so our caller 						 * knows to punt to userland. 						 */
return|return
literal|0
return|;
block|}
block|}
break|break;
block|}
break|break;
block|}
block|}
return|return
literal|1
return|;
comment|/* we succeeded */
block|}
end_function

begin_function
specifier|static
name|int
name|fix_offset
parameter_list|(
name|struct
name|bpf_insn
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * What's the offset? 	 */
if|if
condition|(
name|p
operator|->
name|k
operator|>=
name|SLL_HDR_LEN
condition|)
block|{
comment|/* 		 * It's within the link-layer payload; that starts at an 		 * offset of 0, as far as the kernel packet filter is 		 * concerned, so subtract the length of the link-layer 		 * header. 		 */
name|p
operator|->
name|k
operator|-=
name|SLL_HDR_LEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|k
operator|==
literal|14
condition|)
block|{
comment|/* 		 * It's the protocol field; map it to the special magic 		 * kernel offset for that field. 		 */
name|p
operator|->
name|k
operator|=
name|SKF_AD_OFF
operator|+
name|SKF_AD_PROTOCOL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * It's within the header, but it's not one of those 		 * fields; we can't do that in the kernel, so punt 		 * to userland. 		 */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_kernel_filter
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|)
block|{
name|int
name|total_filter_on
init|=
literal|0
decl_stmt|;
name|int
name|save_mode
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
comment|/* 	 * The socket filter code doesn't discard all packets queued 	 * up on the socket when the filter is changed; this means 	 * that packets that don't match the new filter may show up 	 * after the new filter is put onto the socket, if those 	 * packets haven't yet been read. 	 * 	 * This means, for example, that if you do a tcpdump capture 	 * with a filter, the first few packets in the capture might 	 * be packets that wouldn't have passed the filter. 	 * 	 * We therefore discard all packets queued up on the socket 	 * when setting a kernel filter.  (This isn't an issue for 	 * userland filters, as the userland filtering is done after 	 * packets are queued up.) 	 * 	 * To flush those packets, we put the socket in read-only mode, 	 * and read packets from the socket until there are no more to 	 * read. 	 * 	 * In order to keep that from being an infinite loop - i.e., 	 * to keep more packets from arriving while we're draining 	 * the queue - we put the "total filter", which is a filter 	 * that rejects all packets, onto the socket before draining 	 * the queue. 	 * 	 * This code deliberately ignores any errors, so that you may 	 * get bogus packets if an error occurs, rather than having 	 * the filtering done in userland even if it could have been 	 * done in the kernel. 	 */
if|if
condition|(
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ATTACH_FILTER
argument_list|,
operator|&
name|total_fcode
argument_list|,
sizeof|sizeof
argument_list|(
name|total_fcode
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|drain
index|[
literal|1
index|]
decl_stmt|;
comment|/* 		 * Note that we've put the total filter onto the socket. 		 */
name|total_filter_on
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Save the socket's current mode, and put it in 		 * non-blocking mode; we drain it by reading packets 		 * until we get an error (which is normally a 		 * "nothing more to be read" error). 		 */
name|save_mode
operator|=
name|fcntl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_mode
operator|!=
operator|-
literal|1
operator|&&
name|fcntl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|save_mode
operator||
name|O_NONBLOCK
argument_list|)
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|recv
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
operator|&
name|drain
argument_list|,
sizeof|sizeof
name|drain
argument_list|,
name|MSG_TRUNC
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
name|fcntl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|save_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
operator|!=
name|EAGAIN
condition|)
block|{
comment|/* Fatal error */
name|reset_kernel_filter
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"recv: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
block|}
comment|/* 	 * Now attach the new filter. 	 */
name|ret
operator|=
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ATTACH_FILTER
argument_list|,
name|fcode
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fcode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|total_filter_on
condition|)
block|{
comment|/* 		 * Well, we couldn't set that filter on the socket, 		 * but we could set the total filter on the socket. 		 * 		 * This could, for example, mean that the filter was 		 * too big to put into the kernel, so we'll have to 		 * filter in userland; in any case, we'll be doing 		 * filtering in userland, so we need to remove the 		 * total filter so we see packets. 		 */
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* 		 * XXX - if this fails, we're really screwed; 		 * we have the total filter on the socket, 		 * and it won't come off.  What do we do then? 		 */
name|reset_kernel_filter
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reset_kernel_filter
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
comment|/* setsockopt() barfs unless it get a dummy parameter */
name|int
name|dummy
decl_stmt|;
return|return
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DETACH_FILTER
argument_list|,
operator|&
name|dummy
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

