begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  pcap-linux.c: Packet capture interface to the Linux kernel  *  *  Copyright (c) 2000 Torsten Landschoff<torsten@debian.org>  *  		       Sebastian Krahmer<krahmer@cs.uni-potsdam.de>  *    *  License: BSD  *    *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *    *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  3. The names of the authors may not be used to endorse or promote  *     products derived from this software without specific prior  *     written permission.  *    *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  *  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/pcap-linux.c,v 1.51.2.3 2001/01/18 03:59:56 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Known problems with 2.0[.x] kernels:  *  *   - The loopback device gives every packet twice; on 2.2[.x] kernels,  *     if we use PF_PACKET, we can filter out the transmitted version  *     of the packet by using data in the "sockaddr_ll" returned by  *     "recvfrom()", but, on 2.0[.x] kernels, we have to use  *     PF_INET/SOCK_PACKET, which means "recvfrom()" supplies a  *     "sockaddr_pkt" which doesn't give us enough information to let  *     us do that.  *  *   - We have to set the interface's IFF_PROMISC flag ourselves, if  *     we're to run in promiscuous mode, which means we have to turn  *     it off ourselves when we're done; the kernel doesn't keep track  *     of how many sockets are listening promiscuously, which means  *     it won't get turned off automatically when no sockets are  *     listening promiscuously.  We catch "pcap_close()" and, for  *     interfaces we put into promiscuous mode, take them out of  *     promiscuous mode - which isn't necessarily the right thing to  *     do, if another socket also requested promiscuous mode between  *     the time when we opened the socket and the time when we close  *     the socket.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"sll.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETPACKET_PACKET_H
end_ifdef

begin_include
include|#
directive|include
file|<netpacket/packet.h>
end_include

begin_comment
comment|/*   * We assume this means we really do have PF_PACKET sockets.   */
end_comment

begin_define
define|#
directive|define
name|HAVE_PF_PACKET_SOCKETS
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*   * Oh, joy.  Some Linux distributions have 2.2 or later kernels and   * libc5.  On at least one of those systems (Slackware 4.0), it   * appears that "/usr/include/sys/socket.h" includes<linux/socket.h>,   * which means it picks up all the AF_, PF_, and SO_ definitions   * appropriate for the current kernel; however, it also appears that   * they did not see fit to provide a "/usr/include/netpacket/packet.h"   * file.   *   * However, you should be able to get the right definitions by including   *<linux/if_packet.h>.   *   * So if this system has PF_PACKET defined but doesn't have the   *<netpacket/packet.h> header file, we include<linux/if_packet.h>   * instead.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PF_PACKET
end_ifdef

begin_include
include|#
directive|include
file|<linux/if_packet.h>
end_include

begin_comment
comment|/*   * However, on at least some Linux distributions (for example, Red Hat   * 5.2), there's no<netpacket/packet.h> file, but PF_PACKET is defined   * if you include<sys/socket.h>, but<linux/if_packet.h> doesn't define   * any of the PF_PACKET stuff such as "struct sockaddr_ll" or any of   * the PACKET_xxx stuff.   *   * So we check whether PACKET_HOST is defined, and assume that we have   * PF_PACKET sockets only if it is defined.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PACKET_HOST
end_ifdef

begin_define
define|#
directive|define
name|HAVE_PF_PACKET_SOCKETS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PACKET_HOST */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PF_PACKET */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETPACKET_PACKET_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
end_ifdef

begin_include
include|#
directive|include
file|<linux/types.h>
end_include

begin_include
include|#
directive|include
file|<linux/filter.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GLIBC__
end_ifndef

begin_typedef
typedef|typedef
name|int
name|socklen_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSG_TRUNC
end_ifndef

begin_define
define|#
directive|define
name|MSG_TRUNC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_LINKHEADER_SIZE
value|256
end_define

begin_comment
comment|/*   * When capturing on all interfaces we use this as the buffer size.   * Should be bigger then all MTUs that occur in real life.  * 64kB should be enough for now.  */
end_comment

begin_define
define|#
directive|define
name|BIGGER_THAN_ALL_MTUS
value|(64*1024)
end_define

begin_comment
comment|/*  * Prototypes for internal functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|map_arphrd_to_dlt
parameter_list|(
name|int
name|arptype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|live_open_old
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|live_open_new
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_read_packet
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Wrap some ioctl calls  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_function_decl
specifier|static
name|int
name|iface_get_id
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|iface_get_mtu
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iface_get_arptype
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_function_decl
specifier|static
name|int
name|iface_bind
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|ifindex
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|iface_bind_old
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
end_ifdef

begin_function_decl
specifier|static
name|int
name|fix_program
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fix_offset
parameter_list|(
name|struct
name|bpf_insn
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Get a handle for a live capture from the given device. You can   *  pass NULL as device to get all packages (without link level   *  information of course). If you pass 1 as promisc the interface  *  will be set to promiscous mode (XXX: I think this usage should   *  be deprecated and functions be added to select that later allow  *  modification of that values -- Torsten).  *    *  See also pcap(3).  */
end_comment

begin_function
name|pcap_t
modifier|*
name|pcap_open_live
parameter_list|(
name|char
modifier|*
name|device
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
comment|/* Allocate a handle for this session. */
name|pcap_t
modifier|*
name|handle
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Initialize some components of the pcap structure. */
name|memset
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
name|handle
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|timeout
operator|=
name|to_ms
expr_stmt|;
comment|/* 	 * NULL and "any" are special devices which give us the hint to  	 * monitor all devices. 	 */
if|if
condition|(
operator|!
name|device
operator|||
name|strcmp
argument_list|(
name|device
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device
operator|=
name|NULL
expr_stmt|;
name|handle
operator|->
name|md
operator|.
name|device
operator|=
name|strdup
argument_list|(
literal|"any"
argument_list|)
expr_stmt|;
block|}
else|else
name|handle
operator|->
name|md
operator|.
name|device
operator|=
name|strdup
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|device
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"strdup: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  	 * Current Linux kernels use the protocol family PF_PACKET to  	 * allow direct access to all packets on the network while  	 * older kernels had a special socket type SOCK_PACKET to  	 * implement this feature. 	 * While this old implementation is kind of obsolete we need 	 * to be compatible with older kernels for a while so we are  	 * trying both methods with the newer method preferred. 	 */
if|if
condition|(
operator|!
operator|(
name|live_open_new
argument_list|(
name|handle
argument_list|,
name|device
argument_list|,
name|promisc
argument_list|,
name|to_ms
argument_list|,
name|ebuf
argument_list|)
operator|||
name|live_open_old
argument_list|(
name|handle
argument_list|,
name|device
argument_list|,
name|promisc
argument_list|,
name|to_ms
argument_list|,
name|ebuf
argument_list|)
operator|)
condition|)
block|{
comment|/*  		 * Both methods to open the packet socket failed. Tidy 		 * up and report our failure (ebuf is expected to be 		 * set by the functions above).  		 */
name|free
argument_list|(
name|handle
operator|->
name|md
operator|.
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|handle
return|;
block|}
end_function

begin_comment
comment|/*  *  Read at most max_packets from the capture stream and call the callback  *  for each of them. Returns the number of packets handled or -1 if an  *  error occured.   */
end_comment

begin_function
name|int
name|pcap_read
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
comment|/* 	 * Currently, on Linux only one packet is delivered per read, 	 * so we don't loop. 	 */
return|return
name|pcap_read_packet
argument_list|(
name|handle
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Read a packet from the socket calling the handler provided by   *  the user. Returns the number of packets received or -1 if an  *  error occured.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_read_packet
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|userdata
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
name|struct
name|sockaddr_ll
name|from
decl_stmt|;
name|struct
name|sll_header
modifier|*
name|hdrp
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr
name|from
decl_stmt|;
endif|#
directive|endif
name|socklen_t
name|fromlen
decl_stmt|;
name|int
name|packet_len
decl_stmt|,
name|caplen
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/* 	 * If this is a cooked device, leave extra room for a 	 * fake packet header. 	 */
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|cooked
condition|)
name|offset
operator|=
name|SLL_HDR_LEN
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* 	 * This system doesn't have PF_PACKET sockets, so it doesn't 	 * support cooked devices. 	 */
name|offset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Receive a single packet from the kernel */
do|do
block|{
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|packet_len
operator|=
name|recvfrom
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|handle
operator|->
name|buffer
operator|+
name|offset
operator|+
name|handle
operator|->
name|offset
argument_list|,
name|handle
operator|->
name|md
operator|.
name|readlen
operator|-
name|offset
argument_list|,
name|MSG_TRUNC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|packet_len
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
comment|/* Check if an error occured */
if|if
condition|(
name|packet_len
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|0
return|;
comment|/* no packet there */
else|else
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"recvfrom: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/* 	 * If this is from the loopback device, reject outgoing packets; 	 * we'll see the packet as an incoming packet as well, and 	 * we don't want to see it twice. 	 * 	 * We can only do this if we're using PF_PACKET; the address 	 * returned for SOCK_PACKET is a "sockaddr_pkt" which lacks 	 * the relevant packet type information. 	 */
if|if
condition|(
operator|!
name|handle
operator|->
name|md
operator|.
name|sock_packet
operator|&&
name|from
operator|.
name|sll_ifindex
operator|==
name|handle
operator|->
name|md
operator|.
name|lo_ifindex
operator|&&
name|from
operator|.
name|sll_pkttype
operator|==
name|PACKET_OUTGOING
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/* 	 * If this is a cooked device, fill in the fake packet header. 	 */
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|cooked
condition|)
block|{
comment|/* 		 * Add the length of the fake header to the length 		 * of packet data we read. 		 */
name|packet_len
operator|+=
name|SLL_HDR_LEN
expr_stmt|;
name|hdrp
operator|=
operator|(
expr|struct
name|sll_header
operator|*
operator|)
name|handle
operator|->
name|buffer
expr_stmt|;
comment|/* 		 * Map the PACKET_ value to a LINUX_SLL_ value; we 		 * want the same numerical value to be used in 		 * the link-layer header even if the numerical values 		 * for the PACKET_ #defines change, so that programs 		 * that look at the packet type field will always be 		 * able to handle DLT_LINUX_SLL captures. 		 */
switch|switch
condition|(
name|from
operator|.
name|sll_pkttype
condition|)
block|{
case|case
name|PACKET_HOST
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_HOST
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_BROADCAST
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_BROADCAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_MULTICAST
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_MULTICAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_OTHERHOST
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_OTHERHOST
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_OUTGOING
case|:
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|htons
argument_list|(
name|LINUX_SLL_OUTGOING
argument_list|)
expr_stmt|;
break|break;
default|default:
name|hdrp
operator|->
name|sll_pkttype
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|hdrp
operator|->
name|sll_hatype
operator|=
name|htons
argument_list|(
name|from
operator|.
name|sll_hatype
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_halen
operator|=
name|htons
argument_list|(
name|from
operator|.
name|sll_halen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hdrp
operator|->
name|sll_addr
argument_list|,
name|from
operator|.
name|sll_addr
argument_list|,
operator|(
name|from
operator|.
name|sll_halen
operator|>
name|SLL_ADDRLEN
operator|)
condition|?
name|SLL_ADDRLEN
else|:
name|from
operator|.
name|sll_halen
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_protocol
operator|=
name|from
operator|.
name|sll_protocol
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * XXX: According to the kernel source we should get the real  	 * packet len if calling recvfrom with MSG_TRUNC set. It does  	 * not seem to work here :(, but it is supported by this code 	 * anyway.  	 * To be honest the code RELIES on that feature so this is really 	 * broken with 2.2.x kernels. 	 * I spend a day to figure out what's going on and I found out 	 * that the following is happening:  	 * 	 * The packet comes from a random interface and the packet_rcv  	 * hook is called with a clone of the packet. That code inserts 	 * the packet into the receive queue of the packet socket. 	 * If a filter is attached to that socket that filter is run 	 * first - and there lies the problem. The default filter always 	 * cuts the packet at the snaplen: 	 * 	 * # tcpdump -d 	 * (000) ret      #68 	 * 	 * So the packet filter cuts down the packet. The recvfrom call  	 * says "hey, it's only 68 bytes, it fits into the buffer" with 	 * the result that we don't get the real packet length. This  	 * is valid at least until kernel 2.2.17pre6.  	 * 	 * We currently handle this by making a copy of the filter 	 * program, fixing all "ret" instructions with non-zero 	 * operands to have an operand of 65535 so that the filter 	 * doesn't truncate the packet, and supplying that modified 	 * filter to the kernel. 	 */
name|caplen
operator|=
name|packet_len
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|handle
operator|->
name|snapshot
condition|)
name|caplen
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
comment|/* Run the packet filter if not using kernel filter */
if|if
condition|(
operator|!
name|handle
operator|->
name|md
operator|.
name|use_bpf
operator|&&
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
condition|)
block|{
if|if
condition|(
name|bpf_filter
argument_list|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|handle
operator|->
name|buffer
argument_list|,
name|packet_len
argument_list|,
name|caplen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* rejected by filter */
return|return
literal|0
return|;
block|}
block|}
comment|/* Fill in our own header data */
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGSTAMP
argument_list|,
operator|&
name|pcap_header
operator|.
name|ts
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pcap_header
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pcap_header
operator|.
name|len
operator|=
name|packet_len
expr_stmt|;
comment|/* Call the user supplied callback function */
name|handle
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_recv
operator|++
expr_stmt|;
name|callback
argument_list|(
name|userdata
argument_list|,
operator|&
name|pcap_header
argument_list|,
name|handle
operator|->
name|buffer
operator|+
name|handle
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *  Get the statistics for the given packet capture handle.  *  FIXME: Currently does not report the number of dropped packets.  */
end_comment

begin_function
name|int
name|pcap_stats
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|stats
parameter_list|)
block|{
operator|*
name|stats
operator|=
name|handle
operator|->
name|md
operator|.
name|stat
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Attach the given BPF code to the packet capture device.   */
end_comment

begin_function
name|int
name|pcap_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|filter
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
name|struct
name|sock_fprog
name|fcode
decl_stmt|;
name|int
name|can_filter_in_kernel
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|handle
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|filter
condition|)
block|{
name|strncpy
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
literal|"setfilter: No filter specified"
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make our private copy of the filter */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|handle
argument_list|,
name|filter
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*  	 * Run user level packet filter by default. Will be overriden if  	 * installing a kernel filter succeeds.  	 */
name|handle
operator|->
name|md
operator|.
name|use_bpf
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we're reading from a savefile, don't try to install 	 * a kernel filter. 	 */
if|if
condition|(
name|handle
operator|->
name|sf
operator|.
name|rfile
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Install kernel level filter if possible */
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
ifdef|#
directive|ifdef
name|USHRT_MAX
if|if
condition|(
name|handle
operator|->
name|fcode
operator|.
name|bf_len
operator|>
name|USHRT_MAX
condition|)
block|{
comment|/* 		 * fcode.len is an unsigned short for current kernel.  		 * I have yet to see BPF-Code with that much 		 * instructions but still it is possible. So for the 		 * sake of correctness I added this check. 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Filter too complex for kernel\n"
argument_list|)
expr_stmt|;
name|fcode
operator|.
name|filter
operator|=
name|NULL
expr_stmt|;
name|can_filter_in_kernel
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* USHRT_MAX */
block|{
comment|/* 		 * Oh joy, the Linux kernel uses struct sock_fprog instead 		 * of struct bpf_program and of course the length field is 		 * of different size. Pointed out by Sebastian 		 * 		 * Oh, and we also need to fix it up so that all "ret" 		 * instructions with non-zero operands have 65535 as the 		 * operand, and so that, if we're in cooked mode, all 		 * memory-reference instructions use special magic offsets 		 * in references to the link-layer header and assume that 		 * the link-layer payload begins at 0; "fix_program()" 		 * will do that. 		 */
switch|switch
condition|(
name|fix_program
argument_list|(
name|handle
argument_list|,
operator|&
name|fcode
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
default|default:
comment|/* 			 * Fatal error; just quit. 			 * (The "default" case shouldn't happen; we 			 * return -1 for that reason.) 			 */
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* 			 * The program performed checks that we can't make 			 * work in the kernel. 			 */
name|can_filter_in_kernel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 			 * We have a filter that'll work in the kernel. 			 */
name|can_filter_in_kernel
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|can_filter_in_kernel
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ATTACH_FILTER
argument_list|,
operator|&
name|fcode
argument_list|,
sizeof|sizeof
argument_list|(
name|fcode
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Installation succeded - using kernel filter. */
name|handle
operator|->
name|md
operator|.
name|use_bpf
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*  			 * Print a warning if we weren't able to install 			 * the filter for a reason other than "this kernel 			 * isn't configured to support socket filters. 			 */
if|if
condition|(
name|errno
operator|!=
name|ENOPROTOOPT
operator|&&
name|errno
operator|!=
name|EOPNOTSUPP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Kernel filter failed: %s\n"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Free up the copy of the filter that was made by "fix_program()". 	 */
if|if
condition|(
name|fcode
operator|.
name|filter
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fcode
operator|.
name|filter
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SO_ATTACH_FILTER */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Linux uses the ARP hardware type to identify the type of an   *  interface. pcap uses the DLT_xxx constants for this. This   *  function maps the ARPHRD_xxx constant to an appropriate  *  DLT_xxx constant.  *    *  Returns -1 if unable to map the type; we print a message and,  *  if we're using PF_PACKET/SOCK_RAW rather than PF_INET/SOCK_PACKET,  *  we fall back on using PF_PACKET/SOCK_DGRAM.  */
end_comment

begin_function
specifier|static
name|int
name|map_arphrd_to_dlt
parameter_list|(
name|int
name|arptype
parameter_list|)
block|{
switch|switch
condition|(
name|arptype
condition|)
block|{
case|case
name|ARPHRD_ETHER
case|:
case|case
name|ARPHRD_METRICOM
case|:
case|case
name|ARPHRD_LOOPBACK
case|:
return|return
name|DLT_EN10MB
return|;
case|case
name|ARPHRD_EETHER
case|:
return|return
name|DLT_EN3MB
return|;
case|case
name|ARPHRD_AX25
case|:
return|return
name|DLT_AX25
return|;
case|case
name|ARPHRD_PRONET
case|:
return|return
name|DLT_PRONET
return|;
case|case
name|ARPHRD_CHAOS
case|:
return|return
name|DLT_CHAOS
return|;
ifndef|#
directive|ifndef
name|ARPHRD_IEEE802_TR
define|#
directive|define
name|ARPHRD_IEEE802_TR
value|800
comment|/* From Linux 2.4 */
endif|#
directive|endif
case|case
name|ARPHRD_IEEE802_TR
case|:
case|case
name|ARPHRD_IEEE802
case|:
return|return
name|DLT_IEEE802
return|;
case|case
name|ARPHRD_ARCNET
case|:
return|return
name|DLT_ARCNET
return|;
case|case
name|ARPHRD_FDDI
case|:
return|return
name|DLT_FDDI
return|;
ifndef|#
directive|ifndef
name|ARPHRD_ATM
comment|/* FIXME: How to #include this? */
define|#
directive|define
name|ARPHRD_ATM
value|19
endif|#
directive|endif
case|case
name|ARPHRD_ATM
case|:
return|return
name|DLT_ATM_CLIP
return|;
case|case
name|ARPHRD_PPP
case|:
comment|/* Not sure if this is correct for all tunnels, but it 	 * works for CIPE */
case|case
name|ARPHRD_TUNNEL
case|:
ifndef|#
directive|ifndef
name|ARPHRD_SIT
define|#
directive|define
name|ARPHRD_SIT
value|776
comment|/* From Linux 2.2.14 */
endif|#
directive|endif
case|case
name|ARPHRD_SIT
case|:
case|case
name|ARPHRD_CSLIP
case|:
case|case
name|ARPHRD_SLIP6
case|:
case|case
name|ARPHRD_CSLIP6
case|:
case|case
name|ARPHRD_SLIP
case|:
return|return
name|DLT_RAW
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ===== Functions to interface to the newer kernels ================== */
end_comment

begin_comment
comment|/*  *  Try to open a packet socket using the new kernel interface.  *  Returns 0 on failure.  *  FIXME: 0 uses to mean success (Sebastian)  */
end_comment

begin_function
specifier|static
name|int
name|live_open_new
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|char
modifier|*
name|device
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
name|int
name|sock_fd
init|=
operator|-
literal|1
decl_stmt|,
name|device_id
decl_stmt|,
name|mtu
decl_stmt|,
name|arptype
decl_stmt|;
name|struct
name|packet_mreq
name|mr
decl_stmt|;
comment|/* One shot loop used for error handling - bail out with break */
do|do
block|{
comment|/* 		 * Open a socket with protocol family packet. If a device is 		 * given we try to open it in raw mode otherwise we use  		 * the cooked interface.  		 */
name|sock_fd
operator|=
name|device
condition|?
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_RAW
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
else|:
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* It seems the kernel supports the new interface. */
name|handle
operator|->
name|md
operator|.
name|sock_packet
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Get the interface index of the loopback device. 		 * If the attempt fails, don't fail, just set the 		 * "md.lo_ifindex" to -1. 		 * 		 * XXX - can there be more than one device that loops 		 * packets back, i.e. devices other than "lo"?  If so, 		 * we'd need to find them all, and have an array of 		 * indices for them, and check all of them in 		 * "pcap_read_packet()". 		 */
name|handle
operator|->
name|md
operator|.
name|lo_ifindex
operator|=
name|iface_get_id
argument_list|(
name|sock_fd
argument_list|,
literal|"lo"
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
comment|/* 		 * What kind of frames do we have to deal with? Fall back  		 * to cooked mode if we have an unknown interface type.  		 */
if|if
condition|(
name|device
condition|)
block|{
comment|/* Assume for now we don't need cooked mode. */
name|handle
operator|->
name|md
operator|.
name|cooked
operator|=
literal|0
expr_stmt|;
name|arptype
operator|=
name|iface_get_arptype
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|arptype
operator|==
operator|-
literal|1
condition|)
break|break;
name|handle
operator|->
name|linktype
operator|=
name|map_arphrd_to_dlt
argument_list|(
name|arptype
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
operator|-
literal|1
operator|||
operator|(
name|handle
operator|->
name|linktype
operator|==
name|DLT_EN10MB
operator|&&
operator|(
name|strncmp
argument_list|(
literal|"isdn"
argument_list|,
name|device
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
literal|"isdY"
argument_list|,
name|device
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|handle
operator|->
name|linktype
operator|==
name|DLT_RAW
operator|&&
operator|(
name|strncmp
argument_list|(
literal|"ippp"
argument_list|,
name|device
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 				 * Unknown interface type (-1), or an ISDN 				 * device (whose link-layer type we 				 * can only determine by using APIs 				 * that may be different on different 				 * kernels) - reopen in cooked mode. 				 * 				 * XXX - do that with DLT_RAW as well? 				 */
if|if
condition|(
name|close
argument_list|(
name|sock_fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"close: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|sock_fd
operator|=
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|handle
operator|->
name|md
operator|.
name|cooked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 					 * Warn that we're falling back on 					 * cooked mode; we may want to 					 * update "map_arphrd_to_dlt()" 					 * to handle the new type. 					 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: arptype %d not "
literal|"supported by libpcap - "
literal|"falling back to cooked "
literal|"socket\n"
argument_list|,
name|arptype
argument_list|)
expr_stmt|;
block|}
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
block|}
name|device_id
operator|=
name|iface_get_id
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_id
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|iface_bind
argument_list|(
name|sock_fd
argument_list|,
name|device_id
argument_list|,
name|ebuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
else|else
block|{
comment|/* 			 * This is cooked mode. 			 */
name|handle
operator|->
name|md
operator|.
name|cooked
operator|=
literal|1
expr_stmt|;
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
comment|/* 			 * XXX - squelch GCC complaints about 			 * uninitialized variables; if we can't 			 * select promiscuous mode on all interfaces, 			 * we should move the code below into the 			 * "if (device)" branch of the "if" and 			 * get rid of the next statement. 			 */
name|device_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Select promiscuous mode on/off */
ifdef|#
directive|ifdef
name|SOL_PACKET
comment|/*  		 * Hmm, how can we set promiscuous mode on all interfaces? 		 * I am not sure if that is possible at all. 		 */
if|if
condition|(
name|device
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mr
argument_list|)
argument_list|)
expr_stmt|;
name|mr
operator|.
name|mr_ifindex
operator|=
name|device_id
expr_stmt|;
name|mr
operator|.
name|mr_type
operator|=
name|promisc
condition|?
name|PACKET_MR_PROMISC
else|:
name|PACKET_MR_ALLMULTI
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock_fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_ADD_MEMBERSHIP
argument_list|,
operator|&
name|mr
argument_list|,
sizeof|sizeof
argument_list|(
name|mr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"setsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* Compute the buffersize */
name|mtu
operator|=
name|iface_get_mtu
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|==
operator|-
literal|1
condition|)
break|break;
name|handle
operator|->
name|bufsize
operator|=
name|MAX_LINKHEADER_SIZE
operator|+
name|mtu
expr_stmt|;
comment|/* Fill in the pcap structure */
name|handle
operator|->
name|fd
operator|=
name|sock_fd
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|handle
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|handle
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
operator|->
name|buffer
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * This is a 2.2 or later kernel, as it has PF_PACKET; 		 * "recvfrom()", when passed the MSG_TRUNC flag, will 		 * return the actual length of the packet, not the 		 * number of bytes from the packet copied to userland, 		 * so we can safely pass it a byte count based on the 		 * snapshot length. 		 */
name|handle
operator|->
name|md
operator|.
name|readlen
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
return|return
literal|1
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|sock_fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
name|strncpy
argument_list|(
name|ebuf
argument_list|,
literal|"New packet capturing interface not supported by build "
literal|"environment"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_comment
comment|/*  *  Return the index of the given device name. Fill ebuf and return   *  -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|iface_get_id
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFINDEX
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ifr
operator|.
name|ifr_ifindex
return|;
block|}
end_function

begin_comment
comment|/*  *  Bind the socket associated with FD to the given device.   */
end_comment

begin_function
specifier|static
name|int
name|iface_bind
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|ifindex
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|sockaddr_ll
name|sll
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sll
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sll
argument_list|)
argument_list|)
expr_stmt|;
name|sll
operator|.
name|sll_family
operator|=
name|AF_PACKET
expr_stmt|;
name|sll
operator|.
name|sll_ifindex
operator|=
name|ifindex
expr_stmt|;
name|sll
operator|.
name|sll_protocol
operator|=
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sll
argument_list|,
sizeof|sizeof
argument_list|(
name|sll
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===== Functions to interface to the older kernels ================== */
end_comment

begin_comment
comment|/*  * With older kernels promiscuous mode is kind of interesting because we  * have to reset the interface before exiting. The problem can't really  * be solved without some daemon taking care of managing usage counts.   * If we put the interface into promiscuous mode, we set a flag indicating  * that we must take it out of that mode when the interface is closed,  * and, when closing the interface, if that flag is set we take it out  * of promiscuous mode.  */
end_comment

begin_comment
comment|/*  * List of pcaps for which we turned promiscuous mode on by hand.  * If there are any such pcaps, we arrange to call "pcap_close_all()"  * when we exit, and have it close all of them to turn promiscuous mode  * off.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcap
modifier|*
name|pcaps_to_close
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TRUE if we've already called "atexit()" to cause "pcap_close_all()" to  * be called on exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|did_atexit
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pcap_close_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pcap
modifier|*
name|handle
decl_stmt|;
while|while
condition|(
operator|(
name|handle
operator|=
name|pcaps_to_close
operator|)
operator|!=
name|NULL
condition|)
name|pcap_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pcap_close_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap
modifier|*
name|p
decl_stmt|,
modifier|*
name|prevp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|clear_promisc
condition|)
block|{
comment|/* 		 * We put the interface into promiscuous mode; take 		 * it out of promiscuous mode. 		 * 		 * XXX - if somebody else wants it in promiscuous mode, 		 * this code cannot know that, so it'll take it out 		 * of promiscuous mode.  That's not fixable in 2.0[.x] 		 * kernels. 		 */
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|handle
operator|->
name|md
operator|.
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface flags (SIOCGIFFLAGS failed: %s).\n"
literal|"Please adjust manually.\n"
literal|"Hint: This can't happen with Linux>= 2.2.0.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* 				 * Promiscuous mode is currently on; turn it 				 * off. 				 */
name|ifr
operator|.
name|ifr_flags
operator|&=
operator|~
name|IFF_PROMISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface flags (SIOCSIFFLAGS failed: %s).\n"
literal|"Please adjust manually.\n"
literal|"Hint: This can't happen with Linux>= 2.2.0.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Take this pcap out of the list of pcaps for which we 		 * have to take the interface out of promiscuous mode. 		 */
for|for
control|(
name|p
operator|=
name|pcaps_to_close
operator|,
name|prevp
operator|=
name|NULL
init|;
name|p
operator|!=
name|NULL
condition|;
name|prevp
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|md
operator|.
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|handle
condition|)
block|{
comment|/* 				 * Found it.  Remove it from the list. 				 */
if|if
condition|(
name|prevp
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * It was at the head of the list. 					 */
name|pcaps_to_close
operator|=
name|p
operator|->
name|md
operator|.
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * It was in the middle of the list. 					 */
name|prevp
operator|->
name|md
operator|.
name|next
operator|=
name|p
operator|->
name|md
operator|.
name|next
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|device
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|handle
operator|->
name|md
operator|.
name|device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Try to open a packet socket using the old kernel interface.  *  Returns 0 on failure.  *  FIXME: 0 uses to mean success (Sebastian)  */
end_comment

begin_function
specifier|static
name|int
name|live_open_old
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|char
modifier|*
name|device
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|int
name|sock_fd
init|=
operator|-
literal|1
decl_stmt|,
name|mtu
decl_stmt|,
name|arptype
decl_stmt|;
name|struct
name|utsname
name|utsname
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
do|do
block|{
comment|/* Open the socket */
name|sock_fd
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_PACKET
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* It worked - we are using the old interface */
name|handle
operator|->
name|md
operator|.
name|sock_packet
operator|=
literal|1
expr_stmt|;
comment|/* ...which means we get the link-layer header. */
name|handle
operator|->
name|md
operator|.
name|cooked
operator|=
literal|0
expr_stmt|;
comment|/* Bind to the given device */
if|if
condition|(
operator|!
name|device
condition|)
block|{
name|strncpy
argument_list|(
name|ebuf
argument_list|,
literal|"pcap_open_live: The \"any\" device isn't supported on 2.0[.x]-kernel systems"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|iface_bind_old
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* Go to promisc mode */
if|if
condition|(
name|promisc
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_PROMISC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Promiscuous mode isn't currently on, 				 * so turn it on, and remember that 				 * we should turn it off when the 				 * pcap_t is closed. 				 */
comment|/* 				 * If we haven't already done so, arrange 				 * to have "pcap_close_all()" called when 				 * we exit. 				 */
if|if
condition|(
operator|!
name|did_atexit
condition|)
block|{
if|if
condition|(
name|atexit
argument_list|(
name|pcap_close_all
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 						 * "atexit()" failed; don't 						 * put the interface in 						 * promiscuous mode, just 						 * give up. 						 */
name|strncpy
argument_list|(
name|ebuf
argument_list|,
literal|"atexit failed"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ifr
operator|.
name|ifr_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|handle
operator|->
name|md
operator|.
name|clear_promisc
operator|=
literal|1
expr_stmt|;
comment|/* 				 * Add this to the list of pcaps 				 * to close when we exit. 				 */
name|handle
operator|->
name|md
operator|.
name|next
operator|=
name|pcaps_to_close
expr_stmt|;
name|pcaps_to_close
operator|=
name|handle
expr_stmt|;
block|}
block|}
comment|/* Compute the buffersize */
name|mtu
operator|=
name|iface_get_mtu
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|==
operator|-
literal|1
condition|)
break|break;
name|handle
operator|->
name|bufsize
operator|=
name|MAX_LINKHEADER_SIZE
operator|+
name|mtu
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|bufsize
operator|<
name|handle
operator|->
name|snapshot
condition|)
name|handle
operator|->
name|bufsize
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
comment|/* All done - fill in the pcap handle */
name|arptype
operator|=
name|iface_get_arptype
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|arptype
operator|==
operator|-
literal|1
condition|)
break|break;
name|handle
operator|->
name|fd
operator|=
name|sock_fd
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|handle
operator|->
name|linktype
operator|=
name|map_arphrd_to_dlt
argument_list|(
name|arptype
argument_list|)
expr_stmt|;
comment|/* 		 * XXX - handle ISDN types here?  We can't fall back on 		 * cooked sockets, so we'd have to figure out from the 		 * device name what type of link-layer encapsulation 		 * it's using, and map that to an appropriate DLT_ 		 * value, meaning we'd map "isdnN" devices to DLT_RAW 		 * (they supply raw IP packets with no link-layer 		 * header) and "isdY" devices to a new DLT_I4L_IP 		 * type that has only an Ethernet packet type as 		 * a link-layer header. 		 */
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"interface type of %s not supported"
argument_list|,
name|device
argument_list|)
expr_stmt|;
break|break;
block|}
name|handle
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|handle
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
operator|->
name|buffer
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * This might be a 2.0[.x] kernel - check. 		 */
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|<
literal|0
operator|||
name|strncmp
argument_list|(
name|utsname
operator|.
name|release
argument_list|,
literal|"2.0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Either we couldn't find out what kernel release 			 * this is, or it's a 2.0[.x] kernel. 			 * 			 * In the 2.0[.x] kernel, a "recvfrom()" on 			 * a SOCK_PACKET socket, with MSG_TRUNC set, will 			 * return the number of bytes read, so if we pass 			 * a length based on the snapshot length, it'll 			 * return the number of bytes from the packet 			 * copied to userland, not the actual length 			 * of the packet. 			 * 			 * This means that, for example, the IP dissector 			 * in tcpdump will get handed a packet length less 			 * than the length in the IP header, and will 			 * complain about "truncated-ip". 			 * 			 * So we don't bother trying to copy from the 			 * kernel only the bytes in which we're interested, 			 * but instead copy them all, just as the older 			 * versions of libpcap for Linux did. 			 * 			 * Just one of many problems with packet capture 			 * on 2.0[.x] kernels; you really want a 2.2[.x] 			 * or later kernel if you want packet capture to 			 * work well. 			 */
name|handle
operator|->
name|md
operator|.
name|readlen
operator|=
name|handle
operator|->
name|bufsize
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This is a 2.2[.x] or later kernel (although 			 * why we're using SOCK_PACKET on such a system 			 * is unknown to me). 			 * 			 * We can safely pass "recvfrom()" a byte count 			 * based on the snapshot length. 			 */
name|handle
operator|->
name|md
operator|.
name|readlen
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|sock_fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Bind the socket associated with FD to the given device using the   *  interface of the old kernels.  */
end_comment

begin_function
specifier|static
name|int
name|iface_bind_old
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|sockaddr
name|saddr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|saddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|saddr
operator|.
name|sa_data
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
operator|.
name|sa_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ===== System calls available on all supported kernels ============== */
end_comment

begin_comment
comment|/*  *  Query the kernel for the MTU of the given interface.   */
end_comment

begin_function
specifier|static
name|int
name|iface_get_mtu
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
if|if
condition|(
operator|!
name|device
condition|)
return|return
name|BIGGER_THAN_ALL_MTUS
return|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFMTU
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ifr
operator|.
name|ifr_mtu
return|;
block|}
end_function

begin_comment
comment|/*  *  Get the hardware type of the given interface as ARPHRD_xxx constant.  */
end_comment

begin_function
specifier|static
name|int
name|iface_get_arptype
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFHWADDR
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"ioctl: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ifr
operator|.
name|ifr_hwaddr
operator|.
name|sa_family
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_function
specifier|static
name|int
name|fix_program
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|)
block|{
name|size_t
name|prog_size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|bpf_insn
modifier|*
name|p
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|f
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * Make a copy of the filter, and modify that copy if 	 * necessary. 	 */
name|prog_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|)
operator|*
name|handle
operator|->
name|fcode
operator|.
name|bf_len
expr_stmt|;
name|len
operator|=
name|handle
operator|->
name|fcode
operator|.
name|bf_len
expr_stmt|;
name|f
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
name|malloc
argument_list|(
name|prog_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|f
argument_list|,
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|prog_size
argument_list|)
expr_stmt|;
name|fcode
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|fcode
operator|->
name|filter
operator|=
operator|(
expr|struct
name|sock_filter
operator|*
operator|)
name|f
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|&
name|f
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * What type of instruction is this? 		 */
switch|switch
condition|(
name|BPF_CLASS
argument_list|(
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_RET
case|:
comment|/* 			 * It's a return instruction; is the snapshot 			 * length a constant, rather than the contents 			 * of the accumulator? 			 */
if|if
condition|(
name|BPF_MODE
argument_list|(
name|p
operator|->
name|code
argument_list|)
operator|==
name|BPF_K
condition|)
block|{
comment|/* 				 * Yes - if the value to be returned, 				 * i.e. the snapshot length, is anything 				 * other than 0, make it 65535, so that 				 * the packet is truncated by "recvfrom()", 				 * not by the filter. 				 * 				 * XXX - there's nothing we can easily do 				 * if it's getting the value from the 				 * accumulator; we'd have to insert 				 * code to force non-zero values to be 				 * 65535. 				 */
if|if
condition|(
name|p
operator|->
name|k
operator|!=
literal|0
condition|)
name|p
operator|->
name|k
operator|=
literal|65535
expr_stmt|;
block|}
break|break;
case|case
name|BPF_LD
case|:
case|case
name|BPF_LDX
case|:
comment|/* 			 * It's a load instruction; is it loading 			 * from the packet? 			 */
switch|switch
condition|(
name|BPF_MODE
argument_list|(
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_ABS
case|:
case|case
name|BPF_IND
case|:
case|case
name|BPF_MSH
case|:
comment|/* 				 * Yes; are we in cooked mode? 				 */
if|if
condition|(
name|handle
operator|->
name|md
operator|.
name|cooked
condition|)
block|{
comment|/* 					 * Yes, so we need to fix this 					 * instruction. 					 */
if|if
condition|(
name|fix_offset
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 						 * We failed to do so. 						 * Return 0, so our caller 						 * knows to punt to userland. 						 */
return|return
literal|0
return|;
block|}
block|}
break|break;
block|}
break|break;
block|}
block|}
return|return
literal|1
return|;
comment|/* we succeeded */
block|}
end_function

begin_function
specifier|static
name|int
name|fix_offset
parameter_list|(
name|struct
name|bpf_insn
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * What's the offset? 	 */
if|if
condition|(
name|p
operator|->
name|k
operator|>=
name|SLL_HDR_LEN
condition|)
block|{
comment|/* 		 * It's within the link-layer payload; that starts at an 		 * offset of 0, as far as the kernel packet filter is 		 * concerned, so subtract the length of the link-layer 		 * header. 		 */
name|p
operator|->
name|k
operator|-=
name|SLL_HDR_LEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|k
operator|==
literal|14
condition|)
block|{
comment|/* 		 * It's the protocol field; map it to the special magic 		 * kernel offset for that field. 		 */
name|p
operator|->
name|k
operator|=
name|SKF_AD_OFF
operator|+
name|SKF_AD_PROTOCOL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * It's within the header, but it's not one of those 		 * fields; we can't do that in the kernel, so punt 		 * to userland. 		 */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

