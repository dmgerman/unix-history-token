begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  pcap-linux.c: Packet capture interface to the Linux kernel  *  *  Copyright (c) 2000 Torsten Landschoff<torsten@debian.org>  *  		       Sebastian Krahmer<krahmer@cs.uni-potsdam.de>  *  *  License: BSD  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  3. The names of the authors may not be used to endorse or promote  *     products derived from this software without specific prior  *     written permission.  *  *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  *  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *  Modifications:     Added PACKET_MMAP support  *                     Paolo Abeni<paolo.abeni@email.it>  *                     Added TPACKET_V3 support  *                     Gabor Tatarka<gabor.tatarka@ericsson.com>  *  *                     based on previous works of:  *                     Simon Patarin<patarin@cs.unibo.it>  *                     Phil Wood<cpw@lanl.gov>  *  * Monitor-mode support for mac80211 includes code taken from the iw  * command; the copyright notice for that code is  *  * Copyright (c) 2007, 2008	Johannes Berg  * Copyright (c) 2007		Andy Lutomirski  * Copyright (c) 2007		Mike Kershaw  * Copyright (c) 2008		GÃ¡bor Stefanik  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Known problems with 2.0[.x] kernels:  *  *   - The loopback device gives every packet twice; on 2.2[.x] kernels,  *     if we use PF_PACKET, we can filter out the transmitted version  *     of the packet by using data in the "sockaddr_ll" returned by  *     "recvfrom()", but, on 2.0[.x] kernels, we have to use  *     PF_INET/SOCK_PACKET, which means "recvfrom()" supplies a  *     "sockaddr_pkt" which doesn't give us enough information to let  *     us do that.  *  *   - We have to set the interface's IFF_PROMISC flag ourselves, if  *     we're to run in promiscuous mode, which means we have to turn  *     it off ourselves when we're done; the kernel doesn't keep track  *     of how many sockets are listening promiscuously, which means  *     it won't get turned off automatically when no sockets are  *     listening promiscuously.  We catch "pcap_close()" and, for  *     interfaces we put into promiscuous mode, take them out of  *     promiscuous mode - which isn't necessarily the right thing to  *     do, if another socket also requested promiscuous mode between  *     the time when we opened the socket and the time when we close  *     the socket.  *  *   - MSG_TRUNC isn't supported, so you can't specify that "recvfrom()"  *     return the amount of data that you could have read, rather than  *     the amount that was returned, so we can't just allocate a buffer  *     whose size is the snapshot length and pass the snapshot length  *     as the byte count, and also pass MSG_TRUNC, so that the return  *     value tells us how long the packet was on the wire.  *  *     This means that, if we want to get the actual size of the packet,  *     so we can return it in the "len" field of the packet header,  *     we have to read the entire packet, not just the part that fits  *     within the snapshot length, and thus waste CPU time copying data  *     from the kernel that our caller won't see.  *  *     We have to get the actual size, and supply it in "len", because  *     otherwise, the IP dissector in tcpdump, for example, will complain  *     about "truncated-ip", as the packet will appear to have been  *     shorter, on the wire, than the IP header said it should have been.  */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<linux/if.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_packet.h>
end_include

begin_include
include|#
directive|include
file|<linux/sockios.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"pcap/sll.h"
end_include

begin_include
include|#
directive|include
file|"pcap/vlan.h"
end_include

begin_comment
comment|/*  * If PF_PACKET is defined, we can use {SOCK_RAW,SOCK_DGRAM}/PF_PACKET  * sockets rather than SOCK_PACKET sockets.  *  * To use them, we include<linux/if_packet.h> rather than  *<netpacket/packet.h>; we do so because  *  *	some Linux distributions (e.g., Slackware 4.0) have 2.2 or  *	later kernels and libc5, and don't provide a<netpacket/packet.h>  *	file;  *  *	not all versions of glibc2 have a<netpacket/packet.h> file  *	that defines stuff needed for some of the 2.4-or-later-kernel  *	features, so if the system has a 2.4 or later kernel, we  *	still can't use those features.  *  * We're already including a number of other<linux/XXX.h> headers, and  * this code is Linux-specific (no other OS has PF_PACKET sockets as  * a raw packet capture mechanism), so it's not as if you gain any  * useful portability by using<netpacket/packet.h>  *  * XXX - should we just include<linux/if_packet.h> even if PF_PACKET  * isn't defined?  It only defines one data structure in 2.0.x, so  * it shouldn't cause any problems.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PF_PACKET
end_ifdef

begin_include
include|#
directive|include
file|<linux/if_packet.h>
end_include

begin_comment
comment|/*   * On at least some Linux distributions (for example, Red Hat 5.2),   * there's no<netpacket/packet.h> file, but PF_PACKET is defined if   * you include<sys/socket.h>, but<linux/if_packet.h> doesn't define   * any of the PF_PACKET stuff such as "struct sockaddr_ll" or any of   * the PACKET_xxx stuff.   *   * So we check whether PACKET_HOST is defined, and assume that we have   * PF_PACKET sockets only if it is defined.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PACKET_HOST
end_ifdef

begin_define
define|#
directive|define
name|HAVE_PF_PACKET_SOCKETS
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PACKET_AUXDATA
end_ifdef

begin_define
define|#
directive|define
name|HAVE_PACKET_AUXDATA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PACKET_AUXDATA */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PACKET_HOST */
end_comment

begin_comment
comment|/* check for memory mapped access avaibility. We assume every needed   * struct is defined if the macro TPACKET_HDRLEN is defined, because it   * uses many ring related structs and macros */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PCAP_SUPPORT_PACKET_RING
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TPACKET_HDRLEN
end_ifdef

begin_define
define|#
directive|define
name|HAVE_PACKET_RING
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TPACKET3_HDRLEN
end_ifdef

begin_define
define|#
directive|define
name|HAVE_TPACKET3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TPACKET3_HDRLEN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TPACKET2_HDRLEN
end_ifdef

begin_define
define|#
directive|define
name|HAVE_TPACKET2
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TPACKET2_HDRLEN */
end_comment

begin_define
define|#
directive|define
name|TPACKET_V1
value|0
end_define

begin_comment
comment|/* Old kernel with only V1, so no TPACKET_Vn defined */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TPACKET2_HDRLEN */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TPACKET_HDRLEN */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCAP_SUPPORT_PACKET_RING */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PF_PACKET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
end_ifdef

begin_include
include|#
directive|include
file|<linux/types.h>
end_include

begin_include
include|#
directive|include
file|<linux/filter.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_NET_TSTAMP_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/net_tstamp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_SOCKIOS_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/sockios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_IF_BONDING_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/if_bonding.h>
end_include

begin_comment
comment|/*  * The ioctl code to use to check whether a device is a bonding device.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIOCBONDINFOQUERY
argument_list|)
end_if

begin_define
define|#
directive|define
name|BOND_INFO_QUERY_IOCTL
value|SIOCBONDINFOQUERY
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|BOND_INFO_QUERY_OLD
argument_list|)
end_elif

begin_define
define|#
directive|define
name|BOND_INFO_QUERY_IOCTL
value|BOND_INFO_QUERY_OLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINUX_IF_BONDING_H */
end_comment

begin_comment
comment|/*  * Got Wireless Extensions?  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_WIRELESS_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/wireless.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINUX_WIRELESS_H */
end_comment

begin_comment
comment|/*  * Got libnl?  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBNL
end_ifdef

begin_include
include|#
directive|include
file|<linux/nl80211.h>
end_include

begin_include
include|#
directive|include
file|<netlink/genl/genl.h>
end_include

begin_include
include|#
directive|include
file|<netlink/genl/family.h>
end_include

begin_include
include|#
directive|include
file|<netlink/genl/ctrl.h>
end_include

begin_include
include|#
directive|include
file|<netlink/msg.h>
end_include

begin_include
include|#
directive|include
file|<netlink/attr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIBNL */
end_comment

begin_comment
comment|/*  * Got ethtool support?  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_ETHTOOL_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/ethtool.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SOCKLEN_T
end_ifndef

begin_typedef
typedef|typedef
name|int
name|socklen_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSG_TRUNC
end_ifndef

begin_comment
comment|/*  * This is being compiled on a system that lacks MSG_TRUNC; define it  * with the value it has in the 2.2 and later kernels, so that, on  * those kernels, when we pass it in the flags argument to "recvfrom()"  * we're passing the right value and thus get the MSG_TRUNC behavior  * we want.  (We don't get that behavior on 2.0[.x] kernels, because  * they didn't support MSG_TRUNC.)  */
end_comment

begin_define
define|#
directive|define
name|MSG_TRUNC
value|0x20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOL_PACKET
end_ifndef

begin_comment
comment|/*  * This is being compiled on a system that lacks SOL_PACKET; define it  * with the value it has in the 2.2 and later kernels, so that we can  * set promiscuous mode in the good modern way rather than the old  * 2.0-kernel crappy way.  */
end_comment

begin_define
define|#
directive|define
name|SOL_PACKET
value|263
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_LINKHEADER_SIZE
value|256
end_define

begin_comment
comment|/*  * When capturing on all interfaces we use this as the buffer size.  * Should be bigger then all MTUs that occur in real life.  * 64kB should be enough for now.  */
end_comment

begin_define
define|#
directive|define
name|BIGGER_THAN_ALL_MTUS
value|(64*1024)
end_define

begin_comment
comment|/*  * Private data for capturing on Linux SOCK_PACKET or PF_PACKET sockets.  */
end_comment

begin_struct
struct|struct
name|pcap_linux
block|{
name|u_int
name|packets_read
decl_stmt|;
comment|/* count of packets read with recvfrom() */
name|long
name|proc_dropped
decl_stmt|;
comment|/* packets reported dropped by /proc/net/dev */
name|struct
name|pcap_stat
name|stat
decl_stmt|;
name|char
modifier|*
name|device
decl_stmt|;
comment|/* device name */
name|int
name|filter_in_userland
decl_stmt|;
comment|/* must filter in userland */
name|int
name|blocks_to_filter_in_userland
decl_stmt|;
name|int
name|must_do_on_close
decl_stmt|;
comment|/* stuff we must do when we close */
name|int
name|timeout
decl_stmt|;
comment|/* timeout for buffering */
name|int
name|sock_packet
decl_stmt|;
comment|/* using Linux 2.0 compatible interface */
name|int
name|cooked
decl_stmt|;
comment|/* using SOCK_DGRAM rather than SOCK_RAW */
name|int
name|ifindex
decl_stmt|;
comment|/* interface index of device we're bound to */
name|int
name|lo_ifindex
decl_stmt|;
comment|/* interface index of the loopback device */
name|bpf_u_int32
name|oldmode
decl_stmt|;
comment|/* mode to restore when turning monitor mode off */
name|char
modifier|*
name|mondevice
decl_stmt|;
comment|/* mac80211 monitor device we created */
name|u_char
modifier|*
name|mmapbuf
decl_stmt|;
comment|/* memory-mapped region pointer */
name|size_t
name|mmapbuflen
decl_stmt|;
comment|/* size of region */
name|int
name|vlan_offset
decl_stmt|;
comment|/* offset at which to insert vlan tags; if -1, don't insert */
name|u_int
name|tp_version
decl_stmt|;
comment|/* version of tpacket_hdr for mmaped ring */
name|u_int
name|tp_hdrlen
decl_stmt|;
comment|/* hdrlen of tpacket_hdr for mmaped ring */
name|u_char
modifier|*
name|oneshot_buffer
decl_stmt|;
comment|/* buffer for copy of packet */
name|int
name|poll_timeout
decl_stmt|;
comment|/* timeout to use in poll() */
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
name|unsigned
name|char
modifier|*
name|current_packet
decl_stmt|;
comment|/* Current packet within the TPACKET_V3 block. Move to next block if NULL. */
name|int
name|packets_left
decl_stmt|;
comment|/* Unhandled packets left within the block from previous call to pcap_read_linux_mmap_v3 in case of TPACKET_V3. */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * Stuff to do when we close.  */
end_comment

begin_define
define|#
directive|define
name|MUST_CLEAR_PROMISC
value|0x00000001
end_define

begin_comment
comment|/* clear promiscuous mode */
end_comment

begin_define
define|#
directive|define
name|MUST_CLEAR_RFMON
value|0x00000002
end_define

begin_comment
comment|/* clear rfmon (monitor) mode */
end_comment

begin_define
define|#
directive|define
name|MUST_DELETE_MONIF
value|0x00000004
end_define

begin_comment
comment|/* delete monitor-mode interface */
end_comment

begin_comment
comment|/*  * Prototypes for internal functions and methods.  */
end_comment

begin_function_decl
specifier|static
name|void
name|map_arphrd_to_dlt
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_function_decl
specifier|static
name|short
name|int
name|map_packet_type_to_sll_type
parameter_list|(
name|short
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|pcap_activate_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|activate_old
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|activate_new
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|activate_mmap
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_can_set_rfmon_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_read_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_read_packet
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_inject_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_stats_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|pcap_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setfilter_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setdirection_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|pcap_direction_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_set_datalink_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcap_cleanup_linux
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This is what the header structure looks like in a 64-bit kernel;  * we use this, rather than struct tpacket_hdr, if we're using  * TPACKET_V1 in 32-bit code running on a 64-bit kernel.  */
end_comment

begin_struct
struct|struct
name|tpacket_hdr_64
block|{
name|uint64_t
name|tp_status
decl_stmt|;
name|unsigned
name|int
name|tp_len
decl_stmt|;
name|unsigned
name|int
name|tp_snaplen
decl_stmt|;
name|unsigned
name|short
name|tp_mac
decl_stmt|;
name|unsigned
name|short
name|tp_net
decl_stmt|;
name|unsigned
name|int
name|tp_sec
decl_stmt|;
name|unsigned
name|int
name|tp_usec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * We use this internally as the tpacket version for TPACKET_V1 in  * 32-bit code on a 64-bit kernel.  */
end_comment

begin_define
define|#
directive|define
name|TPACKET_V1_64
value|99
end_define

begin_union
union|union
name|thdr
block|{
name|struct
name|tpacket_hdr
modifier|*
name|h1
decl_stmt|;
name|struct
name|tpacket_hdr_64
modifier|*
name|h1_64
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TPACKET2
name|struct
name|tpacket2_hdr
modifier|*
name|h2
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
name|struct
name|tpacket_block_desc
modifier|*
name|h3
decl_stmt|;
endif|#
directive|endif
name|void
modifier|*
name|raw
decl_stmt|;
block|}
union|;
end_union

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PACKET_RING
end_ifdef

begin_define
define|#
directive|define
name|RING_GET_FRAME_AT
parameter_list|(
name|h
parameter_list|,
name|offset
parameter_list|)
value|(((union thdr **)h->buffer)[(offset)])
end_define

begin_define
define|#
directive|define
name|RING_GET_CURRENT_FRAME
parameter_list|(
name|h
parameter_list|)
value|RING_GET_FRAME_AT(h, h->offset)
end_define

begin_function_decl
specifier|static
name|void
name|destroy_ring
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_ring
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prepare_tpacket_socket
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcap_cleanup_linux_mmap
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_read_linux_mmap_v1
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_read_linux_mmap_v1_64
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TPACKET2
end_ifdef

begin_function_decl
specifier|static
name|int
name|pcap_read_linux_mmap_v2
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
end_ifdef

begin_function_decl
specifier|static
name|int
name|pcap_read_linux_mmap_v3
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|pcap_setfilter_linux_mmap
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setnonblock_mmap
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_getnonblock_mmap
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcap_oneshot_mmap
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TP_STATUS_VLAN_TPID_VALID
end_ifdef

begin_define
define|#
directive|define
name|VLAN_TPID
parameter_list|(
name|hdr
parameter_list|,
name|hv
parameter_list|)
value|(((hv)->tp_vlan_tpid || ((hdr)->tp_status& TP_STATUS_VLAN_TPID_VALID)) ? (hv)->tp_vlan_tpid : ETH_P_8021Q)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VLAN_TPID
parameter_list|(
name|hdr
parameter_list|,
name|hv
parameter_list|)
value|ETH_P_8021Q
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Wrap some ioctl calls  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_function_decl
specifier|static
name|int
name|iface_get_id
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PF_PACKET_SOCKETS */
end_comment

begin_function_decl
specifier|static
name|int
name|iface_get_mtu
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iface_get_arptype
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
end_ifdef

begin_function_decl
specifier|static
name|int
name|iface_bind
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|ifindex
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
end_ifdef

begin_function_decl
specifier|static
name|int
name|has_wext
parameter_list|(
name|int
name|sock_fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IW_MODE_MONITOR */
end_comment

begin_function_decl
specifier|static
name|int
name|enter_rfmon_mode
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|sock_fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PF_PACKET_SOCKETS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LINUX_NET_TSTAMP_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|PACKET_TIMESTAMP
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|iface_ethtool_get_ts_info
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PACKET_RING
end_ifdef

begin_function_decl
specifier|static
name|int
name|iface_get_offload
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|iface_bind_old
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
end_ifdef

begin_function_decl
specifier|static
name|int
name|fix_program
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|,
name|int
name|is_mapped
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fix_offset
parameter_list|(
name|struct
name|bpf_insn
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_kernel_filter
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reset_kernel_filter
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|sock_filter
name|total_insn
init|=
name|BPF_STMT
argument_list|(
name|BPF_RET
operator||
name|BPF_K
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sock_fprog
name|total_fcode
init|=
block|{
literal|1
block|,
operator|&
name|total_insn
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SO_ATTACH_FILTER */
end_comment

begin_function
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|handle
decl_stmt|;
name|handle
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_linux
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|handle
operator|->
name|activate_op
operator|=
name|pcap_activate_linux
expr_stmt|;
name|handle
operator|->
name|can_set_rfmon_op
operator|=
name|pcap_can_set_rfmon_linux
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LINUX_NET_TSTAMP_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|PACKET_TIMESTAMP
argument_list|)
comment|/* 	 * See what time stamp types we support. 	 */
if|if
condition|(
name|iface_ethtool_get_ts_info
argument_list|(
name|device
argument_list|,
name|handle
argument_list|,
name|ebuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIOCGSTAMPNS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SO_TIMESTAMPNS
argument_list|)
comment|/* 	 * We claim that we support microsecond and nanosecond time 	 * stamps. 	 * 	 * XXX - with adapter-supplied time stamps, can we choose 	 * microsecond or nanosecond time stamps on arbitrary 	 * adapters? 	 */
name|handle
operator|->
name|tstamp_precision_count
operator|=
literal|2
expr_stmt|;
name|handle
operator|->
name|tstamp_precision_list
operator|=
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|tstamp_precision_list
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|pcap_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|handle
operator|->
name|tstamp_precision_list
index|[
literal|0
index|]
operator|=
name|PCAP_TSTAMP_PRECISION_MICRO
expr_stmt|;
name|handle
operator|->
name|tstamp_precision_list
index|[
literal|1
index|]
operator|=
name|PCAP_TSTAMP_PRECISION_NANO
expr_stmt|;
endif|#
directive|endif
comment|/* defined(SIOCGSTAMPNS)&& defined(SO_TIMESTAMPNS) */
return|return
name|handle
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBNL
end_ifdef

begin_comment
comment|/*  * If interface {if} is a mac80211 driver, the file  * /sys/class/net/{if}/phy80211 is a symlink to  * /sys/class/ieee80211/{phydev}, for some {phydev}.  *  * On Fedora 9, with a 2.6.26.3-29 kernel, my Zydas stick, at  * least, has a "wmaster0" device and a "wlan0" device; the  * latter is the one with the IP address.  Both show up in  * "tcpdump -D" output.  Capturing on the wmaster0 device  * captures with 802.11 headers.  *  * airmon-ng searches through /sys/class/net for devices named  * monN, starting with mon0; as soon as one *doesn't* exist,  * it chooses that as the monitor device name.  If the "iw"  * command exists, it does "iw dev {if} interface add {monif}  * type monitor", where {monif} is the monitor device.  It  * then (sigh) sleeps .1 second, and then configures the  * device up.  Otherwise, if /sys/class/ieee80211/{phydev}/add_iface  * is a file, it writes {mondev}, without a newline, to that file,  * and again (sigh) sleeps .1 second, and then iwconfig's that  * device into monitor mode and configures it up.  Otherwise,  * you can't do monitor mode.  *  * All these devices are "glued" together by having the  * /sys/class/net/{device}/phy80211 links pointing to the same  * place, so, given a wmaster, wlan, or mon device, you can  * find the other devices by looking for devices with  * the same phy80211 link.  *  * To turn monitor mode off, delete the monitor interface,  * either with "iw dev {monif} interface del" or by sending  * {monif}, with no NL, down /sys/class/ieee80211/{phydev}/remove_iface  *  * Note: if you try to create a monitor device named "monN", and  * there's already a "monN" device, it fails, as least with  * the netlink interface (which is what iw uses), with a return  * value of -ENFILE.  (Return values are negative errnos.)  We  * could probably use that to find an unused device.  *  * Yes, you can have multiple monitor devices for a given  * physical device.  */
end_comment

begin_comment
comment|/*  * Is this a mac80211 device?  If so, fill in the physical device path and  * return 1; if not, return 0.  On an error, fill in handle->errbuf and  * return PCAP_ERROR.  */
end_comment

begin_function
specifier|static
name|int
name|get_mac80211_phydev
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|phydev_path
parameter_list|,
name|size_t
name|phydev_max_pathlen
parameter_list|)
block|{
name|char
modifier|*
name|pathstr
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
comment|/* 	 * Generate the path string for the symlink to the physical device. 	 */
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|pathstr
argument_list|,
literal|"/sys/class/net/%s/phy80211"
argument_list|,
name|device
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: Can't generate path name string for /sys/class/net device"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|bytes_read
operator|=
name|readlink
argument_list|(
name|pathstr
argument_list|,
name|phydev_path
argument_list|,
name|phydev_max_pathlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|||
name|errno
operator|==
name|EINVAL
condition|)
block|{
comment|/* 			 * Doesn't exist, or not a symlink; assume that 			 * means it's not a mac80211 device. 			 */
name|free
argument_list|(
name|pathstr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: Can't readlink %s: %s"
argument_list|,
name|device
argument_list|,
name|pathstr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pathstr
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|free
argument_list|(
name|pathstr
argument_list|)
expr_stmt|;
name|phydev_path
index|[
name|bytes_read
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBNL_SOCKETS
end_ifdef

begin_define
define|#
directive|define
name|get_nl_errmsg
value|nl_geterror
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* libnl 2.x compatibility code */
end_comment

begin_define
define|#
directive|define
name|nl_sock
value|nl_handle
end_define

begin_function
specifier|static
specifier|inline
name|struct
name|nl_handle
modifier|*
name|nl_socket_alloc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|nl_handle_alloc
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|nl_socket_free
parameter_list|(
name|struct
name|nl_handle
modifier|*
name|h
parameter_list|)
block|{
name|nl_handle_destroy
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|get_nl_errmsg
value|strerror
end_define

begin_function
specifier|static
specifier|inline
name|int
name|__genl_ctrl_alloc_cache
parameter_list|(
name|struct
name|nl_handle
modifier|*
name|h
parameter_list|,
name|struct
name|nl_cache
modifier|*
modifier|*
name|cache
parameter_list|)
block|{
name|struct
name|nl_cache
modifier|*
name|tmp
init|=
name|genl_ctrl_alloc_cache
argument_list|(
name|h
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
operator|-
name|ENOMEM
return|;
operator|*
name|cache
operator|=
name|tmp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|genl_ctrl_alloc_cache
value|__genl_ctrl_alloc_cache
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_LIBNL_SOCKETS */
end_comment

begin_struct
struct|struct
name|nl80211_state
block|{
name|struct
name|nl_sock
modifier|*
name|nl_sock
decl_stmt|;
name|struct
name|nl_cache
modifier|*
name|nl_cache
decl_stmt|;
name|struct
name|genl_family
modifier|*
name|nl80211
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|nl80211_init
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|nl80211_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|state
operator|->
name|nl_sock
operator|=
name|nl_socket_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|nl_sock
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: failed to allocate netlink handle"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
if|if
condition|(
name|genl_connect
argument_list|(
name|state
operator|->
name|nl_sock
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: failed to connect to generic netlink"
argument_list|,
name|device
argument_list|)
expr_stmt|;
goto|goto
name|out_handle_destroy
goto|;
block|}
name|err
operator|=
name|genl_ctrl_alloc_cache
argument_list|(
name|state
operator|->
name|nl_sock
argument_list|,
operator|&
name|state
operator|->
name|nl_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: failed to allocate generic netlink cache: %s"
argument_list|,
name|device
argument_list|,
name|get_nl_errmsg
argument_list|(
operator|-
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out_handle_destroy
goto|;
block|}
name|state
operator|->
name|nl80211
operator|=
name|genl_ctrl_search_by_name
argument_list|(
name|state
operator|->
name|nl_cache
argument_list|,
literal|"nl80211"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|nl80211
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: nl80211 not found"
argument_list|,
name|device
argument_list|)
expr_stmt|;
goto|goto
name|out_cache_free
goto|;
block|}
return|return
literal|0
return|;
name|out_cache_free
label|:
name|nl_cache_free
argument_list|(
name|state
operator|->
name|nl_cache
argument_list|)
expr_stmt|;
name|out_handle_destroy
label|:
name|nl_socket_free
argument_list|(
name|state
operator|->
name|nl_sock
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nl80211_cleanup
parameter_list|(
name|struct
name|nl80211_state
modifier|*
name|state
parameter_list|)
block|{
name|genl_family_put
argument_list|(
name|state
operator|->
name|nl80211
argument_list|)
expr_stmt|;
name|nl_cache_free
argument_list|(
name|state
operator|->
name|nl_cache
argument_list|)
expr_stmt|;
name|nl_socket_free
argument_list|(
name|state
operator|->
name|nl_sock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|del_mon_if
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|sock_fd
parameter_list|,
name|struct
name|nl80211_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|mondevice
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|add_mon_if
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|sock_fd
parameter_list|,
name|struct
name|nl80211_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|mondevice
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|int
name|ifindex
decl_stmt|;
name|struct
name|nl_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ifindex
operator|=
name|iface_get_id
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifindex
operator|==
operator|-
literal|1
condition|)
return|return
name|PCAP_ERROR
return|;
name|msg
operator|=
name|nlmsg_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: failed to allocate netlink msg"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|genlmsg_put
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|genl_family_get_id
argument_list|(
name|state
operator|->
name|nl80211
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NL80211_CMD_NEW_INTERFACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NLA_PUT_U32
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_IFINDEX
argument_list|,
name|ifindex
argument_list|)
expr_stmt|;
name|NLA_PUT_STRING
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_IFNAME
argument_list|,
name|mondevice
argument_list|)
expr_stmt|;
name|NLA_PUT_U32
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_IFTYPE
argument_list|,
name|NL80211_IFTYPE_MONITOR
argument_list|)
expr_stmt|;
name|err
operator|=
name|nl_send_auto_complete
argument_list|(
name|state
operator|->
name|nl_sock
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|defined
name|HAVE_LIBNL_NLE
if|if
condition|(
name|err
operator|==
operator|-
name|NLE_FAILURE
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|err
operator|==
operator|-
name|ENFILE
condition|)
block|{
endif|#
directive|endif
comment|/* 			 * Device not available; our caller should just 			 * keep trying.  (libnl 2.x maps ENFILE to 			 * NLE_FAILURE; it can also map other errors 			 * to that, but there's not much we can do 			 * about that.) 			 */
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* 			 * Real failure, not just "that device is not 			 * available. 			 */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: nl_send_auto_complete failed adding %s interface: %s"
argument_list|,
name|device
argument_list|,
name|mondevice
argument_list|,
name|get_nl_errmsg
argument_list|(
operator|-
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
name|err
operator|=
name|nl_wait_for_ack
argument_list|(
name|state
operator|->
name|nl_sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|defined
name|HAVE_LIBNL_NLE
if|if
condition|(
name|err
operator|==
operator|-
name|NLE_FAILURE
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|err
operator|==
operator|-
name|ENFILE
condition|)
block|{
endif|#
directive|endif
comment|/* 			 * Device not available; our caller should just 			 * keep trying.  (libnl 2.x maps ENFILE to 			 * NLE_FAILURE; it can also map other errors 			 * to that, but there's not much we can do 			 * about that.) 			 */
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* 			 * Real failure, not just "that device is not 			 * available. 			 */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: nl_wait_for_ack failed adding %s interface: %s"
argument_list|,
name|device
argument_list|,
name|mondevice
argument_list|,
name|get_nl_errmsg
argument_list|(
operator|-
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
comment|/* 	 * Success. 	 */
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * Try to remember the monitor device. 	 */
name|handlep
operator|->
name|mondevice
operator|=
name|strdup
argument_list|(
name|mondevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|mondevice
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"strdup: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Get rid of the monitor device. 		 */
name|del_mon_if
argument_list|(
name|handle
argument_list|,
name|sock_fd
argument_list|,
name|state
argument_list|,
name|device
argument_list|,
name|mondevice
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
return|return
literal|1
return|;
name|nla_put_failure
label|:
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: nl_put failed adding %s interface"
argument_list|,
name|device
argument_list|,
name|mondevice
argument_list|)
expr_stmt|;
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
specifier|static
name|int
name|del_mon_if
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|sock_fd
parameter_list|,
name|struct
name|nl80211_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|mondevice
parameter_list|)
block|{
name|int
name|ifindex
decl_stmt|;
name|struct
name|nl_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ifindex
operator|=
name|iface_get_id
argument_list|(
name|sock_fd
argument_list|,
name|mondevice
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifindex
operator|==
operator|-
literal|1
condition|)
return|return
name|PCAP_ERROR
return|;
name|msg
operator|=
name|nlmsg_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: failed to allocate netlink msg"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|genlmsg_put
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|genl_family_get_id
argument_list|(
name|state
operator|->
name|nl80211
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NL80211_CMD_DEL_INTERFACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NLA_PUT_U32
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_IFINDEX
argument_list|,
name|ifindex
argument_list|)
expr_stmt|;
name|err
operator|=
name|nl_send_auto_complete
argument_list|(
name|state
operator|->
name|nl_sock
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: nl_send_auto_complete failed deleting %s interface: %s"
argument_list|,
name|device
argument_list|,
name|mondevice
argument_list|,
name|get_nl_errmsg
argument_list|(
operator|-
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|err
operator|=
name|nl_wait_for_ack
argument_list|(
name|state
operator|->
name|nl_sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: nl_wait_for_ack failed adding %s interface: %s"
argument_list|,
name|device
argument_list|,
name|mondevice
argument_list|,
name|get_nl_errmsg
argument_list|(
operator|-
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
comment|/* 	 * Success. 	 */
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|nla_put_failure
label|:
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: nl_put failed deleting %s interface"
argument_list|,
name|device
argument_list|,
name|mondevice
argument_list|)
expr_stmt|;
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
specifier|static
name|int
name|enter_rfmon_mode_mac80211
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|sock_fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|phydev_path
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|nl80211_state
name|nlstate
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|u_int
name|n
decl_stmt|;
comment|/* 	 * Is this a mac80211 device? 	 */
name|ret
operator|=
name|get_mac80211_phydev
argument_list|(
name|handle
argument_list|,
name|device
argument_list|,
name|phydev_path
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
comment|/* error */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* no error, but not mac80211 device */
comment|/* 	 * XXX - is this already a monN device? 	 * If so, we're done. 	 * Is that determined by old Wireless Extensions ioctls? 	 */
comment|/* 	 * OK, it's apparently a mac80211 device. 	 * Try to find an unused monN device for it. 	 */
name|ret
operator|=
name|nl80211_init
argument_list|(
name|handle
argument_list|,
operator|&
name|nlstate
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|UINT_MAX
condition|;
name|n
operator|++
control|)
block|{
comment|/* 		 * Try mon{n}. 		 */
name|char
name|mondevice
index|[
literal|3
operator|+
literal|10
operator|+
literal|1
index|]
decl_stmt|;
comment|/* mon{UINT_MAX}\0 */
name|pcap_snprintf
argument_list|(
name|mondevice
argument_list|,
sizeof|sizeof
name|mondevice
argument_list|,
literal|"mon%u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ret
operator|=
name|add_mon_if
argument_list|(
name|handle
argument_list|,
name|sock_fd
argument_list|,
operator|&
name|nlstate
argument_list|,
name|device
argument_list|,
name|mondevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
comment|/* 			 * Success.  We don't clean up the libnl state 			 * yet, as we'll be using it later. 			 */
goto|goto
name|added
goto|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Hard failure.  Just return ret; handle->errbuf 			 * has already been set. 			 */
name|nl80211_cleanup
argument_list|(
operator|&
name|nlstate
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: No free monN interfaces"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|nl80211_cleanup
argument_list|(
operator|&
name|nlstate
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
name|added
label|:
if|#
directive|if
literal|0
comment|/* 	 * Sleep for .1 seconds. 	 */
block|delay.tv_sec = 0; 	delay.tv_nsec = 500000000; 	nanosleep(&delay, NULL);
endif|#
directive|endif
comment|/* 	 * If we haven't already done so, arrange to have 	 * "pcap_close_all()" called when we exit. 	 */
if|if
condition|(
operator|!
name|pcap_do_addexit
argument_list|(
name|handle
argument_list|)
condition|)
block|{
comment|/* 		 * "atexit()" failed; don't put the interface 		 * in rfmon mode, just give up. 		 */
name|del_mon_if
argument_list|(
name|handle
argument_list|,
name|sock_fd
argument_list|,
operator|&
name|nlstate
argument_list|,
name|device
argument_list|,
name|handlep
operator|->
name|mondevice
argument_list|)
expr_stmt|;
name|nl80211_cleanup
argument_list|(
operator|&
name|nlstate
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
comment|/* 	 * Now configure the monitor interface up. 	 */
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|handlep
operator|->
name|mondevice
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: Can't get flags for %s: %s"
argument_list|,
name|device
argument_list|,
name|handlep
operator|->
name|mondevice
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|del_mon_if
argument_list|(
name|handle
argument_list|,
name|sock_fd
argument_list|,
operator|&
name|nlstate
argument_list|,
name|device
argument_list|,
name|handlep
operator|->
name|mondevice
argument_list|)
expr_stmt|;
name|nl80211_cleanup
argument_list|(
operator|&
name|nlstate
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|ifr
operator|.
name|ifr_flags
operator||=
name|IFF_UP
operator||
name|IFF_RUNNING
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: Can't set flags for %s: %s"
argument_list|,
name|device
argument_list|,
name|handlep
operator|->
name|mondevice
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|del_mon_if
argument_list|(
name|handle
argument_list|,
name|sock_fd
argument_list|,
operator|&
name|nlstate
argument_list|,
name|device
argument_list|,
name|handlep
operator|->
name|mondevice
argument_list|)
expr_stmt|;
name|nl80211_cleanup
argument_list|(
operator|&
name|nlstate
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
comment|/* 	 * Success.  Clean up the libnl state. 	 */
name|nl80211_cleanup
argument_list|(
operator|&
name|nlstate
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we have to delete the monitor device when we close 	 * the handle. 	 */
name|handlep
operator|->
name|must_do_on_close
operator||=
name|MUST_DELETE_MONIF
expr_stmt|;
comment|/* 	 * Add this to the list of pcaps to close when we exit. 	 */
name|pcap_add_to_pcaps_to_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_LIBNL */
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
comment|/*  * Bonding devices mishandle unknown ioctls; they fail with ENODEV  * rather than ENOTSUP, EOPNOTSUPP, or ENOTTY, so Wireless Extensions  * will fail with ENODEV if we try to do them on a bonding device,  * making us return a "no such device" indication rather than just  * saying "no Wireless Extensions".  *  * So we check for bonding devices, if we can, before trying those  * ioctls, by trying a bonding device information query ioctl to see  * whether it succeeds.  */
specifier|static
name|int
name|is_bonding_device
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BOND_INFO_QUERY_IOCTL
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|ifbond
name|ifb
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ifr
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ifb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ifb
argument_list|)
expr_stmt|;
name|ifr
operator|.
name|ifr_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ifb
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BOND_INFO_QUERY_IOCTL
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* success, so it's a bonding device */
endif|#
directive|endif
comment|/* BOND_INFO_QUERY_IOCTL */
return|return
literal|0
return|;
comment|/* no, it's not a bonding device */
block|}
endif|#
directive|endif
comment|/* IW_MODE_MONITOR */
specifier|static
name|int
name|pcap_can_set_rfmon_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LIBNL
name|char
name|phydev_path
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
name|int
name|sock_fd
decl_stmt|;
name|struct
name|iwreq
name|ireq
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|handle
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Monitor mode makes no sense on the "any" device. 		 */
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_LIBNL
comment|/* 	 * Bleah.  There doesn't seem to be a way to ask a mac80211 	 * device, through libnl, whether it supports monitor mode; 	 * we'll just check whether the device appears to be a 	 * mac80211 device and, if so, assume the device supports 	 * monitor mode. 	 * 	 * wmaster devices don't appear to support the Wireless 	 * Extensions, but we can create a mon device for a 	 * wmaster device, so we don't bother checking whether 	 * a mac80211 device supports the Wireless Extensions. 	 */
name|ret
operator|=
name|get_mac80211_phydev
argument_list|(
name|handle
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|device
argument_list|,
name|phydev_path
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
comment|/* error */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* mac80211 device */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
comment|/* 	 * Bleah.  There doesn't appear to be an ioctl to use to ask 	 * whether a device supports monitor mode; we'll just do 	 * SIOCGIWMODE and, if it succeeds, assume the device supports 	 * monitor mode. 	 * 	 * Open a socket on which to attempt to get the mode. 	 * (We assume that if we have Wireless Extensions support 	 * we also have PF_PACKET support.) 	 */
name|sock_fd
operator|=
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_RAW
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_fd
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
if|if
condition|(
name|is_bonding_device
argument_list|(
name|sock_fd
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|device
argument_list|)
condition|)
block|{
comment|/* It's a bonding device, so don't even try. */
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Attempt to get the current mode. 	 */
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCGIWMODE
argument_list|,
operator|&
name|ireq
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Well, we got the mode; assume we can set it. 		 */
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENODEV
condition|)
block|{
comment|/* The device doesn't even exist. */
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIWMODE failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR_NO_SUCH_DEVICE
return|;
block|}
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/*  * Grabs the number of dropped packets by the interface from /proc/net/dev.  *  * XXX - what about /sys/class/net/{interface name}/rx_*?  There are  * individual devices giving, in ASCII, various rx_ and tx_ statistics.  *  * Or can we get them in binary form from netlink?  */
specifier|static
name|long
name|int
name|linux_if_drops
parameter_list|(
specifier|const
name|char
modifier|*
name|if_name
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|bufptr
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|field_to_convert
init|=
literal|3
decl_stmt|,
name|if_name_sz
init|=
name|strlen
argument_list|(
name|if_name
argument_list|)
decl_stmt|;
name|long
name|int
name|dropped_pkts
init|=
literal|0
decl_stmt|;
name|file
operator|=
name|fopen
argument_list|(
literal|"/proc/net/dev"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|!
name|dropped_pkts
operator|&&
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|file
argument_list|)
condition|)
block|{
comment|/* 	search for 'bytes' -- if its in there, then 			that means we need to grab the fourth field. otherwise 			grab the third field. */
if|if
condition|(
name|field_to_convert
operator|!=
literal|4
operator|&&
name|strstr
argument_list|(
name|buffer
argument_list|,
literal|"bytes"
argument_list|)
condition|)
block|{
name|field_to_convert
operator|=
literal|4
expr_stmt|;
continue|continue;
block|}
comment|/* find iface and make sure it actually matches -- space before the name and : after it */
if|if
condition|(
operator|(
name|bufptr
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
name|if_name
argument_list|)
operator|)
operator|&&
operator|(
name|bufptr
operator|==
name|buffer
operator|||
operator|*
operator|(
name|bufptr
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|)
operator|&&
operator|*
operator|(
name|bufptr
operator|+
name|if_name_sz
operator|)
operator|==
literal|':'
condition|)
block|{
name|bufptr
operator|=
name|bufptr
operator|+
name|if_name_sz
operator|+
literal|1
expr_stmt|;
comment|/* grab the nth field from it */
while|while
condition|(
operator|--
name|field_to_convert
operator|&&
operator|*
name|bufptr
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|*
name|bufptr
operator|!=
literal|'\0'
operator|&&
operator|*
operator|(
name|bufptr
operator|++
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|bufptr
operator|!=
literal|'\0'
operator|&&
operator|*
operator|(
name|bufptr
operator|++
operator|)
operator|!=
literal|' '
condition|)
empty_stmt|;
block|}
comment|/* get rid of any final spaces */
while|while
condition|(
operator|*
name|bufptr
operator|!=
literal|'\0'
operator|&&
operator|*
name|bufptr
operator|==
literal|' '
condition|)
name|bufptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bufptr
operator|!=
literal|'\0'
condition|)
name|dropped_pkts
operator|=
name|strtol
argument_list|(
name|bufptr
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|dropped_pkts
return|;
block|}
comment|/*  * With older kernels promiscuous mode is kind of interesting because we  * have to reset the interface before exiting. The problem can't really  * be solved without some daemon taking care of managing usage counts.  * If we put the interface into promiscuous mode, we set a flag indicating  * that we must take it out of that mode when the interface is closed,  * and, when closing the interface, if that flag is set we take it out  * of promiscuous mode.  *  * Even with newer kernels, we have the same issue with rfmon mode.  */
specifier|static
name|void
name|pcap_cleanup_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBNL
name|struct
name|nl80211_state
name|nlstate
decl_stmt|;
name|int
name|ret
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_LIBNL */
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
name|int
name|oldflags
decl_stmt|;
name|struct
name|iwreq
name|ireq
decl_stmt|;
endif|#
directive|endif
comment|/* IW_MODE_MONITOR */
if|if
condition|(
name|handlep
operator|->
name|must_do_on_close
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * There's something we have to do when closing this 		 * pcap_t. 		 */
if|if
condition|(
name|handlep
operator|->
name|must_do_on_close
operator|&
name|MUST_CLEAR_PROMISC
condition|)
block|{
comment|/* 			 * We put the interface into promiscuous mode; 			 * take it out of promiscuous mode. 			 * 			 * XXX - if somebody else wants it in promiscuous 			 * mode, this code cannot know that, so it'll take 			 * it out of promiscuous mode.  That's not fixable 			 * in 2.0[.x] kernels. 			 */
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|handlep
operator|->
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface %s flags (SIOCGIFFLAGS failed: %s).\n"
literal|"Please adjust manually.\n"
literal|"Hint: This can't happen with Linux>= 2.2.0.\n"
argument_list|,
name|handlep
operator|->
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* 					 * Promiscuous mode is currently on; 					 * turn it off. 					 */
name|ifr
operator|.
name|ifr_flags
operator|&=
operator|~
name|IFF_PROMISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface %s flags (SIOCSIFFLAGS failed: %s).\n"
literal|"Please adjust manually.\n"
literal|"Hint: This can't happen with Linux>= 2.2.0.\n"
argument_list|,
name|handlep
operator|->
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_LIBNL
if|if
condition|(
name|handlep
operator|->
name|must_do_on_close
operator|&
name|MUST_DELETE_MONIF
condition|)
block|{
name|ret
operator|=
name|nl80211_init
argument_list|(
name|handle
argument_list|,
operator|&
name|nlstate
argument_list|,
name|handlep
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|ret
operator|=
name|del_mon_if
argument_list|(
name|handle
argument_list|,
name|handle
operator|->
name|fd
argument_list|,
operator|&
name|nlstate
argument_list|,
name|handlep
operator|->
name|device
argument_list|,
name|handlep
operator|->
name|mondevice
argument_list|)
expr_stmt|;
name|nl80211_cleanup
argument_list|(
operator|&
name|nlstate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't delete monitor interface %s (%s).\n"
literal|"Please delete manually.\n"
argument_list|,
name|handlep
operator|->
name|mondevice
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_LIBNL */
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
if|if
condition|(
name|handlep
operator|->
name|must_do_on_close
operator|&
name|MUST_CLEAR_RFMON
condition|)
block|{
comment|/* 			 * We put the interface into rfmon mode; 			 * take it out of rfmon mode. 			 * 			 * XXX - if somebody else wants it in rfmon 			 * mode, this code cannot know that, so it'll take 			 * it out of rfmon mode. 			 */
comment|/* 			 * First, take the interface down if it's up; 			 * otherwise, we might get EBUSY. 			 * If we get errors, just drive on and print 			 * a warning if we can't restore the mode. 			 */
name|oldflags
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|handlep
operator|->
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
condition|)
block|{
name|oldflags
operator|=
name|ifr
operator|.
name|ifr_flags
expr_stmt|;
name|ifr
operator|.
name|ifr_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|oldflags
operator|=
literal|0
expr_stmt|;
comment|/* didn't set, don't restore */
block|}
block|}
comment|/* 			 * Now restore the mode. 			 */
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|handlep
operator|->
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|ireq
operator|.
name|u
operator|.
name|mode
operator|=
name|handlep
operator|->
name|oldmode
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSIWMODE
argument_list|,
operator|&
name|ireq
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Scientist, you've failed. 				 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface %s wireless mode (SIOCSIWMODE failed: %s).\n"
literal|"Please adjust manually.\n"
argument_list|,
name|handlep
operator|->
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Now bring the interface back up if we brought 			 * it down. 			 */
if|if
condition|(
name|oldflags
operator|!=
literal|0
condition|)
block|{
name|ifr
operator|.
name|ifr_flags
operator|=
name|oldflags
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't bring interface %s back up (SIOCSIFFLAGS failed: %s).\n"
literal|"Please adjust manually.\n"
argument_list|,
name|handlep
operator|->
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* IW_MODE_MONITOR */
comment|/* 		 * Take this pcap out of the list of pcaps for which we 		 * have to take the interface out of some mode. 		 */
name|pcap_remove_from_pcaps_to_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handlep
operator|->
name|mondevice
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|handlep
operator|->
name|mondevice
argument_list|)
expr_stmt|;
name|handlep
operator|->
name|mondevice
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|handlep
operator|->
name|device
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|handlep
operator|->
name|device
argument_list|)
expr_stmt|;
name|handlep
operator|->
name|device
operator|=
name|NULL
expr_stmt|;
block|}
name|pcap_cleanup_live_common
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
comment|/*  * Set the timeout to be used in poll() with memory-mapped packet capture.  */
specifier|static
name|void
name|set_poll_timeout
parameter_list|(
name|struct
name|pcap_linux
modifier|*
name|handlep
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
name|struct
name|utsname
name|utsname
decl_stmt|;
name|char
modifier|*
name|version_component
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|int
name|broken_tpacket_v3
init|=
literal|1
decl_stmt|;
comment|/* 	 * Some versions of TPACKET_V3 have annoying bugs/misfeatures 	 * around which we have to work.  Determine if we have those 	 * problems or not. 	 */
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * 3.19 is the first release with a fixed version of 		 * TPACKET_V3.  We treat anything before that as 		 * not haveing a fixed version; that may really mean 		 * it has *no* version. 		 */
name|version_component
operator|=
name|utsname
operator|.
name|release
expr_stmt|;
name|major
operator|=
name|strtol
argument_list|(
name|version_component
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|version_component
operator|&&
operator|*
name|endp
operator|==
literal|'.'
condition|)
block|{
comment|/* 			 * OK, that was a valid major version. 			 * Get the minor version. 			 */
name|version_component
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
name|minor
operator|=
name|strtol
argument_list|(
name|version_component
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|version_component
operator|&&
operator|(
operator|*
name|endp
operator|==
literal|'.'
operator|||
operator|*
name|endp
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* 				 * OK, that was a valid minor version. 				 * Is this 3.19 or newer? 				 */
if|if
condition|(
name|major
operator|>=
literal|4
operator|||
operator|(
name|major
operator|==
literal|3
operator|&&
name|minor
operator|>=
literal|19
operator|)
condition|)
block|{
comment|/* Yes. TPACKET_V3 works correctly. */
name|broken_tpacket_v3
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|handlep
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
comment|/* 		 * XXX - due to a set of (mis)features in the TPACKET_V3 		 * kernel code prior to the 3.19 kernel, blocking forever 		 * with a TPACKET_V3 socket can, if few packets are 		 * arriving and passing the socket filter, cause most 		 * packets to be dropped.  See libpcap issue #335 for the 		 * full painful story. 		 * 		 * The workaround is to have poll() time out very quickly, 		 * so we grab the frames handed to us, and return them to 		 * the kernel, ASAP. 		 */
if|if
condition|(
name|handlep
operator|->
name|tp_version
operator|==
name|TPACKET_V3
operator|&&
name|broken_tpacket_v3
condition|)
name|handlep
operator|->
name|poll_timeout
operator|=
literal|1
expr_stmt|;
comment|/* don't block for very long */
else|else
endif|#
directive|endif
name|handlep
operator|->
name|poll_timeout
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* block forever */
block|}
elseif|else
if|if
condition|(
name|handlep
operator|->
name|timeout
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
comment|/* 		 * For TPACKET_V3, the timeout is handled by the kernel, 		 * so block forever; that way, we don't get extra timeouts. 		 * Don't do that if we have a broken TPACKET_V3, though. 		 */
if|if
condition|(
name|handlep
operator|->
name|tp_version
operator|==
name|TPACKET_V3
operator|&&
operator|!
name|broken_tpacket_v3
condition|)
name|handlep
operator|->
name|poll_timeout
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* block forever, let TPACKET_V3 wake us up */
else|else
endif|#
directive|endif
name|handlep
operator|->
name|poll_timeout
operator|=
name|handlep
operator|->
name|timeout
expr_stmt|;
comment|/* block for that amount of time */
block|}
else|else
block|{
comment|/* 		 * Non-blocking mode; we call poll() to pick up error 		 * indications, but we don't want it to wait for 		 * anything. 		 */
name|handlep
operator|->
name|poll_timeout
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*  *  Get a handle for a live capture from the given device. You can  *  pass NULL as device to get all packages (without link level  *  information of course). If you pass 1 as promisc the interface  *  will be set to promiscous mode (XXX: I think this usage should  *  be deprecated and functions be added to select that later allow  *  modification of that values -- Torsten).  */
specifier|static
name|int
name|pcap_activate_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|device
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|device
operator|=
name|handle
operator|->
name|opt
operator|.
name|device
expr_stmt|;
comment|/* 	 * Make sure the name we were handed will fit into the ioctls we 	 * might perform on the device; if not, return a "No such device" 	 * indication, as the Linux kernel shouldn't support creating 	 * a device whose name won't fit into those ioctls. 	 * 	 * "Will fit" means "will fit, complete with a null terminator", 	 * so if the length, which does *not* include the null terminator, 	 * is greater than *or equal to* the size of the field into which 	 * we'll be copying it, that won't fit. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|device
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR_NO_SUCH_DEVICE
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|handle
operator|->
name|inject_op
operator|=
name|pcap_inject_linux
expr_stmt|;
name|handle
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_linux
expr_stmt|;
name|handle
operator|->
name|setdirection_op
operator|=
name|pcap_setdirection_linux
expr_stmt|;
name|handle
operator|->
name|set_datalink_op
operator|=
name|pcap_set_datalink_linux
expr_stmt|;
name|handle
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|handle
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_fd
expr_stmt|;
name|handle
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_linux
expr_stmt|;
name|handle
operator|->
name|read_op
operator|=
name|pcap_read_linux
expr_stmt|;
name|handle
operator|->
name|stats_op
operator|=
name|pcap_stats_linux
expr_stmt|;
comment|/* 	 * The "any" device is a special device which causes us not 	 * to bind to a particular device and thus to look at all 	 * devices. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|device
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
name|handle
operator|->
name|opt
operator|.
name|promisc
operator|=
literal|0
expr_stmt|;
comment|/* Just a warning. */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Promiscuous mode not supported on the \"any\" device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_WARNING_PROMISC_NOTSUP
expr_stmt|;
block|}
block|}
name|handlep
operator|->
name|device
operator|=
name|strdup
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|device
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"strdup: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
comment|/* copy timeout value */
name|handlep
operator|->
name|timeout
operator|=
name|handle
operator|->
name|opt
operator|.
name|timeout
expr_stmt|;
comment|/* 	 * If we're in promiscuous mode, then we probably want 	 * to see when the interface drops packets too, so get an 	 * initial count from /proc/net/dev 	 */
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|promisc
condition|)
name|handlep
operator|->
name|proc_dropped
operator|=
name|linux_if_drops
argument_list|(
name|handlep
operator|->
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * Current Linux kernels use the protocol family PF_PACKET to 	 * allow direct access to all packets on the network while 	 * older kernels had a special socket type SOCK_PACKET to 	 * implement this feature. 	 * While this old implementation is kind of obsolete we need 	 * to be compatible with older kernels for a while so we are 	 * trying both methods with the newer method preferred. 	 */
name|ret
operator|=
name|activate_new
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Fatal error with the new way; just fail. 		 * ret has the error return; if it's PCAP_ERROR, 		 * handle->errbuf has been set appropriately. 		 */
name|status
operator|=
name|ret
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Success. 		 * Try to use memory-mapped access. 		 */
switch|switch
condition|(
name|activate_mmap
argument_list|(
name|handle
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* 			 * We succeeded.  status has been 			 * set to the status to return, 			 * which might be 0, or might be 			 * a PCAP_WARNING_ value. 			 * 			 * Set the timeout to use in poll() before 			 * returning. 			 */
name|set_poll_timeout
argument_list|(
name|handlep
argument_list|)
expr_stmt|;
return|return
name|status
return|;
case|case
literal|0
case|:
comment|/* 			 * Kernel doesn't support it - just continue 			 * with non-memory-mapped access. 			 */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* 			 * We failed to set up to use it, or the kernel 			 * supports it, but we failed to enable it. 			 * ret has been set to the error status to 			 * return and, if it's PCAP_ERROR, handle->errbuf 			 * contains the error message. 			 */
name|status
operator|=
name|ret
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* Non-fatal error; try old way */
if|if
condition|(
operator|(
name|ret
operator|=
name|activate_old
argument_list|(
name|handle
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
comment|/* 			 * Both methods to open the packet socket failed. 			 * Tidy up and report our failure (handle->errbuf 			 * is expected to be set by the functions above). 			 */
name|status
operator|=
name|ret
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* 	 * We set up the socket, but not with memory-mapped access. 	 */
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|buffer_size
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Set the socket buffer size to the specified value. 		 */
if|if
condition|(
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|handle
operator|->
name|opt
operator|.
name|buffer_size
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
operator|->
name|opt
operator|.
name|buffer_size
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SO_RCVBUF: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Allocate the buffer */
name|handle
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|handle
operator|->
name|bufsize
operator|+
name|handle
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
operator|->
name|buffer
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * "handle->fd" is a socket, so "select()" and "poll()" 	 * should work on it. 	 */
name|handle
operator|->
name|selectable_fd
operator|=
name|handle
operator|->
name|fd
expr_stmt|;
return|return
name|status
return|;
name|fail
label|:
name|pcap_cleanup_linux
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/*  *  Read at most max_packets from the capture stream and call the callback  *  for each of them. Returns the number of packets handled or -1 if an  *  error occured.  */
specifier|static
name|int
name|pcap_read_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
comment|/* 	 * Currently, on Linux only one packet is delivered per read, 	 * so we don't loop. 	 */
return|return
name|pcap_read_packet
argument_list|(
name|handle
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
return|;
block|}
specifier|static
name|int
name|pcap_set_datalink_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|dlt
parameter_list|)
block|{
name|handle
operator|->
name|linktype
operator|=
name|dlt
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * linux_check_direction()  *  * Do checks based on packet direction.  */
specifier|static
specifier|inline
name|int
name|linux_check_direction
parameter_list|(
specifier|const
name|pcap_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|struct
name|sockaddr_ll
modifier|*
name|sll
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|sll
operator|->
name|sll_pkttype
operator|==
name|PACKET_OUTGOING
condition|)
block|{
comment|/* 		 * Outgoing packet. 		 * If this is from the loopback device, reject it; 		 * we'll see the packet as an incoming packet as well, 		 * and we don't want to see it twice. 		 */
if|if
condition|(
name|sll
operator|->
name|sll_ifindex
operator|==
name|handlep
operator|->
name|lo_ifindex
condition|)
return|return
literal|0
return|;
comment|/* 		 * If this is an outgoing CAN or CAN FD frame, and 		 * the user doesn't only want outgoing packets, 		 * reject it; CAN devices and drivers, and the CAN 		 * stack, always arrange to loop back transmitted 		 * packets, so they also appear as incoming packets. 		 * We don't want duplicate packets, and we can't 		 * easily distinguish packets looped back by the CAN 		 * layer than those received by the CAN layer, so we 		 * eliminate this packet instead. 		 */
if|if
condition|(
operator|(
name|sll
operator|->
name|sll_protocol
operator|==
name|LINUX_SLL_P_CAN
operator|||
name|sll
operator|->
name|sll_protocol
operator|==
name|LINUX_SLL_P_CANFD
operator|)
operator|&&
name|handle
operator|->
name|direction
operator|!=
name|PCAP_D_OUT
condition|)
return|return
literal|0
return|;
comment|/* 		 * If the user only wants incoming packets, reject it. 		 */
if|if
condition|(
name|handle
operator|->
name|direction
operator|==
name|PCAP_D_IN
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* 		 * Incoming packet. 		 * If the user only wants outgoing packets, reject it. 		 */
if|if
condition|(
name|handle
operator|->
name|direction
operator|==
name|PCAP_D_OUT
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/*  *  Read a packet from the socket calling the handler provided by  *  the user. Returns the number of packets received or -1 if an  *  error occured.  */
specifier|static
name|int
name|pcap_read_packet
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|userdata
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|u_char
modifier|*
name|bp
decl_stmt|;
name|int
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
name|struct
name|sockaddr_ll
name|from
decl_stmt|;
name|struct
name|sll_header
modifier|*
name|hdrp
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr
name|from
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PACKET_AUXDATA
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI
argument_list|)
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmsg
decl_stmt|;
union|union
block|{
name|struct
name|cmsghdr
name|cmsg
decl_stmt|;
name|char
name|buf
index|[
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tpacket_auxdata
argument_list|)
argument_list|)
index|]
decl_stmt|;
block|}
name|cmsg_buf
union|;
else|#
directive|else
comment|/* defined(HAVE_PACKET_AUXDATA)&& defined(HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI) */
name|socklen_t
name|fromlen
decl_stmt|;
endif|#
directive|endif
comment|/* defined(HAVE_PACKET_AUXDATA)&& defined(HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI) */
name|int
name|packet_len
decl_stmt|,
name|caplen
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
name|struct
name|bpf_aux_data
name|aux_data
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/* 	 * If this is a cooked device, leave extra room for a 	 * fake packet header. 	 */
if|if
condition|(
name|handlep
operator|->
name|cooked
condition|)
name|offset
operator|=
name|SLL_HDR_LEN
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* 	 * This system doesn't have PF_PACKET sockets, so it doesn't 	 * support cooked devices. 	 */
name|offset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Receive a single packet from the kernel. 	 * We ignore EINTR, as that might just be due to a signal 	 * being delivered - if the signal should interrupt the 	 * loop, the signal handler should call pcap_breakloop() 	 * to set handle->break_loop (we ignore it on other 	 * platforms as well). 	 * We also ignore ENETDOWN, so that we can continue to 	 * capture traffic if the interface goes down and comes 	 * back up again; comments in the kernel indicate that 	 * we'll just block waiting for packets if we try to 	 * receive from a socket that delivered ENETDOWN, and, 	 * if we're using a memory-mapped buffer, we won't even 	 * get notified of "network down" events. 	 */
name|bp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|handle
operator|->
name|buffer
operator|+
name|handle
operator|->
name|offset
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PACKET_AUXDATA
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI
argument_list|)
name|msg
operator|.
name|msg_name
operator|=
operator|&
name|from
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
operator|&
name|cmsg_buf
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|cmsg_buf
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|handle
operator|->
name|bufsize
operator|-
name|offset
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|bp
operator|+
name|offset
expr_stmt|;
endif|#
directive|endif
comment|/* defined(HAVE_PACKET_AUXDATA)&& defined(HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI) */
do|do
block|{
comment|/* 		 * Has "pcap_breakloop()" been called? 		 */
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
comment|/* 			 * Yes - clear the flag that indicates that it has, 			 * and return PCAP_ERROR_BREAK as an indication that 			 * we were told to break out of the loop. 			 */
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
name|PCAP_ERROR_BREAK
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PACKET_AUXDATA
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI
argument_list|)
name|packet_len
operator|=
name|recvmsg
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
operator|&
name|msg
argument_list|,
name|MSG_TRUNC
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* defined(HAVE_PACKET_AUXDATA)&& defined(HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI) */
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|packet_len
operator|=
name|recvfrom
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|bp
operator|+
name|offset
argument_list|,
name|handle
operator|->
name|bufsize
operator|-
name|offset
argument_list|,
name|MSG_TRUNC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(HAVE_PACKET_AUXDATA)&& defined(HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI) */
block|}
do|while
condition|(
name|packet_len
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
comment|/* Check if an error occured */
if|if
condition|(
name|packet_len
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EAGAIN
case|:
return|return
literal|0
return|;
comment|/* no packet there */
case|case
name|ENETDOWN
case|:
comment|/* 			 * The device on which we're capturing went away. 			 * 			 * XXX - we should really return 			 * PCAP_ERROR_IFACE_NOT_UP, but pcap_dispatch() 			 * etc. aren't defined to return that. 			 */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The interface went down"
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
default|default:
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recvfrom: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
if|if
condition|(
operator|!
name|handlep
operator|->
name|sock_packet
condition|)
block|{
comment|/* 		 * Unfortunately, there is a window between socket() and 		 * bind() where the kernel may queue packets from any 		 * interface.  If we're bound to a particular interface, 		 * discard packets not from that interface. 		 * 		 * (If socket filters are supported, we could do the 		 * same thing we do when changing the filter; however, 		 * that won't handle packet sockets without socket 		 * filter support, and it's a bit more complicated. 		 * It would save some instructions per packet, however.) 		 */
if|if
condition|(
name|handlep
operator|->
name|ifindex
operator|!=
operator|-
literal|1
operator|&&
name|from
operator|.
name|sll_ifindex
operator|!=
name|handlep
operator|->
name|ifindex
condition|)
return|return
literal|0
return|;
comment|/* 		 * Do checks based on packet direction. 		 * We can only do this if we're using PF_PACKET; the 		 * address returned for SOCK_PACKET is a "sockaddr_pkt" 		 * which lacks the relevant packet type information. 		 */
if|if
condition|(
operator|!
name|linux_check_direction
argument_list|(
name|handle
argument_list|,
operator|&
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/* 	 * If this is a cooked device, fill in the fake packet header. 	 */
if|if
condition|(
name|handlep
operator|->
name|cooked
condition|)
block|{
comment|/* 		 * Add the length of the fake header to the length 		 * of packet data we read. 		 */
name|packet_len
operator|+=
name|SLL_HDR_LEN
expr_stmt|;
name|hdrp
operator|=
operator|(
expr|struct
name|sll_header
operator|*
operator|)
name|bp
expr_stmt|;
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|map_packet_type_to_sll_type
argument_list|(
name|from
operator|.
name|sll_pkttype
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_hatype
operator|=
name|htons
argument_list|(
name|from
operator|.
name|sll_hatype
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_halen
operator|=
name|htons
argument_list|(
name|from
operator|.
name|sll_halen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hdrp
operator|->
name|sll_addr
argument_list|,
name|from
operator|.
name|sll_addr
argument_list|,
operator|(
name|from
operator|.
name|sll_halen
operator|>
name|SLL_ADDRLEN
operator|)
condition|?
name|SLL_ADDRLEN
else|:
name|from
operator|.
name|sll_halen
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_protocol
operator|=
name|from
operator|.
name|sll_protocol
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PACKET_AUXDATA
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI
argument_list|)
if|if
condition|(
name|handlep
operator|->
name|vlan_offset
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|cmsg
operator|=
name|CMSG_FIRSTHDR
argument_list|(
operator|&
name|msg
argument_list|)
init|;
name|cmsg
condition|;
name|cmsg
operator|=
name|CMSG_NXTHDR
argument_list|(
operator|&
name|msg
argument_list|,
name|cmsg
argument_list|)
control|)
block|{
name|struct
name|tpacket_auxdata
modifier|*
name|aux
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|struct
name|vlan_tag
modifier|*
name|tag
decl_stmt|;
if|if
condition|(
name|cmsg
operator|->
name|cmsg_len
operator|<
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tpacket_auxdata
argument_list|)
argument_list|)
operator|||
name|cmsg
operator|->
name|cmsg_level
operator|!=
name|SOL_PACKET
operator|||
name|cmsg
operator|->
name|cmsg_type
operator|!=
name|PACKET_AUXDATA
condition|)
continue|continue;
name|aux
operator|=
operator|(
expr|struct
name|tpacket_auxdata
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TP_STATUS_VLAN_VALID
argument_list|)
if|if
condition|(
operator|(
name|aux
operator|->
name|tp_vlan_tci
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|aux
operator|->
name|tp_status
operator|&
name|TP_STATUS_VLAN_VALID
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|aux
operator|->
name|tp_vlan_tci
operator|==
literal|0
condition|)
comment|/* this is ambigious but without the 						TP_STATUS_VLAN_VALID flag, there is 						nothing that we can do */
endif|#
directive|endif
continue|continue;
name|len
operator|=
operator|(
name|u_int
operator|)
name|packet_len
operator|>
name|iov
operator|.
name|iov_len
condition|?
name|iov
operator|.
name|iov_len
else|:
operator|(
name|u_int
operator|)
name|packet_len
expr_stmt|;
if|if
condition|(
name|len
operator|<
operator|(
name|u_int
operator|)
name|handlep
operator|->
name|vlan_offset
condition|)
break|break;
comment|/* 			 * Move everything in the header, except the 			 * type field, down VLAN_TAG_LEN bytes, to 			 * allow us to insert the VLAN tag between 			 * that stuff and the type field. 			 */
name|bp
operator|-=
name|VLAN_TAG_LEN
expr_stmt|;
name|memmove
argument_list|(
name|bp
argument_list|,
name|bp
operator|+
name|VLAN_TAG_LEN
argument_list|,
name|handlep
operator|->
name|vlan_offset
argument_list|)
expr_stmt|;
comment|/* 			 * Now insert the tag. 			 */
name|tag
operator|=
operator|(
expr|struct
name|vlan_tag
operator|*
operator|)
operator|(
name|bp
operator|+
name|handlep
operator|->
name|vlan_offset
operator|)
expr_stmt|;
name|tag
operator|->
name|vlan_tpid
operator|=
name|htons
argument_list|(
name|VLAN_TPID
argument_list|(
name|aux
argument_list|,
name|aux
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|->
name|vlan_tci
operator|=
name|htons
argument_list|(
name|aux
operator|->
name|tp_vlan_tci
argument_list|)
expr_stmt|;
comment|/* store vlan tci to bpf_aux_data struct for userland bpf filter */
if|#
directive|if
name|defined
argument_list|(
name|TP_STATUS_VLAN_VALID
argument_list|)
name|aux_data
operator|.
name|vlan_tag
operator|=
name|htons
argument_list|(
name|aux
operator|->
name|tp_vlan_tci
argument_list|)
operator|&
literal|0x0fff
expr_stmt|;
name|aux_data
operator|.
name|vlan_tag_present
operator|=
operator|(
name|aux
operator|->
name|tp_status
operator|&
name|TP_STATUS_VLAN_VALID
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Add the tag to the packet lengths. 			 */
name|packet_len
operator|+=
name|VLAN_TAG_LEN
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* defined(HAVE_PACKET_AUXDATA)&& defined(HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI) */
endif|#
directive|endif
comment|/* HAVE_PF_PACKET_SOCKETS */
comment|/* 	 * XXX: According to the kernel source we should get the real 	 * packet len if calling recvfrom with MSG_TRUNC set. It does 	 * not seem to work here :(, but it is supported by this code 	 * anyway. 	 * To be honest the code RELIES on that feature so this is really 	 * broken with 2.2.x kernels. 	 * I spend a day to figure out what's going on and I found out 	 * that the following is happening: 	 * 	 * The packet comes from a random interface and the packet_rcv 	 * hook is called with a clone of the packet. That code inserts 	 * the packet into the receive queue of the packet socket. 	 * If a filter is attached to that socket that filter is run 	 * first - and there lies the problem. The default filter always 	 * cuts the packet at the snaplen: 	 * 	 * # tcpdump -d 	 * (000) ret      #68 	 * 	 * So the packet filter cuts down the packet. The recvfrom call 	 * says "hey, it's only 68 bytes, it fits into the buffer" with 	 * the result that we don't get the real packet length. This 	 * is valid at least until kernel 2.2.17pre6. 	 * 	 * We currently handle this by making a copy of the filter 	 * program, fixing all "ret" instructions with non-zero 	 * operands to have an operand of MAXIMUM_SNAPLEN so that the 	 * filter doesn't truncate the packet, and supplying that modified 	 * filter to the kernel. 	 */
name|caplen
operator|=
name|packet_len
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|handle
operator|->
name|snapshot
condition|)
name|caplen
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
comment|/* Run the packet filter if not using kernel filter */
if|if
condition|(
name|handlep
operator|->
name|filter_in_userland
operator|&&
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
condition|)
block|{
if|if
condition|(
name|bpf_filter_with_aux_data
argument_list|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|bp
argument_list|,
name|packet_len
argument_list|,
name|caplen
argument_list|,
operator|&
name|aux_data
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* rejected by filter */
return|return
literal|0
return|;
block|}
block|}
comment|/* Fill in our own header data */
comment|/* get timestamp for this packet */
if|#
directive|if
name|defined
argument_list|(
name|SIOCGSTAMPNS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SO_TIMESTAMPNS
argument_list|)
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|tstamp_precision
operator|==
name|PCAP_TSTAMP_PRECISION_NANO
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGSTAMPNS
argument_list|,
operator|&
name|pcap_header
operator|.
name|ts
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGSTAMPNS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGSTAMP
argument_list|,
operator|&
name|pcap_header
operator|.
name|ts
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGSTAMP: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
name|pcap_header
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pcap_header
operator|.
name|len
operator|=
name|packet_len
expr_stmt|;
comment|/* 	 * Count the packet. 	 * 	 * Arguably, we should count them before we check the filter, 	 * as on many other platforms "ps_recv" counts packets 	 * handed to the filter rather than packets that passed 	 * the filter, but if filtering is done in the kernel, we 	 * can't get a count of packets that passed the filter, 	 * and that would mean the meaning of "ps_recv" wouldn't 	 * be the same on all Linux systems. 	 * 	 * XXX - it's not the same on all systems in any case; 	 * ideally, we should have a "get the statistics" call 	 * that supplies more counts and indicates which of them 	 * it supplies, so that we supply a count of packets 	 * handed to the filter only on platforms where that 	 * information is available. 	 * 	 * We count them here even if we can get the packet count 	 * from the kernel, as we can only determine at run time 	 * whether we'll be able to get it from the kernel (if 	 * HAVE_TPACKET_STATS isn't defined, we can't get it from 	 * the kernel, but if it is defined, the library might 	 * have been built with a 2.4 or later kernel, but we 	 * might be running on a 2.2[.x] kernel without Alexey 	 * Kuznetzov's turbopacket patches, and thus the kernel 	 * might not be able to supply those statistics).  We 	 * could, I guess, try, when opening the socket, to get 	 * the statistics, and if we can not increment the count 	 * here, but it's not clear that always incrementing 	 * the count is more expensive than always testing a flag 	 * in memory. 	 * 	 * We keep the count in "handlep->packets_read", and use that 	 * for "ps_recv" if we can't get the statistics from the kernel. 	 * We do that because, if we *can* get the statistics from 	 * the kernel, we use "handlep->stat.ps_recv" and 	 * "handlep->stat.ps_drop" as running counts, as reading the 	 * statistics from the kernel resets the kernel statistics, 	 * and if we directly increment "handlep->stat.ps_recv" here, 	 * that means it will count packets *twice* on systems where 	 * we can get kernel statistics - once here, and once in 	 * pcap_stats_linux(). 	 */
name|handlep
operator|->
name|packets_read
operator|++
expr_stmt|;
comment|/* Call the user supplied callback function */
name|callback
argument_list|(
name|userdata
argument_list|,
operator|&
name|pcap_header
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|static
name|int
name|pcap_inject_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
if|if
condition|(
operator|!
name|handlep
operator|->
name|sock_packet
condition|)
block|{
comment|/* PF_PACKET socket */
if|if
condition|(
name|handlep
operator|->
name|ifindex
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * We don't support sending on the "any" device. 			 */
name|strlcpy
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
literal|"Sending packets isn't supported on the \"any\" device"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|handlep
operator|->
name|cooked
condition|)
block|{
comment|/* 			 * We don't support sending on the "any" device. 			 * 			 * XXX - how do you send on a bound cooked-mode 			 * socket? 			 * Is a "sendto()" required there? 			 */
name|strlcpy
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
literal|"Sending packets isn't supported in cooked mode"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|ret
operator|=
name|send
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/*  *  Get the statistics for the given packet capture handle.  *  Reports the number of dropped packets iff the kernel supports  *  the PACKET_STATISTICS "getsockopt()" argument (2.4 and later  *  kernels, and 2.2[.x] kernels with Alexey Kuznetzov's turbopacket  *  patches); otherwise, that information isn't available, and we lie  *  and report 0 as the count of dropped packets.  */
specifier|static
name|int
name|pcap_stats_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TPACKET_STATS
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
comment|/* 	 * For sockets using TPACKET_V1 or TPACKET_V2, the extra 	 * stuff at the end of a struct tpacket_stats_v3 will not 	 * be filled in, and we don't look at it so this is OK even 	 * for those sockets.  In addition, the PF_PACKET socket 	 * code in the kernel only uses the length parameter to 	 * compute how much data to copy out and to indicate how 	 * much data was copied out, so it's OK to base it on the 	 * size of a struct tpacket_stats. 	 * 	 * XXX - it's probably OK, in fact, to just use a 	 * struct tpacket_stats for V3 sockets, as we don't 	 * care about the tp_freeze_q_cnt stat. 	 */
name|struct
name|tpacket_stats_v3
name|kstats
decl_stmt|;
else|#
directive|else
comment|/* HAVE_TPACKET3 */
name|struct
name|tpacket_stats
name|kstats
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TPACKET3 */
name|socklen_t
name|len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|tpacket_stats
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TPACKET_STATS */
name|long
name|if_dropped
init|=
literal|0
decl_stmt|;
comment|/* 	 *	To fill in ps_ifdrop, we parse /proc/net/dev for the number 	 */
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
name|if_dropped
operator|=
name|handlep
operator|->
name|proc_dropped
expr_stmt|;
name|handlep
operator|->
name|proc_dropped
operator|=
name|linux_if_drops
argument_list|(
name|handlep
operator|->
name|device
argument_list|)
expr_stmt|;
name|handlep
operator|->
name|stat
operator|.
name|ps_ifdrop
operator|+=
operator|(
name|handlep
operator|->
name|proc_dropped
operator|-
name|if_dropped
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_TPACKET_STATS
comment|/* 	 * Try to get the packet counts from the kernel. 	 */
if|if
condition|(
name|getsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_STATISTICS
argument_list|,
operator|&
name|kstats
argument_list|,
operator|&
name|len
argument_list|)
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* 		 * On systems where the PACKET_STATISTICS "getsockopt()" 		 * argument is supported on PF_PACKET sockets: 		 * 		 *	"ps_recv" counts only packets that *passed* the 		 *	filter, not packets that didn't pass the filter. 		 *	This includes packets later dropped because we 		 *	ran out of buffer space. 		 * 		 *	"ps_drop" counts packets dropped because we ran 		 *	out of buffer space.  It doesn't count packets 		 *	dropped by the interface driver.  It counts only 		 *	packets that passed the filter. 		 * 		 *	See above for ps_ifdrop. 		 * 		 *	Both statistics include packets not yet read from 		 *	the kernel by libpcap, and thus not yet seen by 		 *	the application. 		 * 		 * In "linux/net/packet/af_packet.c", at least in the 		 * 2.4.9 kernel, "tp_packets" is incremented for every 		 * packet that passes the packet filter *and* is 		 * successfully queued on the socket; "tp_drops" is 		 * incremented for every packet dropped because there's 		 * not enough free space in the socket buffer. 		 * 		 * When the statistics are returned for a PACKET_STATISTICS 		 * "getsockopt()" call, "tp_drops" is added to "tp_packets", 		 * so that "tp_packets" counts all packets handed to 		 * the PF_PACKET socket, including packets dropped because 		 * there wasn't room on the socket buffer - but not 		 * including packets that didn't pass the filter. 		 * 		 * In the BSD BPF, the count of received packets is 		 * incremented for every packet handed to BPF, regardless 		 * of whether it passed the filter. 		 * 		 * We can't make "pcap_stats()" work the same on both 		 * platforms, but the best approximation is to return 		 * "tp_packets" as the count of packets and "tp_drops" 		 * as the count of drops. 		 * 		 * Keep a running total because each call to 		 *    getsockopt(handle->fd, SOL_PACKET, PACKET_STATISTICS, .... 		 * resets the counters to zero. 		 */
name|handlep
operator|->
name|stat
operator|.
name|ps_recv
operator|+=
name|kstats
operator|.
name|tp_packets
expr_stmt|;
name|handlep
operator|->
name|stat
operator|.
name|ps_drop
operator|+=
name|kstats
operator|.
name|tp_drops
expr_stmt|;
operator|*
name|stats
operator|=
name|handlep
operator|->
name|stat
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* 		 * If the error was EOPNOTSUPP, fall through, so that 		 * if you build the library on a system with 		 * "struct tpacket_stats" and run it on a system 		 * that doesn't, it works as it does if the library 		 * is built on a system without "struct tpacket_stats". 		 */
if|if
condition|(
name|errno
operator|!=
name|EOPNOTSUPP
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"pcap_stats: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * On systems where the PACKET_STATISTICS "getsockopt()" argument 	 * is not supported on PF_PACKET sockets: 	 * 	 *	"ps_recv" counts only packets that *passed* the filter, 	 *	not packets that didn't pass the filter.  It does not 	 *	count packets dropped because we ran out of buffer 	 *	space. 	 * 	 *	"ps_drop" is not supported. 	 * 	 *	"ps_ifdrop" is supported. It will return the number 	 *	of drops the interface reports in /proc/net/dev, 	 *	if that is available. 	 * 	 *	"ps_recv" doesn't include packets not yet read from 	 *	the kernel by libpcap. 	 * 	 * We maintain the count of packets processed by libpcap in 	 * "handlep->packets_read", for reasons described in the comment 	 * at the end of pcap_read_packet().  We have no idea how many 	 * packets were dropped by the kernel buffers -- but we know 	 * how many the interface dropped, so we can return that. 	 */
name|stats
operator|->
name|ps_recv
operator|=
name|handlep
operator|->
name|packets_read
expr_stmt|;
name|stats
operator|->
name|ps_drop
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|ps_ifdrop
operator|=
name|handlep
operator|->
name|stat
operator|.
name|ps_ifdrop
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|add_linux_if
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|devlistp
parameter_list|,
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|name
index|[
literal|512
index|]
decl_stmt|;
comment|/* XXX - pick a size */
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|saveq
decl_stmt|;
name|struct
name|ifreq
name|ifrflags
decl_stmt|;
comment|/* 	 * Get the interface name. 	 */
name|p
operator|=
name|ifname
expr_stmt|;
name|q
operator|=
operator|&
name|name
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
comment|/* 			 * This could be the separator between a 			 * name and an alias number, or it could be 			 * the separator between a name with no 			 * alias number and the next field. 			 * 			 * If there's a colon after digits, it 			 * separates the name and the alias number, 			 * otherwise it separates the name and the 			 * next field. 			 */
name|saveq
operator|=
name|q
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
comment|/* 				 * That was the next field, 				 * not the alias number. 				 */
name|q
operator|=
name|saveq
expr_stmt|;
block|}
break|break;
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Get the flags for this interface. 	 */
name|strlcpy
argument_list|(
name|ifrflags
operator|.
name|ifr_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifrflags
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifrflags
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENXIO
operator|||
name|errno
operator|==
name|ENODEV
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* device doesn't actually exist - ignore it */
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIFFLAGS: %.*s: %s"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ifrflags
operator|.
name|ifr_name
argument_list|)
argument_list|,
name|ifrflags
operator|.
name|ifr_name
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Add an entry for this interface, with no addresses. 	 */
if|if
condition|(
name|pcap_add_if
argument_list|(
name|devlistp
argument_list|,
name|name
argument_list|,
name|if_flags_to_pcap_flags
argument_list|(
name|name
argument_list|,
name|ifrflags
operator|.
name|ifr_flags
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Failure. 		 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Get from "/sys/class/net" all interfaces listed there; if they're  * already in the list of interfaces we have, that won't add another  * instance, but if they're not, that'll add them.  *  * We don't bother getting any addresses for them; it appears you can't  * use SIOCGIFADDR on Linux to get IPv6 addresses for interfaces, and,  * although some other types of addresses can be fetched with SIOCGIFADDR,  * we don't bother with them for now.  *  * We also don't fail if we couldn't open "/sys/class/net"; we just leave  * the list of interfaces as is, and return 0, so that we can try  * scanning /proc/net/dev.  *  * Otherwise, we return 1 if we don't get an error and -1 if we do.  */
specifier|static
name|int
name|scan_sys_class_net
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|devlistp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|DIR
modifier|*
name|sys_class_net_d
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|dirent
modifier|*
name|ent
decl_stmt|;
name|char
name|subsystem_path
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|sys_class_net_d
operator|=
name|opendir
argument_list|(
literal|"/sys/class/net"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_class_net_d
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Don't fail if it doesn't exist at all. 		 */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Fail if we got some other error. 		 */
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't open /sys/class/net: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Create a socket from which to fetch interface information. 	 */
name|fd
operator|=
name|socket
argument_list|(
name|PF_UNIX
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|sys_class_net_d
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ent
operator|=
name|readdir
argument_list|(
name|sys_class_net_d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Error or EOF; if errno != 0, it's an error. 			 */
break|break;
block|}
comment|/* 		 * Ignore "." and "..". 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|ent
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ent
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Ignore plain files; they do not have subdirectories 		 * and thus have no attributes. 		 */
if|if
condition|(
name|ent
operator|->
name|d_type
operator|==
name|DT_REG
condition|)
continue|continue;
comment|/* 		 * Is there an "ifindex" file under that name? 		 * (We don't care whether it's a directory or 		 * a symlink; older kernels have directories 		 * for devices, newer kernels have symlinks to 		 * directories.) 		 */
name|pcap_snprintf
argument_list|(
name|subsystem_path
argument_list|,
sizeof|sizeof
name|subsystem_path
argument_list|,
literal|"/sys/class/net/%s/ifindex"
argument_list|,
name|ent
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|subsystem_path
argument_list|,
operator|&
name|statb
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Stat failed.  Either there was an error 			 * other than ENOENT, and we don't know if 			 * this is an interface, or it's ENOENT, 			 * and either some part of "/sys/class/net/{if}" 			 * disappeared, in which case it probably means 			 * the interface disappeared, or there's no 			 * "ifindex" file, which means it's not a 			 * network interface. 			 */
continue|continue;
block|}
comment|/* 		 * Attempt to add the interface. 		 */
if|if
condition|(
name|add_linux_if
argument_list|(
name|devlistp
argument_list|,
operator|&
name|ent
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|,
name|fd
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Fail. */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Well, we didn't fail for any other reason; did we 		 * fail due to an error reading the directory? 		 */
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error reading /sys/class/net: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|sys_class_net_d
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/*  * Get from "/proc/net/dev" all interfaces listed there; if they're  * already in the list of interfaces we have, that won't add another  * instance, but if they're not, that'll add them.  *  * See comments from scan_sys_class_net().  */
specifier|static
name|int
name|scan_proc_net_dev
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|devlistp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|FILE
modifier|*
name|proc_net_f
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|linebuf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|linenum
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|proc_net_f
operator|=
name|fopen
argument_list|(
literal|"/proc/net/dev"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_net_f
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Don't fail if it doesn't exist at all. 		 */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Fail if we got some other error. 		 */
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't open /proc/net/dev: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Create a socket from which to fetch interface information. 	 */
name|fd
operator|=
name|socket
argument_list|(
name|PF_UNIX
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|proc_net_f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|linenum
operator|=
literal|1
init|;
name|fgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
name|linebuf
argument_list|,
name|proc_net_f
argument_list|)
operator|!=
name|NULL
condition|;
name|linenum
operator|++
control|)
block|{
comment|/* 		 * Skip the first two lines - they're headers. 		 */
if|if
condition|(
name|linenum
operator|<=
literal|2
condition|)
continue|continue;
name|p
operator|=
operator|&
name|linebuf
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * Skip leading white space. 		 */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/* blank line */
comment|/* 		 * Attempt to add the interface. 		 */
if|if
condition|(
name|add_linux_if
argument_list|(
name|devlistp
argument_list|,
name|p
argument_list|,
name|fd
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Fail. */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Well, we didn't fail for any other reason; did we 		 * fail due to an error reading the file? 		 */
if|if
condition|(
name|ferror
argument_list|(
name|proc_net_f
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error reading /proc/net/dev: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|proc_net_f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/*  * Description string for the "any" device.  */
specifier|static
specifier|const
name|char
name|any_descr
index|[]
init|=
literal|"Pseudo-device that captures on all interfaces"
decl_stmt|;
comment|/*  * A SOCK_PACKET or PF_PACKET socket can be bound to any network interface.  */
specifier|static
name|int
name|can_be_bound
parameter_list|(
specifier|const
name|char
modifier|*
name|name
name|_U_
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* 	 * Get the list of regular interfaces first. 	 */
if|if
condition|(
name|pcap_findalldevs_interfaces
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|,
name|can_be_bound
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* failure */
comment|/* 	 * Read "/sys/class/net", and add to the list of interfaces all 	 * interfaces listed there that we don't already have, because, 	 * on Linux, SIOCGIFCONF reports only interfaces with IPv4 addresses, 	 * and even getifaddrs() won't return information about 	 * interfaces with no addresses, so you need to read "/sys/class/net" 	 * to get the names of the rest of the interfaces. 	 */
name|ret
operator|=
name|scan_sys_class_net
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* failed */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No /sys/class/net; try reading /proc/net/dev instead. 		 */
if|if
condition|(
name|scan_proc_net_dev
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Add the "any" device. 	 */
if|if
condition|(
name|pcap_add_if
argument_list|(
name|alldevsp
argument_list|,
literal|"any"
argument_list|,
name|PCAP_IF_UP
operator||
name|PCAP_IF_RUNNING
argument_list|,
name|any_descr
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *  Attach the given BPF code to the packet capture device.  */
specifier|static
name|int
name|pcap_setfilter_linux_common
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|filter
parameter_list|,
name|int
name|is_mmapped
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
decl_stmt|;
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
name|struct
name|sock_fprog
name|fcode
decl_stmt|;
name|int
name|can_filter_in_kernel
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|handle
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|filter
condition|)
block|{
name|strlcpy
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
literal|"setfilter: No filter specified"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|handlep
operator|=
name|handle
operator|->
name|priv
expr_stmt|;
comment|/* Make our private copy of the filter */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|handle
argument_list|,
name|filter
argument_list|)
operator|<
literal|0
condition|)
comment|/* install_bpf_program() filled in errbuf */
return|return
operator|-
literal|1
return|;
comment|/* 	 * Run user level packet filter by default. Will be overriden if 	 * installing a kernel filter succeeds. 	 */
name|handlep
operator|->
name|filter_in_userland
operator|=
literal|1
expr_stmt|;
comment|/* Install kernel level filter if possible */
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
ifdef|#
directive|ifdef
name|USHRT_MAX
if|if
condition|(
name|handle
operator|->
name|fcode
operator|.
name|bf_len
operator|>
name|USHRT_MAX
condition|)
block|{
comment|/* 		 * fcode.len is an unsigned short for current kernel. 		 * I have yet to see BPF-Code with that much 		 * instructions but still it is possible. So for the 		 * sake of correctness I added this check. 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Filter too complex for kernel\n"
argument_list|)
expr_stmt|;
name|fcode
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|fcode
operator|.
name|filter
operator|=
name|NULL
expr_stmt|;
name|can_filter_in_kernel
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* USHRT_MAX */
block|{
comment|/* 		 * Oh joy, the Linux kernel uses struct sock_fprog instead 		 * of struct bpf_program and of course the length field is 		 * of different size. Pointed out by Sebastian 		 * 		 * Oh, and we also need to fix it up so that all "ret" 		 * instructions with non-zero operands have MAXIMUM_SNAPLEN 		 * as the operand if we're not capturing in memory-mapped 		 * mode, and so that, if we're in cooked mode, all memory- 		 * reference instructions use special magic offsets in 		 * references to the link-layer header and assume that the 		 * link-layer payload begins at 0; "fix_program()" will do 		 * that. 		 */
switch|switch
condition|(
name|fix_program
argument_list|(
name|handle
argument_list|,
operator|&
name|fcode
argument_list|,
name|is_mmapped
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
default|default:
comment|/* 			 * Fatal error; just quit. 			 * (The "default" case shouldn't happen; we 			 * return -1 for that reason.) 			 */
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* 			 * The program performed checks that we can't make 			 * work in the kernel. 			 */
name|can_filter_in_kernel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 			 * We have a filter that'll work in the kernel. 			 */
name|can_filter_in_kernel
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * NOTE: at this point, we've set both the "len" and "filter" 	 * fields of "fcode".  As of the 2.6.32.4 kernel, at least, 	 * those are the only members of the "sock_fprog" structure, 	 * so we initialize every member of that structure. 	 * 	 * If there is anything in "fcode" that is not initialized, 	 * it is either a field added in a later kernel, or it's 	 * padding. 	 * 	 * If a new field is added, this code needs to be updated 	 * to set it correctly. 	 * 	 * If there are no other fields, then: 	 * 	 *	if the Linux kernel looks at the padding, it's 	 *	buggy; 	 * 	 *	if the Linux kernel doesn't look at the padding, 	 *	then if some tool complains that we're passing 	 *	uninitialized data to the kernel, then the tool 	 *	is buggy and needs to understand that it's just 	 *	padding. 	 */
if|if
condition|(
name|can_filter_in_kernel
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|set_kernel_filter
argument_list|(
name|handle
argument_list|,
operator|&
name|fcode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Installation succeded - using kernel filter, 			 * so userland filtering not needed. 			 */
name|handlep
operator|->
name|filter_in_userland
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
comment|/* Non-fatal error */
block|{
comment|/* 			 * Print a warning if we weren't able to install 			 * the filter for a reason other than "this kernel 			 * isn't configured to support socket filters. 			 */
if|if
condition|(
name|errno
operator|!=
name|ENOPROTOOPT
operator|&&
name|errno
operator|!=
name|EOPNOTSUPP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Kernel filter failed: %s\n"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If we're not using the kernel filter, get rid of any kernel 	 * filter that might've been there before, e.g. because the 	 * previous filter could work in the kernel, or because some other 	 * code attached a filter to the socket by some means other than 	 * calling "pcap_setfilter()".  Otherwise, the kernel filter may 	 * filter out packets that would pass the new userland filter. 	 */
if|if
condition|(
name|handlep
operator|->
name|filter_in_userland
condition|)
block|{
if|if
condition|(
name|reset_kernel_filter
argument_list|(
name|handle
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't remove kernel filter: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* fatal error */
block|}
block|}
comment|/* 	 * Free up the copy of the filter that was made by "fix_program()". 	 */
if|if
condition|(
name|fcode
operator|.
name|filter
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fcode
operator|.
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|2
condition|)
comment|/* Fatal error */
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* SO_ATTACH_FILTER */
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|pcap_setfilter_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|filter
parameter_list|)
block|{
return|return
name|pcap_setfilter_linux_common
argument_list|(
name|handle
argument_list|,
name|filter
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/*  * Set direction flag: Which packets do we accept on a forwarding  * single device? IN, OUT or both?  */
specifier|static
name|int
name|pcap_setdirection_linux
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|pcap_direction_t
name|d
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
if|if
condition|(
operator|!
name|handlep
operator|->
name|sock_packet
condition|)
block|{
name|handle
operator|->
name|direction
operator|=
name|d
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* 	 * We're not using PF_PACKET sockets, so we can't determine 	 * the direction of the packet. 	 */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Setting direction is not supported on SOCK_PACKET sockets"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/*  * Map the PACKET_ value to a LINUX_SLL_ value; we  * want the same numerical value to be used in  * the link-layer header even if the numerical values  * for the PACKET_ #defines change, so that programs  * that look at the packet type field will always be  * able to handle DLT_LINUX_SLL captures.  */
specifier|static
name|short
name|int
name|map_packet_type_to_sll_type
parameter_list|(
name|short
name|int
name|sll_pkttype
parameter_list|)
block|{
switch|switch
condition|(
name|sll_pkttype
condition|)
block|{
case|case
name|PACKET_HOST
case|:
return|return
name|htons
argument_list|(
name|LINUX_SLL_HOST
argument_list|)
return|;
case|case
name|PACKET_BROADCAST
case|:
return|return
name|htons
argument_list|(
name|LINUX_SLL_BROADCAST
argument_list|)
return|;
case|case
name|PACKET_MULTICAST
case|:
return|return
name|htons
argument_list|(
name|LINUX_SLL_MULTICAST
argument_list|)
return|;
case|case
name|PACKET_OTHERHOST
case|:
return|return
name|htons
argument_list|(
name|LINUX_SLL_OTHERHOST
argument_list|)
return|;
case|case
name|PACKET_OUTGOING
case|:
return|return
name|htons
argument_list|(
name|LINUX_SLL_OUTGOING
argument_list|)
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
specifier|static
name|int
name|is_wifi
parameter_list|(
name|int
name|sock_fd
ifndef|#
directive|ifndef
name|IW_MODE_MONITOR
name|_U_
endif|#
directive|endif
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
name|char
modifier|*
name|pathstr
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * See if there's a sysfs wireless directory for it. 	 * If so, it's a wireless interface. 	 */
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|pathstr
argument_list|,
literal|"/sys/class/net/%s/wireless"
argument_list|,
name|device
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Just give up here. 		 */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|pathstr
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|pathstr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|free
argument_list|(
name|pathstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
comment|/* 	 * OK, maybe it's not wireless, or maybe this kernel doesn't 	 * support sysfs.  Try the wireless extensions. 	 */
if|if
condition|(
name|has_wext
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|errbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 		 * It supports the wireless extensions, so it's a Wi-Fi 		 * device. 		 */
return|return
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/*  *  Linux uses the ARP hardware type to identify the type of an  *  interface. pcap uses the DLT_xxx constants for this. This  *  function takes a pointer to a "pcap_t", and an ARPHRD_xxx  *  constant, as arguments, and sets "handle->linktype" to the  *  appropriate DLT_XXX constant and sets "handle->offset" to  *  the appropriate value (to make "handle->offset" plus link-layer  *  header length be a multiple of 4, so that the link-layer payload  *  will be aligned on a 4-byte boundary when capturing packets).  *  (If the offset isn't set here, it'll be 0; add code as appropriate  *  for cases where it shouldn't be 0.)  *  *  If "cooked_ok" is non-zero, we can use DLT_LINUX_SLL and capture  *  in cooked mode; otherwise, we can't use cooked mode, so we have  *  to pick some type that works in raw mode, or fail.  *  *  Sets the link type to -1 if unable to map the type.  */
specifier|static
name|void
name|map_arphrd_to_dlt
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|sock_fd
parameter_list|,
name|int
name|arptype
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|int
name|cooked_ok
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|cdma_rmnet
index|[]
init|=
literal|"cdma_rmnet"
decl_stmt|;
switch|switch
condition|(
name|arptype
condition|)
block|{
case|case
name|ARPHRD_ETHER
case|:
comment|/* 		 * For various annoying reasons having to do with DHCP 		 * software, some versions of Android give the mobile- 		 * phone-network interface an ARPHRD_ value of 		 * ARPHRD_ETHER, even though the packets supplied by 		 * that interface have no link-layer header, and begin 		 * with an IP header, so that the ARPHRD_ value should 		 * be ARPHRD_NONE. 		 * 		 * Detect those devices by checking the device name, and 		 * use DLT_RAW for them. 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|device
argument_list|,
name|cdma_rmnet
argument_list|,
sizeof|sizeof
name|cdma_rmnet
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|handle
operator|->
name|linktype
operator|=
name|DLT_RAW
expr_stmt|;
return|return;
block|}
comment|/* 		 * Is this a real Ethernet device?  If so, give it a 		 * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so 		 * that an application can let you choose it, in case you're 		 * capturing DOCSIS traffic that a Cisco Cable Modem 		 * Termination System is putting out onto an Ethernet (it 		 * doesn't put an Ethernet header onto the wire, it puts raw 		 * DOCSIS frames out on the wire inside the low-level 		 * Ethernet framing). 		 * 		 * XXX - are there any other sorts of "fake Ethernet" that 		 * have ARPHRD_ETHER but that shouldn't offer DLT_DOCSIS as 		 * a Cisco CMTS won't put traffic onto it or get traffic 		 * bridged onto it?  ISDN is handled in "activate_new()", 		 * as we fall back on cooked mode there, and we use 		 * is_wifi() to check for 802.11 devices; are there any 		 * others? 		 */
if|if
condition|(
operator|!
name|is_wifi
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|)
condition|)
block|{
comment|/* 			 * It's not a Wi-Fi device; offer DOCSIS. 			 */
name|handle
operator|->
name|dlt_list
operator|=
operator|(
name|u_int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* 			 * If that fails, just leave the list empty. 			 */
if|if
condition|(
name|handle
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|handle
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|=
name|DLT_EN10MB
expr_stmt|;
name|handle
operator|->
name|dlt_list
index|[
literal|1
index|]
operator|=
name|DLT_DOCSIS
expr_stmt|;
name|handle
operator|->
name|dlt_count
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/* FALLTHROUGH */
case|case
name|ARPHRD_METRICOM
case|:
case|case
name|ARPHRD_LOOPBACK
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ARPHRD_EETHER
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_EN3MB
expr_stmt|;
break|break;
case|case
name|ARPHRD_AX25
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_AX25_KISS
expr_stmt|;
break|break;
case|case
name|ARPHRD_PRONET
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_PRONET
expr_stmt|;
break|break;
case|case
name|ARPHRD_CHAOS
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_CHAOS
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_CAN
define|#
directive|define
name|ARPHRD_CAN
value|280
endif|#
directive|endif
case|case
name|ARPHRD_CAN
case|:
comment|/* 		 * Map this to DLT_LINUX_SLL; that way, CAN frames will 		 * have ETH_P_CAN/LINUX_SLL_P_CAN as the protocol and 		 * CAN FD frames will have ETH_P_CANFD/LINUX_SLL_P_CANFD 		 * as the protocol, so they can be distinguished by the 		 * protocol in the SLL header. 		 */
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_IEEE802_TR
define|#
directive|define
name|ARPHRD_IEEE802_TR
value|800
comment|/* From Linux 2.4 */
endif|#
directive|endif
case|case
name|ARPHRD_IEEE802_TR
case|:
case|case
name|ARPHRD_IEEE802
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_IEEE802
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ARPHRD_ARCNET
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_ARCNET_LINUX
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_FDDI
comment|/* From Linux 2.2.13 */
define|#
directive|define
name|ARPHRD_FDDI
value|774
endif|#
directive|endif
case|case
name|ARPHRD_FDDI
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_FDDI
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|3
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_ATM
comment|/* FIXME: How to #include this? */
define|#
directive|define
name|ARPHRD_ATM
value|19
endif|#
directive|endif
case|case
name|ARPHRD_ATM
case|:
comment|/* 		 * The Classical IP implementation in ATM for Linux 		 * supports both what RFC 1483 calls "LLC Encapsulation", 		 * in which each packet has an LLC header, possibly 		 * with a SNAP header as well, prepended to it, and 		 * what RFC 1483 calls "VC Based Multiplexing", in which 		 * different virtual circuits carry different network 		 * layer protocols, and no header is prepended to packets. 		 * 		 * They both have an ARPHRD_ type of ARPHRD_ATM, so 		 * you can't use the ARPHRD_ type to find out whether 		 * captured packets will have an LLC header, and, 		 * while there's a socket ioctl to *set* the encapsulation 		 * type, there's no ioctl to *get* the encapsulation type. 		 * 		 * This means that 		 * 		 *	programs that dissect Linux Classical IP frames 		 *	would have to check for an LLC header and, 		 *	depending on whether they see one or not, dissect 		 *	the frame as LLC-encapsulated or as raw IP (I 		 *	don't know whether there's any traffic other than 		 *	IP that would show up on the socket, or whether 		 *	there's any support for IPv6 in the Linux 		 *	Classical IP code); 		 * 		 *	filter expressions would have to compile into 		 *	code that checks for an LLC header and does 		 *	the right thing. 		 * 		 * Both of those are a nuisance - and, at least on systems 		 * that support PF_PACKET sockets, we don't have to put 		 * up with those nuisances; instead, we can just capture 		 * in cooked mode.  That's what we'll do, if we can. 		 * Otherwise, we'll just fail. 		 */
if|if
condition|(
name|cooked_ok
condition|)
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
else|else
name|handle
operator|->
name|linktype
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_IEEE80211
comment|/* From Linux 2.4.6 */
define|#
directive|define
name|ARPHRD_IEEE80211
value|801
endif|#
directive|endif
case|case
name|ARPHRD_IEEE80211
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_IEEE802_11
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_IEEE80211_PRISM
comment|/* From Linux 2.4.18 */
define|#
directive|define
name|ARPHRD_IEEE80211_PRISM
value|802
endif|#
directive|endif
case|case
name|ARPHRD_IEEE80211_PRISM
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_PRISM_HEADER
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_IEEE80211_RADIOTAP
comment|/* new */
define|#
directive|define
name|ARPHRD_IEEE80211_RADIOTAP
value|803
endif|#
directive|endif
case|case
name|ARPHRD_IEEE80211_RADIOTAP
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_IEEE802_11_RADIO
expr_stmt|;
break|break;
case|case
name|ARPHRD_PPP
case|:
comment|/* 		 * Some PPP code in the kernel supplies no link-layer 		 * header whatsoever to PF_PACKET sockets; other PPP 		 * code supplies PPP link-layer headers ("syncppp.c"); 		 * some PPP code might supply random link-layer 		 * headers (PPP over ISDN - there's code in Ethereal, 		 * for example, to cope with PPP-over-ISDN captures 		 * with which the Ethereal developers have had to cope, 		 * heuristically trying to determine which of the 		 * oddball link-layer headers particular packets have). 		 * 		 * As such, we just punt, and run all PPP interfaces 		 * in cooked mode, if we can; otherwise, we just treat 		 * it as DLT_RAW, for now - if somebody needs to capture, 		 * on a 2.0[.x] kernel, on PPP devices that supply a 		 * link-layer header, they'll have to add code here to 		 * map to the appropriate DLT_ type (possibly adding a 		 * new DLT_ type, if necessary). 		 */
if|if
condition|(
name|cooked_ok
condition|)
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
else|else
block|{
comment|/* 			 * XXX - handle ISDN types here?  We can't fall 			 * back on cooked sockets, so we'd have to 			 * figure out from the device name what type of 			 * link-layer encapsulation it's using, and map 			 * that to an appropriate DLT_ value, meaning 			 * we'd map "isdnN" devices to DLT_RAW (they 			 * supply raw IP packets with no link-layer 			 * header) and "isdY" devices to a new DLT_I4L_IP 			 * type that has only an Ethernet packet type as 			 * a link-layer header. 			 * 			 * But sometimes we seem to get random crap 			 * in the link-layer header when capturing on 			 * ISDN devices.... 			 */
name|handle
operator|->
name|linktype
operator|=
name|DLT_RAW
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_CISCO
define|#
directive|define
name|ARPHRD_CISCO
value|513
comment|/* previously ARPHRD_HDLC */
endif|#
directive|endif
case|case
name|ARPHRD_CISCO
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_C_HDLC
expr_stmt|;
break|break;
comment|/* Not sure if this is correct for all tunnels, but it 	 * works for CIPE */
case|case
name|ARPHRD_TUNNEL
case|:
ifndef|#
directive|ifndef
name|ARPHRD_SIT
define|#
directive|define
name|ARPHRD_SIT
value|776
comment|/* From Linux 2.2.13 */
endif|#
directive|endif
case|case
name|ARPHRD_SIT
case|:
case|case
name|ARPHRD_CSLIP
case|:
case|case
name|ARPHRD_SLIP6
case|:
case|case
name|ARPHRD_CSLIP6
case|:
case|case
name|ARPHRD_ADAPT
case|:
case|case
name|ARPHRD_SLIP
case|:
ifndef|#
directive|ifndef
name|ARPHRD_RAWHDLC
define|#
directive|define
name|ARPHRD_RAWHDLC
value|518
endif|#
directive|endif
case|case
name|ARPHRD_RAWHDLC
case|:
ifndef|#
directive|ifndef
name|ARPHRD_DLCI
define|#
directive|define
name|ARPHRD_DLCI
value|15
endif|#
directive|endif
case|case
name|ARPHRD_DLCI
case|:
comment|/* 		 * XXX - should some of those be mapped to DLT_LINUX_SLL 		 * instead?  Should we just map all of them to DLT_LINUX_SLL? 		 */
name|handle
operator|->
name|linktype
operator|=
name|DLT_RAW
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_FRAD
define|#
directive|define
name|ARPHRD_FRAD
value|770
endif|#
directive|endif
case|case
name|ARPHRD_FRAD
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_FRELAY
expr_stmt|;
break|break;
case|case
name|ARPHRD_LOCALTLK
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_LTALK
expr_stmt|;
break|break;
case|case
literal|18
case|:
comment|/* 		 * RFC 4338 defines an encapsulation for IP and ARP 		 * packets that's compatible with the RFC 2625 		 * encapsulation, but that uses a different ARP 		 * hardware type and hardware addresses.  That 		 * ARP hardware type is 18; Linux doesn't define 		 * any ARPHRD_ value as 18, but if it ever officially 		 * supports RFC 4338-style IP-over-FC, it should define 		 * one. 		 * 		 * For now, we map it to DLT_IP_OVER_FC, in the hopes 		 * that this will encourage its use in the future, 		 * should Linux ever officially support RFC 4338-style 		 * IP-over-FC. 		 */
name|handle
operator|->
name|linktype
operator|=
name|DLT_IP_OVER_FC
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_FCPP
define|#
directive|define
name|ARPHRD_FCPP
value|784
endif|#
directive|endif
case|case
name|ARPHRD_FCPP
case|:
ifndef|#
directive|ifndef
name|ARPHRD_FCAL
define|#
directive|define
name|ARPHRD_FCAL
value|785
endif|#
directive|endif
case|case
name|ARPHRD_FCAL
case|:
ifndef|#
directive|ifndef
name|ARPHRD_FCPL
define|#
directive|define
name|ARPHRD_FCPL
value|786
endif|#
directive|endif
case|case
name|ARPHRD_FCPL
case|:
ifndef|#
directive|ifndef
name|ARPHRD_FCFABRIC
define|#
directive|define
name|ARPHRD_FCFABRIC
value|787
endif|#
directive|endif
case|case
name|ARPHRD_FCFABRIC
case|:
comment|/* 		 * Back in 2002, Donald Lee at Cray wanted a DLT_ for 		 * IP-over-FC: 		 * 		 *	http://www.mail-archive.com/tcpdump-workers@sandelman.ottawa.on.ca/msg01043.html 		 * 		 * and one was assigned. 		 * 		 * In a later private discussion (spun off from a message 		 * on the ethereal-users list) on how to get that DLT_ 		 * value in libpcap on Linux, I ended up deciding that 		 * the best thing to do would be to have him tweak the 		 * driver to set the ARPHRD_ value to some ARPHRD_FCxx 		 * type, and map all those types to DLT_IP_OVER_FC: 		 * 		 *	I've checked into the libpcap and tcpdump CVS tree 		 *	support for DLT_IP_OVER_FC.  In order to use that, 		 *	you'd have to modify your modified driver to return 		 *	one of the ARPHRD_FCxxx types, in "fcLINUXfcp.c" - 		 *	change it to set "dev->type" to ARPHRD_FCFABRIC, for 		 *	example (the exact value doesn't matter, it can be 		 *	any of ARPHRD_FCPP, ARPHRD_FCAL, ARPHRD_FCPL, or 		 *	ARPHRD_FCFABRIC). 		 * 		 * 11 years later, Christian Svensson wanted to map 		 * various ARPHRD_ values to DLT_FC_2 and 		 * DLT_FC_2_WITH_FRAME_DELIMS for raw Fibre Channel 		 * frames: 		 * 		 *	https://github.com/mcr/libpcap/pull/29 		 * 		 * There doesn't seem to be any network drivers that uses 		 * any of the ARPHRD_FC* values for IP-over-FC, and 		 * it's not exactly clear what the "Dummy types for non 		 * ARP hardware" are supposed to mean (link-layer 		 * header type?  Physical network type?), so it's 		 * not exactly clear why the ARPHRD_FC* types exist 		 * in the first place. 		 * 		 * For now, we map them to DLT_FC_2, and provide an 		 * option of DLT_FC_2_WITH_FRAME_DELIMS, as well as 		 * DLT_IP_OVER_FC just in case there's some old 		 * driver out there that uses one of those types for 		 * IP-over-FC on which somebody wants to capture 		 * packets. 		 */
name|handle
operator|->
name|dlt_list
operator|=
operator|(
name|u_int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * If that fails, just leave the list empty. 		 */
if|if
condition|(
name|handle
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|handle
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|=
name|DLT_FC_2
expr_stmt|;
name|handle
operator|->
name|dlt_list
index|[
literal|1
index|]
operator|=
name|DLT_FC_2_WITH_FRAME_DELIMS
expr_stmt|;
name|handle
operator|->
name|dlt_list
index|[
literal|2
index|]
operator|=
name|DLT_IP_OVER_FC
expr_stmt|;
name|handle
operator|->
name|dlt_count
operator|=
literal|3
expr_stmt|;
block|}
name|handle
operator|->
name|linktype
operator|=
name|DLT_FC_2
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_IRDA
define|#
directive|define
name|ARPHRD_IRDA
value|783
endif|#
directive|endif
case|case
name|ARPHRD_IRDA
case|:
comment|/* Don't expect IP packet out of this interfaces... */
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_IRDA
expr_stmt|;
comment|/* We need to save packet direction for IrDA decoding, 		 * so let's use "Linux-cooked" mode. Jean II 		 * 		 * XXX - this is handled in activate_new(). */
comment|/* handlep->cooked = 1; */
break|break;
comment|/* ARPHRD_LAPD is unofficial and randomly allocated, if reallocation 	 * is needed, please report it to<daniele@orlandi.com> */
ifndef|#
directive|ifndef
name|ARPHRD_LAPD
define|#
directive|define
name|ARPHRD_LAPD
value|8445
endif|#
directive|endif
case|case
name|ARPHRD_LAPD
case|:
comment|/* Don't expect IP packet out of this interfaces... */
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_LAPD
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_NONE
define|#
directive|define
name|ARPHRD_NONE
value|0xFFFE
endif|#
directive|endif
case|case
name|ARPHRD_NONE
case|:
comment|/* 		 * No link-layer header; packets are just IP 		 * packets, so use DLT_RAW. 		 */
name|handle
operator|->
name|linktype
operator|=
name|DLT_RAW
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_IEEE802154
define|#
directive|define
name|ARPHRD_IEEE802154
value|804
endif|#
directive|endif
case|case
name|ARPHRD_IEEE802154
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_IEEE802_15_4_NOFCS
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARPHRD_NETLINK
define|#
directive|define
name|ARPHRD_NETLINK
value|824
endif|#
directive|endif
case|case
name|ARPHRD_NETLINK
case|:
name|handle
operator|->
name|linktype
operator|=
name|DLT_NETLINK
expr_stmt|;
comment|/* 		 * We need to use cooked mode, so that in sll_protocol we 		 * pick up the netlink protocol type such as NETLINK_ROUTE, 		 * NETLINK_GENERIC, NETLINK_FIB_LOOKUP, etc. 		 * 		 * XXX - this is handled in activate_new(). 		 */
comment|/* handlep->cooked = 1; */
break|break;
default|default:
name|handle
operator|->
name|linktype
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* ===== Functions to interface to the newer kernels ================== */
comment|/*  * Try to open a packet socket using the new kernel PF_PACKET interface.  * Returns 1 on success, 0 on an error that means the new interface isn't  * present (so the old SOCK_PACKET interface should be tried), and a  * PCAP_ERROR_ value on an error that means that the old mechanism won't  * work either (so it shouldn't be tried).  */
specifier|static
name|int
name|activate_new
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|device
init|=
name|handle
operator|->
name|opt
operator|.
name|device
decl_stmt|;
name|int
name|is_any_device
init|=
operator|(
name|strcmp
argument_list|(
name|device
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|sock_fd
init|=
operator|-
literal|1
decl_stmt|,
name|arptype
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PACKET_AUXDATA
name|int
name|val
decl_stmt|;
endif|#
directive|endif
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|packet_mreq
name|mr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_BPF_EXTENSIONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SKF_AD_VLAN_TAG_PRESENT
argument_list|)
name|int
name|bpf_extensions
decl_stmt|;
name|socklen_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|bpf_extensions
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Open a socket with protocol family packet. If the 	 * "any" device was specified, we open a SOCK_DGRAM 	 * socket for the cooked interface, otherwise we first 	 * try a SOCK_RAW socket for the raw interface. 	 */
name|sock_fd
operator|=
name|is_any_device
condition|?
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
else|:
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_RAW
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_fd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
operator|||
name|errno
operator|==
name|EAFNOSUPPORT
condition|)
block|{
comment|/* 			 * We don't support PF_PACKET/SOCK_whatever 			 * sockets; try the old mechanism. 			 */
return|return
literal|0
return|;
block|}
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EPERM
operator|||
name|errno
operator|==
name|EACCES
condition|)
block|{
comment|/* 			 * You don't have permission to open the 			 * socket. 			 */
return|return
name|PCAP_ERROR_PERM_DENIED
return|;
block|}
else|else
block|{
comment|/* 			 * Other error. 			 */
return|return
name|PCAP_ERROR
return|;
block|}
block|}
comment|/* It seems the kernel supports the new interface. */
name|handlep
operator|->
name|sock_packet
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get the interface index of the loopback device. 	 * If the attempt fails, don't fail, just set the 	 * "handlep->lo_ifindex" to -1. 	 * 	 * XXX - can there be more than one device that loops 	 * packets back, i.e. devices other than "lo"?  If so, 	 * we'd need to find them all, and have an array of 	 * indices for them, and check all of them in 	 * "pcap_read_packet()". 	 */
name|handlep
operator|->
name|lo_ifindex
operator|=
name|iface_get_id
argument_list|(
name|sock_fd
argument_list|,
literal|"lo"
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
comment|/* 	 * Default value for offset to align link-layer payload 	 * on a 4-byte boundary. 	 */
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * What kind of frames do we have to deal with? Fall back 	 * to cooked mode if we have an unknown interface type 	 * or a type we know doesn't work well in raw mode. 	 */
if|if
condition|(
operator|!
name|is_any_device
condition|)
block|{
comment|/* Assume for now we don't need cooked mode. */
name|handlep
operator|->
name|cooked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 			 * We were asked to turn on monitor mode. 			 * Do so before we get the link-layer type, 			 * because entering monitor mode could change 			 * the link-layer type. 			 */
name|err
operator|=
name|enter_rfmon_mode
argument_list|(
name|handle
argument_list|,
name|sock_fd
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
comment|/* Hard failure */
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Nothing worked for turning monitor mode 				 * on. 				 */
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR_RFMON_NOTSUP
return|;
block|}
comment|/* 			 * Either monitor mode has been turned on for 			 * the device, or we've been given a different 			 * device to open for monitor mode.  If we've 			 * been given a different device, use it. 			 */
if|if
condition|(
name|handlep
operator|->
name|mondevice
operator|!=
name|NULL
condition|)
name|device
operator|=
name|handlep
operator|->
name|mondevice
expr_stmt|;
block|}
name|arptype
operator|=
name|iface_get_arptype
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|arptype
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
name|arptype
return|;
block|}
name|map_arphrd_to_dlt
argument_list|(
name|handle
argument_list|,
name|sock_fd
argument_list|,
name|arptype
argument_list|,
name|device
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
operator|-
literal|1
operator|||
name|handle
operator|->
name|linktype
operator|==
name|DLT_LINUX_SLL
operator|||
name|handle
operator|->
name|linktype
operator|==
name|DLT_LINUX_IRDA
operator|||
name|handle
operator|->
name|linktype
operator|==
name|DLT_LINUX_LAPD
operator|||
name|handle
operator|->
name|linktype
operator|==
name|DLT_NETLINK
operator|||
operator|(
name|handle
operator|->
name|linktype
operator|==
name|DLT_EN10MB
operator|&&
operator|(
name|strncmp
argument_list|(
literal|"isdn"
argument_list|,
name|device
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
literal|"isdY"
argument_list|,
name|device
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Unknown interface type (-1), or a 			 * device we explicitly chose to run 			 * in cooked mode (e.g., PPP devices), 			 * or an ISDN device (whose link-layer 			 * type we can only determine by using 			 * APIs that may be different on different 			 * kernels) - reopen in cooked mode. 			 */
if|if
condition|(
name|close
argument_list|(
name|sock_fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"close: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|sock_fd
operator|=
name|socket
argument_list|(
name|PF_PACKET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EPERM
operator|||
name|errno
operator|==
name|EACCES
condition|)
block|{
comment|/* 					 * You don't have permission to 					 * open the socket. 					 */
return|return
name|PCAP_ERROR_PERM_DENIED
return|;
block|}
else|else
block|{
comment|/* 					 * Other error. 					 */
return|return
name|PCAP_ERROR
return|;
block|}
block|}
name|handlep
operator|->
name|cooked
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Get rid of any link-layer type list 			 * we allocated - this only supports cooked 			 * capture. 			 */
if|if
condition|(
name|handle
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|handle
operator|->
name|dlt_list
argument_list|)
expr_stmt|;
name|handle
operator|->
name|dlt_list
operator|=
name|NULL
expr_stmt|;
name|handle
operator|->
name|dlt_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Warn that we're falling back on 				 * cooked mode; we may want to 				 * update "map_arphrd_to_dlt()" 				 * to handle the new type. 				 */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"arptype %d not "
literal|"supported by libpcap - "
literal|"falling back to cooked "
literal|"socket"
argument_list|,
name|arptype
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * IrDA capture is not a real "cooked" capture, 			 * it's IrLAP frames, not IP packets.  The 			 * same applies to LAPD capture. 			 */
if|if
condition|(
name|handle
operator|->
name|linktype
operator|!=
name|DLT_LINUX_IRDA
operator|&&
name|handle
operator|->
name|linktype
operator|!=
name|DLT_LINUX_LAPD
operator|&&
name|handle
operator|->
name|linktype
operator|!=
name|DLT_NETLINK
condition|)
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
block|}
name|handlep
operator|->
name|ifindex
operator|=
name|iface_get_id
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|ifindex
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|iface_bind
argument_list|(
name|sock_fd
argument_list|,
name|handlep
operator|->
name|ifindex
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
else|else
return|return
literal|0
return|;
comment|/* try old mechanism */
block|}
block|}
else|else
block|{
comment|/* 		 * The "any" device. 		 */
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 			 * It doesn't support monitor mode. 			 */
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR_RFMON_NOTSUP
return|;
block|}
comment|/* 		 * It uses cooked mode. 		 */
name|handlep
operator|->
name|cooked
operator|=
literal|1
expr_stmt|;
name|handle
operator|->
name|linktype
operator|=
name|DLT_LINUX_SLL
expr_stmt|;
comment|/* 		 * We're not bound to a device. 		 * For now, we're using this as an indication 		 * that we can't transmit; stop doing that only 		 * if we figure out how to transmit in cooked 		 * mode. 		 */
name|handlep
operator|->
name|ifindex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Select promiscuous mode on if "promisc" is set. 	 * 	 * Do not turn allmulti mode on if we don't select 	 * promiscuous mode - on some devices (e.g., Orinoco 	 * wireless interfaces), allmulti mode isn't supported 	 * and the driver implements it by turning promiscuous 	 * mode on, and that screws up the operation of the 	 * card as a normal networking interface, and on no 	 * other platform I know of does starting a non- 	 * promiscuous capture affect which multicast packets 	 * are received by the interface. 	 */
comment|/* 	 * Hmm, how can we set promiscuous mode on all interfaces? 	 * I am not sure if that is possible at all.  For now, we 	 * silently ignore attempts to turn promiscuous mode on 	 * for the "any" device (so you don't have to explicitly 	 * disable it in programs such as tcpdump). 	 */
if|if
condition|(
operator|!
name|is_any_device
operator|&&
name|handle
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mr
argument_list|)
argument_list|)
expr_stmt|;
name|mr
operator|.
name|mr_ifindex
operator|=
name|handlep
operator|->
name|ifindex
expr_stmt|;
name|mr
operator|.
name|mr_type
operator|=
name|PACKET_MR_PROMISC
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock_fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_ADD_MEMBERSHIP
argument_list|,
operator|&
name|mr
argument_list|,
sizeof|sizeof
argument_list|(
name|mr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"setsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
comment|/* Enable auxillary data if supported and reserve room for 	 * reconstructing VLAN headers. */
ifdef|#
directive|ifdef
name|HAVE_PACKET_AUXDATA
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock_fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_AUXDATA
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOPROTOOPT
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"setsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|handle
operator|->
name|offset
operator|+=
name|VLAN_TAG_LEN
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_PACKET_AUXDATA */
comment|/* 	 * This is a 2.2[.x] or later kernel (we know that 	 * because we're not using a SOCK_PACKET socket - 	 * PF_PACKET is supported only in 2.2 and later 	 * kernels). 	 * 	 * We can safely pass "recvfrom()" a byte count 	 * based on the snapshot length. 	 * 	 * If we're in cooked mode, make the snapshot length 	 * large enough to hold a "cooked mode" header plus 	 * 1 byte of packet data (so we don't pass a byte 	 * count of 0 to "recvfrom()"). 	 */
if|if
condition|(
name|handlep
operator|->
name|cooked
condition|)
block|{
if|if
condition|(
name|handle
operator|->
name|snapshot
operator|<
name|SLL_HDR_LEN
operator|+
literal|1
condition|)
name|handle
operator|->
name|snapshot
operator|=
name|SLL_HDR_LEN
operator|+
literal|1
expr_stmt|;
block|}
name|handle
operator|->
name|bufsize
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
comment|/* 	 * Set the offset at which to insert VLAN tags. 	 * That should be the offset of the type field. 	 */
switch|switch
condition|(
name|handle
operator|->
name|linktype
condition|)
block|{
case|case
name|DLT_EN10MB
case|:
comment|/* 		 * The type field is after the destination and source 		 * MAC address. 		 */
name|handlep
operator|->
name|vlan_offset
operator|=
literal|2
operator|*
name|ETH_ALEN
expr_stmt|;
break|break;
case|case
name|DLT_LINUX_SLL
case|:
comment|/* 		 * The type field is in the last 2 bytes of the 		 * DLT_LINUX_SLL header. 		 */
name|handlep
operator|->
name|vlan_offset
operator|=
name|SLL_HDR_LEN
operator|-
literal|2
expr_stmt|;
break|break;
default|default:
name|handlep
operator|->
name|vlan_offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SIOCGSTAMPNS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SO_TIMESTAMPNS
argument_list|)
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|tstamp_precision
operator|==
name|PCAP_TSTAMP_PRECISION_NANO
condition|)
block|{
name|int
name|nsec_tstamps
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock_fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TIMESTAMPNS
argument_list|,
operator|&
name|nsec_tstamps
argument_list|,
sizeof|sizeof
argument_list|(
name|nsec_tstamps
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"setsockopt: unable to set SO_TIMESTAMPNS"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock_fd
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
endif|#
directive|endif
comment|/* defined(SIOCGSTAMPNS)&& defined(SO_TIMESTAMPNS) */
comment|/* 	 * We've succeeded. Save the socket FD in the pcap structure. 	 */
name|handle
operator|->
name|fd
operator|=
name|sock_fd
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_BPF_EXTENSIONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SKF_AD_VLAN_TAG_PRESENT
argument_list|)
comment|/* 	 * Can we generate special code for VLAN checks? 	 * (XXX - what if we need the special code but it's not supported 	 * by the OS?  Is that possible?) 	 */
if|if
condition|(
name|getsockopt
argument_list|(
name|sock_fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BPF_EXTENSIONS
argument_list|,
operator|&
name|bpf_extensions
argument_list|,
operator|&
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bpf_extensions
operator|>=
name|SKF_AD_VLAN_TAG_PRESENT
condition|)
block|{
comment|/* 			 * Yes, we can.  Request that we do so. 			 */
name|handle
operator|->
name|bpf_codegen_flags
operator||=
name|BPF_SPECIAL_VLAN_HANDLING
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* defined(SO_BPF_EXTENSIONS)&& defined(SKF_AD_VLAN_TAG_PRESENT) */
return|return
literal|1
return|;
else|#
directive|else
comment|/* HAVE_PF_PACKET_SOCKETS */
name|strlcpy
argument_list|(
name|ebuf
argument_list|,
literal|"New packet capturing interface not supported by build "
literal|"environment"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* HAVE_PF_PACKET_SOCKETS */
block|}
ifdef|#
directive|ifdef
name|HAVE_PACKET_RING
comment|/*  * Attempt to activate with memory-mapped access.  *  * On success, returns 1, and sets *status to 0 if there are no warnings  * or to a PCAP_WARNING_ code if there is a warning.  *  * On failure due to lack of support for memory-mapped capture, returns  * 0.  *  * On error, returns -1, and sets *status to the appropriate error code;  * if that is PCAP_ERROR, sets handle->errbuf to the appropriate message.  */
specifier|static
name|int
name|activate_mmap
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * Attempt to allocate a buffer to hold the contents of one 	 * packet, for use by the oneshot callback. 	 */
name|handlep
operator|->
name|oneshot_buffer
operator|=
name|malloc
argument_list|(
name|handle
operator|->
name|snapshot
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|oneshot_buffer
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't allocate oneshot buffer: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|buffer_size
operator|==
literal|0
condition|)
block|{
comment|/* by default request 2M for the ring buffer */
name|handle
operator|->
name|opt
operator|.
name|buffer_size
operator|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
name|ret
operator|=
name|prepare_tpacket_socket
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|handlep
operator|->
name|oneshot_buffer
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|create_ring
argument_list|(
name|handle
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We don't support memory-mapped capture; our caller 		 * will fall back on reading from the socket. 		 */
name|free
argument_list|(
name|handlep
operator|->
name|oneshot_buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Error attempting to enable memory-mapped capture; 		 * fail.  create_ring() has set *status. 		 */
name|free
argument_list|(
name|handlep
operator|->
name|oneshot_buffer
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Success.  *status has been set either to 0 if there are no 	 * warnings or to a PCAP_WARNING_ value if there is a warning. 	 * 	 * Override some defaults and inherit the other fields from 	 * activate_new. 	 * handle->offset is used to get the current position into the rx ring. 	 * handle->cc is used to store the ring size. 	 */
switch|switch
condition|(
name|handlep
operator|->
name|tp_version
condition|)
block|{
case|case
name|TPACKET_V1
case|:
name|handle
operator|->
name|read_op
operator|=
name|pcap_read_linux_mmap_v1
expr_stmt|;
break|break;
case|case
name|TPACKET_V1_64
case|:
name|handle
operator|->
name|read_op
operator|=
name|pcap_read_linux_mmap_v1_64
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_TPACKET2
case|case
name|TPACKET_V2
case|:
name|handle
operator|->
name|read_op
operator|=
name|pcap_read_linux_mmap_v2
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
case|case
name|TPACKET_V3
case|:
name|handle
operator|->
name|read_op
operator|=
name|pcap_read_linux_mmap_v3
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|handle
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_linux_mmap
expr_stmt|;
name|handle
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_linux_mmap
expr_stmt|;
name|handle
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_mmap
expr_stmt|;
name|handle
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_mmap
expr_stmt|;
name|handle
operator|->
name|oneshot_callback
operator|=
name|pcap_oneshot_mmap
expr_stmt|;
name|handle
operator|->
name|selectable_fd
operator|=
name|handle
operator|->
name|fd
expr_stmt|;
return|return
literal|1
return|;
block|}
else|#
directive|else
comment|/* HAVE_PACKET_RING */
specifier|static
name|int
name|activate_mmap
parameter_list|(
name|pcap_t
modifier|*
name|handle
name|_U_
parameter_list|,
name|int
modifier|*
name|status
name|_U_
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_PACKET_RING */
ifdef|#
directive|ifdef
name|HAVE_PACKET_RING
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TPACKET2
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TPACKET3
argument_list|)
comment|/*  * Attempt to set the socket to the specified version of the memory-mapped  * header.  *  * Return 0 if we succeed; return 1 if we fail because that version isn't  * supported; return -1 on any other error, and set handle->errbuf.  */
specifier|static
name|int
name|init_tpacket
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|version_str
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|int
name|val
init|=
name|version
decl_stmt|;
name|socklen_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
decl_stmt|;
comment|/* 	 * Probe whether kernel supports the specified TPACKET version; 	 * this also gets the length of the header for that version. 	 */
if|if
condition|(
name|getsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_HDRLEN
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOPROTOOPT
operator|||
name|errno
operator|==
name|EINVAL
condition|)
return|return
literal|1
return|;
comment|/* no */
comment|/* Failed to even find out; this is a fatal error. */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't get %s header len on packet socket: %s"
argument_list|,
name|version_str
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|handlep
operator|->
name|tp_hdrlen
operator|=
name|val
expr_stmt|;
name|val
operator|=
name|version
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_VERSION
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't activate %s on packet socket: %s"
argument_list|,
name|version_str
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|handlep
operator|->
name|tp_version
operator|=
name|version
expr_stmt|;
comment|/* Reserve space for VLAN tag reconstruction */
name|val
operator|=
name|VLAN_TAG_LEN
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_RESERVE
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't set up reserve on packet socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* defined HAVE_TPACKET2 || defined HAVE_TPACKET3 */
comment|/*  * If the instruction set for which we're compiling has both 32-bit  * and 64-bit versions, and Linux support for the 64-bit version  * predates TPACKET_V2, define ISA_64_BIT as the .machine value  * you get from uname() for the 64-bit version.  Otherwise, leave  * it undefined.  (This includes ARM, which has a 64-bit version,  * but Linux support for it appeared well after TPACKET_V2 support  * did, so there should never be a case where 32-bit ARM code is  * running o a 64-bit kernel that only supports TPACKET_V1.)  *  * If we've omitted your favorite such architecture, please contribute  * a patch.  (No patch is needed for architectures that are 32-bit-only  * or for which Linux has no support for 32-bit userland - or for which,  * as noted, 64-bit support appeared in Linux after TPACKET_V2 support  * did.)  */
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
define|#
directive|define
name|ISA_64_BIT
value|"x86_64"
elif|#
directive|elif
name|defined
argument_list|(
name|__ppc__
argument_list|)
define|#
directive|define
name|ISA_64_BIT
value|"ppc64"
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc__
argument_list|)
define|#
directive|define
name|ISA_64_BIT
value|"sparc64"
elif|#
directive|elif
name|defined
argument_list|(
name|__s390__
argument_list|)
define|#
directive|define
name|ISA_64_BIT
value|"s390x"
elif|#
directive|elif
name|defined
argument_list|(
name|__mips__
argument_list|)
define|#
directive|define
name|ISA_64_BIT
value|"mips64"
elif|#
directive|elif
name|defined
argument_list|(
name|__hppa__
argument_list|)
define|#
directive|define
name|ISA_64_BIT
value|"parisc64"
endif|#
directive|endif
comment|/*  * Attempt to set the socket to version 3 of the memory-mapped header and,  * if that fails because version 3 isn't supported, attempt to fall  * back to version 2.  If version 2 isn't supported, just leave it at  * version 1.  *  * Return 1 if we succeed or if we fail because neither version 2 nor 3 is  * supported; return -1 on any other error, and set handle->errbuf.  */
specifier|static
name|int
name|prepare_tpacket_socket
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TPACKET2
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TPACKET3
argument_list|)
name|int
name|ret
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
comment|/* 	 * Try setting the version to TPACKET_V3. 	 * 	 * The only mode in which buffering is done on PF_PACKET 	 * sockets, so that packets might not be delivered 	 * immediately, is TPACKET_V3 mode. 	 * 	 * The buffering cannot be disabled in that mode, so 	 * if the user has requested immediate mode, we don't 	 * use TPACKET_V3. 	 */
if|if
condition|(
operator|!
name|handle
operator|->
name|opt
operator|.
name|immediate
condition|)
block|{
name|ret
operator|=
name|init_tpacket
argument_list|(
name|handle
argument_list|,
name|TPACKET_V3
argument_list|,
literal|"TPACKET_V3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Success. 			 */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * We failed for some reason other than "the 			 * kernel doesn't support TPACKET_V3". 			 */
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TPACKET3 */
ifdef|#
directive|ifdef
name|HAVE_TPACKET2
comment|/* 	 * Try setting the version to TPACKET_V2. 	 */
name|ret
operator|=
name|init_tpacket
argument_list|(
name|handle
argument_list|,
name|TPACKET_V2
argument_list|,
literal|"TPACKET_V2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Success. 		 */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * We failed for some reason other than "the 		 * kernel doesn't support TPACKET_V2". 		 */
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_TPACKET2 */
comment|/* 	 * OK, we're using TPACKET_V1, as that's all the kernel supports. 	 */
name|handlep
operator|->
name|tp_version
operator|=
name|TPACKET_V1
expr_stmt|;
name|handlep
operator|->
name|tp_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tpacket_hdr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISA_64_BIT
comment|/* 	 * 32-bit userspace + 64-bit kernel + TPACKET_V1 are not compatible with 	 * each other due to platform-dependent data type size differences. 	 * 	 * If we have a 32-bit userland and a 64-bit kernel, use an 	 * internally-defined TPACKET_V1_64, with which we use a 64-bit 	 * version of the data structures. 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|==
literal|4
condition|)
block|{
comment|/* 		 * This is 32-bit code. 		 */
name|struct
name|utsname
name|utsname
decl_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Failed. 			 */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"uname failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|utsname
operator|.
name|machine
argument_list|,
name|ISA_64_BIT
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * uname() tells us the machine is 64-bit, 			 * so we presumably have a 64-bit kernel. 			 * 			 * XXX - this presumes that uname() won't lie 			 * in 32-bit code and claim that the machine 			 * has the 32-bit version of the ISA. 			 */
name|handlep
operator|->
name|tp_version
operator|=
name|TPACKET_V1_64
expr_stmt|;
name|handlep
operator|->
name|tp_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tpacket_hdr_64
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
comment|/*  * Attempt to set up memory-mapped access.  *  * On success, returns 1, and sets *status to 0 if there are no warnings  * or to a PCAP_WARNING_ code if there is a warning.  *  * On failure due to lack of support for memory-mapped capture, returns  * 0.  *  * On error, returns -1, and sets *status to the appropriate error code;  * if that is PCAP_ERROR, sets handle->errbuf to the appropriate message.  */
specifier|static
name|int
name|create_ring
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|frames_per_block
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
comment|/* 	 * For sockets using TPACKET_V1 or TPACKET_V2, the extra 	 * stuff at the end of a struct tpacket_req3 will be 	 * ignored, so this is OK even for those sockets. 	 */
name|struct
name|tpacket_req3
name|req
decl_stmt|;
else|#
directive|else
name|struct
name|tpacket_req
name|req
decl_stmt|;
endif|#
directive|endif
name|socklen_t
name|len
decl_stmt|;
name|unsigned
name|int
name|sk_type
decl_stmt|,
name|tp_reserve
decl_stmt|,
name|maclen
decl_stmt|,
name|tp_hdrlen
decl_stmt|,
name|netoff
decl_stmt|,
name|macoff
decl_stmt|;
name|unsigned
name|int
name|frame_size
decl_stmt|;
comment|/* 	 * Start out assuming no warnings or errors. 	 */
operator|*
name|status
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|handlep
operator|->
name|tp_version
condition|)
block|{
case|case
name|TPACKET_V1
case|:
case|case
name|TPACKET_V1_64
case|:
ifdef|#
directive|ifdef
name|HAVE_TPACKET2
case|case
name|TPACKET_V2
case|:
endif|#
directive|endif
comment|/* Note that with large snapshot length (say 64K, which is 		 * the default for recent versions of tcpdump, the value that 		 * "-s 0" has given for a long time with tcpdump, and the 		 * default in Wireshark/TShark/dumpcap), if we use the snapshot 		 * length to calculate the frame length, only a few frames 		 * will be available in the ring even with pretty 		 * large ring size (and a lot of memory will be unused). 		 * 		 * Ideally, we should choose a frame length based on the 		 * minimum of the specified snapshot length and the maximum 		 * packet size.  That's not as easy as it sounds; consider, 		 * for example, an 802.11 interface in monitor mode, where 		 * the frame would include a radiotap header, where the 		 * maximum radiotap header length is device-dependent. 		 * 		 * So, for now, we just do this for Ethernet devices, where 		 * there's no metadata header, and the link-layer header is 		 * fixed length.  We can get the maximum packet size by 		 * adding 18, the Ethernet header length plus the CRC length 		 * (just in case we happen to get the CRC in the packet), to 		 * the MTU of the interface; we fetch the MTU in the hopes 		 * that it reflects support for jumbo frames.  (Even if the 		 * interface is just being used for passive snooping, the 		 * driver might set the size of buffers in the receive ring 		 * based on the MTU, so that the MTU limits the maximum size 		 * of packets that we can receive.) 		 * 		 * We don't do that if segmentation/fragmentation or receive 		 * offload are enabled, so we don't get rudely surprised by 		 * "packets" bigger than the MTU. */
name|frame_size
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
name|DLT_EN10MB
condition|)
block|{
name|int
name|mtu
decl_stmt|;
name|int
name|offload
decl_stmt|;
name|offload
operator|=
name|iface_get_offload
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|offload
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|offload
condition|)
block|{
name|mtu
operator|=
name|iface_get_mtu
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|device
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|frame_size
operator|>
operator|(
name|unsigned
name|int
operator|)
name|mtu
operator|+
literal|18
condition|)
name|frame_size
operator|=
operator|(
name|unsigned
name|int
operator|)
name|mtu
operator|+
literal|18
expr_stmt|;
block|}
block|}
comment|/* NOTE: calculus matching those in tpacket_rcv() 		 * in linux-2.6/net/packet/af_packet.c 		 */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sk_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TYPE
argument_list|,
operator|&
name|sk_type
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|PACKET_RESERVE
name|len
operator|=
sizeof|sizeof
argument_list|(
name|tp_reserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_RESERVE
argument_list|,
operator|&
name|tp_reserve
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOPROTOOPT
condition|)
block|{
comment|/* 				 * ENOPROTOOPT means "kernel doesn't support 				 * PACKET_RESERVE", in which case we fall back 				 * as best we can. 				 */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|tp_reserve
operator|=
literal|0
expr_stmt|;
comment|/* older kernel, reserve not supported */
block|}
else|#
directive|else
name|tp_reserve
operator|=
literal|0
expr_stmt|;
comment|/* older kernel, reserve not supported */
endif|#
directive|endif
name|maclen
operator|=
operator|(
name|sk_type
operator|==
name|SOCK_DGRAM
operator|)
condition|?
literal|0
else|:
name|MAX_LINKHEADER_SIZE
expr_stmt|;
comment|/* XXX: in the kernel maclen is calculated from 			 * LL_ALLOCATED_SPACE(dev) and vnet_hdr.hdr_len 			 * in:  packet_snd()           in linux-2.6/net/packet/af_packet.c 			 * then packet_alloc_skb()     in linux-2.6/net/packet/af_packet.c 			 * then sock_alloc_send_pskb() in linux-2.6/net/core/sock.c 			 * but I see no way to get those sizes in userspace, 			 * like for instance with an ifreq ioctl(); 			 * the best thing I've found so far is MAX_HEADER in 			 * the kernel part of linux-2.6/include/linux/netdevice.h 			 * which goes up to 128+48=176; since pcap-linux.c 			 * defines a MAX_LINKHEADER_SIZE of 256 which is 			 * greater than that, let's use it.. maybe is it even 			 * large enough to directly replace macoff.. 			 */
name|tp_hdrlen
operator|=
name|TPACKET_ALIGN
argument_list|(
name|handlep
operator|->
name|tp_hdrlen
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ll
argument_list|)
expr_stmt|;
name|netoff
operator|=
name|TPACKET_ALIGN
argument_list|(
name|tp_hdrlen
operator|+
operator|(
name|maclen
operator|<
literal|16
condition|?
literal|16
else|:
name|maclen
operator|)
argument_list|)
operator|+
name|tp_reserve
expr_stmt|;
comment|/* NOTE: AFAICS tp_reserve may break the TPACKET_ALIGN 			 * of netoff, which contradicts 			 * linux-2.6/Documentation/networking/packet_mmap.txt 			 * documenting that: 			 * "- Gap, chosen so that packet data (Start+tp_net) 			 * aligns to TPACKET_ALIGNMENT=16" 			 */
comment|/* NOTE: in linux-2.6/include/linux/skbuff.h: 			 * "CPUs often take a performance hit 			 *  when accessing unaligned memory locations" 			 */
name|macoff
operator|=
name|netoff
operator|-
name|maclen
expr_stmt|;
name|req
operator|.
name|tp_frame_size
operator|=
name|TPACKET_ALIGN
argument_list|(
name|macoff
operator|+
name|frame_size
argument_list|)
expr_stmt|;
name|req
operator|.
name|tp_frame_nr
operator|=
name|handle
operator|->
name|opt
operator|.
name|buffer_size
operator|/
name|req
operator|.
name|tp_frame_size
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
case|case
name|TPACKET_V3
case|:
comment|/* The "frames" for this are actually buffers that 		 * contain multiple variable-sized frames. 		 * 		 * We pick a "frame" size of 128K to leave enough 		 * room for at least one reasonably-sized packet 		 * in the "frame". */
name|req
operator|.
name|tp_frame_size
operator|=
name|MAXIMUM_SNAPLEN
expr_stmt|;
name|req
operator|.
name|tp_frame_nr
operator|=
name|handle
operator|->
name|opt
operator|.
name|buffer_size
operator|/
name|req
operator|.
name|tp_frame_size
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Internal error: unknown TPACKET_ value %u"
argument_list|,
name|handlep
operator|->
name|tp_version
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* compute the minumum block size that will handle this frame. 	 * The block has to be page size aligned. 	 * The max block size allowed by the kernel is arch-dependent and 	 * it's not explicitly checked here. */
name|req
operator|.
name|tp_block_size
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
while|while
condition|(
name|req
operator|.
name|tp_block_size
operator|<
name|req
operator|.
name|tp_frame_size
condition|)
name|req
operator|.
name|tp_block_size
operator|<<=
literal|1
expr_stmt|;
name|frames_per_block
operator|=
name|req
operator|.
name|tp_block_size
operator|/
name|req
operator|.
name|tp_frame_size
expr_stmt|;
comment|/* 	 * PACKET_TIMESTAMP was added after linux/net_tstamp.h was, 	 * so we check for PACKET_TIMESTAMP.  We check for 	 * linux/net_tstamp.h just in case a system somehow has 	 * PACKET_TIMESTAMP but not linux/net_tstamp.h; that might 	 * be unnecessary. 	 * 	 * SIOCSHWTSTAMP was introduced in the patch that introduced 	 * linux/net_tstamp.h, so we don't bother checking whether 	 * SIOCSHWTSTAMP is defined (if your Linux system has 	 * linux/net_tstamp.h but doesn't define SIOCSHWTSTAMP, your 	 * Linux system is badly broken). 	 */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LINUX_NET_TSTAMP_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|PACKET_TIMESTAMP
argument_list|)
comment|/* 	 * If we were told to do so, ask the kernel and the driver 	 * to use hardware timestamps. 	 * 	 * Hardware timestamps are only supported with mmapped 	 * captures. 	 */
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|tstamp_type
operator|==
name|PCAP_TSTAMP_ADAPTER
operator|||
name|handle
operator|->
name|opt
operator|.
name|tstamp_type
operator|==
name|PCAP_TSTAMP_ADAPTER_UNSYNCED
condition|)
block|{
name|struct
name|hwtstamp_config
name|hwconfig
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|timesource
decl_stmt|;
comment|/* 		 * Ask for hardware time stamps on all packets, 		 * including transmitted packets. 		 */
name|memset
argument_list|(
operator|&
name|hwconfig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hwconfig
argument_list|)
argument_list|)
expr_stmt|;
name|hwconfig
operator|.
name|tx_type
operator|=
name|HWTSTAMP_TX_ON
expr_stmt|;
name|hwconfig
operator|.
name|rx_filter
operator|=
name|HWTSTAMP_FILTER_ALL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|ifr
operator|.
name|ifr_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|hwconfig
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSHWTSTAMP
argument_list|,
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EPERM
case|:
comment|/* 				 * Treat this as an error, as the 				 * user should try to run this 				 * with the appropriate privileges - 				 * and, if they can't, shouldn't 				 * try requesting hardware time stamps. 				 */
operator|*
name|status
operator|=
name|PCAP_ERROR_PERM_DENIED
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|EOPNOTSUPP
case|:
case|case
name|ERANGE
case|:
comment|/* 				 * Treat this as a warning, as the 				 * only way to fix the warning is to 				 * get an adapter that supports hardware 				 * time stamps for *all* packets. 				 * (ERANGE means "we support hardware 				 * time stamps, but for packets matching 				 * that particular filter", so it means 				 * "we don't support hardware time stamps 				 * for all incoming packets" here.) 				 * 				 * We'll just fall back on the standard 				 * host time stamps. 				 */
operator|*
name|status
operator|=
name|PCAP_WARNING_TSTAMP_TYPE_NOTSUP
expr_stmt|;
break|break;
default|default:
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCSHWTSTAMP failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * Well, that worked.  Now specify the type of 			 * hardware time stamp we want for this 			 * socket. 			 */
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|tstamp_type
operator|==
name|PCAP_TSTAMP_ADAPTER
condition|)
block|{
comment|/* 				 * Hardware timestamp, synchronized 				 * with the system clock. 				 */
name|timesource
operator|=
name|SOF_TIMESTAMPING_SYS_HARDWARE
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * PCAP_TSTAMP_ADAPTER_UNSYNCED - hardware 				 * timestamp, not synchronized with the 				 * system clock. 				 */
name|timesource
operator|=
name|SOF_TIMESTAMPING_RAW_HARDWARE
expr_stmt|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_TIMESTAMP
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|timesource
argument_list|,
sizeof|sizeof
argument_list|(
name|timesource
argument_list|)
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't set PACKET_TIMESTAMP: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_LINUX_NET_TSTAMP_H&& PACKET_TIMESTAMP */
comment|/* ask the kernel to create the ring */
name|retry
label|:
name|req
operator|.
name|tp_block_nr
operator|=
name|req
operator|.
name|tp_frame_nr
operator|/
name|frames_per_block
expr_stmt|;
comment|/* req.tp_frame_nr is requested to match frames_per_block*req.tp_block_nr */
name|req
operator|.
name|tp_frame_nr
operator|=
name|req
operator|.
name|tp_block_nr
operator|*
name|frames_per_block
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
comment|/* timeout value to retire block - use the configured buffering timeout, or default if<0. */
name|req
operator|.
name|tp_retire_blk_tov
operator|=
operator|(
name|handlep
operator|->
name|timeout
operator|>=
literal|0
operator|)
condition|?
name|handlep
operator|->
name|timeout
else|:
literal|0
expr_stmt|;
comment|/* private data not used */
name|req
operator|.
name|tp_sizeof_priv
operator|=
literal|0
expr_stmt|;
comment|/* Rx ring - feature request bits - none (rxhash will not be filled) */
name|req
operator|.
name|tp_feature_req_word
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_RX_RING
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|errno
operator|==
name|ENOMEM
operator|)
operator|&&
operator|(
name|req
operator|.
name|tp_block_nr
operator|>
literal|1
operator|)
condition|)
block|{
comment|/* 			 * Memory failure; try to reduce the requested ring 			 * size. 			 * 			 * We used to reduce this by half -- do 5% instead. 			 * That may result in more iterations and a longer 			 * startup, but the user will be much happier with 			 * the resulting buffer size. 			 */
if|if
condition|(
name|req
operator|.
name|tp_frame_nr
operator|<
literal|20
condition|)
name|req
operator|.
name|tp_frame_nr
operator|-=
literal|1
expr_stmt|;
else|else
name|req
operator|.
name|tp_frame_nr
operator|-=
name|req
operator|.
name|tp_frame_nr
operator|/
literal|20
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENOPROTOOPT
condition|)
block|{
comment|/* 			 * We don't have ring buffer support in this kernel. 			 */
return|return
literal|0
return|;
block|}
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't create rx ring on packet socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* memory map the rx ring */
name|handlep
operator|->
name|mmapbuflen
operator|=
name|req
operator|.
name|tp_block_nr
operator|*
name|req
operator|.
name|tp_block_size
expr_stmt|;
name|handlep
operator|->
name|mmapbuf
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|handlep
operator|->
name|mmapbuflen
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|handle
operator|->
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|mmapbuf
operator|==
name|MAP_FAILED
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't mmap rx ring: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear the allocated ring on error*/
name|destroy_ring
argument_list|(
name|handle
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* allocate a ring for each frame header pointer*/
name|handle
operator|->
name|cc
operator|=
name|req
operator|.
name|tp_frame_nr
expr_stmt|;
name|handle
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|handle
operator|->
name|cc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|thdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
operator|->
name|buffer
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't allocate ring of frame headers: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_ring
argument_list|(
name|handle
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* fill the header ring with proper frame ptr*/
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|.
name|tp_block_nr
condition|;
operator|++
name|i
control|)
block|{
name|void
modifier|*
name|base
init|=
operator|&
name|handlep
operator|->
name|mmapbuf
index|[
name|i
operator|*
name|req
operator|.
name|tp_block_size
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|frames_per_block
condition|;
operator|++
name|j
operator|,
operator|++
name|handle
operator|->
name|offset
control|)
block|{
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
operator|=
name|base
expr_stmt|;
name|base
operator|+=
name|req
operator|.
name|tp_frame_size
expr_stmt|;
block|}
block|}
name|handle
operator|->
name|bufsize
operator|=
name|req
operator|.
name|tp_frame_size
expr_stmt|;
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* free all ring related resources*/
specifier|static
name|void
name|destroy_ring
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
comment|/* tell the kernel to destroy the ring*/
name|struct
name|tpacket_req
name|req
decl_stmt|;
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do not test for setsockopt failure, as we can't recover from any error */
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_PACKET
argument_list|,
name|PACKET_RX_RING
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if ring is mapped, unmap it*/
if|if
condition|(
name|handlep
operator|->
name|mmapbuf
condition|)
block|{
comment|/* do not test for mmap failure, as we can't recover from any error */
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|handlep
operator|->
name|mmapbuf
argument_list|,
name|handlep
operator|->
name|mmapbuflen
argument_list|)
expr_stmt|;
name|handlep
operator|->
name|mmapbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*  * Special one-shot callback, used for pcap_next() and pcap_next_ex(),  * for Linux mmapped capture.  *  * The problem is that pcap_next() and pcap_next_ex() expect the packet  * data handed to the callback to be valid after the callback returns,  * but pcap_read_linux_mmap() has to release that packet as soon as  * the callback returns (otherwise, the kernel thinks there's still  * at least one unprocessed packet available in the ring, so a select()  * will immediately return indicating that there's data to process), so,  * in the callback, we have to make a copy of the packet.  *  * Yes, this means that, if the capture is using the ring buffer, using  * pcap_next() or pcap_next_ex() requires more copies than using  * pcap_loop() or pcap_dispatch().  If that bothers you, don't use  * pcap_next() or pcap_next_ex().  */
specifier|static
name|void
name|pcap_oneshot_mmap
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|bytes
parameter_list|)
block|{
name|struct
name|oneshot_userdata
modifier|*
name|sp
init|=
operator|(
expr|struct
name|oneshot_userdata
operator|*
operator|)
name|user
decl_stmt|;
name|pcap_t
modifier|*
name|handle
init|=
name|sp
operator|->
name|pd
decl_stmt|;
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
operator|*
name|sp
operator|->
name|hdr
operator|=
operator|*
name|h
expr_stmt|;
name|memcpy
argument_list|(
name|handlep
operator|->
name|oneshot_buffer
argument_list|,
name|bytes
argument_list|,
name|h
operator|->
name|caplen
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|->
name|pkt
operator|=
name|handlep
operator|->
name|oneshot_buffer
expr_stmt|;
block|}
specifier|static
name|void
name|pcap_cleanup_linux_mmap
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|destroy_ring
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|oneshot_buffer
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|handlep
operator|->
name|oneshot_buffer
argument_list|)
expr_stmt|;
name|handlep
operator|->
name|oneshot_buffer
operator|=
name|NULL
expr_stmt|;
block|}
name|pcap_cleanup_linux
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|pcap_getnonblock_mmap
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|p
operator|->
name|priv
decl_stmt|;
comment|/* use negative value of timeout to indicate non blocking ops */
return|return
operator|(
name|handlep
operator|->
name|timeout
operator|<
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|pcap_setnonblock_mmap
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|p
operator|->
name|priv
decl_stmt|;
comment|/* 	 * Set the file descriptor to non-blocking mode, as we use 	 * it for sending packets. 	 */
if|if
condition|(
name|pcap_setnonblock_fd
argument_list|(
name|p
argument_list|,
name|nonblock
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * Map each value to their corresponding negation to 	 * preserve the timeout value provided with pcap_set_timeout. 	 */
if|if
condition|(
name|nonblock
condition|)
block|{
if|if
condition|(
name|handlep
operator|->
name|timeout
operator|>=
literal|0
condition|)
block|{
comment|/* 			 * Indicate that we're switching to 			 * non-blocking mode. 			 */
name|handlep
operator|->
name|timeout
operator|=
operator|~
name|handlep
operator|->
name|timeout
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|handlep
operator|->
name|timeout
operator|<
literal|0
condition|)
block|{
name|handlep
operator|->
name|timeout
operator|=
operator|~
name|handlep
operator|->
name|timeout
expr_stmt|;
block|}
block|}
comment|/* Update the timeout to use in poll(). */
name|set_poll_timeout
argument_list|(
name|handlep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Get the status field of the ring buffer frame at a specified offset.  */
specifier|static
specifier|inline
name|int
name|pcap_get_ring_frame_status
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|union
name|thdr
name|h
decl_stmt|;
name|h
operator|.
name|raw
operator|=
name|RING_GET_FRAME_AT
argument_list|(
name|handle
argument_list|,
name|offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|handlep
operator|->
name|tp_version
condition|)
block|{
case|case
name|TPACKET_V1
case|:
return|return
operator|(
name|h
operator|.
name|h1
operator|->
name|tp_status
operator|)
return|;
break|break;
case|case
name|TPACKET_V1_64
case|:
return|return
operator|(
name|h
operator|.
name|h1_64
operator|->
name|tp_status
operator|)
return|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_TPACKET2
case|case
name|TPACKET_V2
case|:
return|return
operator|(
name|h
operator|.
name|h2
operator|->
name|tp_status
operator|)
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
case|case
name|TPACKET_V3
case|:
return|return
operator|(
name|h
operator|.
name|h3
operator|->
name|hdr
operator|.
name|bh1
operator|.
name|block_status
operator|)
return|;
break|break;
endif|#
directive|endif
block|}
comment|/* This should not happen. */
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|POLLRDHUP
define|#
directive|define
name|POLLRDHUP
value|0
endif|#
directive|endif
comment|/*  * Block waiting for frames to be available.  */
specifier|static
name|int
name|pcap_wait_for_frames_mmap
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|pollfd
name|pollinfo
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|pollinfo
operator|.
name|fd
operator|=
name|handle
operator|->
name|fd
expr_stmt|;
name|pollinfo
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
do|do
block|{
comment|/* 		 * Yes, we do this even in non-blocking mode, as it's 		 * the only way to get error indications from a 		 * tpacket socket. 		 * 		 * The timeout is 0 in non-blocking mode, so poll() 		 * returns immediately. 		 */
name|ret
operator|=
name|poll
argument_list|(
operator|&
name|pollinfo
argument_list|,
literal|1
argument_list|,
name|handlep
operator|->
name|poll_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't poll on packet socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|>
literal|0
operator|&&
operator|(
name|pollinfo
operator|.
name|revents
operator|&
operator|(
name|POLLHUP
operator||
name|POLLRDHUP
operator||
name|POLLERR
operator||
name|POLLNVAL
operator|)
operator|)
condition|)
block|{
comment|/* 			 * There's some indication other than 			 * "you can read on this descriptor" on 			 * the descriptor. 			 */
if|if
condition|(
name|pollinfo
operator|.
name|revents
operator|&
operator|(
name|POLLHUP
operator||
name|POLLRDHUP
operator|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Hangup on packet socket"
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
if|if
condition|(
name|pollinfo
operator|.
name|revents
operator|&
name|POLLERR
condition|)
block|{
comment|/* 				 * A recv() will give us the actual error code. 				 * 				 * XXX - make the socket non-blocking? 				 */
if|if
condition|(
name|recv
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|,
name|MSG_PEEK
argument_list|)
operator|!=
operator|-
literal|1
condition|)
continue|continue;
comment|/* what, no error? */
if|if
condition|(
name|errno
operator|==
name|ENETDOWN
condition|)
block|{
comment|/* 					 * The device on which we're 					 * capturing went away. 					 * 					 * XXX - we should really return 					 * PCAP_ERROR_IFACE_NOT_UP, but 					 * pcap_dispatch() etc. aren't 					 * defined to return that. 					 */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The interface went down"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error condition on packet socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|PCAP_ERROR
return|;
block|}
if|if
condition|(
name|pollinfo
operator|.
name|revents
operator|&
name|POLLNVAL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Invalid polling request on packet socket"
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
comment|/* check for break loop condition on interrupted syscall*/
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
name|PCAP_ERROR_BREAK
return|;
block|}
block|}
do|while
condition|(
name|ret
operator|<
literal|0
condition|)
do|;
return|return
literal|0
return|;
block|}
comment|/* handle a single memory mapped packet */
specifier|static
name|int
name|pcap_handle_packet_mmap
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|,
name|unsigned
name|char
modifier|*
name|frame
parameter_list|,
name|unsigned
name|int
name|tp_len
parameter_list|,
name|unsigned
name|int
name|tp_mac
parameter_list|,
name|unsigned
name|int
name|tp_snaplen
parameter_list|,
name|unsigned
name|int
name|tp_sec
parameter_list|,
name|unsigned
name|int
name|tp_usec
parameter_list|,
name|int
name|tp_vlan_tci_valid
parameter_list|,
name|__u16
name|tp_vlan_tci
parameter_list|,
name|__u16
name|tp_vlan_tpid
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|struct
name|sockaddr_ll
modifier|*
name|sll
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcaphdr
decl_stmt|;
comment|/* perform sanity check on internal offset. */
if|if
condition|(
name|tp_mac
operator|+
name|tp_snaplen
operator|>
name|handle
operator|->
name|bufsize
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"corrupted frame on kernel ring mac "
literal|"offset %u + caplen %u> frame len %d"
argument_list|,
name|tp_mac
argument_list|,
name|tp_snaplen
argument_list|,
name|handle
operator|->
name|bufsize
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* run filter on received packet 	 * If the kernel filtering is enabled we need to run the 	 * filter until all the frames present into the ring 	 * at filter creation time are processed. 	 * In this case, blocks_to_filter_in_userland is used 	 * as a counter for the packet we need to filter. 	 * Note: alternatively it could be possible to stop applying 	 * the filter when the ring became empty, but it can possibly 	 * happen a lot later... */
name|bp
operator|=
name|frame
operator|+
name|tp_mac
expr_stmt|;
comment|/* if required build in place the sll header*/
name|sll
operator|=
operator|(
name|void
operator|*
operator|)
name|frame
operator|+
name|TPACKET_ALIGN
argument_list|(
name|handlep
operator|->
name|tp_hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|cooked
condition|)
block|{
name|struct
name|sll_header
modifier|*
name|hdrp
decl_stmt|;
comment|/* 		 * The kernel should have left us with enough 		 * space for an sll header; back up the packet 		 * data pointer into that space, as that'll be 		 * the beginning of the packet we pass to the 		 * callback. 		 */
name|bp
operator|-=
name|SLL_HDR_LEN
expr_stmt|;
comment|/* 		 * Let's make sure that's past the end of 		 * the tpacket header, i.e.>= 		 * ((u_char *)thdr + TPACKET_HDRLEN), so we 		 * don't step on the header when we construct 		 * the sll header. 		 */
if|if
condition|(
name|bp
operator|<
operator|(
name|u_char
operator|*
operator|)
name|frame
operator|+
name|TPACKET_ALIGN
argument_list|(
name|handlep
operator|->
name|tp_hdrlen
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ll
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"cooked-mode frame doesn't have room for sll header"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 		 * OK, that worked; construct the sll header. 		 */
name|hdrp
operator|=
operator|(
expr|struct
name|sll_header
operator|*
operator|)
name|bp
expr_stmt|;
name|hdrp
operator|->
name|sll_pkttype
operator|=
name|map_packet_type_to_sll_type
argument_list|(
name|sll
operator|->
name|sll_pkttype
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_hatype
operator|=
name|htons
argument_list|(
name|sll
operator|->
name|sll_hatype
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_halen
operator|=
name|htons
argument_list|(
name|sll
operator|->
name|sll_halen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hdrp
operator|->
name|sll_addr
argument_list|,
name|sll
operator|->
name|sll_addr
argument_list|,
name|SLL_ADDRLEN
argument_list|)
expr_stmt|;
name|hdrp
operator|->
name|sll_protocol
operator|=
name|sll
operator|->
name|sll_protocol
expr_stmt|;
block|}
if|if
condition|(
name|handlep
operator|->
name|filter_in_userland
operator|&&
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
condition|)
block|{
name|struct
name|bpf_aux_data
name|aux_data
decl_stmt|;
name|aux_data
operator|.
name|vlan_tag
operator|=
name|tp_vlan_tci
operator|&
literal|0x0fff
expr_stmt|;
name|aux_data
operator|.
name|vlan_tag_present
operator|=
name|tp_vlan_tci_valid
expr_stmt|;
if|if
condition|(
name|bpf_filter_with_aux_data
argument_list|(
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|bp
argument_list|,
name|tp_len
argument_list|,
name|tp_snaplen
argument_list|,
operator|&
name|aux_data
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|linux_check_direction
argument_list|(
name|handle
argument_list|,
name|sll
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* get required packet info from ring header */
name|pcaphdr
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|tp_sec
expr_stmt|;
name|pcaphdr
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|tp_usec
expr_stmt|;
name|pcaphdr
operator|.
name|caplen
operator|=
name|tp_snaplen
expr_stmt|;
name|pcaphdr
operator|.
name|len
operator|=
name|tp_len
expr_stmt|;
comment|/* if required build in place the sll header*/
if|if
condition|(
name|handlep
operator|->
name|cooked
condition|)
block|{
comment|/* update packet len */
name|pcaphdr
operator|.
name|caplen
operator|+=
name|SLL_HDR_LEN
expr_stmt|;
name|pcaphdr
operator|.
name|len
operator|+=
name|SLL_HDR_LEN
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TPACKET2
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TPACKET3
argument_list|)
if|if
condition|(
name|tp_vlan_tci_valid
operator|&&
name|handlep
operator|->
name|vlan_offset
operator|!=
operator|-
literal|1
operator|&&
name|tp_snaplen
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|handlep
operator|->
name|vlan_offset
condition|)
block|{
name|struct
name|vlan_tag
modifier|*
name|tag
decl_stmt|;
comment|/* 		 * Move everything in the header, except the type field, 		 * down VLAN_TAG_LEN bytes, to allow us to insert the 		 * VLAN tag between that stuff and the type field. 		 */
name|bp
operator|-=
name|VLAN_TAG_LEN
expr_stmt|;
name|memmove
argument_list|(
name|bp
argument_list|,
name|bp
operator|+
name|VLAN_TAG_LEN
argument_list|,
name|handlep
operator|->
name|vlan_offset
argument_list|)
expr_stmt|;
comment|/* 		 * Now insert the tag. 		 */
name|tag
operator|=
operator|(
expr|struct
name|vlan_tag
operator|*
operator|)
operator|(
name|bp
operator|+
name|handlep
operator|->
name|vlan_offset
operator|)
expr_stmt|;
name|tag
operator|->
name|vlan_tpid
operator|=
name|htons
argument_list|(
name|tp_vlan_tpid
argument_list|)
expr_stmt|;
name|tag
operator|->
name|vlan_tci
operator|=
name|htons
argument_list|(
name|tp_vlan_tci
argument_list|)
expr_stmt|;
comment|/* 		 * Add the tag to the packet lengths. 		 */
name|pcaphdr
operator|.
name|caplen
operator|+=
name|VLAN_TAG_LEN
expr_stmt|;
name|pcaphdr
operator|.
name|len
operator|+=
name|VLAN_TAG_LEN
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * The only way to tell the kernel to cut off the 	 * packet at a snapshot length is with a filter program; 	 * if there's no filter program, the kernel won't cut 	 * the packet off. 	 * 	 * Trim the snapshot length to be no longer than the 	 * specified snapshot length. 	 */
if|if
condition|(
name|pcaphdr
operator|.
name|caplen
operator|>
operator|(
name|bpf_u_int32
operator|)
name|handle
operator|->
name|snapshot
condition|)
name|pcaphdr
operator|.
name|caplen
operator|=
name|handle
operator|->
name|snapshot
expr_stmt|;
comment|/* pass the packet to the user */
name|callback
argument_list|(
name|user
argument_list|,
operator|&
name|pcaphdr
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|static
name|int
name|pcap_read_linux_mmap_v1
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|union
name|thdr
name|h
decl_stmt|;
name|int
name|pkts
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* wait for frames availability.*/
name|h
operator|.
name|raw
operator|=
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|h1
operator|->
name|tp_status
operator|==
name|TP_STATUS_KERNEL
condition|)
block|{
comment|/* 		 * The current frame is owned by the kernel; wait for 		 * a frame to be handed to us. 		 */
name|ret
operator|=
name|pcap_wait_for_frames_mmap
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
comment|/* non-positive values of max_packets are used to require all 	 * packets currently available in the ring */
while|while
condition|(
operator|(
name|pkts
operator|<
name|max_packets
operator|)
operator|||
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|max_packets
argument_list|)
condition|)
block|{
comment|/* 		 * Get the current ring buffer frame, and break if 		 * it's still owned by the kernel. 		 */
name|h
operator|.
name|raw
operator|=
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|h1
operator|->
name|tp_status
operator|==
name|TP_STATUS_KERNEL
condition|)
break|break;
name|ret
operator|=
name|pcap_handle_packet_mmap
argument_list|(
name|handle
argument_list|,
name|callback
argument_list|,
name|user
argument_list|,
name|h
operator|.
name|raw
argument_list|,
name|h
operator|.
name|h1
operator|->
name|tp_len
argument_list|,
name|h
operator|.
name|h1
operator|->
name|tp_mac
argument_list|,
name|h
operator|.
name|h1
operator|->
name|tp_snaplen
argument_list|,
name|h
operator|.
name|h1
operator|->
name|tp_sec
argument_list|,
name|h
operator|.
name|h1
operator|->
name|tp_usec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|pkts
operator|++
expr_stmt|;
name|handlep
operator|->
name|packets_read
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|/* 		 * Hand this block back to the kernel, and, if we're 		 * counting blocks that need to be filtered in userland 		 * after having been filtered by the kernel, count 		 * the one we've just processed. 		 */
name|h
operator|.
name|h1
operator|->
name|tp_status
operator|=
name|TP_STATUS_KERNEL
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|>
literal|0
condition|)
block|{
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|--
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|==
literal|0
condition|)
block|{
comment|/* 				 * No more blocks need to be filtered 				 * in userland. 				 */
name|handlep
operator|->
name|filter_in_userland
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* next block */
if|if
condition|(
operator|++
name|handle
operator|->
name|offset
operator|>=
name|handle
operator|->
name|cc
condition|)
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* check for break loop condition*/
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
name|PCAP_ERROR_BREAK
return|;
block|}
block|}
return|return
name|pkts
return|;
block|}
specifier|static
name|int
name|pcap_read_linux_mmap_v1_64
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|union
name|thdr
name|h
decl_stmt|;
name|int
name|pkts
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* wait for frames availability.*/
name|h
operator|.
name|raw
operator|=
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|h1_64
operator|->
name|tp_status
operator|==
name|TP_STATUS_KERNEL
condition|)
block|{
comment|/* 		 * The current frame is owned by the kernel; wait for 		 * a frame to be handed to us. 		 */
name|ret
operator|=
name|pcap_wait_for_frames_mmap
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
comment|/* non-positive values of max_packets are used to require all 	 * packets currently available in the ring */
while|while
condition|(
operator|(
name|pkts
operator|<
name|max_packets
operator|)
operator|||
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|max_packets
argument_list|)
condition|)
block|{
comment|/* 		 * Get the current ring buffer frame, and break if 		 * it's still owned by the kernel. 		 */
name|h
operator|.
name|raw
operator|=
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|h1_64
operator|->
name|tp_status
operator|==
name|TP_STATUS_KERNEL
condition|)
break|break;
name|ret
operator|=
name|pcap_handle_packet_mmap
argument_list|(
name|handle
argument_list|,
name|callback
argument_list|,
name|user
argument_list|,
name|h
operator|.
name|raw
argument_list|,
name|h
operator|.
name|h1_64
operator|->
name|tp_len
argument_list|,
name|h
operator|.
name|h1_64
operator|->
name|tp_mac
argument_list|,
name|h
operator|.
name|h1_64
operator|->
name|tp_snaplen
argument_list|,
name|h
operator|.
name|h1_64
operator|->
name|tp_sec
argument_list|,
name|h
operator|.
name|h1_64
operator|->
name|tp_usec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|pkts
operator|++
expr_stmt|;
name|handlep
operator|->
name|packets_read
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|/* 		 * Hand this block back to the kernel, and, if we're 		 * counting blocks that need to be filtered in userland 		 * after having been filtered by the kernel, count 		 * the one we've just processed. 		 */
name|h
operator|.
name|h1_64
operator|->
name|tp_status
operator|=
name|TP_STATUS_KERNEL
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|>
literal|0
condition|)
block|{
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|--
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|==
literal|0
condition|)
block|{
comment|/* 				 * No more blocks need to be filtered 				 * in userland. 				 */
name|handlep
operator|->
name|filter_in_userland
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* next block */
if|if
condition|(
operator|++
name|handle
operator|->
name|offset
operator|>=
name|handle
operator|->
name|cc
condition|)
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* check for break loop condition*/
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
name|PCAP_ERROR_BREAK
return|;
block|}
block|}
return|return
name|pkts
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_TPACKET2
specifier|static
name|int
name|pcap_read_linux_mmap_v2
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|union
name|thdr
name|h
decl_stmt|;
name|int
name|pkts
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* wait for frames availability.*/
name|h
operator|.
name|raw
operator|=
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|h2
operator|->
name|tp_status
operator|==
name|TP_STATUS_KERNEL
condition|)
block|{
comment|/* 		 * The current frame is owned by the kernel; wait for 		 * a frame to be handed to us. 		 */
name|ret
operator|=
name|pcap_wait_for_frames_mmap
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
comment|/* non-positive values of max_packets are used to require all 	 * packets currently available in the ring */
while|while
condition|(
operator|(
name|pkts
operator|<
name|max_packets
operator|)
operator|||
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|max_packets
argument_list|)
condition|)
block|{
comment|/* 		 * Get the current ring buffer frame, and break if 		 * it's still owned by the kernel. 		 */
name|h
operator|.
name|raw
operator|=
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|h2
operator|->
name|tp_status
operator|==
name|TP_STATUS_KERNEL
condition|)
break|break;
name|ret
operator|=
name|pcap_handle_packet_mmap
argument_list|(
name|handle
argument_list|,
name|callback
argument_list|,
name|user
argument_list|,
name|h
operator|.
name|raw
argument_list|,
name|h
operator|.
name|h2
operator|->
name|tp_len
argument_list|,
name|h
operator|.
name|h2
operator|->
name|tp_mac
argument_list|,
name|h
operator|.
name|h2
operator|->
name|tp_snaplen
argument_list|,
name|h
operator|.
name|h2
operator|->
name|tp_sec
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|tstamp_precision
operator|==
name|PCAP_TSTAMP_PRECISION_NANO
condition|?
name|h
operator|.
name|h2
operator|->
name|tp_nsec
else|:
name|h
operator|.
name|h2
operator|->
name|tp_nsec
operator|/
literal|1000
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|TP_STATUS_VLAN_VALID
argument_list|)
operator|(
name|h
operator|.
name|h2
operator|->
name|tp_vlan_tci
operator|||
operator|(
name|h
operator|.
name|h2
operator|->
name|tp_status
operator|&
name|TP_STATUS_VLAN_VALID
operator|)
operator|)
argument_list|,
else|#
directive|else
name|h
operator|.
name|h2
operator|->
name|tp_vlan_tci
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
name|h
operator|.
name|h2
operator|->
name|tp_vlan_tci
argument_list|,
name|VLAN_TPID
argument_list|(
name|h
operator|.
name|h2
argument_list|,
name|h
operator|.
name|h2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|pkts
operator|++
expr_stmt|;
name|handlep
operator|->
name|packets_read
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|/* 		 * Hand this block back to the kernel, and, if we're 		 * counting blocks that need to be filtered in userland 		 * after having been filtered by the kernel, count 		 * the one we've just processed. 		 */
name|h
operator|.
name|h2
operator|->
name|tp_status
operator|=
name|TP_STATUS_KERNEL
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|>
literal|0
condition|)
block|{
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|--
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|==
literal|0
condition|)
block|{
comment|/* 				 * No more blocks need to be filtered 				 * in userland. 				 */
name|handlep
operator|->
name|filter_in_userland
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* next block */
if|if
condition|(
operator|++
name|handle
operator|->
name|offset
operator|>=
name|handle
operator|->
name|cc
condition|)
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* check for break loop condition*/
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
name|PCAP_ERROR_BREAK
return|;
block|}
block|}
return|return
name|pkts
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_TPACKET2 */
ifdef|#
directive|ifdef
name|HAVE_TPACKET3
specifier|static
name|int
name|pcap_read_linux_mmap_v3
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|max_packets
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|union
name|thdr
name|h
decl_stmt|;
name|int
name|pkts
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|again
label|:
if|if
condition|(
name|handlep
operator|->
name|current_packet
operator|==
name|NULL
condition|)
block|{
comment|/* wait for frames availability.*/
name|h
operator|.
name|raw
operator|=
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|h3
operator|->
name|hdr
operator|.
name|bh1
operator|.
name|block_status
operator|==
name|TP_STATUS_KERNEL
condition|)
block|{
comment|/* 			 * The current frame is owned by the kernel; wait 			 * for a frame to be handed to us. 			 */
name|ret
operator|=
name|pcap_wait_for_frames_mmap
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
block|}
name|h
operator|.
name|raw
operator|=
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|h3
operator|->
name|hdr
operator|.
name|bh1
operator|.
name|block_status
operator|==
name|TP_STATUS_KERNEL
condition|)
block|{
if|if
condition|(
name|pkts
operator|==
literal|0
operator|&&
name|handlep
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* Block until we see a packet. */
goto|goto
name|again
goto|;
block|}
return|return
name|pkts
return|;
block|}
comment|/* non-positive values of max_packets are used to require all 	 * packets currently available in the ring */
while|while
condition|(
operator|(
name|pkts
operator|<
name|max_packets
operator|)
operator|||
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|max_packets
argument_list|)
condition|)
block|{
name|int
name|packets_to_read
decl_stmt|;
if|if
condition|(
name|handlep
operator|->
name|current_packet
operator|==
name|NULL
condition|)
block|{
name|h
operator|.
name|raw
operator|=
name|RING_GET_CURRENT_FRAME
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|h3
operator|->
name|hdr
operator|.
name|bh1
operator|.
name|block_status
operator|==
name|TP_STATUS_KERNEL
condition|)
break|break;
name|handlep
operator|->
name|current_packet
operator|=
name|h
operator|.
name|raw
operator|+
name|h
operator|.
name|h3
operator|->
name|hdr
operator|.
name|bh1
operator|.
name|offset_to_first_pkt
expr_stmt|;
name|handlep
operator|->
name|packets_left
operator|=
name|h
operator|.
name|h3
operator|->
name|hdr
operator|.
name|bh1
operator|.
name|num_pkts
expr_stmt|;
block|}
name|packets_to_read
operator|=
name|handlep
operator|->
name|packets_left
expr_stmt|;
if|if
condition|(
operator|!
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|max_packets
argument_list|)
operator|&&
name|packets_to_read
operator|>
operator|(
name|max_packets
operator|-
name|pkts
operator|)
condition|)
block|{
comment|/* 			 * We've been given a maximum number of packets 			 * to process, and there are more packets in 			 * this buffer than that.  Only process enough 			 * of them to get us up to that maximum. 			 */
name|packets_to_read
operator|=
name|max_packets
operator|-
name|pkts
expr_stmt|;
block|}
while|while
condition|(
name|packets_to_read
operator|--
operator|&&
operator|!
name|handle
operator|->
name|break_loop
condition|)
block|{
name|struct
name|tpacket3_hdr
modifier|*
name|tp3_hdr
init|=
operator|(
expr|struct
name|tpacket3_hdr
operator|*
operator|)
name|handlep
operator|->
name|current_packet
decl_stmt|;
name|ret
operator|=
name|pcap_handle_packet_mmap
argument_list|(
name|handle
argument_list|,
name|callback
argument_list|,
name|user
argument_list|,
name|handlep
operator|->
name|current_packet
argument_list|,
name|tp3_hdr
operator|->
name|tp_len
argument_list|,
name|tp3_hdr
operator|->
name|tp_mac
argument_list|,
name|tp3_hdr
operator|->
name|tp_snaplen
argument_list|,
name|tp3_hdr
operator|->
name|tp_sec
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|tstamp_precision
operator|==
name|PCAP_TSTAMP_PRECISION_NANO
condition|?
name|tp3_hdr
operator|->
name|tp_nsec
else|:
name|tp3_hdr
operator|->
name|tp_nsec
operator|/
literal|1000
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|TP_STATUS_VLAN_VALID
argument_list|)
operator|(
name|tp3_hdr
operator|->
name|hv1
operator|.
name|tp_vlan_tci
operator|||
operator|(
name|tp3_hdr
operator|->
name|tp_status
operator|&
name|TP_STATUS_VLAN_VALID
operator|)
operator|)
argument_list|,
else|#
directive|else
name|tp3_hdr
operator|->
name|hv1
operator|.
name|tp_vlan_tci
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
name|tp3_hdr
operator|->
name|hv1
operator|.
name|tp_vlan_tci
argument_list|,
name|VLAN_TPID
argument_list|(
name|tp3_hdr
argument_list|,
operator|&
name|tp3_hdr
operator|->
name|hv1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|pkts
operator|++
expr_stmt|;
name|handlep
operator|->
name|packets_read
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|handlep
operator|->
name|current_packet
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
name|handlep
operator|->
name|current_packet
operator|+=
name|tp3_hdr
operator|->
name|tp_next_offset
expr_stmt|;
name|handlep
operator|->
name|packets_left
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|handlep
operator|->
name|packets_left
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Hand this block back to the kernel, and, if 			 * we're counting blocks that need to be 			 * filtered in userland after having been 			 * filtered by the kernel, count the one we've 			 * just processed. 			 */
name|h
operator|.
name|h3
operator|->
name|hdr
operator|.
name|bh1
operator|.
name|block_status
operator|=
name|TP_STATUS_KERNEL
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|>
literal|0
condition|)
block|{
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|--
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|==
literal|0
condition|)
block|{
comment|/* 					 * No more blocks need to be filtered 					 * in userland. 					 */
name|handlep
operator|->
name|filter_in_userland
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* next block */
if|if
condition|(
operator|++
name|handle
operator|->
name|offset
operator|>=
name|handle
operator|->
name|cc
condition|)
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|handlep
operator|->
name|current_packet
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* check for break loop condition*/
if|if
condition|(
name|handle
operator|->
name|break_loop
condition|)
block|{
name|handle
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
name|PCAP_ERROR_BREAK
return|;
block|}
block|}
if|if
condition|(
name|pkts
operator|==
literal|0
operator|&&
name|handlep
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* Block until we see a packet. */
goto|goto
name|again
goto|;
block|}
return|return
name|pkts
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_TPACKET3 */
specifier|static
name|int
name|pcap_setfilter_linux_mmap
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|filter
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|int
name|n
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * Don't rewrite "ret" instructions; we don't need to, as 	 * we're not reading packets with recvmsg(), and we don't 	 * want to, as, by not rewriting them, the kernel can avoid 	 * copying extra data. 	 */
name|ret
operator|=
name|pcap_setfilter_linux_common
argument_list|(
name|handle
argument_list|,
name|filter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
comment|/* 	 * If we're filtering in userland, there's nothing to do; 	 * the new filter will be used for the next packet. 	 */
if|if
condition|(
name|handlep
operator|->
name|filter_in_userland
condition|)
return|return
name|ret
return|;
comment|/* 	 * We're filtering in the kernel; the packets present in 	 * all blocks currently in the ring were already filtered 	 * by the old filter, and so will need to be filtered in 	 * userland by the new filter. 	 * 	 * Get an upper bound for the number of such blocks; first, 	 * walk the ring backward and count the free blocks. 	 */
name|offset
operator|=
name|handle
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|--
name|offset
operator|<
literal|0
condition|)
name|offset
operator|=
name|handle
operator|->
name|cc
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|handle
operator|->
name|cc
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|--
name|offset
operator|<
literal|0
condition|)
name|offset
operator|=
name|handle
operator|->
name|cc
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pcap_get_ring_frame_status
argument_list|(
name|handle
argument_list|,
name|offset
argument_list|)
operator|!=
name|TP_STATUS_KERNEL
condition|)
break|break;
block|}
comment|/* 	 * If we found free blocks, decrement the count of free 	 * blocks by 1, just in case we lost a race with another 	 * thread of control that was adding a packet while 	 * we were counting and that had run the filter before 	 * we changed it. 	 * 	 * XXX - could there be more than one block added in 	 * this fashion? 	 * 	 * XXX - is there a way to avoid that race, e.g. somehow 	 * wait for all packets that passed the old filter to 	 * be added to the ring? 	 */
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|n
operator|--
expr_stmt|;
comment|/* 	 * Set the count of blocks worth of packets to filter 	 * in userland to the total number of blocks in the 	 * ring minus the number of free blocks we found, and 	 * turn on userland filtering.  (The count of blocks 	 * worth of packets to filter in userland is guaranteed 	 * not to be zero - n, above, couldn't be set to a 	 * value> handle->cc, and if it were equal to 	 * handle->cc, it wouldn't be zero, and thus would 	 * be decremented to handle->cc - 1.) 	 */
name|handlep
operator|->
name|blocks_to_filter_in_userland
operator|=
name|handle
operator|->
name|cc
operator|-
name|n
expr_stmt|;
name|handlep
operator|->
name|filter_in_userland
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_PACKET_RING */
ifdef|#
directive|ifdef
name|HAVE_PF_PACKET_SOCKETS
comment|/*  *  Return the index of the given device name. Fill ebuf and return  *  -1 on failure.  */
specifier|static
name|int
name|iface_get_id
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFINDEX
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIFINDEX: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ifr
operator|.
name|ifr_ifindex
return|;
block|}
comment|/*  *  Bind the socket associated with FD to the given device.  *  Return 1 on success, 0 if we should try a SOCK_PACKET socket,  *  or a PCAP_ERROR_ value on a hard error.  */
specifier|static
name|int
name|iface_bind
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|ifindex
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|sockaddr_ll
name|sll
decl_stmt|;
name|int
name|err
decl_stmt|;
name|socklen_t
name|errlen
init|=
sizeof|sizeof
argument_list|(
name|err
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sll
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sll
argument_list|)
argument_list|)
expr_stmt|;
name|sll
operator|.
name|sll_family
operator|=
name|AF_PACKET
expr_stmt|;
name|sll
operator|.
name|sll_ifindex
operator|=
name|ifindex
expr_stmt|;
name|sll
operator|.
name|sll_protocol
operator|=
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sll
argument_list|,
sizeof|sizeof
argument_list|(
name|sll
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENETDOWN
condition|)
block|{
comment|/* 			 * Return a "network down" indication, so that 			 * the application can report that rather than 			 * saying we had a mysterious failure and 			 * suggest that they report a problem to the 			 * libpcap developers. 			 */
return|return
name|PCAP_ERROR_IFACE_NOT_UP
return|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
comment|/* Any pending errors, e.g., network is down? */
if|if
condition|(
name|getsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|errlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|err
operator|==
name|ENETDOWN
condition|)
block|{
comment|/* 		 * Return a "network down" indication, so that 		 * the application can report that rather than 		 * saying we had a mysterious failure and 		 * suggest that they report a problem to the 		 * libpcap developers. 		 */
return|return
name|PCAP_ERROR_IFACE_NOT_UP
return|;
block|}
elseif|else
if|if
condition|(
name|err
operator|>
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
comment|/*  * Check whether the device supports the Wireless Extensions.  * Returns 1 if it does, 0 if it doesn't, PCAP_ERROR_NO_SUCH_DEVICE  * if the device doesn't even exist.  */
specifier|static
name|int
name|has_wext
parameter_list|(
name|int
name|sock_fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|iwreq
name|ireq
decl_stmt|;
if|if
condition|(
name|is_bonding_device
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* bonding device, so don't even try */
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCGIWNAME
argument_list|,
operator|&
name|ireq
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* yes */
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: SIOCGIWNAME: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENODEV
condition|)
return|return
name|PCAP_ERROR_NO_SUCH_DEVICE
return|;
return|return
literal|0
return|;
block|}
comment|/*  * Per me si va ne la citta dolente,  * Per me si va ne l'etterno dolore,  *	...  * Lasciate ogne speranza, voi ch'intrate.  *  * XXX - airmon-ng does special stuff with the Orinoco driver and the  * wlan-ng driver.  */
typedef|typedef
enum|enum
block|{
name|MONITOR_WEXT
block|,
name|MONITOR_HOSTAP
block|,
name|MONITOR_PRISM
block|,
name|MONITOR_PRISM54
block|,
name|MONITOR_ACX100
block|,
name|MONITOR_RT2500
block|,
name|MONITOR_RT2570
block|,
name|MONITOR_RT73
block|,
name|MONITOR_RTL8XXX
block|}
name|monitor_type
typedef|;
comment|/*  * Use the Wireless Extensions, if we have them, to try to turn monitor mode  * on if it's not already on.  *  * Returns 1 on success, 0 if we don't support the Wireless Extensions  * on this device, or a PCAP_ERROR_ value if we do support them but  * we weren't able to turn monitor mode on.  */
specifier|static
name|int
name|enter_rfmon_mode_wext
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|sock_fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
comment|/* 	 * XXX - at least some adapters require non-Wireless Extensions 	 * mechanisms to turn monitor mode on. 	 * 	 * Atheros cards might require that a separate "monitor virtual access 	 * point" be created, with later versions of the madwifi driver. 	 * airmon-ng does "wlanconfig ath create wlandev {if} wlanmode 	 * monitor -bssid", which apparently spits out a line "athN" 	 * where "athN" is the monitor mode device.  To leave monitor 	 * mode, it destroys the monitor mode device. 	 * 	 * Some Intel Centrino adapters might require private ioctls to get 	 * radio headers; the ipw2200 and ipw3945 drivers allow you to 	 * configure a separate "rtapN" interface to capture in monitor 	 * mode without preventing the adapter from operating normally. 	 * (airmon-ng doesn't appear to use that, though.) 	 * 	 * It would be Truly Wonderful if mac80211 and nl80211 cleaned this 	 * up, and if all drivers were converted to mac80211 drivers. 	 * 	 * If interface {if} is a mac80211 driver, the file 	 * /sys/class/net/{if}/phy80211 is a symlink to 	 * /sys/class/ieee80211/{phydev}, for some {phydev}. 	 * 	 * On Fedora 9, with a 2.6.26.3-29 kernel, my Zydas stick, at 	 * least, has a "wmaster0" device and a "wlan0" device; the 	 * latter is the one with the IP address.  Both show up in 	 * "tcpdump -D" output.  Capturing on the wmaster0 device 	 * captures with 802.11 headers. 	 * 	 * airmon-ng searches through /sys/class/net for devices named 	 * monN, starting with mon0; as soon as one *doesn't* exist, 	 * it chooses that as the monitor device name.  If the "iw" 	 * command exists, it does "iw dev {if} interface add {monif} 	 * type monitor", where {monif} is the monitor device.  It 	 * then (sigh) sleeps .1 second, and then configures the 	 * device up.  Otherwise, if /sys/class/ieee80211/{phydev}/add_iface 	 * is a file, it writes {mondev}, without a newline, to that file, 	 * and again (sigh) sleeps .1 second, and then iwconfig's that 	 * device into monitor mode and configures it up.  Otherwise, 	 * you can't do monitor mode. 	 * 	 * All these devices are "glued" together by having the 	 * /sys/class/net/{device}/phy80211 links pointing to the same 	 * place, so, given a wmaster, wlan, or mon device, you can 	 * find the other devices by looking for devices with 	 * the same phy80211 link. 	 * 	 * To turn monitor mode off, delete the monitor interface, 	 * either with "iw dev {monif} interface del" or by sending 	 * {monif}, with no NL, down /sys/class/ieee80211/{phydev}/remove_iface 	 * 	 * Note: if you try to create a monitor device named "monN", and 	 * there's already a "monN" device, it fails, as least with 	 * the netlink interface (which is what iw uses), with a return 	 * value of -ENFILE.  (Return values are negative errnos.)  We 	 * could probably use that to find an unused device. 	 */
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|iwreq
name|ireq
decl_stmt|;
name|struct
name|iw_priv_args
modifier|*
name|priv
decl_stmt|;
name|monitor_type
name|montype
decl_stmt|;
name|int
name|i
decl_stmt|;
name|__u32
name|cmd
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|oldflags
decl_stmt|;
name|int
name|args
index|[
literal|2
index|]
decl_stmt|;
name|int
name|channel
decl_stmt|;
comment|/* 	 * Does this device *support* the Wireless Extensions? 	 */
name|err
operator|=
name|has_wext
argument_list|(
name|sock_fd
argument_list|,
name|device
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
return|return
name|err
return|;
comment|/* either it doesn't or the device doesn't even exist */
comment|/* 	 * Start out assuming we have no private extensions to control 	 * radio metadata. 	 */
name|montype
operator|=
name|MONITOR_WEXT
expr_stmt|;
name|cmd
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Try to get all the Wireless Extensions private ioctls 	 * supported by this device. 	 * 	 * First, get the size of the buffer we need, by supplying no 	 * buffer and a length of 0.  If the device supports private 	 * ioctls, it should return E2BIG, with ireq.u.data.length set 	 * to the length we need.  If it doesn't support them, it should 	 * return EOPNOTSUPP. 	 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|pointer
operator|=
operator|(
name|void
operator|*
operator|)
name|args
expr_stmt|;
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCGIWPRIV
argument_list|,
operator|&
name|ireq
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: SIOCGIWPRIV with a zero-length buffer didn't fail!"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|EOPNOTSUPP
condition|)
block|{
comment|/* 		 * OK, it's not as if there are no private ioctls. 		 */
if|if
condition|(
name|errno
operator|!=
name|E2BIG
condition|)
block|{
comment|/* 			 * Failed. 			 */
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: SIOCGIWPRIV: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
comment|/* 		 * OK, try to get the list of private ioctls. 		 */
name|priv
operator|=
name|malloc
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iw_priv_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|pointer
operator|=
operator|(
name|void
operator|*
operator|)
name|priv
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCGIWPRIV
argument_list|,
operator|&
name|ireq
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: SIOCGIWPRIV: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
comment|/* 		 * Look for private ioctls to turn monitor mode on or, if 		 * monitor mode is on, to set the header type. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|priv
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"monitor_type"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Hostap driver, use this one. 				 * Set monitor mode first. 				 * You can set it to 0 to get DLT_IEEE80211, 				 * 1 to get DLT_PRISM, 2 to get 				 * DLT_IEEE80211_RADIO_AVS, and, with more 				 * recent versions of the driver, 3 to get 				 * DLT_IEEE80211_RADIO. 				 */
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_TYPE_MASK
operator|)
operator|!=
name|IW_PRIV_TYPE_INT
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_FIXED
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_MASK
operator|)
operator|!=
literal|1
condition|)
break|break;
name|montype
operator|=
name|MONITOR_HOSTAP
expr_stmt|;
name|cmd
operator|=
name|priv
index|[
name|i
index|]
operator|.
name|cmd
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|priv
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"set_prismhdr"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Prism54 driver, use this one. 				 * Set monitor mode first. 				 * You can set it to 2 to get DLT_IEEE80211 				 * or 3 or get DLT_PRISM. 				 */
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_TYPE_MASK
operator|)
operator|!=
name|IW_PRIV_TYPE_INT
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_FIXED
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_MASK
operator|)
operator|!=
literal|1
condition|)
break|break;
name|montype
operator|=
name|MONITOR_PRISM54
expr_stmt|;
name|cmd
operator|=
name|priv
index|[
name|i
index|]
operator|.
name|cmd
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|priv
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"forceprismheader"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * RT2570 driver, use this one. 				 * Do this after turning monitor mode on. 				 * You can set it to 1 to get DLT_PRISM or 2 				 * to get DLT_IEEE80211. 				 */
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_TYPE_MASK
operator|)
operator|!=
name|IW_PRIV_TYPE_INT
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_FIXED
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_MASK
operator|)
operator|!=
literal|1
condition|)
break|break;
name|montype
operator|=
name|MONITOR_RT2570
expr_stmt|;
name|cmd
operator|=
name|priv
index|[
name|i
index|]
operator|.
name|cmd
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|priv
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"forceprism"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * RT73 driver, use this one. 				 * Do this after turning monitor mode on. 				 * Its argument is a *string*; you can 				 * set it to "1" to get DLT_PRISM or "2" 				 * to get DLT_IEEE80211. 				 */
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_TYPE_MASK
operator|)
operator|!=
name|IW_PRIV_TYPE_CHAR
condition|)
break|break;
if|if
condition|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_FIXED
condition|)
break|break;
name|montype
operator|=
name|MONITOR_RT73
expr_stmt|;
name|cmd
operator|=
name|priv
index|[
name|i
index|]
operator|.
name|cmd
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|priv
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"prismhdr"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * One of the RTL8xxx drivers, use this one. 				 * It can only be done after monitor mode 				 * has been turned on.  You can set it to 1 				 * to get DLT_PRISM or 0 to get DLT_IEEE80211. 				 */
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_TYPE_MASK
operator|)
operator|!=
name|IW_PRIV_TYPE_INT
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_FIXED
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_MASK
operator|)
operator|!=
literal|1
condition|)
break|break;
name|montype
operator|=
name|MONITOR_RTL8XXX
expr_stmt|;
name|cmd
operator|=
name|priv
index|[
name|i
index|]
operator|.
name|cmd
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|priv
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"rfmontx"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * RT2500 or RT61 driver, use this one. 				 * It has one one-byte parameter; set 				 * u.data.length to 1 and u.data.pointer to 				 * point to the parameter. 				 * It doesn't itself turn monitor mode on. 				 * You can set it to 1 to allow transmitting 				 * in monitor mode(?) and get DLT_IEEE80211, 				 * or set it to 0 to disallow transmitting in 				 * monitor mode(?) and get DLT_PRISM. 				 */
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_TYPE_MASK
operator|)
operator|!=
name|IW_PRIV_TYPE_INT
condition|)
break|break;
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_MASK
operator|)
operator|!=
literal|2
condition|)
break|break;
name|montype
operator|=
name|MONITOR_RT2500
expr_stmt|;
name|cmd
operator|=
name|priv
index|[
name|i
index|]
operator|.
name|cmd
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|priv
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"monitor"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Either ACX100 or hostap, use this one. 				 * It turns monitor mode on. 				 * If it takes two arguments, it's ACX100; 				 * the first argument is 1 for DLT_PRISM 				 * or 2 for DLT_IEEE80211, and the second 				 * argument is the channel on which to 				 * run.  If it takes one argument, it's 				 * HostAP, and the argument is 2 for 				 * DLT_IEEE80211 and 3 for DLT_PRISM. 				 * 				 * If we see this, we don't quit, as this 				 * might be a version of the hostap driver 				 * that also supports "monitor_type". 				 */
if|if
condition|(
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_TYPE_MASK
operator|)
operator|!=
name|IW_PRIV_TYPE_INT
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_FIXED
operator|)
condition|)
break|break;
switch|switch
condition|(
name|priv
index|[
name|i
index|]
operator|.
name|set_args
operator|&
name|IW_PRIV_SIZE_MASK
condition|)
block|{
case|case
literal|1
case|:
name|montype
operator|=
name|MONITOR_PRISM
expr_stmt|;
name|cmd
operator|=
name|priv
index|[
name|i
index|]
operator|.
name|cmd
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|montype
operator|=
name|MONITOR_ACX100
expr_stmt|;
name|cmd
operator|=
name|priv
index|[
name|i
index|]
operator|.
name|cmd
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX - ipw3945?  islism? 	 */
comment|/* 	 * Get the old mode. 	 */
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCGIWMODE
argument_list|,
operator|&
name|ireq
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * We probably won't be able to set the mode, either. 		 */
return|return
name|PCAP_ERROR_RFMON_NOTSUP
return|;
block|}
comment|/* 	 * Is it currently in monitor mode? 	 */
if|if
condition|(
name|ireq
operator|.
name|u
operator|.
name|mode
operator|==
name|IW_MODE_MONITOR
condition|)
block|{
comment|/* 		 * Yes.  Just leave things as they are. 		 * We don't offer multiple link-layer types, as 		 * changing the link-layer type out from under 		 * somebody else capturing in monitor mode would 		 * be considered rude. 		 */
return|return
literal|1
return|;
block|}
comment|/* 	 * No.  We have to put the adapter into rfmon mode. 	 */
comment|/* 	 * If we haven't already done so, arrange to have 	 * "pcap_close_all()" called when we exit. 	 */
if|if
condition|(
operator|!
name|pcap_do_addexit
argument_list|(
name|handle
argument_list|)
condition|)
block|{
comment|/* 		 * "atexit()" failed; don't put the interface 		 * in rfmon mode, just give up. 		 */
return|return
name|PCAP_ERROR_RFMON_NOTSUP
return|;
block|}
comment|/* 	 * Save the old mode. 	 */
name|handlep
operator|->
name|oldmode
operator|=
name|ireq
operator|.
name|u
operator|.
name|mode
expr_stmt|;
comment|/* 	 * Put the adapter in rfmon mode.  How we do this depends 	 * on whether we have a special private ioctl or not. 	 */
if|if
condition|(
name|montype
operator|==
name|MONITOR_PRISM
condition|)
block|{
comment|/* 		 * We have the "monitor" private ioctl, but none of 		 * the other private ioctls.  Use this, and select 		 * the Prism header. 		 * 		 * If it fails, just fall back on SIOCSIWMODE. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|length
operator|=
literal|1
expr_stmt|;
comment|/* 1 argument */
name|args
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
comment|/* request Prism header */
name|memcpy
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|name
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Success. 			 * Note that we have to put the old mode back 			 * when we close the device. 			 */
name|handlep
operator|->
name|must_do_on_close
operator||=
name|MUST_CLEAR_RFMON
expr_stmt|;
comment|/* 			 * Add this to the list of pcaps to close 			 * when we exit. 			 */
name|pcap_add_to_pcaps_to_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 		 * Failure.  Fall back on SIOCSIWMODE. 		 */
block|}
comment|/* 	 * First, take the interface down if it's up; otherwise, we 	 * might get EBUSY. 	 */
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: Can't get flags: %s"
argument_list|,
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|oldflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
condition|)
block|{
name|oldflags
operator|=
name|ifr
operator|.
name|ifr_flags
expr_stmt|;
name|ifr
operator|.
name|ifr_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: Can't set flags: %s"
argument_list|,
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
block|}
comment|/* 	 * Then turn monitor mode on. 	 */
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|ireq
operator|.
name|u
operator|.
name|mode
operator|=
name|IW_MODE_MONITOR
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCSIWMODE
argument_list|,
operator|&
name|ireq
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Scientist, you've failed. 		 * Bring the interface back up if we shut it down. 		 */
name|ifr
operator|.
name|ifr_flags
operator|=
name|oldflags
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: Can't set flags: %s"
argument_list|,
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
return|return
name|PCAP_ERROR_RFMON_NOTSUP
return|;
block|}
comment|/* 	 * XXX - airmon-ng does "iwconfig {if} key off" after setting 	 * monitor mode and setting the channel, and then does 	 * "iwconfig up". 	 */
comment|/* 	 * Now select the appropriate radio header. 	 */
switch|switch
condition|(
name|montype
condition|)
block|{
case|case
name|MONITOR_WEXT
case|:
comment|/* 		 * We don't have any private ioctl to set the header. 		 */
break|break;
case|case
name|MONITOR_HOSTAP
case|:
comment|/* 		 * Try to select the radiotap header. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
comment|/* request radiotap header */
name|memcpy
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|name
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
comment|/* success */
comment|/* 		 * That failed.  Try to select the AVS header. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
comment|/* request AVS header */
name|memcpy
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|name
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
comment|/* success */
comment|/* 		 * That failed.  Try to select the Prism header. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* request Prism header */
name|memcpy
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|name
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONITOR_PRISM
case|:
comment|/* 		 * The private ioctl failed. 		 */
break|break;
case|case
name|MONITOR_PRISM54
case|:
comment|/* 		 * Select the Prism header. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
comment|/* request Prism header */
name|memcpy
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|name
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONITOR_ACX100
case|:
comment|/* 		 * Get the current channel. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCGIWFREQ
argument_list|,
operator|&
name|ireq
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: SIOCGIWFREQ: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|channel
operator|=
name|ireq
operator|.
name|u
operator|.
name|freq
operator|.
name|m
expr_stmt|;
comment|/* 		 * Select the Prism header, and set the channel to the 		 * current value. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* request Prism header */
name|args
index|[
literal|1
index|]
operator|=
name|channel
expr_stmt|;
comment|/* set channel */
name|memcpy
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|name
argument_list|,
name|args
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONITOR_RT2500
case|:
comment|/* 		 * Disallow transmission - that turns on the 		 * Prism header. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* disallow transmitting */
name|memcpy
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|name
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONITOR_RT2570
case|:
comment|/* 		 * Force the Prism header. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* request Prism header */
name|memcpy
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|name
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONITOR_RT73
case|:
comment|/* 		 * Force the Prism header. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|length
operator|=
literal|1
expr_stmt|;
comment|/* 1 argument */
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|pointer
operator|=
literal|"1"
expr_stmt|;
name|ireq
operator|.
name|u
operator|.
name|data
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONITOR_RTL8XXX
case|:
comment|/* 		 * Force the Prism header. 		 */
name|memset
argument_list|(
operator|&
name|ireq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ireq
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ireq
operator|.
name|ifr_ifrn
operator|.
name|ifrn_name
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* request Prism header */
name|memcpy
argument_list|(
name|ireq
operator|.
name|u
operator|.
name|name
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|ireq
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Now bring the interface back up if we brought it down. 	 */
if|if
condition|(
name|oldflags
operator|!=
literal|0
condition|)
block|{
name|ifr
operator|.
name|ifr_flags
operator|=
name|oldflags
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock_fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: Can't set flags: %s"
argument_list|,
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * At least try to restore the old mode on the 			 * interface. 			 */
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSIWMODE
argument_list|,
operator|&
name|ireq
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Scientist, you've failed. 				 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface wireless mode (SIOCSIWMODE failed: %s).\n"
literal|"Please adjust manually.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|PCAP_ERROR
return|;
block|}
block|}
comment|/* 	 * Note that we have to put the old mode back when we 	 * close the device. 	 */
name|handlep
operator|->
name|must_do_on_close
operator||=
name|MUST_CLEAR_RFMON
expr_stmt|;
comment|/* 	 * Add this to the list of pcaps to close when we exit. 	 */
name|pcap_add_to_pcaps_to_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* IW_MODE_MONITOR */
comment|/*  * Try various mechanisms to enter monitor mode.  */
specifier|static
name|int
name|enter_rfmon_mode
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|sock_fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LIBNL
argument_list|)
operator|||
name|defined
argument_list|(
name|IW_MODE_MONITOR
argument_list|)
name|int
name|ret
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LIBNL
name|ret
operator|=
name|enter_rfmon_mode_mac80211
argument_list|(
name|handle
argument_list|,
name|sock_fd
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
comment|/* error attempting to do so */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* success */
endif|#
directive|endif
comment|/* HAVE_LIBNL */
ifdef|#
directive|ifdef
name|IW_MODE_MONITOR
name|ret
operator|=
name|enter_rfmon_mode_wext
argument_list|(
name|handle
argument_list|,
name|sock_fd
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
comment|/* error attempting to do so */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* success */
endif|#
directive|endif
comment|/* IW_MODE_MONITOR */
comment|/* 	 * Either none of the mechanisms we know about work or none 	 * of those mechanisms are available, so we can't do monitor 	 * mode. 	 */
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LINUX_NET_TSTAMP_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|PACKET_TIMESTAMP
argument_list|)
comment|/*  * Map SOF_TIMESTAMPING_ values to PCAP_TSTAMP_ values.  */
specifier|static
specifier|const
struct|struct
block|{
name|int
name|soft_timestamping_val
decl_stmt|;
name|int
name|pcap_tstamp_val
decl_stmt|;
block|}
name|sof_ts_type_map
index|[
literal|3
index|]
init|=
block|{
block|{
name|SOF_TIMESTAMPING_SOFTWARE
block|,
name|PCAP_TSTAMP_HOST
block|}
block|,
block|{
name|SOF_TIMESTAMPING_SYS_HARDWARE
block|,
name|PCAP_TSTAMP_ADAPTER
block|}
block|,
block|{
name|SOF_TIMESTAMPING_RAW_HARDWARE
block|,
name|PCAP_TSTAMP_ADAPTER_UNSYNCED
block|}
block|}
struct|;
define|#
directive|define
name|NUM_SOF_TIMESTAMPING_TYPES
value|(sizeof sof_ts_type_map / sizeof sof_ts_type_map[0])
comment|/*  * Set the list of time stamping types to include all types.  */
specifier|static
name|void
name|iface_set_all_ts_types
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|handle
operator|->
name|tstamp_type_count
operator|=
name|NUM_SOF_TIMESTAMPING_TYPES
expr_stmt|;
name|handle
operator|->
name|tstamp_type_list
operator|=
name|malloc
argument_list|(
name|NUM_SOF_TIMESTAMPING_TYPES
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SOF_TIMESTAMPING_TYPES
condition|;
name|i
operator|++
control|)
name|handle
operator|->
name|tstamp_type_list
index|[
name|i
index|]
operator|=
name|sof_ts_type_map
index|[
name|i
index|]
operator|.
name|pcap_tstamp_val
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ETHTOOL_GET_TS_INFO
comment|/*  * Get a list of time stamping capabilities.  */
specifier|static
name|int
name|iface_ethtool_get_ts_info
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|struct
name|ethtool_ts_info
name|info
decl_stmt|;
name|int
name|num_ts_types
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * This doesn't apply to the "any" device; you can't say "turn on 	 * hardware time stamping for all devices that exist now and arrange 	 * that it be turned on for any device that appears in the future", 	 * and not all devices even necessarily *support* hardware time 	 * stamping, so don't report any time stamp types. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|device
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|handle
operator|->
name|tstamp_type_list
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Create a socket from which to fetch time stamping capabilities. 	 */
name|fd
operator|=
name|socket
argument_list|(
name|PF_UNIX
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket for SIOCETHTOOL(ETHTOOL_GET_TS_INFO): %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|cmd
operator|=
name|ETHTOOL_GET_TS_INFO
expr_stmt|;
name|ifr
operator|.
name|ifr_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|info
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCETHTOOL
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|save_errno
condition|)
block|{
case|case
name|EOPNOTSUPP
case|:
case|case
name|EINVAL
case|:
comment|/* 			 * OK, this OS version or driver doesn't support 			 * asking for the time stamping types, so let's 			 * just return all the possible types. 			 */
name|iface_set_all_ts_types
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ENODEV
case|:
comment|/* 			 * OK, no such device. 			 * The user will find that out when they try to 			 * activate the device; just return an empty 			 * list of time stamp types. 			 */
name|handle
operator|->
name|tstamp_type_list
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
default|default:
comment|/* 			 * Other error. 			 */
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: SIOCETHTOOL(ETHTOOL_GET_TS_INFO) ioctl failed: %s"
argument_list|,
name|device
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * Do we support hardware time stamping of *all* packets? 	 */
if|if
condition|(
operator|!
operator|(
name|info
operator|.
name|rx_filters
operator|&
operator|(
literal|1
operator|<<
name|HWTSTAMP_FILTER_ALL
operator|)
operator|)
condition|)
block|{
comment|/* 		 * No, so don't report any time stamp types. 		 * 		 * XXX - some devices either don't report 		 * HWTSTAMP_FILTER_ALL when they do support it, or 		 * report HWTSTAMP_FILTER_ALL but map it to only 		 * time stamping a few PTP packets.  See 		 * http://marc.info/?l=linux-netdev&m=146318183529571&w=2 		 */
name|handle
operator|->
name|tstamp_type_list
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|num_ts_types
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SOF_TIMESTAMPING_TYPES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|info
operator|.
name|so_timestamping
operator|&
name|sof_ts_type_map
index|[
name|i
index|]
operator|.
name|soft_timestamping_val
condition|)
name|num_ts_types
operator|++
expr_stmt|;
block|}
name|handle
operator|->
name|tstamp_type_count
operator|=
name|num_ts_types
expr_stmt|;
if|if
condition|(
name|num_ts_types
operator|!=
literal|0
condition|)
block|{
name|handle
operator|->
name|tstamp_type_list
operator|=
name|malloc
argument_list|(
name|num_ts_types
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SOF_TIMESTAMPING_TYPES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|info
operator|.
name|so_timestamping
operator|&
name|sof_ts_type_map
index|[
name|i
index|]
operator|.
name|soft_timestamping_val
condition|)
block|{
name|handle
operator|->
name|tstamp_type_list
index|[
name|j
index|]
operator|=
name|sof_ts_type_map
index|[
name|i
index|]
operator|.
name|pcap_tstamp_val
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
name|handle
operator|->
name|tstamp_type_list
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
else|#
directive|else
comment|/* ETHTOOL_GET_TS_INFO */
specifier|static
name|int
name|iface_ethtool_get_ts_info
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|char
modifier|*
name|ebuf
name|_U_
parameter_list|)
block|{
comment|/* 	 * This doesn't apply to the "any" device; you can't say "turn on 	 * hardware time stamping for all devices that exist now and arrange 	 * that it be turned on for any device that appears in the future", 	 * and not all devices even necessarily *support* hardware time 	 * stamping, so don't report any time stamp types. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|device
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|handle
operator|->
name|tstamp_type_list
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * We don't have an ioctl to use to ask what's supported, 	 * so say we support everything. 	 */
name|iface_set_all_ts_types
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* ETHTOOL_GET_TS_INFO */
endif|#
directive|endif
comment|/* defined(HAVE_LINUX_NET_TSTAMP_H)&& defined(PACKET_TIMESTAMP) */
ifdef|#
directive|ifdef
name|HAVE_PACKET_RING
comment|/*  * Find out if we have any form of fragmentation/reassembly offloading.  *  * We do so using SIOCETHTOOL checking for various types of offloading;  * if SIOCETHTOOL isn't defined, or we don't have any #defines for any  * of the types of offloading, there's nothing we can do to check, so  * we just say "no, we don't".  */
if|#
directive|if
name|defined
argument_list|(
name|SIOCETHTOOL
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|ETHTOOL_GTSO
argument_list|)
operator|||
name|defined
argument_list|(
name|ETHTOOL_GUFO
argument_list|)
operator|||
name|defined
argument_list|(
name|ETHTOOL_GGSO
argument_list|)
operator|||
name|defined
argument_list|(
name|ETHTOOL_GFLAGS
argument_list|)
operator|||
name|defined
argument_list|(
name|ETHTOOL_GGRO
argument_list|)
operator|)
specifier|static
name|int
name|iface_ethtool_flag_ioctl
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|int
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
name|cmdname
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|struct
name|ethtool_value
name|eval
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|eval
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|eval
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|ifr
operator|.
name|ifr_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|eval
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCETHTOOL
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EOPNOTSUPP
operator|||
name|errno
operator|==
name|EINVAL
condition|)
block|{
comment|/* 			 * OK, let's just return 0, which, in our 			 * case, either means "no, what we're asking 			 * about is not enabled" or "all the flags 			 * are clear (i.e., nothing is enabled)". 			 */
return|return
literal|0
return|;
block|}
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: SIOCETHTOOL(%s) ioctl failed: %s"
argument_list|,
name|handle
operator|->
name|opt
operator|.
name|device
argument_list|,
name|cmdname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|eval
operator|.
name|data
return|;
block|}
specifier|static
name|int
name|iface_get_offload
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|ETHTOOL_GTSO
name|ret
operator|=
name|iface_ethtool_flag_ioctl
argument_list|(
name|handle
argument_list|,
name|ETHTOOL_GTSO
argument_list|,
literal|"ETHTOOL_GTSO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ret
condition|)
return|return
literal|1
return|;
comment|/* TCP segmentation offloading on */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ETHTOOL_GUFO
name|ret
operator|=
name|iface_ethtool_flag_ioctl
argument_list|(
name|handle
argument_list|,
name|ETHTOOL_GUFO
argument_list|,
literal|"ETHTOOL_GUFO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ret
condition|)
return|return
literal|1
return|;
comment|/* UDP fragmentation offloading on */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ETHTOOL_GGSO
comment|/* 	 * XXX - will this cause large unsegmented packets to be 	 * handed to PF_PACKET sockets on transmission?  If not, 	 * this need not be checked. 	 */
name|ret
operator|=
name|iface_ethtool_flag_ioctl
argument_list|(
name|handle
argument_list|,
name|ETHTOOL_GGSO
argument_list|,
literal|"ETHTOOL_GGSO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ret
condition|)
return|return
literal|1
return|;
comment|/* generic segmentation offloading on */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ETHTOOL_GFLAGS
name|ret
operator|=
name|iface_ethtool_flag_ioctl
argument_list|(
name|handle
argument_list|,
name|ETHTOOL_GFLAGS
argument_list|,
literal|"ETHTOOL_GFLAGS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ret
operator|&
name|ETH_FLAG_LRO
condition|)
return|return
literal|1
return|;
comment|/* large receive offloading on */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ETHTOOL_GGRO
comment|/* 	 * XXX - will this cause large reassembled packets to be 	 * handed to PF_PACKET sockets on receipt?  If not, 	 * this need not be checked. 	 */
name|ret
operator|=
name|iface_ethtool_flag_ioctl
argument_list|(
name|handle
argument_list|,
name|ETHTOOL_GGRO
argument_list|,
literal|"ETHTOOL_GGRO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ret
condition|)
return|return
literal|1
return|;
comment|/* generic (large) receive offloading on */
endif|#
directive|endif
return|return
literal|0
return|;
block|}
else|#
directive|else
comment|/* SIOCETHTOOL */
specifier|static
name|int
name|iface_get_offload
parameter_list|(
name|pcap_t
modifier|*
name|handle
name|_U_
parameter_list|)
block|{
comment|/* 	 * XXX - do we need to get this information if we don't 	 * have the ethtool ioctls?  If so, how do we do that? 	 */
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* SIOCETHTOOL */
endif|#
directive|endif
comment|/* HAVE_PACKET_RING */
endif|#
directive|endif
comment|/* HAVE_PF_PACKET_SOCKETS */
comment|/* ===== Functions to interface to the older kernels ================== */
comment|/*  * Try to open a packet socket using the old kernel interface.  * Returns 1 on success and a PCAP_ERROR_ value on an error.  */
specifier|static
name|int
name|activate_old
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|int
name|arptype
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
specifier|const
name|char
modifier|*
name|device
init|=
name|handle
operator|->
name|opt
operator|.
name|device
decl_stmt|;
name|struct
name|utsname
name|utsname
decl_stmt|;
name|int
name|mtu
decl_stmt|;
comment|/* Open the socket */
name|handle
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_PACKET
argument_list|,
name|htons
argument_list|(
name|ETH_P_ALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EPERM
operator|||
name|errno
operator|==
name|EACCES
condition|)
block|{
comment|/* 			 * You don't have permission to open the 			 * socket. 			 */
return|return
name|PCAP_ERROR_PERM_DENIED
return|;
block|}
else|else
block|{
comment|/* 			 * Other error. 			 */
return|return
name|PCAP_ERROR
return|;
block|}
block|}
comment|/* It worked - we are using the old interface */
name|handlep
operator|->
name|sock_packet
operator|=
literal|1
expr_stmt|;
comment|/* ...which means we get the link-layer header. */
name|handlep
operator|->
name|cooked
operator|=
literal|0
expr_stmt|;
comment|/* Bind to the given device */
if|if
condition|(
name|strcmp
argument_list|(
name|device
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
literal|"pcap_activate: The \"any\" device isn't supported on 2.0[.x]-kernel systems"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
if|if
condition|(
name|iface_bind_old
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|device
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|PCAP_ERROR
return|;
comment|/* 	 * Try to get the link-layer type. 	 */
name|arptype
operator|=
name|iface_get_arptype
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|device
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|arptype
operator|<
literal|0
condition|)
return|return
name|PCAP_ERROR
return|;
comment|/* 	 * Try to find the DLT_ type corresponding to that 	 * link-layer type. 	 */
name|map_arphrd_to_dlt
argument_list|(
name|handle
argument_list|,
name|handle
operator|->
name|fd
argument_list|,
name|arptype
argument_list|,
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|linktype
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown arptype %d"
argument_list|,
name|arptype
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
comment|/* Go to promisc mode if requested */
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIFFLAGS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_PROMISC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Promiscuous mode isn't currently on, 			 * so turn it on, and remember that 			 * we should turn it off when the 			 * pcap_t is closed. 			 */
comment|/* 			 * If we haven't already done so, arrange 			 * to have "pcap_close_all()" called when 			 * we exit. 			 */
if|if
condition|(
operator|!
name|pcap_do_addexit
argument_list|(
name|handle
argument_list|)
condition|)
block|{
comment|/* 				 * "atexit()" failed; don't put 				 * the interface in promiscuous 				 * mode, just give up. 				 */
return|return
name|PCAP_ERROR
return|;
block|}
name|ifr
operator|.
name|ifr_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCSIFFLAGS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PCAP_ERROR
return|;
block|}
name|handlep
operator|->
name|must_do_on_close
operator||=
name|MUST_CLEAR_PROMISC
expr_stmt|;
comment|/* 			 * Add this to the list of pcaps 			 * to close when we exit. 			 */
name|pcap_add_to_pcaps_to_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Compute the buffer size. 	 * 	 * We're using SOCK_PACKET, so this might be a 2.0[.x] 	 * kernel, and might require special handling - check. 	 */
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|<
literal|0
operator|||
name|strncmp
argument_list|(
name|utsname
operator|.
name|release
argument_list|,
literal|"2.0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Either we couldn't find out what kernel release 		 * this is, or it's a 2.0[.x] kernel. 		 * 		 * In the 2.0[.x] kernel, a "recvfrom()" on 		 * a SOCK_PACKET socket, with MSG_TRUNC set, will 		 * return the number of bytes read, so if we pass 		 * a length based on the snapshot length, it'll 		 * return the number of bytes from the packet 		 * copied to userland, not the actual length 		 * of the packet. 		 * 		 * This means that, for example, the IP dissector 		 * in tcpdump will get handed a packet length less 		 * than the length in the IP header, and will 		 * complain about "truncated-ip". 		 * 		 * So we don't bother trying to copy from the 		 * kernel only the bytes in which we're interested, 		 * but instead copy them all, just as the older 		 * versions of libpcap for Linux did. 		 * 		 * The buffer therefore needs to be big enough to 		 * hold the largest packet we can get from this 		 * device.  Unfortunately, we can't get the MRU 		 * of the network; we can only get the MTU.  The 		 * MTU may be too small, in which case a packet larger 		 * than the buffer size will be truncated *and* we 		 * won't get the actual packet size. 		 * 		 * However, if the snapshot length is larger than 		 * the buffer size based on the MTU, we use the 		 * snapshot length as the buffer size, instead; 		 * this means that with a sufficiently large snapshot 		 * length we won't artificially truncate packets 		 * to the MTU-based size. 		 * 		 * This mess just one of many problems with packet 		 * capture on 2.0[.x] kernels; you really want a 		 * 2.2[.x] or later kernel if you want packet capture 		 * to work well. 		 */
name|mtu
operator|=
name|iface_get_mtu
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|device
argument_list|,
name|handle
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|==
operator|-
literal|1
condition|)
return|return
name|PCAP_ERROR
return|;
name|handle
operator|->
name|bufsize
operator|=
name|MAX_LINKHEADER_SIZE
operator|+
name|mtu
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|bufsize
operator|<
operator|(
name|u_int
operator|)
name|handle
operator|->
name|snapshot
condition|)
name|handle
operator|->
name|bufsize
operator|=
operator|(
name|u_int
operator|)
name|handle
operator|->
name|snapshot
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a 2.2[.x] or later kernel. 		 * 		 * We can safely pass "recvfrom()" a byte count 		 * based on the snapshot length. 		 */
name|handle
operator|->
name|bufsize
operator|=
operator|(
name|u_int
operator|)
name|handle
operator|->
name|snapshot
expr_stmt|;
block|}
comment|/* 	 * Default value for offset to align link-layer payload 	 * on a 4-byte boundary. 	 */
name|handle
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * SOCK_PACKET sockets don't supply information from 	 * stripped VLAN tags. 	 */
name|handlep
operator|->
name|vlan_offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
return|return
literal|1
return|;
block|}
comment|/*  *  Bind the socket associated with FD to the given device using the  *  interface of the old kernels.  */
specifier|static
name|int
name|iface_bind_old
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|sockaddr
name|saddr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|socklen_t
name|errlen
init|=
sizeof|sizeof
argument_list|(
name|err
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|saddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|saddr
operator|.
name|sa_data
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
operator|.
name|sa_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Any pending errors, e.g., network is down? */
if|if
condition|(
name|getsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|errlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getsockopt: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|err
operator|>
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bind: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* ===== System calls available on all supported kernels ============== */
comment|/*  *  Query the kernel for the MTU of the given interface.  */
specifier|static
name|int
name|iface_get_mtu
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
if|if
condition|(
operator|!
name|device
condition|)
return|return
name|BIGGER_THAN_ALL_MTUS
return|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFMTU
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIFMTU: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ifr
operator|.
name|ifr_mtu
return|;
block|}
comment|/*  *  Get the hardware type of the given interface as ARPHRD_xxx constant.  */
specifier|static
name|int
name|iface_get_arptype
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFHWADDR
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIFHWADDR: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENODEV
condition|)
block|{
comment|/* 			 * No such device. 			 */
return|return
name|PCAP_ERROR_NO_SUCH_DEVICE
return|;
block|}
return|return
name|PCAP_ERROR
return|;
block|}
return|return
name|ifr
operator|.
name|ifr_hwaddr
operator|.
name|sa_family
return|;
block|}
ifdef|#
directive|ifdef
name|SO_ATTACH_FILTER
specifier|static
name|int
name|fix_program
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|,
name|int
name|is_mmapped
parameter_list|)
block|{
name|struct
name|pcap_linux
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
name|size_t
name|prog_size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|bpf_insn
modifier|*
name|p
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|f
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * Make a copy of the filter, and modify that copy if 	 * necessary. 	 */
name|prog_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|)
operator|*
name|handle
operator|->
name|fcode
operator|.
name|bf_len
expr_stmt|;
name|len
operator|=
name|handle
operator|->
name|fcode
operator|.
name|bf_len
expr_stmt|;
name|f
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
name|malloc
argument_list|(
name|prog_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|f
argument_list|,
name|handle
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|prog_size
argument_list|)
expr_stmt|;
name|fcode
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|fcode
operator|->
name|filter
operator|=
operator|(
expr|struct
name|sock_filter
operator|*
operator|)
name|f
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|&
name|f
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * What type of instruction is this? 		 */
switch|switch
condition|(
name|BPF_CLASS
argument_list|(
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_RET
case|:
comment|/* 			 * It's a return instruction; are we capturing 			 * in memory-mapped mode? 			 */
if|if
condition|(
operator|!
name|is_mmapped
condition|)
block|{
comment|/* 				 * No; is the snapshot length a constant, 				 * rather than the contents of the 				 * accumulator? 				 */
if|if
condition|(
name|BPF_MODE
argument_list|(
name|p
operator|->
name|code
argument_list|)
operator|==
name|BPF_K
condition|)
block|{
comment|/* 					 * Yes - if the value to be returned, 					 * i.e. the snapshot length, is 					 * anything other than 0, make it 					 * MAXIMUM_SNAPLEN, so that the packet 					 * is truncated by "recvfrom()", 					 * not by the filter. 					 * 					 * XXX - there's nothing we can 					 * easily do if it's getting the 					 * value from the accumulator; we'd 					 * have to insert code to force 					 * non-zero values to be 					 * MAXIMUM_SNAPLEN. 					 */
if|if
condition|(
name|p
operator|->
name|k
operator|!=
literal|0
condition|)
name|p
operator|->
name|k
operator|=
name|MAXIMUM_SNAPLEN
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BPF_LD
case|:
case|case
name|BPF_LDX
case|:
comment|/* 			 * It's a load instruction; is it loading 			 * from the packet? 			 */
switch|switch
condition|(
name|BPF_MODE
argument_list|(
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_ABS
case|:
case|case
name|BPF_IND
case|:
case|case
name|BPF_MSH
case|:
comment|/* 				 * Yes; are we in cooked mode? 				 */
if|if
condition|(
name|handlep
operator|->
name|cooked
condition|)
block|{
comment|/* 					 * Yes, so we need to fix this 					 * instruction. 					 */
if|if
condition|(
name|fix_offset
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 						 * We failed to do so. 						 * Return 0, so our caller 						 * knows to punt to userland. 						 */
return|return
literal|0
return|;
block|}
block|}
break|break;
block|}
break|break;
block|}
block|}
return|return
literal|1
return|;
comment|/* we succeeded */
block|}
specifier|static
name|int
name|fix_offset
parameter_list|(
name|struct
name|bpf_insn
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * What's the offset? 	 */
if|if
condition|(
name|p
operator|->
name|k
operator|>=
name|SLL_HDR_LEN
condition|)
block|{
comment|/* 		 * It's within the link-layer payload; that starts at an 		 * offset of 0, as far as the kernel packet filter is 		 * concerned, so subtract the length of the link-layer 		 * header. 		 */
name|p
operator|->
name|k
operator|-=
name|SLL_HDR_LEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|k
operator|==
literal|0
condition|)
block|{
comment|/* 		 * It's the packet type field; map it to the special magic 		 * kernel offset for that field. 		 */
name|p
operator|->
name|k
operator|=
name|SKF_AD_OFF
operator|+
name|SKF_AD_PKTTYPE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|k
operator|==
literal|14
condition|)
block|{
comment|/* 		 * It's the protocol field; map it to the special magic 		 * kernel offset for that field. 		 */
name|p
operator|->
name|k
operator|=
name|SKF_AD_OFF
operator|+
name|SKF_AD_PROTOCOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|bpf_int32
call|)
argument_list|(
name|p
operator|->
name|k
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 		 * It's within the header, but it's not one of those 		 * fields; we can't do that in the kernel, so punt 		 * to userland. 		 */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|set_kernel_filter
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|,
name|struct
name|sock_fprog
modifier|*
name|fcode
parameter_list|)
block|{
name|int
name|total_filter_on
init|=
literal|0
decl_stmt|;
name|int
name|save_mode
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
comment|/* 	 * The socket filter code doesn't discard all packets queued 	 * up on the socket when the filter is changed; this means 	 * that packets that don't match the new filter may show up 	 * after the new filter is put onto the socket, if those 	 * packets haven't yet been read. 	 * 	 * This means, for example, that if you do a tcpdump capture 	 * with a filter, the first few packets in the capture might 	 * be packets that wouldn't have passed the filter. 	 * 	 * We therefore discard all packets queued up on the socket 	 * when setting a kernel filter.  (This isn't an issue for 	 * userland filters, as the userland filtering is done after 	 * packets are queued up.) 	 * 	 * To flush those packets, we put the socket in read-only mode, 	 * and read packets from the socket until there are no more to 	 * read. 	 * 	 * In order to keep that from being an infinite loop - i.e., 	 * to keep more packets from arriving while we're draining 	 * the queue - we put the "total filter", which is a filter 	 * that rejects all packets, onto the socket before draining 	 * the queue. 	 * 	 * This code deliberately ignores any errors, so that you may 	 * get bogus packets if an error occurs, rather than having 	 * the filtering done in userland even if it could have been 	 * done in the kernel. 	 */
if|if
condition|(
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ATTACH_FILTER
argument_list|,
operator|&
name|total_fcode
argument_list|,
sizeof|sizeof
argument_list|(
name|total_fcode
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|drain
index|[
literal|1
index|]
decl_stmt|;
comment|/* 		 * Note that we've put the total filter onto the socket. 		 */
name|total_filter_on
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Save the socket's current mode, and put it in 		 * non-blocking mode; we drain it by reading packets 		 * until we get an error (which is normally a 		 * "nothing more to be read" error). 		 */
name|save_mode
operator|=
name|fcntl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_mode
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't get FD flags when changing filter: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|save_mode
operator||
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't set nonblocking mode when changing filter: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
while|while
condition|(
name|recv
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
operator|&
name|drain
argument_list|,
sizeof|sizeof
name|drain
argument_list|,
name|MSG_TRUNC
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|save_errno
operator|!=
name|EAGAIN
condition|)
block|{
comment|/* 			 * Fatal error. 			 * 			 * If we can't restore the mode or reset the 			 * kernel filter, there's nothing we can do. 			 */
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|save_mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reset_kernel_filter
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"recv failed when changing filter: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|save_mode
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't restore FD flags when changing filter: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
comment|/* 	 * Now attach the new filter. 	 */
name|ret
operator|=
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ATTACH_FILTER
argument_list|,
name|fcode
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fcode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|total_filter_on
condition|)
block|{
comment|/* 		 * Well, we couldn't set that filter on the socket, 		 * but we could set the total filter on the socket. 		 * 		 * This could, for example, mean that the filter was 		 * too big to put into the kernel, so we'll have to 		 * filter in userland; in any case, we'll be doing 		 * filtering in userland, so we need to remove the 		 * total filter so we see packets. 		 */
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* 		 * If this fails, we're really screwed; we have the 		 * total filter on the socket, and it won't come off. 		 * Report it as a fatal error. 		 */
if|if
condition|(
name|reset_kernel_filter
argument_list|(
name|handle
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't remove kernel total filter: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
comment|/* fatal error */
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|static
name|int
name|reset_kernel_filter
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
comment|/* 	 * setsockopt() barfs unless it get a dummy parameter. 	 * valgrind whines unless the value is initialized, 	 * as it has no idea that setsockopt() ignores its 	 * parameter. 	 */
name|int
name|dummy
init|=
literal|0
decl_stmt|;
return|return
name|setsockopt
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DETACH_FILTER
argument_list|,
operator|&
name|dummy
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

