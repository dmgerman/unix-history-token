begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tar.c - read in write tar headers for cpio    Copyright (C) 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"filetypes.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpiohdr.h"
end_include

begin_include
include|#
directive|include
file|"dstring.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_include
include|#
directive|include
file|"tarhdr.h"
end_include

begin_function_decl
specifier|static
name|void
name|to_oct
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stash_tar_linkname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stash_tar_filename
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Compute and return a checksum for TAR_HDR,    counting the checksum bytes as if they were spaces.  */
end_comment

begin_function
name|unsigned
name|long
name|tar_checksum
parameter_list|(
name|tar_hdr
parameter_list|)
name|struct
name|tar_header
modifier|*
name|tar_hdr
decl_stmt|;
block|{
name|unsigned
name|long
name|sum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|tar_hdr
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|p
operator|+
name|TARRECORDSIZE
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|tar_hdr
operator|->
name|chksum
condition|)
name|sum
operator|+=
operator|*
name|p
operator|++
operator|&
literal|0xff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
literal|' '
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|q
condition|)
name|sum
operator|+=
operator|*
name|p
operator|++
operator|&
literal|0xff
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/* Write out header FILE_HDR, including the file name, to file    descriptor OUT_DES.  */
end_comment

begin_function
name|void
name|write_out_tar_header
parameter_list|(
name|file_hdr
parameter_list|,
name|out_des
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
name|int
name|out_des
decl_stmt|;
block|{
name|int
name|name_len
decl_stmt|;
name|union
name|tar_record
name|tar_rec
decl_stmt|;
name|struct
name|tar_header
modifier|*
name|tar_hdr
init|=
operator|(
expr|struct
name|tar_header
operator|*
operator|)
operator|&
name|tar_rec
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tar_rec
argument_list|,
name|TARRECORDSIZE
argument_list|)
expr_stmt|;
comment|/* process_copy_out must ensure that file_hdr->c_name is short enough,      or we will lose here.  */
name|name_len
operator|=
name|strlen
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_len
operator|<=
name|TARNAMESIZE
condition|)
block|{
name|strncpy
argument_list|(
name|tar_hdr
operator|->
name|name
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fit as much as we can into `name', the rest into `prefix'.  */
name|char
modifier|*
name|suffix
init|=
name|file_hdr
operator|->
name|c_name
operator|+
name|name_len
operator|-
name|TARNAMESIZE
decl_stmt|;
comment|/* We have to put the boundary at a slash.  */
name|name_len
operator|=
name|TARNAMESIZE
expr_stmt|;
while|while
condition|(
operator|*
name|suffix
operator|!=
literal|'/'
condition|)
block|{
operator|--
name|name_len
expr_stmt|;
operator|++
name|suffix
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|tar_hdr
operator|->
name|name
argument_list|,
name|suffix
operator|+
literal|1
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tar_hdr
operator|->
name|prefix
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|,
name|suffix
operator|-
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
comment|/* SVR4 seems to want the whole mode, not just protection modes.      Nobody else seems to care, so we might as well put it all in.  */
name|to_oct
argument_list|(
name|file_hdr
operator|->
name|c_mode
argument_list|,
literal|8
argument_list|,
name|tar_hdr
operator|->
name|mode
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
name|file_hdr
operator|->
name|c_uid
argument_list|,
literal|8
argument_list|,
name|tar_hdr
operator|->
name|uid
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
name|file_hdr
operator|->
name|c_gid
argument_list|,
literal|8
argument_list|,
name|tar_hdr
operator|->
name|gid
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
name|file_hdr
operator|->
name|c_filesize
argument_list|,
literal|12
argument_list|,
name|tar_hdr
operator|->
name|size
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
name|file_hdr
operator|->
name|c_mtime
argument_list|,
literal|12
argument_list|,
name|tar_hdr
operator|->
name|mtime
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFREG
case|:
if|if
condition|(
name|file_hdr
operator|->
name|c_tar_linkname
condition|)
block|{
comment|/* process_copy_out makes sure that c_tar_linkname is shorter 	     than TARLINKNAMESIZE.  */
name|strncpy
argument_list|(
name|tar_hdr
operator|->
name|linkname
argument_list|,
name|file_hdr
operator|->
name|c_tar_linkname
argument_list|,
name|TARLINKNAMESIZE
argument_list|)
expr_stmt|;
name|tar_hdr
operator|->
name|typeflag
operator|=
name|LNKTYPE
expr_stmt|;
name|to_oct
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|,
name|tar_hdr
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|tar_hdr
operator|->
name|typeflag
operator|=
name|REGTYPE
expr_stmt|;
break|break;
case|case
name|CP_IFDIR
case|:
name|tar_hdr
operator|->
name|typeflag
operator|=
name|DIRTYPE
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|__MSDOS__
case|case
name|CP_IFCHR
case|:
name|tar_hdr
operator|->
name|typeflag
operator|=
name|CHRTYPE
expr_stmt|;
break|break;
case|case
name|CP_IFBLK
case|:
name|tar_hdr
operator|->
name|typeflag
operator|=
name|BLKTYPE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
name|tar_hdr
operator|->
name|typeflag
operator|=
name|FIFOTYPE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* CP_IFIFO */
ifdef|#
directive|ifdef
name|CP_IFLNK
case|case
name|CP_IFLNK
case|:
name|tar_hdr
operator|->
name|typeflag
operator|=
name|SYMTYPE
expr_stmt|;
comment|/* process_copy_out makes sure that c_tar_linkname is shorter 	 than TARLINKNAMESIZE.  */
name|strncpy
argument_list|(
name|tar_hdr
operator|->
name|linkname
argument_list|,
name|file_hdr
operator|->
name|c_tar_linkname
argument_list|,
name|TARLINKNAMESIZE
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|,
name|tar_hdr
operator|->
name|size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* CP_IFLNK */
endif|#
directive|endif
comment|/* !__MSDOS__ */
block|}
if|if
condition|(
name|archive_format
operator|==
name|arf_ustar
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|strncpy
argument_list|(
name|tar_hdr
operator|->
name|magic
argument_list|,
name|TMAGIC
argument_list|,
name|TMAGLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tar_hdr
operator|->
name|magic
operator|+
name|TMAGLEN
argument_list|,
name|TVERSION
argument_list|,
name|TVERSLEN
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
name|name
operator|=
name|getuser
argument_list|(
name|file_hdr
operator|->
name|c_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|strcpy
argument_list|(
name|tar_hdr
operator|->
name|uname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|getgroup
argument_list|(
name|file_hdr
operator|->
name|c_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|strcpy
argument_list|(
name|tar_hdr
operator|->
name|gname
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|to_oct
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
literal|8
argument_list|,
name|tar_hdr
operator|->
name|devmajor
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
name|file_hdr
operator|->
name|c_rdev_min
argument_list|,
literal|8
argument_list|,
name|tar_hdr
operator|->
name|devminor
argument_list|)
expr_stmt|;
block|}
name|to_oct
argument_list|(
name|tar_checksum
argument_list|(
name|tar_hdr
argument_list|)
argument_list|,
literal|8
argument_list|,
name|tar_hdr
operator|->
name|chksum
argument_list|)
expr_stmt|;
name|tape_buffered_write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tar_rec
argument_list|,
name|out_des
argument_list|,
name|TARRECORDSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero iff all the bytes in BLOCK are NUL.    SIZE is the number of bytes to check in BLOCK; it must be a    multiple of sizeof (long).  */
end_comment

begin_function
name|int
name|null_block
parameter_list|(
name|block
parameter_list|,
name|size
parameter_list|)
name|long
modifier|*
name|block
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|long
modifier|*
name|p
init|=
name|block
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
if|if
condition|(
operator|*
name|p
operator|++
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read a tar header, including the file name, from file descriptor IN_DES    into FILE_HDR.  */
end_comment

begin_function
name|void
name|read_in_tar_header
parameter_list|(
name|file_hdr
parameter_list|,
name|in_des
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
name|int
name|in_des
decl_stmt|;
block|{
name|long
name|bytes_skipped
init|=
literal|0
decl_stmt|;
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
name|union
name|tar_record
name|tar_rec
decl_stmt|;
name|struct
name|tar_header
modifier|*
name|tar_hdr
init|=
operator|(
expr|struct
name|tar_header
operator|*
operator|)
operator|&
name|tar_rec
decl_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
name|uid_t
modifier|*
name|uidp
decl_stmt|;
name|gid_t
modifier|*
name|gidp
decl_stmt|;
endif|#
directive|endif
name|tape_buffered_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tar_rec
argument_list|,
name|in_des
argument_list|,
name|TARRECORDSIZE
argument_list|)
expr_stmt|;
comment|/* Check for a block of 0's.  */
if|if
condition|(
name|null_block
argument_list|(
operator|(
name|long
operator|*
operator|)
operator|&
name|tar_rec
argument_list|,
name|TARRECORDSIZE
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Found one block of 512 0's.  If the next block is also all 0's 	 then this is the end of the archive.  If not, assume the 	 previous block was all corruption and continue reading 	 the archive.  */
comment|/* Commented out because GNU tar sometimes creates archives with 	 only one block of 0's at the end.  This happened for the 	 cpio 2.0 distribution!  */
block|tape_buffered_read ((char *)&tar_rec, in_des, TARRECORDSIZE);       if (null_block ((long *)&tar_rec, TARRECORDSIZE))
endif|#
directive|endif
block|{
name|file_hdr
operator|->
name|c_name
operator|=
literal|"TRAILER!!!"
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|bytes_skipped = TARRECORDSIZE;
endif|#
directive|endif
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|otoa
argument_list|(
name|tar_hdr
operator|->
name|chksum
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_chksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_hdr
operator|->
name|c_chksum
operator|!=
name|tar_checksum
argument_list|(
name|tar_hdr
argument_list|)
condition|)
block|{
comment|/* If the checksum is bad, skip 1 byte and try again.  When 	     we try again we do not look for an EOF record (all zeros), 	     because when we start skipping bytes in a corrupted archive 	     the chances are pretty good that we might stumble across 	     2 blocks of 512 zeros (that probably is not really the last 	     record) and it is better to miss the EOF and give the user 	     a "premature EOF" error than to give up too soon on a corrupted 	     archive.  */
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid header: checksum error"
argument_list|)
expr_stmt|;
name|warned
operator|=
name|TRUE
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tar_rec
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tar_rec
argument_list|,
name|TARRECORDSIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tape_buffered_read
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tar_rec
operator|)
operator|+
operator|(
name|TARRECORDSIZE
operator|-
literal|1
operator|)
argument_list|,
name|in_des
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|++
name|bytes_skipped
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|archive_format
operator|!=
name|arf_ustar
condition|)
name|file_hdr
operator|->
name|c_name
operator|=
name|stash_tar_filename
argument_list|(
name|NULL
argument_list|,
name|tar_hdr
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|file_hdr
operator|->
name|c_name
operator|=
name|stash_tar_filename
argument_list|(
name|tar_hdr
operator|->
name|prefix
argument_list|,
name|tar_hdr
operator|->
name|name
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_nlink
operator|=
literal|1
expr_stmt|;
name|otoa
argument_list|(
name|tar_hdr
operator|->
name|mode
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mode
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_mode
operator|=
name|file_hdr
operator|->
name|c_mode
operator|&
literal|07777
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
if|if
condition|(
name|archive_format
operator|==
name|arf_ustar
operator|&&
operator|(
name|uidp
operator|=
name|getuidbyname
argument_list|(
name|tar_hdr
operator|->
name|uname
argument_list|)
operator|)
condition|)
name|file_hdr
operator|->
name|c_uid
operator|=
operator|*
name|uidp
expr_stmt|;
else|else
endif|#
directive|endif
name|otoa
argument_list|(
name|tar_hdr
operator|->
name|uid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_uid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
if|if
condition|(
name|archive_format
operator|==
name|arf_ustar
operator|&&
operator|(
name|gidp
operator|=
name|getgidbyname
argument_list|(
name|tar_hdr
operator|->
name|gname
argument_list|)
operator|)
condition|)
name|file_hdr
operator|->
name|c_gid
operator|=
operator|*
name|gidp
expr_stmt|;
else|else
endif|#
directive|endif
name|otoa
argument_list|(
name|tar_hdr
operator|->
name|gid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_gid
argument_list|)
expr_stmt|;
name|otoa
argument_list|(
name|tar_hdr
operator|->
name|size
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|otoa
argument_list|(
name|tar_hdr
operator|->
name|mtime
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mtime
argument_list|)
expr_stmt|;
name|otoa
argument_list|(
name|tar_hdr
operator|->
name|devmajor
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|)
expr_stmt|;
name|otoa
argument_list|(
name|tar_hdr
operator|->
name|devminor
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_tar_linkname
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|tar_hdr
operator|->
name|typeflag
condition|)
block|{
case|case
name|REGTYPE
case|:
case|case
name|CONTTYPE
case|:
comment|/* For now, punt.  */
default|default:
name|file_hdr
operator|->
name|c_mode
operator||=
name|CP_IFREG
expr_stmt|;
break|break;
case|case
name|DIRTYPE
case|:
name|file_hdr
operator|->
name|c_mode
operator||=
name|CP_IFDIR
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|__MSDOS__
case|case
name|CHRTYPE
case|:
name|file_hdr
operator|->
name|c_mode
operator||=
name|CP_IFCHR
expr_stmt|;
comment|/* If a POSIX tar header has a valid linkname it's always supposed 	     to set typeflag to be LNKTYPE.  System V.4 tar seems to 	     be broken, and for device files with multiple links it 	     puts the name of the link into linkname, but leaves typeflag  	     as CHRTYPE, BLKTYPE, FIFOTYPE, etc.  */
name|file_hdr
operator|->
name|c_tar_linkname
operator|=
name|stash_tar_linkname
argument_list|(
name|tar_hdr
operator|->
name|linkname
argument_list|)
expr_stmt|;
comment|/* Does POSIX say that the filesize must be 0 for devices?  We 	     assume so, but HPUX's POSIX tar sets it to be 1 which causes 	     us problems (when reading an archive we assume we can always 	     skip to the next file by skipping filesize bytes).  For  	     now at least, it's easier to clear filesize for devices, 	     rather than check everywhere we skip in copyin.c.  */
name|file_hdr
operator|->
name|c_filesize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BLKTYPE
case|:
name|file_hdr
operator|->
name|c_mode
operator||=
name|CP_IFBLK
expr_stmt|;
name|file_hdr
operator|->
name|c_tar_linkname
operator|=
name|stash_tar_linkname
argument_list|(
name|tar_hdr
operator|->
name|linkname
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|FIFOTYPE
case|:
name|file_hdr
operator|->
name|c_mode
operator||=
name|CP_IFIFO
expr_stmt|;
name|file_hdr
operator|->
name|c_tar_linkname
operator|=
name|stash_tar_linkname
argument_list|(
name|tar_hdr
operator|->
name|linkname
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SYMTYPE
case|:
ifdef|#
directive|ifdef
name|CP_IFLNK
name|file_hdr
operator|->
name|c_mode
operator||=
name|CP_IFLNK
expr_stmt|;
name|file_hdr
operator|->
name|c_tar_linkname
operator|=
name|stash_tar_linkname
argument_list|(
name|tar_hdr
operator|->
name|linkname
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Else fall through.  */
endif|#
directive|endif
case|case
name|LNKTYPE
case|:
name|file_hdr
operator|->
name|c_mode
operator||=
name|CP_IFREG
expr_stmt|;
name|file_hdr
operator|->
name|c_tar_linkname
operator|=
name|stash_tar_linkname
argument_list|(
name|tar_hdr
operator|->
name|linkname
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* !__MSDOS__ */
case|case
name|AREGTYPE
case|:
comment|/* Old tar format; if the last char in filename is '/' then it is 	     a directory, otherwise it's a regular file.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_name
index|[
name|strlen
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|file_hdr
operator|->
name|c_mode
operator||=
name|CP_IFDIR
expr_stmt|;
else|else
name|file_hdr
operator|->
name|c_mode
operator||=
name|CP_IFREG
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipped %ld bytes of junk"
argument_list|,
name|bytes_skipped
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stash the tar linkname in static storage.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stash_tar_linkname
parameter_list|(
name|linkname
parameter_list|)
name|char
modifier|*
name|linkname
decl_stmt|;
block|{
specifier|static
name|char
name|hold_tar_linkname
index|[
name|TARLINKNAMESIZE
operator|+
literal|1
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|hold_tar_linkname
argument_list|,
name|linkname
argument_list|,
name|TARLINKNAMESIZE
argument_list|)
expr_stmt|;
name|hold_tar_linkname
index|[
name|TARLINKNAMESIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|hold_tar_linkname
return|;
block|}
end_function

begin_comment
comment|/* Stash the tar filename and optional prefix in static storage.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stash_tar_filename
parameter_list|(
name|prefix
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|static
name|char
name|hold_tar_filename
index|[
name|TARNAMESIZE
operator|+
name|TARPREFIXSIZE
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|prefix
operator|==
name|NULL
operator|||
operator|*
name|prefix
operator|==
literal|'\0'
condition|)
block|{
name|strncpy
argument_list|(
name|hold_tar_filename
argument_list|,
name|filename
argument_list|,
name|TARNAMESIZE
argument_list|)
expr_stmt|;
name|hold_tar_filename
index|[
name|TARNAMESIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|hold_tar_filename
argument_list|,
name|prefix
argument_list|,
name|TARPREFIXSIZE
argument_list|)
expr_stmt|;
name|hold_tar_filename
index|[
name|TARPREFIXSIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|hold_tar_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|hold_tar_filename
argument_list|,
name|filename
argument_list|,
name|TARNAMESIZE
argument_list|)
expr_stmt|;
name|hold_tar_filename
index|[
name|TARPREFIXSIZE
operator|+
name|TARNAMESIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|hold_tar_filename
return|;
block|}
end_function

begin_comment
comment|/* Convert the string of octal digits S into a number and store    it in *N.  Return nonzero if the whole string was converted,    zero if there was something after the number.    Skip leading and trailing spaces.  */
end_comment

begin_function
name|int
name|otoa
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|long
modifier|*
name|n
decl_stmt|;
block|{
name|unsigned
name|long
name|val
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
condition|)
name|val
operator|=
literal|8
operator|*
name|val
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
operator|*
name|n
operator|=
name|val
expr_stmt|;
return|return
operator|*
name|s
operator|==
literal|'\0'
return|;
block|}
end_function

begin_comment
comment|/* Convert a number into a string of octal digits.    Convert long VALUE into a DIGITS-digit field at WHERE,    including a trailing space and room for a NUL.  DIGITS==3 means    1 digit, a space, and room for a NUL.     We assume the trailing NUL is already there and don't fill it in.    This fact is used by start_header and finish_header, so don't change it!     This is be equivalent to:    sprintf (where, "%*lo ", digits - 2, value);    except that sprintf fills in the trailing NUL and we don't.  */
end_comment

begin_function
specifier|static
name|void
name|to_oct
parameter_list|(
name|value
parameter_list|,
name|digits
parameter_list|,
name|where
parameter_list|)
specifier|register
name|long
name|value
decl_stmt|;
specifier|register
name|int
name|digits
decl_stmt|;
specifier|register
name|char
modifier|*
name|where
decl_stmt|;
block|{
operator|--
name|digits
expr_stmt|;
comment|/* Leave the trailing NUL slot alone.  */
name|where
index|[
operator|--
name|digits
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Put in the space, though.  */
comment|/* Produce the digits -- at least one.  */
do|do
block|{
name|where
index|[
operator|--
name|digits
index|]
operator|=
literal|'0'
operator|+
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|7
argument_list|)
expr_stmt|;
comment|/* One octal digit.  */
name|value
operator|>>=
literal|3
expr_stmt|;
block|}
do|while
condition|(
name|digits
operator|>
literal|0
operator|&&
name|value
operator|!=
literal|0
condition|)
do|;
comment|/* Add leading spaces, if necessary.  */
while|while
condition|(
name|digits
operator|>
literal|0
condition|)
name|where
index|[
operator|--
name|digits
index|]
operator|=
literal|' '
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return    2 if BUF is a valid POSIX tar header (the checksum is correct    and it has the "ustar" magic string),    1 if BUF is a valid old tar header (the checksum is correct),    0 otherwise.  */
end_comment

begin_function
name|int
name|is_tar_header
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|tar_header
modifier|*
name|tar_hdr
init|=
operator|(
expr|struct
name|tar_header
operator|*
operator|)
name|buf
decl_stmt|;
name|unsigned
name|long
name|chksum
decl_stmt|;
name|otoa
argument_list|(
name|tar_hdr
operator|->
name|chksum
argument_list|,
operator|&
name|chksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|chksum
operator|!=
name|tar_checksum
argument_list|(
name|tar_hdr
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* GNU tar 1.10 and previous set the magic field to be "ustar " instead      of "ustar\0".  Only look at the first 5 characters of the magic      field so we can recognize old GNU tar ustar archives.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|tar_hdr
operator|->
name|magic
argument_list|,
name|TMAGIC
argument_list|,
name|TMAGLEN
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the filename is too long to fit in a tar header.    For old tar headers, if the filename's length is less than or equal    to 100 then it will fit, otherwise it will not.  For POSIX tar headers,    if the filename's length is less than or equal to 100 then it    will definitely fit, and if it is greater than 256 then it    will definitely not fit.  If the length is between 100 and 256,    then the filename will fit only if it is possible to break it    into a 155 character "prefix" and 100 character "name".  There    must be a slash between the "prefix" and the "name", although    the slash is not stored or counted in either the "prefix" or    the "name", and there must be at least one character in both    the "prefix" and the "name".  If it is not possible to break down    the filename like this then it will not fit.  */
end_comment

begin_function
name|int
name|is_tar_filename_too_long
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|whole_name_len
decl_stmt|;
name|int
name|prefix_name_len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|whole_name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|whole_name_len
operator|<=
name|TARNAMESIZE
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|archive_format
operator|!=
name|arf_ustar
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|whole_name_len
operator|>
name|TARNAMESIZE
operator|+
name|TARPREFIXSIZE
operator|+
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* See whether we can split up the name into acceptably-sized      `prefix' and `name' (`p') pieces.  Start out by making `name'      as big as possible, then shrink it by looking for the first '/'.  */
name|p
operator|=
name|name
operator|+
name|whole_name_len
operator|-
name|TARNAMESIZE
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* The last component of the path is longer than TARNAMESIZE.  */
return|return
name|TRUE
return|;
name|prefix_name_len
operator|=
name|p
operator|-
name|name
operator|-
literal|1
expr_stmt|;
comment|/* Interestingly, a name consisting of a slash followed by      TARNAMESIZE characters can't be stored, because the prefix      would be empty, and thus ignored.  */
if|if
condition|(
name|prefix_name_len
operator|>
name|TARPREFIXSIZE
operator|||
name|prefix_name_len
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

end_unit

