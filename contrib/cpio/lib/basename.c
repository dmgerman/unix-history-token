begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* basename.c -- return the last element in a file name     Copyright (C) 1990, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006 Free    Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"dirname.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"xalloc.h"
end_include

begin_include
include|#
directive|include
file|"xstrndup.h"
end_include

begin_comment
comment|/* Return the address of the last file name component of NAME.  If    NAME has no relative file name components because it is a file    system root, return the empty string.  */
end_comment

begin_function
name|char
modifier|*
name|last_component
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|base
init|=
name|name
operator|+
name|FILE_SYSTEM_PREFIX_LEN
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|bool
name|saw_slash
init|=
name|false
decl_stmt|;
while|while
condition|(
name|ISSLASH
argument_list|(
operator|*
name|base
argument_list|)
condition|)
name|base
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|base
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ISSLASH
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|saw_slash
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|saw_slash
condition|)
block|{
name|base
operator|=
name|p
expr_stmt|;
name|saw_slash
operator|=
name|false
expr_stmt|;
block|}
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|base
return|;
block|}
end_function

begin_comment
comment|/* In general, we can't use the builtin `basename' function if available,    since it has different meanings in different environments.    In some environments the builtin `basename' modifies its argument.     Return the last file name component of NAME, allocated with    xmalloc.  On systems with drive letters, a leading "./"    distinguishes relative names that would otherwise look like a drive    letter.  Unlike POSIX basename(), NAME cannot be NULL,    base_name("") returns "", and the first trailing slash is not    stripped.     If lstat (NAME) would succeed, then { chdir (dir_name (NAME));    lstat (base_name (NAME)); } will access the same file.  Likewise,    if the sequence { chdir (dir_name (NAME));    rename (base_name (NAME), "foo"); } succeeds, you have renamed NAME    to "foo" in the same directory NAME was in.  */
end_comment

begin_function
name|char
modifier|*
name|base_name
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|base
init|=
name|last_component
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* If there is no last component, then name is a file system root or the      empty string.  */
if|if
condition|(
operator|!
operator|*
name|base
condition|)
return|return
name|xstrndup
argument_list|(
name|name
argument_list|,
name|base_len
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
comment|/* Collapse a sequence of trailing slashes into one.  */
name|length
operator|=
name|base_len
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSLASH
argument_list|(
name|base
index|[
name|length
index|]
argument_list|)
condition|)
name|length
operator|++
expr_stmt|;
comment|/* On systems with drive letters, `a/b:c' must return `./b:c' rather      than `b:c' to avoid confusion with a drive letter.  On systems      with pure POSIX semantics, this is not an issue.  */
if|if
condition|(
name|FILE_SYSTEM_PREFIX_LEN
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|3
argument_list|)
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|base
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
index|[
name|length
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Finally, copy the basename.  */
return|return
name|xstrndup
argument_list|(
name|base
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the length of the basename NAME.  Typically NAME is the    value returned by base_name or last_component.  Act like strlen    (NAME), except omit all trailing slashes.  */
end_comment

begin_function
name|size_t
name|base_len
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|size_t
name|prefix_len
init|=
name|FILE_SYSTEM_PREFIX_LEN
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
init|;
literal|1
operator|<
name|len
operator|&&
name|ISSLASH
argument_list|(
name|name
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|;
name|len
operator|--
control|)
continue|continue;
if|if
condition|(
name|DOUBLE_SLASH_IS_DISTINCT_ROOT
operator|&&
name|len
operator|==
literal|1
operator|&&
name|ISSLASH
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ISSLASH
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|name
index|[
literal|2
index|]
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE
operator|&&
name|prefix_len
operator|&&
name|len
operator|==
name|prefix_len
operator|&&
name|ISSLASH
argument_list|(
name|name
index|[
name|prefix_len
index|]
argument_list|)
condition|)
return|return
name|prefix_len
operator|+
literal|1
return|;
return|return
name|len
return|;
block|}
end_function

end_unit

