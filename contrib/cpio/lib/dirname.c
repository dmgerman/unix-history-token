begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dirname.c -- return all but the last element in a file name     Copyright (C) 1990, 1998, 2000, 2001, 2003, 2004, 2005, 2006 Free Software    Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"dirname.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"xalloc.h"
end_include

begin_comment
comment|/* Return the length of the prefix of FILE that will be used by    dir_name.  If FILE is in the working directory, this returns zero    even though `dir_name (FILE)' will return ".".  Works properly even    if there are trailing slashes (by effectively ignoring them).  */
end_comment

begin_function
name|size_t
name|dir_len
parameter_list|(
name|char
specifier|const
modifier|*
name|file
parameter_list|)
block|{
name|size_t
name|prefix_length
init|=
name|FILE_SYSTEM_PREFIX_LEN
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* Advance prefix_length beyond important leading slashes.  */
name|prefix_length
operator|+=
operator|(
name|prefix_length
operator|!=
literal|0
condition|?
operator|(
name|FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE
operator|&&
name|ISSLASH
argument_list|(
name|file
index|[
name|prefix_length
index|]
argument_list|)
operator|)
else|:
operator|(
name|ISSLASH
argument_list|(
name|file
index|[
literal|0
index|]
argument_list|)
condition|?
operator|(
operator|(
name|DOUBLE_SLASH_IS_DISTINCT_ROOT
operator|&&
name|ISSLASH
argument_list|(
name|file
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|ISSLASH
argument_list|(
name|file
index|[
literal|2
index|]
argument_list|)
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* Strip the basename and any redundant slashes before it.  */
for|for
control|(
name|length
operator|=
name|last_component
argument_list|(
name|file
argument_list|)
operator|-
name|file
init|;
name|prefix_length
operator|<
name|length
condition|;
name|length
operator|--
control|)
if|if
condition|(
operator|!
name|ISSLASH
argument_list|(
name|file
index|[
name|length
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* In general, we can't use the builtin `dirname' function if available,    since it has different meanings in different environments.    In some environments the builtin `dirname' modifies its argument.     Return the leading directories part of FILE, allocated with xmalloc.    Works properly even if there are trailing slashes (by effectively    ignoring them).  Unlike POSIX dirname(), FILE cannot be NULL.     If lstat (FILE) would succeed, then { chdir (dir_name (FILE));    lstat (base_name (FILE)); } will access the same file.  Likewise,    if the sequence { chdir (dir_name (FILE));    rename (base_name (FILE), "foo"); } succeeds, you have renamed FILE    to "foo" in the same directory FILE was in.  */
end_comment

begin_function
name|char
modifier|*
name|dir_name
parameter_list|(
name|char
specifier|const
modifier|*
name|file
parameter_list|)
block|{
name|size_t
name|length
init|=
name|dir_len
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|bool
name|append_dot
init|=
operator|(
name|length
operator|==
literal|0
operator|||
operator|(
name|FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE
operator|&&
name|length
operator|==
name|FILE_SYSTEM_PREFIX_LEN
argument_list|(
name|file
argument_list|)
operator|&&
name|file
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSLASH
argument_list|(
name|file
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|xmalloc
argument_list|(
name|length
operator|+
name|append_dot
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dir
argument_list|,
name|file
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_dot
condition|)
name|dir
index|[
name|length
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|dir
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dir
return|;
block|}
end_function

end_unit

