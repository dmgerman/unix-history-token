begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Set file access and modification times.     Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software    Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Written by Paul Eggert.  */
end_comment

begin_comment
comment|/* derived from a function in touch.c */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"utimens.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|HAVE_UTIME_H
end_if

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some systems (even some that do have<utime.h>) don't declare this    structure anywhere.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRUCT_UTIMBUF
end_ifndef

begin_struct
struct|struct
name|utimbuf
block|{
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some systems don't have ENOSYS.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENOSYS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|ENOTSUP
end_ifdef

begin_define
define|#
directive|define
name|ENOSYS
value|ENOTSUP
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Some systems don't have ENOTSUP either.  */
end_comment

begin_define
define|#
directive|define
name|ENOSYS
value|EINVAL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__attribute__
end_ifndef

begin_if
if|#
directive|if
name|__GNUC__
operator|<
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|<
literal|8
operator|)
operator|||
name|__STRICT_ANSI__
end_if

begin_define
define|#
directive|define
name|__attribute__
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTRIBUTE_UNUSED
end_ifndef

begin_define
define|#
directive|define
name|ATTRIBUTE_UNUSED
value|__attribute__ ((__unused__))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set the access and modification time stamps of FD (a.k.a. FILE) to be    TIMESPEC[0] and TIMESPEC[1], respectively.    FD must be either negative -- in which case it is ignored --    or a file descriptor that is open on FILE.    If FD is nonnegative, then FILE can be NULL, which means    use just futimes (or equivalent) instead of utimes (or equivalent),    and fail if on an old system without futimes (or equivalent).    If TIMESPEC is null, set the time stamps to the current time.    Return 0 on success, -1 (setting errno) on failure.  */
end_comment

begin_function
name|int
name|gl_futimens
parameter_list|(
name|int
name|fd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|,
name|struct
name|timespec
specifier|const
name|timespec
index|[
literal|2
index|]
parameter_list|)
block|{
comment|/* Some Linux-based NFS clients are buggy, and mishandle time stamps      of files in NFS file systems in some cases.  We have no      configure-time test for this, but please see<http://bugs.gentoo.org/show_bug.cgi?id=132673> for references to      some of the problems with Linux 2.6.16.  If this affects you,      compile with -DHAVE_BUGGY_NFS_TIME_STAMPS; this is reported to      help in some cases, albeit at a cost in performance.  But you      really should upgrade your kernel to a fixed version, since the      problem affects many applications.  */
if|#
directive|if
name|HAVE_BUGGY_NFS_TIME_STAMPS
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|sync
argument_list|()
expr_stmt|;
else|else
name|fsync
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* There's currently no interface to set file timestamps with      nanosecond resolution, so do the best we can, discarding any      fractional part of the timestamp.  */
if|#
directive|if
name|HAVE_FUTIMESAT
operator|||
name|HAVE_WORKING_UTIMES
name|struct
name|timeval
name|timeval
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timeval
specifier|const
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|timespec
condition|)
block|{
name|timeval
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|timespec
index|[
literal|0
index|]
operator|.
name|tv_sec
expr_stmt|;
name|timeval
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|timespec
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|timeval
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|timespec
index|[
literal|1
index|]
operator|.
name|tv_sec
expr_stmt|;
name|timeval
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|timespec
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|t
operator|=
name|timeval
expr_stmt|;
block|}
else|else
name|t
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|HAVE_FUTIMESAT
return|return
name|futimesat
argument_list|(
name|AT_FDCWD
argument_list|,
name|file
argument_list|,
name|t
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* If futimesat or futimes fails here, don't try to speed things 	 up by returning right away.  glibc can incorrectly fail with 	 errno == ENOENT if /proc isn't mounted.  Also, Mandrake 10.0 	 in high security mode doesn't allow ordinary users to read 	 /proc/self, so glibc incorrectly fails with errno == EACCES. 	 If errno == EIO, EPERM, or EROFS, it's probably safe to fail 	 right away, but these cases are rare enough that they're not 	 worth optimizing, and who knows what other messed-up systems 	 are out there?  So play it safe and fall back on the code 	 below.  */
if|#
directive|if
name|HAVE_FUTIMESAT
if|if
condition|(
name|futimesat
argument_list|(
name|fd
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elif|#
directive|elif
name|HAVE_FUTIMES
if|if
condition|(
name|futimes
argument_list|(
name|fd
argument_list|,
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|file
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|HAVE_FUTIMESAT
operator|||
operator|(
name|HAVE_WORKING_UTIMES
operator|&&
name|HAVE_FUTIMES
operator|)
operator|)
name|errno
operator|=
name|ENOSYS
expr_stmt|;
endif|#
directive|endif
comment|/* Prefer EBADF to ENOSYS if both error numbers apply.  */
if|if
condition|(
name|errno
operator|==
name|ENOSYS
condition|)
block|{
name|int
name|fd2
init|=
name|dup
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|int
name|dup_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|fd2
condition|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
name|errno
operator|=
operator|(
name|fd2
operator|<
literal|0
operator|&&
name|dup_errno
operator|==
name|EBADF
condition|?
name|EBADF
else|:
name|ENOSYS
operator|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
name|HAVE_WORKING_UTIMES
return|return
name|utimes
argument_list|(
name|file
argument_list|,
name|t
argument_list|)
return|;
else|#
directive|else
block|{
name|struct
name|utimbuf
name|utimbuf
decl_stmt|;
name|struct
name|utimbuf
specifier|const
modifier|*
name|ut
decl_stmt|;
if|if
condition|(
name|timespec
condition|)
block|{
name|utimbuf
operator|.
name|actime
operator|=
name|timespec
index|[
literal|0
index|]
operator|.
name|tv_sec
expr_stmt|;
name|utimbuf
operator|.
name|modtime
operator|=
name|timespec
index|[
literal|1
index|]
operator|.
name|tv_sec
expr_stmt|;
name|ut
operator|=
operator|&
name|utimbuf
expr_stmt|;
block|}
else|else
name|ut
operator|=
name|NULL
expr_stmt|;
return|return
name|utime
argument_list|(
name|file
argument_list|,
name|ut
argument_list|)
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Set the access and modification time stamps of FILE to be    TIMESPEC[0] and TIMESPEC[1], respectively.  */
end_comment

begin_function
name|int
name|utimens
parameter_list|(
name|char
specifier|const
modifier|*
name|file
parameter_list|,
name|struct
name|timespec
specifier|const
name|timespec
index|[
literal|2
index|]
parameter_list|)
block|{
return|return
name|gl_futimens
argument_list|(
operator|-
literal|1
argument_list|,
name|file
argument_list|,
name|timespec
argument_list|)
return|;
block|}
end_function

end_unit

