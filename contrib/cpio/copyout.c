begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* copyout.c - create a cpio archive    Copyright (C) 1990, 1991, 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"filetypes.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpiohdr.h"
end_include

begin_include
include|#
directive|include
file|"dstring.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"defer.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_function_decl
specifier|static
name|unsigned
name|long
name|read_for_checksum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tape_clear_rest_of_block
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tape_pad_output
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|last_link
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_defered_links_to_dev_ino
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_link_defer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writeout_other_defers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writeout_final_defers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writeout_defered_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_rdev
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Write out header FILE_HDR, including the file name, to file    descriptor OUT_DES.  */
end_comment

begin_function
name|void
name|write_out_header
parameter_list|(
name|file_hdr
parameter_list|,
name|out_des
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
name|int
name|out_des
decl_stmt|;
block|{
if|if
condition|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
condition|)
block|{
name|char
name|ascii_header
index|[
literal|112
index|]
decl_stmt|;
name|char
modifier|*
name|magic_string
decl_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
condition|)
name|magic_string
operator|=
literal|"070702"
expr_stmt|;
else|else
name|magic_string
operator|=
literal|"070701"
expr_stmt|;
name|sprintf
argument_list|(
name|ascii_header
argument_list|,
literal|"%6s%08lx%08lx%08lx%08lx%08lx%08lx%08lx%08lx%08lx%08lx%08lx%08lx%08lx"
argument_list|,
name|magic_string
argument_list|,
name|file_hdr
operator|->
name|c_ino
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|,
name|file_hdr
operator|->
name|c_uid
argument_list|,
name|file_hdr
operator|->
name|c_gid
argument_list|,
name|file_hdr
operator|->
name|c_nlink
argument_list|,
name|file_hdr
operator|->
name|c_mtime
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|,
name|file_hdr
operator|->
name|c_dev_maj
argument_list|,
name|file_hdr
operator|->
name|c_dev_min
argument_list|,
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|,
name|file_hdr
operator|->
name|c_namesize
argument_list|,
name|file_hdr
operator|->
name|c_chksum
argument_list|)
expr_stmt|;
name|tape_buffered_write
argument_list|(
name|ascii_header
argument_list|,
name|out_des
argument_list|,
literal|110L
argument_list|)
expr_stmt|;
comment|/* Write file name to output.  */
name|tape_buffered_write
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|out_des
argument_list|,
operator|(
name|long
operator|)
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
name|tape_pad_output
argument_list|(
name|out_des
argument_list|,
name|file_hdr
operator|->
name|c_namesize
operator|+
literal|110
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_oldascii
operator|||
name|archive_format
operator|==
name|arf_hpoldascii
condition|)
block|{
name|char
name|ascii_header
index|[
literal|78
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
name|dev_t
name|dev
decl_stmt|;
name|dev_t
name|rdev
decl_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_oldascii
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_dev_maj
argument_list|,
name|file_hdr
operator|->
name|c_dev_min
argument_list|)
expr_stmt|;
name|rdev
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* HP/UX cpio creates archives that look just like ordinary archives, 	     but for devices it sets major = 0, minor = 1, and puts the 	     actual major/minor number in the filesize field.  */
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
name|file_hdr
operator|->
name|c_filesize
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
name|rdev
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|dev
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_dev_maj
argument_list|,
name|file_hdr
operator|->
name|c_dev_min
argument_list|)
expr_stmt|;
name|rdev
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|#
directive|else
name|int
name|dev
init|=
literal|0
decl_stmt|,
name|rdev
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_ino
operator|>>
literal|16
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: truncating inode number"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ascii_header
argument_list|,
literal|"%06o%06o%06lo%06lo%06lo%06lo%06lo%06o%011lo%06lo%011lo"
argument_list|,
name|file_hdr
operator|->
name|c_magic
operator|&
literal|0xFFFF
argument_list|,
name|dev
operator|&
literal|0xFFFF
argument_list|,
name|file_hdr
operator|->
name|c_ino
operator|&
literal|0xFFFF
argument_list|,
name|file_hdr
operator|->
name|c_mode
operator|&
literal|0xFFFF
argument_list|,
name|file_hdr
operator|->
name|c_uid
operator|&
literal|0xFFFF
argument_list|,
name|file_hdr
operator|->
name|c_gid
operator|&
literal|0xFFFF
argument_list|,
name|file_hdr
operator|->
name|c_nlink
operator|&
literal|0xFFFF
argument_list|,
name|rdev
operator|&
literal|0xFFFF
argument_list|,
name|file_hdr
operator|->
name|c_mtime
argument_list|,
name|file_hdr
operator|->
name|c_namesize
operator|&
literal|0xFFFF
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_buffered_write
argument_list|(
name|ascii_header
argument_list|,
name|out_des
argument_list|,
literal|76L
argument_list|)
expr_stmt|;
comment|/* Write file name to output.  */
name|tape_buffered_write
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|out_des
argument_list|,
operator|(
name|long
operator|)
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
block|{
name|write_out_tar_header
argument_list|(
name|file_hdr
argument_list|,
name|out_des
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|old_cpio_header
name|short_hdr
decl_stmt|;
name|short_hdr
operator|.
name|c_magic
operator|=
literal|070707
expr_stmt|;
name|short_hdr
operator|.
name|c_dev
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_dev_maj
argument_list|,
name|file_hdr
operator|->
name|c_dev_min
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_ino
operator|>>
literal|16
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: truncating inode number"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|short_hdr
operator|.
name|c_ino
operator|=
name|file_hdr
operator|->
name|c_ino
operator|&
literal|0xFFFF
expr_stmt|;
name|short_hdr
operator|.
name|c_mode
operator|=
name|file_hdr
operator|->
name|c_mode
operator|&
literal|0xFFFF
expr_stmt|;
name|short_hdr
operator|.
name|c_uid
operator|=
name|file_hdr
operator|->
name|c_uid
operator|&
literal|0xFFFF
expr_stmt|;
name|short_hdr
operator|.
name|c_gid
operator|=
name|file_hdr
operator|->
name|c_gid
operator|&
literal|0xFFFF
expr_stmt|;
name|short_hdr
operator|.
name|c_nlink
operator|=
name|file_hdr
operator|->
name|c_nlink
operator|&
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|archive_format
operator|!=
name|arf_hpbinary
condition|)
name|short_hdr
operator|.
name|c_rdev
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
comment|/* HP/UX cpio creates archives that look just like ordinary  		 archives, but for devices it sets major = 0, minor = 1, and  		 puts the actual major/minor number in the filesize field.  */
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
name|file_hdr
operator|->
name|c_filesize
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
name|short_hdr
operator|.
name|c_rdev
operator|=
name|makedev
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|short_hdr
operator|.
name|c_rdev
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|short_hdr
operator|.
name|c_mtimes
index|[
literal|0
index|]
operator|=
name|file_hdr
operator|->
name|c_mtime
operator|>>
literal|16
expr_stmt|;
name|short_hdr
operator|.
name|c_mtimes
index|[
literal|1
index|]
operator|=
name|file_hdr
operator|->
name|c_mtime
operator|&
literal|0xFFFF
expr_stmt|;
name|short_hdr
operator|.
name|c_namesize
operator|=
name|file_hdr
operator|->
name|c_namesize
operator|&
literal|0xFFFF
expr_stmt|;
name|short_hdr
operator|.
name|c_filesizes
index|[
literal|0
index|]
operator|=
name|file_hdr
operator|->
name|c_filesize
operator|>>
literal|16
expr_stmt|;
name|short_hdr
operator|.
name|c_filesizes
index|[
literal|1
index|]
operator|=
name|file_hdr
operator|->
name|c_filesize
operator|&
literal|0xFFFF
expr_stmt|;
comment|/* Output the file header.  */
name|tape_buffered_write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|short_hdr
argument_list|,
name|out_des
argument_list|,
literal|26L
argument_list|)
expr_stmt|;
comment|/* Write file name to output.  */
name|tape_buffered_write
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|out_des
argument_list|,
operator|(
name|long
operator|)
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
name|tape_pad_output
argument_list|(
name|out_des
argument_list|,
name|file_hdr
operator|->
name|c_namesize
operator|+
literal|26
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read a list of file names from the standard input    and write a cpio collection on the standard output.    The format of the header depends on the compatibility (-c) flag.  */
end_comment

begin_function
name|void
name|process_copy_out
parameter_list|()
block|{
name|int
name|res
decl_stmt|;
comment|/* Result of functions.  */
name|dynamic_string
name|input_name
decl_stmt|;
comment|/* Name of file read from stdin.  */
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* For resetting file times after copy.  */
name|struct
name|stat
name|file_stat
decl_stmt|;
comment|/* Stat record for file.  */
name|struct
name|new_cpio_header
name|file_hdr
decl_stmt|;
comment|/* Output header information.  */
name|int
name|in_file_des
decl_stmt|;
comment|/* Source file descriptor.  */
name|int
name|out_file_des
decl_stmt|;
comment|/* Output file descriptor.  */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Initialize the copy out.  */
name|ds_init
argument_list|(
operator|&
name|input_name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
comment|/* Initialize this in case it has members we don't know to set.  */
name|bzero
argument_list|(
operator|&
name|times
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utimbuf
argument_list|)
argument_list|)
expr_stmt|;
name|file_hdr
operator|.
name|c_magic
operator|=
literal|070707
expr_stmt|;
ifdef|#
directive|ifdef
name|__MSDOS__
name|setmode
argument_list|(
name|archive_des
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check whether the output file might be a tape.  */
name|out_file_des
operator|=
name|archive_des
expr_stmt|;
if|if
condition|(
name|_isrmt
argument_list|(
name|out_file_des
argument_list|)
condition|)
block|{
name|output_is_special
operator|=
literal|1
expr_stmt|;
name|output_is_seekable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fstat
argument_list|(
name|out_file_des
argument_list|,
operator|&
name|file_stat
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard output is closed"
argument_list|)
expr_stmt|;
name|output_is_special
operator|=
ifdef|#
directive|ifdef
name|S_ISBLK
name|S_ISBLK
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
operator|||
endif|#
directive|endif
name|S_ISCHR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|output_is_seekable
operator|=
name|S_ISREG
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|append_flag
condition|)
block|{
name|process_copy_in
argument_list|()
expr_stmt|;
name|prepare_append
argument_list|(
name|out_file_des
argument_list|)
expr_stmt|;
block|}
comment|/* Copy files with names read from stdin.  */
while|while
condition|(
name|ds_fgetstr
argument_list|(
name|stdin
argument_list|,
operator|&
name|input_name
argument_list|,
name|name_end
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Check for blank line.  */
if|if
condition|(
name|input_name
operator|.
name|ds_string
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"blank line ignored"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Process next file.  */
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|input_name
operator|.
name|ds_string
argument_list|,
operator|&
name|file_stat
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|input_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Set values in output header.  */
name|file_hdr
operator|.
name|c_dev_maj
operator|=
name|major
argument_list|(
name|file_stat
operator|.
name|st_dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|.
name|c_dev_min
operator|=
name|minor
argument_list|(
name|file_stat
operator|.
name|st_dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|.
name|c_ino
operator|=
name|file_stat
operator|.
name|st_ino
expr_stmt|;
comment|/* For POSIX systems that don't define the S_IF macros, 	     we can't assume that S_ISfoo means the standard Unix 	     S_IFfoo bit(s) are set.  So do it manually, with a 	     different name.  Bleah.  */
name|file_hdr
operator|.
name|c_mode
operator|=
operator|(
name|file_stat
operator|.
name|st_mode
operator|&
literal|07777
operator|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|file_hdr
operator|.
name|c_mode
operator||=
name|CP_IFREG
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|file_hdr
operator|.
name|c_mode
operator||=
name|CP_IFDIR
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISBLK
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|file_hdr
operator|.
name|c_mode
operator||=
name|CP_IFBLK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISCHR
elseif|else
if|if
condition|(
name|S_ISCHR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|file_hdr
operator|.
name|c_mode
operator||=
name|CP_IFCHR
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISFIFO
elseif|else
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|file_hdr
operator|.
name|c_mode
operator||=
name|CP_IFIFO
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISLNK
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|file_hdr
operator|.
name|c_mode
operator||=
name|CP_IFLNK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISSOCK
elseif|else
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|file_hdr
operator|.
name|c_mode
operator||=
name|CP_IFSOCK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISNWK
elseif|else
if|if
condition|(
name|S_ISNWK
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|file_hdr
operator|.
name|c_mode
operator||=
name|CP_IFNWK
expr_stmt|;
endif|#
directive|endif
name|file_hdr
operator|.
name|c_uid
operator|=
name|file_stat
operator|.
name|st_uid
expr_stmt|;
name|file_hdr
operator|.
name|c_gid
operator|=
name|file_stat
operator|.
name|st_gid
expr_stmt|;
name|file_hdr
operator|.
name|c_nlink
operator|=
name|file_stat
operator|.
name|st_nlink
expr_stmt|;
comment|/* The rdev is meaningless except for block and character 	     special files (POSIX standard) and perhaps fifos and 	     sockets.  Clear it for other types of files so that 	     check_rdev() doesn't reject files just because stat() 	     put garbage in st_rdev and so that the output doesn't 	     depend on the garbage.  */
switch|switch
condition|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFBLK
case|:
case|case
name|CP_IFCHR
case|:
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
name|file_hdr
operator|.
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|file_stat
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
name|file_hdr
operator|.
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|file_stat
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
break|break;
default|default:
name|file_hdr
operator|.
name|c_rdev_maj
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_rdev_min
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|file_hdr
operator|.
name|c_mtime
operator|=
name|file_stat
operator|.
name|st_mtime
expr_stmt|;
name|file_hdr
operator|.
name|c_filesize
operator|=
name|file_stat
operator|.
name|st_size
expr_stmt|;
name|file_hdr
operator|.
name|c_chksum
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_tar_linkname
operator|=
name|NULL
expr_stmt|;
comment|/* Strip leading `./' from the filename.  */
name|p
operator|=
name|input_name
operator|.
name|ds_string
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'/'
condition|)
block|{
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|p
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|HPUX_CDF
name|file_hdr
operator|.
name|c_name
operator|=
name|p
expr_stmt|;
name|file_hdr
operator|.
name|c_namesize
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|archive_format
operator|!=
name|arf_tar
operator|)
operator|&&
operator|(
name|archive_format
operator|!=
name|arf_ustar
operator|)
condition|)
block|{
comment|/* We mark CDF's in cpio files by adding a 2nd `/' after the 		 "hidden" directory name.  We need to do this so we can 		 properly recreate the directory as hidden (in case the 		 files of a directory go into the archive before the 		 directory itself (e.g from "find ... -depth ... | cpio")).  */
name|file_hdr
operator|.
name|c_name
operator|=
name|add_cdf_double_slashes
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|file_hdr
operator|.
name|c_namesize
operator|=
name|strlen
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't mark CDF's in tar files.  We assume the "hidden" 		 directory will always go into the archive before any of 		 its files.  */
name|file_hdr
operator|.
name|c_name
operator|=
name|p
expr_stmt|;
name|file_hdr
operator|.
name|c_namesize
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
operator|)
operator|&&
name|is_tar_filename_too_long
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: file name too long"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|check_rdev
argument_list|(
operator|&
name|file_hdr
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s not dumped: major number would be truncated"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|2
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s not dumped: minor number would be truncated"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|4
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s not dumped: device number would be truncated"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Copy the named file to the output.  */
switch|switch
condition|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFREG
case|:
ifndef|#
directive|ifndef
name|__MSDOS__
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
block|{
name|char
modifier|*
name|otherfile
decl_stmt|;
if|if
condition|(
operator|(
name|otherfile
operator|=
name|find_inode_file
argument_list|(
name|file_hdr
operator|.
name|c_ino
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_dev_min
argument_list|)
operator|)
condition|)
block|{
name|file_hdr
operator|.
name|c_tar_linkname
operator|=
name|otherfile
expr_stmt|;
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
operator|)
operator|&&
operator|(
name|file_hdr
operator|.
name|c_nlink
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|last_link
argument_list|(
operator|&
name|file_hdr
argument_list|)
condition|)
block|{
name|writeout_other_defers
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_link_defer
argument_list|(
operator|&
name|file_hdr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|in_file_des
operator|=
name|open
argument_list|(
name|input_name
operator|.
name|ds_string
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_file_des
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|input_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
condition|)
name|file_hdr
operator|.
name|c_chksum
operator|=
name|read_for_checksum
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|,
name|input_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
name|copy_files_disk_to_tape
argument_list|(
name|in_file_des
argument_list|,
name|out_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|,
name|input_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
name|add_inode
argument_list|(
name|file_hdr
operator|.
name|c_ino
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_dev_min
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tape_pad_output
argument_list|(
name|out_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|in_file_des
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|input_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset_time_flag
condition|)
block|{
name|times
operator|.
name|actime
operator|=
name|file_stat
operator|.
name|st_atime
expr_stmt|;
name|times
operator|.
name|modtime
operator|=
name|file_stat
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CP_IFDIR
case|:
name|file_hdr
operator|.
name|c_filesize
operator|=
literal|0
expr_stmt|;
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|__MSDOS__
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s not dumped: not a regular file"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_ustar
condition|)
block|{
name|char
modifier|*
name|otherfile
decl_stmt|;
if|if
condition|(
operator|(
name|otherfile
operator|=
name|find_inode_file
argument_list|(
name|file_hdr
operator|.
name|c_ino
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_dev_min
argument_list|)
operator|)
condition|)
block|{
comment|/* This file is linked to another file already in the  		         archive, so write it out as a hard link. */
name|file_hdr
operator|.
name|c_mode
operator|=
operator|(
name|file_stat
operator|.
name|st_mode
operator|&
literal|07777
operator|)
expr_stmt|;
name|file_hdr
operator|.
name|c_mode
operator||=
name|CP_IFREG
expr_stmt|;
name|file_hdr
operator|.
name|c_tar_linkname
operator|=
name|otherfile
expr_stmt|;
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
break|break;
block|}
name|add_inode
argument_list|(
name|file_hdr
operator|.
name|c_ino
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_dev_min
argument_list|)
expr_stmt|;
block|}
name|file_hdr
operator|.
name|c_filesize
operator|=
literal|0
expr_stmt|;
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFLNK
case|case
name|CP_IFLNK
case|:
block|{
name|char
modifier|*
name|link_name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|file_stat
operator|.
name|st_size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|link_size
decl_stmt|;
name|link_size
operator|=
name|readlink
argument_list|(
name|input_name
operator|.
name|ds_string
argument_list|,
name|link_name
argument_list|,
name|file_stat
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_size
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|input_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|file_hdr
operator|.
name|c_filesize
operator|=
name|link_size
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
block|{
if|if
condition|(
name|link_size
operator|+
literal|1
operator|>
literal|100
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: symbolic link too long"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_name
index|[
name|link_size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|file_hdr
operator|.
name|c_tar_linkname
operator|=
name|link_name
expr_stmt|;
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
name|tape_buffered_write
argument_list|(
name|link_name
argument_list|,
name|out_file_des
argument_list|,
name|link_size
argument_list|)
expr_stmt|;
name|tape_pad_output
argument_list|(
name|out_file_des
argument_list|,
name|link_size
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: unknown file type"
argument_list|,
name|input_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|input_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_flag
condition|)
name|fputc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|writeout_final_defers
argument_list|(
name|out_file_des
argument_list|)
expr_stmt|;
comment|/* The collection is complete; append the trailer.  */
name|file_hdr
operator|.
name|c_ino
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_mode
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_uid
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_gid
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_nlink
operator|=
literal|1
expr_stmt|;
comment|/* Must be 1 for crc format.  */
name|file_hdr
operator|.
name|c_dev_maj
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_dev_min
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_rdev_maj
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_rdev_min
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_mtime
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_chksum
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_filesize
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|.
name|c_namesize
operator|=
literal|11
expr_stmt|;
name|file_hdr
operator|.
name|c_name
operator|=
literal|"TRAILER!!!"
expr_stmt|;
if|if
condition|(
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
else|else
block|{
name|tape_buffered_write
argument_list|(
name|zeros_512
argument_list|,
name|out_file_des
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|tape_buffered_write
argument_list|(
name|zeros_512
argument_list|,
name|out_file_des
argument_list|,
literal|512
argument_list|)
expr_stmt|;
block|}
comment|/* Fill up the output block.  */
name|tape_clear_rest_of_block
argument_list|(
name|out_file_des
argument_list|)
expr_stmt|;
name|tape_empty_output_buffer
argument_list|(
name|out_file_des
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_flag
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|res
operator|=
operator|(
name|output_bytes
operator|+
name|io_block_size
operator|-
literal|1
operator|)
operator|/
name|io_block_size
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"1 block\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d blocks\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read FILE_SIZE bytes of FILE_NAME from IN_FILE_DES and    compute and return a checksum for them.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|read_for_checksum
parameter_list|(
name|in_file_des
parameter_list|,
name|file_size
parameter_list|,
name|file_name
parameter_list|)
name|int
name|in_file_des
decl_stmt|;
name|int
name|file_size
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
name|unsigned
name|long
name|crc
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|bytes_left
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|int
name|i
decl_stmt|;
name|crc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bytes_left
operator|=
name|file_size
init|;
name|bytes_left
operator|>
literal|0
condition|;
name|bytes_left
operator|-=
name|bytes_read
control|)
block|{
name|bytes_read
operator|=
name|read
argument_list|(
name|in_file_des
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read checksum for %s"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bytes_read
condition|;
operator|++
name|i
control|)
name|crc
operator|+=
name|buf
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|in_file_des
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read checksum for %s"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
name|crc
return|;
block|}
end_function

begin_comment
comment|/* Write out NULs to fill out the rest of the current block on    OUT_FILE_DES.  */
end_comment

begin_function
specifier|static
name|void
name|tape_clear_rest_of_block
parameter_list|(
name|out_file_des
parameter_list|)
name|int
name|out_file_des
decl_stmt|;
block|{
while|while
condition|(
name|output_size
operator|<
name|io_block_size
condition|)
block|{
if|if
condition|(
operator|(
name|io_block_size
operator|-
name|output_size
operator|)
operator|>
literal|512
condition|)
name|tape_buffered_write
argument_list|(
name|zeros_512
argument_list|,
name|out_file_des
argument_list|,
literal|512
argument_list|)
expr_stmt|;
else|else
name|tape_buffered_write
argument_list|(
name|zeros_512
argument_list|,
name|out_file_des
argument_list|,
name|io_block_size
operator|-
name|output_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write NULs on OUT_FILE_DES to move from OFFSET (the current location)    to the end of the header.  */
end_comment

begin_function
specifier|static
name|void
name|tape_pad_output
parameter_list|(
name|out_file_des
parameter_list|,
name|offset
parameter_list|)
name|int
name|out_file_des
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|pad
decl_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
condition|)
name|pad
operator|=
operator|(
literal|4
operator|-
operator|(
name|offset
operator|%
literal|4
operator|)
operator|)
operator|%
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
name|pad
operator|=
operator|(
literal|512
operator|-
operator|(
name|offset
operator|%
literal|512
operator|)
operator|)
operator|%
literal|512
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_format
operator|!=
name|arf_oldascii
operator|&&
name|archive_format
operator|!=
name|arf_hpoldascii
condition|)
name|pad
operator|=
operator|(
literal|2
operator|-
operator|(
name|offset
operator|%
literal|2
operator|)
operator|)
operator|%
literal|2
expr_stmt|;
else|else
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|tape_buffered_write
argument_list|(
name|zeros_512
argument_list|,
name|out_file_des
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When creating newc and crc archives if a file has multiple (hard)    links, we don't put any of them into the archive until we have seen    all of them (or until we get to the end of the list of files that    are going into the archive and know that we have seen all of the links    to the file that we will see).  We keep these "defered" files on    this list.   */
end_comment

begin_decl_stmt
name|struct
name|deferment
modifier|*
name|deferouts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is this file_hdr the last (hard) link to a file?  I.e., have    we already seen and defered all of the other links?  */
end_comment

begin_function
specifier|static
name|int
name|last_link
parameter_list|(
name|file_hdr
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
block|{
name|int
name|other_files_sofar
decl_stmt|;
name|other_files_sofar
operator|=
name|count_defered_links_to_dev_ino
argument_list|(
name|file_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_hdr
operator|->
name|c_nlink
operator|==
operator|(
name|other_files_sofar
operator|+
literal|1
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Count the number of other (hard) links to this file that have    already been defered.  */
end_comment

begin_function
specifier|static
name|int
name|count_defered_links_to_dev_ino
parameter_list|(
name|file_hdr
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|int
name|ino
decl_stmt|;
name|int
name|maj
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ino
operator|=
name|file_hdr
operator|->
name|c_ino
expr_stmt|;
name|maj
operator|=
name|file_hdr
operator|->
name|c_dev_maj
expr_stmt|;
name|min
operator|=
name|file_hdr
operator|->
name|c_dev_min
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|deferouts
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|header
operator|.
name|c_ino
operator|==
name|ino
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_maj
operator|==
name|maj
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_min
operator|==
name|min
operator|)
condition|)
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Add the file header for a link that is being defered to the deferouts    list.  */
end_comment

begin_function
specifier|static
name|void
name|add_link_defer
parameter_list|(
name|file_hdr
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|create_deferment
argument_list|(
name|file_hdr
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|deferouts
expr_stmt|;
name|deferouts
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We are about to put a file into a newc or crc archive that is    multiply linked.  We have already seen and defered all of the    other links to the file but haven't written them into the archive.    Write the other links into the archive, and remove them from the    deferouts list.  */
end_comment

begin_function
specifier|static
name|void
name|writeout_other_defers
parameter_list|(
name|file_hdr
parameter_list|,
name|out_des
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
name|int
name|out_des
decl_stmt|;
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|struct
name|deferment
modifier|*
name|d_prev
decl_stmt|;
name|int
name|ino
decl_stmt|;
name|int
name|maj
decl_stmt|;
name|int
name|min
decl_stmt|;
name|ino
operator|=
name|file_hdr
operator|->
name|c_ino
expr_stmt|;
name|maj
operator|=
name|file_hdr
operator|->
name|c_dev_maj
expr_stmt|;
name|min
operator|=
name|file_hdr
operator|->
name|c_dev_min
expr_stmt|;
name|d_prev
operator|=
name|NULL
expr_stmt|;
name|d
operator|=
name|deferouts
expr_stmt|;
while|while
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|header
operator|.
name|c_ino
operator|==
name|ino
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_maj
operator|==
name|maj
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_min
operator|==
name|min
operator|)
condition|)
block|{
name|struct
name|deferment
modifier|*
name|d_free
decl_stmt|;
name|d
operator|->
name|header
operator|.
name|c_filesize
operator|=
literal|0
expr_stmt|;
name|write_out_header
argument_list|(
operator|&
name|d
operator|->
name|header
argument_list|,
name|out_des
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_prev
operator|!=
name|NULL
condition|)
name|d_prev
operator|->
name|next
operator|=
name|d
operator|->
name|next
expr_stmt|;
else|else
name|deferouts
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|d_free
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|free_deferment
argument_list|(
name|d_free
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d_prev
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* When writing newc and crc format archives we defer multiply linked    files until we have seen all of the links to the file.  If a file    has links to it that aren't going into the archive, then we will    never see the "last" link to the file, so at the end we just write     all of the leftover defered files into the archive.  */
end_comment

begin_function
specifier|static
name|void
name|writeout_final_defers
parameter_list|(
name|out_des
parameter_list|)
name|int
name|out_des
decl_stmt|;
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|int
name|other_count
decl_stmt|;
while|while
condition|(
name|deferouts
operator|!=
name|NULL
condition|)
block|{
name|d
operator|=
name|deferouts
expr_stmt|;
name|other_count
operator|=
name|count_defered_links_to_dev_ino
argument_list|(
operator|&
name|d
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_count
operator|==
literal|1
condition|)
block|{
name|writeout_defered_file
argument_list|(
operator|&
name|d
operator|->
name|header
argument_list|,
name|out_des
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|new_cpio_header
name|file_hdr
decl_stmt|;
name|file_hdr
operator|=
name|d
operator|->
name|header
expr_stmt|;
name|file_hdr
operator|.
name|c_filesize
operator|=
literal|0
expr_stmt|;
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_des
argument_list|)
expr_stmt|;
block|}
name|deferouts
operator|=
name|deferouts
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write a file into the archive.  This code is the same as    the code in process_copy_out(), but we need it here too    for writeout_final_defers() to call.  */
end_comment

begin_function
specifier|static
name|void
name|writeout_defered_file
parameter_list|(
name|header
parameter_list|,
name|out_file_des
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|header
decl_stmt|;
name|int
name|out_file_des
decl_stmt|;
block|{
name|int
name|in_file_des
decl_stmt|;
name|struct
name|new_cpio_header
name|file_hdr
decl_stmt|;
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* For setting file times.  */
comment|/* Initialize this in case it has members we don't know to set.  */
name|bzero
argument_list|(
operator|&
name|times
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utimbuf
argument_list|)
argument_list|)
expr_stmt|;
name|file_hdr
operator|=
operator|*
name|header
expr_stmt|;
name|in_file_des
operator|=
name|open
argument_list|(
name|header
operator|->
name|c_name
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_file_des
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|header
operator|->
name|c_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
condition|)
name|file_hdr
operator|.
name|c_chksum
operator|=
name|read_for_checksum
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|,
name|header
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|write_out_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|out_file_des
argument_list|)
expr_stmt|;
name|copy_files_disk_to_tape
argument_list|(
name|in_file_des
argument_list|,
name|out_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|,
name|header
operator|->
name|c_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
name|add_inode
argument_list|(
name|file_hdr
operator|.
name|c_ino
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_dev_min
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tape_pad_output
argument_list|(
name|out_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|in_file_des
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|header
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset_time_flag
condition|)
block|{
name|times
operator|.
name|actime
operator|=
name|file_hdr
operator|.
name|c_mtime
expr_stmt|;
name|times
operator|.
name|modtime
operator|=
name|file_hdr
operator|.
name|c_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|check_rdev
parameter_list|(
name|file_hdr
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
block|{
if|if
condition|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
condition|)
block|{
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_rdev_maj
operator|&
literal|0xFFFFFFFF
operator|)
operator|!=
name|file_hdr
operator|->
name|c_rdev_maj
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_rdev_min
operator|&
literal|0xFFFFFFFF
operator|)
operator|!=
name|file_hdr
operator|->
name|c_rdev_min
condition|)
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_oldascii
operator|||
name|archive_format
operator|==
name|arf_hpoldascii
condition|)
block|{
ifndef|#
directive|ifndef
name|__MSDOS__
name|dev_t
name|rdev
decl_stmt|;
name|rdev
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_oldascii
condition|)
block|{
if|if
condition|(
operator|(
name|rdev
operator|&
literal|0xFFFF
operator|)
operator|!=
name|rdev
condition|)
return|return
literal|4
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
comment|/* We could handle one more bit if longs are>= 33 bits.  */
if|if
condition|(
operator|(
name|rdev
operator|&
literal|037777777777
operator|)
operator|!=
name|rdev
condition|)
return|return
literal|4
return|;
break|break;
default|default:
if|if
condition|(
operator|(
name|rdev
operator|&
literal|0xFFFF
operator|)
operator|!=
name|rdev
condition|)
return|return
literal|4
return|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
block|{
comment|/* The major and minor formats are limited to 7 octal digits in ustar 	 format, and to_oct () adds a gratuitous trailing blank to further 	 limit the format to 6 octal digits.  */
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_rdev_maj
operator|&
literal|0777777
operator|)
operator|!=
name|file_hdr
operator|->
name|c_rdev_maj
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_rdev_min
operator|&
literal|0777777
operator|)
operator|!=
name|file_hdr
operator|->
name|c_rdev_min
condition|)
return|return
literal|2
return|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|__MSDOS__
name|dev_t
name|rdev
decl_stmt|;
name|rdev
operator|=
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_format
operator|!=
name|arf_hpbinary
condition|)
block|{
if|if
condition|(
operator|(
name|rdev
operator|&
literal|0xFFFF
operator|)
operator|!=
name|rdev
condition|)
return|return
literal|4
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
if|if
condition|(
operator|(
name|rdev
operator|&
literal|0xFFFFFFFF
operator|)
operator|!=
name|rdev
condition|)
return|return
literal|4
return|;
name|file_hdr
operator|->
name|c_filesize
operator|=
name|rdev
expr_stmt|;
name|rdev
operator|=
name|makedev
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|rdev
operator|&
literal|0xFFFF
operator|)
operator|!=
name|rdev
condition|)
return|return
literal|4
return|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

