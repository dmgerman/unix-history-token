begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* util.c - Several utility routines for cpio.    Copyright (C) 1990, 1991, 1992, 2001, 2004,    2006 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public    License along with this program; if not, write to the Free    Software Foundation, Inc., 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301 USA.  */
end_comment

begin_include
include|#
directive|include
file|<system.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"cpiohdr.h"
end_include

begin_include
include|#
directive|include
file|"dstring.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|<paxlib.h>
end_include

begin_include
include|#
directive|include
file|"filetypes.h"
end_include

begin_include
include|#
directive|include
file|<safe-read.h>
end_include

begin_include
include|#
directive|include
file|<full-write.h>
end_include

begin_include
include|#
directive|include
file|<rmt.h>
end_include

begin_include
include|#
directive|include
file|<hash.h>
end_include

begin_include
include|#
directive|include
file|<utimens.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MTIO_H
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IO_TRIOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/io/trioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_DECL_ERRNO
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Write `output_size' bytes of `output_buffer' to file    descriptor OUT_DES and reset `output_size' and `out_buff'.  */
end_comment

begin_function
name|void
name|tape_empty_output_buffer
parameter_list|(
name|int
name|out_des
parameter_list|)
block|{
name|int
name|bytes_written
decl_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_LONG_TAPE_DRIVER
specifier|static
name|long
name|output_bytes_before_lseek
init|=
literal|0
decl_stmt|;
comment|/* Some tape drivers seem to have a signed internal seek pointer and      they lose if it overflows and becomes negative (e.g. when writing       tapes> 2Gb).  Doing an lseek (des, 0, SEEK_SET) seems to reset the       seek pointer and prevent it from overflowing.  */
if|if
condition|(
name|output_is_special
operator|&&
operator|(
operator|(
name|output_bytes_before_lseek
operator|+=
name|output_size
operator|)
operator|>=
literal|1073741824L
operator|)
condition|)
block|{
name|lseek
argument_list|(
name|out_des
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|output_bytes_before_lseek
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|bytes_written
operator|=
name|rmtwrite
argument_list|(
name|out_des
argument_list|,
name|output_buffer
argument_list|,
name|output_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|!=
name|output_size
condition|)
block|{
name|int
name|rest_bytes_written
decl_stmt|;
name|int
name|rest_output_size
decl_stmt|;
if|if
condition|(
name|output_is_special
operator|&&
operator|(
name|bytes_written
operator|>=
literal|0
operator|||
operator|(
name|bytes_written
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|ENOSPC
operator|||
name|errno
operator|==
name|EIO
operator|||
name|errno
operator|==
name|ENXIO
operator|)
operator|)
operator|)
condition|)
block|{
name|get_next_reel
argument_list|(
name|out_des
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|>
literal|0
condition|)
name|rest_output_size
operator|=
name|output_size
operator|-
name|bytes_written
expr_stmt|;
else|else
name|rest_output_size
operator|=
name|output_size
expr_stmt|;
name|rest_bytes_written
operator|=
name|rmtwrite
argument_list|(
name|out_des
argument_list|,
name|output_buffer
argument_list|,
name|rest_output_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest_bytes_written
operator|!=
name|rest_output_size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"write error"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"write error"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_bytes
operator|+=
name|output_size
expr_stmt|;
name|out_buff
operator|=
name|output_buffer
expr_stmt|;
name|output_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|sparse_write
parameter_list|(
name|int
name|fildes
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|nbyte
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Write `output_size' bytes of `output_buffer' to file    descriptor OUT_DES and reset `output_size' and `out_buff'.    If `swapping_halfwords' or `swapping_bytes' is set,    do the appropriate swapping first.  Our callers have    to make sure to only set these flags if `output_size'     is appropriate (a multiple of 4 for `swapping_halfwords',    2 for `swapping_bytes').  The fact that DISK_IO_BLOCK_SIZE    must always be a multiple of 4 helps us (and our callers)    insure this.  */
end_comment

begin_function
name|void
name|disk_empty_output_buffer
parameter_list|(
name|int
name|out_des
parameter_list|)
block|{
name|int
name|bytes_written
decl_stmt|;
if|if
condition|(
name|swapping_halfwords
operator|||
name|swapping_bytes
condition|)
block|{
if|if
condition|(
name|swapping_halfwords
condition|)
block|{
name|int
name|complete_words
decl_stmt|;
name|complete_words
operator|=
name|output_size
operator|/
literal|4
expr_stmt|;
name|swahw_array
argument_list|(
name|output_buffer
argument_list|,
name|complete_words
argument_list|)
expr_stmt|;
if|if
condition|(
name|swapping_bytes
condition|)
name|swab_array
argument_list|(
name|output_buffer
argument_list|,
literal|2
operator|*
name|complete_words
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|complete_halfwords
decl_stmt|;
name|complete_halfwords
operator|=
name|output_size
operator|/
literal|2
expr_stmt|;
name|swab_array
argument_list|(
name|output_buffer
argument_list|,
name|complete_halfwords
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sparse_flag
condition|)
name|bytes_written
operator|=
name|sparse_write
argument_list|(
name|out_des
argument_list|,
name|output_buffer
argument_list|,
name|output_size
argument_list|)
expr_stmt|;
else|else
name|bytes_written
operator|=
name|write
argument_list|(
name|out_des
argument_list|,
name|output_buffer
argument_list|,
name|output_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|!=
name|output_size
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"write error"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_bytes
operator|+=
name|output_size
expr_stmt|;
name|out_buff
operator|=
name|output_buffer
expr_stmt|;
name|output_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exchange the halfwords of each element of the array of COUNT longs    starting at PTR.  PTR does not have to be aligned at a word    boundary.  */
end_comment

begin_function
name|void
name|swahw_array
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|char
name|tmp
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
block|{
name|tmp
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|=
name|tmp
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
name|tmp
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|=
name|tmp
expr_stmt|;
name|ptr
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read at most NUM_BYTES or `io_block_size' bytes, whichever is smaller,    into the start of `input_buffer' from file descriptor IN_DES.    Set `input_size' to the number of bytes read and reset `in_buff'.    Exit with an error if end of file is reached.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_LONG_TAPE_DRIVER
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|input_bytes_before_lseek
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|tape_fill_input_buffer
parameter_list|(
name|int
name|in_des
parameter_list|,
name|int
name|num_bytes
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BROKEN_LONG_TAPE_DRIVER
comment|/* Some tape drivers seem to have a signed internal seek pointer and      they lose if it overflows and becomes negative (e.g. when writing       tapes> 4Gb).  Doing an lseek (des, 0, SEEK_SET) seems to reset the       seek pointer and prevent it from overflowing.  */
if|if
condition|(
name|input_is_special
operator|&&
operator|(
operator|(
name|input_bytes_before_lseek
operator|+=
name|num_bytes
operator|)
operator|>=
literal|1073741824L
operator|)
condition|)
block|{
name|lseek
argument_list|(
name|in_des
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|input_bytes_before_lseek
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|in_buff
operator|=
name|input_buffer
expr_stmt|;
name|num_bytes
operator|=
operator|(
name|num_bytes
operator|<
name|io_block_size
operator|)
condition|?
name|num_bytes
else|:
name|io_block_size
expr_stmt|;
name|input_size
operator|=
name|rmtread
argument_list|(
name|in_des
argument_list|,
name|input_buffer
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_size
operator|==
literal|0
operator|&&
name|input_is_special
condition|)
block|{
name|get_next_reel
argument_list|(
name|in_des
argument_list|)
expr_stmt|;
name|input_size
operator|=
name|rmtread
argument_list|(
name|in_des
argument_list|,
name|input_buffer
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"read error"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"premature end of file"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|input_bytes
operator|+=
name|input_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read at most NUM_BYTES or `DISK_IO_BLOCK_SIZE' bytes, whichever is smaller,    into the start of `input_buffer' from file descriptor IN_DES.    Set `input_size' to the number of bytes read and reset `in_buff'.    Exit with an error if end of file is reached.  */
end_comment

begin_function
specifier|static
name|int
name|disk_fill_input_buffer
parameter_list|(
name|int
name|in_des
parameter_list|,
name|off_t
name|num_bytes
parameter_list|)
block|{
name|in_buff
operator|=
name|input_buffer
expr_stmt|;
name|num_bytes
operator|=
operator|(
name|num_bytes
operator|<
name|DISK_IO_BLOCK_SIZE
operator|)
condition|?
name|num_bytes
else|:
name|DISK_IO_BLOCK_SIZE
expr_stmt|;
name|input_size
operator|=
name|read
argument_list|(
name|in_des
argument_list|,
name|input_buffer
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_size
operator|<
literal|0
condition|)
block|{
name|input_size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|input_bytes
operator|+=
name|input_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy NUM_BYTES of buffer IN_BUF to `out_buff', which may be partly full.    When `out_buff' fills up, flush it to file descriptor OUT_DES.  */
end_comment

begin_function
name|void
name|tape_buffered_write
parameter_list|(
name|char
modifier|*
name|in_buf
parameter_list|,
name|int
name|out_des
parameter_list|,
name|off_t
name|num_bytes
parameter_list|)
block|{
name|off_t
name|bytes_left
init|=
name|num_bytes
decl_stmt|;
comment|/* Bytes needing to be copied.  */
name|off_t
name|space_left
decl_stmt|;
comment|/* Room left in output buffer.  */
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|space_left
operator|=
name|io_block_size
operator|-
name|output_size
expr_stmt|;
if|if
condition|(
name|space_left
operator|==
literal|0
condition|)
name|tape_empty_output_buffer
argument_list|(
name|out_des
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bytes_left
operator|<
name|space_left
condition|)
name|space_left
operator|=
name|bytes_left
expr_stmt|;
name|memcpy
argument_list|(
name|out_buff
argument_list|,
name|in_buf
argument_list|,
operator|(
name|unsigned
operator|)
name|space_left
argument_list|)
expr_stmt|;
name|out_buff
operator|+=
name|space_left
expr_stmt|;
name|output_size
operator|+=
name|space_left
expr_stmt|;
name|in_buf
operator|+=
name|space_left
expr_stmt|;
name|bytes_left
operator|-=
name|space_left
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Copy NUM_BYTES of buffer IN_BUF to `out_buff', which may be partly full.    When `out_buff' fills up, flush it to file descriptor OUT_DES.  */
end_comment

begin_function
name|void
name|disk_buffered_write
parameter_list|(
name|char
modifier|*
name|in_buf
parameter_list|,
name|int
name|out_des
parameter_list|,
name|off_t
name|num_bytes
parameter_list|)
block|{
name|off_t
name|bytes_left
init|=
name|num_bytes
decl_stmt|;
comment|/* Bytes needing to be copied.  */
name|off_t
name|space_left
decl_stmt|;
comment|/* Room left in output buffer.  */
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|space_left
operator|=
name|DISK_IO_BLOCK_SIZE
operator|-
name|output_size
expr_stmt|;
if|if
condition|(
name|space_left
operator|==
literal|0
condition|)
name|disk_empty_output_buffer
argument_list|(
name|out_des
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bytes_left
operator|<
name|space_left
condition|)
name|space_left
operator|=
name|bytes_left
expr_stmt|;
name|memcpy
argument_list|(
name|out_buff
argument_list|,
name|in_buf
argument_list|,
operator|(
name|unsigned
operator|)
name|space_left
argument_list|)
expr_stmt|;
name|out_buff
operator|+=
name|space_left
expr_stmt|;
name|output_size
operator|+=
name|space_left
expr_stmt|;
name|in_buf
operator|+=
name|space_left
expr_stmt|;
name|bytes_left
operator|-=
name|space_left
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Copy NUM_BYTES of buffer `in_buff' into IN_BUF.    `in_buff' may be partly full.    When `in_buff' is exhausted, refill it from file descriptor IN_DES.  */
end_comment

begin_function
name|void
name|tape_buffered_read
parameter_list|(
name|char
modifier|*
name|in_buf
parameter_list|,
name|int
name|in_des
parameter_list|,
name|off_t
name|num_bytes
parameter_list|)
block|{
name|off_t
name|bytes_left
init|=
name|num_bytes
decl_stmt|;
comment|/* Bytes needing to be copied.  */
name|off_t
name|space_left
decl_stmt|;
comment|/* Bytes to copy from input buffer.  */
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
name|tape_fill_input_buffer
argument_list|(
name|in_des
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|input_size
condition|)
name|space_left
operator|=
name|bytes_left
expr_stmt|;
else|else
name|space_left
operator|=
name|input_size
expr_stmt|;
name|memcpy
argument_list|(
name|in_buf
argument_list|,
name|in_buff
argument_list|,
operator|(
name|unsigned
operator|)
name|space_left
argument_list|)
expr_stmt|;
name|in_buff
operator|+=
name|space_left
expr_stmt|;
name|in_buf
operator|+=
name|space_left
expr_stmt|;
name|input_size
operator|-=
name|space_left
expr_stmt|;
name|bytes_left
operator|-=
name|space_left
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy the the next NUM_BYTES bytes of `input_buffer' into PEEK_BUF.    If NUM_BYTES bytes are not available, read the next `io_block_size' bytes    into the end of `input_buffer' and update `input_size'.     Return the number of bytes copied into PEEK_BUF.    If the number of bytes returned is less than NUM_BYTES,    then EOF has been reached.  */
end_comment

begin_function
name|int
name|tape_buffered_peek
parameter_list|(
name|char
modifier|*
name|peek_buf
parameter_list|,
name|int
name|in_des
parameter_list|,
name|int
name|num_bytes
parameter_list|)
block|{
name|long
name|tmp_input_size
decl_stmt|;
name|long
name|got_bytes
decl_stmt|;
name|char
modifier|*
name|append_buf
decl_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_LONG_TAPE_DRIVER
comment|/* Some tape drivers seem to have a signed internal seek pointer and      they lose if it overflows and becomes negative (e.g. when writing       tapes> 4Gb).  Doing an lseek (des, 0, SEEK_SET) seems to reset the       seek pointer and prevent it from overflowing.  */
if|if
condition|(
name|input_is_special
operator|&&
operator|(
operator|(
name|input_bytes_before_lseek
operator|+=
name|num_bytes
operator|)
operator|>=
literal|1073741824L
operator|)
condition|)
block|{
name|lseek
argument_list|(
name|in_des
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|input_bytes_before_lseek
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|input_size
operator|<
name|num_bytes
condition|)
block|{
name|append_buf
operator|=
name|in_buff
operator|+
name|input_size
expr_stmt|;
if|if
condition|(
operator|(
name|append_buf
operator|-
name|input_buffer
operator|)
operator|>=
name|input_buffer_size
condition|)
block|{
comment|/* We can keep up to 2 "blocks" (either the physical block size 	     or 512 bytes(the size of a tar record), which ever is 	     larger) in the input buffer when we are peeking.  We 	     assume that our caller will never be interested in peeking 	     ahead at more than 512 bytes, so we know that by the time 	     we need a 3rd "block" in the buffer we can throw away the 	     first block to make room.  */
name|int
name|half
decl_stmt|;
name|half
operator|=
name|input_buffer_size
operator|/
literal|2
expr_stmt|;
name|memmove
argument_list|(
name|input_buffer
argument_list|,
name|input_buffer
operator|+
name|half
argument_list|,
name|half
argument_list|)
expr_stmt|;
name|in_buff
operator|=
name|in_buff
operator|-
name|half
expr_stmt|;
name|append_buf
operator|=
name|append_buf
operator|-
name|half
expr_stmt|;
block|}
name|tmp_input_size
operator|=
name|rmtread
argument_list|(
name|in_des
argument_list|,
name|append_buf
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_input_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|input_is_special
condition|)
block|{
name|get_next_reel
argument_list|(
name|in_des
argument_list|)
expr_stmt|;
name|tmp_input_size
operator|=
name|rmtread
argument_list|(
name|in_des
argument_list|,
name|append_buf
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|tmp_input_size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"read error"
argument_list|)
argument_list|)
expr_stmt|;
name|input_bytes
operator|+=
name|tmp_input_size
expr_stmt|;
name|input_size
operator|+=
name|tmp_input_size
expr_stmt|;
block|}
if|if
condition|(
name|num_bytes
operator|<=
name|input_size
condition|)
name|got_bytes
operator|=
name|num_bytes
expr_stmt|;
else|else
name|got_bytes
operator|=
name|input_size
expr_stmt|;
name|memcpy
argument_list|(
name|peek_buf
argument_list|,
name|in_buff
argument_list|,
operator|(
name|unsigned
operator|)
name|got_bytes
argument_list|)
expr_stmt|;
return|return
name|got_bytes
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip the next NUM_BYTES bytes of file descriptor IN_DES.  */
end_comment

begin_function
name|void
name|tape_toss_input
parameter_list|(
name|int
name|in_des
parameter_list|,
name|off_t
name|num_bytes
parameter_list|)
block|{
name|off_t
name|bytes_left
init|=
name|num_bytes
decl_stmt|;
comment|/* Bytes needing to be copied.  */
name|off_t
name|space_left
decl_stmt|;
comment|/* Bytes to copy from input buffer.  */
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
name|tape_fill_input_buffer
argument_list|(
name|in_des
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|input_size
condition|)
name|space_left
operator|=
name|bytes_left
expr_stmt|;
else|else
name|space_left
operator|=
name|input_size
expr_stmt|;
if|if
condition|(
name|crc_i_flag
operator|&&
name|only_verify_crc_flag
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|space_left
condition|;
operator|++
name|k
control|)
name|crc
operator|+=
name|in_buff
index|[
name|k
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|in_buff
operator|+=
name|space_left
expr_stmt|;
name|input_size
operator|-=
name|space_left
expr_stmt|;
name|bytes_left
operator|-=
name|space_left
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|write_nuls_to_file
parameter_list|(
name|off_t
name|num_bytes
parameter_list|,
name|int
name|out_des
parameter_list|,
name|void
function_decl|(
modifier|*
name|writer
function_decl|)
parameter_list|(
name|char
modifier|*
name|in_buf
parameter_list|,
name|int
name|out_des
parameter_list|,
name|off_t
name|num_bytes
parameter_list|)
parameter_list|)
block|{
name|off_t
name|blocks
decl_stmt|;
name|off_t
name|extra_bytes
decl_stmt|;
name|off_t
name|i
decl_stmt|;
specifier|static
name|char
name|zeros_512
index|[
literal|512
index|]
decl_stmt|;
name|blocks
operator|=
name|num_bytes
operator|/
sizeof|sizeof
name|zeros_512
expr_stmt|;
name|extra_bytes
operator|=
name|num_bytes
operator|%
sizeof|sizeof
name|zeros_512
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blocks
condition|;
operator|++
name|i
control|)
name|writer
argument_list|(
name|zeros_512
argument_list|,
name|out_des
argument_list|,
sizeof|sizeof
name|zeros_512
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_bytes
condition|)
name|writer
argument_list|(
name|zeros_512
argument_list|,
name|out_des
argument_list|,
name|extra_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy a file using the input and output buffers, which may start out    partly full.  After the copy, the files are not closed nor the last    block flushed to output, and the input buffer may still be partly    full.  If `crc_i_flag' is set, add each byte to `crc'.    IN_DES is the file descriptor for input;    OUT_DES is the file descriptor for output;    NUM_BYTES is the number of bytes to copy.  */
end_comment

begin_function
name|void
name|copy_files_tape_to_disk
parameter_list|(
name|int
name|in_des
parameter_list|,
name|int
name|out_des
parameter_list|,
name|off_t
name|num_bytes
parameter_list|)
block|{
name|long
name|size
decl_stmt|;
name|long
name|k
decl_stmt|;
while|while
condition|(
name|num_bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
name|tape_fill_input_buffer
argument_list|(
name|in_des
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|input_size
operator|<
name|num_bytes
operator|)
condition|?
name|input_size
else|:
name|num_bytes
expr_stmt|;
if|if
condition|(
name|crc_i_flag
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
operator|++
name|k
control|)
name|crc
operator|+=
name|in_buff
index|[
name|k
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|disk_buffered_write
argument_list|(
name|in_buff
argument_list|,
name|out_des
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|num_bytes
operator|-=
name|size
expr_stmt|;
name|input_size
operator|-=
name|size
expr_stmt|;
name|in_buff
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy a file using the input and output buffers, which may start out    partly full.  After the copy, the files are not closed nor the last    block flushed to output, and the input buffer may still be partly    full.  If `crc_i_flag' is set, add each byte to `crc'.    IN_DES is the file descriptor for input;    OUT_DES is the file descriptor for output;    NUM_BYTES is the number of bytes to copy.  */
end_comment

begin_function
name|void
name|copy_files_disk_to_tape
parameter_list|(
name|int
name|in_des
parameter_list|,
name|int
name|out_des
parameter_list|,
name|off_t
name|num_bytes
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|long
name|size
decl_stmt|;
name|long
name|k
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|off_t
name|original_num_bytes
decl_stmt|;
name|original_num_bytes
operator|=
name|num_bytes
expr_stmt|;
while|while
condition|(
name|num_bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
if|if
condition|(
name|rc
operator|=
name|disk_fill_input_buffer
argument_list|(
name|in_des
argument_list|,
name|num_bytes
operator|<
name|DISK_IO_BLOCK_SIZE
condition|?
name|num_bytes
else|:
name|DISK_IO_BLOCK_SIZE
argument_list|)
condition|)
block|{
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ngettext
argument_list|(
literal|"File %s shrunk by %s byte, padding with zeros"
argument_list|,
literal|"File %s shrunk by %s bytes, padding with zeros"
argument_list|,
name|num_bytes
argument_list|)
argument_list|,
name|filename
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|num_bytes
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Read error at byte %lld in file %s, padding with zeros"
argument_list|)
argument_list|,
name|original_num_bytes
operator|-
name|num_bytes
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|write_nuls_to_file
argument_list|(
name|num_bytes
argument_list|,
name|out_des
argument_list|,
name|tape_buffered_write
argument_list|)
expr_stmt|;
break|break;
block|}
name|size
operator|=
operator|(
name|input_size
operator|<
name|num_bytes
operator|)
condition|?
name|input_size
else|:
name|num_bytes
expr_stmt|;
if|if
condition|(
name|crc_i_flag
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
operator|++
name|k
control|)
name|crc
operator|+=
name|in_buff
index|[
name|k
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|tape_buffered_write
argument_list|(
name|in_buff
argument_list|,
name|out_des
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|num_bytes
operator|-=
name|size
expr_stmt|;
name|input_size
operator|-=
name|size
expr_stmt|;
name|in_buff
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy a file using the input and output buffers, which may start out    partly full.  After the copy, the files are not closed nor the last    block flushed to output, and the input buffer may still be partly    full.  If `crc_i_flag' is set, add each byte to `crc'.    IN_DES is the file descriptor for input;    OUT_DES is the file descriptor for output;    NUM_BYTES is the number of bytes to copy.  */
end_comment

begin_function
name|void
name|copy_files_disk_to_disk
parameter_list|(
name|int
name|in_des
parameter_list|,
name|int
name|out_des
parameter_list|,
name|off_t
name|num_bytes
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|long
name|size
decl_stmt|;
name|long
name|k
decl_stmt|;
name|off_t
name|original_num_bytes
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|original_num_bytes
operator|=
name|num_bytes
expr_stmt|;
while|while
condition|(
name|num_bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
if|if
condition|(
name|rc
operator|=
name|disk_fill_input_buffer
argument_list|(
name|in_des
argument_list|,
name|num_bytes
argument_list|)
condition|)
block|{
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ngettext
argument_list|(
literal|"File %s shrunk by %s byte, padding with zeros"
argument_list|,
literal|"File %s shrunk by %s bytes, padding with zeros"
argument_list|,
name|num_bytes
argument_list|)
argument_list|,
name|filename
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|num_bytes
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Read error at byte %lld in file %s, padding with zeros"
argument_list|)
argument_list|,
name|original_num_bytes
operator|-
name|num_bytes
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|write_nuls_to_file
argument_list|(
name|num_bytes
argument_list|,
name|out_des
argument_list|,
name|disk_buffered_write
argument_list|)
expr_stmt|;
break|break;
block|}
name|size
operator|=
operator|(
name|input_size
operator|<
name|num_bytes
operator|)
condition|?
name|input_size
else|:
name|num_bytes
expr_stmt|;
if|if
condition|(
name|crc_i_flag
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
operator|++
name|k
control|)
name|crc
operator|+=
name|in_buff
index|[
name|k
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|disk_buffered_write
argument_list|(
name|in_buff
argument_list|,
name|out_des
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|num_bytes
operator|-=
name|size
expr_stmt|;
name|input_size
operator|-=
name|size
expr_stmt|;
name|in_buff
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Warn if file changed while it was being copied.  */
end_comment

begin_function
name|void
name|warn_if_file_changed
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|,
name|unsigned
name|long
name|old_file_size
parameter_list|,
name|off_t
name|old_file_mtime
parameter_list|)
block|{
name|struct
name|stat
name|new_file_stat
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|file_name
argument_list|,
operator|&
name|new_file_stat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|stat_error
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only check growth, shrinkage detected in copy_files_disk_to_{disk,tape}()    */
if|if
condition|(
name|new_file_stat
operator|.
name|st_size
operator|>
name|old_file_size
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ngettext
argument_list|(
literal|"File %s grew, %"
name|PRIuMAX
literal|" new byte not copied"
argument_list|,
literal|"File %s grew, %"
name|PRIuMAX
literal|" new bytes not copied"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|new_file_stat
operator|.
name|st_size
operator|-
name|old_file_size
argument_list|)
argument_list|)
argument_list|,
name|file_name
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|new_file_stat
operator|.
name|st_size
operator|-
name|old_file_size
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|new_file_stat
operator|.
name|st_mtime
operator|!=
name|old_file_mtime
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"File %s was modified while being copied"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create all directories up to but not including the last part of NAME.    Do not destroy any nondirectories while creating directories.  */
end_comment

begin_function
name|void
name|create_all_directories
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|HPUX_CDF
name|int
name|cdf
decl_stmt|;
endif|#
directive|endif
name|dir
operator|=
name|dir_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|0700
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUX_CDF
name|cdf
operator|=
name|islastparentcdf
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdf
condition|)
block|{
name|dir
index|[
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove final + */
name|mode
operator|=
literal|04700
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|dir
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|make_path
argument_list|(
name|dir
argument_list|,
name|mode
argument_list|,
literal|0700
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to append to an archive.  We have been in    process_copy_in, keeping track of the position where    the last header started in `last_header_start'.  Now we    have the starting position of the last header (the TRAILER!!!    header, or blank record for tar archives) and we want to start    writing (appending) over the last header.  The last header may    be in the middle of a block, so to keep the buffering in sync    we lseek back to the start of the block, read everything up    to but not including the last header, lseek back to the start    of the block, and then do a copy_buf_out of what we read.    Actually, we probably don't have to worry so much about keeping the    buffering perfect since you can only append to archives that    are disk files.  */
end_comment

begin_function
name|void
name|prepare_append
parameter_list|(
name|int
name|out_file_des
parameter_list|)
block|{
name|int
name|start_of_header
decl_stmt|;
name|int
name|start_of_block
decl_stmt|;
name|int
name|useful_bytes_in_block
decl_stmt|;
name|char
modifier|*
name|tmp_buf
decl_stmt|;
name|start_of_header
operator|=
name|last_header_start
expr_stmt|;
comment|/* Figure out how many bytes we will rewrite, and where they start.  */
name|useful_bytes_in_block
operator|=
name|start_of_header
operator|%
name|io_block_size
expr_stmt|;
name|start_of_block
operator|=
name|start_of_header
operator|-
name|useful_bytes_in_block
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|out_file_des
argument_list|,
name|start_of_block
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"cannot seek on output"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|useful_bytes_in_block
operator|>
literal|0
condition|)
block|{
name|tmp_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|useful_bytes_in_block
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|out_file_des
argument_list|,
name|tmp_buf
argument_list|,
name|useful_bytes_in_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|out_file_des
argument_list|,
name|start_of_block
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"cannot seek on output"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fix juo -- is this copy_tape_buf_out?  or copy_disk? */
name|tape_buffered_write
argument_list|(
name|tmp_buf
argument_list|,
name|out_file_des
argument_list|,
name|useful_bytes_in_block
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
block|}
comment|/* We are done reading the archive, so clear these since they      will now be used for reading in files that we are appending      to the archive.  */
name|input_size
operator|=
literal|0
expr_stmt|;
name|input_bytes
operator|=
literal|0
expr_stmt|;
name|in_buff
operator|=
name|input_buffer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support for remembering inodes with multiple links.  Used in the    "copy in" and "copy pass" modes for making links instead of copying    the file.  */
end_comment

begin_struct
struct|struct
name|inode_val
block|{
name|unsigned
name|long
name|inode
decl_stmt|;
name|unsigned
name|long
name|major_num
decl_stmt|;
name|unsigned
name|long
name|minor_num
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Inode hash table.  Allocated by first call to add_inode.  */
end_comment

begin_decl_stmt
specifier|static
name|Hash_table
modifier|*
name|hash_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|size_t
name|inode_val_hasher
parameter_list|(
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|size_t
name|n_buckets
parameter_list|)
block|{
specifier|const
name|struct
name|inode_val
modifier|*
name|ival
init|=
name|val
decl_stmt|;
return|return
name|ival
operator|->
name|inode
operator|%
name|n_buckets
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|inode_val_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|val1
parameter_list|,
specifier|const
name|void
modifier|*
name|val2
parameter_list|)
block|{
specifier|const
name|struct
name|inode_val
modifier|*
name|ival1
init|=
name|val1
decl_stmt|;
specifier|const
name|struct
name|inode_val
modifier|*
name|ival2
init|=
name|val2
decl_stmt|;
return|return
name|ival1
operator|->
name|inode
operator|==
name|ival2
operator|->
name|inode
operator|&&
name|ival1
operator|->
name|major_num
operator|==
name|ival2
operator|->
name|major_num
operator|&&
name|ival1
operator|->
name|minor_num
operator|==
name|ival2
operator|->
name|minor_num
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|find_inode_file
parameter_list|(
name|unsigned
name|long
name|node_num
parameter_list|,
name|unsigned
name|long
name|major_num
parameter_list|,
name|unsigned
name|long
name|minor_num
parameter_list|)
block|{
name|struct
name|inode_val
name|sample
decl_stmt|;
name|struct
name|inode_val
modifier|*
name|ival
decl_stmt|;
if|if
condition|(
operator|!
name|hash_table
condition|)
return|return
name|NULL
return|;
name|sample
operator|.
name|inode
operator|=
name|node_num
expr_stmt|;
name|sample
operator|.
name|major_num
operator|=
name|major_num
expr_stmt|;
name|sample
operator|.
name|minor_num
operator|=
name|minor_num
expr_stmt|;
name|ival
operator|=
name|hash_lookup
argument_list|(
name|hash_table
argument_list|,
operator|&
name|sample
argument_list|)
expr_stmt|;
return|return
name|ival
condition|?
name|ival
operator|->
name|file_name
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Associate FILE_NAME with the inode NODE_NUM.  (Insert into hash table.)  */
end_comment

begin_function
name|void
name|add_inode
parameter_list|(
name|unsigned
name|long
name|node_num
parameter_list|,
name|char
modifier|*
name|file_name
parameter_list|,
name|unsigned
name|long
name|major_num
parameter_list|,
name|unsigned
name|long
name|minor_num
parameter_list|)
block|{
name|struct
name|inode_val
modifier|*
name|temp
decl_stmt|;
name|struct
name|inode_val
modifier|*
name|e
decl_stmt|;
comment|/* Create new inode record.  */
name|temp
operator|=
operator|(
expr|struct
name|inode_val
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|inode_val
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|inode
operator|=
name|node_num
expr_stmt|;
name|temp
operator|->
name|major_num
operator|=
name|major_num
expr_stmt|;
name|temp
operator|->
name|minor_num
operator|=
name|minor_num
expr_stmt|;
name|temp
operator|->
name|file_name
operator|=
name|xstrdup
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|hash_table
operator|||
operator|(
name|hash_table
operator|=
name|hash_initialize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|inode_val_hasher
argument_list|,
name|inode_val_compare
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|e
operator|=
name|hash_insert
argument_list|(
name|hash_table
argument_list|,
name|temp
argument_list|)
operator|)
operator|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
comment|/* FIXME: e is not used */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open FILE in the mode specified by the command line options    and return an open file descriptor for it,    or -1 if it can't be opened.  */
end_comment

begin_function
name|int
name|open_archive
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|void
function_decl|(
modifier|*
name|copy_in
function_decl|)
parameter_list|()
function_decl|;
comment|/* Workaround for pcc bug.  */
name|copy_in
operator|=
name|process_copy_in
expr_stmt|;
if|if
condition|(
name|copy_function
operator|==
name|copy_in
condition|)
name|fd
operator|=
name|rmtopen
argument_list|(
name|file
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|append_flag
condition|)
name|fd
operator|=
name|rmtopen
argument_list|(
name|file
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_BINARY
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
else|else
name|fd
operator|=
name|rmtopen
argument_list|(
name|file
argument_list|,
name|O_RDWR
operator||
name|O_BINARY
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* Attempt to rewind the tape drive on file descriptor TAPE_DES    and take it offline.  */
end_comment

begin_function
name|void
name|tape_offline
parameter_list|(
name|int
name|tape_des
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MTIOCTOP
argument_list|)
operator|&&
name|defined
argument_list|(
name|MTOFFL
argument_list|)
name|struct
name|mtop
name|control
decl_stmt|;
name|control
operator|.
name|mt_op
operator|=
name|MTOFFL
expr_stmt|;
name|control
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
name|rmtioctl
argument_list|(
name|tape_des
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|control
argument_list|)
expr_stmt|;
comment|/* Don't care if it fails.  */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The file on file descriptor TAPE_DES is assumed to be magnetic tape    (or floppy disk or other device) and the end of the medium    has been reached.  Ask the user for to mount a new "tape" to continue    the processing.  If the user specified the device name on the    command line (with the -I, -O, -F or --file options), then we can    automatically re-open the same device to use the next medium.  If the    user did not specify the device name, then we have to ask them which    device to use.  */
end_comment

begin_function
name|void
name|get_next_reel
parameter_list|(
name|int
name|tape_des
parameter_list|)
block|{
specifier|static
name|int
name|reel_number
init|=
literal|1
decl_stmt|;
name|FILE
modifier|*
name|tty_in
decl_stmt|;
comment|/* File for interacting with user.  */
name|FILE
modifier|*
name|tty_out
decl_stmt|;
comment|/* File for interacting with user.  */
name|int
name|old_tape_des
decl_stmt|;
name|char
modifier|*
name|next_archive_name
decl_stmt|;
name|dynamic_string
name|new_name
decl_stmt|;
name|char
modifier|*
name|str_res
decl_stmt|;
name|ds_init
argument_list|(
operator|&
name|new_name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
comment|/* Open files for interactive communication.  */
name|tty_in
operator|=
name|fopen
argument_list|(
name|TTY_NAME
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_in
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|TTY_NAME
argument_list|)
expr_stmt|;
name|tty_out
operator|=
name|fopen
argument_list|(
name|TTY_NAME
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_out
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|TTY_NAME
argument_list|)
expr_stmt|;
name|old_tape_des
operator|=
name|tape_des
expr_stmt|;
name|tape_offline
argument_list|(
name|tape_des
argument_list|)
expr_stmt|;
name|rmtclose
argument_list|(
name|tape_des
argument_list|)
expr_stmt|;
comment|/* Give message and wait for carrage return.  User should hit carrage return      only after loading the next tape.  */
operator|++
name|reel_number
expr_stmt|;
if|if
condition|(
name|new_media_message
condition|)
name|fprintf
argument_list|(
name|tty_out
argument_list|,
literal|"%s"
argument_list|,
name|new_media_message
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|new_media_message_with_number
condition|)
name|fprintf
argument_list|(
name|tty_out
argument_list|,
literal|"%s%d%s"
argument_list|,
name|new_media_message_with_number
argument_list|,
name|reel_number
argument_list|,
name|new_media_message_after_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_name
condition|)
name|fprintf
argument_list|(
name|tty_out
argument_list|,
name|_
argument_list|(
literal|"Found end of volume.  Load next volume and press RETURN. "
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|tty_out
argument_list|,
name|_
argument_list|(
literal|"Found end of volume.  To continue, type device/file name when ready.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|tty_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_name
condition|)
block|{
name|int
name|c
decl_stmt|;
do|do
name|c
operator|=
name|getc
argument_list|(
name|tty_in
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
do|;
name|tape_des
operator|=
name|open_archive
argument_list|(
name|archive_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_des
operator|==
operator|-
literal|1
condition|)
name|open_error
argument_list|(
name|archive_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|tape_des
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|tty_out
argument_list|,
name|_
argument_list|(
literal|"To continue, type device/file name when ready.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|tty_out
argument_list|)
expr_stmt|;
block|}
name|str_res
operator|=
name|ds_fgets
argument_list|(
name|tty_in
argument_list|,
operator|&
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_res
operator|==
name|NULL
operator|||
name|str_res
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|next_archive_name
operator|=
name|str_res
expr_stmt|;
name|tape_des
operator|=
name|open_archive
argument_list|(
name|next_archive_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_des
operator|==
operator|-
literal|1
condition|)
name|open_error
argument_list|(
name|next_archive_name
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tape_des
operator|<
literal|0
condition|)
do|;
block|}
comment|/* We have to make sure that `tape_des' has not changed its value even      though we closed it and reopened it, since there are local      copies of it in other routines.  This works fine on Unix (even with      rmtread and rmtwrite) since open will always return the lowest      available file descriptor and we haven't closed any files (e.g.,      stdin, stdout or stderr) that were opened before we originally opened      the archive.  */
if|if
condition|(
name|tape_des
operator|!=
name|old_tape_des
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"internal error: tape descriptor changed from %d to %d"
argument_list|)
argument_list|,
name|old_tape_des
argument_list|,
name|tape_des
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tty_in
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tty_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If MESSAGE does not contain the string "%d", make `new_media_message'    a copy of MESSAGE.  If MESSAGES does contain the string "%d", make    `new_media_message_with_number' a copy of MESSAGE up to, but    not including, the string "%d", and make `new_media_message_after_number'    a copy of MESSAGE after the string "%d".  */
end_comment

begin_function
name|void
name|set_new_media_message
parameter_list|(
name|char
modifier|*
name|message
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|prev_was_percent
decl_stmt|;
name|p
operator|=
name|message
expr_stmt|;
name|prev_was_percent
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'d'
operator|&&
name|prev_was_percent
condition|)
break|break;
name|prev_was_percent
operator|=
operator|(
operator|*
name|p
operator|==
literal|'%'
operator|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|new_media_message
operator|=
name|xstrdup
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|length
init|=
name|p
operator|-
name|message
operator|-
literal|1
decl_stmt|;
name|new_media_message_with_number
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_media_message_with_number
argument_list|,
name|message
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|new_media_message_with_number
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_media_message_after_number
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_media_message_after_number
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYMLINK_USES_UMASK
end_ifdef

begin_comment
comment|/* Most machines always create symlinks with rwxrwxrwx protection,    but some (HP/UX 8.07; maybe DEC's OSF on MIPS, too?) use the    umask when creating symlinks, so if your umask is 022 you end    up with rwxr-xr-x symlinks (although HP/UX seems to completely    ignore the protection).  There doesn't seem to be any way to    manipulate the modes once the symlinks are created (e.g.    a hypothetical "lchmod"), so to create them with the right    modes we have to set the umask first.  */
end_comment

begin_function
name|int
name|umasked_symlink
parameter_list|(
name|char
modifier|*
name|name1
parameter_list|,
name|char
modifier|*
name|name2
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|old_umask
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mode
operator|=
operator|~
operator|(
name|mode
operator|&
literal|0777
operator|)
operator|&
literal|0777
expr_stmt|;
name|old_umask
operator|=
name|umask
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|rc
operator|=
name|symlink
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|old_umask
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYMLINK_USES_UMASK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX_CDF
end_ifdef

begin_comment
comment|/* When we create a cpio archive we mark CDF's by putting an extra `/'    after their component name so we can distinguish the CDF's when we    extract the archive (in case the "hidden" directory's files appear    in the archive before the directory itself).  E.g., in the path    "a/b+/c", if b+ is a CDF, we will write this path as "a/b+//c" in    the archive so when we extract the archive we will know that b+    is actually a CDF, and not an ordinary directory whose name happens    to end in `+'.  We also do the same thing internally in copypass.c.  */
end_comment

begin_comment
comment|/* Take an input pathname and check it for CDF's.  Insert an extra    `/' in the pathname after each "hidden" directory.  If we add    any `/'s, return a malloced string instead of the original input    string.    FIXME: This creates a memory leak. */
end_comment

begin_function
name|char
modifier|*
name|add_cdf_double_slashes
parameter_list|(
name|char
modifier|*
name|input_name
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|ret_name
init|=
name|NULL
decl_stmt|;
comment|/* re-usuable return buffer (malloc'ed)  */
specifier|static
name|int
name|ret_size
init|=
operator|-
literal|1
decl_stmt|;
comment|/* size of return buffer.  */
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|stat
name|dir_stat
decl_stmt|;
comment|/*  Search for a `/' preceeded by a `+'.  */
for|for
control|(
name|p
operator|=
name|input_name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'/'
operator|)
condition|)
break|break;
block|}
comment|/* If we didn't find a `/' preceeded by a `+' then there are      no CDF's in this pathname.  Return the original pathname.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|input_name
return|;
comment|/* There was a `/' preceeded by a `+' in the pathname.  If it is a CDF       then we will need to copy the input pathname to our return      buffer so we can insert the extra `/'s.  Since we can't tell      yet whether or not it is a CDF we will just always copy the      string to the return buffer.  First we have to make sure the      buffer is large enough to hold the string and any number of      extra `/'s we might add.  */
name|n
operator|=
literal|2
operator|*
operator|(
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|ret_size
condition|)
block|{
if|if
condition|(
name|ret_size
operator|<
literal|0
condition|)
name|ret_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|ret_name
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ret_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ret_size
operator|=
name|n
expr_stmt|;
block|}
comment|/* Clear the `/' after this component, so we can stat the pathname       up to and including this component.  */
operator|++
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|input_name
argument_list|,
operator|&
name|dir_stat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|stat_error
argument_list|(
name|input_name
argument_list|)
expr_stmt|;
return|return
name|input_name
return|;
block|}
comment|/* Now put back the `/' after this component and copy the pathname up to      and including this component and its trailing `/' to the return      buffer.  */
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strncpy
argument_list|(
name|ret_name
argument_list|,
name|input_name
argument_list|,
name|p
operator|-
name|input_name
argument_list|)
expr_stmt|;
name|q
operator|=
name|ret_name
operator|+
operator|(
name|p
operator|-
name|input_name
operator|)
expr_stmt|;
comment|/* If it was a CDF, add another `/'.  */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|dir_stat
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|dir_stat
operator|.
name|st_mode
operator|&
literal|04000
operator|)
condition|)
operator|*
name|q
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* Go through the rest of the input pathname, copying it to the      return buffer, and adding an extra `/' after each CDF.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'/'
operator|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|input_name
argument_list|,
operator|&
name|dir_stat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|stat_error
argument_list|(
name|input_name
argument_list|)
expr_stmt|;
return|return
name|input_name
return|;
block|}
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|dir_stat
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|dir_stat
operator|.
name|st_mode
operator|&
literal|04000
operator|)
condition|)
operator|*
name|q
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret_name
return|;
block|}
end_function

begin_comment
comment|/* Is the last parent directory (e.g., c in a/b/c/d) a CDF?  If the    directory name ends in `+' and is followed by 2 `/'s instead of 1    then it is.  This is only the case for cpio archives, but we don't    have to worry about tar because tar always has the directory before    its files (or else we lose).  */
end_comment

begin_function
name|int
name|islastparentcdf
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|int
name|slash_count
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Length of result, not including NUL.  */
name|slash
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|slash_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|slash
operator|>
name|path
operator|&&
operator|*
name|slash
operator|==
literal|'/'
condition|)
block|{
operator|++
name|slash_count
expr_stmt|;
operator|--
name|slash
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|slash
operator|==
literal|'+'
operator|)
operator|&&
operator|(
name|slash_count
operator|>=
literal|2
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DISKBLOCKSIZE
value|(512)
end_define

begin_function
specifier|static
name|int
name|buf_all_zeros
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufsize
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bufsize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
name|buf
operator|++
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|int
name|delayed_seek_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write NBYTE bytes from BUF to remote tape connection FILDES.    Return the number of bytes written on success, -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|sparse_write
parameter_list|(
name|int
name|fildes
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|nbyte
parameter_list|)
block|{
name|int
name|complete_block_count
decl_stmt|;
name|int
name|leftover_bytes_count
decl_stmt|;
name|int
name|seek_count
decl_stmt|;
name|int
name|write_count
decl_stmt|;
name|char
modifier|*
name|cur_write_start
decl_stmt|;
name|int
name|lseek_rc
decl_stmt|;
name|int
name|write_rc
decl_stmt|;
name|int
name|i
decl_stmt|;
enum|enum
block|{
name|begin
block|,
name|in_zeros
block|,
name|not_in_zeros
block|}
name|state
enum|;
name|complete_block_count
operator|=
name|nbyte
operator|/
name|DISKBLOCKSIZE
expr_stmt|;
name|leftover_bytes_count
operator|=
name|nbyte
operator|%
name|DISKBLOCKSIZE
expr_stmt|;
if|if
condition|(
name|delayed_seek_count
operator|!=
literal|0
condition|)
name|state
operator|=
name|in_zeros
expr_stmt|;
else|else
name|state
operator|=
name|begin
expr_stmt|;
name|seek_count
operator|=
name|delayed_seek_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|complete_block_count
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|begin
case|:
if|if
condition|(
name|buf_all_zeros
argument_list|(
name|buf
argument_list|,
name|DISKBLOCKSIZE
argument_list|)
condition|)
block|{
name|seek_count
operator|=
name|DISKBLOCKSIZE
expr_stmt|;
name|state
operator|=
name|in_zeros
expr_stmt|;
block|}
else|else
block|{
name|cur_write_start
operator|=
name|buf
expr_stmt|;
name|write_count
operator|=
name|DISKBLOCKSIZE
expr_stmt|;
name|state
operator|=
name|not_in_zeros
expr_stmt|;
block|}
name|buf
operator|+=
name|DISKBLOCKSIZE
expr_stmt|;
break|break;
case|case
name|in_zeros
case|:
if|if
condition|(
name|buf_all_zeros
argument_list|(
name|buf
argument_list|,
name|DISKBLOCKSIZE
argument_list|)
condition|)
block|{
name|seek_count
operator|+=
name|DISKBLOCKSIZE
expr_stmt|;
block|}
else|else
block|{
name|lseek
argument_list|(
name|fildes
argument_list|,
name|seek_count
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|cur_write_start
operator|=
name|buf
expr_stmt|;
name|write_count
operator|=
name|DISKBLOCKSIZE
expr_stmt|;
name|state
operator|=
name|not_in_zeros
expr_stmt|;
block|}
name|buf
operator|+=
name|DISKBLOCKSIZE
expr_stmt|;
break|break;
case|case
name|not_in_zeros
case|:
if|if
condition|(
name|buf_all_zeros
argument_list|(
name|buf
argument_list|,
name|DISKBLOCKSIZE
argument_list|)
condition|)
block|{
name|write_rc
operator|=
name|write
argument_list|(
name|fildes
argument_list|,
name|cur_write_start
argument_list|,
name|write_count
argument_list|)
expr_stmt|;
name|seek_count
operator|=
name|DISKBLOCKSIZE
expr_stmt|;
name|state
operator|=
name|in_zeros
expr_stmt|;
block|}
else|else
block|{
name|write_count
operator|+=
name|DISKBLOCKSIZE
expr_stmt|;
block|}
name|buf
operator|+=
name|DISKBLOCKSIZE
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|begin
case|:
case|case
name|in_zeros
case|:
name|delayed_seek_count
operator|=
name|seek_count
expr_stmt|;
break|break;
case|case
name|not_in_zeros
case|:
name|write_rc
operator|=
name|write
argument_list|(
name|fildes
argument_list|,
name|cur_write_start
argument_list|,
name|write_count
argument_list|)
expr_stmt|;
name|delayed_seek_count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|leftover_bytes_count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|delayed_seek_count
operator|!=
literal|0
condition|)
block|{
name|lseek_rc
operator|=
name|lseek
argument_list|(
name|fildes
argument_list|,
name|delayed_seek_count
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|delayed_seek_count
operator|=
literal|0
expr_stmt|;
block|}
name|write_rc
operator|=
name|write
argument_list|(
name|fildes
argument_list|,
name|buf
argument_list|,
name|leftover_bytes_count
argument_list|)
expr_stmt|;
block|}
return|return
name|nbyte
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CPIO_UID
parameter_list|(
name|uid
parameter_list|)
value|(set_owner_flag ? set_owner : (uid))
end_define

begin_define
define|#
directive|define
name|CPIO_GID
parameter_list|(
name|gid
parameter_list|)
value|(set_group_flag ? set_group : (gid))
end_define

begin_function
name|void
name|stat_to_cpio
parameter_list|(
name|struct
name|cpio_file_stat
modifier|*
name|hdr
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|hdr
operator|->
name|c_dev_maj
operator|=
name|major
argument_list|(
name|st
operator|->
name|st_dev
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|c_dev_min
operator|=
name|minor
argument_list|(
name|st
operator|->
name|st_dev
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|c_ino
operator|=
name|st
operator|->
name|st_ino
expr_stmt|;
comment|/* For POSIX systems that don't define the S_IF macros,      we can't assume that S_ISfoo means the standard Unix      S_IFfoo bit(s) are set.  So do it manually, with a      different name.  Bleah.  */
name|hdr
operator|->
name|c_mode
operator|=
operator|(
name|st
operator|->
name|st_mode
operator|&
literal|07777
operator|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
name|hdr
operator|->
name|c_mode
operator||=
name|CP_IFREG
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
name|hdr
operator|->
name|c_mode
operator||=
name|CP_IFDIR
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISBLK
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
name|hdr
operator|->
name|c_mode
operator||=
name|CP_IFBLK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISCHR
elseif|else
if|if
condition|(
name|S_ISCHR
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
name|hdr
operator|->
name|c_mode
operator||=
name|CP_IFCHR
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISFIFO
elseif|else
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
name|hdr
operator|->
name|c_mode
operator||=
name|CP_IFIFO
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISLNK
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
name|hdr
operator|->
name|c_mode
operator||=
name|CP_IFLNK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISSOCK
elseif|else
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
name|hdr
operator|->
name|c_mode
operator||=
name|CP_IFSOCK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISNWK
elseif|else
if|if
condition|(
name|S_ISNWK
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
name|hdr
operator|->
name|c_mode
operator||=
name|CP_IFNWK
expr_stmt|;
endif|#
directive|endif
name|hdr
operator|->
name|c_uid
operator|=
name|CPIO_UID
argument_list|(
name|st
operator|->
name|st_uid
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|c_gid
operator|=
name|CPIO_GID
argument_list|(
name|st
operator|->
name|st_gid
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|c_nlink
operator|=
name|st
operator|->
name|st_nlink
expr_stmt|;
name|hdr
operator|->
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|st
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|st
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|c_mtime
operator|=
name|st
operator|->
name|st_mtime
expr_stmt|;
name|hdr
operator|->
name|c_filesize
operator|=
name|st
operator|->
name|st_size
expr_stmt|;
name|hdr
operator|->
name|c_chksum
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|c_tar_linkname
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_FCHOWN
end_ifndef

begin_define
define|#
directive|define
name|fchown
parameter_list|(
name|fd
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|)
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|fchown_or_chown
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|uid_t
name|gid
parameter_list|)
block|{
if|if
condition|(
name|HAVE_FCHOWN
operator|&&
name|fd
operator|!=
operator|-
literal|1
condition|)
return|return
name|fchown
argument_list|(
name|fd
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
return|;
else|else
return|return
name|chown
argument_list|(
name|name
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|fchmod_or_chmod
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
if|if
condition|(
name|HAVE_FCHMOD
operator|&&
name|fd
operator|!=
operator|-
literal|1
condition|)
return|return
name|fchmod
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|)
return|;
else|else
return|return
name|chmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|set_perms
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|cpio_file_stat
modifier|*
name|header
parameter_list|)
block|{
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
block|{
name|uid_t
name|uid
init|=
name|CPIO_UID
argument_list|(
name|header
operator|->
name|c_uid
argument_list|)
decl_stmt|;
name|gid_t
name|gid
init|=
name|CPIO_GID
argument_list|(
name|header
operator|->
name|c_gid
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fchown_or_chown
argument_list|(
name|fd
argument_list|,
name|header
operator|->
name|c_name
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|chown_error_details
argument_list|(
name|header
operator|->
name|c_name
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
comment|/* chown may have turned off some permissions we wanted. */
if|if
condition|(
name|fchmod_or_chmod
argument_list|(
name|fd
argument_list|,
name|header
operator|->
name|c_name
argument_list|,
name|header
operator|->
name|c_mode
argument_list|)
operator|<
literal|0
condition|)
name|chmod_error_details
argument_list|(
name|header
operator|->
name|c_name
argument_list|,
name|header
operator|->
name|c_mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUX_CDF
if|if
condition|(
operator|(
name|header
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|&&
name|cdf_flag
condition|)
comment|/* Once we "hide" the directory with the chmod(),        we have to refer to it using name+ instead of name.  */
name|file_hdr
operator|->
name|c_name
index|[
name|cdf_char
index|]
operator|=
literal|'+'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retain_time_flag
condition|)
name|set_file_times
argument_list|(
name|fd
argument_list|,
name|header
operator|->
name|c_name
argument_list|,
name|header
operator|->
name|c_mtime
argument_list|,
name|header
operator|->
name|c_mtime
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_file_times
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|long
name|atime
parameter_list|,
name|unsigned
name|long
name|mtime
parameter_list|)
block|{
name|struct
name|timespec
name|ts
index|[
literal|2
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ts
argument_list|)
expr_stmt|;
name|ts
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|atime
expr_stmt|;
name|ts
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|mtime
expr_stmt|;
comment|/* Silently ignore EROFS because reading the file won't have upset its       timestamp if it's on a read-only filesystem. */
if|if
condition|(
name|gl_futimens
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|ts
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EROFS
condition|)
name|utime_error
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do we have to ignore absolute paths, and if so, does the filename    have an absolute path?  */
end_comment

begin_function
name|void
name|cpio_safer_name_suffix
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|link_target
parameter_list|,
name|bool
name|absolute_names
parameter_list|,
name|bool
name|strip_leading_dots
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|safer_name_suffix
argument_list|(
name|name
argument_list|,
name|link_target
argument_list|,
name|absolute_names
argument_list|)
decl_stmt|;
if|if
condition|(
name|strip_leading_dots
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"./"
argument_list|)
condition|)
comment|/* strip leading `./' from the filename.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'/'
condition|)
block|{
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|name
condition|)
name|memmove
argument_list|(
name|name
argument_list|,
name|p
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

