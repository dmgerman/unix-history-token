begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* main.c - main program and argument processing for cpio.    Copyright (C) 1990, 1991, 1992, 2001, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public    License along with this program; if not, write to the Free    Software Foundation, Inc., 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301 USA.  */
end_comment

begin_comment
comment|/* Written by Phil Nelson<phil@cs.wwu.edu>,    David MacKenzie<djm@gnu.ai.mit.edu>,    John Oleynick<juo@klinzhai.rutgers.edu>,    and Sergey Poznyakoff<gray@mirddin.farlep.net> */
end_comment

begin_include
include|#
directive|include
file|<system.h>
end_include

begin_include
include|#
directive|include
file|<paxlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<argp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LOCALE_H
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"filetypes.h"
end_include

begin_include
include|#
directive|include
file|"cpiohdr.h"
end_include

begin_include
include|#
directive|include
file|"dstring.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|<rmt.h>
end_include

begin_include
include|#
directive|include
file|<rmt-command.h>
end_include

begin_enum
enum|enum
name|cpio_options
block|{
name|NO_ABSOLUTE_FILENAMES_OPTION
init|=
literal|256
block|,
name|ABSOLUTE_FILENAMES_OPTION
block|,
name|NO_PRESERVE_OWNER_OPTION
block|,
name|ONLY_VERIFY_CRC_OPTION
block|,
name|RENAME_BATCH_FILE_OPTION
block|,
name|RSH_COMMAND_OPTION
block|,
name|QUIET_OPTION
block|,
name|SPARSE_OPTION
block|,
name|FORCE_LOCAL_OPTION
block|,
name|DEBUG_OPTION
block|,
name|BLOCK_SIZE_OPTION
block|,
name|TO_STDOUT_OPTION
block|,
name|HANG_OPTION
block|,
name|USAGE_OPTION
block|,
name|LICENSE_OPTION
block|,
name|VERSION_OPTION
block|}
enum|;
end_enum

begin_decl_stmt
specifier|const
name|char
modifier|*
name|argp_program_version
init|=
literal|"cpio ("
name|PACKAGE_NAME
literal|") "
name|VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|argp_program_bug_address
init|=
literal|"<"
name|PACKAGE_BUGREPORT
literal|">"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|doc
index|[]
init|=
name|N_
argument_list|(
literal|"GNU `cpio' copies files to and from archives\n\ \n\ Examples:\n\   # Copy files named in name-list to the archive\n\   cpio -o< name-list [> archive]\n\   # Extract files from the archive\n\   cpio -i [< archive]\n\   # Copy files named in name-list to destination-directory\n\   cpio -p destination-directory< name-list\n"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Print usage error message and exit with error.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_USAGE
parameter_list|(
name|cond
parameter_list|,
name|opt
parameter_list|,
name|mode_opt
parameter_list|)
define|\
value|if (cond) \    ERROR((PAXEXIT_FAILURE, 0, _("%s is meaningless with %s"), opt, mode_opt));
end_define

begin_decl_stmt
specifier|static
name|struct
name|argp_option
name|options
index|[]
init|=
block|{
comment|/* ********** */
define|#
directive|define
name|GRID
value|10
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Main operation mode:"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"create"
block|,
literal|'o'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Create the archive (run in copy-out mode)"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"extract"
block|,
literal|'i'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Extract files from an archive (run in copy-in mode)"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"pass-through"
block|,
literal|'p'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Run in copy-pass mode"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"list"
block|,
literal|'t'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Print a table of contents of the input"
argument_list|)
block|,
name|GRID
block|}
block|,
undef|#
directive|undef
name|GRID
comment|/* ********** */
define|#
directive|define
name|GRID
value|100
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Operation modifiers valid in any mode:"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"file"
block|,
literal|'F'
block|,
name|N_
argument_list|(
literal|"[[USER@]HOST:]FILE-NAME"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Use this FILE-NAME instead of standard input or output. Optional USER and HOST specify the user and host names in case of a remote archive"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"force-local"
block|,
name|FORCE_LOCAL_OPTION
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Archive file is local, even if its name contains colons"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"format"
block|,
literal|'H'
block|,
name|N_
argument_list|(
literal|"FORMAT"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Use given archive FORMAT"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|'B'
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Set the I/O block size to 5120 bytes"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"block-size"
block|,
name|BLOCK_SIZE_OPTION
block|,
name|N_
argument_list|(
literal|"BLOCK-SIZE"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Set the I/O block size to BLOCK-SIZE * 512 bytes"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|'c'
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Use the old portable (ASCII) archive format"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"dot"
block|,
literal|'V'
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Print a \".\" for each file processed"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"io-size"
block|,
literal|'C'
block|,
name|N_
argument_list|(
literal|"NUMBER"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Set the I/O block size to the given NUMBER of bytes"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"message"
block|,
literal|'M'
block|,
name|N_
argument_list|(
literal|"STRING"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Print STRING when the end of a volume of the backup media is reached"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"nonmatching"
block|,
literal|'f'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Only copy files that do not match any of the given patterns"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"numeric-uid-gid"
block|,
literal|'n'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"In the verbose table of contents listing, show numeric UID and GID"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"rsh-command"
block|,
name|RSH_COMMAND_OPTION
block|,
name|N_
argument_list|(
literal|"COMMAND"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Use remote COMMAND instead of rsh"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"quiet"
block|,
name|QUIET_OPTION
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Do not print the number of blocks copied"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"verbose"
block|,
literal|'v'
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Verbosely list the files processed"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|DEBUG_CPIO
block|{
literal|"debug"
block|,
name|DEBUG_OPTION
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Enable debugging info"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
endif|#
directive|endif
block|{
literal|"warning"
block|,
literal|'W'
block|,
name|N_
argument_list|(
literal|"FLAG"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Control warning display. Currently FLAG is one of 'none', 'truncate', 'all'. Multiple options accumulate."
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
undef|#
directive|undef
name|GRID
comment|/* ********** */
define|#
directive|define
name|GRID
value|200
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Operation modifiers valid only in copy-in mode:"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"pattern-file"
block|,
literal|'E'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Read additional patterns specifying filenames to extract or list from FILE"
argument_list|)
block|,
literal|210
block|}
block|,
block|{
literal|"absolute-filenames"
block|,
name|ABSOLUTE_FILENAMES_OPTION
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do not strip leading file name components that contain \"..\" and leading slashes from file names"
argument_list|)
block|,
literal|210
block|}
block|,
block|{
literal|"only-verify-crc"
block|,
name|ONLY_VERIFY_CRC_OPTION
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"When reading a CRC format archive, only verify the CRC's of each file in the archive, don't actually extract the files"
argument_list|)
block|,
literal|210
block|}
block|,
block|{
literal|"rename"
block|,
literal|'r'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Interactively rename files"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"rename-batch-file"
block|,
name|RENAME_BATCH_FILE_OPTION
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|OPTION_HIDDEN
block|,
literal|""
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"swap"
block|,
literal|'b'
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Swap both halfwords of words and bytes of halfwords in the data. Equivalent to -sS"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"swap-bytes"
block|,
literal|'s'
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Swap the bytes of each halfword in the files"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"swap-halfwords"
block|,
literal|'S'
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Swap the halfwords of each word (4 bytes) in the files"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"to-stdout"
block|,
name|TO_STDOUT_OPTION
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Extract files to standard output"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
undef|#
directive|undef
name|GRID
comment|/* ********** */
define|#
directive|define
name|GRID
value|300
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Operation modifiers valid only in copy-out mode:"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"append"
block|,
literal|'A'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Append to an existing archive."
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|'O'
block|,
name|N_
argument_list|(
literal|"[[USER@]HOST:]FILE-NAME"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Archive filename to use instead of standard output. Optional USER and HOST specify the user and host names in case of a remote archive"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
undef|#
directive|undef
name|GRID
comment|/* ********** */
define|#
directive|define
name|GRID
value|400
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Operation modifiers valid only in copy-pass mode:"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"link"
block|,
literal|'l'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Link files instead of copying them, when  possible"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
undef|#
directive|undef
name|GRID
comment|/* ********** */
define|#
directive|define
name|GRID
value|500
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Operation modifiers valid in copy-in and copy-out modes:"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"absolute-filenames"
block|,
name|ABSOLUTE_FILENAMES_OPTION
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Do not strip file system prefix components from the file names"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"no-absolute-filenames"
block|,
name|NO_ABSOLUTE_FILENAMES_OPTION
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Create all files relative to the current directory"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
undef|#
directive|undef
name|GRID
comment|/* ********** */
define|#
directive|define
name|GRID
value|600
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Operation modifiers valid in copy-out and copy-pass modes:"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"null"
block|,
literal|'0'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"A list of filenames is terminated by a null character instead of a newline"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|'I'
block|,
name|N_
argument_list|(
literal|"[[USER@]HOST:]FILE-NAME"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Archive filename to use instead of standard input. Optional USER and HOST specify the user and host names in case of a remote archive"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"dereference"
block|,
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Dereference  symbolic  links  (copy  the files that they point to instead of copying the links)."
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"owner"
block|,
literal|'R'
block|,
name|N_
argument_list|(
literal|"[USER][:.][GROUP]"
argument_list|)
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Set the ownership of all files created to the specified USER and/or GROUP"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"reset-access-time"
block|,
literal|'a'
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Reset the access times of files after reading them"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
undef|#
directive|undef
name|GRID
comment|/* ********** */
define|#
directive|define
name|GRID
value|700
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Operation modifiers valid in copy-in and copy-pass modes:"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"preserve-modification-time"
block|,
literal|'m'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Retain previous file modification times when creating files"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"make-directories"
block|,
literal|'d'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Create leading directories where needed"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"no-preserve-owner"
block|,
name|NO_PRESERVE_OWNER_OPTION
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Do not change the ownership of the files"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"unconditional"
block|,
literal|'u'
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Replace all files unconditionally"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
block|{
literal|"sparse"
block|,
name|SPARSE_OPTION
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Write files with large blocks of zeros as sparse files"
argument_list|)
block|,
name|GRID
operator|+
literal|1
block|}
block|,
undef|#
directive|undef
name|GRID
comment|/* ********** */
define|#
directive|define
name|GRID
value|800
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Informative options:"
argument_list|)
block|,
name|GRID
block|}
block|,
block|{
literal|"help"
block|,
literal|'?'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Give this help list"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"usage"
block|,
name|USAGE_OPTION
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Give a short usage message"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"license"
block|,
name|LICENSE_OPTION
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Print license and exit"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"version"
block|,
name|VERSION_OPTION
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Print program version"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
comment|/* FIXME -V (--dot) conflicts with the default short option for      --version */
block|{
literal|"HANG"
block|,
name|HANG_OPTION
block|,
literal|"SECS"
block|,
name|OPTION_ARG_OPTIONAL
operator||
name|OPTION_HIDDEN
block|,
name|N_
argument_list|(
literal|"hang for SECS seconds (default 3600)"
argument_list|)
block|,
literal|0
block|}
block|,
undef|#
directive|undef
name|GRID
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_archive_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_archive_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|license
parameter_list|()
block|{
name|printf
argument_list|(
literal|"%s (%s) %s\n%s\n"
argument_list|,
name|program_name
argument_list|,
name|PACKAGE_NAME
argument_list|,
name|PACKAGE_VERSION
argument_list|,
literal|"Copyright (C) 2004 Free Software Foundation, Inc.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   GNU cpio is free software; you can redistribute it and/or modify\n"
literal|"   it under the terms of the GNU General Public License as published by\n"
literal|"   the Free Software Foundation; either version 2 of the License, or\n"
literal|"   (at your option) any later version.\n"
literal|"\n"
literal|"   GNU cpio is distributed in the hope that it will be useful,\n"
literal|"   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
literal|"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
literal|"   GNU General Public License for more details.\n"
literal|"\n"
literal|"   You should have received a copy of the GNU General Public License\n"
literal|"   along with GNU cpio; if not, write to the Free Software Foundation,\n"
literal|"   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|warn_control
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
struct|struct
name|warn_tab
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|}
name|warn_tab
index|[]
init|=
block|{
block|{
literal|"none"
block|,
name|CPIO_WARN_ALL
block|}
block|,
block|{
literal|"truncate"
block|,
name|CPIO_WARN_TRUNCATE
block|}
block|,
block|{
literal|"all"
block|,
name|CPIO_WARN_ALL
block|}
block|,
block|{
name|NULL
block|}
block|}
struct|;
name|struct
name|warn_tab
modifier|*
name|wt
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warn_option
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|>
literal|2
operator|&&
name|memcmp
argument_list|(
name|arg
argument_list|,
literal|"no-"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|offset
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|wt
operator|=
name|warn_tab
init|;
name|wt
operator|->
name|name
condition|;
name|wt
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|+
name|offset
argument_list|,
name|wt
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|offset
condition|)
name|warn_option
operator|&=
operator|~
name|wt
operator|->
name|flag
expr_stmt|;
else|else
name|warn_option
operator||=
name|wt
operator|->
name|flag
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|error_t
name|parse_opt
parameter_list|(
name|int
name|key
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|struct
name|argp_state
modifier|*
name|state
parameter_list|)
block|{
specifier|static
specifier|volatile
name|int
name|_argp_hang
decl_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Read null-terminated filenames.  */
name|name_end
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Reset access times.  */
name|reset_time_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* Append to the archive.  */
name|append_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Swap bytes and halfwords.  */
name|swap_bytes_flag
operator|=
name|true
expr_stmt|;
name|swap_halfwords_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Set block size to 5120.  */
name|io_block_size
operator|=
literal|5120
expr_stmt|;
break|break;
case|case
name|BLOCK_SIZE_OPTION
case|:
comment|/* --block-size */
name|io_block_size
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_block_size
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"invalid block size"
argument_list|)
argument_list|)
expr_stmt|;
name|io_block_size
operator|*=
literal|512
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Use the old portable ASCII format.  */
if|if
condition|(
name|archive_format
operator|!=
name|arf_unknown
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"Archive format multiply defined"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVR4_COMPAT
name|archive_format
operator|=
name|arf_newascii
expr_stmt|;
comment|/* -H newc.  */
else|#
directive|else
name|archive_format
operator|=
name|arf_oldascii
expr_stmt|;
comment|/* -H odc.  */
endif|#
directive|endif
break|break;
case|case
literal|'C'
case|:
comment|/* Block size.  */
name|io_block_size
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_block_size
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"invalid block size"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Create directories where needed.  */
name|create_dir_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Only copy files not matching patterns.  */
name|copy_matching_files
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Pattern file name.  */
name|pattern_file_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Archive file name.  */
name|archive_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Header format name.  */
if|if
condition|(
name|archive_format
operator|!=
name|arf_unknown
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Archive format multiply defined"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"crc"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_crcascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"newc"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_newascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"odc"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_oldascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"bin"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_binary
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"ustar"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_ustar
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"tar"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_tar
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"hpodc"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_hpoldascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"hpbin"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_hpbinary
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"\ invalid archive format `%s'; valid formats are:\n\ crc newc odc bin ustar tar (all-caps also recognized)"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Copy-in mode.  */
if|if
condition|(
name|copy_function
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Mode already defined"
argument_list|)
argument_list|)
expr_stmt|;
name|copy_function
operator|=
name|process_copy_in
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Input archive file name.  */
name|input_archive_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* Handle corrupted archives.  We always handle 			   corrupted archives, but recognize this 			   option for compatability.  */
break|break;
case|case
literal|'l'
case|:
comment|/* Link files when possible.  */
name|link_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Dereference symbolic links.  */
name|xstat
operator|=
name|stat
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Retain previous file modify times.  */
name|retain_time_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* New media message.  */
name|set_new_media_message
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Long list owner and group as numbers.  */
name|numeric_uid
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|NO_ABSOLUTE_FILENAMES_OPTION
case|:
comment|/* --no-absolute-filenames */
name|abs_paths_flag
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|ABSOLUTE_FILENAMES_OPTION
case|:
comment|/* --absolute-filenames */
name|abs_paths_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|NO_PRESERVE_OWNER_OPTION
case|:
comment|/* --no-preserve-owner */
if|if
condition|(
name|set_owner_flag
operator|||
name|set_group_flag
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"--no-preserve-owner cannot be used with --owner"
argument_list|)
argument_list|)
expr_stmt|;
name|no_chown_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Copy-out mode.  */
if|if
condition|(
name|copy_function
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Mode already defined"
argument_list|)
argument_list|)
expr_stmt|;
name|copy_function
operator|=
name|process_copy_out
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* Output archive file name.  */
name|output_archive_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|ONLY_VERIFY_CRC_OPTION
case|:
name|only_verify_crc_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Copy-pass mode.  */
if|if
condition|(
name|copy_function
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Mode already defined"
argument_list|)
argument_list|)
expr_stmt|;
name|copy_function
operator|=
name|process_copy_pass
expr_stmt|;
break|break;
case|case
name|RSH_COMMAND_OPTION
case|:
name|rsh_command_option
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Interactively rename.  */
name|rename_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RENAME_BATCH_FILE_OPTION
case|:
name|rename_batch_file
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|QUIET_OPTION
case|:
name|quiet_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Set the owner.  */
if|if
condition|(
name|no_chown_flag
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"--owner cannot be used with --no-preserve-owner"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|g
decl_stmt|;
name|e
operator|=
name|parse_user_spec
argument_list|(
name|arg
argument_list|,
operator|&
name|set_owner
argument_list|,
operator|&
name|set_group
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
literal|"%s: %s"
argument_list|,
name|arg
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
condition|)
block|{
name|free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|set_owner_flag
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|g
condition|)
block|{
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|set_group_flag
operator|=
name|true
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* Swap bytes.  */
name|swap_bytes_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Swap halfwords.  */
name|swap_halfwords_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Only print a list.  */
name|table_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Replace all!  Unconditionally!  */
name|unconditional_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Verbose!  */
name|verbose_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* Print `.' for each file.  */
name|dot_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|warn_control
argument_list|(
name|arg
argument_list|)
condition|)
name|argp_error
argument_list|(
name|state
argument_list|,
name|_
argument_list|(
literal|"Invalid value for --warning option: %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPARSE_OPTION
case|:
name|sparse_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|FORCE_LOCAL_OPTION
case|:
name|force_local_option
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG_CPIO
case|case
name|DEBUG_OPTION
case|:
name|debug_flag
operator|=
name|true
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|TO_STDOUT_OPTION
case|:
name|to_stdout_option
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|HANG_OPTION
case|:
name|_argp_hang
operator|=
name|atoi
argument_list|(
name|arg
condition|?
name|arg
else|:
literal|"3600"
argument_list|)
expr_stmt|;
while|while
condition|(
name|_argp_hang
operator|--
operator|>
literal|0
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|argp_state_help
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|out_stream
argument_list|,
name|ARGP_HELP_STD_HELP
argument_list|)
expr_stmt|;
break|break;
case|case
name|USAGE_OPTION
case|:
name|argp_state_help
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|out_stream
argument_list|,
name|ARGP_HELP_USAGE
operator||
name|ARGP_HELP_EXIT_OK
argument_list|)
expr_stmt|;
break|break;
case|case
name|VERSION_OPTION
case|:
name|fprintf
argument_list|(
name|state
operator|->
name|out_stream
argument_list|,
literal|"%s\n"
argument_list|,
name|argp_program_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|LICENSE_OPTION
case|:
name|license
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|ARGP_ERR_UNKNOWN
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|argp
name|argp
init|=
block|{
name|options
block|,
name|parse_opt
block|,
name|N_
argument_list|(
literal|"[destination-directory]"
argument_list|)
block|,
name|doc
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process the arguments.  Set all options and set up the copy pass    directory or the copy in patterns.  */
end_comment

begin_function
name|void
name|process_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|copy_in
function_decl|)
parameter_list|()
function_decl|;
comment|/* Work around for pcc bug.  */
name|void
function_decl|(
modifier|*
name|copy_out
function_decl|)
parameter_list|()
function_decl|;
name|int
name|index
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"You must specify one of -oipt options.\nTry `%s --help' or `%s --usage' for more information.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|xstat
operator|=
name|lstat
expr_stmt|;
if|if
condition|(
name|argp_parse
argument_list|(
operator|&
name|argp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|ARGP_IN_ORDER
operator||
name|ARGP_NO_HELP
argument_list|,
operator|&
name|index
argument_list|,
name|NULL
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Do error checking and look at other args.  */
if|if
condition|(
name|copy_function
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|table_flag
condition|)
name|copy_function
operator|=
name|process_copy_in
expr_stmt|;
else|else
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"You must specify one of -oipt options.\nTry `%s --help' or `%s --usage' for more information.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
comment|/* Work around for pcc bug.  */
name|copy_in
operator|=
name|process_copy_in
expr_stmt|;
name|copy_out
operator|=
name|process_copy_out
expr_stmt|;
if|if
condition|(
name|copy_function
operator|==
name|copy_in
condition|)
block|{
name|archive_des
operator|=
literal|0
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|link_flag
argument_list|,
literal|"--link"
argument_list|,
literal|"--extract"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|reset_time_flag
argument_list|,
literal|"--reset"
argument_list|,
literal|"--extract"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|xstat
operator|!=
name|lstat
argument_list|,
literal|"--dereference"
argument_list|,
literal|"--extract"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|append_flag
argument_list|,
literal|"--append"
argument_list|,
literal|"--extract"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|output_archive_name
argument_list|,
literal|"-O"
argument_list|,
literal|"--extract"
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_stdout_option
condition|)
block|{
name|CHECK_USAGE
argument_list|(
name|create_dir_flag
argument_list|,
literal|"--make-directories"
argument_list|,
literal|"--to-stdout"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|rename_flag
argument_list|,
literal|"--rename"
argument_list|,
literal|"--to-stdout"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|no_chown_flag
argument_list|,
literal|"--no-preserve-owner"
argument_list|,
literal|"--to-stdout"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|set_owner_flag
operator|||
name|set_group_flag
argument_list|,
literal|"--owner"
argument_list|,
literal|"--to-stdout"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|retain_time_flag
argument_list|,
literal|"--preserve-modification-time"
argument_list|,
literal|"--to-stdout"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive_name
operator|&&
name|input_archive_name
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Both -I and -F are used in copy-in mode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
condition|)
name|crc_i_flag
operator|=
name|true
expr_stmt|;
name|num_patterns
operator|=
name|argc
operator|-
name|index
expr_stmt|;
name|save_patterns
operator|=
operator|&
name|argv
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|input_archive_name
condition|)
name|archive_name
operator|=
name|input_archive_name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copy_function
operator|==
name|copy_out
condition|)
block|{
if|if
condition|(
name|index
operator|!=
name|argc
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Too many arguments"
argument_list|)
argument_list|)
expr_stmt|;
name|archive_des
operator|=
literal|1
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|create_dir_flag
argument_list|,
literal|"--make-directories"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|rename_flag
argument_list|,
literal|"--rename"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|table_flag
argument_list|,
literal|"--list"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|unconditional_flag
argument_list|,
literal|"--unconditional"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|link_flag
argument_list|,
literal|"--link"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|sparse_flag
argument_list|,
literal|"--sparse"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|retain_time_flag
argument_list|,
literal|"--preserve-modification-time"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|no_chown_flag
argument_list|,
literal|"--no-preserve-owner"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|swap_bytes_flag
argument_list|,
literal|"--swap-bytes (--swap)"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|swap_halfwords_flag
argument_list|,
literal|"--swap-halfwords (--swap)"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|to_stdout_option
argument_list|,
literal|"--to-stdout"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_flag
operator|&&
operator|!
operator|(
name|archive_name
operator|||
name|output_archive_name
operator|)
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"--append is used but no archive file name is given (use -F or -O options)"
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|rename_batch_file
argument_list|,
literal|"--rename-batch-file"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|abs_paths_flag
argument_list|,
literal|"--absolute-pathnames"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|input_archive_name
argument_list|,
literal|"-I"
argument_list|,
literal|"--create"
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_name
operator|&&
name|output_archive_name
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Both -O and -F are used in copy-out mode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_unknown
condition|)
name|archive_format
operator|=
name|arf_binary
expr_stmt|;
if|if
condition|(
name|output_archive_name
condition|)
name|archive_name
operator|=
name|output_archive_name
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy pass.  */
if|if
condition|(
name|index
operator|<
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Too many arguments"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|>
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Not enough arguments"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_format
operator|!=
name|arf_unknown
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Archive format is not specified in copy-pass mode (use --format option)"
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|swap_bytes_flag
argument_list|,
literal|"--swap-bytes (--swap)"
argument_list|,
literal|"--pass-through"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|swap_halfwords_flag
argument_list|,
literal|"--swap-halfwords (--swap)"
argument_list|,
literal|"--pass-through"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|table_flag
argument_list|,
literal|"--list"
argument_list|,
literal|"--pass-through"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|rename_flag
argument_list|,
literal|"--rename"
argument_list|,
literal|"--pass-through"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|append_flag
argument_list|,
literal|"--append"
argument_list|,
literal|"--pass-through"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|rename_batch_file
argument_list|,
literal|"--rename-batch-file"
argument_list|,
literal|"--pass-through"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|abs_paths_flag
argument_list|,
literal|"--absolute-pathnames"
argument_list|,
literal|"--pass-through"
argument_list|)
expr_stmt|;
name|CHECK_USAGE
argument_list|(
name|to_stdout_option
argument_list|,
literal|"--to-stdout"
argument_list|,
literal|"--pass-through"
argument_list|)
expr_stmt|;
name|directory_name
operator|=
name|argv
index|[
name|index
index|]
expr_stmt|;
block|}
if|if
condition|(
name|archive_name
condition|)
block|{
if|if
condition|(
name|copy_function
operator|!=
name|copy_in
operator|&&
name|copy_function
operator|!=
name|copy_out
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"-F can be used only with --create or --extract"
argument_list|)
argument_list|)
expr_stmt|;
name|archive_des
operator|=
name|open_archive
argument_list|(
name|archive_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_des
operator|<
literal|0
condition|)
name|error
argument_list|(
name|PAXEXIT_FAILURE
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"Cannot open %s"
argument_list|)
argument_list|,
name|quotearg_colon
argument_list|(
name|archive_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent SysV non-root users from giving away files inadvertantly.      This happens automatically on BSD, where only root can give      away files.  */
if|if
condition|(
name|set_owner_flag
operator|==
name|false
operator|&&
name|set_group_flag
operator|==
name|false
operator|&&
name|geteuid
argument_list|()
condition|)
name|no_chown_flag
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the input and output buffers to their proper size and    initialize all variables associated with the input and output    buffers.  */
end_comment

begin_function
name|void
name|initialize_buffers
parameter_list|()
block|{
name|int
name|in_buf_size
decl_stmt|,
name|out_buf_size
decl_stmt|;
if|if
condition|(
name|copy_function
operator|==
name|process_copy_in
condition|)
block|{
comment|/* Make sure the input buffer can always hold 2 blocks and that it 	 is big enough to hold 1 tar record (512 bytes) even if it 	 is not aligned on a block boundary.  The extra buffer space 	 is needed by process_copyin and peek_in_buf to automatically 	 figure out what kind of archive it is reading.  */
if|if
condition|(
name|io_block_size
operator|>=
literal|512
condition|)
name|in_buf_size
operator|=
literal|2
operator|*
name|io_block_size
expr_stmt|;
else|else
name|in_buf_size
operator|=
literal|1024
expr_stmt|;
name|out_buf_size
operator|=
name|DISK_IO_BLOCK_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copy_function
operator|==
name|process_copy_out
condition|)
block|{
name|in_buf_size
operator|=
name|DISK_IO_BLOCK_SIZE
expr_stmt|;
name|out_buf_size
operator|=
name|io_block_size
expr_stmt|;
block|}
else|else
block|{
name|in_buf_size
operator|=
name|DISK_IO_BLOCK_SIZE
expr_stmt|;
name|out_buf_size
operator|=
name|DISK_IO_BLOCK_SIZE
expr_stmt|;
block|}
name|input_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|in_buf_size
argument_list|)
expr_stmt|;
name|in_buff
operator|=
name|input_buffer
expr_stmt|;
name|input_buffer_size
operator|=
name|in_buf_size
expr_stmt|;
name|input_size
operator|=
literal|0
expr_stmt|;
name|input_bytes
operator|=
literal|0
expr_stmt|;
name|output_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|out_buf_size
argument_list|)
expr_stmt|;
name|out_buff
operator|=
name|output_buffer
expr_stmt|;
name|output_size
operator|=
literal|0
expr_stmt|;
name|output_bytes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|process_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|initialize_buffers
argument_list|()
expr_stmt|;
call|(
modifier|*
name|copy_function
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|archive_des
operator|>=
literal|0
operator|&&
name|rmtclose
argument_list|(
name|archive_des
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"error closing archive"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

