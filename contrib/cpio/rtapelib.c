begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions for communicating with a remote tape drive.    Copyright (C) 1988, 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* The man page rmt(8) for /etc/rmt documents the remote mag tape    protocol which rdump and rrestore use.  Unfortunately, the man    page is *WRONG*.  The author of the routines I'm including originally    wrote his code just based on the man page, and it didn't work, so he    went to the rdump source to figure out why.  The only thing he had to    change was to check for the 'F' return code in addition to the 'E',    and to separate the various arguments with \n instead of a space.  I    personally don't think that this is much of a problem, but I wanted to    point it out. -- Arnold Robbins     Originally written by Jeff Lee, modified some by Arnold Robbins.    Redone as a library that can replace open, read, write, etc., by    Fred Fish, with some additional work by Arnold Robbins.    Modified to make all rmtXXX calls into macros for speed by Jay Fenlason.    Use -DHAVE_NETDB_H for rexec code, courtesy of Dan Kegel, srs!dan.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MTIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Maximum size of a fully qualified host name.  */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTLEN
value|257
end_define

begin_comment
comment|/* Size of buffers for reading and writing commands to rmt.    (An arbitrary limit.)  */
end_comment

begin_define
define|#
directive|define
name|CMDBUFSIZE
value|64
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|RETSIGTYPE
end_ifndef

begin_define
define|#
directive|define
name|RETSIGTYPE
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Maximum number of simultaneous remote tape connections.    (Another arbitrary limit.)  */
end_comment

begin_define
define|#
directive|define
name|MAXUNIT
value|4
end_define

begin_comment
comment|/* Return the parent's read side of remote tape connection FILDES.  */
end_comment

begin_define
define|#
directive|define
name|READ
parameter_list|(
name|fildes
parameter_list|)
value|(from_rmt[fildes][0])
end_define

begin_comment
comment|/* Return the parent's write side of remote tape connection FILDES.  */
end_comment

begin_define
define|#
directive|define
name|WRITE
parameter_list|(
name|fildes
parameter_list|)
value|(to_rmt[fildes][1])
end_define

begin_comment
comment|/* The pipes for receiving data from remote tape drives.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|from_rmt
index|[
name|MAXUNIT
index|]
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The pipes for sending data to remote tape drives.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|to_rmt
index|[
name|MAXUNIT
index|]
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary variable used by macros in rmt.h.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|__rmt_path
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Close remote tape connection FILDES.  */
end_comment

begin_function
specifier|static
name|void
name|_rmt_shutdown
parameter_list|(
name|fildes
parameter_list|)
name|int
name|fildes
decl_stmt|;
block|{
name|close
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|WRITE
argument_list|(
name|fildes
argument_list|)
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|fildes
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|WRITE
argument_list|(
name|fildes
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to perform the remote tape command specified in BUF    on remote tape connection FILDES.    Return 0 if successful, -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|command
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|buflen
decl_stmt|;
name|RETSIGTYPE
function_decl|(
modifier|*
name|pipe_handler
function_decl|)
parameter_list|()
function_decl|;
comment|/* Save the current pipe handler and try to make the request.  */
name|pipe_handler
operator|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|WRITE
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
operator|==
name|buflen
condition|)
block|{
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_handler
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Something went wrong.  Close down and go home.  */
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_handler
argument_list|)
expr_stmt|;
name|_rmt_shutdown
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read and return the status from remote tape connection FILDES.    If an error occurred, return -1 and set errno.  */
end_comment

begin_function
specifier|static
name|int
name|status
parameter_list|(
name|fildes
parameter_list|)
name|int
name|fildes
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|CMDBUFSIZE
index|]
decl_stmt|;
comment|/* Read the reply command line.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
name|buffer
init|;
name|i
operator|<
name|CMDBUFSIZE
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|CMDBUFSIZE
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check the return status.  */
for|for
control|(
name|cp
operator|=
name|buffer
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|!=
literal|' '
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'E'
operator|||
operator|*
name|cp
operator|==
literal|'F'
condition|)
block|{
name|errno
operator|=
name|atoi
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Skip the error message line.  */
while|while
condition|(
name|read
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'F'
condition|)
name|_rmt_shutdown
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check for mis-synced pipes. */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'A'
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Got an `A' (success) response.  */
return|return
name|atoi
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_comment
comment|/* Execute /etc/rmt as user USER on remote system HOST using rexec.    Return a file descriptor of a bidirectional socket for stdin and stdout.    If USER is NULL, or an empty string, use the current username.     By default, this code is not used, since it requires that    the user have a .netrc file in his/her home directory, or that the    application designer be willing to have rexec prompt for login and    password info.  This may be unacceptable, and .rhosts files for use    with rsh are much more common on BSD systems.  */
end_comment

begin_function
specifier|static
name|int
name|_rmt_rexec
parameter_list|(
name|host
parameter_list|,
name|user
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|struct
name|servent
modifier|*
name|rexecserv
decl_stmt|;
name|int
name|save_stdin
init|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|save_stdout
init|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|tape_fd
decl_stmt|;
comment|/* Return value. */
comment|/* When using cpio -o< filename, stdin is no longer the tty.      But the rexec subroutine reads the login and the passwd on stdin,      to allow remote execution of the command.      So, reopen stdin and stdout on /dev/tty before the rexec and      give them back their original value after.  */
if|if
condition|(
name|freopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|rexecserv
operator|=
name|getservbyname
argument_list|(
literal|"exec"
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|rexecserv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"exec/tcp: service not available"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|user
operator|!=
name|NULL
operator|&&
operator|*
name|user
operator|==
literal|'\0'
condition|)
name|user
operator|=
name|NULL
expr_stmt|;
name|tape_fd
operator|=
name|rexec
argument_list|(
operator|&
name|host
argument_list|,
name|rexecserv
operator|->
name|s_port
argument_list|,
name|user
argument_list|,
name|NULL
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|fdopen
argument_list|(
name|save_stdin
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fdopen
argument_list|(
name|save_stdout
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
return|return
name|tape_fd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETDB_H */
end_comment

begin_comment
comment|/* Open a magtape device on the system specified in PATH, as the given user.    PATH has the form `[user@]system:/dev/????'.    If COMPAT is defined, it can also have the form `system[.user]:/dev/????'.     OFLAG is O_RDONLY, O_WRONLY, etc.    MODE is ignored; 0666 is always used.     If successful, return the remote tape pipe number plus BIAS.    On error, return -1.  */
end_comment

begin_function
name|int
name|__rmt_open
parameter_list|(
name|path
parameter_list|,
name|oflag
parameter_list|,
name|mode
parameter_list|,
name|bias
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|oflag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|bias
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|char
name|buffer
index|[
name|CMDBUFSIZE
index|]
decl_stmt|;
comment|/* Command buffer.  */
name|char
name|system
index|[
name|MAXHOSTLEN
index|]
decl_stmt|;
comment|/* The remote host name.  */
name|char
name|device
index|[
name|CMDBUFSIZE
index|]
decl_stmt|;
comment|/* The remote device name.  */
name|char
name|login
index|[
name|CMDBUFSIZE
index|]
decl_stmt|;
comment|/* The remote user name.  */
name|char
modifier|*
name|sys
decl_stmt|,
modifier|*
name|dev
decl_stmt|,
modifier|*
name|user
decl_stmt|;
comment|/* For copying into the above buffers.  */
name|sys
operator|=
name|system
expr_stmt|;
name|dev
operator|=
name|device
expr_stmt|;
name|user
operator|=
name|login
expr_stmt|;
comment|/* Find an unused pair of file descriptors.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNIT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|READ
argument_list|(
name|i
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|WRITE
argument_list|(
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAXUNIT
condition|)
block|{
name|errno
operator|=
name|EMFILE
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Pull apart the system and device, and optional user.      Don't munge the original string.  */
while|while
condition|(
operator|*
name|path
operator|!=
literal|'@'
ifdef|#
directive|ifdef
name|COMPAT
operator|&&
operator|*
name|path
operator|!=
literal|'.'
endif|#
directive|endif
operator|&&
operator|*
name|path
operator|!=
literal|':'
condition|)
block|{
operator|*
name|sys
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
block|}
operator|*
name|sys
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|path
operator|-
literal|1
operator|)
operator|==
literal|'@'
condition|)
block|{
comment|/* Saw user part of user@host.  Start over. */
name|strcpy
argument_list|(
name|user
argument_list|,
name|system
argument_list|)
expr_stmt|;
name|sys
operator|=
name|system
expr_stmt|;
while|while
condition|(
operator|*
name|path
operator|!=
literal|':'
condition|)
block|{
operator|*
name|sys
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
block|}
operator|*
name|sys
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMPAT
elseif|else
if|if
condition|(
operator|*
operator|(
name|path
operator|-
literal|1
operator|)
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
operator|*
name|path
operator|!=
literal|':'
condition|)
block|{
operator|*
name|user
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
block|}
operator|*
name|user
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
else|else
operator|*
name|user
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|path
condition|)
block|{
operator|*
name|dev
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
block|}
operator|*
name|dev
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
comment|/* Execute the remote command using rexec.  */
name|READ
argument_list|(
name|i
argument_list|)
operator|=
name|WRITE
argument_list|(
name|i
argument_list|)
operator|=
name|_rmt_rexec
argument_list|(
name|system
argument_list|,
name|login
argument_list|)
expr_stmt|;
if|if
condition|(
name|READ
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* !HAVE_NETDB_H */
comment|/* Set up the pipes for the `rsh' command, and fork.  */
if|if
condition|(
name|pipe
argument_list|(
name|to_rmt
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|pipe
argument_list|(
name|from_rmt
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|rc
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* Child.  */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|to_rmt
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|to_rmt
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|to_rmt
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|from_rmt
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|from_rmt
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|from_rmt
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|login
condition|)
block|{
name|execl
argument_list|(
literal|"/usr/bin/rsh"
argument_list|,
literal|"rsh"
argument_list|,
literal|"-l"
argument_list|,
name|login
argument_list|,
name|system
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execl
argument_list|(
literal|"/usr/bin/rsh"
argument_list|,
literal|"rsh"
argument_list|,
name|system
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Bad problems if we get here.  */
name|perror
argument_list|(
literal|"cannot execute remote shell"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Parent.  */
name|close
argument_list|(
name|to_rmt
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|from_rmt
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !HAVE_NETDB_H */
comment|/* Attempt to open the tape device.  */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"O%s\n%d\n"
argument_list|,
name|device
argument_list|,
name|oflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|i
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|status
argument_list|(
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i
operator|+
name|bias
return|;
block|}
end_function

begin_comment
comment|/* Close remote tape connection FILDES and shut down.    Return 0 if successful, -1 on error.  */
end_comment

begin_function
name|int
name|__rmt_close
parameter_list|(
name|fildes
parameter_list|)
name|int
name|fildes
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
literal|"C\n"
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|rc
operator|=
name|status
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|_rmt_shutdown
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* Read up to NBYTE bytes into BUF from remote tape connection FILDES.    Return the number of bytes read on success, -1 on error.  */
end_comment

begin_function
name|int
name|__rmt_read
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|,
name|nbyte
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|nbyte
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|CMDBUFSIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"R%d\n"
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|rc
operator|=
name|status
argument_list|(
name|fildes
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rc
condition|;
name|i
operator|+=
name|nbyte
operator|,
name|buf
operator|+=
name|nbyte
control|)
block|{
name|nbyte
operator|=
name|read
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|buf
argument_list|,
name|rc
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbyte
operator|<=
literal|0
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* Write NBYTE bytes from BUF to remote tape connection FILDES.    Return the number of bytes written on success, -1 on error.  */
end_comment

begin_function
name|int
name|__rmt_write
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|,
name|nbyte
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|nbyte
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|CMDBUFSIZE
index|]
decl_stmt|;
name|RETSIGTYPE
function_decl|(
modifier|*
name|pipe_handler
function_decl|)
parameter_list|()
function_decl|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"W%d\n"
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|pipe_handler
operator|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|WRITE
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|buf
argument_list|,
name|nbyte
argument_list|)
operator|==
name|nbyte
condition|)
block|{
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_handler
argument_list|)
expr_stmt|;
return|return
name|status
argument_list|(
name|fildes
argument_list|)
return|;
block|}
comment|/* Write error.  */
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_handler
argument_list|)
expr_stmt|;
name|_rmt_shutdown
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Perform an imitation lseek operation on remote tape connection FILDES.    Return the new file offset if successful, -1 if on error.  */
end_comment

begin_function
name|long
name|__rmt_lseek
parameter_list|(
name|fildes
parameter_list|,
name|offset
parameter_list|,
name|whence
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|whence
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|CMDBUFSIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"L%ld\n%d\n"
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|status
argument_list|(
name|fildes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform a raw tape operation on remote tape connection FILDES.    Return the results of the ioctl, or -1 on error.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MTIOCTOP
end_ifdef

begin_function
name|int
name|__rmt_ioctl
parameter_list|(
name|fildes
parameter_list|,
name|op
parameter_list|,
name|arg
parameter_list|)
name|int
name|fildes
decl_stmt|,
name|op
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|cnt
decl_stmt|;
name|char
name|buffer
index|[
name|CMDBUFSIZE
index|]
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|MTIOCTOP
case|:
comment|/* MTIOCTOP is the easy one.  Nothing is transfered in binary.  */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"I%d\n%d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_op
argument_list|,
operator|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|status
argument_list|(
name|fildes
argument_list|)
return|;
comment|/* Return the count.  */
case|case
name|MTIOCGET
case|:
comment|/* Grab the status and read it directly into the structure. 	 This assumes that the status buffer is not padded 	 and that 2 shorts fit in a long without any word 	 alignment problems; i.e., the whole struct is contiguous. 	 NOTE - this is probably NOT a good assumption.  */
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
literal|"S"
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|rc
operator|=
name|status
argument_list|(
name|fildes
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
init|;
name|rc
operator|>
literal|0
condition|;
name|rc
operator|-=
name|cnt
operator|,
name|arg
operator|+=
name|cnt
control|)
block|{
name|cnt
operator|=
name|read
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|arg
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Check for byte position.  mt_type is a small integer field 	 (normally) so we will check its magnitude.  If it is larger than 	 256, we will assume that the bytes are swapped and go through 	 and reverse all the bytes.  */
if|if
condition|(
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_type
operator|<
literal|256
condition|)
return|return
literal|0
return|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|rc
condition|;
name|cnt
operator|+=
literal|2
control|)
block|{
name|c
operator|=
name|arg
index|[
name|cnt
index|]
expr_stmt|;
name|arg
index|[
name|cnt
index|]
operator|=
name|arg
index|[
name|cnt
operator|+
literal|1
index|]
expr_stmt|;
name|arg
index|[
name|cnt
operator|+
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

