begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tcexparg.c - Unix-style command line wildcards for Turbo C 2.0     This file is in the public domain.     Compile your main program with -Dmain=_main and link with this file.     After that, it is just as if the operating system had expanded the    arguments, except that they are not sorted.  The program name and all    arguments that are expanded from wildcards are lowercased.     Syntax for wildcards:    *		Matches zero or more of any character (except a '.' at 		the beginning of a name).    ?		Matches any single character.    [r3z]	Matches 'r', '3', or 'z'.    [a-d]	Matches a single character in the range 'a' through 'd'.    [!a-d]	Matches any single character except a character in the 		range 'a' through 'd'.     The period between the filename root and its extension need not be    given explicitly.  Thus, the pattern `a*e' will match 'abacus.exe'    and 'axyz.e' as well as 'apple'.  Comparisons are not case sensitive.     Authors:    The expargs code is a modification of wildcard expansion code    written for Turbo C 1.0 by    Richard Hargrove    Texas Instruments, Inc.    P.O. Box 869305, m/s 8473    Plano, Texas 75086    214/575-4128    and posted to USENET in September, 1987.     The wild_match code was written by Rich Salz, rsalz@bbn.com,    posted to net.sources in November, 1986.     The code connecting the two is by Mike Slomin, bellcore!lcuxa!mike2,    posted to comp.sys.ibm.pc in November, 1988.     Major performance enhancements and bug fixes, and source cleanup,    by David MacKenzie, djm@gnu.ai.mit.edu.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<dir.h>
end_include

begin_comment
comment|/* Number of new arguments to allocate space for at a time.  */
end_comment

begin_define
define|#
directive|define
name|ARGS_INCREMENT
value|10
end_define

begin_comment
comment|/* The name this program was run with, for error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|grow_argv
parameter_list|(
name|char
modifier|*
modifier|*
name|new_argv
parameter_list|,
name|int
name|new_argc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fatal_error
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wild_match
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|basename
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
modifier|*
name|expargs
parameter_list|(
name|int
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|main
end_ifdef

begin_undef
undef|#
directive|undef
name|main
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|envp
parameter_list|)
block|{
name|argv
operator|=
name|expargs
argument_list|(
operator|&
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
return|return
name|_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|expargs
parameter_list|(
name|int
modifier|*
name|pargc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
name|path
index|[
name|MAXPATH
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
name|struct
name|ffblk
name|block
decl_stmt|;
name|char
modifier|*
name|path_base
decl_stmt|;
name|char
modifier|*
name|arg_base
decl_stmt|;
name|int
name|argind
decl_stmt|;
name|int
name|new_argc
decl_stmt|;
name|int
name|path_length
decl_stmt|;
name|int
name|matched
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|program_name
operator|&&
operator|*
name|program_name
condition|)
name|strlwr
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|new_argv
operator|=
name|grow_argv
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|new_argc
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|argind
operator|=
literal|1
init|;
name|argind
operator|<
operator|*
name|pargc
condition|;
operator|++
name|argind
control|)
block|{
name|matched
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strpbrk
argument_list|(
name|argv
index|[
name|argind
index|]
argument_list|,
literal|"?*["
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|path
argument_list|,
name|argv
index|[
name|argind
index|]
argument_list|,
name|MAXPATH
operator|-
literal|3
argument_list|)
expr_stmt|;
name|path_base
operator|=
name|basename
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path_base
argument_list|,
literal|"*.*"
argument_list|)
expr_stmt|;
name|arg_base
operator|=
name|argv
index|[
name|argind
index|]
operator|+
operator|(
name|path_base
operator|-
name|path
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|findfirst
argument_list|(
name|path
argument_list|,
operator|&
name|block
argument_list|,
name|FA_DIREC
argument_list|)
condition|)
block|{
name|strlwr
argument_list|(
name|path
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Only match "." and ".." explicitly.  */
if|if
condition|(
operator|*
name|block
operator|.
name|ff_name
operator|==
literal|'.'
operator|&&
operator|*
name|arg_base
operator|!=
literal|'.'
condition|)
continue|continue;
name|path_length
operator|=
name|stpcpy
argument_list|(
name|path_base
argument_list|,
name|block
operator|.
name|ff_name
argument_list|)
operator|-
name|path
operator|+
literal|1
expr_stmt|;
name|strlwr
argument_list|(
name|path_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|wild_match
argument_list|(
name|path
argument_list|,
name|argv
index|[
name|argind
index|]
argument_list|)
condition|)
block|{
name|matched
operator|=
literal|1
expr_stmt|;
name|new_argv
index|[
name|new_argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|path_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_argv
index|[
name|new_argc
index|]
operator|==
name|NULL
condition|)
name|fatal_error
argument_list|(
literal|"memory exhausted"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_argv
index|[
name|new_argc
operator|++
index|]
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|new_argv
operator|=
name|grow_argv
argument_list|(
name|new_argv
argument_list|,
name|new_argc
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|findnext
argument_list|(
operator|&
name|block
argument_list|)
condition|)
do|;
block|}
block|}
if|if
condition|(
name|matched
operator|==
literal|0
condition|)
name|new_argv
index|[
name|new_argc
operator|++
index|]
operator|=
name|argv
index|[
name|argind
index|]
expr_stmt|;
name|new_argv
operator|=
name|grow_argv
argument_list|(
name|new_argv
argument_list|,
name|new_argc
argument_list|)
expr_stmt|;
block|}
operator|*
name|pargc
operator|=
name|new_argc
expr_stmt|;
name|new_argv
index|[
name|new_argc
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|new_argv
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the last element of PATH.  */
end_comment

begin_function
name|char
modifier|*
name|basename
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|path
init|;
operator|*
name|path
condition|;
operator|++
name|path
control|)
if|if
condition|(
operator|*
name|path
operator|==
literal|':'
operator|||
operator|*
name|path
operator|==
literal|'\\'
condition|)
name|tail
operator|=
name|path
operator|+
literal|1
expr_stmt|;
return|return
name|tail
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|grow_argv
parameter_list|(
name|char
modifier|*
modifier|*
name|new_argv
parameter_list|,
name|int
name|new_argc
parameter_list|)
block|{
if|if
condition|(
name|new_argc
operator|%
name|ARGS_INCREMENT
operator|==
literal|0
condition|)
block|{
name|new_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|new_argv
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|new_argc
operator|+
name|ARGS_INCREMENT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_argv
operator|==
name|NULL
condition|)
name|fatal_error
argument_list|(
literal|"memory exhausted"
argument_list|)
expr_stmt|;
block|}
return|return
name|new_argv
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fatal_error
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|program_name
operator|&&
operator|*
name|program_name
condition|)
block|{
name|fputs
argument_list|(
name|program_name
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|": "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|message
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shell-style pattern matching for ?, \, [], and * characters.    I'm putting this replacement in the public domain.     Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986.  */
end_comment

begin_comment
comment|/* The character that inverts a character class; '!' or '^'.  */
end_comment

begin_define
define|#
directive|define
name|INVERT
value|'!'
end_define

begin_function_decl
specifier|static
name|int
name|star
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return nonzero if `string' matches Unix-style wildcard pattern    `pattern'; zero if not.  */
end_comment

begin_function
name|int
name|wild_match
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|)
block|{
name|int
name|prev
decl_stmt|;
comment|/* Previous character in character class.  */
name|int
name|matched
decl_stmt|;
comment|/* If 1, character class has been matched.  */
name|int
name|reverse
decl_stmt|;
comment|/* If 1, character class is inverted.  */
for|for
control|(
init|;
operator|*
name|pattern
condition|;
name|string
operator|++
operator|,
name|pattern
operator|++
control|)
switch|switch
condition|(
operator|*
name|pattern
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* Literal match with following character; fall through.  */
name|pattern
operator|++
expr_stmt|;
default|default:
if|if
condition|(
operator|*
name|string
operator|!=
operator|*
name|pattern
condition|)
return|return
literal|0
return|;
continue|continue;
case|case
literal|'?'
case|:
comment|/* Match anything.  */
if|if
condition|(
operator|*
name|string
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
continue|continue;
case|case
literal|'*'
case|:
comment|/* Trailing star matches everything.  */
return|return
operator|*
operator|++
name|pattern
condition|?
name|star
argument_list|(
name|string
argument_list|,
name|pattern
argument_list|)
else|:
literal|1
return|;
case|case
literal|'['
case|:
comment|/* Check for inverse character class.  */
name|reverse
operator|=
name|pattern
index|[
literal|1
index|]
operator|==
name|INVERT
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|pattern
operator|++
expr_stmt|;
for|for
control|(
name|prev
operator|=
literal|256
operator|,
name|matched
operator|=
literal|0
init|;
operator|*
operator|++
name|pattern
operator|&&
operator|*
name|pattern
operator|!=
literal|']'
condition|;
name|prev
operator|=
operator|*
name|pattern
control|)
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'-'
condition|?
operator|*
name|string
operator|<=
operator|*
operator|++
name|pattern
operator|&&
operator|*
name|string
operator|>=
name|prev
else|:
operator|*
name|string
operator|==
operator|*
name|pattern
condition|)
name|matched
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|matched
operator|==
name|reverse
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
return|return
operator|*
name|string
operator|==
literal|'\0'
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|star
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|)
block|{
while|while
condition|(
name|wild_match
argument_list|(
name|string
argument_list|,
name|pattern
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|*
operator|++
name|string
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

end_unit

