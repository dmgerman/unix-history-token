begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c - main program and argument processing for cpio.    Copyright (C) 1990, 1991, 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Phil Nelson<phil@cs.wwu.edu>,    David MacKenzie<djm@gnu.ai.mit.edu>,    and John Oleynick<juo@klinzhai.rutgers.edu>.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199306
operator|)
operator|)
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"filetypes.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpiohdr.h"
end_include

begin_include
include|#
directive|include
file|"dstring.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_decl_stmt
name|struct
name|option
name|long_opts
index|[]
init|=
block|{
block|{
literal|"null"
block|,
literal|0
block|,
literal|0
block|,
literal|'0'
block|}
block|,
block|{
literal|"append"
block|,
literal|0
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"block-size"
block|,
literal|1
block|,
literal|0
block|,
literal|130
block|}
block|,
block|{
literal|"create"
block|,
literal|0
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"dereference"
block|,
literal|0
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"dot"
block|,
literal|0
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"extract"
block|,
literal|0
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"file"
block|,
literal|1
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"force-local"
block|,
literal|0
block|,
operator|&
name|f_force_local
block|,
literal|1
block|}
block|,
block|{
literal|"format"
block|,
literal|1
block|,
literal|0
block|,
literal|'H'
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|132
block|}
block|,
block|{
literal|"io-size"
block|,
literal|1
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"link"
block|,
literal|0
block|,
operator|&
name|link_flag
block|,
name|TRUE
block|}
block|,
block|{
literal|"list"
block|,
literal|0
block|,
operator|&
name|table_flag
block|,
name|TRUE
block|}
block|,
block|{
literal|"make-directories"
block|,
literal|0
block|,
operator|&
name|create_dir_flag
block|,
name|TRUE
block|}
block|,
block|{
literal|"message"
block|,
literal|1
block|,
literal|0
block|,
literal|'M'
block|}
block|,
block|{
literal|"absolute-filenames"
block|,
literal|0
block|,
literal|0
block|,
literal|136
block|}
block|,
block|{
literal|"no-preserve-owner"
block|,
literal|0
block|,
literal|0
block|,
literal|134
block|}
block|,
block|{
literal|"nonmatching"
block|,
literal|0
block|,
operator|&
name|copy_matching_files
block|,
name|FALSE
block|}
block|,
block|{
literal|"numeric-uid-gid"
block|,
literal|0
block|,
operator|&
name|numeric_uid
block|,
name|TRUE
block|}
block|,
block|{
literal|"only-verify-crc"
block|,
literal|0
block|,
literal|0
block|,
literal|139
block|}
block|,
block|{
literal|"owner"
block|,
literal|1
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"pass-through"
block|,
literal|0
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"pattern-file"
block|,
literal|1
block|,
literal|0
block|,
literal|'E'
block|}
block|,
block|{
literal|"preserve-modification-time"
block|,
literal|0
block|,
operator|&
name|retain_time_flag
block|,
name|TRUE
block|}
block|,
block|{
literal|"rename"
block|,
literal|0
block|,
operator|&
name|rename_flag
block|,
name|TRUE
block|}
block|,
block|{
literal|"rename-batch-file"
block|,
literal|1
block|,
literal|0
block|,
literal|137
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|,
literal|0
block|,
literal|138
block|}
block|,
block|{
literal|"sparse"
block|,
literal|0
block|,
literal|0
block|,
literal|135
block|}
block|,
block|{
literal|"swap"
block|,
literal|0
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"swap-bytes"
block|,
literal|0
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"swap-halfwords"
block|,
literal|0
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"reset-access-time"
block|,
literal|0
block|,
operator|&
name|reset_time_flag
block|,
name|TRUE
block|}
block|,
block|{
literal|"unconditional"
block|,
literal|0
block|,
operator|&
name|unconditional_flag
block|,
name|TRUE
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
operator|&
name|verbose_flag
block|,
name|TRUE
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|131
block|}
block|,
ifdef|#
directive|ifdef
name|DEBUG_CPIO
block|{
literal|"debug"
block|,
literal|0
block|,
operator|&
name|debug_flag
block|,
name|TRUE
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Print usage message and exit with error.  */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|fp
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\ Usage: %s {-o|--create} [-0acvABLV] [-C bytes] [-H format] [-M message]\n\        [-O [[user@]host:]archive] [-F [[user@]host:]archive]\n\        [--file=[[user@]host:]archive] [--format=format] [--message=message]\n\        [--null] [--reset-access-time] [--verbose] [--dot] [--append]\n\        [--block-size=blocks] [--dereference] [--io-size=bytes] [--quiet]\n\        [--force-local] [--help] [--version]< name-list [> archive]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\        %s {-i|--extract} [-bcdfmnrtsuvBSV] [-C bytes] [-E file] [-H format]\n\        [-M message] [-R [user][:.][group]] [-I [[user@]host:]archive]\n\        [-F [[user@]host:]archive] [--file=[[user@]host:]archive]\n\        [--make-directories] [--nonmatching] [--preserve-modification-time]\n\        [--numeric-uid-gid] [--rename] [--list] [--swap-bytes] [--swap] [--dot]\n\        [--unconditional] [--verbose] [--block-size=blocks] [--swap-halfwords]\n\        [--io-size=bytes] [--pattern-file=file] [--format=format]\n\        [--owner=[user][:.][group]] [--no-preserve-owner] [--message=message]\n\        [--force-local] [--absolute-filenames] [--sparse] [--only-verify-crc]\n\        [--quiet] [--help] [--version] [pattern...] [< archive]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\        %s {-p|--pass-through} [-0adlmuvLV] [-R [user][:.][group]]\n\        [--null] [--reset-access-time] [--make-directories] [--link] [--quiet]\n\        [--preserve-modification-time] [--unconditional] [--verbose] [--dot]\n\        [--dereference] [--owner=[user][:.][group]] [--no-preserve-owner]\n\        [--sparse] [--help] [--version] destination-directory< name-list\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the arguments.  Set all options and set up the copy pass    directory or the copy in patterns.  */
end_comment

begin_function
name|void
name|process_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
name|void
function_decl|(
modifier|*
name|copy_in
function_decl|)
parameter_list|()
function_decl|;
comment|/* Work around for pcc bug.  */
name|void
function_decl|(
modifier|*
name|copy_out
function_decl|)
parameter_list|()
function_decl|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|input_archive_name
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|output_archive_name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xstat
operator|=
name|lstat
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"0aAbBcC:dfE:F:H:iI:lLmM:noO:prR:sStuvVz"
argument_list|,
name|long_opts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* A long option that just sets a flag.  */
break|break;
case|case
literal|'0'
case|:
comment|/* Read null-terminated filenames.  */
name|name_end
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Reset access times.  */
name|reset_time_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* Append to the archive.  */
name|append_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Swap bytes and halfwords.  */
name|swap_bytes_flag
operator|=
name|TRUE
expr_stmt|;
name|swap_halfwords_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Set block size to 5120.  */
name|io_block_size
operator|=
literal|5120
expr_stmt|;
break|break;
case|case
literal|130
case|:
comment|/* --block-size */
name|io_block_size
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_block_size
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid block size"
argument_list|)
expr_stmt|;
name|io_block_size
operator|*=
literal|512
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Use the old portable ASCII format.  */
if|if
condition|(
name|archive_format
operator|!=
name|arf_unknown
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVR4_COMPAT
name|archive_format
operator|=
name|arf_newascii
expr_stmt|;
comment|/* -H newc.  */
else|#
directive|else
name|archive_format
operator|=
name|arf_oldascii
expr_stmt|;
comment|/* -H odc.  */
endif|#
directive|endif
break|break;
case|case
literal|'C'
case|:
comment|/* Block size.  */
name|io_block_size
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_block_size
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid block size"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Create directories where needed.  */
name|create_dir_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Only copy files not matching patterns.  */
name|copy_matching_files
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Pattern file name.  */
name|pattern_file_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Archive file name.  */
name|archive_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Header format name.  */
if|if
condition|(
name|archive_format
operator|!=
name|arf_unknown
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"crc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"CRC"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_crcascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"newc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"NEWC"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_newascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"odc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"ODC"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_oldascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"bin"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"BIN"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_binary
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"ustar"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"USTAR"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_ustar
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"tar"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"TAR"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_tar
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"hpodc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"HPODC"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_hpoldascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"hpbin"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"HPBIN"
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_hpbinary
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"\ invalid archive format `%s'; valid formats are:\n\ crc newc odc bin ustar tar (all-caps also recognized)"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Copy-in mode.  */
if|if
condition|(
name|copy_function
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|copy_function
operator|=
name|process_copy_in
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Input archive file name.  */
name|input_archive_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* Handle corrupted archives.  We always handle 				   corrupted archives, but recognize this 				   option for compatability.  */
break|break;
case|case
literal|'l'
case|:
comment|/* Link files when possible.  */
name|link_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Dereference symbolic links.  */
name|xstat
operator|=
name|stat
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Retain previous file modify times.  */
name|retain_time_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* New media message.  */
name|set_new_media_message
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Long list owner and group as numbers.  */
name|numeric_uid
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|136
case|:
comment|/* --absolute-filenames */
name|abs_paths_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|134
case|:
comment|/* --no-preserve-owner */
if|if
condition|(
name|set_owner_flag
operator|||
name|set_group_flag
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|no_chown_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Copy-out mode.  */
if|if
condition|(
name|copy_function
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|copy_function
operator|=
name|process_copy_out
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* Output archive file name.  */
name|output_archive_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|139
case|:
name|only_verify_crc_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Copy-pass mode.  */
if|if
condition|(
name|copy_function
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|copy_function
operator|=
name|process_copy_pass
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Interactively rename.  */
name|rename_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|137
case|:
name|rename_batch_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|138
case|:
name|quiet_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Set the owner.  */
if|if
condition|(
name|no_chown_flag
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
block|{
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|g
decl_stmt|;
name|e
operator|=
name|parse_user_spec
argument_list|(
name|optarg
argument_list|,
operator|&
name|set_owner
argument_list|,
operator|&
name|set_group
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"%s: %s"
argument_list|,
name|optarg
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
condition|)
block|{
name|free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|set_owner_flag
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|g
condition|)
block|{
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|set_group_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
literal|'s'
case|:
comment|/* Swap bytes.  */
name|swap_bytes_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Swap halfwords.  */
name|swap_halfwords_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Only print a list.  */
name|table_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Replace all!  Unconditionally!  */
name|unconditional_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Verbose!  */
name|verbose_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* Print `.' for each file.  */
name|dot_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|131
case|:
name|printf
argument_list|(
literal|"GNU cpio %s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|135
case|:
name|sparse_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|132
case|:
comment|/* --help */
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do error checking and look at other args.  */
if|if
condition|(
name|copy_function
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|table_flag
condition|)
name|copy_function
operator|=
name|process_copy_in
expr_stmt|;
else|else
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|table_flag
operator|||
operator|!
name|verbose_flag
operator|)
operator|&&
name|numeric_uid
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Work around for pcc bug.  */
name|copy_in
operator|=
name|process_copy_in
expr_stmt|;
name|copy_out
operator|=
name|process_copy_out
expr_stmt|;
if|if
condition|(
name|copy_function
operator|==
name|copy_in
condition|)
block|{
name|archive_des
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|link_flag
operator|||
name|reset_time_flag
operator|||
name|xstat
operator|!=
name|lstat
operator|||
name|append_flag
operator|||
name|sparse_flag
operator|||
name|output_archive_name
operator|||
operator|(
name|archive_name
operator|&&
name|input_archive_name
operator|)
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
condition|)
name|crc_i_flag
operator|=
name|TRUE
expr_stmt|;
name|num_patterns
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|save_patterns
operator|=
operator|&
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|input_archive_name
condition|)
name|archive_name
operator|=
name|input_archive_name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copy_function
operator|==
name|copy_out
condition|)
block|{
name|archive_des
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
name|optind
operator|||
name|create_dir_flag
operator|||
name|rename_flag
operator|||
name|table_flag
operator|||
name|unconditional_flag
operator|||
name|link_flag
operator|||
name|retain_time_flag
operator|||
name|no_chown_flag
operator|||
name|set_owner_flag
operator|||
name|set_group_flag
operator|||
name|swap_bytes_flag
operator|||
name|swap_halfwords_flag
operator|||
operator|(
name|append_flag
operator|&&
operator|!
operator|(
name|archive_name
operator|||
name|output_archive_name
operator|)
operator|)
operator|||
name|rename_batch_file
operator|||
name|abs_paths_flag
operator|||
name|input_archive_name
operator|||
operator|(
name|archive_name
operator|&&
name|output_archive_name
operator|)
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_unknown
condition|)
name|archive_format
operator|=
name|arf_binary
expr_stmt|;
if|if
condition|(
name|output_archive_name
condition|)
name|archive_name
operator|=
name|output_archive_name
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy pass.  */
name|archive_des
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|-
literal|1
operator|!=
name|optind
operator|||
name|archive_format
operator|!=
name|arf_unknown
operator|||
name|swap_bytes_flag
operator|||
name|swap_halfwords_flag
operator|||
name|table_flag
operator|||
name|rename_flag
operator|||
name|append_flag
operator|||
name|rename_batch_file
operator|||
name|abs_paths_flag
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|directory_name
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
block|}
if|if
condition|(
name|archive_name
condition|)
block|{
if|if
condition|(
name|copy_function
operator|!=
name|copy_in
operator|&&
name|copy_function
operator|!=
name|copy_out
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|archive_des
operator|=
name|open_archive
argument_list|(
name|archive_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_des
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|archive_name
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|__MSDOS__
comment|/* Prevent SysV non-root users from giving away files inadvertantly.      This happens automatically on BSD, where only root can give      away files.  */
if|if
condition|(
name|set_owner_flag
operator|==
name|FALSE
operator|&&
name|set_group_flag
operator|==
name|FALSE
operator|&&
name|geteuid
argument_list|()
condition|)
name|no_chown_flag
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Initialize the input and output buffers to their proper size and    initialize all variables associated with the input and output    buffers.  */
end_comment

begin_function
name|void
name|initialize_buffers
parameter_list|()
block|{
name|int
name|in_buf_size
decl_stmt|,
name|out_buf_size
decl_stmt|;
if|if
condition|(
name|copy_function
operator|==
name|process_copy_in
condition|)
block|{
comment|/* Make sure the input buffer can always hold 2 blocks and that it 	 is big enough to hold 1 tar record (512 bytes) even if it 	 is not aligned on a block boundary.  The extra buffer space 	 is needed by process_copyin and peek_in_buf to automatically 	 figure out what kind of archive it is reading.  */
if|if
condition|(
name|io_block_size
operator|>=
literal|512
condition|)
name|in_buf_size
operator|=
literal|2
operator|*
name|io_block_size
expr_stmt|;
else|else
name|in_buf_size
operator|=
literal|1024
expr_stmt|;
name|out_buf_size
operator|=
name|DISK_IO_BLOCK_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copy_function
operator|==
name|process_copy_out
condition|)
block|{
name|in_buf_size
operator|=
name|DISK_IO_BLOCK_SIZE
expr_stmt|;
name|out_buf_size
operator|=
name|io_block_size
expr_stmt|;
block|}
else|else
block|{
name|in_buf_size
operator|=
name|DISK_IO_BLOCK_SIZE
expr_stmt|;
name|out_buf_size
operator|=
name|DISK_IO_BLOCK_SIZE
expr_stmt|;
block|}
name|input_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|in_buf_size
argument_list|)
expr_stmt|;
name|in_buff
operator|=
name|input_buffer
expr_stmt|;
name|input_buffer_size
operator|=
name|in_buf_size
expr_stmt|;
name|input_size
operator|=
literal|0
expr_stmt|;
name|input_bytes
operator|=
literal|0
expr_stmt|;
name|output_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|out_buf_size
argument_list|)
expr_stmt|;
name|out_buff
operator|=
name|output_buffer
expr_stmt|;
name|output_size
operator|=
literal|0
expr_stmt|;
name|output_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Clear the block of zeros.  */
name|bzero
argument_list|(
name|zeros_512
argument_list|,
literal|512
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199306
operator|)
operator|)
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__TURBOC__
name|_fmode
operator|=
name|O_BINARY
expr_stmt|;
comment|/* Put stdin and stdout in binary mode.  */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__EMX__
comment|/* gcc on OS/2.  */
name|_response
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|_wildcard
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|process_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|initialize_buffers
argument_list|()
expr_stmt|;
call|(
modifier|*
name|copy_function
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|archive_des
operator|>=
literal|0
operator|&&
name|rmtclose
argument_list|(
name|archive_des
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing archive"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

