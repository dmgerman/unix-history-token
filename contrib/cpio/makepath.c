begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* makepath.c -- Ensure that a directory path exists.    Copyright (C) 1990 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by David MacKenzie<djm@gnu.ai.mit.edu> and    Jim Meyering<meyering@cs.utexas.edu>.  */
end_comment

begin_comment
comment|/* This copy of makepath is almost like the fileutils one, but has    changes for HPUX CDF's.  Maybe the 2 versions of makepath can    come together again in the future.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA_H
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|index
end_ifndef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|int
name|uid_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|gid_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Ensure that the directory ARGPATH exists.    Remove any trailing slashes from ARGPATH before calling this function.     Make any leading directories that don't already exist, with    permissions PARENT_MODE.    If the last element of ARGPATH does not exist, create it as    a new directory with permissions MODE.    If OWNER and GROUP are non-negative, make them the UID and GID of    created directories.    If VERBOSE_FMT_STRING is nonzero, use it as a printf format    string for printing a message after successfully making a directory,    with the name of the directory that was just made as an argument.     Return 0 if ARGPATH exists as a directory with the proper    ownership and permissions when done, otherwise 1.  */
end_comment

begin_function
name|int
name|make_path
parameter_list|(
name|argpath
parameter_list|,
name|mode
parameter_list|,
name|parent_mode
parameter_list|,
name|owner
parameter_list|,
name|group
parameter_list|,
name|verbose_fmt_string
parameter_list|)
name|char
modifier|*
name|argpath
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|parent_mode
decl_stmt|;
name|uid_t
name|owner
decl_stmt|;
name|gid_t
name|group
decl_stmt|;
name|char
modifier|*
name|verbose_fmt_string
decl_stmt|;
block|{
name|char
modifier|*
name|dirpath
decl_stmt|;
comment|/* A copy we can scribble NULs on.  */
name|struct
name|stat
name|stats
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|oldmask
init|=
name|umask
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|dirpath
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|argpath
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirpath
argument_list|,
name|argpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dirpath
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|int
name|tmp_mode
decl_stmt|;
comment|/* Initial perms for leading dirs.  */
name|int
name|re_protect
decl_stmt|;
comment|/* Should leading dirs be unwritable? */
struct|struct
name|ptr_list
block|{
name|char
modifier|*
name|dirname_end
decl_stmt|;
name|struct
name|ptr_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
name|struct
name|ptr_list
modifier|*
name|p
decl_stmt|,
modifier|*
name|leading_dirs
init|=
name|NULL
decl_stmt|;
comment|/* If leading directories shouldn't be writable or executable, 	 or should have set[ug]id or sticky bits set and we are setting 	 their owners, we need to fix their permissions after making them.  */
if|if
condition|(
operator|(
operator|(
name|parent_mode
operator|&
literal|0300
operator|)
operator|!=
literal|0300
operator|)
operator|||
operator|(
name|owner
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|group
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
operator|(
name|parent_mode
operator|&
literal|07000
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|tmp_mode
operator|=
literal|0700
expr_stmt|;
name|re_protect
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tmp_mode
operator|=
name|parent_mode
expr_stmt|;
name|re_protect
operator|=
literal|0
expr_stmt|;
block|}
name|slash
operator|=
name|dirpath
expr_stmt|;
while|while
condition|(
operator|*
name|slash
operator|==
literal|'/'
condition|)
name|slash
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|slash
operator|=
name|index
argument_list|(
name|slash
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HPUX_CDF
name|int
name|iscdf
decl_stmt|;
name|iscdf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dirpath
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HPUX_CDF
comment|/* If this component of the pathname ends in `+' and is 		 followed by 2 `/'s, then this is a CDF.  We remove the 		 `+' from the name and create the directory.  Later 		 we will "hide" the directory.  */
if|if
condition|(
operator|(
operator|*
operator|(
name|slash
operator|+
literal|1
operator|)
operator|==
literal|'/'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|slash
operator|-
literal|1
operator|)
operator|==
literal|'+'
operator|)
condition|)
block|{
name|iscdf
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|slash
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mkdir
argument_list|(
name|dirpath
argument_list|,
name|tmp_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory `%s'"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|verbose_fmt_string
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|verbose_fmt_string
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|group
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|chown
argument_list|(
name|dirpath
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
ifdef|#
directive|ifdef
name|AFS
operator|&&
name|errno
operator|!=
name|EPERM
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|re_protect
condition|)
block|{
name|struct
name|ptr_list
modifier|*
name|new
init|=
operator|(
expr|struct
name|ptr_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ptr_list
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|dirname_end
operator|=
name|slash
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|leading_dirs
expr_stmt|;
name|leading_dirs
operator|=
name|new
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HPUX_CDF
if|if
condition|(
name|iscdf
condition|)
block|{
comment|/*  If this is a CDF, "hide" the directory by setting 			  its hidden/setuid bit.  Also add the `+' back to 			  its name (since once it's "hidden" we must refer 			  to as `name+' instead of `name').  */
name|chmod
argument_list|(
name|dirpath
argument_list|,
literal|04700
argument_list|)
expr_stmt|;
operator|*
operator|(
name|slash
operator|-
literal|1
operator|)
operator|=
literal|'+'
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' exists but is not a directory"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|slash
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* Avoid unnecessary calls to `stat' when given 	     pathnames containing multiple adjacent slashes.  */
while|while
condition|(
operator|*
name|slash
operator|==
literal|'/'
condition|)
name|slash
operator|++
expr_stmt|;
block|}
comment|/* We're done making leading directories. 	 Make the final component of the path. */
if|if
condition|(
name|mkdir
argument_list|(
name|dirpath
argument_list|,
name|mode
argument_list|)
condition|)
block|{
comment|/* In some cases, if the final component in dirpath was `.' then we  	     just got an EEXIST error from that last mkdir().  If that's 	     the case, ignore it.  */
if|if
condition|(
operator|(
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|stat
argument_list|(
name|dirpath
argument_list|,
operator|&
name|stats
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|!
name|S_ISDIR
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory `%s'"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|verbose_fmt_string
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|verbose_fmt_string
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|group
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|chown
argument_list|(
name|dirpath
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
ifdef|#
directive|ifdef
name|AFS
operator|&&
name|errno
operator|!=
name|EPERM
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* chown may have turned off some permission bits we wanted.  */
if|if
condition|(
operator|(
name|mode
operator|&
literal|07000
operator|)
operator|!=
literal|0
operator|&&
name|chmod
argument_list|(
name|dirpath
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the mode for leading directories didn't include owner "wx" 	 privileges, we have to reset their protections to the correct 	 value.  */
for|for
control|(
name|p
operator|=
name|leading_dirs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
operator|*
operator|(
name|p
operator|->
name|dirname_end
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
literal|0
comment|/* cpio always calls make_path with parent mode 0700, so 	     we don't have to do this.  If we ever do have to do this, 	     we have to stat the directory first to get the setuid 	     bit so we don't break HP CDF's.  */
block|if (chmod (dirpath, parent_mode)) 	    { 	      error (0, errno, "%s", dirpath); 	      retval = 1; 	    }
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* We get here if the entire path already exists.  */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' exists but is not a directory"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* chown must precede chmod because on some systems, 	 chown clears the set[ug]id bits for non-superusers, 	 resulting in incorrect permissions. 	 On System V, users can give away files with chown and then not 	 be able to chmod them.  So don't give files away.  */
if|if
condition|(
name|owner
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|group
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|chown
argument_list|(
name|dirpath
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
ifdef|#
directive|ifdef
name|AFS
operator|&&
name|errno
operator|!=
name|EPERM
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|dirpath
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

