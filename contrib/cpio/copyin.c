begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* copyin.c - extract or list a cpio archive    Copyright (C) 1990, 1991, 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199306
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|HAVE_STRFTIME
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"filetypes.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpiohdr.h"
end_include

begin_include
include|#
directive|include
file|"dstring.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"defer.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FNM_PATHNAME
end_ifndef

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_LCHOWN
end_ifndef

begin_define
define|#
directive|define
name|lchown
value|chown
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|read_pattern_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tape_skip_padding
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|defer_copyin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_defered_links
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_final_defers
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return 16-bit integer I with the bytes swapped.  */
end_comment

begin_define
define|#
directive|define
name|swab_short
parameter_list|(
name|i
parameter_list|)
value|((((i)<< 8)& 0xff00) | (((i)>> 8)& 0x00ff))
end_define

begin_comment
comment|/* Read the header, including the name of the file, from file    descriptor IN_DES into FILE_HDR.  */
end_comment

begin_function
name|void
name|read_in_header
parameter_list|(
name|file_hdr
parameter_list|,
name|in_des
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
name|int
name|in_des
decl_stmt|;
block|{
name|long
name|bytes_skipped
init|=
literal|0
decl_stmt|;
comment|/* Bytes of junk found before magic number.  */
comment|/* Search for a valid magic number.  */
if|if
condition|(
name|archive_format
operator|==
name|arf_unknown
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|check_tar
decl_stmt|;
name|int
name|peeked_bytes
decl_stmt|;
while|while
condition|(
name|archive_format
operator|==
name|arf_unknown
condition|)
block|{
name|peeked_bytes
operator|=
name|tape_buffered_peek
argument_list|(
name|tmpbuf
argument_list|,
name|in_des
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|peeked_bytes
operator|<
literal|6
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"premature end of archive"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"070701"
argument_list|,
literal|6
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_newascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"070707"
argument_list|,
literal|6
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_oldascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"070702"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|archive_format
operator|=
name|arf_crcascii
expr_stmt|;
name|crc_i_flag
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|tmpbuf
operator|)
operator|==
literal|070707
operator|)
operator|||
operator|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|tmpbuf
operator|)
operator|==
name|swab_short
argument_list|(
operator|(
name|unsigned
name|short
operator|)
literal|070707
argument_list|)
operator|)
condition|)
name|archive_format
operator|=
name|arf_binary
expr_stmt|;
elseif|else
if|if
condition|(
name|peeked_bytes
operator|>=
literal|512
operator|&&
operator|(
name|check_tar
operator|=
name|is_tar_header
argument_list|(
name|tmpbuf
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|check_tar
operator|==
literal|2
condition|)
name|archive_format
operator|=
name|arf_ustar
expr_stmt|;
else|else
name|archive_format
operator|=
name|arf_tar
expr_stmt|;
block|}
else|else
block|{
name|tape_buffered_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
name|in_des
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
operator|++
name|bytes_skipped
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
block|{
if|if
condition|(
name|append_flag
condition|)
name|last_header_start
operator|=
name|input_bytes
operator|-
name|io_block_size
operator|+
operator|(
name|in_buff
operator|-
name|input_buffer
operator|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipped %ld bytes of junk"
argument_list|,
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_tar_header
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
return|return;
block|}
name|file_hdr
operator|->
name|c_tar_linkname
operator|=
name|NULL
expr_stmt|;
name|tape_buffered_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
name|in_des
argument_list|,
literal|6L
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|append_flag
condition|)
name|last_header_start
operator|=
name|input_bytes
operator|-
name|io_block_size
operator|+
operator|(
name|in_buff
operator|-
name|input_buffer
operator|)
operator|-
literal|6
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_newascii
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
literal|"070701"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipped %ld bytes of junk"
argument_list|,
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_new_ascii
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
literal|"070702"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipped %ld bytes of junk"
argument_list|,
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_new_ascii
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|archive_format
operator|==
name|arf_oldascii
operator|||
name|archive_format
operator|==
name|arf_hpoldascii
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
literal|"070707"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipped %ld bytes of junk"
argument_list|,
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_old_ascii
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|archive_format
operator|==
name|arf_binary
operator|||
name|archive_format
operator|==
name|arf_hpbinary
operator|)
operator|&&
operator|(
name|file_hdr
operator|->
name|c_magic
operator|==
literal|070707
operator|||
name|file_hdr
operator|->
name|c_magic
operator|==
name|swab_short
argument_list|(
operator|(
name|unsigned
name|short
operator|)
literal|070707
argument_list|)
operator|)
condition|)
block|{
comment|/* Having to skip 1 byte because of word alignment is normal.  */
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipped %ld bytes of junk"
argument_list|,
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_binary
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
break|break;
block|}
name|bytes_skipped
operator|++
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tape_buffered_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
operator|+
literal|5
argument_list|,
name|in_des
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill in FILE_HDR by reading an old-format ASCII format cpio header from    file descriptor IN_DES, except for the magic number, which is    already filled in.  */
end_comment

begin_function
name|void
name|read_in_old_ascii
parameter_list|(
name|file_hdr
parameter_list|,
name|in_des
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
name|int
name|in_des
decl_stmt|;
block|{
name|char
name|ascii_header
index|[
literal|78
index|]
decl_stmt|;
name|unsigned
name|long
name|dev
decl_stmt|;
name|unsigned
name|long
name|rdev
decl_stmt|;
name|tape_buffered_read
argument_list|(
name|ascii_header
argument_list|,
name|in_des
argument_list|,
literal|70L
argument_list|)
expr_stmt|;
name|ascii_header
index|[
literal|70
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ascii_header
argument_list|,
literal|"%6lo%6lo%6lo%6lo%6lo%6lo%6lo%11lo%6lo%11lo"
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_ino
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mode
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_uid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_gid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_nlink
argument_list|,
operator|&
name|rdev
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mtime
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_namesize
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_dev_maj
operator|=
name|major
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_dev_min
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
comment|/* Read file name from input.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|file_hdr
operator|->
name|c_namesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|in_des
argument_list|,
operator|(
name|long
operator|)
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
comment|/* HP/UX cpio creates archives that look just like ordinary archives,      but for devices it sets major = 0, minor = 1, and puts the      actual major/minor number in the filesize field.  See if this      is an HP/UX cpio archive, and if so fix it.  We have to do this      here because process_copy_in() assumes filesize is always 0      for devices.  */
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
if|if
condition|(
name|file_hdr
operator|->
name|c_filesize
operator|!=
literal|0
operator|&&
name|file_hdr
operator|->
name|c_rdev_maj
operator|==
literal|0
operator|&&
name|file_hdr
operator|->
name|c_rdev_min
operator|==
literal|1
condition|)
block|{
name|file_hdr
operator|->
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* __MSDOS__ */
block|}
end_function

begin_comment
comment|/* Fill in FILE_HDR by reading a new-format ASCII format cpio header from    file descriptor IN_DES, except for the magic number, which is    already filled in.  */
end_comment

begin_function
name|void
name|read_in_new_ascii
parameter_list|(
name|file_hdr
parameter_list|,
name|in_des
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
name|int
name|in_des
decl_stmt|;
block|{
name|char
name|ascii_header
index|[
literal|112
index|]
decl_stmt|;
name|tape_buffered_read
argument_list|(
name|ascii_header
argument_list|,
name|in_des
argument_list|,
literal|104L
argument_list|)
expr_stmt|;
name|ascii_header
index|[
literal|104
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ascii_header
argument_list|,
literal|"%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx"
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_ino
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mode
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_uid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_gid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_nlink
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mtime
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_filesize
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_dev_maj
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_dev_min
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_rdev_min
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_namesize
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_chksum
argument_list|)
expr_stmt|;
comment|/* Read file name from input.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|in_des
argument_list|,
operator|(
name|long
operator|)
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
comment|/* In SVR4 ASCII format, the amount of space allocated for the header      is rounded up to the next long-word, so we might need to drop      1-3 bytes.  */
name|tape_skip_padding
argument_list|(
name|in_des
argument_list|,
name|file_hdr
operator|->
name|c_namesize
operator|+
literal|110
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill in FILE_HDR by reading a binary format cpio header from    file descriptor IN_DES, except for the first 6 bytes (the magic    number, device, and inode number), which are already filled in.  */
end_comment

begin_function
name|void
name|read_in_binary
parameter_list|(
name|file_hdr
parameter_list|,
name|in_des
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
name|int
name|in_des
decl_stmt|;
block|{
name|struct
name|old_cpio_header
name|short_hdr
decl_stmt|;
comment|/* Copy the data into the short header, then later transfer      it into the argument long header.  */
name|short_hdr
operator|.
name|c_dev
operator|=
operator|(
operator|(
expr|struct
name|old_cpio_header
operator|*
operator|)
name|file_hdr
operator|)
operator|->
name|c_dev
expr_stmt|;
name|short_hdr
operator|.
name|c_ino
operator|=
operator|(
operator|(
expr|struct
name|old_cpio_header
operator|*
operator|)
name|file_hdr
operator|)
operator|->
name|c_ino
expr_stmt|;
name|tape_buffered_read
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|short_hdr
operator|)
operator|+
literal|6
argument_list|,
name|in_des
argument_list|,
literal|20L
argument_list|)
expr_stmt|;
comment|/* If the magic number is byte swapped, fix the header.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_magic
operator|==
name|swab_short
argument_list|(
operator|(
name|unsigned
name|short
operator|)
literal|070707
argument_list|)
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
comment|/* Alert the user that they might have to do byte swapping on 	 the file contents.  */
if|if
condition|(
name|warned
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: archive header has reverse byte-order"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
name|swab_array
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|short_hdr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
name|file_hdr
operator|->
name|c_dev_maj
operator|=
name|major
argument_list|(
name|short_hdr
operator|.
name|c_dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_dev_min
operator|=
name|minor
argument_list|(
name|short_hdr
operator|.
name|c_dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_ino
operator|=
name|short_hdr
operator|.
name|c_ino
expr_stmt|;
name|file_hdr
operator|->
name|c_mode
operator|=
name|short_hdr
operator|.
name|c_mode
expr_stmt|;
name|file_hdr
operator|->
name|c_uid
operator|=
name|short_hdr
operator|.
name|c_uid
expr_stmt|;
name|file_hdr
operator|->
name|c_gid
operator|=
name|short_hdr
operator|.
name|c_gid
expr_stmt|;
name|file_hdr
operator|->
name|c_nlink
operator|=
name|short_hdr
operator|.
name|c_nlink
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|short_hdr
operator|.
name|c_rdev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|short_hdr
operator|.
name|c_rdev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_mtime
operator|=
operator|(
name|unsigned
name|long
operator|)
name|short_hdr
operator|.
name|c_mtimes
index|[
literal|0
index|]
operator|<<
literal|16
operator||
name|short_hdr
operator|.
name|c_mtimes
index|[
literal|1
index|]
expr_stmt|;
name|file_hdr
operator|->
name|c_namesize
operator|=
name|short_hdr
operator|.
name|c_namesize
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
operator|(
name|unsigned
name|long
operator|)
name|short_hdr
operator|.
name|c_filesizes
index|[
literal|0
index|]
operator|<<
literal|16
operator||
name|short_hdr
operator|.
name|c_filesizes
index|[
literal|1
index|]
expr_stmt|;
comment|/* Read file name from input.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|in_des
argument_list|,
operator|(
name|long
operator|)
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
comment|/* In binary mode, the amount of space allocated in the header for      the filename is `c_namesize' rounded up to the next short-word,      so we might need to drop a byte.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_namesize
operator|%
literal|2
condition|)
name|tape_toss_input
argument_list|(
name|in_des
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
comment|/* HP/UX cpio creates archives that look just like ordinary archives,      but for devices it sets major = 0, minor = 1, and puts the      actual major/minor number in the filesize field.  See if this      is an HP/UX cpio archive, and if so fix it.  We have to do this      here because process_copy_in() assumes filesize is always 0      for devices.  */
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
if|if
condition|(
name|file_hdr
operator|->
name|c_filesize
operator|!=
literal|0
operator|&&
name|file_hdr
operator|->
name|c_rdev_maj
operator|==
literal|0
operator|&&
name|file_hdr
operator|->
name|c_rdev_min
operator|==
literal|1
condition|)
block|{
name|file_hdr
operator|->
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* __MSDOS__ */
block|}
end_function

begin_comment
comment|/* Exchange the bytes of each element of the array of COUNT shorts    starting at PTR.  */
end_comment

begin_function
name|void
name|swab_array
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|char
name|tmp
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
name|tmp
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Current time for verbose table.  */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the collection from standard input and create files    in the file system.  */
end_comment

begin_function
name|void
name|process_copy_in
parameter_list|()
block|{
name|char
name|done
init|=
name|FALSE
decl_stmt|;
comment|/* True if trailer reached.  */
name|int
name|res
decl_stmt|;
comment|/* Result of various function calls.  */
name|dynamic_string
name|new_name
decl_stmt|;
comment|/* New file name for rename option.  */
name|FILE
modifier|*
name|tty_in
decl_stmt|;
comment|/* Interactive file for rename option.  */
name|FILE
modifier|*
name|tty_out
decl_stmt|;
comment|/* Interactive file for rename option.  */
name|FILE
modifier|*
name|rename_in
decl_stmt|;
comment|/* Batch file for rename option.  */
name|char
modifier|*
name|str_res
decl_stmt|;
comment|/* Result for string function.  */
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* For setting file times.  */
name|struct
name|stat
name|file_stat
decl_stmt|;
comment|/* Output file stat record.  */
name|struct
name|new_cpio_header
name|file_hdr
decl_stmt|;
comment|/* Output header information.  */
name|int
name|out_file_des
decl_stmt|;
comment|/* Output file descriptor.  */
name|int
name|in_file_des
decl_stmt|;
comment|/* Input file descriptor.  */
name|char
name|skip_file
decl_stmt|;
comment|/* Flag for use with patterns.  */
name|int
name|existing_dir
decl_stmt|;
comment|/* True if file is a dir& already exists.  */
name|int
name|i
decl_stmt|;
comment|/* Loop index variable.  */
name|char
modifier|*
name|link_name
init|=
name|NULL
decl_stmt|;
comment|/* Name of hard and symbolic links.  */
ifdef|#
directive|ifdef
name|HPUX_CDF
name|int
name|cdf_flag
decl_stmt|;
comment|/* True if file is a CDF.  */
name|int
name|cdf_char
decl_stmt|;
comment|/* Index of `+' char indicating a CDF.  */
endif|#
directive|endif
comment|/* Initialize the copy in.  */
if|if
condition|(
name|pattern_file_name
condition|)
name|read_pattern_file
argument_list|()
expr_stmt|;
name|file_hdr
operator|.
name|c_name
operator|=
name|NULL
expr_stmt|;
name|ds_init
argument_list|(
operator|&
name|new_name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
comment|/* Initialize this in case it has members we don't know to set.  */
name|bzero
argument_list|(
operator|&
name|times
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utimbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename_batch_file
condition|)
block|{
name|rename_in
operator|=
name|fopen
argument_list|(
name|rename_batch_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename_in
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|CONSOLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rename_flag
condition|)
block|{
comment|/* Open interactive file pair for rename operation.  */
name|tty_in
operator|=
name|fopen
argument_list|(
name|CONSOLE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_in
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|CONSOLE
argument_list|)
expr_stmt|;
name|tty_out
operator|=
name|fopen
argument_list|(
name|CONSOLE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_out
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|CONSOLE
argument_list|)
expr_stmt|;
block|}
comment|/* Get date and time if needed for processing the table option.  */
if|if
condition|(
name|table_flag
operator|&&
name|verbose_flag
condition|)
name|time
argument_list|(
operator|&
name|current_time
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__MSDOS__
name|setmode
argument_list|(
name|archive_des
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check whether the input file might be a tape.  */
name|in_file_des
operator|=
name|archive_des
expr_stmt|;
if|if
condition|(
name|_isrmt
argument_list|(
name|in_file_des
argument_list|)
condition|)
block|{
name|input_is_special
operator|=
literal|1
expr_stmt|;
name|input_is_seekable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fstat
argument_list|(
name|in_file_des
argument_list|,
operator|&
name|file_stat
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard input is closed"
argument_list|)
expr_stmt|;
name|input_is_special
operator|=
ifdef|#
directive|ifdef
name|S_ISBLK
name|S_ISBLK
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
operator|||
endif|#
directive|endif
name|S_ISCHR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|input_is_seekable
operator|=
name|S_ISREG
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
name|output_is_seekable
operator|=
name|TRUE
expr_stmt|;
comment|/* While there is more input in the collection, process the input.  */
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|link_name
operator|=
name|NULL
expr_stmt|;
name|swapping_halfwords
operator|=
name|swapping_bytes
operator|=
name|FALSE
expr_stmt|;
comment|/* Start processing the next file by reading the header.  */
name|read_in_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|in_file_des
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CPIO
if|if
condition|(
name|debug_flag
condition|)
block|{
name|struct
name|new_cpio_header
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|&
name|file_hdr
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"magic = 0%o, ino = %d, mode = 0%o, uid = %d, gid = %d\n"
argument_list|,
name|h
operator|->
name|c_magic
argument_list|,
name|h
operator|->
name|c_ino
argument_list|,
name|h
operator|->
name|c_mode
argument_list|,
name|h
operator|->
name|c_uid
argument_list|,
name|h
operator|->
name|c_gid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nlink = %d, mtime = %d, filesize = %d, dev_maj = 0x%x\n"
argument_list|,
name|h
operator|->
name|c_nlink
argument_list|,
name|h
operator|->
name|c_mtime
argument_list|,
name|h
operator|->
name|c_filesize
argument_list|,
name|h
operator|->
name|c_dev_maj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dev_min = 0x%x, rdev_maj = 0x%x, rdev_min = 0x%x, namesize = %d\n"
argument_list|,
name|h
operator|->
name|c_dev_min
argument_list|,
name|h
operator|->
name|c_rdev_maj
argument_list|,
name|h
operator|->
name|c_rdev_min
argument_list|,
name|h
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chksum = %d, name = \"%s\", tar_linkname = \"%s\"\n"
argument_list|,
name|h
operator|->
name|c_chksum
argument_list|,
name|h
operator|->
name|c_name
argument_list|,
name|h
operator|->
name|c_tar_linkname
condition|?
name|h
operator|->
name|c_tar_linkname
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Is this the header for the TRAILER file?  */
if|if
condition|(
name|strcmp
argument_list|(
literal|"TRAILER!!!"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Do we have to ignore absolute paths, and if so, does the filename          have an absolute path?  */
if|if
condition|(
name|no_abs_paths_flag
operator|&&
name|file_hdr
operator|.
name|c_name
operator|&&
name|file_hdr
operator|.
name|c_name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|file_hdr
operator|.
name|c_name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|non_abs_name
decl_stmt|;
name|non_abs_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|non_abs_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|file_hdr
operator|.
name|c_name
operator|=
name|non_abs_name
expr_stmt|;
block|}
block|}
comment|/* Does the file name match one of the given patterns?  */
if|if
condition|(
name|num_patterns
operator|<=
literal|0
condition|)
name|skip_file
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|skip_file
operator|=
name|copy_matching_files
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
operator|&&
name|skip_file
operator|==
name|copy_matching_files
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|save_patterns
index|[
name|i
index|]
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|skip_file
operator|=
operator|!
name|copy_matching_files
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skip_file
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|table_flag
condition|)
block|{
if|if
condition|(
name|verbose_flag
condition|)
block|{
ifdef|#
directive|ifdef
name|CP_IFLNK
if|if
condition|(
operator|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFLNK
condition|)
block|{
if|if
condition|(
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|link_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|file_hdr
operator|.
name|c_filesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|link_name
index|[
name|file_hdr
operator|.
name|c_filesize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|link_name
argument_list|,
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|long_format
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|link_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|long_format
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|file_hdr
operator|.
name|c_tar_linkname
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
endif|#
directive|endif
name|long_format
argument_list|(
operator|&
name|file_hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|crc
operator|=
literal|0
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_verify_crc_flag
condition|)
block|{
ifdef|#
directive|ifdef
name|CP_IFLNK
if|if
condition|(
operator|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFLNK
condition|)
continue|continue;
comment|/* links don't have a checksum */
endif|#
directive|endif
if|if
condition|(
name|crc
operator|!=
name|file_hdr
operator|.
name|c_chksum
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: checksum error (0x%x, should be 0x%x)"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
name|crc
argument_list|,
name|file_hdr
operator|.
name|c_chksum
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|append_flag
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|only_verify_crc_flag
condition|)
block|{
ifdef|#
directive|ifdef
name|CP_IFLNK
if|if
condition|(
operator|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFLNK
condition|)
block|{
if|if
condition|(
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
name|crc
operator|=
literal|0
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|crc
operator|!=
name|file_hdr
operator|.
name|c_chksum
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: checksum error (0x%x, should be 0x%x)"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
name|crc
argument_list|,
name|file_hdr
operator|.
name|c_chksum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy the input file into the directory structure.  */
comment|/* Do we need to rename the file? */
if|if
condition|(
name|rename_flag
operator|||
name|rename_batch_file
condition|)
block|{
if|if
condition|(
name|rename_flag
condition|)
block|{
name|fprintf
argument_list|(
name|tty_out
argument_list|,
literal|"rename %s -> "
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|tty_out
argument_list|)
expr_stmt|;
name|str_res
operator|=
name|ds_fgets
argument_list|(
name|tty_in
argument_list|,
operator|&
name|new_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|str_res
operator|=
name|ds_fgetstr
argument_list|(
name|rename_in
argument_list|,
operator|&
name|new_name
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str_res
operator|==
name|NULL
operator|||
name|str_res
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|file_hdr
operator|.
name|c_name
operator|=
name|xstrdup
argument_list|(
name|new_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
block|}
comment|/* See if the file already exists.  */
name|existing_dir
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
operator|&
name|file_stat
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
operator|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFDIR
operator|)
condition|)
block|{
comment|/* If there is already a directory there that 		     we are trying to create, don't complain about 		     it.  */
name|existing_dir
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|unconditional_flag
operator|&&
name|file_hdr
operator|.
name|c_mtime
operator|<=
name|file_stat
operator|.
name|st_mtime
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s not created: newer or same age version exists"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Go to the next file.  */
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|?
name|rmdir
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
else|:
name|unlink
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove current %s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Go to the next file.  */
block|}
block|}
comment|/* Do the real copy or link.  */
switch|switch
condition|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFREG
case|:
ifndef|#
directive|ifndef
name|__MSDOS__
comment|/* Can the current file be linked to a previously copied file? */
if|if
condition|(
name|file_hdr
operator|.
name|c_nlink
operator|>
literal|1
operator|&&
operator|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
operator|)
condition|)
block|{
name|int
name|link_res
decl_stmt|;
if|if
condition|(
name|file_hdr
operator|.
name|c_filesize
operator|==
literal|0
condition|)
block|{
comment|/* The newc and crc formats store multiply linked copies 			 of the same file in the archive only once.  The 			 actual data is attached to the last link in the 			 archive, and the other links all have a filesize 			 of 0.  Since this file has multiple links and a 			 filesize of 0, its data is probably attatched to 			 another file in the archive.  Save the link, and 			 process it later when we get the actual data.  We 			 can't just create it with length 0 and add the 			 data later, in case the file is readonly.  We still 			 lose if its parent directory is readonly (and we aren't 			 running as root), but there's nothing we can do about 			 that.  */
name|defer_copyin
argument_list|(
operator|&
name|file_hdr
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If the file has data (filesize != 0), then presumably 		     any other links have already been defer_copyin'ed(), 		     but GNU cpio version 2.0-2.2 didn't do that, so we 		     still have to check for links here (and also in case 		     the archive was created and later appeneded to). */
name|link_res
operator|=
name|link_to_maj_min_ino
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|==
literal|0
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|file_hdr
operator|.
name|c_nlink
operator|>
literal|1
operator|&&
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|int
name|link_res
decl_stmt|;
name|link_res
operator|=
name|link_to_maj_min_ino
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|==
literal|0
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
operator|)
operator|&&
name|file_hdr
operator|.
name|c_tar_linkname
operator|&&
name|file_hdr
operator|.
name|c_tar_linkname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|link_res
decl_stmt|;
name|link_res
operator|=
name|link_to_name
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_tar_linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot link %s to %s"
argument_list|,
name|file_hdr
operator|.
name|c_tar_linkname
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* If not linked, copy the contents of the file.  */
if|if
condition|(
name|link_name
operator|==
name|NULL
condition|)
block|{
name|out_file_des
operator|=
name|open
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_file_des
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|out_file_des
operator|=
name|open
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out_file_des
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|crc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|swap_halfwords_flag
condition|)
block|{
if|if
condition|(
operator|(
name|file_hdr
operator|.
name|c_filesize
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
name|swapping_halfwords
operator|=
name|TRUE
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot swap halfwords of %s: odd number of halfwords"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_bytes_flag
condition|)
block|{
if|if
condition|(
operator|(
name|file_hdr
operator|.
name|c_filesize
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
name|swapping_bytes
operator|=
name|TRUE
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot swap bytes of %s: odd number of bytes"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
name|copy_files_tape_to_disk
argument_list|(
name|in_file_des
argument_list|,
name|out_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|disk_empty_output_buffer
argument_list|(
name|out_file_des
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|out_file_des
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
condition|)
block|{
if|if
condition|(
name|crc
operator|!=
name|file_hdr
operator|.
name|c_chksum
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: checksum error (0x%x, should be 0x%x)"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
name|crc
argument_list|,
name|file_hdr
operator|.
name|c_chksum
argument_list|)
expr_stmt|;
block|}
comment|/* File is now copied; set attributes.  */
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|chown
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|file_hdr
operator|.
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|file_hdr
operator|.
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
comment|/* chown may have turned off some permissions we wanted. */
if|if
condition|(
name|chmod
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
operator|(
name|int
operator|)
name|file_hdr
operator|.
name|c_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retain_time_flag
condition|)
block|{
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|file_hdr
operator|.
name|c_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_hdr
operator|.
name|c_nlink
operator|>
literal|1
operator|&&
operator|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
operator|)
condition|)
block|{
comment|/* (see comment above for how the newc and crc formats  			 store multiple links).  Now that we have the data  			 for this file, create any other links to it which 			 we defered.  */
name|create_defered_links
argument_list|(
operator|&
name|file_hdr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CP_IFDIR
case|:
comment|/* Strip any trailing `/'s off the filename; tar puts 		 them on.  We might as well do it here in case anybody 		 else does too, since they cause strange things to happen.  */
name|strip_trailing_slashes
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
comment|/* Ignore the current directory.  It must already exist, 		 and we don't want to change its permission, ownership 		 or time.  */
if|if
condition|(
name|file_hdr
operator|.
name|c_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|file_hdr
operator|.
name|c_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
ifdef|#
directive|ifdef
name|HPUX_CDF
name|cdf_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|existing_dir
condition|)
block|{
ifdef|#
directive|ifdef
name|HPUX_CDF
comment|/* If the directory name ends in a + and is SUID, 		     then it is a CDF.  Strip the trailing + from 		     the name before creating it.  */
name|cdf_char
operator|=
name|strlen
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cdf_char
operator|>
literal|0
operator|)
operator|&&
operator|(
name|file_hdr
operator|.
name|c_mode
operator|&
literal|04000
operator|)
operator|&&
operator|(
name|file_hdr
operator|.
name|c_name
index|[
name|cdf_char
index|]
operator|==
literal|'+'
operator|)
condition|)
block|{
name|file_hdr
operator|.
name|c_name
index|[
name|cdf_char
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cdf_flag
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|res
operator|=
name|mkdir
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_mode
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|res
operator|=
name|mkdir
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
comment|/* In some odd cases where the file_hdr.c_name includes `.', 		     the directory may have actually been created by 		     create_all_directories(), so the mkdir will fail 		     because the directory exists.  If that's the case, 		     don't complain about it.  */
if|if
condition|(
operator|(
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|lstat
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
operator|&
name|file_stat
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|!
operator|(
name|S_ISDIR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|chown
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|file_hdr
operator|.
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|file_hdr
operator|.
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
comment|/* chown may have turned off some permissions we wanted. */
if|if
condition|(
name|chmod
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
operator|(
name|int
operator|)
name|file_hdr
operator|.
name|c_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUX_CDF
if|if
condition|(
name|cdf_flag
condition|)
comment|/* Once we "hide" the directory with the chmod(), 		   we have to refer to it using name+ instead of name.  */
name|file_hdr
operator|.
name|c_name
index|[
name|cdf_char
index|]
operator|=
literal|'+'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retain_time_flag
condition|)
block|{
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|file_hdr
operator|.
name|c_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|__MSDOS__
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
if|if
condition|(
name|file_hdr
operator|.
name|c_nlink
operator|>
literal|1
operator|&&
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|int
name|link_res
decl_stmt|;
name|link_res
operator|=
name|link_to_maj_min_ino
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_dev_maj
argument_list|,
name|file_hdr
operator|.
name|c_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_ustar
operator|&&
name|file_hdr
operator|.
name|c_tar_linkname
operator|&&
name|file_hdr
operator|.
name|c_tar_linkname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|link_res
decl_stmt|;
name|link_res
operator|=
name|link_to_name
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_tar_linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot link %s to %s"
argument_list|,
name|file_hdr
operator|.
name|c_tar_linkname
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
comment|/* Something must be wrong, because we couldn't 			 find the file to link to.  But can we assume 			 that the device maj/min numbers are correct 			 and fall through to the mknod?  It's probably 			 safer to just break, rather than possibly 			 creating a bogus device file.  */
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|CP_IFIFO
if|if
condition|(
operator|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFIFO
condition|)
name|res
operator|=
name|mkfifo
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_mode
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|res
operator|=
name|mknod
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_mode
argument_list|,
name|makedev
argument_list|(
name|file_hdr
operator|.
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|.
name|c_rdev_min
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CP_IFIFO
if|if
condition|(
operator|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFIFO
condition|)
name|res
operator|=
name|mkfifo
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_mode
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|res
operator|=
name|mknod
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_mode
argument_list|,
name|makedev
argument_list|(
name|file_hdr
operator|.
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|.
name|c_rdev_min
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|chown
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|file_hdr
operator|.
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|file_hdr
operator|.
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
comment|/* chown may have turned off some permissions we wanted. */
if|if
condition|(
name|chmod
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retain_time_flag
condition|)
block|{
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|file_hdr
operator|.
name|c_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFLNK
case|case
name|CP_IFLNK
case|:
block|{
if|if
condition|(
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|link_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|file_hdr
operator|.
name|c_filesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|link_name
index|[
name|file_hdr
operator|.
name|c_filesize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|link_name
argument_list|,
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_name
operator|=
name|xstrdup
argument_list|(
name|file_hdr
operator|.
name|c_tar_linkname
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|UMASKED_SYMLINK
argument_list|(
name|link_name
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|res
operator|=
name|UMASKED_SYMLINK
argument_list|(
name|link_name
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|.
name|c_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
name|link_name
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|lchown
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|file_hdr
operator|.
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|file_hdr
operator|.
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
name|link_name
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: unknown file type"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_flag
condition|)
name|fputc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dot_flag
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_flag
condition|)
return|return;
if|if
condition|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
condition|)
name|create_final_defers
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|res
operator|=
operator|(
name|input_bytes
operator|+
name|io_block_size
operator|-
literal|1
operator|)
operator|/
name|io_block_size
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"1 block\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d blocks\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the file described by FILE_HDR in long format.    If LINK_NAME is nonzero, it is the name of the file that    this file is a symbolic link to.  */
end_comment

begin_function
name|void
name|long_format
parameter_list|(
name|file_hdr
parameter_list|,
name|link_name
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
name|char
modifier|*
name|link_name
decl_stmt|;
block|{
name|char
name|mbuf
index|[
literal|11
index|]
decl_stmt|;
name|char
name|tbuf
index|[
literal|40
index|]
decl_stmt|;
name|time_t
name|when
decl_stmt|;
name|mode_string
argument_list|(
name|file_hdr
operator|->
name|c_mode
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
name|mbuf
index|[
literal|10
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get time values ready to print.  */
name|when
operator|=
name|file_hdr
operator|->
name|c_mtime
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRFTIME
name|strftime
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"%c"
argument_list|,
name|localtime
argument_list|(
operator|&
name|when
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|tbuf
argument_list|,
name|ctime
argument_list|(
operator|&
name|when
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current_time
operator|-
name|when
operator|>
literal|6L
operator|*
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
operator|||
name|current_time
operator|-
name|when
operator|<
literal|0L
condition|)
block|{
comment|/* The file is older than 6 months, or in the future. 	 Show the year instead of the time of day.  */
name|strcpy
argument_list|(
name|tbuf
operator|+
literal|11
argument_list|,
name|tbuf
operator|+
literal|19
argument_list|)
expr_stmt|;
block|}
name|tbuf
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s %3lu "
argument_list|,
name|mbuf
argument_list|,
name|file_hdr
operator|->
name|c_nlink
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
if|if
condition|(
name|numeric_uid
condition|)
endif|#
directive|endif
name|printf
argument_list|(
literal|"%-8u %-8u "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|file_hdr
operator|->
name|c_uid
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|file_hdr
operator|->
name|c_gid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
else|else
name|printf
argument_list|(
literal|"%-8.8s %-8.8s "
argument_list|,
name|getuser
argument_list|(
name|file_hdr
operator|->
name|c_uid
argument_list|)
argument_list|,
name|getgroup
argument_list|(
name|file_hdr
operator|->
name|c_gid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFCHR
operator|||
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFBLK
condition|)
name|printf
argument_list|(
literal|"%3lu, %3lu "
argument_list|,
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|printf
argument_list|(
literal|"%8lu "
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|tbuf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_name_with_quoting
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_name
condition|)
block|{
name|printf
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|print_name_with_quoting
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_name_with_quoting
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
ifndef|#
directive|ifndef
name|__MSDOS__
case|case
literal|'\\'
case|:
name|printf
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'\n'
case|:
name|printf
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|printf
argument_list|(
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|printf
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|printf
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|printf
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|printf
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|printf
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
default|default:
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199306
operator|)
operator|)
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|c
operator|>
literal|040
operator|&&
ifdef|#
directive|ifdef
name|__MSDOS__
name|c
operator|<
literal|0377
operator|&&
name|c
operator|!=
literal|0177
else|#
directive|else
name|c
operator|<
literal|0177
endif|#
directive|endif
condition|)
endif|#
directive|endif
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a pattern file (for the -E option).  Put a list of    `num_patterns' elements in `save_patterns'.  Any patterns that were    already in `save_patterns' (from the command line) are preserved.  */
end_comment

begin_function
specifier|static
name|void
name|read_pattern_file
parameter_list|()
block|{
name|int
name|max_new_patterns
decl_stmt|;
name|char
modifier|*
modifier|*
name|new_save_patterns
decl_stmt|;
name|int
name|new_num_patterns
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dynamic_string
name|pattern_name
decl_stmt|;
name|FILE
modifier|*
name|pattern_fp
decl_stmt|;
if|if
condition|(
name|num_patterns
operator|<
literal|0
condition|)
name|num_patterns
operator|=
literal|0
expr_stmt|;
name|max_new_patterns
operator|=
literal|1
operator|+
name|num_patterns
expr_stmt|;
name|new_save_patterns
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_new_patterns
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new_num_patterns
operator|=
name|num_patterns
expr_stmt|;
name|ds_init
argument_list|(
operator|&
name|pattern_name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|pattern_fp
operator|=
name|fopen
argument_list|(
name|pattern_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|pattern_file_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|ds_fgetstr
argument_list|(
name|pattern_fp
argument_list|,
operator|&
name|pattern_name
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|new_num_patterns
operator|>=
name|max_new_patterns
condition|)
block|{
name|max_new_patterns
operator|+=
literal|1
expr_stmt|;
name|new_save_patterns
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_save_patterns
argument_list|,
name|max_new_patterns
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new_save_patterns
index|[
name|new_num_patterns
index|]
operator|=
name|xstrdup
argument_list|(
name|pattern_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
operator|++
name|new_num_patterns
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|pattern_fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|pattern_fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|pattern_file_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
condition|;
operator|++
name|i
control|)
name|new_save_patterns
index|[
name|i
index|]
operator|=
name|save_patterns
index|[
name|i
index|]
expr_stmt|;
name|save_patterns
operator|=
name|new_save_patterns
expr_stmt|;
name|num_patterns
operator|=
name|new_num_patterns
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Skip the padding on IN_FILE_DES after a header or file,    up to the next header.    The number of bytes skipped is based on OFFSET -- the current offset    from the last start of a header (or file) -- and the current    header type.  */
end_comment

begin_function
specifier|static
name|void
name|tape_skip_padding
parameter_list|(
name|in_file_des
parameter_list|,
name|offset
parameter_list|)
name|int
name|in_file_des
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|pad
decl_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
operator|||
name|archive_format
operator|==
name|arf_newascii
condition|)
name|pad
operator|=
operator|(
literal|4
operator|-
operator|(
name|offset
operator|%
literal|4
operator|)
operator|)
operator|%
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_binary
operator|||
name|archive_format
operator|==
name|arf_hpbinary
condition|)
name|pad
operator|=
operator|(
literal|2
operator|-
operator|(
name|offset
operator|%
literal|2
operator|)
operator|)
operator|%
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
name|pad
operator|=
operator|(
literal|512
operator|-
operator|(
name|offset
operator|%
literal|512
operator|)
operator|)
operator|%
literal|512
expr_stmt|;
else|else
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The newc and crc formats store multiply linked copies of the same file     in the archive only once.  The actual data is attached to the last link     in the archive, and the other links all have a filesize of 0.  When a     file in the archive has multiple links and a filesize of 0, its data is     probably "attatched" to another file in the archive, so we can't create    it right away.  We have to "defer" creating it until we have created    the file that has the data "attatched" to it.  We keep a list of the    "defered" links on deferments.  */
end_comment

begin_decl_stmt
name|struct
name|deferment
modifier|*
name|deferments
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a file header to the deferments list.  For now they all just    go on one list, although we could optimize this if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|defer_copyin
parameter_list|(
name|file_hdr
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|create_deferment
argument_list|(
name|file_hdr
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|deferments
expr_stmt|;
name|deferments
operator|=
name|d
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* We just created a file that (probably) has some other links to it    which have been defered.  Go through all of the links on the deferments    list and create any which are links to this file.  */
end_comment

begin_function
specifier|static
name|void
name|create_defered_links
parameter_list|(
name|file_hdr
parameter_list|)
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
decl_stmt|;
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|struct
name|deferment
modifier|*
name|d_prev
decl_stmt|;
name|int
name|ino
decl_stmt|;
name|int
name|maj
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|link_res
decl_stmt|;
name|ino
operator|=
name|file_hdr
operator|->
name|c_ino
expr_stmt|;
name|maj
operator|=
name|file_hdr
operator|->
name|c_dev_maj
expr_stmt|;
name|min
operator|=
name|file_hdr
operator|->
name|c_dev_min
expr_stmt|;
name|d
operator|=
name|deferments
expr_stmt|;
name|d_prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|header
operator|.
name|c_ino
operator|==
name|ino
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_maj
operator|==
name|maj
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_min
operator|==
name|min
operator|)
condition|)
block|{
name|struct
name|deferment
modifier|*
name|d_free
decl_stmt|;
name|link_res
operator|=
name|link_to_name
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot link %s to %s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d_prev
operator|!=
name|NULL
condition|)
name|d_prev
operator|->
name|next
operator|=
name|d
operator|->
name|next
expr_stmt|;
else|else
name|deferments
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|d_free
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|free_deferment
argument_list|(
name|d_free
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d_prev
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If we had a multiply linked file that really was empty then we would    have defered all of its links, since we never found any with data    "attached", and they will still be on the deferment list even when    we are done reading the whole archive.  Write out all of these    empty links that are still on the deferments list.  */
end_comment

begin_function
specifier|static
name|void
name|create_final_defers
parameter_list|()
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|int
name|link_res
decl_stmt|;
name|int
name|out_file_des
decl_stmt|;
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* For setting file times.  */
comment|/* Initialize this in case it has members we don't know to set.  */
name|bzero
argument_list|(
operator|&
name|times
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utimbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|deferments
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|link_res
operator|=
name|link_to_maj_min_ino
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_dev_maj
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_dev_maj
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|out_file_des
operator|=
name|open
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_file_des
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|out_file_des
operator|=
name|open
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out_file_des
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|close
argument_list|(
name|out_file_des
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
comment|/* File is now copied; set attributes.  */
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|chown
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|d
operator|->
name|header
operator|.
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|d
operator|->
name|header
operator|.
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
comment|/* chown may have turned off some permissions we wanted. */
if|if
condition|(
name|chmod
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|header
operator|.
name|c_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retain_time_flag
condition|)
block|{
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|d
operator|->
name|header
operator|.
name|c_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

