begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* userspec.c -- Parse a user and group string.    Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by David MacKenzie<djm@gnu.ai.mit.edu>.  */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA_H
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|index
end_ifndef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_VERSION
end_ifndef

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|group
modifier|*
name|getgrgid
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
end_ifdef

begin_define
define|#
directive|define
name|endpwent
parameter_list|()
end_define

begin_define
define|#
directive|define
name|endgrent
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Perform the equivalent of the statement `dest = strdup (src);',    but obtaining storage via alloca instead of from the heap.  */
end_comment

begin_define
define|#
directive|define
name|V_STRDUP
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|do									\     {									\       int _len = strlen ((src));					\       (dest) = (char *) alloca (_len + 1);				\       strcpy (dest, src);						\     }									\   while (0)
end_define

begin_define
define|#
directive|define
name|isdigit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_function_decl
name|char
modifier|*
name|strdup
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return nonzero if STR represents an unsigned decimal integer,    otherwise return 0. */
end_comment

begin_function
specifier|static
name|int
name|isnumber
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Extract from NAME, which has the form "[user][:.][group]",    a USERNAME, UID U, GROUPNAME, and GID G.    Either user or group, or both, must be present.    If the group is omitted but the ":" or "." separator is given,    use the given user's login group.     USERNAME and GROUPNAME will be in newly malloc'd memory.    Either one might be NULL instead, indicating that it was not    given and the corresponding numeric ID was left unchanged.     Return NULL if successful, a static error message string if not.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|parse_user_spec
parameter_list|(
name|spec_arg
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|,
name|username_arg
parameter_list|,
name|groupname_arg
parameter_list|)
specifier|const
name|char
modifier|*
name|spec_arg
decl_stmt|;
name|uid_t
modifier|*
name|uid
decl_stmt|;
name|gid_t
modifier|*
name|gid
decl_stmt|;
name|char
modifier|*
modifier|*
name|username_arg
decl_stmt|,
decl|*
modifier|*
name|groupname_arg
decl_stmt|;
end_function

begin_block
block|{
specifier|static
specifier|const
name|char
modifier|*
name|tired
init|=
literal|"virtual memory exhausted"
decl_stmt|;
specifier|const
name|char
modifier|*
name|error_msg
decl_stmt|;
name|char
modifier|*
name|spec
decl_stmt|;
comment|/* A copy we can write on.  */
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|char
modifier|*
name|g
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|separator
decl_stmt|;
name|char
modifier|*
name|groupname
decl_stmt|;
name|error_msg
operator|=
name|NULL
expr_stmt|;
operator|*
name|username_arg
operator|=
operator|*
name|groupname_arg
operator|=
name|NULL
expr_stmt|;
name|groupname
operator|=
name|NULL
expr_stmt|;
name|V_STRDUP
argument_list|(
name|spec
argument_list|,
name|spec_arg
argument_list|)
expr_stmt|;
comment|/* Find the separator if there is one.  */
name|separator
operator|=
name|index
argument_list|(
name|spec
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|separator
operator|==
name|NULL
condition|)
name|separator
operator|=
name|index
argument_list|(
name|spec
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* Replace separator with a NUL.  */
if|if
condition|(
name|separator
operator|!=
name|NULL
condition|)
operator|*
name|separator
operator|=
literal|'\0'
expr_stmt|;
comment|/* Set U and G to non-zero length strings corresponding to user and      group specifiers or to NULL.  */
name|u
operator|=
operator|(
operator|*
name|spec
operator|==
literal|'\0'
condition|?
name|NULL
else|:
name|spec
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|separator
operator|==
name|NULL
operator|||
operator|*
operator|(
name|separator
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|?
name|NULL
else|:
name|separator
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|u
operator|==
name|NULL
operator|&&
name|g
operator|==
name|NULL
condition|)
return|return
literal|"can not omit both user and group"
return|;
if|if
condition|(
name|u
operator|!=
name|NULL
condition|)
block|{
name|pwd
operator|=
name|getpwnam
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isnumber
argument_list|(
name|u
argument_list|)
condition|)
name|error_msg
operator|=
literal|"invalid user"
expr_stmt|;
else|else
block|{
name|int
name|use_login_group
decl_stmt|;
name|use_login_group
operator|=
operator|(
name|separator
operator|!=
name|NULL
operator|&&
name|g
operator|==
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|use_login_group
condition|)
name|error_msg
operator|=
literal|"cannot get the login group of a numeric UID"
expr_stmt|;
else|else
operator|*
name|uid
operator|=
name|atoi
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
operator|&&
name|separator
operator|!=
name|NULL
condition|)
block|{
comment|/* A separator was given, but a group was not specified, 	         so get the login group.  */
operator|*
name|gid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
name|grp
operator|=
name|getgrgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
block|{
comment|/* This is enough room to hold the unsigned decimal 		     representation of any 32-bit quantity and the trailing 		     zero byte.  */
name|char
name|uint_buf
index|[
literal|21
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|uint_buf
argument_list|,
literal|"%u"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
argument_list|)
expr_stmt|;
name|V_STRDUP
argument_list|(
name|groupname
argument_list|,
name|uint_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|V_STRDUP
argument_list|(
name|groupname
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
name|endgrent
argument_list|()
expr_stmt|;
block|}
block|}
name|endpwent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|!=
name|NULL
operator|&&
name|error_msg
operator|==
name|NULL
condition|)
block|{
comment|/* Explicit group.  */
name|grp
operator|=
name|getgrnam
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isnumber
argument_list|(
name|g
argument_list|)
condition|)
name|error_msg
operator|=
literal|"invalid group"
expr_stmt|;
else|else
operator|*
name|gid
operator|=
name|atoi
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
comment|/* Save a file descriptor.  */
if|if
condition|(
name|error_msg
operator|==
name|NULL
condition|)
name|V_STRDUP
argument_list|(
name|groupname
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error_msg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|u
operator|!=
name|NULL
condition|)
block|{
operator|*
name|username_arg
operator|=
name|strdup
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|username_arg
operator|==
name|NULL
condition|)
name|error_msg
operator|=
name|tired
expr_stmt|;
block|}
if|if
condition|(
name|groupname
operator|!=
name|NULL
operator|&&
name|error_msg
operator|==
name|NULL
condition|)
block|{
operator|*
name|groupname_arg
operator|=
name|strdup
argument_list|(
name|groupname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|groupname_arg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|username_arg
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|username_arg
argument_list|)
expr_stmt|;
operator|*
name|username_arg
operator|=
name|NULL
expr_stmt|;
block|}
name|error_msg
operator|=
name|tired
expr_stmt|;
block|}
block|}
block|}
return|return
name|error_msg
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_define
define|#
directive|define
name|NULL_CHECK
parameter_list|(
name|s
parameter_list|)
value|((s) == NULL ? "(null)" : (s))
end_define

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|username
decl_stmt|,
modifier|*
name|groupname
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|strdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|e
operator|=
name|parse_user_spec
argument_list|(
name|tmp
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|,
operator|&
name|username
argument_list|,
operator|&
name|groupname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %u %u %s %s %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|uid
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|gid
argument_list|,
name|NULL_CHECK
argument_list|(
name|username
argument_list|)
argument_list|,
name|NULL_CHECK
argument_list|(
name|groupname
argument_list|)
argument_list|,
name|NULL_CHECK
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

