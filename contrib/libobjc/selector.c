begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime selector related functions    Copyright (C) 1993, 1995, 1996, 1997, 2002, 2004 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"objc/runtime.h"
end_include

begin_include
include|#
directive|include
file|"objc/sarray.h"
end_include

begin_include
include|#
directive|include
file|"objc/encoding.h"
end_include

begin_comment
comment|/* Initial selector hash table size. Value doesn't matter much */
end_comment

begin_define
define|#
directive|define
name|SELECTOR_HASH_SIZE
value|128
end_define

begin_comment
comment|/* Tables mapping selector names to uid and opposite */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sarray
modifier|*
name|__objc_selector_array
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uid -> sel  !T:MUTEX */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sarray
modifier|*
name|__objc_selector_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uid -> name !T:MUTEX */
end_comment

begin_decl_stmt
specifier|static
name|cache_ptr
name|__objc_selector_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name -> uid !T:MUTEX */
end_comment

begin_comment
comment|/* Number of selectors stored in each of the above tables */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|__objc_selector_max_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_function
name|void
name|__objc_init_selector_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|__objc_selector_array
operator|=
name|sarray_new
argument_list|(
name|SELECTOR_HASH_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__objc_selector_names
operator|=
name|sarray_new
argument_list|(
name|SELECTOR_HASH_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__objc_selector_hash
operator|=
name|objc_hash_new
argument_list|(
name|SELECTOR_HASH_SIZE
argument_list|,
operator|(
name|hash_func_type
operator|)
name|objc_hash_string
argument_list|,
operator|(
name|compare_func_type
operator|)
name|objc_compare_strings
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine is given a class and records all of the methods in its class    structure in the record table.  */
end_comment

begin_function
name|void
name|__objc_register_selectors_from_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|MethodList_t
name|method_list
decl_stmt|;
name|method_list
operator|=
name|class
operator|->
name|methods
expr_stmt|;
while|while
condition|(
name|method_list
condition|)
block|{
name|__objc_register_selectors_from_list
argument_list|(
name|method_list
argument_list|)
expr_stmt|;
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is given a list of methods and records each of the methods in    the record table.  This is the routine that does the actual recording    work.     The name and type pointers in the method list must be permanent and    immutable.    */
end_comment

begin_function
name|void
name|__objc_register_selectors_from_list
parameter_list|(
name|MethodList_t
name|method_list
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|)
block|{
name|Method_t
name|method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
condition|)
block|{
name|method
operator|->
name|method_name
operator|=
name|__sel_register_typed_name
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|method
operator|->
name|method_name
argument_list|,
name|method
operator|->
name|method_types
argument_list|,
literal|0
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
literal|1
expr_stmt|;
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register instance methods as class methods for root classes */
end_comment

begin_function
name|void
name|__objc_register_instance_methods_to_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|MethodList_t
name|method_list
decl_stmt|;
name|MethodList_t
name|class_method_list
decl_stmt|;
name|int
name|max_methods_no
init|=
literal|16
decl_stmt|;
name|MethodList_t
name|new_list
decl_stmt|;
name|Method_t
name|curr_method
decl_stmt|;
comment|/* Only if a root class. */
if|if
condition|(
name|class
operator|->
name|super_class
condition|)
return|return;
comment|/* Allocate a method list to hold the new class methods */
name|new_list
operator|=
name|objc_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method_list
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method
index|[
name|max_methods_no
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|method_list
operator|=
name|class
operator|->
name|methods
expr_stmt|;
name|class_method_list
operator|=
name|class
operator|->
name|class_pointer
operator|->
name|methods
expr_stmt|;
name|curr_method
operator|=
operator|&
name|new_list
operator|->
name|method_list
index|[
literal|0
index|]
expr_stmt|;
comment|/* Iterate through the method lists for the class */
while|while
condition|(
name|method_list
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Iterate through the methods from this method list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
name|i
operator|++
control|)
block|{
name|Method_t
name|mth
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mth
operator|->
name|method_name
operator|&&
operator|!
name|search_for_method_in_list
argument_list|(
name|class_method_list
argument_list|,
name|mth
operator|->
name|method_name
argument_list|)
condition|)
block|{
comment|/* This instance method isn't a class method.  		  Add it into the new_list. */
operator|*
name|curr_method
operator|=
operator|*
name|mth
expr_stmt|;
comment|/* Reallocate the method list if necessary */
if|if
condition|(
operator|++
name|new_list
operator|->
name|method_count
operator|==
name|max_methods_no
condition|)
name|new_list
operator|=
name|objc_realloc
argument_list|(
name|new_list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method_list
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method
index|[
name|max_methods_no
operator|+=
literal|16
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|curr_method
operator|=
operator|&
name|new_list
operator|->
name|method_list
index|[
name|new_list
operator|->
name|method_count
index|]
expr_stmt|;
block|}
block|}
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
comment|/* If we created any new class methods      then attach the method list to the class */
if|if
condition|(
name|new_list
operator|->
name|method_count
condition|)
block|{
name|new_list
operator|=
name|objc_realloc
argument_list|(
name|new_list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method_list
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method
index|[
name|new_list
operator|->
name|method_count
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|new_list
operator|->
name|method_next
operator|=
name|class
operator|->
name|class_pointer
operator|->
name|methods
expr_stmt|;
name|class
operator|->
name|class_pointer
operator|->
name|methods
operator|=
name|new_list
expr_stmt|;
block|}
else|else
name|objc_free
argument_list|(
name|new_list
argument_list|)
expr_stmt|;
name|__objc_update_dispatch_table_for_class
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns YES iff t1 and t2 have same method types, but we ignore    the argframe layout */
end_comment

begin_function
name|BOOL
name|sel_types_match
parameter_list|(
specifier|const
name|char
modifier|*
name|t1
parameter_list|,
specifier|const
name|char
modifier|*
name|t2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|t1
operator|||
operator|!
name|t2
condition|)
return|return
name|NO
return|;
while|while
condition|(
operator|*
name|t1
operator|&&
operator|*
name|t2
condition|)
block|{
if|if
condition|(
operator|*
name|t1
operator|==
literal|'+'
condition|)
name|t1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t2
operator|==
literal|'+'
condition|)
name|t2
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t1
argument_list|)
condition|)
name|t1
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t2
argument_list|)
condition|)
name|t2
operator|++
expr_stmt|;
comment|/* xxx Remove these next two lines when qualifiers are put in 	 all selectors, not just Protocol selectors. */
name|t1
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|t1
operator|&&
operator|!
operator|*
name|t2
condition|)
return|return
name|YES
return|;
if|if
condition|(
operator|*
name|t1
operator|!=
operator|*
name|t2
condition|)
return|return
name|NO
return|;
name|t1
operator|++
expr_stmt|;
name|t2
operator|++
expr_stmt|;
block|}
return|return
name|NO
return|;
block|}
end_function

begin_comment
comment|/* return selector representing name */
end_comment

begin_function
name|SEL
name|sel_get_typed_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|types
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|objc_hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|tail
control|)
block|{
name|SEL
name|s
init|=
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|types
operator|==
literal|0
operator|||
name|s
operator|->
name|sel_types
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|sel_types
operator|==
name|types
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sel_types_match
argument_list|(
name|s
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return selector representing name; prefer a selector with non-NULL type */
end_comment

begin_function
name|SEL
name|sel_get_any_typed_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|SEL
name|s
init|=
name|NULL
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|objc_hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|tail
control|)
block|{
name|s
operator|=
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|sel_types
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* return selector representing name */
end_comment

begin_function
name|SEL
name|sel_get_any_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|objc_hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soffset_decode
argument_list|(
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
return|;
block|}
end_function

begin_comment
comment|/* return selector representing name */
end_comment

begin_function
name|SEL
name|sel_get_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|sel_register_typed_name
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get name of selector.  If selector is unknown, the empty string ""     is returned */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|sel_get_name
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|soffset_decode
argument_list|(
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|soffset_decode
argument_list|(
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
operator|<=
name|__objc_selector_max_index
operator|)
condition|)
name|ret
operator|=
name|sarray_get_safe
argument_list|(
name|__objc_selector_names
argument_list|,
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|BOOL
name|sel_is_mapped
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
name|unsigned
name|int
name|idx
init|=
name|soffset_decode
argument_list|(
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|idx
operator|>
literal|0
operator|)
operator|&&
operator|(
name|idx
operator|<=
name|__objc_selector_max_index
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sel_get_type
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
if|if
condition|(
name|selector
condition|)
return|return
name|selector
operator|->
name|sel_types
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The uninstalled dispatch table */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|sarray
modifier|*
name|__objc_uninstalled_dtable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* __sel_register_typed_name allocates lots of struct objc_selector:s    of 8 (16, if pointers are 64 bits) bytes at startup. To reduce the number    of malloc calls and memory lost to malloc overhead, we allocate    objc_selector:s in blocks here. This is only called from    __sel_register_typed_name, and __sel_register_typed_name may only be    called when __objc_runtime_mutex is locked.     Note that the objc_selector:s allocated from __sel_register_typed_name    are never freed.     62 because 62 * sizeof (struct objc_selector) = 496 (992). This should    let malloc add some overhead and use a nice, round 512 (1024) byte chunk.    */
end_comment

begin_define
define|#
directive|define
name|SELECTOR_POOL_SIZE
value|62
end_define

begin_decl_stmt
specifier|static
name|struct
name|objc_selector
modifier|*
name|selector_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|selector_pool_left
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|objc_selector
modifier|*
name|pool_alloc_selector
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|selector_pool_left
condition|)
block|{
name|selector_pool
operator|=
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objc_selector
argument_list|)
operator|*
name|SELECTOR_POOL_SIZE
argument_list|)
expr_stmt|;
name|selector_pool_left
operator|=
name|SELECTOR_POOL_SIZE
expr_stmt|;
block|}
return|return
operator|&
name|selector_pool
index|[
operator|--
name|selector_pool_left
index|]
return|;
block|}
end_function

begin_comment
comment|/* Store the passed selector name in the selector record and return its    selector value (value returned by sel_get_uid).    Assumes that the calling function has locked down __objc_runtime_mutex. */
end_comment

begin_comment
comment|/* is_const parameter tells us if the name and types parameters    are really constant or not.  If YES then they are constant and    we can just store the pointers.  If NO then we need to copy    name and types because the pointers may disappear later on. */
end_comment

begin_function
name|SEL
name|__sel_register_typed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|types
parameter_list|,
name|struct
name|objc_selector
modifier|*
name|orig
parameter_list|,
name|BOOL
name|is_const
parameter_list|)
block|{
name|struct
name|objc_selector
modifier|*
name|j
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|objc_hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soffset_decode
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|tail
control|)
block|{
name|SEL
name|s
init|=
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|types
operator|==
literal|0
operator|||
name|s
operator|->
name|sel_types
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|sel_types
operator|==
name|types
condition|)
block|{
if|if
condition|(
name|orig
condition|)
block|{
name|orig
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
return|return
name|orig
return|;
block|}
else|else
return|return
name|s
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
name|orig
condition|)
block|{
name|orig
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
return|return
name|orig
return|;
block|}
else|else
return|return
name|s
return|;
block|}
block|}
if|if
condition|(
name|orig
condition|)
name|j
operator|=
name|orig
expr_stmt|;
else|else
name|j
operator|=
name|pool_alloc_selector
argument_list|()
expr_stmt|;
name|j
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
comment|/* Can we use the pointer or must copy types?  Don't copy if NULL */
if|if
condition|(
operator|(
name|is_const
operator|)
operator|||
operator|(
name|types
operator|==
literal|0
operator|)
condition|)
name|j
operator|->
name|sel_types
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|types
expr_stmt|;
else|else
block|{
name|j
operator|->
name|sel_types
operator|=
operator|(
name|char
operator|*
operator|)
name|objc_malloc
argument_list|(
name|strlen
argument_list|(
name|types
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|j
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__objc_selector_max_index
operator|+=
literal|1
expr_stmt|;
name|i
operator|=
name|soffset_encode
argument_list|(
name|__objc_selector_max_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
condition|)
name|j
operator|=
name|orig
expr_stmt|;
else|else
name|j
operator|=
name|pool_alloc_selector
argument_list|()
expr_stmt|;
name|j
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
comment|/* Can we use the pointer or must copy types?  Don't copy if NULL */
if|if
condition|(
operator|(
name|is_const
operator|)
operator|||
operator|(
name|types
operator|==
literal|0
operator|)
condition|)
name|j
operator|->
name|sel_types
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|types
expr_stmt|;
else|else
block|{
name|j
operator|->
name|sel_types
operator|=
operator|(
name|char
operator|*
operator|)
name|objc_malloc
argument_list|(
name|strlen
argument_list|(
name|types
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|j
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
literal|0
expr_stmt|;
block|}
name|DEBUG_PRINTF
argument_list|(
literal|"Record selector %s[%s] as: %ld\n"
argument_list|,
name|name
argument_list|,
name|types
argument_list|,
operator|(
name|long
operator|)
name|soffset_decode
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|is_new
init|=
operator|(
name|l
operator|==
literal|0
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_name
decl_stmt|;
comment|/* Can we use the pointer or must copy name?  Don't copy if NULL */
if|if
condition|(
operator|(
name|is_const
operator|)
operator|||
operator|(
name|name
operator|==
literal|0
operator|)
condition|)
name|new_name
operator|=
name|name
expr_stmt|;
else|else
block|{
name|new_name
operator|=
operator|(
name|char
operator|*
operator|)
name|objc_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|list_cons
argument_list|(
operator|(
name|void
operator|*
operator|)
name|j
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sarray_at_put_safe
argument_list|(
name|__objc_selector_names
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_name
argument_list|)
expr_stmt|;
name|sarray_at_put_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
name|objc_hash_add
argument_list|(
operator|&
name|__objc_selector_hash
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|sarray_realloc
argument_list|(
name|__objc_uninstalled_dtable
argument_list|,
name|__objc_selector_max_index
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|SEL
operator|)
name|j
return|;
block|}
end_function

begin_function
name|SEL
name|sel_register_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|SEL
name|ret
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* Assume that name is not constant static memory and needs to be      copied before put into a runtime structure.  is_const == NO */
name|ret
operator|=
name|__sel_register_typed_name
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|SEL
name|sel_register_typed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|SEL
name|ret
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* Assume that name and type are not constant static memory and need to      be copied before put into a runtime structure.  is_const == NO */
name|ret
operator|=
name|__sel_register_typed_name
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

