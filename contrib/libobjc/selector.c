begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime selector related functions    Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"sarray.h"
end_include

begin_include
include|#
directive|include
file|"encoding.h"
end_include

begin_comment
comment|/* Initial selector hash table size. Value doesn't matter much */
end_comment

begin_define
define|#
directive|define
name|SELECTOR_HASH_SIZE
value|128
end_define

begin_comment
comment|/* Tables mapping selector names to uid and opposite */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sarray
modifier|*
name|__objc_selector_array
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uid -> sel  !T:MUTEX */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sarray
modifier|*
name|__objc_selector_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uid -> name !T:MUTEX */
end_comment

begin_decl_stmt
specifier|static
name|cache_ptr
name|__objc_selector_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name -> uid !T:MUTEX */
end_comment

begin_function_decl
specifier|static
name|void
name|register_selectors_from_list
parameter_list|(
name|MethodList_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Number of selectors stored in each of the above tables */
end_comment

begin_decl_stmt
name|int
name|__objc_selector_max_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_function
name|void
name|__objc_init_selector_tables
parameter_list|()
block|{
name|__objc_selector_array
operator|=
name|sarray_new
argument_list|(
name|SELECTOR_HASH_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__objc_selector_names
operator|=
name|sarray_new
argument_list|(
name|SELECTOR_HASH_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__objc_selector_hash
operator|=
name|hash_new
argument_list|(
name|SELECTOR_HASH_SIZE
argument_list|,
operator|(
name|hash_func_type
operator|)
name|hash_string
argument_list|,
operator|(
name|compare_func_type
operator|)
name|compare_strings
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine is given a class and records all of the methods in its class    structure in the record table.  */
end_comment

begin_function
name|void
name|__objc_register_selectors_from_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|MethodList_t
name|method_list
decl_stmt|;
name|method_list
operator|=
name|class
operator|->
name|methods
expr_stmt|;
while|while
condition|(
name|method_list
condition|)
block|{
name|register_selectors_from_list
argument_list|(
name|method_list
argument_list|)
expr_stmt|;
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is given a list of methods and records each of the methods in    the record table.  This is the routine that does the actual recording    work.     This one is only called for Class objects.  For categories,    class_add_method_list is called.    */
end_comment

begin_function
specifier|static
name|void
name|register_selectors_from_list
parameter_list|(
name|MethodList_t
name|method_list
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|)
block|{
name|Method_t
name|method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
name|method
operator|->
name|method_name
operator|=
name|sel_register_typed_name
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|method
operator|->
name|method_name
argument_list|,
name|method
operator|->
name|method_types
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Register instance methods as class methods for root classes */
end_comment

begin_function
name|void
name|__objc_register_instance_methods_to_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|MethodList_t
name|method_list
decl_stmt|;
name|MethodList_t
name|class_method_list
decl_stmt|;
name|int
name|max_methods_no
init|=
literal|16
decl_stmt|;
name|MethodList_t
name|new_list
decl_stmt|;
name|Method_t
name|curr_method
decl_stmt|;
comment|/* Only if a root class. */
if|if
condition|(
name|class
operator|->
name|super_class
condition|)
return|return;
comment|/* Allocate a method list to hold the new class methods */
name|new_list
operator|=
name|objc_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method_list
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method
index|[
name|max_methods_no
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|method_list
operator|=
name|class
operator|->
name|methods
expr_stmt|;
name|class_method_list
operator|=
name|class
operator|->
name|class_pointer
operator|->
name|methods
expr_stmt|;
name|curr_method
operator|=
operator|&
name|new_list
operator|->
name|method_list
index|[
literal|0
index|]
expr_stmt|;
comment|/* Iterate through the method lists for the class */
while|while
condition|(
name|method_list
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Iterate through the methods from this method list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
name|i
operator|++
control|)
block|{
name|Method_t
name|mth
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mth
operator|->
name|method_name
operator|&&
operator|!
name|search_for_method_in_list
argument_list|(
name|class_method_list
argument_list|,
name|mth
operator|->
name|method_name
argument_list|)
condition|)
block|{
comment|/* This instance method isn't a class method.  		  Add it into the new_list. */
operator|*
name|curr_method
operator|=
operator|*
name|mth
expr_stmt|;
comment|/* Reallocate the method list if necessary */
if|if
condition|(
operator|++
name|new_list
operator|->
name|method_count
operator|==
name|max_methods_no
condition|)
name|new_list
operator|=
name|objc_realloc
argument_list|(
name|new_list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method_list
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method
index|[
name|max_methods_no
operator|+=
literal|16
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|curr_method
operator|=
operator|&
name|new_list
operator|->
name|method_list
index|[
name|new_list
operator|->
name|method_count
index|]
expr_stmt|;
block|}
block|}
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
comment|/* If we created any new class methods      then attach the method list to the class */
if|if
condition|(
name|new_list
operator|->
name|method_count
condition|)
block|{
name|new_list
operator|=
name|objc_realloc
argument_list|(
name|new_list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method_list
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|objc_method
index|[
name|new_list
operator|->
name|method_count
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|new_list
operator|->
name|method_next
operator|=
name|class
operator|->
name|class_pointer
operator|->
name|methods
expr_stmt|;
name|class
operator|->
name|class_pointer
operator|->
name|methods
operator|=
name|new_list
expr_stmt|;
block|}
name|__objc_update_dispatch_table_for_class
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns YES iff t1 and t2 have same method types, but we ignore    the argframe layout */
end_comment

begin_function
name|BOOL
name|sel_types_match
parameter_list|(
specifier|const
name|char
modifier|*
name|t1
parameter_list|,
specifier|const
name|char
modifier|*
name|t2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|t1
operator|||
operator|!
name|t2
condition|)
return|return
name|NO
return|;
while|while
condition|(
operator|*
name|t1
operator|&&
operator|*
name|t2
condition|)
block|{
if|if
condition|(
operator|*
name|t1
operator|==
literal|'+'
condition|)
name|t1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t2
operator|==
literal|'+'
condition|)
name|t2
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|t1
argument_list|)
condition|)
name|t1
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|t2
argument_list|)
condition|)
name|t2
operator|++
expr_stmt|;
comment|/* xxx Remove these next two lines when qualifiers are put in 	 all selectors, not just Protocol selectors. */
name|t1
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|t1
operator|&&
operator|!
operator|*
name|t2
condition|)
return|return
name|YES
return|;
if|if
condition|(
operator|*
name|t1
operator|!=
operator|*
name|t2
condition|)
return|return
name|NO
return|;
name|t1
operator|++
expr_stmt|;
name|t2
operator|++
expr_stmt|;
block|}
return|return
name|NO
return|;
block|}
end_function

begin_comment
comment|/* return selector representing name */
end_comment

begin_function
name|SEL
name|sel_get_typed_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|types
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|tail
control|)
block|{
name|SEL
name|s
init|=
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|types
operator|==
literal|0
operator|||
name|s
operator|->
name|sel_types
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|sel_types
operator|==
name|types
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sel_types_match
argument_list|(
name|s
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return selector representing name; prefer a selector with non-NULL type */
end_comment

begin_function
name|SEL
name|sel_get_any_typed_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|SEL
name|s
init|=
name|NULL
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|tail
control|)
block|{
name|s
operator|=
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|sel_types
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* return selector representing name */
end_comment

begin_function
name|SEL
name|sel_get_any_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soffset_decode
argument_list|(
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
return|;
block|}
end_function

begin_comment
comment|/* return selector representing name */
end_comment

begin_function
name|SEL
name|sel_get_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|sel_register_typed_name
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get name of selector.  If selector is unknown, the empty string ""     is returned */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|sel_get_name
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|soffset_decode
argument_list|(
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|soffset_decode
argument_list|(
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
operator|<=
name|__objc_selector_max_index
operator|)
condition|)
name|ret
operator|=
name|sarray_get_safe
argument_list|(
name|__objc_selector_names
argument_list|,
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|BOOL
name|sel_is_mapped
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
name|unsigned
name|int
name|idx
init|=
name|soffset_decode
argument_list|(
operator|(
name|sidx
operator|)
name|selector
operator|->
name|sel_id
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|idx
operator|>
literal|0
operator|)
operator|&&
operator|(
name|idx
operator|<=
name|__objc_selector_max_index
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sel_get_type
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
if|if
condition|(
name|selector
condition|)
return|return
name|selector
operator|->
name|sel_types
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The uninstalled dispatch table */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|sarray
modifier|*
name|__objc_uninstalled_dtable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store the passed selector name in the selector record and return its    selector value (value returned by sel_get_uid).    Assumes that the calling function has locked down __objc_runtime_mutex. */
end_comment

begin_comment
comment|/* is_const parameter tells us if the name and types parameters    are really constant or not.  If YES then they are constant and    we can just store the pointers.  If NO then we need to copy    name and types because the pointers may disappear later on. */
end_comment

begin_function
name|SEL
name|__sel_register_typed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|types
parameter_list|,
name|struct
name|objc_selector
modifier|*
name|orig
parameter_list|,
name|BOOL
name|is_const
parameter_list|)
block|{
name|struct
name|objc_selector
modifier|*
name|j
decl_stmt|;
name|sidx
name|i
decl_stmt|;
name|struct
name|objc_list
modifier|*
name|l
decl_stmt|;
name|i
operator|=
operator|(
name|sidx
operator|)
name|hash_value_for_key
argument_list|(
name|__objc_selector_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soffset_decode
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|tail
control|)
block|{
name|SEL
name|s
init|=
operator|(
name|SEL
operator|)
name|l
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|types
operator|==
literal|0
operator|||
name|s
operator|->
name|sel_types
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|sel_types
operator|==
name|types
condition|)
block|{
if|if
condition|(
name|orig
condition|)
block|{
name|orig
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
return|return
name|orig
return|;
block|}
else|else
return|return
name|s
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
name|orig
condition|)
block|{
name|orig
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
return|return
name|orig
return|;
block|}
else|else
return|return
name|s
return|;
block|}
block|}
if|if
condition|(
name|orig
condition|)
name|j
operator|=
name|orig
expr_stmt|;
else|else
name|j
operator|=
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objc_selector
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
comment|/* Can we use the pointer or must copy types?  Don't copy if NULL */
if|if
condition|(
operator|(
name|is_const
operator|)
operator|||
operator|(
name|types
operator|==
literal|0
operator|)
condition|)
name|j
operator|->
name|sel_types
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|types
expr_stmt|;
else|else
block|{
name|j
operator|->
name|sel_types
operator|=
operator|(
name|char
operator|*
operator|)
name|objc_malloc
argument_list|(
name|strlen
argument_list|(
name|types
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|j
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
operator|(
expr|struct
name|objc_list
operator|*
operator|)
name|sarray_get_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__objc_selector_max_index
operator|+=
literal|1
expr_stmt|;
name|i
operator|=
name|soffset_encode
argument_list|(
name|__objc_selector_max_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
condition|)
name|j
operator|=
name|orig
expr_stmt|;
else|else
name|j
operator|=
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objc_selector
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|sel_id
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
comment|/* Can we use the pointer or must copy types?  Don't copy if NULL */
if|if
condition|(
operator|(
name|is_const
operator|)
operator|||
operator|(
name|types
operator|==
literal|0
operator|)
condition|)
name|j
operator|->
name|sel_types
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|types
expr_stmt|;
else|else
block|{
name|j
operator|->
name|sel_types
operator|=
operator|(
name|char
operator|*
operator|)
name|objc_malloc
argument_list|(
name|strlen
argument_list|(
name|types
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|j
operator|->
name|sel_types
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
literal|0
expr_stmt|;
block|}
name|DEBUG_PRINTF
argument_list|(
literal|"Record selector %s[%s] as: %ld\n"
argument_list|,
name|name
argument_list|,
name|types
argument_list|,
name|soffset_decode
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|is_new
init|=
operator|(
name|l
operator|==
literal|0
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_name
decl_stmt|;
comment|/* Can we use the pointer or must copy name?  Don't copy if NULL */
if|if
condition|(
operator|(
name|is_const
operator|)
operator|||
operator|(
name|name
operator|==
literal|0
operator|)
condition|)
name|new_name
operator|=
name|name
expr_stmt|;
else|else
block|{
name|new_name
operator|=
operator|(
name|char
operator|*
operator|)
name|objc_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|list_cons
argument_list|(
operator|(
name|void
operator|*
operator|)
name|j
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sarray_at_put_safe
argument_list|(
name|__objc_selector_names
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_name
argument_list|)
expr_stmt|;
name|sarray_at_put_safe
argument_list|(
name|__objc_selector_array
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
name|hash_add
argument_list|(
operator|&
name|__objc_selector_hash
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|sarray_realloc
argument_list|(
name|__objc_uninstalled_dtable
argument_list|,
name|__objc_selector_max_index
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|SEL
operator|)
name|j
return|;
block|}
end_function

begin_function
name|SEL
name|sel_register_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|SEL
name|ret
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* Assume that name is not constant static memory and needs to be      copied before put into a runtime structure.  is_const == NO */
name|ret
operator|=
name|__sel_register_typed_name
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|SEL
name|sel_register_typed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|SEL
name|ret
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* Assume that name and type are not constant static memory and need to      be copied before put into a runtime structure.  is_const == NO */
name|ret
operator|=
name|__sel_register_typed_name
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

