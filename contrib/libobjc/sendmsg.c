begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime message lookup     Copyright (C) 1993, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"sarray.h"
end_include

begin_include
include|#
directive|include
file|"encoding.h"
end_include

begin_include
include|#
directive|include
file|"runtime-info.h"
end_include

begin_comment
comment|/* this is how we hack STRUCT_VALUE to be 1 or 0 */
end_comment

begin_define
define|#
directive|define
name|gen_rtx
parameter_list|(
name|args
modifier|...
parameter_list|)
value|1
end_define

begin_define
define|#
directive|define
name|gen_rtx_MEM
parameter_list|(
name|args
modifier|...
parameter_list|)
value|1
end_define

begin_define
define|#
directive|define
name|rtx
value|int
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STRUCT_VALUE
argument_list|)
operator|||
name|STRUCT_VALUE
operator|==
literal|0
end_if

begin_define
define|#
directive|define
name|INVISIBLE_STRUCT_RETURN
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INVISIBLE_STRUCT_RETURN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The uninstalled dispatch table */
end_comment

begin_decl_stmt
name|struct
name|sarray
modifier|*
name|__objc_uninstalled_dtable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_comment
comment|/* Send +initialize to class */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_send_initialize
parameter_list|(
name|Class
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__objc_install_dispatch_table_for_class
parameter_list|(
name|Class
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Forward declare some functions */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_init_install_dtable
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Various forwarding functions that are used based upon the    return type for the selector.    __objc_block_forward for structures.    __objc_double_forward for floats/doubles.    __objc_word_forward for pointers or types that fit in registers.    */
end_comment

begin_function_decl
specifier|static
name|double
name|__objc_double_forward
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|id
name|__objc_word_forward
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
name|id
name|many
index|[
literal|8
index|]
decl_stmt|;
block|}
name|__big
typedef|;
end_typedef

begin_if
if|#
directive|if
name|INVISIBLE_STRUCT_RETURN
end_if

begin_function_decl
specifier|static
name|__big
else|#
directive|else
specifier|static
name|id
endif|#
directive|endif
name|__objc_block_forward
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Method_t
name|search_for_method_in_hierarchy
parameter_list|(
name|Class
name|class
parameter_list|,
name|SEL
name|sel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Method_t
name|search_for_method_in_list
parameter_list|(
name|MethodList_t
name|list
parameter_list|,
name|SEL
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|id
name|nil_method
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Given a selector, return the proper forwarding implementation. */
end_comment

begin_function
name|__inline__
name|IMP
name|__objc_get_forward_imp
parameter_list|(
name|SEL
name|sel
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|sel
operator|->
name|sel_types
decl_stmt|;
if|if
condition|(
name|t
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'['
operator|||
operator|*
name|t
operator|==
literal|'('
operator|||
operator|*
name|t
operator|==
literal|'{'
operator|)
ifdef|#
directive|ifdef
name|OBJC_MAX_STRUCT_BY_VALUE
operator|&&
name|objc_sizeof_type
argument_list|(
name|t
argument_list|)
operator|>
name|OBJC_MAX_STRUCT_BY_VALUE
endif|#
directive|endif
condition|)
return|return
operator|(
name|IMP
operator|)
name|__objc_block_forward
return|;
elseif|else
if|if
condition|(
name|t
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'f'
operator|||
operator|*
name|t
operator|==
literal|'d'
operator|)
condition|)
return|return
operator|(
name|IMP
operator|)
name|__objc_double_forward
return|;
else|else
return|return
operator|(
name|IMP
operator|)
name|__objc_word_forward
return|;
block|}
end_function

begin_comment
comment|/* Given a class and selector, return the selector's implementation.  */
end_comment

begin_function
name|__inline__
name|IMP
name|get_imp
parameter_list|(
name|Class
name|class
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|void
modifier|*
name|res
init|=
name|sarray_get_safe
argument_list|(
name|class
operator|->
name|dtable
argument_list|,
operator|(
name|size_t
operator|)
name|sel
operator|->
name|sel_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
comment|/* Not a valid method */
if|if
condition|(
name|class
operator|->
name|dtable
operator|==
name|__objc_uninstalled_dtable
condition|)
block|{
comment|/* The dispatch table needs to be installed. */
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|__objc_install_dispatch_table_for_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* Call ourselves with the installed dispatch table 	     and get the real method */
name|res
operator|=
name|get_imp
argument_list|(
name|class
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The dispatch table has been installed so the 	     method just doesn't exist for the class. 	     Return the forwarding implementation. */
name|res
operator|=
name|__objc_get_forward_imp
argument_list|(
name|sel
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Query if an object can respond to a selector, returns YES if the object implements the selector otherwise NO.  Does not check if the method can be forwarded. */
end_comment

begin_function
name|__inline__
name|BOOL
name|__objc_responds_to
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|void
modifier|*
name|res
decl_stmt|;
comment|/* Install dispatch table if need be */
if|if
condition|(
name|object
operator|->
name|class_pointer
operator|->
name|dtable
operator|==
name|__objc_uninstalled_dtable
condition|)
block|{
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|__objc_install_dispatch_table_for_class
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
comment|/* Get the method from the dispatch table */
name|res
operator|=
name|sarray_get_safe
argument_list|(
name|object
operator|->
name|class_pointer
operator|->
name|dtable
argument_list|,
operator|(
name|size_t
operator|)
name|sel
operator|->
name|sel_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the lookup function.  All entries in the table are either a     valid method *or* zero.  If zero then either the dispatch table    needs to be installed or it doesn't exist and forwarding is attempted. */
end_comment

begin_function
name|__inline__
name|IMP
name|objc_msg_lookup
parameter_list|(
name|id
name|receiver
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
name|IMP
name|result
decl_stmt|;
if|if
condition|(
name|receiver
condition|)
block|{
name|result
operator|=
name|sarray_get_safe
argument_list|(
name|receiver
operator|->
name|class_pointer
operator|->
name|dtable
argument_list|,
operator|(
name|sidx
operator|)
name|op
operator|->
name|sel_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|/* Not a valid method */
if|if
condition|(
name|receiver
operator|->
name|class_pointer
operator|->
name|dtable
operator|==
name|__objc_uninstalled_dtable
condition|)
block|{
comment|/* The dispatch table needs to be installed. 		 This happens on the very first method call to the class. */
name|__objc_init_install_dtable
argument_list|(
name|receiver
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Get real method for this in newly installed dtable */
name|result
operator|=
name|get_imp
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The dispatch table has been installed so the 		 method just doesn't exist for the class. 		 Attempt to forward the method. */
name|result
operator|=
name|__objc_get_forward_imp
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
else|else
return|return
name|nil_method
return|;
block|}
end_function

begin_function
name|IMP
name|objc_msg_lookup_super
parameter_list|(
name|Super_t
name|super
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
if|if
condition|(
name|super
operator|->
name|self
condition|)
return|return
name|get_imp
argument_list|(
name|super
operator|->
name|class
argument_list|,
name|sel
argument_list|)
return|;
else|else
return|return
name|nil_method
return|;
block|}
end_function

begin_function_decl
name|int
name|method_get_sizeof_arguments
parameter_list|(
name|Method
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|retval_t
name|objc_msg_sendv
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|op
parameter_list|,
name|arglist_t
name|arg_frame
parameter_list|)
block|{
name|Method
modifier|*
name|m
init|=
name|class_get_instance_method
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|op
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
operator|*
operator|(
operator|(
name|id
operator|*
operator|)
name|method_get_first_argument
argument_list|(
name|m
argument_list|,
name|arg_frame
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|=
name|object
expr_stmt|;
operator|*
operator|(
operator|(
name|SEL
operator|*
operator|)
name|method_get_next_argument
argument_list|(
name|arg_frame
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|=
name|op
expr_stmt|;
return|return
name|__builtin_apply
argument_list|(
operator|(
name|apply_t
operator|)
name|m
operator|->
name|method_imp
argument_list|,
name|arg_frame
argument_list|,
name|method_get_sizeof_arguments
argument_list|(
name|m
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|__objc_init_dispatch_tables
parameter_list|()
block|{
name|__objc_uninstalled_dtable
operator|=
name|sarray_new
argument_list|(
literal|200
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called by objc_msg_lookup when the    dispatch table needs to be installed; thus it is called once    for each class, namely when the very first message is sent to it. */
end_comment

begin_function
specifier|static
name|void
name|__objc_init_install_dtable
parameter_list|(
name|id
name|receiver
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
comment|/* This may happen, if the programmer has taken the address of a       method before the dtable was initialized... too bad for him! */
if|if
condition|(
name|receiver
operator|->
name|class_pointer
operator|->
name|dtable
operator|!=
name|__objc_uninstalled_dtable
condition|)
return|return;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLS_ISCLASS
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
condition|)
block|{
comment|/* receiver is an ordinary object */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install instance methods table */
name|__objc_install_dispatch_table_for_class
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
comment|/* call +initialize -- this will in turn install the factory  	 dispatch table if not already done :-) */
name|__objc_send_initialize
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* receiver is a class object */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
operator|(
name|Class
operator|)
name|receiver
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISMETA
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Install real dtable for factory methods */
name|__objc_install_dispatch_table_for_class
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
name|__objc_send_initialize
argument_list|(
operator|(
name|Class
operator|)
name|receiver
argument_list|)
expr_stmt|;
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install dummy table for class which causes the first message to    that class (or instances hereof) to be initialized properly */
end_comment

begin_function
name|void
name|__objc_install_premature_dtable
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|assert
argument_list|(
name|__objc_uninstalled_dtable
argument_list|)
expr_stmt|;
name|class
operator|->
name|dtable
operator|=
name|__objc_uninstalled_dtable
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send +initialize to class if not already done */
end_comment

begin_function
specifier|static
name|void
name|__objc_send_initialize
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
comment|/* This *must* be a class object */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|CLS_ISMETA
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLS_ISINITIALIZED
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|CLS_SETINITIALIZED
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLS_SETINITIALIZED
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
comment|/* Create the garbage collector type memory description */
name|__objc_generate_gc_type_description
argument_list|(
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|->
name|super_class
condition|)
name|__objc_send_initialize
argument_list|(
name|class
operator|->
name|super_class
argument_list|)
expr_stmt|;
block|{
name|SEL
name|op
init|=
name|sel_register_name
argument_list|(
literal|"initialize"
argument_list|)
decl_stmt|;
name|IMP
name|imp
init|=
literal|0
decl_stmt|;
name|MethodList_t
name|method_list
init|=
name|class
operator|->
name|class_pointer
operator|->
name|methods
decl_stmt|;
while|while
condition|(
name|method_list
condition|)
block|{
name|int
name|i
decl_stmt|;
name|Method_t
name|method
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
name|i
operator|++
control|)
block|{
name|method
operator|=
operator|&
operator|(
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
operator|&&
name|method
operator|->
name|method_name
operator|->
name|sel_id
operator|==
name|op
operator|->
name|sel_id
condition|)
block|{
name|imp
operator|=
name|method
operator|->
name|method_imp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|imp
condition|)
break|break;
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
if|if
condition|(
name|imp
condition|)
call|(
modifier|*
name|imp
call|)
argument_list|(
operator|(
name|id
operator|)
name|class
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Walk on the methods list of class and install the methods in the reverse    order of the lists. Since methods added by categories are before the methods    of class in the methods list, this allows categories to substitute methods    declared in class. However if more than one category replaces the same    method nothing is guaranteed about what method will be used.    Assumes that __objc_runtime_mutex is locked down. */
end_comment

begin_function
specifier|static
name|void
name|__objc_install_methods_in_dtable
parameter_list|(
name|Class
name|class
parameter_list|,
name|MethodList_t
name|method_list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|method_list
condition|)
return|return;
if|if
condition|(
name|method_list
operator|->
name|method_next
condition|)
name|__objc_install_methods_in_dtable
argument_list|(
name|class
argument_list|,
name|method_list
operator|->
name|method_next
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
name|i
operator|++
control|)
block|{
name|Method_t
name|method
init|=
operator|&
operator|(
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
operator|)
decl_stmt|;
name|sarray_at_put_safe
argument_list|(
name|class
operator|->
name|dtable
argument_list|,
operator|(
name|sidx
operator|)
name|method
operator|->
name|method_name
operator|->
name|sel_id
argument_list|,
name|method
operator|->
name|method_imp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assumes that __objc_runtime_mutex is locked down. */
end_comment

begin_function
specifier|static
name|void
name|__objc_install_dispatch_table_for_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|Class
name|super
decl_stmt|;
comment|/* If the class has not yet had its class links resolved, we must       re-compute all class links */
if|if
condition|(
operator|!
name|CLS_ISRESOLV
argument_list|(
name|class
argument_list|)
condition|)
name|__objc_resolve_class_links
argument_list|()
expr_stmt|;
name|super
operator|=
name|class
operator|->
name|super_class
expr_stmt|;
if|if
condition|(
name|super
operator|!=
literal|0
operator|&&
operator|(
name|super
operator|->
name|dtable
operator|==
name|__objc_uninstalled_dtable
operator|)
condition|)
name|__objc_install_dispatch_table_for_class
argument_list|(
name|super
argument_list|)
expr_stmt|;
comment|/* Allocate dtable if necessary */
if|if
condition|(
name|super
operator|==
literal|0
condition|)
block|{
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|class
operator|->
name|dtable
operator|=
name|sarray_new
argument_list|(
name|__objc_selector_max_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
else|else
name|class
operator|->
name|dtable
operator|=
name|sarray_lazy_copy
argument_list|(
name|super
operator|->
name|dtable
argument_list|)
expr_stmt|;
name|__objc_install_methods_in_dtable
argument_list|(
name|class
argument_list|,
name|class
operator|->
name|methods
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__objc_update_dispatch_table_for_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|Class
name|next
decl_stmt|;
name|struct
name|sarray
modifier|*
name|arr
decl_stmt|;
comment|/* not yet installed -- skip it */
if|if
condition|(
name|class
operator|->
name|dtable
operator|==
name|__objc_uninstalled_dtable
condition|)
return|return;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|arr
operator|=
name|class
operator|->
name|dtable
expr_stmt|;
name|__objc_install_premature_dtable
argument_list|(
name|class
argument_list|)
expr_stmt|;
comment|/* someone might require it... */
name|sarray_free
argument_list|(
name|arr
argument_list|)
expr_stmt|;
comment|/* release memory */
comment|/* could have been lazy... */
name|__objc_install_dispatch_table_for_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|->
name|subclass_list
condition|)
comment|/* Traverse subclasses */
for|for
control|(
name|next
operator|=
name|class
operator|->
name|subclass_list
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|sibling_class
control|)
name|__objc_update_dispatch_table_for_class
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function adds a method list to a class.  This function is    typically called by another function specific to the run-time.  As    such this function does not worry about thread safe issues.     This one is only called for categories. Class objects have their    methods installed right away, and their selectors are made into    SEL's by the function __objc_register_selectors_from_class. */
end_comment

begin_function
name|void
name|class_add_method_list
parameter_list|(
name|Class
name|class
parameter_list|,
name|MethodList_t
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Passing of a linked list is not allowed.  Do multiple calls.  */
name|assert
argument_list|(
operator|!
name|list
operator|->
name|method_next
argument_list|)
expr_stmt|;
comment|/* Check for duplicates.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
condition|)
comment|/* Sometimes these are NULL */
block|{
comment|/* This is where selector names are transmogrified to SEL's */
name|method
operator|->
name|method_name
operator|=
name|sel_register_typed_name
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|method
operator|->
name|method_name
argument_list|,
name|method
operator|->
name|method_types
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add the methods to the class's method list.  */
name|list
operator|->
name|method_next
operator|=
name|class
operator|->
name|methods
expr_stmt|;
name|class
operator|->
name|methods
operator|=
name|list
expr_stmt|;
comment|/* Update the dispatch table of class */
name|__objc_update_dispatch_table_for_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Method_t
name|class_get_instance_method
parameter_list|(
name|Class
name|class
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
return|return
name|search_for_method_in_hierarchy
argument_list|(
name|class
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|Method_t
name|class_get_class_method
parameter_list|(
name|MetaClass
name|class
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
return|return
name|search_for_method_in_hierarchy
argument_list|(
name|class
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Search for a method starting from the current class up its hierarchy.    Return a pointer to the method's method structure if found.  NULL    otherwise. */
end_comment

begin_function
specifier|static
name|Method_t
name|search_for_method_in_hierarchy
parameter_list|(
name|Class
name|cls
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|Method_t
name|method
init|=
name|NULL
decl_stmt|;
name|Class
name|class
decl_stmt|;
if|if
condition|(
operator|!
name|sel_is_mapped
argument_list|(
name|sel
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Scan the method list of the class.  If the method isn't found in the      list then step to its super class. */
for|for
control|(
name|class
operator|=
name|cls
init|;
operator|(
operator|(
operator|!
name|method
operator|)
operator|&&
name|class
operator|)
condition|;
name|class
operator|=
name|class
operator|->
name|super_class
control|)
name|method
operator|=
name|search_for_method_in_list
argument_list|(
name|class
operator|->
name|methods
argument_list|,
name|sel
argument_list|)
expr_stmt|;
return|return
name|method
return|;
block|}
end_function

begin_comment
comment|/* Given a linked list of method and a method's name.  Search for the named    method's method structure.  Return a pointer to the method's method    structure if found.  NULL otherwise. */
end_comment

begin_function
name|Method_t
name|search_for_method_in_list
parameter_list|(
name|MethodList_t
name|list
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
name|MethodList_t
name|method_list
init|=
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|sel_is_mapped
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* If not found then we'll search the list.  */
while|while
condition|(
name|method_list
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Search the method list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
condition|)
if|if
condition|(
name|method
operator|->
name|method_name
operator|->
name|sel_id
operator|==
name|op
operator|->
name|sel_id
condition|)
return|return
name|method
return|;
block|}
comment|/* The method wasn't found.  Follow the link to the next list of          methods.  */
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|static
name|retval_t
name|__objc_forward
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|,
name|arglist_t
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Forwarding pointers/integers through the normal registers */
end_comment

begin_function
specifier|static
name|id
name|__objc_word_forward
parameter_list|(
name|id
name|rcv
parameter_list|,
name|SEL
name|op
parameter_list|,
modifier|...
parameter_list|)
block|{
name|void
modifier|*
name|args
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|args
operator|=
name|__builtin_apply_args
argument_list|()
expr_stmt|;
name|res
operator|=
name|__objc_forward
argument_list|(
name|rcv
argument_list|,
name|op
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|__builtin_return
argument_list|(
name|res
argument_list|)
expr_stmt|;
else|else
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Specific routine for forwarding floats/double because of    architectural differences on some processors.  i386s for    example which uses a floating point stack versus general    registers for floating point numbers.  This forward routine     makes sure that GCC restores the proper return values */
end_comment

begin_function
specifier|static
name|double
name|__objc_double_forward
parameter_list|(
name|id
name|rcv
parameter_list|,
name|SEL
name|op
parameter_list|,
modifier|...
parameter_list|)
block|{
name|void
modifier|*
name|args
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|args
operator|=
name|__builtin_apply_args
argument_list|()
expr_stmt|;
name|res
operator|=
name|__objc_forward
argument_list|(
name|rcv
argument_list|,
name|op
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|__builtin_return
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|INVISIBLE_STRUCT_RETURN
end_if

begin_function
specifier|static
name|__big
else|#
directive|else
specifier|static
name|id
endif|#
directive|endif
name|__objc_block_forward
parameter_list|(
name|id
name|rcv
parameter_list|,
name|SEL
name|op
parameter_list|,
modifier|...
parameter_list|)
block|{
name|void
modifier|*
name|args
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|args
operator|=
name|__builtin_apply_args
argument_list|()
expr_stmt|;
name|res
operator|=
name|__objc_forward
argument_list|(
name|rcv
argument_list|,
name|op
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|__builtin_return
argument_list|(
name|res
argument_list|)
expr_stmt|;
else|else
if|#
directive|if
name|INVISIBLE_STRUCT_RETURN
return|return
operator|(
name|__big
operator|)
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
return|;
else|#
directive|else
return|return
name|nil
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This function is installed in the dispatch table for all methods which are    not implemented.  Thus, it is called when a selector is not recognized. */
end_comment

begin_function
specifier|static
name|retval_t
name|__objc_forward
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|,
name|arglist_t
name|args
parameter_list|)
block|{
name|IMP
name|imp
decl_stmt|;
specifier|static
name|SEL
name|frwd_sel
init|=
literal|0
decl_stmt|;
comment|/* !T:SAFE2 */
name|SEL
name|err_sel
decl_stmt|;
comment|/* first try if the object understands forward:: */
if|if
condition|(
operator|!
name|frwd_sel
condition|)
name|frwd_sel
operator|=
name|sel_get_any_uid
argument_list|(
literal|"forward::"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__objc_responds_to
argument_list|(
name|object
argument_list|,
name|frwd_sel
argument_list|)
condition|)
block|{
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|frwd_sel
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|frwd_sel
argument_list|,
name|sel
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/* If the object recognizes the doesNotRecognize: method then we're going      to send it. */
name|err_sel
operator|=
name|sel_get_any_uid
argument_list|(
literal|"doesNotRecognize:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__objc_responds_to
argument_list|(
name|object
argument_list|,
name|err_sel
argument_list|)
condition|)
block|{
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|err_sel
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|err_sel
argument_list|,
name|sel
argument_list|)
return|;
block|}
comment|/* The object doesn't recognize the method.  Check for responding to      error:.  If it does then sent it. */
block|{
name|size_t
name|strlen
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
name|msg
index|[
literal|256
operator|+
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|sel_get_name
argument_list|(
name|sel
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|object
operator|->
name|class_pointer
operator|->
name|name
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"(%s) %s does not recognize %s"
argument_list|,
operator|(
name|CLS_ISMETA
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
literal|"class"
else|:
literal|"instance"
operator|)
argument_list|,
name|object
operator|->
name|class_pointer
operator|->
name|name
argument_list|,
name|sel_get_name
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|err_sel
operator|=
name|sel_get_any_uid
argument_list|(
literal|"error:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__objc_responds_to
argument_list|(
name|object
argument_list|,
name|err_sel
argument_list|)
condition|)
block|{
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|err_sel
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|sel_get_any_uid
argument_list|(
literal|"error:"
argument_list|)
argument_list|,
name|msg
argument_list|)
return|;
block|}
comment|/* The object doesn't respond to doesNotRecognize: or error:;  Therefore,        a default action is taken. */
name|objc_error
argument_list|(
name|object
argument_list|,
name|OBJC_ERR_UNIMPLEMENTED
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|__objc_print_dtable_stats
parameter_list|()
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE2
name|printf
argument_list|(
literal|"memory usage: (%s)\n"
argument_list|,
literal|"2-level sparse arrays"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"memory usage: (%s)\n"
argument_list|,
literal|"3-level sparse arrays"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"arrays: %d = %ld bytes\n"
argument_list|,
name|narrays
argument_list|,
operator|(
name|long
operator|)
name|narrays
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|+=
name|narrays
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"buckets: %d = %ld bytes\n"
argument_list|,
name|nbuckets
argument_list|,
operator|(
name|long
operator|)
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|+=
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"idxtables: %d = %ld bytes\n"
argument_list|,
name|idxsize
argument_list|,
operator|(
name|long
operator|)
name|idxsize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|+=
name|idxsize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-----------------------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total: %d bytes\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"===================================\n"
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the uninstalled dispatch table indicator.  If a class' dispatch table points to __objc_uninstalled_dtable  then that means it needs its dispatch table to be installed. */
end_comment

begin_function
name|__inline__
name|struct
name|sarray
modifier|*
name|objc_get_uninstalled_dtable
parameter_list|()
block|{
return|return
name|__objc_uninstalled_dtable
return|;
block|}
end_function

end_unit

