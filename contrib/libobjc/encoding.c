begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Encoding of types for Objective C.    Copyright (C) 1993, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup    Bitfield support by Ovidiu Predescu  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files    compiled with GCC to produce an executable, this does not cause    the resulting executable to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"objc-api.h"
end_include

begin_include
include|#
directive|include
file|"encoding.h"
end_include

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|({ typeof(X) __x = (X), __y = (Y); \      (__x> __y ? __x : __y); })
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|({ typeof(X) __x = (X), __y = (Y); \      (__x< __y ? __x : __y); })
end_define

begin_define
define|#
directive|define
name|ROUND
parameter_list|(
name|V
parameter_list|,
name|A
parameter_list|)
define|\
value|({ typeof(V) __v=(V); typeof(A) __a=(A); \      __a*((__v+__a-1)/__a); })
end_define

begin_comment
comment|/* Various hacks for objc_layout_record. These are used by the target    macros. */
end_comment

begin_define
define|#
directive|define
name|TREE_CODE
parameter_list|(
name|TYPE
parameter_list|)
value|*TYPE
end_define

begin_define
define|#
directive|define
name|TREE_TYPE
parameter_list|(
name|TREE
parameter_list|)
value|TREE
end_define

begin_define
define|#
directive|define
name|RECORD_TYPE
value|_C_STRUCT_B
end_define

begin_define
define|#
directive|define
name|UNION_TYPE
value|_C_UNION_B
end_define

begin_define
define|#
directive|define
name|QUAL_UNION_TYPE
value|_C_UNION_B
end_define

begin_define
define|#
directive|define
name|ARRAY_TYPE
value|_C_ARY_B
end_define

begin_define
define|#
directive|define
name|TYPE_FIELDS
parameter_list|(
name|TYPE
parameter_list|)
value|objc_skip_typespec (TYPE)
end_define

begin_define
define|#
directive|define
name|DECL_MODE
parameter_list|(
name|TYPE
parameter_list|)
value|*(TYPE)
end_define

begin_define
define|#
directive|define
name|DFmode
value|_C_DBL
end_define

begin_define
define|#
directive|define
name|get_inner_array_type
parameter_list|(
name|TYPE
parameter_list|)
value|((TYPE) + 1)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|atoi
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|res
operator|*=
literal|10
operator|,
name|res
operator|+=
operator|(
operator|*
name|str
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*   return the size of an object specified by type  */
end_comment

begin_function
name|int
name|objc_sizeof_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_ID
case|:
return|return
sizeof|sizeof
argument_list|(
name|id
argument_list|)
return|;
break|break;
case|case
name|_C_CLASS
case|:
return|return
sizeof|sizeof
argument_list|(
name|Class
argument_list|)
return|;
break|break;
case|case
name|_C_SEL
case|:
return|return
sizeof|sizeof
argument_list|(
name|SEL
argument_list|)
return|;
break|break;
case|case
name|_C_CHR
case|:
return|return
sizeof|sizeof
argument_list|(
name|char
argument_list|)
return|;
break|break;
case|case
name|_C_UCHR
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
return|;
break|break;
case|case
name|_C_SHT
case|:
return|return
sizeof|sizeof
argument_list|(
name|short
argument_list|)
return|;
break|break;
case|case
name|_C_USHT
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
return|;
break|break;
case|case
name|_C_INT
case|:
return|return
sizeof|sizeof
argument_list|(
name|int
argument_list|)
return|;
break|break;
case|case
name|_C_UINT
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
return|;
break|break;
case|case
name|_C_LNG
case|:
return|return
sizeof|sizeof
argument_list|(
name|long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
return|;
break|break;
case|case
name|_C_LNG_LNG
case|:
return|return
expr|sizeof
operator|(
name|long
name|long
operator|)
return|;
break|break;
case|case
name|_C_ULNG_LNG
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|long
name|long
operator|)
return|;
break|break;
case|case
name|_C_FLT
case|:
return|return
sizeof|sizeof
argument_list|(
name|float
argument_list|)
return|;
break|break;
case|case
name|_C_DBL
case|:
return|return
sizeof|sizeof
argument_list|(
name|double
argument_list|)
return|;
break|break;
case|case
name|_C_VOID
case|:
return|return
sizeof|sizeof
argument_list|(
name|void
argument_list|)
return|;
break|break;
case|case
name|_C_PTR
case|:
case|case
name|_C_ATOM
case|:
case|case
name|_C_CHARPTR
case|:
return|return
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
return|;
break|break;
case|case
name|_C_ARY_B
case|:
block|{
name|int
name|len
init|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
return|return
name|len
operator|*
name|objc_aligned_size
argument_list|(
name|type
argument_list|)
return|;
block|}
break|break;
case|case
name|_C_BFLD
case|:
block|{
comment|/* The new encoding of bitfields is: b 'position' 'type' 'size' */
name|int
name|position
decl_stmt|,
name|size
decl_stmt|;
name|int
name|startByte
decl_stmt|,
name|endByte
decl_stmt|;
name|position
operator|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
expr_stmt|;
name|startByte
operator|=
name|position
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|endByte
operator|=
operator|(
name|position
operator|+
name|size
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|endByte
operator|-
name|startByte
return|;
block|}
case|case
name|_C_STRUCT_B
case|:
block|{
name|struct
name|objc_struct_layout
name|layout
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|objc_layout_structure
argument_list|(
name|type
argument_list|,
operator|&
name|layout
argument_list|)
expr_stmt|;
while|while
condition|(
name|objc_layout_structure_next_member
argument_list|(
operator|&
name|layout
argument_list|)
condition|)
comment|/* do nothing */
empty_stmt|;
name|objc_layout_finish_structure
argument_list|(
operator|&
name|layout
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
case|case
name|_C_UNION_B
case|:
block|{
name|int
name|max_size
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
comment|/* do nothing */
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
condition|)
block|{
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|max_size
operator|=
name|MAX
argument_list|(
name|max_size
argument_list|,
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|max_size
return|;
block|}
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   Return the alignment of an object specified by type  */
end_comment

begin_function
name|int
name|objc_alignof_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_ID
case|:
return|return
name|__alignof__
argument_list|(
name|id
argument_list|)
return|;
break|break;
case|case
name|_C_CLASS
case|:
return|return
name|__alignof__
argument_list|(
name|Class
argument_list|)
return|;
break|break;
case|case
name|_C_SEL
case|:
return|return
name|__alignof__
argument_list|(
name|SEL
argument_list|)
return|;
break|break;
case|case
name|_C_CHR
case|:
return|return
name|__alignof__
argument_list|(
name|char
argument_list|)
return|;
break|break;
case|case
name|_C_UCHR
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned char
argument_list|)
return|;
break|break;
case|case
name|_C_SHT
case|:
return|return
name|__alignof__
argument_list|(
name|short
argument_list|)
return|;
break|break;
case|case
name|_C_USHT
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned short
argument_list|)
return|;
break|break;
case|case
name|_C_INT
case|:
return|return
name|__alignof__
argument_list|(
name|int
argument_list|)
return|;
break|break;
case|case
name|_C_UINT
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned int
argument_list|)
return|;
break|break;
case|case
name|_C_LNG
case|:
return|return
name|__alignof__
argument_list|(
name|long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned long
argument_list|)
return|;
break|break;
case|case
name|_C_LNG_LNG
case|:
return|return
name|__alignof__
argument_list|(
argument|long long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG_LNG
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned long long
argument_list|)
return|;
break|break;
case|case
name|_C_FLT
case|:
return|return
name|__alignof__
argument_list|(
name|float
argument_list|)
return|;
break|break;
case|case
name|_C_DBL
case|:
return|return
name|__alignof__
argument_list|(
name|double
argument_list|)
return|;
break|break;
case|case
name|_C_PTR
case|:
case|case
name|_C_ATOM
case|:
case|case
name|_C_CHARPTR
case|:
return|return
name|__alignof__
argument_list|(
name|char
operator|*
argument_list|)
return|;
break|break;
case|case
name|_C_ARY_B
case|:
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
comment|/* do nothing */
empty_stmt|;
return|return
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
return|;
case|case
name|_C_STRUCT_B
case|:
block|{
name|struct
name|objc_struct_layout
name|layout
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|objc_layout_structure
argument_list|(
name|type
argument_list|,
operator|&
name|layout
argument_list|)
expr_stmt|;
while|while
condition|(
name|objc_layout_structure_next_member
argument_list|(
operator|&
name|layout
argument_list|)
condition|)
comment|/* do nothing */
empty_stmt|;
name|objc_layout_finish_structure
argument_list|(
operator|&
name|layout
argument_list|,
name|NULL
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
return|return
name|align
return|;
block|}
case|case
name|_C_UNION_B
case|:
block|{
name|int
name|maxalign
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
comment|/* do nothing */
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
condition|)
block|{
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|maxalign
operator|=
name|MAX
argument_list|(
name|maxalign
argument_list|,
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|maxalign
return|;
block|}
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   The aligned size if the size rounded up to the nearest alignment. */
end_comment

begin_function
name|int
name|objc_aligned_size
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|;
comment|/* Skip the variable name */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|size
operator|=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|align
operator|=
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|ROUND
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   The size rounded up to the nearest integral of the wordsize, taken   to be the size of a void*. */
end_comment

begin_function
name|int
name|objc_promoted_size
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|wordsize
decl_stmt|;
comment|/* Skip the variable name */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|size
operator|=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|wordsize
operator|=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
return|return
name|ROUND
argument_list|(
name|size
argument_list|,
name|wordsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Skip type qualifiers.  These may eventually precede typespecs   occurring in method prototype encodings. */
end_comment

begin_function
specifier|inline
specifier|const
name|char
modifier|*
name|objc_skip_type_qualifiers
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
while|while
condition|(
operator|*
name|type
operator|==
name|_C_CONST
operator|||
operator|*
name|type
operator|==
name|_C_IN
operator|||
operator|*
name|type
operator|==
name|_C_INOUT
operator|||
operator|*
name|type
operator|==
name|_C_OUT
operator|||
operator|*
name|type
operator|==
name|_C_BYCOPY
operator|||
operator|*
name|type
operator|==
name|_C_BYREF
operator|||
operator|*
name|type
operator|==
name|_C_ONEWAY
operator|||
operator|*
name|type
operator|==
name|_C_GCINVISIBLE
condition|)
block|{
name|type
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Skip one typespec element.  If the typespec is prepended by type   qualifiers, these are skipped as well. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|objc_skip_typespec
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|type
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_ID
case|:
comment|/* An id may be annotated by the actual type if it is known        with the @"ClassName" syntax */
if|if
condition|(
operator|*
operator|++
name|type
operator|!=
literal|'"'
condition|)
return|return
name|type
return|;
else|else
block|{
while|while
condition|(
operator|*
operator|++
name|type
operator|!=
literal|'"'
condition|)
comment|/* do nothing */
empty_stmt|;
return|return
name|type
operator|+
literal|1
return|;
block|}
comment|/* The following are one character type codes */
case|case
name|_C_CLASS
case|:
case|case
name|_C_SEL
case|:
case|case
name|_C_CHR
case|:
case|case
name|_C_UCHR
case|:
case|case
name|_C_CHARPTR
case|:
case|case
name|_C_ATOM
case|:
case|case
name|_C_SHT
case|:
case|case
name|_C_USHT
case|:
case|case
name|_C_INT
case|:
case|case
name|_C_UINT
case|:
case|case
name|_C_LNG
case|:
case|case
name|_C_ULNG
case|:
case|case
name|_C_LNG_LNG
case|:
case|case
name|_C_ULNG_LNG
case|:
case|case
name|_C_FLT
case|:
case|case
name|_C_DBL
case|:
case|case
name|_C_VOID
case|:
case|case
name|_C_UNDEF
case|:
return|return
operator|++
name|type
return|;
break|break;
case|case
name|_C_ARY_B
case|:
comment|/* skip digits, typespec and closing ']' */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
name|_C_ARY_E
condition|)
return|return
operator|++
name|type
return|;
else|else
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"bad array type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|_C_BFLD
case|:
comment|/* The new encoding of bitfields is: b 'position' 'type' 'size' */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
comment|/* skip position */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
comment|/* skip type and size */
return|return
name|type
return|;
case|case
name|_C_STRUCT_B
case|:
comment|/* skip name, and elements until closing '}'  */
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
condition|)
block|{
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|++
name|type
return|;
case|case
name|_C_UNION_B
case|:
comment|/* skip name, and elements until closing ')'  */
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
condition|)
block|{
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|++
name|type
return|;
case|case
name|_C_PTR
case|:
comment|/* Just skip the following typespec */
return|return
name|objc_skip_typespec
argument_list|(
operator|++
name|type
argument_list|)
return|;
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   Skip an offset as part of a method encoding.  This is prepended by a   '+' if the argument is passed in registers. */
end_comment

begin_function
specifier|inline
specifier|const
name|char
modifier|*
name|objc_skip_offset
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
operator|*
name|type
operator|==
literal|'+'
condition|)
name|type
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Skip an argument specification of a method encoding. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|objc_skip_argspec
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|objc_skip_offset
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Return the number of arguments that the method MTH expects.   Note that all methods need two implicit arguments `self' and   `_cmd'.  */
end_comment

begin_function
name|int
name|method_get_number_of_arguments
parameter_list|(
name|struct
name|objc_method
modifier|*
name|mth
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
name|mth
operator|->
name|method_types
decl_stmt|;
while|while
condition|(
operator|*
name|type
condition|)
block|{
name|type
operator|=
name|objc_skip_argspec
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|i
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*   Return the size of the argument block needed on the stack to invoke   the method MTH.  This may be zero, if all arguments are passed in   registers. */
end_comment

begin_function
name|int
name|method_get_sizeof_arguments
parameter_list|(
name|struct
name|objc_method
modifier|*
name|mth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|type
init|=
name|objc_skip_typespec
argument_list|(
name|mth
operator|->
name|method_types
argument_list|)
decl_stmt|;
return|return
name|atoi
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Return a pointer to the next argument of ARGFRAME.  type points to   the last argument.  Typical use of this look like:    {     char *datum, *type;      for (datum = method_get_first_argument (method, argframe,&type);          datum; datum = method_get_next_argument (argframe,&type))       {         unsigned flags = objc_get_type_qualifiers (type);         type = objc_skip_type_qualifiers (type); 	if (*type != _C_PTR)           [portal encodeData: datum ofType: type]; 	else 	  { 	    if ((flags& _F_IN) == _F_IN)               [portal encodeData: *(char**)datum ofType: ++type]; 	  }       }   } */
end_comment

begin_function
name|char
modifier|*
name|method_get_next_argument
parameter_list|(
name|arglist_t
name|argframe
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|objc_skip_argspec
argument_list|(
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
operator|*
name|type
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|objc_skip_typespec
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'+'
condition|)
return|return
name|argframe
operator|->
name|arg_regs
operator|+
name|atoi
argument_list|(
operator|++
name|t
argument_list|)
return|;
else|else
return|return
name|argframe
operator|->
name|arg_ptr
operator|+
name|atoi
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Return a pointer to the value of the first argument of the method    described in M with the given argumentframe ARGFRAME.  The type   is returned in TYPE.  type must be passed to successive calls of    method_get_next_argument. */
end_comment

begin_function
name|char
modifier|*
name|method_get_first_argument
parameter_list|(
name|struct
name|objc_method
modifier|*
name|m
parameter_list|,
name|arglist_t
name|argframe
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
operator|*
name|type
operator|=
name|m
operator|->
name|method_types
expr_stmt|;
return|return
name|method_get_next_argument
argument_list|(
name|argframe
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    Return a pointer to the ARGth argument of the method    M from the frame ARGFRAME.  The type of the argument    is returned in the value-result argument TYPE  */
end_comment

begin_function
name|char
modifier|*
name|method_get_nth_argument
parameter_list|(
name|struct
name|objc_method
modifier|*
name|m
parameter_list|,
name|arglist_t
name|argframe
parameter_list|,
name|int
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|objc_skip_argspec
argument_list|(
name|m
operator|->
name|method_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|>
name|method_get_number_of_arguments
argument_list|(
name|m
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|arg
operator|--
condition|)
name|t
operator|=
name|objc_skip_argspec
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|objc_skip_typespec
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'+'
condition|)
return|return
name|argframe
operator|->
name|arg_regs
operator|+
name|atoi
argument_list|(
operator|++
name|t
argument_list|)
return|;
else|else
return|return
name|argframe
operator|->
name|arg_ptr
operator|+
name|atoi
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|objc_get_type_qualifiers
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|res
init|=
literal|0
decl_stmt|;
name|BOOL
name|flag
init|=
name|YES
decl_stmt|;
while|while
condition|(
name|flag
condition|)
switch|switch
condition|(
operator|*
name|type
operator|++
condition|)
block|{
case|case
name|_C_CONST
case|:
name|res
operator||=
name|_F_CONST
expr_stmt|;
break|break;
case|case
name|_C_IN
case|:
name|res
operator||=
name|_F_IN
expr_stmt|;
break|break;
case|case
name|_C_INOUT
case|:
name|res
operator||=
name|_F_INOUT
expr_stmt|;
break|break;
case|case
name|_C_OUT
case|:
name|res
operator||=
name|_F_OUT
expr_stmt|;
break|break;
case|case
name|_C_BYCOPY
case|:
name|res
operator||=
name|_F_BYCOPY
expr_stmt|;
break|break;
case|case
name|_C_BYREF
case|:
name|res
operator||=
name|_F_BYREF
expr_stmt|;
break|break;
case|case
name|_C_ONEWAY
case|:
name|res
operator||=
name|_F_ONEWAY
expr_stmt|;
break|break;
case|case
name|_C_GCINVISIBLE
case|:
name|res
operator||=
name|_F_GCINVISIBLE
expr_stmt|;
break|break;
default|default:
name|flag
operator|=
name|NO
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* The following three functions can be used to determine how a    structure is laid out by the compiler. For example:    struct objc_struct_layout layout;   int i;    objc_layout_structure (type,&layout);   while (objc_layout_structure_next_member (&layout))     {       int position, align;       const char *type;        objc_layout_structure_get_info (&layout,&position,&align,&type);       printf ("element %d has offset %d, alignment %d\n",               i++, position, align);     }    These functions are used by objc_sizeof_type and objc_alignof_type   functions to compute the size and alignment of structures. The   previous method of computing the size and alignment of a structure   was not working on some architectures, particulary on AIX, and in   the presence of bitfields inside the structure. */
end_comment

begin_function
name|void
name|objc_layout_structure
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|struct
name|objc_struct_layout
modifier|*
name|layout
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ntype
decl_stmt|;
if|if
condition|(
operator|*
name|type
operator|++
operator|!=
name|_C_STRUCT_B
condition|)
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"record type expected in objc_layout_structure, got %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|layout
operator|->
name|original_type
operator|=
name|type
expr_stmt|;
comment|/* Skip "<name>=" if any. Avoid embedded structures and unions. */
name|ntype
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|*
name|ntype
operator|!=
name|_C_STRUCT_E
operator|&&
operator|*
name|ntype
operator|!=
name|_C_STRUCT_B
operator|&&
operator|*
name|ntype
operator|!=
name|_C_UNION_B
operator|&&
operator|*
name|ntype
operator|++
operator|!=
literal|'='
condition|)
comment|/* do nothing */
empty_stmt|;
comment|/* If there's a "<name>=", ntype - 1 points to '='; skip the the name */
if|if
condition|(
operator|*
operator|(
name|ntype
operator|-
literal|1
operator|)
operator|==
literal|'='
condition|)
name|type
operator|=
name|ntype
expr_stmt|;
name|layout
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|layout
operator|->
name|prev_type
operator|=
name|NULL
expr_stmt|;
name|layout
operator|->
name|record_size
operator|=
literal|0
expr_stmt|;
name|layout
operator|->
name|record_align
operator|=
name|BITS_PER_UNIT
expr_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|STRUCTURE_SIZE_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|BOOL
name|objc_layout_structure_next_member
parameter_list|(
name|struct
name|objc_struct_layout
modifier|*
name|layout
parameter_list|)
block|{
specifier|register
name|int
name|known_align
init|=
name|layout
operator|->
name|record_size
decl_stmt|;
specifier|register
name|int
name|desired_align
init|=
literal|0
decl_stmt|;
comment|/* The following are used only if the field is a bitfield */
specifier|register
specifier|const
name|char
modifier|*
name|bfld_type
decl_stmt|;
specifier|register
name|int
name|bfld_type_size
decl_stmt|,
name|bfld_type_align
decl_stmt|,
name|bfld_field_size
decl_stmt|;
comment|/* The current type without the type qualifiers */
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|layout
operator|->
name|prev_type
operator|==
name|NULL
condition|)
block|{
name|layout
operator|->
name|prev_type
operator|=
name|layout
operator|->
name|type
expr_stmt|;
name|layout
operator|->
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|layout
operator|->
name|prev_type
argument_list|)
expr_stmt|;
return|return
name|YES
return|;
block|}
endif|#
directive|endif
comment|/* Add the size of the previous field to the size of the record.  */
if|if
condition|(
name|layout
operator|->
name|prev_type
condition|)
block|{
name|type
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|layout
operator|->
name|prev_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|!=
name|_C_BFLD
condition|)
name|layout
operator|->
name|record_size
operator|+=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
else|else
block|{
name|desired_align
operator|=
literal|1
expr_stmt|;
comment|/* Get the bitfield's type */
for|for
control|(
name|bfld_type
operator|=
name|type
operator|+
literal|1
init|;
name|isdigit
argument_list|(
operator|*
name|bfld_type
argument_list|)
condition|;
name|bfld_type
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
name|bfld_type_size
operator|=
name|objc_sizeof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bfld_type_align
operator|=
name|objc_alignof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bfld_field_size
operator|=
name|atoi
argument_list|(
name|objc_skip_typespec
argument_list|(
name|bfld_type
argument_list|)
argument_list|)
expr_stmt|;
name|layout
operator|->
name|record_size
operator|+=
name|bfld_field_size
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|layout
operator|->
name|type
operator|==
name|_C_STRUCT_E
condition|)
return|return
name|NO
return|;
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|layout
operator|->
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|layout
operator|->
name|type
operator|++
init|;
operator|*
name|layout
operator|->
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|type
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|layout
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|!=
name|_C_BFLD
condition|)
name|desired_align
operator|=
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
else|else
block|{
name|desired_align
operator|=
literal|1
expr_stmt|;
comment|/* Skip the bitfield's offset */
for|for
control|(
name|bfld_type
operator|=
name|type
operator|+
literal|1
init|;
name|isdigit
argument_list|(
operator|*
name|bfld_type
argument_list|)
condition|;
name|bfld_type
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
name|bfld_type_size
operator|=
name|objc_sizeof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bfld_type_align
operator|=
name|objc_alignof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bfld_field_size
operator|=
name|atoi
argument_list|(
name|objc_skip_typespec
argument_list|(
name|bfld_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIGGEST_FIELD_ALIGNMENT
name|desired_align
operator|=
name|MIN
argument_list|(
name|desired_align
argument_list|,
name|BIGGEST_FIELD_ALIGNMENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ADJUST_FIELD_ALIGN
name|desired_align
operator|=
name|ADJUST_FIELD_ALIGN
argument_list|(
name|type
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record must have at least as much alignment as any field.      Otherwise, the alignment of the field within the record      is meaningless.  */
ifndef|#
directive|ifndef
name|PCC_BITFIELD_TYPE_MATTERS
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|*
name|type
operator|==
name|_C_BFLD
condition|)
block|{
comment|/* For these machines, a zero-length field does not          affect the alignment of the structure as a whole.          It does, however, affect the alignment of the next field          within the structure.  */
if|if
condition|(
name|bfld_field_size
condition|)
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
else|else
name|desired_align
operator|=
name|objc_alignof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* A named bit field of declared type `int'          forces the entire structure to have `int' alignment.          Q1: How is encoded this thing and how to check for it?          Q2: How to determine maximum_field_alignment at runtime? */
comment|/*	  if (DECL_NAME (field) != 0) */
block|{
name|int
name|type_align
init|=
name|bfld_type_align
decl_stmt|;
if|#
directive|if
literal|0
block|if (maximum_field_alignment != 0)           type_align = MIN (type_align, maximum_field_alignment);         else if (DECL_PACKED (field))           type_align = MIN (type_align, BITS_PER_UNIT);
endif|#
directive|endif
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Does this field automatically have alignment it needs      by virtue of the fields that precede it and the record's      own alignment?  */
if|if
condition|(
operator|*
name|type
operator|==
name|_C_BFLD
condition|)
name|layout
operator|->
name|record_size
operator|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|layout
operator|->
name|record_size
operator|%
name|desired_align
operator|!=
literal|0
condition|)
block|{
comment|/* No, we need to skip space before this field.          Bump the cumulative size to multiple of field alignment.  */
name|layout
operator|->
name|record_size
operator|=
name|ROUND
argument_list|(
name|layout
operator|->
name|record_size
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
block|}
comment|/* Jump to the next field in record. */
name|layout
operator|->
name|prev_type
operator|=
name|layout
operator|->
name|type
expr_stmt|;
name|layout
operator|->
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|layout
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* skip component */
return|return
name|YES
return|;
block|}
end_function

begin_function
name|void
name|objc_layout_finish_structure
parameter_list|(
name|struct
name|objc_struct_layout
modifier|*
name|layout
parameter_list|,
name|unsigned
name|int
modifier|*
name|size
parameter_list|,
name|unsigned
name|int
modifier|*
name|align
parameter_list|)
block|{
if|if
condition|(
name|layout
operator|->
name|type
operator|&&
operator|*
name|layout
operator|->
name|type
operator|==
name|_C_STRUCT_E
condition|)
block|{
comment|/* Work out the alignment of the record as one expression and store          in the record type.  Round it up to a multiple of the record's          alignment. */
ifdef|#
directive|ifdef
name|ROUND_TYPE_ALIGN
name|layout
operator|->
name|record_align
operator|=
name|ROUND_TYPE_ALIGN
argument_list|(
name|layout
operator|->
name|original_type
argument_list|,
literal|1
argument_list|,
name|layout
operator|->
name|record_align
argument_list|)
expr_stmt|;
else|#
directive|else
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|layout
operator|->
name|record_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ROUND_TYPE_SIZE
name|layout
operator|->
name|record_size
operator|=
name|ROUND_TYPE_SIZE
argument_list|(
name|layout
operator|->
name|original_type
argument_list|,
name|layout
operator|->
name|record_size
argument_list|,
name|layout
operator|->
name|record_align
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Round the size up to be a multiple of the required alignment */
name|layout
operator|->
name|record_size
operator|=
name|ROUND
argument_list|(
name|layout
operator|->
name|record_size
argument_list|,
name|layout
operator|->
name|record_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|layout
operator|->
name|type
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|layout
operator|->
name|record_size
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|align
condition|)
operator|*
name|align
operator|=
name|layout
operator|->
name|record_align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_layout_structure_get_info
parameter_list|(
name|struct
name|objc_struct_layout
modifier|*
name|layout
parameter_list|,
name|unsigned
name|int
modifier|*
name|offset
parameter_list|,
name|unsigned
name|int
modifier|*
name|align
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|offset
condition|)
operator|*
name|offset
operator|=
name|layout
operator|->
name|record_size
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|align
condition|)
operator|*
name|align
operator|=
name|layout
operator|->
name|record_align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|layout
operator|->
name|prev_type
expr_stmt|;
block|}
end_function

end_unit

