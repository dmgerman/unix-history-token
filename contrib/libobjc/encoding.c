begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Encoding of types for Objective C.    Copyright (C) 1993, 1995, 1996, 1997, 1998, 2000, 2002, 2004    Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup    Bitfield support by Ovidiu Predescu  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files    compiled with GCC to produce an executable, this does not cause    the resulting executable to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* FIXME: This file has no business including tm.h.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"objc/objc-api.h"
end_include

begin_include
include|#
directive|include
file|"objc/encoding.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|({ typeof (X) __x = (X), __y = (Y); \      (__x> __y ? __x : __y); })
end_define

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|({ typeof (X) __x = (X), __y = (Y); \      (__x< __y ? __x : __y); })
end_define

begin_undef
undef|#
directive|undef
name|ROUND
end_undef

begin_define
define|#
directive|define
name|ROUND
parameter_list|(
name|V
parameter_list|,
name|A
parameter_list|)
define|\
value|({ typeof (V) __v = (V); typeof (A) __a = (A); \      __a * ((__v+__a - 1)/__a); })
end_define

begin_comment
comment|/* Various hacks for objc_layout_record. These are used by the target    macros. */
end_comment

begin_define
define|#
directive|define
name|TREE_CODE
parameter_list|(
name|TYPE
parameter_list|)
value|*(TYPE)
end_define

begin_define
define|#
directive|define
name|TREE_TYPE
parameter_list|(
name|TREE
parameter_list|)
value|(TREE)
end_define

begin_define
define|#
directive|define
name|RECORD_TYPE
value|_C_STRUCT_B
end_define

begin_define
define|#
directive|define
name|UNION_TYPE
value|_C_UNION_B
end_define

begin_define
define|#
directive|define
name|QUAL_UNION_TYPE
value|_C_UNION_B
end_define

begin_define
define|#
directive|define
name|ARRAY_TYPE
value|_C_ARY_B
end_define

begin_define
define|#
directive|define
name|REAL_TYPE
value|_C_DBL
end_define

begin_define
define|#
directive|define
name|VECTOR_TYPE
value|_C_VECTOR
end_define

begin_define
define|#
directive|define
name|TYPE_FIELDS
parameter_list|(
name|TYPE
parameter_list|)
value|({const char *_field = (TYPE)+1; \     while (*_field != _C_STRUCT_E&& *_field != _C_STRUCT_B \&& *_field != _C_UNION_B&& *_field++ != '=') \
comment|/* do nothing */
value|; \     _field;})
end_define

begin_define
define|#
directive|define
name|DECL_MODE
parameter_list|(
name|TYPE
parameter_list|)
value|*(TYPE)
end_define

begin_define
define|#
directive|define
name|TYPE_MODE
parameter_list|(
name|TYPE
parameter_list|)
value|*(TYPE)
end_define

begin_define
define|#
directive|define
name|DFmode
value|_C_DBL
end_define

begin_define
define|#
directive|define
name|get_inner_array_type
parameter_list|(
name|TYPE
parameter_list|)
value|({const char *_field = (TYPE); \   while (*_field == _C_ARY_B)\     {\       while (isdigit ((unsigned char)*++_field))\ 	;\     }\     _field;})
end_define

begin_comment
comment|/* Some ports (eg ARM) allow the structure size boundary to be    selected at compile-time.  We override the normal definition with    one that has a constant value for this compilation.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITS_PER_UNIT
end_ifndef

begin_define
define|#
directive|define
name|BITS_PER_UNIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|STRUCTURE_SIZE_BOUNDARY
end_undef

begin_define
define|#
directive|define
name|STRUCTURE_SIZE_BOUNDARY
value|(BITS_PER_UNIT * sizeof (struct{char a;}))
end_define

begin_comment
comment|/* Some ROUND_TYPE_ALIGN macros use TARGET_foo, and consequently    target_flags.  Define a dummy entry here to so we don't die.    We have to rename it because target_flags may already have been    declared extern.  */
end_comment

begin_define
define|#
directive|define
name|target_flags
value|not_target_flags
end_define

begin_decl_stmt
specifier|static
name|int
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
name|not_target_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some ROUND_TYPE_ALIGN use ALTIVEC_VECTOR_MODE (rs6000 darwin).    Define a dummy ALTIVEC_VECTOR_MODE so it will not die.  */
end_comment

begin_undef
undef|#
directive|undef
name|ALTIVEC_VECTOR_MODE
end_undef

begin_define
define|#
directive|define
name|ALTIVEC_VECTOR_MODE
parameter_list|(
name|MODE
parameter_list|)
value|(0)
end_define

begin_comment
comment|/*  FIXME: while this file has no business including tm.h, this     definitely has no business defining this macro but it     is only way around without really rewritting this file,     should look after the branch of 3.4 to fix this.  */
end_comment

begin_define
define|#
directive|define
name|rs6000_special_round_type_align
parameter_list|(
name|STRUCT
parameter_list|,
name|COMPUTED
parameter_list|,
name|SPECIFIED
parameter_list|)
define|\
value|({ const char *_fields = TYPE_FIELDS (STRUCT);				\   ((_fields != 0							\&& TYPE_MODE (TREE_CODE (TREE_TYPE (_fields)) == ARRAY_TYPE		\ 		    ? get_inner_array_type (_fields)			\ 		    : TREE_TYPE (_fields)) == DFmode)			\    ? MAX (MAX (COMPUTED, SPECIFIED), 64)				\    : MAX (COMPUTED, SPECIFIED));})
end_define

begin_comment
comment|/*   return the size of an object specified by type */
end_comment

begin_function
name|int
name|objc_sizeof_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_BOOL
case|:
return|return
sizeof|sizeof
argument_list|(
name|_Bool
argument_list|)
return|;
break|break;
case|case
name|_C_ID
case|:
return|return
sizeof|sizeof
argument_list|(
name|id
argument_list|)
return|;
break|break;
case|case
name|_C_CLASS
case|:
return|return
sizeof|sizeof
argument_list|(
name|Class
argument_list|)
return|;
break|break;
case|case
name|_C_SEL
case|:
return|return
sizeof|sizeof
argument_list|(
name|SEL
argument_list|)
return|;
break|break;
case|case
name|_C_CHR
case|:
return|return
sizeof|sizeof
argument_list|(
name|char
argument_list|)
return|;
break|break;
case|case
name|_C_UCHR
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
return|;
break|break;
case|case
name|_C_SHT
case|:
return|return
sizeof|sizeof
argument_list|(
name|short
argument_list|)
return|;
break|break;
case|case
name|_C_USHT
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
return|;
break|break;
case|case
name|_C_INT
case|:
return|return
sizeof|sizeof
argument_list|(
name|int
argument_list|)
return|;
break|break;
case|case
name|_C_UINT
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
return|;
break|break;
case|case
name|_C_LNG
case|:
return|return
sizeof|sizeof
argument_list|(
name|long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
return|;
break|break;
case|case
name|_C_LNG_LNG
case|:
return|return
expr|sizeof
operator|(
name|long
name|long
operator|)
return|;
break|break;
case|case
name|_C_ULNG_LNG
case|:
return|return
expr|sizeof
operator|(
name|unsigned
name|long
name|long
operator|)
return|;
break|break;
case|case
name|_C_FLT
case|:
return|return
sizeof|sizeof
argument_list|(
name|float
argument_list|)
return|;
break|break;
case|case
name|_C_DBL
case|:
return|return
sizeof|sizeof
argument_list|(
name|double
argument_list|)
return|;
break|break;
case|case
name|_C_VOID
case|:
return|return
sizeof|sizeof
argument_list|(
name|void
argument_list|)
return|;
break|break;
case|case
name|_C_PTR
case|:
case|case
name|_C_ATOM
case|:
case|case
name|_C_CHARPTR
case|:
return|return
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
return|;
break|break;
case|case
name|_C_ARY_B
case|:
block|{
name|int
name|len
init|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
return|return
name|len
operator|*
name|objc_aligned_size
argument_list|(
name|type
argument_list|)
return|;
block|}
break|break;
case|case
name|_C_BFLD
case|:
block|{
comment|/* The new encoding of bitfields is: b 'position' 'type' 'size' */
name|int
name|position
decl_stmt|,
name|size
decl_stmt|;
name|int
name|startByte
decl_stmt|,
name|endByte
decl_stmt|;
name|position
operator|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
expr_stmt|;
name|startByte
operator|=
name|position
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|endByte
operator|=
operator|(
name|position
operator|+
name|size
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|endByte
operator|-
name|startByte
return|;
block|}
case|case
name|_C_UNION_B
case|:
case|case
name|_C_STRUCT_B
case|:
block|{
name|struct
name|objc_struct_layout
name|layout
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|objc_layout_structure
argument_list|(
name|type
argument_list|,
operator|&
name|layout
argument_list|)
expr_stmt|;
while|while
condition|(
name|objc_layout_structure_next_member
argument_list|(
operator|&
name|layout
argument_list|)
condition|)
comment|/* do nothing */
empty_stmt|;
name|objc_layout_finish_structure
argument_list|(
operator|&
name|layout
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
case|case
name|_C_COMPLEX
case|:
block|{
name|type
operator|++
expr_stmt|;
comment|/* Skip after the 'j'. */
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_CHR
case|:
return|return
sizeof|sizeof
argument_list|(
specifier|_Complex
name|char
argument_list|)
return|;
break|break;
case|case
name|_C_UCHR
case|:
return|return
expr|sizeof
operator|(
specifier|_Complex
name|unsigned
name|char
operator|)
return|;
break|break;
case|case
name|_C_SHT
case|:
return|return
sizeof|sizeof
argument_list|(
specifier|_Complex
name|short
argument_list|)
return|;
break|break;
case|case
name|_C_USHT
case|:
return|return
expr|sizeof
operator|(
specifier|_Complex
name|unsigned
name|short
operator|)
return|;
break|break;
case|case
name|_C_INT
case|:
return|return
sizeof|sizeof
argument_list|(
specifier|_Complex
name|int
argument_list|)
return|;
break|break;
case|case
name|_C_UINT
case|:
return|return
expr|sizeof
operator|(
specifier|_Complex
name|unsigned
name|int
operator|)
return|;
break|break;
case|case
name|_C_LNG
case|:
return|return
sizeof|sizeof
argument_list|(
specifier|_Complex
name|long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG
case|:
return|return
expr|sizeof
operator|(
specifier|_Complex
name|unsigned
name|long
operator|)
return|;
break|break;
case|case
name|_C_LNG_LNG
case|:
return|return
expr|sizeof
operator|(
specifier|_Complex
name|long
name|long
operator|)
return|;
break|break;
case|case
name|_C_ULNG_LNG
case|:
return|return
expr|sizeof
operator|(
specifier|_Complex
name|unsigned
name|long
name|long
operator|)
return|;
break|break;
case|case
name|_C_FLT
case|:
return|return
sizeof|sizeof
argument_list|(
specifier|_Complex
name|float
argument_list|)
return|;
break|break;
case|case
name|_C_DBL
case|:
return|return
sizeof|sizeof
argument_list|(
specifier|_Complex
name|double
argument_list|)
return|;
break|break;
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown complex type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   Return the alignment of an object specified by type */
end_comment

begin_function
name|int
name|objc_alignof_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_BOOL
case|:
return|return
name|__alignof__
argument_list|(
name|_Bool
argument_list|)
return|;
break|break;
case|case
name|_C_ID
case|:
return|return
name|__alignof__
argument_list|(
name|id
argument_list|)
return|;
break|break;
case|case
name|_C_CLASS
case|:
return|return
name|__alignof__
argument_list|(
name|Class
argument_list|)
return|;
break|break;
case|case
name|_C_SEL
case|:
return|return
name|__alignof__
argument_list|(
name|SEL
argument_list|)
return|;
break|break;
case|case
name|_C_CHR
case|:
return|return
name|__alignof__
argument_list|(
name|char
argument_list|)
return|;
break|break;
case|case
name|_C_UCHR
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned char
argument_list|)
return|;
break|break;
case|case
name|_C_SHT
case|:
return|return
name|__alignof__
argument_list|(
name|short
argument_list|)
return|;
break|break;
case|case
name|_C_USHT
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned short
argument_list|)
return|;
break|break;
case|case
name|_C_INT
case|:
return|return
name|__alignof__
argument_list|(
name|int
argument_list|)
return|;
break|break;
case|case
name|_C_UINT
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned int
argument_list|)
return|;
break|break;
case|case
name|_C_LNG
case|:
return|return
name|__alignof__
argument_list|(
name|long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned long
argument_list|)
return|;
break|break;
case|case
name|_C_LNG_LNG
case|:
return|return
name|__alignof__
argument_list|(
argument|long long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG_LNG
case|:
return|return
name|__alignof__
argument_list|(
argument|unsigned long long
argument_list|)
return|;
break|break;
case|case
name|_C_FLT
case|:
return|return
name|__alignof__
argument_list|(
name|float
argument_list|)
return|;
break|break;
case|case
name|_C_DBL
case|:
return|return
name|__alignof__
argument_list|(
name|double
argument_list|)
return|;
break|break;
case|case
name|_C_PTR
case|:
case|case
name|_C_ATOM
case|:
case|case
name|_C_CHARPTR
case|:
return|return
name|__alignof__
argument_list|(
name|char
operator|*
argument_list|)
return|;
break|break;
case|case
name|_C_ARY_B
case|:
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|type
argument_list|)
condition|)
comment|/* do nothing */
empty_stmt|;
return|return
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
return|;
case|case
name|_C_STRUCT_B
case|:
case|case
name|_C_UNION_B
case|:
block|{
name|struct
name|objc_struct_layout
name|layout
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|objc_layout_structure
argument_list|(
name|type
argument_list|,
operator|&
name|layout
argument_list|)
expr_stmt|;
while|while
condition|(
name|objc_layout_structure_next_member
argument_list|(
operator|&
name|layout
argument_list|)
condition|)
comment|/* do nothing */
empty_stmt|;
name|objc_layout_finish_structure
argument_list|(
operator|&
name|layout
argument_list|,
name|NULL
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
return|return
name|align
return|;
block|}
case|case
name|_C_COMPLEX
case|:
block|{
name|type
operator|++
expr_stmt|;
comment|/* Skip after the 'j'. */
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_CHR
case|:
return|return
name|__alignof__
argument_list|(
specifier|_Complex
name|char
argument_list|)
return|;
break|break;
case|case
name|_C_UCHR
case|:
return|return
name|__alignof__
argument_list|(
argument|_Complex unsigned char
argument_list|)
return|;
break|break;
case|case
name|_C_SHT
case|:
return|return
name|__alignof__
argument_list|(
specifier|_Complex
name|short
argument_list|)
return|;
break|break;
case|case
name|_C_USHT
case|:
return|return
name|__alignof__
argument_list|(
argument|_Complex unsigned short
argument_list|)
return|;
break|break;
case|case
name|_C_INT
case|:
return|return
name|__alignof__
argument_list|(
specifier|_Complex
name|int
argument_list|)
return|;
break|break;
case|case
name|_C_UINT
case|:
return|return
name|__alignof__
argument_list|(
argument|_Complex unsigned int
argument_list|)
return|;
break|break;
case|case
name|_C_LNG
case|:
return|return
name|__alignof__
argument_list|(
specifier|_Complex
name|long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG
case|:
return|return
name|__alignof__
argument_list|(
argument|_Complex unsigned long
argument_list|)
return|;
break|break;
case|case
name|_C_LNG_LNG
case|:
return|return
name|__alignof__
argument_list|(
argument|_Complex long long
argument_list|)
return|;
break|break;
case|case
name|_C_ULNG_LNG
case|:
return|return
name|__alignof__
argument_list|(
argument|_Complex unsigned long long
argument_list|)
return|;
break|break;
case|case
name|_C_FLT
case|:
return|return
name|__alignof__
argument_list|(
specifier|_Complex
name|float
argument_list|)
return|;
break|break;
case|case
name|_C_DBL
case|:
return|return
name|__alignof__
argument_list|(
specifier|_Complex
name|double
argument_list|)
return|;
break|break;
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown complex type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   The aligned size if the size rounded up to the nearest alignment. */
end_comment

begin_function
name|int
name|objc_aligned_size
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|;
comment|/* Skip the variable name */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|size
operator|=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|align
operator|=
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|ROUND
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   The size rounded up to the nearest integral of the wordsize, taken   to be the size of a void *. */
end_comment

begin_function
name|int
name|objc_promoted_size
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|wordsize
decl_stmt|;
comment|/* Skip the variable name */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|size
operator|=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|wordsize
operator|=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
return|return
name|ROUND
argument_list|(
name|size
argument_list|,
name|wordsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Skip type qualifiers.  These may eventually precede typespecs   occurring in method prototype encodings. */
end_comment

begin_function
specifier|inline
specifier|const
name|char
modifier|*
name|objc_skip_type_qualifiers
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
while|while
condition|(
operator|*
name|type
operator|==
name|_C_CONST
operator|||
operator|*
name|type
operator|==
name|_C_IN
operator|||
operator|*
name|type
operator|==
name|_C_INOUT
operator|||
operator|*
name|type
operator|==
name|_C_OUT
operator|||
operator|*
name|type
operator|==
name|_C_BYCOPY
operator|||
operator|*
name|type
operator|==
name|_C_BYREF
operator|||
operator|*
name|type
operator|==
name|_C_ONEWAY
operator|||
operator|*
name|type
operator|==
name|_C_GCINVISIBLE
condition|)
block|{
name|type
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Skip one typespec element.  If the typespec is prepended by type   qualifiers, these are skipped as well. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|objc_skip_typespec
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|type
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_ID
case|:
comment|/* An id may be annotated by the actual type if it is known        with the @"ClassName" syntax */
if|if
condition|(
operator|*
operator|++
name|type
operator|!=
literal|'"'
condition|)
return|return
name|type
return|;
else|else
block|{
while|while
condition|(
operator|*
operator|++
name|type
operator|!=
literal|'"'
condition|)
comment|/* do nothing */
empty_stmt|;
return|return
name|type
operator|+
literal|1
return|;
block|}
comment|/* The following are one character type codes */
case|case
name|_C_CLASS
case|:
case|case
name|_C_SEL
case|:
case|case
name|_C_CHR
case|:
case|case
name|_C_UCHR
case|:
case|case
name|_C_CHARPTR
case|:
case|case
name|_C_ATOM
case|:
case|case
name|_C_SHT
case|:
case|case
name|_C_USHT
case|:
case|case
name|_C_INT
case|:
case|case
name|_C_UINT
case|:
case|case
name|_C_LNG
case|:
case|case
name|_C_BOOL
case|:
case|case
name|_C_ULNG
case|:
case|case
name|_C_LNG_LNG
case|:
case|case
name|_C_ULNG_LNG
case|:
case|case
name|_C_FLT
case|:
case|case
name|_C_DBL
case|:
case|case
name|_C_VOID
case|:
case|case
name|_C_UNDEF
case|:
return|return
operator|++
name|type
return|;
break|break;
case|case
name|_C_COMPLEX
case|:
return|return
name|type
operator|+
literal|2
return|;
break|break;
case|case
name|_C_ARY_B
case|:
comment|/* skip digits, typespec and closing ']' */
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
name|_C_ARY_E
condition|)
return|return
operator|++
name|type
return|;
else|else
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"bad array type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|_C_BFLD
case|:
comment|/* The new encoding of bitfields is: b 'position' 'type' 'size' */
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
comment|/* skip position */
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
comment|/* skip type and size */
return|return
name|type
return|;
case|case
name|_C_STRUCT_B
case|:
comment|/* skip name, and elements until closing '}'  */
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_STRUCT_E
condition|)
block|{
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|++
name|type
return|;
case|case
name|_C_UNION_B
case|:
comment|/* skip name, and elements until closing ')'  */
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
operator|&&
operator|*
name|type
operator|++
operator|!=
literal|'='
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_E
condition|)
block|{
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|++
name|type
return|;
case|case
name|_C_PTR
case|:
comment|/* Just skip the following typespec */
return|return
name|objc_skip_typespec
argument_list|(
operator|++
name|type
argument_list|)
return|;
default|default:
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"unknown type %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   Skip an offset as part of a method encoding.  This is prepended by a   '+' if the argument is passed in registers. */
end_comment

begin_function
specifier|inline
specifier|const
name|char
modifier|*
name|objc_skip_offset
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
operator|*
name|type
operator|==
literal|'+'
condition|)
name|type
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|type
argument_list|)
condition|)
empty_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Skip an argument specification of a method encoding. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|objc_skip_argspec
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|objc_skip_offset
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Return the number of arguments that the method MTH expects.   Note that all methods need two implicit arguments `self' and   `_cmd'. */
end_comment

begin_function
name|int
name|method_get_number_of_arguments
parameter_list|(
name|struct
name|objc_method
modifier|*
name|mth
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
name|mth
operator|->
name|method_types
decl_stmt|;
while|while
condition|(
operator|*
name|type
condition|)
block|{
name|type
operator|=
name|objc_skip_argspec
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|i
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*   Return the size of the argument block needed on the stack to invoke   the method MTH.  This may be zero, if all arguments are passed in   registers. */
end_comment

begin_function
name|int
name|method_get_sizeof_arguments
parameter_list|(
name|struct
name|objc_method
modifier|*
name|mth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|type
init|=
name|objc_skip_typespec
argument_list|(
name|mth
operator|->
name|method_types
argument_list|)
decl_stmt|;
return|return
name|atoi
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Return a pointer to the next argument of ARGFRAME.  type points to   the last argument.  Typical use of this look like:    {     char *datum, *type;     for (datum = method_get_first_argument (method, argframe,&type);          datum; datum = method_get_next_argument (argframe,&type))       {         unsigned flags = objc_get_type_qualifiers (type);         type = objc_skip_type_qualifiers (type); 	if (*type != _C_PTR)           [portal encodeData: datum ofType: type]; 	else 	  { 	    if ((flags& _F_IN) == _F_IN)               [portal encodeData: *(char **) datum ofType: ++type]; 	  }       }   } */
end_comment

begin_function
name|char
modifier|*
name|method_get_next_argument
parameter_list|(
name|arglist_t
name|argframe
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|objc_skip_argspec
argument_list|(
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
operator|*
name|type
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|objc_skip_typespec
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'+'
condition|)
return|return
name|argframe
operator|->
name|arg_regs
operator|+
name|atoi
argument_list|(
operator|++
name|t
argument_list|)
return|;
else|else
return|return
name|argframe
operator|->
name|arg_ptr
operator|+
name|atoi
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Return a pointer to the value of the first argument of the method   described in M with the given argumentframe ARGFRAME.  The type   is returned in TYPE.  type must be passed to successive calls of   method_get_next_argument. */
end_comment

begin_function
name|char
modifier|*
name|method_get_first_argument
parameter_list|(
name|struct
name|objc_method
modifier|*
name|m
parameter_list|,
name|arglist_t
name|argframe
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
operator|*
name|type
operator|=
name|m
operator|->
name|method_types
expr_stmt|;
return|return
name|method_get_next_argument
argument_list|(
name|argframe
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    Return a pointer to the ARGth argument of the method    M from the frame ARGFRAME.  The type of the argument    is returned in the value-result argument TYPE */
end_comment

begin_function
name|char
modifier|*
name|method_get_nth_argument
parameter_list|(
name|struct
name|objc_method
modifier|*
name|m
parameter_list|,
name|arglist_t
name|argframe
parameter_list|,
name|int
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|objc_skip_argspec
argument_list|(
name|m
operator|->
name|method_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|>
name|method_get_number_of_arguments
argument_list|(
name|m
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|arg
operator|--
condition|)
name|t
operator|=
name|objc_skip_argspec
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|objc_skip_typespec
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'+'
condition|)
return|return
name|argframe
operator|->
name|arg_regs
operator|+
name|atoi
argument_list|(
operator|++
name|t
argument_list|)
return|;
else|else
return|return
name|argframe
operator|->
name|arg_ptr
operator|+
name|atoi
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|objc_get_type_qualifiers
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|res
init|=
literal|0
decl_stmt|;
name|BOOL
name|flag
init|=
name|YES
decl_stmt|;
while|while
condition|(
name|flag
condition|)
switch|switch
condition|(
operator|*
name|type
operator|++
condition|)
block|{
case|case
name|_C_CONST
case|:
name|res
operator||=
name|_F_CONST
expr_stmt|;
break|break;
case|case
name|_C_IN
case|:
name|res
operator||=
name|_F_IN
expr_stmt|;
break|break;
case|case
name|_C_INOUT
case|:
name|res
operator||=
name|_F_INOUT
expr_stmt|;
break|break;
case|case
name|_C_OUT
case|:
name|res
operator||=
name|_F_OUT
expr_stmt|;
break|break;
case|case
name|_C_BYCOPY
case|:
name|res
operator||=
name|_F_BYCOPY
expr_stmt|;
break|break;
case|case
name|_C_BYREF
case|:
name|res
operator||=
name|_F_BYREF
expr_stmt|;
break|break;
case|case
name|_C_ONEWAY
case|:
name|res
operator||=
name|_F_ONEWAY
expr_stmt|;
break|break;
case|case
name|_C_GCINVISIBLE
case|:
name|res
operator||=
name|_F_GCINVISIBLE
expr_stmt|;
break|break;
default|default:
name|flag
operator|=
name|NO
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* The following three functions can be used to determine how a    structure is laid out by the compiler. For example:    struct objc_struct_layout layout;   int i;    objc_layout_structure (type,&layout);   while (objc_layout_structure_next_member (&layout))     {       int position, align;       const char *type;        objc_layout_structure_get_info (&layout,&position,&align,&type);       printf ("element %d has offset %d, alignment %d\n",               i++, position, align);     }    These functions are used by objc_sizeof_type and objc_alignof_type   functions to compute the size and alignment of structures. The   previous method of computing the size and alignment of a structure   was not working on some architectures, particulary on AIX, and in   the presence of bitfields inside the structure. */
end_comment

begin_function
name|void
name|objc_layout_structure
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|struct
name|objc_struct_layout
modifier|*
name|layout
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ntype
decl_stmt|;
if|if
condition|(
operator|*
name|type
operator|!=
name|_C_UNION_B
operator|&&
operator|*
name|type
operator|!=
name|_C_STRUCT_B
condition|)
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_TYPE
argument_list|,
literal|"record (or union) type expected in objc_layout_structure, got %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|type
operator|++
expr_stmt|;
name|layout
operator|->
name|original_type
operator|=
name|type
expr_stmt|;
comment|/* Skip "<name>=" if any. Avoid embedded structures and unions. */
name|ntype
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|*
name|ntype
operator|!=
name|_C_STRUCT_E
operator|&&
operator|*
name|ntype
operator|!=
name|_C_STRUCT_B
operator|&&
operator|*
name|ntype
operator|!=
name|_C_UNION_B
operator|&&
operator|*
name|ntype
operator|++
operator|!=
literal|'='
condition|)
comment|/* do nothing */
empty_stmt|;
comment|/* If there's a "<name>=", ntype - 1 points to '='; skip the the name */
if|if
condition|(
operator|*
operator|(
name|ntype
operator|-
literal|1
operator|)
operator|==
literal|'='
condition|)
name|type
operator|=
name|ntype
expr_stmt|;
name|layout
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|layout
operator|->
name|prev_type
operator|=
name|NULL
expr_stmt|;
name|layout
operator|->
name|record_size
operator|=
literal|0
expr_stmt|;
name|layout
operator|->
name|record_align
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|STRUCTURE_SIZE_BOUNDARY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|BOOL
name|objc_layout_structure_next_member
parameter_list|(
name|struct
name|objc_struct_layout
modifier|*
name|layout
parameter_list|)
block|{
specifier|register
name|int
name|desired_align
init|=
literal|0
decl_stmt|;
comment|/* The following are used only if the field is a bitfield */
specifier|register
specifier|const
name|char
modifier|*
name|bfld_type
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|bfld_type_size
decl_stmt|,
name|bfld_type_align
init|=
literal|0
decl_stmt|,
name|bfld_field_size
init|=
literal|0
decl_stmt|;
comment|/* The current type without the type qualifiers */
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|BOOL
name|unionp
init|=
name|layout
operator|->
name|original_type
index|[
operator|-
literal|1
index|]
operator|==
name|_C_UNION_B
decl_stmt|;
comment|/* Add the size of the previous field to the size of the record.  */
if|if
condition|(
name|layout
operator|->
name|prev_type
condition|)
block|{
name|type
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|layout
operator|->
name|prev_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unionp
condition|)
name|layout
operator|->
name|record_size
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_size
argument_list|,
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|type
operator|!=
name|_C_BFLD
condition|)
name|layout
operator|->
name|record_size
operator|+=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
else|else
block|{
comment|/* Get the bitfield's type */
for|for
control|(
name|bfld_type
operator|=
name|type
operator|+
literal|1
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|bfld_type
argument_list|)
condition|;
name|bfld_type
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
name|bfld_type_size
operator|=
name|objc_sizeof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bfld_type_align
operator|=
name|objc_alignof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bfld_field_size
operator|=
name|atoi
argument_list|(
name|objc_skip_typespec
argument_list|(
name|bfld_type
argument_list|)
argument_list|)
expr_stmt|;
name|layout
operator|->
name|record_size
operator|+=
name|bfld_field_size
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|unionp
operator|&&
operator|*
name|layout
operator|->
name|type
operator|==
name|_C_UNION_E
operator|)
operator|||
operator|(
operator|!
name|unionp
operator|&&
operator|*
name|layout
operator|->
name|type
operator|==
name|_C_STRUCT_E
operator|)
condition|)
return|return
name|NO
return|;
comment|/* Skip the variable name if any */
if|if
condition|(
operator|*
name|layout
operator|->
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|layout
operator|->
name|type
operator|++
init|;
operator|*
name|layout
operator|->
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|type
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|layout
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|!=
name|_C_BFLD
condition|)
name|desired_align
operator|=
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
else|else
block|{
name|desired_align
operator|=
literal|1
expr_stmt|;
comment|/* Skip the bitfield's offset */
for|for
control|(
name|bfld_type
operator|=
name|type
operator|+
literal|1
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|bfld_type
argument_list|)
condition|;
name|bfld_type
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
name|bfld_type_size
operator|=
name|objc_sizeof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bfld_type_align
operator|=
name|objc_alignof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bfld_field_size
operator|=
name|atoi
argument_list|(
name|objc_skip_typespec
argument_list|(
name|bfld_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIGGEST_FIELD_ALIGNMENT
name|desired_align
operator|=
name|MIN
argument_list|(
name|desired_align
argument_list|,
name|BIGGEST_FIELD_ALIGNMENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ADJUST_FIELD_ALIGN
name|desired_align
operator|=
name|ADJUST_FIELD_ALIGN
argument_list|(
name|type
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record must have at least as much alignment as any field.      Otherwise, the alignment of the field within the record      is meaningless.  */
ifndef|#
directive|ifndef
name|PCC_BITFIELD_TYPE_MATTERS
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PCC_BITFIELD_TYPE_MATTERS */
if|if
condition|(
operator|*
name|type
operator|==
name|_C_BFLD
condition|)
block|{
comment|/* For these machines, a zero-length field does not          affect the alignment of the structure as a whole.          It does, however, affect the alignment of the next field          within the structure.  */
if|if
condition|(
name|bfld_field_size
condition|)
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
else|else
name|desired_align
operator|=
name|objc_alignof_type
argument_list|(
name|bfld_type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* A named bit field of declared type `int'          forces the entire structure to have `int' alignment.          Q1: How is encoded this thing and how to check for it?          Q2: How to determine maximum_field_alignment at runtime? */
comment|/*	  if (DECL_NAME (field) != 0) */
block|{
name|int
name|type_align
init|=
name|bfld_type_align
decl_stmt|;
if|#
directive|if
literal|0
block|if (maximum_field_alignment != 0)           type_align = MIN (type_align, maximum_field_alignment);         else if (DECL_PACKED (field))           type_align = MIN (type_align, BITS_PER_UNIT);
endif|#
directive|endif
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
name|layout
operator|->
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCC_BITFIELD_TYPE_MATTERS */
comment|/* Does this field automatically have alignment it needs      by virtue of the fields that precede it and the record's      own alignment?  */
if|if
condition|(
operator|*
name|type
operator|==
name|_C_BFLD
condition|)
name|layout
operator|->
name|record_size
operator|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|layout
operator|->
name|record_size
operator|%
name|desired_align
operator|!=
literal|0
condition|)
block|{
comment|/* No, we need to skip space before this field.          Bump the cumulative size to multiple of field alignment.  */
name|layout
operator|->
name|record_size
operator|=
name|ROUND
argument_list|(
name|layout
operator|->
name|record_size
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
block|}
comment|/* Jump to the next field in record. */
name|layout
operator|->
name|prev_type
operator|=
name|layout
operator|->
name|type
expr_stmt|;
name|layout
operator|->
name|type
operator|=
name|objc_skip_typespec
argument_list|(
name|layout
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* skip component */
return|return
name|YES
return|;
block|}
end_function

begin_function
name|void
name|objc_layout_finish_structure
parameter_list|(
name|struct
name|objc_struct_layout
modifier|*
name|layout
parameter_list|,
name|unsigned
name|int
modifier|*
name|size
parameter_list|,
name|unsigned
name|int
modifier|*
name|align
parameter_list|)
block|{
name|BOOL
name|unionp
init|=
name|layout
operator|->
name|original_type
index|[
operator|-
literal|1
index|]
operator|==
name|_C_UNION_B
decl_stmt|;
if|if
condition|(
name|layout
operator|->
name|type
operator|&&
operator|(
operator|(
operator|!
name|unionp
operator|&&
operator|*
name|layout
operator|->
name|type
operator|==
name|_C_STRUCT_E
operator|)
operator|||
operator|(
name|unionp
operator|&&
operator|*
name|layout
operator|->
name|type
operator|==
name|_C_UNION_E
operator|)
operator|)
condition|)
block|{
comment|/* Work out the alignment of the record as one expression and store          in the record type.  Round it up to a multiple of the record's          alignment. */
if|#
directive|if
name|defined
argument_list|(
name|ROUND_TYPE_ALIGN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__sparc__
argument_list|)
name|layout
operator|->
name|record_align
operator|=
name|ROUND_TYPE_ALIGN
argument_list|(
name|layout
operator|->
name|original_type
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|layout
operator|->
name|record_align
argument_list|)
expr_stmt|;
else|#
directive|else
name|layout
operator|->
name|record_align
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|layout
operator|->
name|record_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ROUND_TYPE_SIZE
name|layout
operator|->
name|record_size
operator|=
name|ROUND_TYPE_SIZE
argument_list|(
name|layout
operator|->
name|original_type
argument_list|,
name|layout
operator|->
name|record_size
argument_list|,
name|layout
operator|->
name|record_align
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Round the size up to be a multiple of the required alignment */
name|layout
operator|->
name|record_size
operator|=
name|ROUND
argument_list|(
name|layout
operator|->
name|record_size
argument_list|,
name|layout
operator|->
name|record_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|layout
operator|->
name|type
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|layout
operator|->
name|record_size
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|align
condition|)
operator|*
name|align
operator|=
name|layout
operator|->
name|record_align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_layout_structure_get_info
parameter_list|(
name|struct
name|objc_struct_layout
modifier|*
name|layout
parameter_list|,
name|unsigned
name|int
modifier|*
name|offset
parameter_list|,
name|unsigned
name|int
modifier|*
name|align
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|offset
condition|)
operator|*
name|offset
operator|=
name|layout
operator|->
name|record_size
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|align
condition|)
operator|*
name|align
operator|=
name|layout
operator|->
name|record_align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|layout
operator|->
name|prev_type
expr_stmt|;
block|}
end_function

end_unit

