begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Sparse Arrays for Objective C dispatch tables    Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files    compiled with GCC to produce an executable, this does not cause    the resulting executable to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"sarray.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_decl_stmt
name|int
name|nbuckets
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_decl_stmt
name|int
name|nindices
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_decl_stmt
name|int
name|narrays
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_decl_stmt
name|int
name|idxsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|first_free_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJC_SPARSE2
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|__objc_sparse2_id
init|=
literal|"2 level sparse indices"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|__objc_sparse3_id
init|=
literal|"3 level sparse indices"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_function_decl
specifier|const
name|void
modifier|*
name|memcpy
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function removes any structures left over from free operations    that were not safe in a multi-threaded environment. */
end_comment

begin_function
name|void
name|sarray_remove_garbage
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|vp
decl_stmt|;
name|void
modifier|*
name|np
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|vp
operator|=
name|first_free_data
expr_stmt|;
name|first_free_data
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|vp
condition|)
block|{
name|np
operator|=
operator|*
name|vp
expr_stmt|;
name|objc_free
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|np
expr_stmt|;
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a block of dynamically allocated memory.  If we are in multi-threaded    mode, it is ok to free it.  If not, we add it to the garbage heap to be    freed later. */
end_comment

begin_function
specifier|static
name|void
name|sarray_free_garbage
parameter_list|(
name|void
modifier|*
name|vp
parameter_list|)
block|{
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|__objc_runtime_threads_alive
operator|==
literal|1
condition|)
block|{
name|objc_free
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_free_data
condition|)
name|sarray_remove_garbage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|vp
operator|=
name|first_free_data
expr_stmt|;
name|first_free_data
operator|=
name|vp
expr_stmt|;
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sarray_at_put : copies data in such a way as to be thread reader safe. */
end_comment

begin_function
name|void
name|sarray_at_put
parameter_list|(
name|struct
name|sarray
modifier|*
name|array
parameter_list|,
name|sidx
name|index
parameter_list|,
name|void
modifier|*
name|element
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|struct
name|sindex
modifier|*
modifier|*
name|the_index
decl_stmt|;
name|struct
name|sindex
modifier|*
name|new_index
decl_stmt|;
endif|#
directive|endif
name|struct
name|sbucket
modifier|*
modifier|*
name|the_bucket
decl_stmt|;
name|struct
name|sbucket
modifier|*
name|new_bucket
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|ioffset
decl_stmt|;
endif|#
directive|endif
name|size_t
name|boffset
decl_stmt|;
name|size_t
name|eoffset
decl_stmt|;
ifdef|#
directive|ifdef
name|PRECOMPUTE_SELECTORS
name|union
name|sofftype
name|xx
decl_stmt|;
name|xx
operator|.
name|idx
operator|=
name|index
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|ioffset
operator|=
name|xx
operator|.
name|off
operator|.
name|ioffset
expr_stmt|;
endif|#
directive|endif
name|boffset
operator|=
name|xx
operator|.
name|off
operator|.
name|boffset
expr_stmt|;
name|eoffset
operator|=
name|xx
operator|.
name|off
operator|.
name|eoffset
expr_stmt|;
else|#
directive|else
comment|/* not PRECOMPUTE_SELECTORS */
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|ioffset
operator|=
name|index
operator|/
name|INDEX_CAPACITY
expr_stmt|;
name|boffset
operator|=
operator|(
name|index
operator|/
name|BUCKET_SIZE
operator|)
operator|%
name|INDEX_SIZE
expr_stmt|;
name|eoffset
operator|=
name|index
operator|%
name|BUCKET_SIZE
expr_stmt|;
else|#
directive|else
name|boffset
operator|=
name|index
operator|/
name|BUCKET_SIZE
expr_stmt|;
name|eoffset
operator|=
name|index
operator|%
name|BUCKET_SIZE
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* not PRECOMPUTE_SELECTORS */
name|assert
argument_list|(
name|soffset_decode
argument_list|(
name|index
argument_list|)
operator|<
name|array
operator|->
name|capacity
argument_list|)
expr_stmt|;
comment|/* Range check */
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|the_index
operator|=
operator|&
operator|(
name|array
operator|->
name|indices
index|[
name|ioffset
index|]
operator|)
expr_stmt|;
name|the_bucket
operator|=
operator|&
operator|(
operator|(
operator|*
name|the_index
operator|)
operator|->
name|buckets
index|[
name|boffset
index|]
operator|)
expr_stmt|;
else|#
directive|else
name|the_bucket
operator|=
operator|&
operator|(
name|array
operator|->
name|buckets
index|[
name|boffset
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|*
name|the_bucket
operator|)
operator|->
name|elems
index|[
name|eoffset
index|]
operator|==
name|element
condition|)
return|return;
comment|/* great! we just avoided a lazy copy */
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* First, perform lazy copy/allocation of index if needed */
if|if
condition|(
operator|(
operator|*
name|the_index
operator|)
operator|==
name|array
operator|->
name|empty_index
condition|)
block|{
comment|/* The index was previously empty, allocate a new */
name|new_index
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_index
argument_list|,
name|array
operator|->
name|empty_index
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
name|new_index
operator|->
name|version
operator|.
name|version
operator|=
name|array
operator|->
name|version
operator|.
name|version
expr_stmt|;
operator|*
name|the_index
operator|=
name|new_index
expr_stmt|;
comment|/* Prepared for install. */
name|the_bucket
operator|=
operator|&
operator|(
operator|(
operator|*
name|the_index
operator|)
operator|->
name|buckets
index|[
name|boffset
index|]
operator|)
expr_stmt|;
name|nindices
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|the_index
operator|)
operator|->
name|version
operator|.
name|version
operator|!=
name|array
operator|->
name|version
operator|.
name|version
condition|)
block|{
comment|/* This index must be lazy copied */
name|struct
name|sindex
modifier|*
name|old_index
init|=
operator|*
name|the_index
decl_stmt|;
name|new_index
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_index
argument_list|,
name|old_index
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
name|new_index
operator|->
name|version
operator|.
name|version
operator|=
name|array
operator|->
name|version
operator|.
name|version
expr_stmt|;
operator|*
name|the_index
operator|=
name|new_index
expr_stmt|;
comment|/* Prepared for install. */
name|the_bucket
operator|=
operator|&
operator|(
operator|(
operator|*
name|the_index
operator|)
operator|->
name|buckets
index|[
name|boffset
index|]
operator|)
expr_stmt|;
name|nindices
operator|+=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJC_SPARSE3 */
comment|/* next, perform lazy allocation/copy of the bucket if needed */
if|if
condition|(
operator|(
operator|*
name|the_bucket
operator|)
operator|==
name|array
operator|->
name|empty_bucket
condition|)
block|{
comment|/* The bucket was previously empty (or something like that), */
comment|/* allocate a new.  This is the effect of `lazy' allocation */
name|new_bucket
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|new_bucket
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|array
operator|->
name|empty_bucket
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|new_bucket
operator|->
name|version
operator|.
name|version
operator|=
name|array
operator|->
name|version
operator|.
name|version
expr_stmt|;
operator|*
name|the_bucket
operator|=
name|new_bucket
expr_stmt|;
comment|/* Prepared for install. */
name|nbuckets
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|the_bucket
operator|)
operator|->
name|version
operator|.
name|version
operator|!=
name|array
operator|->
name|version
operator|.
name|version
condition|)
block|{
comment|/* Perform lazy copy. */
name|struct
name|sbucket
modifier|*
name|old_bucket
init|=
operator|*
name|the_bucket
decl_stmt|;
name|new_bucket
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_bucket
argument_list|,
name|old_bucket
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|new_bucket
operator|->
name|version
operator|.
name|version
operator|=
name|array
operator|->
name|version
operator|.
name|version
expr_stmt|;
operator|*
name|the_bucket
operator|=
name|new_bucket
expr_stmt|;
comment|/* Prepared for install. */
name|nbuckets
operator|+=
literal|1
expr_stmt|;
block|}
operator|(
operator|*
name|the_bucket
operator|)
operator|->
name|elems
index|[
name|eoffset
index|]
operator|=
name|element
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sarray_at_put_safe
parameter_list|(
name|struct
name|sarray
modifier|*
name|array
parameter_list|,
name|sidx
name|index
parameter_list|,
name|void
modifier|*
name|element
parameter_list|)
block|{
if|if
condition|(
name|soffset_decode
argument_list|(
name|index
argument_list|)
operator|>=
name|array
operator|->
name|capacity
condition|)
name|sarray_realloc
argument_list|(
name|array
argument_list|,
name|soffset_decode
argument_list|(
name|index
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sarray_at_put
argument_list|(
name|array
argument_list|,
name|index
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|sarray
modifier|*
name|sarray_new
parameter_list|(
name|int
name|size
parameter_list|,
name|void
modifier|*
name|default_element
parameter_list|)
block|{
name|struct
name|sarray
modifier|*
name|arr
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|num_indices
init|=
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
operator|(
name|INDEX_CAPACITY
operator|)
operator|)
operator|+
literal|1
decl_stmt|;
name|struct
name|sindex
modifier|*
modifier|*
name|new_indices
decl_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|size_t
name|num_indices
init|=
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
operator|)
operator|+
literal|1
decl_stmt|;
name|struct
name|sbucket
modifier|*
modifier|*
name|new_buckets
decl_stmt|;
endif|#
directive|endif
name|int
name|counter
decl_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate core array */
name|arr
operator|=
operator|(
expr|struct
name|sarray
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
argument_list|)
expr_stmt|;
name|arr
operator|->
name|version
operator|.
name|version
operator|=
literal|0
expr_stmt|;
comment|/* Initialize members */
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|arr
operator|->
name|capacity
operator|=
name|num_indices
operator|*
name|INDEX_CAPACITY
expr_stmt|;
name|new_indices
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|arr
operator|->
name|empty_index
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
argument_list|)
argument_list|)
expr_stmt|;
name|arr
operator|->
name|empty_index
operator|->
name|version
operator|.
name|version
operator|=
literal|0
expr_stmt|;
name|narrays
operator|+=
literal|1
expr_stmt|;
name|idxsize
operator|+=
name|num_indices
expr_stmt|;
name|nindices
operator|+=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|arr
operator|->
name|capacity
operator|=
name|num_indices
operator|*
name|BUCKET_SIZE
expr_stmt|;
name|new_buckets
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|narrays
operator|+=
literal|1
expr_stmt|;
name|idxsize
operator|+=
name|num_indices
expr_stmt|;
endif|#
directive|endif
name|arr
operator|->
name|empty_bucket
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|arr
operator|->
name|empty_bucket
operator|->
name|version
operator|.
name|version
operator|=
literal|0
expr_stmt|;
name|nbuckets
operator|+=
literal|1
expr_stmt|;
name|arr
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|arr
operator|->
name|is_copy_of
operator|=
operator|(
expr|struct
name|sarray
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|BUCKET_SIZE
condition|;
name|counter
operator|++
control|)
name|arr
operator|->
name|empty_bucket
operator|->
name|elems
index|[
name|counter
index|]
operator|=
name|default_element
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|INDEX_SIZE
condition|;
name|counter
operator|++
control|)
name|arr
operator|->
name|empty_index
operator|->
name|buckets
index|[
name|counter
index|]
operator|=
name|arr
operator|->
name|empty_bucket
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|num_indices
condition|;
name|counter
operator|++
control|)
name|new_indices
index|[
name|counter
index|]
operator|=
name|arr
operator|->
name|empty_index
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|num_indices
condition|;
name|counter
operator|++
control|)
name|new_buckets
index|[
name|counter
index|]
operator|=
name|arr
operator|->
name|empty_bucket
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|arr
operator|->
name|indices
operator|=
name|new_indices
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|arr
operator|->
name|buckets
operator|=
name|new_buckets
expr_stmt|;
endif|#
directive|endif
return|return
name|arr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reallocate the sparse array to hold `newsize' entries    Note: We really allocate and then free.  We have to do this to ensure that    any concurrent readers notice the update. */
end_comment

begin_function
name|void
name|sarray_realloc
parameter_list|(
name|struct
name|sarray
modifier|*
name|array
parameter_list|,
name|int
name|newsize
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|old_max_index
init|=
operator|(
name|array
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|INDEX_CAPACITY
decl_stmt|;
name|size_t
name|new_max_index
init|=
operator|(
operator|(
name|newsize
operator|-
literal|1
operator|)
operator|/
name|INDEX_CAPACITY
operator|)
decl_stmt|;
name|size_t
name|rounded_size
init|=
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
name|INDEX_CAPACITY
decl_stmt|;
name|struct
name|sindex
modifier|*
modifier|*
name|new_indices
decl_stmt|;
name|struct
name|sindex
modifier|*
modifier|*
name|old_indices
decl_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|size_t
name|old_max_index
init|=
operator|(
name|array
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
decl_stmt|;
name|size_t
name|new_max_index
init|=
operator|(
operator|(
name|newsize
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
operator|)
decl_stmt|;
name|size_t
name|rounded_size
init|=
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
name|BUCKET_SIZE
decl_stmt|;
name|struct
name|sbucket
modifier|*
modifier|*
name|new_buckets
decl_stmt|;
name|struct
name|sbucket
modifier|*
modifier|*
name|old_buckets
decl_stmt|;
endif|#
directive|endif
name|int
name|counter
decl_stmt|;
name|assert
argument_list|(
name|newsize
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* The size is the same, just ignore the request */
if|if
condition|(
name|rounded_size
operator|<=
name|array
operator|->
name|capacity
condition|)
return|return;
name|assert
argument_list|(
name|array
operator|->
name|ref_count
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* stop if lazy copied... */
comment|/* We are asked to extend the array -- allocate new bucket table, */
comment|/* and insert empty_bucket in newly allocated places. */
if|if
condition|(
name|rounded_size
operator|>
name|array
operator|->
name|capacity
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|new_max_index
operator|+=
literal|4
expr_stmt|;
name|rounded_size
operator|=
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
name|INDEX_CAPACITY
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|new_max_index
operator|+=
literal|4
expr_stmt|;
name|rounded_size
operator|=
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
name|BUCKET_SIZE
expr_stmt|;
endif|#
directive|endif
comment|/* update capacity */
name|array
operator|->
name|capacity
operator|=
name|rounded_size
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* alloc to force re-read by any concurrent readers. */
name|old_indices
operator|=
name|array
operator|->
name|indices
expr_stmt|;
name|new_indices
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|*
operator|)
name|objc_malloc
argument_list|(
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|old_buckets
operator|=
name|array
operator|->
name|buckets
expr_stmt|;
name|new_buckets
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|*
operator|)
name|objc_malloc
argument_list|(
operator|(
name|new_max_index
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
operator|*
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* copy buckets below old_max_index (they are still valid) */
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<=
name|old_max_index
condition|;
name|counter
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|new_indices
index|[
name|counter
index|]
operator|=
name|old_indices
index|[
name|counter
index|]
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|new_buckets
index|[
name|counter
index|]
operator|=
name|old_buckets
index|[
name|counter
index|]
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* reset entries above old_max_index to empty_bucket */
for|for
control|(
name|counter
operator|=
name|old_max_index
operator|+
literal|1
init|;
name|counter
operator|<=
name|new_max_index
condition|;
name|counter
operator|++
control|)
name|new_indices
index|[
name|counter
index|]
operator|=
name|array
operator|->
name|empty_index
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
comment|/* reset entries above old_max_index to empty_bucket */
for|for
control|(
name|counter
operator|=
name|old_max_index
operator|+
literal|1
init|;
name|counter
operator|<=
name|new_max_index
condition|;
name|counter
operator|++
control|)
name|new_buckets
index|[
name|counter
index|]
operator|=
name|array
operator|->
name|empty_bucket
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* install the new indices */
name|array
operator|->
name|indices
operator|=
name|new_indices
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|array
operator|->
name|buckets
operator|=
name|new_buckets
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* free the old indices */
name|sarray_free_garbage
argument_list|(
name|old_indices
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|sarray_free_garbage
argument_list|(
name|old_buckets
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idxsize
operator|+=
operator|(
name|new_max_index
operator|-
name|old_max_index
operator|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free a sparse array allocated with sarray_new */
end_comment

begin_function
name|void
name|sarray_free
parameter_list|(
name|struct
name|sarray
modifier|*
name|array
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|old_max_index
init|=
operator|(
name|array
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|INDEX_CAPACITY
decl_stmt|;
name|struct
name|sindex
modifier|*
modifier|*
name|old_indices
decl_stmt|;
else|#
directive|else
name|size_t
name|old_max_index
init|=
operator|(
name|array
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
decl_stmt|;
name|struct
name|sbucket
modifier|*
modifier|*
name|old_buckets
decl_stmt|;
endif|#
directive|endif
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|array
operator|->
name|ref_count
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Freed multiple times!!! */
if|if
condition|(
operator|--
operator|(
name|array
operator|->
name|ref_count
operator|)
operator|!=
literal|0
condition|)
comment|/* There exists copies of me */
return|return;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|old_indices
operator|=
name|array
operator|->
name|indices
expr_stmt|;
else|#
directive|else
name|old_buckets
operator|=
name|array
operator|->
name|buckets
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|array
operator|->
name|is_copy_of
operator|)
operator|&&
operator|(
operator|(
name|array
operator|->
name|is_copy_of
operator|->
name|ref_count
operator|-
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
name|sarray_free
argument_list|(
name|array
operator|->
name|is_copy_of
argument_list|)
expr_stmt|;
comment|/* Free all entries that do not point to empty_bucket */
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<=
name|old_max_index
condition|;
name|counter
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|struct
name|sindex
modifier|*
name|idx
init|=
name|old_indices
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|idx
operator|!=
name|array
operator|->
name|empty_index
operator|)
operator|&&
operator|(
name|idx
operator|->
name|version
operator|.
name|version
operator|==
name|array
operator|->
name|version
operator|.
name|version
operator|)
condition|)
block|{
name|int
name|c2
decl_stmt|;
for|for
control|(
name|c2
operator|=
literal|0
init|;
name|c2
operator|<
name|INDEX_SIZE
condition|;
name|c2
operator|++
control|)
block|{
name|struct
name|sbucket
modifier|*
name|bkt
init|=
name|idx
operator|->
name|buckets
index|[
name|c2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|bkt
operator|!=
name|array
operator|->
name|empty_bucket
operator|)
operator|&&
operator|(
name|bkt
operator|->
name|version
operator|.
name|version
operator|==
name|array
operator|->
name|version
operator|.
name|version
operator|)
condition|)
block|{
name|sarray_free_garbage
argument_list|(
name|bkt
argument_list|)
expr_stmt|;
name|nbuckets
operator|-=
literal|1
expr_stmt|;
block|}
block|}
name|sarray_free_garbage
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|nindices
operator|-=
literal|1
expr_stmt|;
block|}
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|struct
name|sbucket
modifier|*
name|bkt
init|=
name|array
operator|->
name|buckets
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|bkt
operator|!=
name|array
operator|->
name|empty_bucket
operator|)
operator|&&
operator|(
name|bkt
operator|->
name|version
operator|.
name|version
operator|==
name|array
operator|->
name|version
operator|.
name|version
operator|)
condition|)
block|{
name|sarray_free_garbage
argument_list|(
name|bkt
argument_list|)
expr_stmt|;
name|nbuckets
operator|-=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* free empty_index */
if|if
condition|(
name|array
operator|->
name|empty_index
operator|->
name|version
operator|.
name|version
operator|==
name|array
operator|->
name|version
operator|.
name|version
condition|)
block|{
name|sarray_free_garbage
argument_list|(
name|array
operator|->
name|empty_index
argument_list|)
expr_stmt|;
name|nindices
operator|-=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* free empty_bucket */
if|if
condition|(
name|array
operator|->
name|empty_bucket
operator|->
name|version
operator|.
name|version
operator|==
name|array
operator|->
name|version
operator|.
name|version
condition|)
block|{
name|sarray_free_garbage
argument_list|(
name|array
operator|->
name|empty_bucket
argument_list|)
expr_stmt|;
name|nbuckets
operator|-=
literal|1
expr_stmt|;
block|}
name|idxsize
operator|-=
operator|(
name|old_max_index
operator|+
literal|1
operator|)
expr_stmt|;
name|narrays
operator|-=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* free bucket table */
name|sarray_free_garbage
argument_list|(
name|array
operator|->
name|indices
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* free bucket table */
name|sarray_free_garbage
argument_list|(
name|array
operator|->
name|buckets
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* free array */
name|sarray_free_garbage
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a lazy copy.  Only the core of the structure is actually */
end_comment

begin_comment
comment|/* copied.   */
end_comment

begin_function
name|struct
name|sarray
modifier|*
name|sarray_lazy_copy
parameter_list|(
name|struct
name|sarray
modifier|*
name|oarr
parameter_list|)
block|{
name|struct
name|sarray
modifier|*
name|arr
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|size_t
name|num_indices
init|=
operator|(
operator|(
name|oarr
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|INDEX_CAPACITY
operator|)
operator|+
literal|1
decl_stmt|;
name|struct
name|sindex
modifier|*
modifier|*
name|new_indices
decl_stmt|;
else|#
directive|else
comment|/* OBJC_SPARSE2 */
name|size_t
name|num_indices
init|=
operator|(
operator|(
name|oarr
operator|->
name|capacity
operator|-
literal|1
operator|)
operator|/
name|BUCKET_SIZE
operator|)
operator|+
literal|1
decl_stmt|;
name|struct
name|sbucket
modifier|*
modifier|*
name|new_buckets
decl_stmt|;
endif|#
directive|endif
comment|/* Allocate core array */
name|arr
operator|=
operator|(
expr|struct
name|sarray
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
argument_list|)
expr_stmt|;
comment|/* !!! */
name|arr
operator|->
name|version
operator|.
name|version
operator|=
name|oarr
operator|->
name|version
operator|.
name|version
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
name|arr
operator|->
name|empty_index
operator|=
name|oarr
operator|->
name|empty_index
expr_stmt|;
endif|#
directive|endif
name|arr
operator|->
name|empty_bucket
operator|=
name|oarr
operator|->
name|empty_bucket
expr_stmt|;
name|arr
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|oarr
operator|->
name|ref_count
operator|+=
literal|1
expr_stmt|;
name|arr
operator|->
name|is_copy_of
operator|=
name|oarr
expr_stmt|;
name|arr
operator|->
name|capacity
operator|=
name|oarr
operator|->
name|capacity
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_SPARSE3
comment|/* Copy bucket table */
name|new_indices
operator|=
operator|(
expr|struct
name|sindex
operator|*
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_indices
argument_list|,
name|oarr
operator|->
name|indices
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sindex
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|arr
operator|->
name|indices
operator|=
name|new_indices
expr_stmt|;
else|#
directive|else
comment|/* Copy bucket table */
name|new_buckets
operator|=
operator|(
expr|struct
name|sbucket
operator|*
operator|*
operator|)
name|objc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_buckets
argument_list|,
name|oarr
operator|->
name|buckets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
operator|*
argument_list|)
operator|*
name|num_indices
argument_list|)
expr_stmt|;
name|arr
operator|->
name|buckets
operator|=
name|new_buckets
expr_stmt|;
endif|#
directive|endif
name|idxsize
operator|+=
name|num_indices
expr_stmt|;
name|narrays
operator|+=
literal|1
expr_stmt|;
return|return
name|arr
return|;
block|}
end_function

end_unit

