begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hash tables for Objective C internal structures    Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files    compiled with GCC to produce an executable, this does not cause    the resulting executable to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_comment
comment|/* for DEBUG_PRINTF */
end_comment

begin_comment
comment|/* These two macros determine when a hash table is full and    by how much it should be expanded respectively.     These equations are percentages.  */
end_comment

begin_define
define|#
directive|define
name|FULLNESS
parameter_list|(
name|cache
parameter_list|)
define|\
value|((((cache)->size * 75) / 100)<= (cache)->used)
end_define

begin_define
define|#
directive|define
name|EXPANSION
parameter_list|(
name|cache
parameter_list|)
define|\
value|((cache)->size * 2)
end_define

begin_function
name|cache_ptr
name|hash_new
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|,
name|hash_func_type
name|hash_func
parameter_list|,
name|compare_func_type
name|compare_func
parameter_list|)
block|{
name|cache_ptr
name|cache
decl_stmt|;
comment|/* Pass me a value greater than 0 and a power of 2.  */
name|assert
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Allocate the cache structure.  calloc insures      its initialization for default values.  */
name|cache
operator|=
operator|(
name|cache_ptr
operator|)
name|objc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cache
argument_list|)
expr_stmt|;
comment|/* Allocate the array of buckets for the cache.      calloc initializes all of the pointers to NULL.  */
name|cache
operator|->
name|node_table
operator|=
operator|(
name|node_ptr
operator|*
operator|)
name|objc_calloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|node_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cache
operator|->
name|node_table
argument_list|)
expr_stmt|;
name|cache
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* This should work for all processor architectures? */
name|cache
operator|->
name|mask
operator|=
operator|(
name|size
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Store the hashing function so that codes can be computed.  */
name|cache
operator|->
name|hash_func
operator|=
name|hash_func
expr_stmt|;
comment|/* Store the function that compares hash keys to      determine if they are equal.  */
name|cache
operator|->
name|compare_func
operator|=
name|compare_func
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
name|void
name|hash_delete
parameter_list|(
name|cache_ptr
name|cache
parameter_list|)
block|{
name|node_ptr
name|node
decl_stmt|;
name|node_ptr
name|next_node
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Purge all key/value pairs from the table.  */
comment|/* Step through the nodes one by one and remove every node WITHOUT      using hash_next. this makes hash_delete much more efficient. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|node
operator|=
name|cache
operator|->
name|node_table
index|[
name|i
index|]
operator|)
condition|)
block|{
comment|/* an entry in the hash table has been found, now step through the 	 nodes next in the list and free them. */
while|while
condition|(
operator|(
name|next_node
operator|=
name|node
operator|->
name|next
operator|)
condition|)
block|{
name|hash_remove
argument_list|(
name|cache
argument_list|,
name|node
operator|->
name|key
argument_list|)
expr_stmt|;
name|node
operator|=
name|next_node
expr_stmt|;
block|}
name|hash_remove
argument_list|(
name|cache
argument_list|,
name|node
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Release the array of nodes and the cache itself.  */
name|objc_free
argument_list|(
name|cache
operator|->
name|node_table
argument_list|)
expr_stmt|;
name|objc_free
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hash_add
parameter_list|(
name|cache_ptr
modifier|*
name|cachep
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
name|size_t
name|indx
init|=
operator|(
operator|*
operator|(
operator|*
name|cachep
operator|)
operator|->
name|hash_func
operator|)
operator|(
operator|*
name|cachep
expr|,
name|key
operator|)
decl_stmt|;
name|node_ptr
name|node
init|=
operator|(
name|node_ptr
operator|)
name|objc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cache_node
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Initialize the new node.  */
name|node
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|node
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|node
operator|->
name|next
operator|=
operator|(
operator|*
name|cachep
operator|)
operator|->
name|node_table
index|[
name|indx
index|]
expr_stmt|;
comment|/* Debugging.      Check the list for another key.  */
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|node_ptr
name|node1
init|=
operator|(
operator|*
name|cachep
operator|)
operator|->
name|node_table
index|[
name|indx
index|]
decl_stmt|;
while|while
condition|(
name|node1
condition|)
block|{
name|assert
argument_list|(
name|node1
operator|->
name|key
operator|!=
name|key
argument_list|)
expr_stmt|;
name|node1
operator|=
name|node1
operator|->
name|next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Install the node as the first element on the list.  */
operator|(
operator|*
name|cachep
operator|)
operator|->
name|node_table
index|[
name|indx
index|]
operator|=
name|node
expr_stmt|;
comment|/* Bump the number of entries in the cache.  */
operator|++
operator|(
operator|*
name|cachep
operator|)
operator|->
name|used
expr_stmt|;
comment|/* Check the hash table's fullness.   We're going      to expand if it is above the fullness level.  */
if|if
condition|(
name|FULLNESS
argument_list|(
operator|*
name|cachep
argument_list|)
condition|)
block|{
comment|/* The hash table has reached its fullness level.  Time to        expand it.         I'm using a slow method here but is built on other        primitive functions thereby increasing its        correctness.  */
name|node_ptr
name|node1
init|=
name|NULL
decl_stmt|;
name|cache_ptr
name|new
init|=
name|hash_new
argument_list|(
name|EXPANSION
argument_list|(
operator|*
name|cachep
argument_list|)
argument_list|,
operator|(
operator|*
name|cachep
operator|)
operator|->
name|hash_func
argument_list|,
operator|(
operator|*
name|cachep
operator|)
operator|->
name|compare_func
argument_list|)
decl_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"Expanding cache %#x from %d to %d\n"
argument_list|,
operator|*
name|cachep
argument_list|,
operator|(
operator|*
name|cachep
operator|)
operator|->
name|size
argument_list|,
name|new
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Copy the nodes from the first hash table to the new one.  */
while|while
condition|(
operator|(
name|node1
operator|=
name|hash_next
argument_list|(
operator|*
name|cachep
argument_list|,
name|node1
argument_list|)
operator|)
condition|)
name|hash_add
argument_list|(
operator|&
name|new
argument_list|,
name|node1
operator|->
name|key
argument_list|,
name|node1
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Trash the old cache.  */
name|hash_delete
argument_list|(
operator|*
name|cachep
argument_list|)
expr_stmt|;
comment|/* Return a pointer to the new hash table.  */
operator|*
name|cachep
operator|=
name|new
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|hash_remove
parameter_list|(
name|cache_ptr
name|cache
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|size_t
name|indx
init|=
call|(
modifier|*
name|cache
operator|->
name|hash_func
call|)
argument_list|(
name|cache
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|node_ptr
name|node
init|=
name|cache
operator|->
name|node_table
index|[
name|indx
index|]
decl_stmt|;
comment|/* We assume there is an entry in the table.  Error if it is not.  */
name|assert
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Special case.  First element is the key/value pair to be removed.  */
if|if
condition|(
call|(
modifier|*
name|cache
operator|->
name|compare_func
call|)
argument_list|(
name|node
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|cache
operator|->
name|node_table
index|[
name|indx
index|]
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|objc_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, find the hash entry.  */
name|node_ptr
name|prev
init|=
name|node
decl_stmt|;
name|BOOL
name|removed
init|=
name|NO
decl_stmt|;
do|do
block|{
if|if
condition|(
call|(
modifier|*
name|cache
operator|->
name|compare_func
call|)
argument_list|(
name|node
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|node
operator|->
name|next
operator|,
name|removed
operator|=
name|YES
expr_stmt|;
name|objc_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|node
operator|,
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|removed
operator|&&
name|node
condition|)
do|;
name|assert
argument_list|(
name|removed
argument_list|)
expr_stmt|;
block|}
comment|/* Decrement the number of entries in the hash table.  */
operator|--
name|cache
operator|->
name|used
expr_stmt|;
block|}
end_function

begin_function
name|node_ptr
name|hash_next
parameter_list|(
name|cache_ptr
name|cache
parameter_list|,
name|node_ptr
name|node
parameter_list|)
block|{
comment|/* If the scan is being started then reset the last node      visitied pointer and bucket index.  */
if|if
condition|(
operator|!
name|node
condition|)
name|cache
operator|->
name|last_bucket
operator|=
literal|0
expr_stmt|;
comment|/* If there is a node visited last then check for another      entry in the same bucket;  Otherwise step to the next bucket.  */
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|next
condition|)
comment|/* There is a node which follows the last node 	 returned.  Step to that node and retun it.  */
return|return
name|node
operator|->
name|next
return|;
else|else
operator|++
name|cache
operator|->
name|last_bucket
expr_stmt|;
block|}
comment|/* If the list isn't exhausted then search the buckets for      other nodes.  */
if|if
condition|(
name|cache
operator|->
name|last_bucket
operator|<
name|cache
operator|->
name|size
condition|)
block|{
comment|/*  Scan the remainder of the buckets looking for an entry 	at the head of the list.  Return the first item found.  */
while|while
condition|(
name|cache
operator|->
name|last_bucket
operator|<
name|cache
operator|->
name|size
condition|)
if|if
condition|(
name|cache
operator|->
name|node_table
index|[
name|cache
operator|->
name|last_bucket
index|]
condition|)
return|return
name|cache
operator|->
name|node_table
index|[
name|cache
operator|->
name|last_bucket
index|]
return|;
else|else
operator|++
name|cache
operator|->
name|last_bucket
expr_stmt|;
comment|/* No further nodes were found in the hash table.  */
return|return
name|NULL
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given KEY, return corresponding value for it in CACHE.    Return NULL if the KEY is not recorded.  */
end_comment

begin_function
name|void
modifier|*
name|hash_value_for_key
parameter_list|(
name|cache_ptr
name|cache
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|node_ptr
name|node
init|=
name|cache
operator|->
name|node_table
index|[
call|(
modifier|*
name|cache
operator|->
name|hash_func
call|)
argument_list|(
name|cache
argument_list|,
name|key
argument_list|)
index|]
decl_stmt|;
name|void
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|node
condition|)
do|do
block|{
if|if
condition|(
call|(
modifier|*
name|cache
operator|->
name|compare_func
call|)
argument_list|(
name|node
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|retval
operator|=
name|node
operator|->
name|value
expr_stmt|;
break|break;
block|}
else|else
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|retval
operator|&&
name|node
condition|)
do|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Given KEY, return YES if it exists in the CACHE.    Return NO if it does not */
end_comment

begin_function
name|BOOL
name|hash_is_key_in_hash
parameter_list|(
name|cache_ptr
name|cache
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|node_ptr
name|node
init|=
name|cache
operator|->
name|node_table
index|[
call|(
modifier|*
name|cache
operator|->
name|hash_func
call|)
argument_list|(
name|cache
argument_list|,
name|key
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|node
condition|)
do|do
block|{
if|if
condition|(
call|(
modifier|*
name|cache
operator|->
name|compare_func
call|)
argument_list|(
name|node
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
return|return
name|YES
return|;
else|else
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|node
condition|)
do|;
return|return
name|NO
return|;
block|}
end_function

end_unit

