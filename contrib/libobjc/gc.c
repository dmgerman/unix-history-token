begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic data types for Objective C.    Copyright (C) 1998 Free Software Foundation, Inc.    Contributed by Ovidiu Predescu.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files    compiled with GCC to produce an executable, this does not cause    the resulting executable to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"objc.h"
end_include

begin_include
include|#
directive|include
file|"encoding.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|OBJC_WITH_GC
end_if

begin_include
include|#
directive|include
file|<gc.h>
end_include

begin_comment
comment|/* gc_typed.h uses the following but doesn't declare them */
end_comment

begin_typedef
typedef|typedef
name|GC_word
name|word
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|GC_signed_word
name|signed_word
typedef|;
end_typedef

begin_if
if|#
directive|if
name|BITS_PER_WORD
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|LOGWL
value|5
end_define

begin_define
define|#
directive|define
name|modWORDSZ
parameter_list|(
name|n
parameter_list|)
value|((n)& 0x1f)
end_define

begin_comment
comment|/* n mod size of word	    */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS_PER_WORD
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|LOGWL
value|6
end_define

begin_define
define|#
directive|define
name|modWORDSZ
parameter_list|(
name|n
parameter_list|)
value|((n)& 0x3f)
end_define

begin_comment
comment|/* n mod size of word	    */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|divWORDSZ
parameter_list|(
name|n
parameter_list|)
value|((n)>> LOGWL)
end_define

begin_comment
comment|/* divide n by size of word      */
end_comment

begin_include
include|#
directive|include
file|<gc_typed.h>
end_include

begin_comment
comment|/* The following functions set up in `mask` the corresponding pointers.    The offset is incremented with the size of the type.  */
end_comment

begin_define
define|#
directive|define
name|ROUND
parameter_list|(
name|V
parameter_list|,
name|A
parameter_list|)
define|\
value|({ typeof(V) __v=(V); typeof(A) __a=(A); \      __a*((__v+__a-1)/__a); })
end_define

begin_define
define|#
directive|define
name|SET_BIT_FOR_OFFSET
parameter_list|(
name|mask
parameter_list|,
name|offset
parameter_list|)
define|\
value|GC_set_bit(mask, offset / sizeof (void*))
end_define

begin_comment
comment|/* Some prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_gc_setup_struct
parameter_list|(
name|GC_bitmap
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__objc_gc_setup_union
parameter_list|(
name|GC_bitmap
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|__objc_gc_setup_array
parameter_list|(
name|GC_bitmap
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|atoi
argument_list|(
name|type
operator|+
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|type
argument_list|)
condition|)
comment|/* do nothing */
empty_stmt|;
comment|/* skip the size of the array */
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|_C_ARY_B
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|__objc_gc_setup_array
argument_list|(
name|mask
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|_C_STRUCT_B
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|__objc_gc_setup_struct
argument_list|(
name|mask
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|_C_UNION_B
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|__objc_gc_setup_union
argument_list|(
name|mask
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_gc_setup_struct
parameter_list|(
name|GC_bitmap
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|objc_struct_layout
name|layout
decl_stmt|;
name|unsigned
name|int
name|position
decl_stmt|;
specifier|const
name|char
modifier|*
name|mtype
decl_stmt|;
name|objc_layout_structure
argument_list|(
name|type
argument_list|,
operator|&
name|layout
argument_list|)
expr_stmt|;
while|while
condition|(
name|objc_layout_structure_next_member
argument_list|(
operator|&
name|layout
argument_list|)
condition|)
block|{
name|BOOL
name|gc_invisible
init|=
name|NO
decl_stmt|;
name|objc_layout_structure_get_info
argument_list|(
operator|&
name|layout
argument_list|,
operator|&
name|position
argument_list|,
name|NULL
argument_list|,
operator|&
name|mtype
argument_list|)
expr_stmt|;
comment|/* Skip the variable name */
if|if
condition|(
operator|*
name|mtype
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|mtype
operator|++
init|;
operator|*
name|mtype
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|mtype
operator|==
name|_C_GCINVISIBLE
condition|)
block|{
name|gc_invisible
operator|=
name|YES
expr_stmt|;
name|mtype
operator|++
expr_stmt|;
block|}
comment|/* Add to position the offset of this structure */
name|position
operator|+=
name|offset
expr_stmt|;
switch|switch
condition|(
operator|*
name|mtype
condition|)
block|{
case|case
name|_C_ID
case|:
case|case
name|_C_CLASS
case|:
case|case
name|_C_SEL
case|:
case|case
name|_C_PTR
case|:
case|case
name|_C_CHARPTR
case|:
case|case
name|_C_ATOM
case|:
if|if
condition|(
operator|!
name|gc_invisible
condition|)
name|SET_BIT_FOR_OFFSET
argument_list|(
name|mask
argument_list|,
name|position
argument_list|)
expr_stmt|;
break|break;
case|case
name|_C_ARY_B
case|:
name|__objc_gc_setup_array
argument_list|(
name|mask
argument_list|,
name|mtype
argument_list|,
name|position
argument_list|)
expr_stmt|;
break|break;
case|case
name|_C_STRUCT_B
case|:
name|__objc_gc_setup_struct
argument_list|(
name|mask
argument_list|,
name|mtype
argument_list|,
name|position
argument_list|)
expr_stmt|;
break|break;
case|case
name|_C_UNION_B
case|:
name|__objc_gc_setup_union
argument_list|(
name|mask
argument_list|,
name|mtype
argument_list|,
name|position
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_gc_setup_union
parameter_list|(
name|GC_bitmap
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|/* Sub-optimal, quick implementation: assume the union is made of      pointers, set up the mask accordingly. */
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|align
decl_stmt|;
comment|/* Skip the variable name */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
name|size
operator|=
name|objc_sizeof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|align
operator|=
name|objc_alignof_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ROUND
argument_list|(
name|offset
argument_list|,
name|align
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
control|)
block|{
name|SET_BIT_FOR_OFFSET
argument_list|(
name|mask
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Iterates over the types in the structure that represents the class    encoding and sets the bits in mask according to each ivar type.  */
end_comment

begin_function
specifier|static
name|void
name|__objc_gc_type_description_from_type
parameter_list|(
name|GC_bitmap
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|objc_struct_layout
name|layout
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|,
name|align
decl_stmt|;
specifier|const
name|char
modifier|*
name|ivar_type
decl_stmt|;
name|objc_layout_structure
argument_list|(
name|type
argument_list|,
operator|&
name|layout
argument_list|)
expr_stmt|;
while|while
condition|(
name|objc_layout_structure_next_member
argument_list|(
operator|&
name|layout
argument_list|)
condition|)
block|{
name|BOOL
name|gc_invisible
init|=
name|NO
decl_stmt|;
name|objc_layout_structure_get_info
argument_list|(
operator|&
name|layout
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|align
argument_list|,
operator|&
name|ivar_type
argument_list|)
expr_stmt|;
comment|/* Skip the variable name */
if|if
condition|(
operator|*
name|ivar_type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|ivar_type
operator|++
init|;
operator|*
name|ivar_type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|ivar_type
operator|==
name|_C_GCINVISIBLE
condition|)
block|{
name|gc_invisible
operator|=
name|YES
expr_stmt|;
name|ivar_type
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|ivar_type
condition|)
block|{
case|case
name|_C_ID
case|:
case|case
name|_C_CLASS
case|:
case|case
name|_C_SEL
case|:
case|case
name|_C_PTR
case|:
case|case
name|_C_CHARPTR
case|:
if|if
condition|(
operator|!
name|gc_invisible
condition|)
name|SET_BIT_FOR_OFFSET
argument_list|(
name|mask
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|_C_ARY_B
case|:
name|__objc_gc_setup_array
argument_list|(
name|mask
argument_list|,
name|ivar_type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|_C_STRUCT_B
case|:
name|__objc_gc_setup_struct
argument_list|(
name|mask
argument_list|,
name|ivar_type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|_C_UNION_B
case|:
name|__objc_gc_setup_union
argument_list|(
name|mask
argument_list|,
name|ivar_type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Computes in *type the full type encoding of this class including    its super classes. '*size' gives the total number of bytes allocated    into *type, '*current' the number of bytes used so far by the    encoding. */
end_comment

begin_function
specifier|static
name|void
name|__objc_class_structure_encoding
parameter_list|(
name|Class
name|class
parameter_list|,
name|char
modifier|*
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|size
parameter_list|,
name|int
modifier|*
name|current
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ivar_count
decl_stmt|;
name|struct
name|objc_ivar_list
modifier|*
name|ivars
decl_stmt|;
if|if
condition|(
operator|!
name|class
condition|)
block|{
name|strcat
argument_list|(
operator|*
name|type
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
operator|*
name|current
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Add the type encodings of the super classes */
name|__objc_class_structure_encoding
argument_list|(
name|class
operator|->
name|super_class
argument_list|,
name|type
argument_list|,
name|size
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|ivars
operator|=
name|class
operator|->
name|ivars
expr_stmt|;
if|if
condition|(
operator|!
name|ivars
condition|)
return|return;
name|ivar_count
operator|=
name|ivars
operator|->
name|ivar_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivar_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|objc_ivar
modifier|*
name|ivar
init|=
operator|&
operator|(
name|ivars
operator|->
name|ivar_list
index|[
name|i
index|]
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|ivar_type
init|=
name|ivar
operator|->
name|ivar_type
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|ivar_type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|current
operator|+
name|len
operator|+
literal|1
operator|>=
operator|*
name|size
condition|)
block|{
comment|/* Increase the size of the encoding string so that it              contains this ivar's type. */
operator|*
name|size
operator|=
name|ROUND
argument_list|(
operator|*
name|current
operator|+
name|len
operator|+
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|objc_realloc
argument_list|(
operator|*
name|type
argument_list|,
operator|*
name|size
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
operator|*
name|type
operator|+
operator|*
name|current
argument_list|,
name|ivar_type
argument_list|)
expr_stmt|;
operator|*
name|current
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocates the memory that will hold the type description for class    and calls the __objc_class_structure_encoding that generates this    value. */
end_comment

begin_function
name|void
name|__objc_generate_gc_type_description
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|GC_bitmap
name|mask
decl_stmt|;
name|int
name|bits_no
decl_stmt|,
name|size
decl_stmt|;
name|int
name|type_size
init|=
literal|10
decl_stmt|,
name|current
decl_stmt|;
name|char
modifier|*
name|class_structure_type
decl_stmt|;
if|if
condition|(
operator|!
name|CLS_ISCLASS
argument_list|(
name|class
argument_list|)
condition|)
return|return;
comment|/* We have to create a mask in which each bit counts for a pointer member.      We take into consideration all the non-pointer instance variables and we      round them up to the alignment. */
comment|/* The number of bits in the mask is the size of an instance in bytes divided      by the size of a pointer. */
name|bits_no
operator|=
operator|(
name|ROUND
argument_list|(
name|class_get_instance_size
argument_list|(
name|class
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
expr_stmt|;
name|size
operator|=
name|ROUND
argument_list|(
name|bits_no
argument_list|,
name|BITS_PER_WORD
argument_list|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|mask
operator|=
name|objc_atomic_malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|class_structure_type
operator|=
name|objc_atomic_malloc
argument_list|(
name|type_size
argument_list|)
expr_stmt|;
operator|*
name|class_structure_type
operator|=
name|current
operator|=
literal|0
expr_stmt|;
name|__objc_class_structure_encoding
argument_list|(
name|class
argument_list|,
operator|&
name|class_structure_type
argument_list|,
operator|&
name|type_size
argument_list|,
operator|&
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|+
literal|1
operator|==
name|type_size
condition|)
name|class_structure_type
operator|=
name|objc_realloc
argument_list|(
name|class_structure_type
argument_list|,
operator|++
name|type_size
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|class_structure_type
operator|+
name|current
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
comment|//  printf ("type description for '%s' is %s\n", class->name, class_structure_type);
name|__objc_gc_type_description_from_type
argument_list|(
name|mask
argument_list|,
name|class_structure_type
argument_list|)
expr_stmt|;
name|objc_free
argument_list|(
name|class_structure_type
argument_list|)
expr_stmt|;
define|#
directive|define
name|DEBUG
value|1
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"  mask for '%s', type '%s' (bits %d, mask size %d) is:"
argument_list|,
name|class_structure_type
argument_list|,
name|class
operator|->
name|name
argument_list|,
name|bits_no
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|class
operator|->
name|gc_object_type
operator|=
operator|(
name|void
operator|*
operator|)
name|GC_make_descriptor
argument_list|(
name|mask
argument_list|,
name|bits_no
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns YES if type denotes a pointer type, NO otherwise */
end_comment

begin_function
specifier|static
specifier|inline
name|BOOL
name|__objc_ivar_pointer
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|=
name|objc_skip_type_qualifiers
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|type
operator|==
name|_C_ID
operator|||
operator|*
name|type
operator|==
name|_C_CLASS
operator|||
operator|*
name|type
operator|==
name|_C_SEL
operator|||
operator|*
name|type
operator|==
name|_C_PTR
operator|||
operator|*
name|type
operator|==
name|_C_CHARPTR
operator|||
operator|*
name|type
operator|==
name|_C_ATOM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Mark the instance variable whose name is given by ivarname as a    weak pointer (a pointer hidden to the garbage collector) if    gc_invisible is true. If gc_invisible is false it unmarks the    instance variable and makes it a normal pointer, visible to the    garbage collector.     This operation only makes sense on instance variables that are    pointers.  */
end_comment

begin_function
name|void
name|class_ivar_set_gcinvisible
parameter_list|(
name|Class
name|class
parameter_list|,
specifier|const
name|char
modifier|*
name|ivarname
parameter_list|,
name|BOOL
name|gc_invisible
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ivar_count
decl_stmt|;
name|struct
name|objc_ivar_list
modifier|*
name|ivars
decl_stmt|;
if|if
condition|(
operator|!
name|class
operator|||
operator|!
name|ivarname
condition|)
return|return;
name|ivars
operator|=
name|class
operator|->
name|ivars
expr_stmt|;
if|if
condition|(
operator|!
name|ivars
condition|)
return|return;
name|ivar_count
operator|=
name|ivars
operator|->
name|ivar_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivar_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|objc_ivar
modifier|*
name|ivar
init|=
operator|&
operator|(
name|ivars
operator|->
name|ivar_list
index|[
name|i
index|]
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|ivar
operator|->
name|ivar_name
operator|||
name|strcmp
argument_list|(
name|ivar
operator|->
name|ivar_name
argument_list|,
name|ivarname
argument_list|)
condition|)
continue|continue;
name|assert
argument_list|(
name|ivar
operator|->
name|ivar_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|ivar
operator|->
name|ivar_type
expr_stmt|;
comment|/* Skip the variable name */
if|if
condition|(
operator|*
name|type
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|type
operator|++
init|;
operator|*
name|type
operator|++
operator|!=
literal|'"'
condition|;
control|)
comment|/* do nothing */
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|type
operator|==
name|_C_GCINVISIBLE
condition|)
block|{
name|char
modifier|*
name|new_type
decl_stmt|;
if|if
condition|(
name|gc_invisible
operator|||
operator|!
name|__objc_ivar_pointer
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* The type of the variable already matches the 			   requested gc_invisible type */
comment|/* The variable is gc_invisible and we have to reverse it */
name|new_type
operator|=
name|objc_atomic_malloc
argument_list|(
name|strlen
argument_list|(
name|ivar
operator|->
name|ivar_type
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_type
argument_list|,
name|ivar
operator|->
name|ivar_type
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|type
operator|-
name|ivar
operator|->
name|ivar_type
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new_type
argument_list|,
name|type
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ivar
operator|->
name|ivar_type
operator|=
name|new_type
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|new_type
decl_stmt|;
if|if
condition|(
operator|!
name|gc_invisible
operator|||
operator|!
name|__objc_ivar_pointer
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* The type of the variable already matches the 			   requested gc_invisible type */
comment|/* The variable is gc visible and we have to make it gc_invisible */
name|new_type
operator|=
name|objc_malloc
argument_list|(
name|strlen
argument_list|(
name|ivar
operator|->
name|ivar_type
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_type
argument_list|,
name|ivar
operator|->
name|ivar_type
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|type
operator|-
name|ivar
operator|->
name|ivar_type
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new_type
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ivar
operator|->
name|ivar_type
operator|=
name|new_type
expr_stmt|;
block|}
name|__objc_generate_gc_type_description
argument_list|(
name|class
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Search the instance variable in the superclasses */
name|class_ivar_set_gcinvisible
argument_list|(
name|class
operator|->
name|super_class
argument_list|,
name|ivarname
argument_list|,
name|gc_invisible
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !OBJC_WITH_GC */
end_comment

begin_function
name|void
name|__objc_generate_gc_type_description
parameter_list|(
name|Class
name|class
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|class_ivar_set_gcinvisible
parameter_list|(
name|Class
name|class
parameter_list|,
specifier|const
name|char
modifier|*
name|ivarname
parameter_list|,
name|BOOL
name|gc_invisible
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJC_WITH_GC */
end_comment

end_unit

