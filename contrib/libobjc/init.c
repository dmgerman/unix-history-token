begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime initialization     Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup    +load support contributed by Ovidiu Predescu<ovidiu@net-community.com>  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_comment
comment|/* The version number of this runtime.  This must match the number     defined in gcc (objc-act.c) */
end_comment

begin_define
define|#
directive|define
name|OBJC_VERSION
value|8
end_define

begin_define
define|#
directive|define
name|PROTOCOL_VERSION
value|2
end_define

begin_comment
comment|/* This list contains all modules currently loaded into the runtime */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|__objc_module_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_comment
comment|/* This list contains all proto_list's not yet assigned class links */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|unclaimed_proto_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_comment
comment|/* List of unresolved static instances.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|uninitialized_statics
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_comment
comment|/* Global runtime "write" mutex. */
end_comment

begin_decl_stmt
name|objc_mutex_t
name|__objc_runtime_mutex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of threads that are alive. */
end_comment

begin_decl_stmt
name|int
name|__objc_runtime_threads_alive
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_comment
comment|/* Check compiler vs runtime version */
end_comment

begin_function_decl
specifier|static
name|void
name|init_check_module_version
parameter_list|(
name|Module_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Assign isa links to protos */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_init_protocols
parameter_list|(
name|struct
name|objc_protocol_list
modifier|*
name|protos
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add protocol to class */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_class_add_protocols
parameter_list|(
name|Class
parameter_list|,
name|struct
name|objc_protocol_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is a hook which is called by __objc_exec_class every time a class    or a category is loaded into the runtime.  This may e.g. help a    dynamic loader determine the classes that have been loaded when    an object file is dynamically linked in */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|_objc_load_callback
function_decl|)
parameter_list|(
name|Class
name|class
parameter_list|,
name|Category
modifier|*
name|category
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* !T:SAFE */
end_comment

begin_comment
comment|/* Is all categories/classes resolved? */
end_comment

begin_decl_stmt
name|BOOL
name|__objc_dangling_categories
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:UNUSED */
end_comment

begin_function_decl
specifier|extern
name|SEL
name|__sel_register_typed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|types
parameter_list|,
name|struct
name|objc_selector
modifier|*
name|orig
parameter_list|,
name|BOOL
name|is_const
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Sends +load to all classes and categories in certain situations. */
end_comment

begin_function_decl
specifier|static
name|void
name|objc_send_load
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Inserts all the classes defined in module in a tree of classes that    resembles the class hierarchy. This tree is traversed in preorder and the    classes in its nodes receive the +load message if these methods were not    executed before. The algorithm ensures that when the +load method of a class    is executed all the superclasses have been already received the +load    message. */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_create_classes_tree
parameter_list|(
name|Module_t
name|module
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__objc_call_callback
parameter_list|(
name|Module_t
name|module
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A special version that works only before the classes are completely    installed in the runtime. */
end_comment

begin_function_decl
specifier|static
name|BOOL
name|class_is_subclass_of_class
parameter_list|(
name|Class
name|class
parameter_list|,
name|Class
name|superclass
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|objc_class_tree
block|{
name|Class
name|class
decl_stmt|;
name|struct
name|objc_list
modifier|*
name|subclasses
decl_stmt|;
comment|/* `head' is pointer to an objc_class_tree */
block|}
name|objc_class_tree
typedef|;
end_typedef

begin_comment
comment|/* This is a linked list of objc_class_tree trees. The head of these trees    are root classes (their super class is Nil). These different trees    represent different class hierarchies. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|__objc_class_tree_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keeps the +load methods who have been already executed. This hash should    not be destroyed during the execution of the program. */
end_comment

begin_decl_stmt
specifier|static
name|cache_ptr
name|__objc_load_methods
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Creates a tree of classes whose topmost class is directly inherited from    `upper' and the bottom class in this tree is `bottom_class'. The classes    in this tree are super classes of `bottom_class'. `subclasses' member    of each tree node point to the next subclass tree node. */
end_comment

begin_function
specifier|static
name|objc_class_tree
modifier|*
name|create_tree_of_subclasses_inherited_from
parameter_list|(
name|Class
name|bottom_class
parameter_list|,
name|Class
name|upper
parameter_list|)
block|{
name|Class
name|superclass
init|=
name|bottom_class
operator|->
name|super_class
condition|?
name|objc_lookup_class
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bottom_class
operator|->
name|super_class
argument_list|)
else|:
name|Nil
decl_stmt|;
name|objc_class_tree
modifier|*
name|tree
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"create_tree_of_subclasses_inherited_from:"
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"bottom_class = %s, upper = %s\n"
argument_list|,
operator|(
name|bottom_class
condition|?
name|bottom_class
operator|->
name|name
else|:
name|NULL
operator|)
argument_list|,
operator|(
name|upper
condition|?
name|upper
operator|->
name|name
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|prev
operator|=
name|objc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|objc_class_tree
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|class
operator|=
name|bottom_class
expr_stmt|;
while|while
condition|(
name|superclass
operator|!=
name|upper
condition|)
block|{
name|tree
operator|=
name|objc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|objc_class_tree
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|->
name|class
operator|=
name|superclass
expr_stmt|;
name|tree
operator|->
name|subclasses
operator|=
name|list_cons
argument_list|(
name|prev
argument_list|,
name|tree
operator|->
name|subclasses
argument_list|)
expr_stmt|;
name|superclass
operator|=
operator|(
name|superclass
operator|->
name|super_class
condition|?
name|objc_lookup_class
argument_list|(
operator|(
name|char
operator|*
operator|)
name|superclass
operator|->
name|super_class
argument_list|)
else|:
name|Nil
operator|)
expr_stmt|;
name|prev
operator|=
name|tree
expr_stmt|;
block|}
return|return
name|tree
return|;
block|}
end_function

begin_comment
comment|/* Insert the `class' into the proper place in the `tree' class hierarchy. This    function returns a new tree if the class has been successfully inserted into    the tree or NULL if the class is not part of the classes hierarchy described    by `tree'. This function is private to objc_tree_insert_class(), you should    not call it directly. */
end_comment

begin_function
specifier|static
name|objc_class_tree
modifier|*
name|__objc_tree_insert_class
parameter_list|(
name|objc_class_tree
modifier|*
name|tree
parameter_list|,
name|Class
name|class
parameter_list|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"__objc_tree_insert_class: tree = %x, class = %s\n"
argument_list|,
name|tree
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return
name|create_tree_of_subclasses_inherited_from
argument_list|(
name|class
argument_list|,
name|NULL
argument_list|)
return|;
elseif|else
if|if
condition|(
name|class
operator|==
name|tree
operator|->
name|class
condition|)
block|{
comment|/* `class' has been already inserted */
name|DEBUG_PRINTF
argument_list|(
literal|"1. class %s was previously inserted\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|class
operator|->
name|super_class
condition|?
name|objc_lookup_class
argument_list|(
operator|(
name|char
operator|*
operator|)
name|class
operator|->
name|super_class
argument_list|)
else|:
name|Nil
operator|)
operator|==
name|tree
operator|->
name|class
condition|)
block|{
comment|/* If class is a direct subclass of tree->class then add class to the 	 list of subclasses. First check to see if it wasn't already 	 inserted. */
name|struct
name|objc_list
modifier|*
name|list
init|=
name|tree
operator|->
name|subclasses
decl_stmt|;
name|objc_class_tree
modifier|*
name|node
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
comment|/* Class has been already inserted; do nothing just return 	     the tree. */
if|if
condition|(
operator|(
operator|(
name|objc_class_tree
operator|*
operator|)
name|list
operator|->
name|head
operator|)
operator|->
name|class
operator|==
name|class
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"2. class %s was previously inserted\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
block|}
name|list
operator|=
name|list
operator|->
name|tail
expr_stmt|;
block|}
comment|/* Create a new node class and insert it into the list of subclasses */
name|node
operator|=
name|objc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|objc_class_tree
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|tree
operator|->
name|subclasses
operator|=
name|list_cons
argument_list|(
name|node
argument_list|,
name|tree
operator|->
name|subclasses
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"3. class %s inserted\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
block|}
else|else
block|{
comment|/* The class is not a direct subclass of tree->class. Search for class's          superclasses in the list of subclasses. */
name|struct
name|objc_list
modifier|*
name|subclasses
init|=
name|tree
operator|->
name|subclasses
decl_stmt|;
comment|/* Precondition: the class must be a subclass of tree->class; otherwise          return NULL to indicate our caller that it must take the next tree. */
if|if
condition|(
operator|!
name|class_is_subclass_of_class
argument_list|(
name|class
argument_list|,
name|tree
operator|->
name|class
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
name|subclasses
operator|!=
name|NULL
condition|;
name|subclasses
operator|=
name|subclasses
operator|->
name|tail
control|)
block|{
name|Class
name|aClass
init|=
operator|(
operator|(
name|objc_class_tree
operator|*
operator|)
operator|(
name|subclasses
operator|->
name|head
operator|)
operator|)
operator|->
name|class
decl_stmt|;
if|if
condition|(
name|class_is_subclass_of_class
argument_list|(
name|class
argument_list|,
name|aClass
argument_list|)
condition|)
block|{
comment|/* If we found one of class's superclasses we insert the class 	         into its subtree and return the original tree since nothing 		 has been changed. */
name|subclasses
operator|->
name|head
operator|=
name|__objc_tree_insert_class
argument_list|(
name|subclasses
operator|->
name|head
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"4. class %s inserted\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
block|}
block|}
comment|/* We haven't found a subclass of `class' in the `subclasses' list.          Create a new tree of classes whose topmost class is a direct subclass 	 of tree->class. */
block|{
name|objc_class_tree
modifier|*
name|new_tree
init|=
name|create_tree_of_subclasses_inherited_from
argument_list|(
name|class
argument_list|,
name|tree
operator|->
name|class
argument_list|)
decl_stmt|;
name|tree
operator|->
name|subclasses
operator|=
name|list_cons
argument_list|(
name|new_tree
argument_list|,
name|tree
operator|->
name|subclasses
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"5. class %s inserted\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function inserts `class' in the right tree hierarchy classes. */
end_comment

begin_function
specifier|static
name|void
name|objc_tree_insert_class
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|list_node
decl_stmt|;
name|objc_class_tree
modifier|*
name|tree
decl_stmt|;
name|list_node
operator|=
name|__objc_class_tree_list
expr_stmt|;
while|while
condition|(
name|list_node
condition|)
block|{
name|tree
operator|=
name|__objc_tree_insert_class
argument_list|(
name|list_node
operator|->
name|head
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
condition|)
block|{
name|list_node
operator|->
name|head
operator|=
name|tree
expr_stmt|;
break|break;
block|}
else|else
name|list_node
operator|=
name|list_node
operator|->
name|tail
expr_stmt|;
block|}
comment|/* If the list was finished but the class hasn't been inserted, insert it      here. */
if|if
condition|(
operator|!
name|list_node
condition|)
block|{
name|__objc_class_tree_list
operator|=
name|list_cons
argument_list|(
name|NULL
argument_list|,
name|__objc_class_tree_list
argument_list|)
expr_stmt|;
name|__objc_class_tree_list
operator|->
name|head
operator|=
name|__objc_tree_insert_class
argument_list|(
name|NULL
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Traverse tree in preorder. Used to send +load. */
end_comment

begin_function
specifier|static
name|void
name|objc_preorder_traverse
parameter_list|(
name|objc_class_tree
modifier|*
name|tree
parameter_list|,
name|int
name|level
parameter_list|,
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|objc_class_tree
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|node
decl_stmt|;
call|(
modifier|*
name|function
call|)
argument_list|(
name|tree
argument_list|,
name|level
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|tree
operator|->
name|subclasses
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|tail
control|)
name|objc_preorder_traverse
argument_list|(
name|node
operator|->
name|head
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Traverse tree in postorder. Used to destroy a tree. */
end_comment

begin_function
specifier|static
name|void
name|objc_postorder_traverse
parameter_list|(
name|objc_class_tree
modifier|*
name|tree
parameter_list|,
name|int
name|level
parameter_list|,
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|objc_class_tree
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|tree
operator|->
name|subclasses
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|tail
control|)
name|objc_postorder_traverse
argument_list|(
name|node
operator|->
name|head
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|function
argument_list|)
expr_stmt|;
call|(
modifier|*
name|function
call|)
argument_list|(
name|tree
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used to print a tree class hierarchy. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|__objc_tree_print
parameter_list|(
name|objc_class_tree
modifier|*
name|tree
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|level
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tree
operator|->
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Walks on a linked list of methods in the reverse order and executes all    the methods corresponding to `op' selector. Walking in the reverse order    assures the +load of class is executed first and then +load of categories    because of the way in which categories are added to the class methods. */
end_comment

begin_function
specifier|static
name|void
name|__objc_send_message_in_list
parameter_list|(
name|MethodList_t
name|method_list
parameter_list|,
name|Class
name|class
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|method_list
condition|)
return|return;
comment|/* First execute the `op' message in the following method lists */
name|__objc_send_message_in_list
argument_list|(
name|method_list
operator|->
name|method_next
argument_list|,
name|class
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Search the method list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
name|i
operator|++
control|)
block|{
name|Method_t
name|mth
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mth
operator|->
name|method_name
operator|&&
name|sel_eq
argument_list|(
name|mth
operator|->
name|method_name
argument_list|,
name|op
argument_list|)
operator|&&
operator|!
name|hash_is_key_in_hash
argument_list|(
name|__objc_load_methods
argument_list|,
name|mth
operator|->
name|method_name
argument_list|)
condition|)
block|{
comment|/* The method was found and wasn't previously executed. */
call|(
modifier|*
name|mth
operator|->
name|method_imp
call|)
argument_list|(
operator|(
name|id
operator|)
name|class
argument_list|,
name|mth
operator|->
name|method_name
argument_list|)
expr_stmt|;
comment|/* Add this method into the +load hash table */
name|hash_add
argument_list|(
operator|&
name|__objc_load_methods
argument_list|,
name|mth
operator|->
name|method_imp
argument_list|,
name|mth
operator|->
name|method_imp
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"sending +load in class: %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_send_load
parameter_list|(
name|objc_class_tree
modifier|*
name|tree
parameter_list|,
name|int
name|level
parameter_list|)
block|{
specifier|static
name|SEL
name|load_sel
init|=
literal|0
decl_stmt|;
name|Class
name|class
init|=
name|tree
operator|->
name|class
decl_stmt|;
name|MethodList_t
name|method_list
init|=
name|class
operator|->
name|class_pointer
operator|->
name|methods
decl_stmt|;
if|if
condition|(
operator|!
name|load_sel
condition|)
name|load_sel
operator|=
name|sel_register_name
argument_list|(
literal|"load"
argument_list|)
expr_stmt|;
name|__objc_send_message_in_list
argument_list|(
name|method_list
argument_list|,
name|class
argument_list|,
name|load_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_destroy_class_tree_node
parameter_list|(
name|objc_class_tree
modifier|*
name|tree
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|objc_free
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is used to check if the relationship between two classes before the    runtime completely installs the classes. */
end_comment

begin_function
specifier|static
name|BOOL
name|class_is_subclass_of_class
parameter_list|(
name|Class
name|class
parameter_list|,
name|Class
name|superclass
parameter_list|)
block|{
for|for
control|(
init|;
name|class
operator|!=
name|Nil
condition|;
control|)
block|{
if|if
condition|(
name|class
operator|==
name|superclass
condition|)
return|return
name|YES
return|;
name|class
operator|=
operator|(
name|class
operator|->
name|super_class
condition|?
name|objc_lookup_class
argument_list|(
operator|(
name|char
operator|*
operator|)
name|class
operator|->
name|super_class
argument_list|)
else|:
name|Nil
operator|)
expr_stmt|;
block|}
return|return
name|NO
return|;
block|}
end_function

begin_comment
comment|/* This list contains all the classes in the runtime system for whom their    superclasses are not yet know to the runtime. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|unresolved_classes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extern function used to reference the Object and NXConstantString classes.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__objc_force_linking
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|__objc_force_linking
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|void
name|__objc_linking
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|__objc_linking
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run through the statics list, removing modules as soon as all its statics    have been initialized.  */
end_comment

begin_function
specifier|static
name|void
name|objc_init_statics
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objc_list
modifier|*
modifier|*
name|cell
init|=
operator|&
name|uninitialized_statics
decl_stmt|;
name|struct
name|objc_static_instances
modifier|*
modifier|*
name|statics_in_module
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cell
condition|)
block|{
name|int
name|module_initialized
init|=
literal|1
decl_stmt|;
for|for
control|(
name|statics_in_module
operator|=
operator|(
operator|*
name|cell
operator|)
operator|->
name|head
init|;
operator|*
name|statics_in_module
condition|;
name|statics_in_module
operator|++
control|)
block|{
name|struct
name|objc_static_instances
modifier|*
name|statics
init|=
operator|*
name|statics_in_module
decl_stmt|;
name|Class
name|class
init|=
name|objc_lookup_class
argument_list|(
name|statics
operator|->
name|class_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|class
condition|)
name|module_initialized
operator|=
literal|0
expr_stmt|;
comment|/* Actually, the static's class_pointer will be NULL when we              haven't been here before.  However, the comparison is to be              reminded of taking into account class posing and to think about              possible semantics...  */
elseif|else
if|if
condition|(
name|class
operator|!=
name|statics
operator|->
name|instances
index|[
literal|0
index|]
operator|->
name|class_pointer
condition|)
block|{
name|id
modifier|*
name|inst
decl_stmt|;
for|for
control|(
name|inst
operator|=
operator|&
name|statics
operator|->
name|instances
index|[
literal|0
index|]
init|;
operator|*
name|inst
condition|;
name|inst
operator|++
control|)
block|{
operator|(
operator|*
name|inst
operator|)
operator|->
name|class_pointer
operator|=
name|class
expr_stmt|;
comment|/* ??? Make sure the object will not be freed.  With                      refcounting, invoke `-retain'.  Without refcounting, do                      nothing and hope that `-free' will never be invoked.  */
comment|/* ??? Send the object an `-initStatic' or something to                      that effect now or later on?  What are the semantics of                      statically allocated instances, besides the trivial                      NXConstantString, anyway?  */
block|}
block|}
block|}
if|if
condition|(
name|module_initialized
condition|)
block|{
comment|/* Remove this module from the uninitialized list.  */
name|struct
name|objc_list
modifier|*
name|this
init|=
operator|*
name|cell
decl_stmt|;
operator|*
name|cell
operator|=
name|this
operator|->
name|tail
expr_stmt|;
name|objc_free
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
name|cell
operator|=
operator|&
operator|(
operator|*
name|cell
operator|)
operator|->
name|tail
expr_stmt|;
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* objc_init_statics */
end_comment

begin_comment
comment|/* This function is called by constructor functions generated for each    module compiled.  (_GLOBAL_$I$...) The purpose of this function is to    gather the module pointers so that they may be processed by the    initialization routines as soon as possible */
end_comment

begin_function
name|void
name|__objc_exec_class
parameter_list|(
name|Module_t
name|module
parameter_list|)
block|{
comment|/* Have we processed any constructors previously?  This flag is used to      indicate that some global data structures need to be built.  */
specifier|static
name|BOOL
name|previous_constructors
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|objc_list
modifier|*
name|unclaimed_categories
init|=
literal|0
decl_stmt|;
comment|/* The symbol table (defined in objc-api.h) generated by gcc */
name|Symtab_t
name|symtab
init|=
name|module
operator|->
name|symtab
decl_stmt|;
comment|/* The statics in this module */
name|struct
name|objc_static_instances
modifier|*
modifier|*
name|statics
init|=
name|symtab
operator|->
name|defs
index|[
name|symtab
operator|->
name|cls_def_cnt
operator|+
name|symtab
operator|->
name|cat_def_cnt
index|]
decl_stmt|;
comment|/* Entry used to traverse hash lists */
name|struct
name|objc_list
modifier|*
modifier|*
name|cell
decl_stmt|;
comment|/* The table of selector references for this module */
name|SEL
name|selectors
init|=
name|symtab
operator|->
name|refs
decl_stmt|;
comment|/* dummy counter */
name|int
name|i
decl_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"received module: %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* check gcc version */
name|init_check_module_version
argument_list|(
name|module
argument_list|)
expr_stmt|;
comment|/* On the first call of this routine, initialize some data structures.  */
if|if
condition|(
operator|!
name|previous_constructors
condition|)
block|{
comment|/* Initialize thread-safe system */
name|__objc_init_thread_system
argument_list|()
expr_stmt|;
name|__objc_runtime_threads_alive
operator|=
literal|1
expr_stmt|;
name|__objc_runtime_mutex
operator|=
name|objc_mutex_allocate
argument_list|()
expr_stmt|;
name|__objc_init_selector_tables
argument_list|()
expr_stmt|;
name|__objc_init_class_tables
argument_list|()
expr_stmt|;
name|__objc_init_dispatch_tables
argument_list|()
expr_stmt|;
name|__objc_class_tree_list
operator|=
name|list_cons
argument_list|(
name|NULL
argument_list|,
name|__objc_class_tree_list
argument_list|)
expr_stmt|;
name|__objc_load_methods
operator|=
name|hash_new
argument_list|(
literal|128
argument_list|,
operator|(
name|hash_func_type
operator|)
name|hash_ptr
argument_list|,
name|compare_ptrs
argument_list|)
expr_stmt|;
name|previous_constructors
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Save the module pointer for later processing. (not currently used) */
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|__objc_module_list
operator|=
name|list_cons
argument_list|(
name|module
argument_list|,
name|__objc_module_list
argument_list|)
expr_stmt|;
comment|/* Replace referenced selectors from names to SEL's.  */
if|if
condition|(
name|selectors
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|selectors
index|[
name|i
index|]
operator|.
name|sel_id
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|type
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|selectors
index|[
name|i
index|]
operator|.
name|sel_id
expr_stmt|;
name|type
operator|=
operator|(
name|char
operator|*
operator|)
name|selectors
index|[
name|i
index|]
operator|.
name|sel_types
expr_stmt|;
comment|/* Constructors are constant static data so we can safely store 	     pointers to them in the runtime structures. is_const == YES */
name|__sel_register_typed_name
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
operator|(
expr|struct
name|objc_selector
operator|*
operator|)
operator|&
operator|(
name|selectors
index|[
name|i
index|]
operator|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Parse the classes in the load module and gather selector information.  */
name|DEBUG_PRINTF
argument_list|(
literal|"gathering selectors from module: %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cls_def_cnt
condition|;
operator|++
name|i
control|)
block|{
name|Class
name|class
init|=
operator|(
name|Class
operator|)
name|symtab
operator|->
name|defs
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|superclass
init|=
operator|(
name|char
operator|*
operator|)
name|class
operator|->
name|super_class
decl_stmt|;
comment|/* Make sure we have what we think.  */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISMETA
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"phase 1, processing class: %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Initialize the subclass list to be NULL. 	 In some cases it isn't and this crashes the program. */
name|class
operator|->
name|subclass_list
operator|=
name|NULL
expr_stmt|;
comment|/* Store the class in the class table and assign class numbers.  */
name|__objc_add_class_to_hash
argument_list|(
name|class
argument_list|)
expr_stmt|;
comment|/* Register all of the selectors in the class and meta class.  */
name|__objc_register_selectors_from_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|__objc_register_selectors_from_class
argument_list|(
operator|(
name|Class
operator|)
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
comment|/* Install the fake dispatch tables */
name|__objc_install_premature_dtable
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|__objc_install_premature_dtable
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
comment|/* Register the instance methods as class methods, this is 	 only done for root classes. */
name|__objc_register_instance_methods_to_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|->
name|protocols
condition|)
name|__objc_init_protocols
argument_list|(
name|class
operator|->
name|protocols
argument_list|)
expr_stmt|;
comment|/* Check to see if the superclass is known in this point. If it's not 	 add the class to the unresolved_classes list. */
if|if
condition|(
name|superclass
operator|&&
operator|!
name|objc_lookup_class
argument_list|(
name|superclass
argument_list|)
condition|)
name|unresolved_classes
operator|=
name|list_cons
argument_list|(
name|class
argument_list|,
name|unresolved_classes
argument_list|)
expr_stmt|;
block|}
comment|/* Process category information from the module.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cat_def_cnt
condition|;
operator|++
name|i
control|)
block|{
name|Category_t
name|category
init|=
name|symtab
operator|->
name|defs
index|[
name|i
operator|+
name|symtab
operator|->
name|cls_def_cnt
index|]
decl_stmt|;
name|Class
name|class
init|=
name|objc_lookup_class
argument_list|(
name|category
operator|->
name|class_name
argument_list|)
decl_stmt|;
comment|/* If the class for the category exists then append its methods.  */
if|if
condition|(
name|class
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"processing categories from (module,object): %s, %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Do instance methods.  */
if|if
condition|(
name|category
operator|->
name|instance_methods
condition|)
name|class_add_method_list
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|instance_methods
argument_list|)
expr_stmt|;
comment|/* Do class methods.  */
if|if
condition|(
name|category
operator|->
name|class_methods
condition|)
name|class_add_method_list
argument_list|(
operator|(
name|Class
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|category
operator|->
name|class_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|protocols
condition|)
block|{
name|__objc_init_protocols
argument_list|(
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
name|__objc_class_add_protocols
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
block|}
comment|/* Register the instance methods as class methods, this is              only done for root classes. */
name|__objc_register_instance_methods_to_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The object to which the category methods belong can't be found. 	     Save the information.  */
name|unclaimed_categories
operator|=
name|list_cons
argument_list|(
name|category
argument_list|,
name|unclaimed_categories
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|statics
condition|)
name|uninitialized_statics
operator|=
name|list_cons
argument_list|(
name|statics
argument_list|,
name|uninitialized_statics
argument_list|)
expr_stmt|;
if|if
condition|(
name|uninitialized_statics
condition|)
name|objc_init_statics
argument_list|()
expr_stmt|;
comment|/* Scan the unclaimed category hash.  Attempt to attach any unclaimed      categories to objects.  */
for|for
control|(
name|cell
operator|=
operator|&
name|unclaimed_categories
init|;
operator|*
name|cell
condition|;
operator|(
block|{
if|if
condition|(
operator|*
name|cell
condition|)
name|cell
operator|=
operator|&
operator|(
operator|*
name|cell
operator|)
operator|->
name|tail
expr_stmt|;
block|}
control|)
block|)
block|{
name|Category_t
name|category
init|=
operator|(
operator|*
name|cell
operator|)
operator|->
name|head
decl_stmt|;
name|Class
name|class
init|=
name|objc_lookup_class
argument_list|(
name|category
operator|->
name|class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|class
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"attaching stored categories to object: %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
name|list_remove_head
argument_list|(
name|cell
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|instance_methods
condition|)
name|class_add_method_list
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|instance_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|class_methods
condition|)
name|class_add_method_list
argument_list|(
operator|(
name|Class
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|category
operator|->
name|class_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|protocols
condition|)
block|{
name|__objc_init_protocols
argument_list|(
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
name|__objc_class_add_protocols
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
block|}
comment|/* Register the instance methods as class methods, this is              only done for root classes. */
name|__objc_register_instance_methods_to_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|if
condition|(
name|unclaimed_proto_list
operator|&&
name|objc_lookup_class
argument_list|(
literal|"Protocol"
argument_list|)
condition|)
block|{
name|list_mapcar
argument_list|(
name|unclaimed_proto_list
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|__objc_init_protocols
argument_list|)
expr_stmt|;
name|list_free
argument_list|(
name|unclaimed_proto_list
argument_list|)
expr_stmt|;
name|unclaimed_proto_list
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|objc_send_load
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|void
name|objc_send_load
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|__objc_module_list
condition|)
return|return;
comment|/* Try to find out if all the classes loaded so far also have their      superclasses known to the runtime. We suppose that the objects that are      allocated in the +load method are in general of a class declared in the      same module. */
if|if
condition|(
name|unresolved_classes
condition|)
block|{
name|Class
name|class
init|=
name|unresolved_classes
operator|->
name|head
decl_stmt|;
while|while
condition|(
name|objc_lookup_class
argument_list|(
operator|(
name|char
operator|*
operator|)
name|class
operator|->
name|super_class
argument_list|)
condition|)
block|{
name|list_remove_head
argument_list|(
operator|&
name|unresolved_classes
argument_list|)
expr_stmt|;
if|if
condition|(
name|unresolved_classes
condition|)
name|class
operator|=
name|unresolved_classes
operator|->
name|head
expr_stmt|;
else|else
break|break;
block|}
comment|/*        * If we still have classes for whom we don't have yet their super        * classes known to the runtime we don't send the +load messages.        */
if|if
condition|(
name|unresolved_classes
condition|)
return|return;
block|}
comment|/* Special check to allow creating and sending messages to constant strings      in +load methods. If these classes are not yet known, even if all the      other classes are known, delay sending of +load. */
if|if
condition|(
operator|!
name|objc_lookup_class
argument_list|(
literal|"NXConstantString"
argument_list|)
operator|||
operator|!
name|objc_lookup_class
argument_list|(
literal|"Object"
argument_list|)
condition|)
return|return;
comment|/* Iterate over all modules in the __objc_module_list and call on them the      __objc_create_classes_tree function. This function creates a tree of      classes that resembles the class hierarchy. */
name|list_mapcar
argument_list|(
name|__objc_module_list
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|__objc_create_classes_tree
argument_list|)
expr_stmt|;
while|while
condition|(
name|__objc_class_tree_list
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|objc_preorder_traverse
argument_list|(
name|__objc_class_tree_list
operator|->
name|head
argument_list|,
literal|0
argument_list|,
name|__objc_tree_print
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|objc_preorder_traverse
argument_list|(
name|__objc_class_tree_list
operator|->
name|head
argument_list|,
literal|0
argument_list|,
name|__objc_send_load
argument_list|)
expr_stmt|;
name|objc_postorder_traverse
argument_list|(
name|__objc_class_tree_list
operator|->
name|head
argument_list|,
literal|0
argument_list|,
name|__objc_destroy_class_tree_node
argument_list|)
expr_stmt|;
name|list_remove_head
argument_list|(
operator|&
name|__objc_class_tree_list
argument_list|)
expr_stmt|;
block|}
name|list_mapcar
argument_list|(
name|__objc_module_list
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|__objc_call_callback
argument_list|)
expr_stmt|;
name|list_free
argument_list|(
name|__objc_module_list
argument_list|)
expr_stmt|;
name|__objc_module_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_create_classes_tree
parameter_list|(
name|Module_t
name|module
parameter_list|)
block|{
comment|/* The runtime mutex is locked in this point */
name|Symtab_t
name|symtab
init|=
name|module
operator|->
name|symtab
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Iterate thru classes defined in this module and insert them in the classes      tree hierarchy. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cls_def_cnt
condition|;
name|i
operator|++
control|)
block|{
name|Class
name|class
init|=
operator|(
name|Class
operator|)
name|symtab
operator|->
name|defs
index|[
name|i
index|]
decl_stmt|;
name|objc_tree_insert_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_call_callback
parameter_list|(
name|Module_t
name|module
parameter_list|)
block|{
comment|/* The runtime mutex is locked in this point */
name|Symtab_t
name|symtab
init|=
name|module
operator|->
name|symtab
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Iterate thru classes defined in this module and call the callback for      each one. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cls_def_cnt
condition|;
name|i
operator|++
control|)
block|{
name|Class
name|class
init|=
operator|(
name|Class
operator|)
name|symtab
operator|->
name|defs
index|[
name|i
index|]
decl_stmt|;
comment|/* Call the _objc_load_callback for this class. */
if|if
condition|(
name|_objc_load_callback
condition|)
name|_objc_load_callback
argument_list|(
name|class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Call the _objc_load_callback for categories. Don't register the instance      methods as class methods for categories to root classes since they were      already added in the class. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cat_def_cnt
condition|;
name|i
operator|++
control|)
block|{
name|Category_t
name|category
init|=
name|symtab
operator|->
name|defs
index|[
name|i
operator|+
name|symtab
operator|->
name|cls_def_cnt
index|]
decl_stmt|;
name|Class
name|class
init|=
name|objc_lookup_class
argument_list|(
name|category
operator|->
name|class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|_objc_load_callback
condition|)
name|_objc_load_callback
argument_list|(
name|class
argument_list|,
name|category
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sanity check the version of gcc used to compile `module'*/
end_comment

begin_function
specifier|static
name|void
name|init_check_module_version
parameter_list|(
name|Module_t
name|module
parameter_list|)
block|{
if|if
condition|(
operator|(
name|module
operator|->
name|version
operator|!=
name|OBJC_VERSION
operator|)
operator|||
operator|(
name|module
operator|->
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|Module
argument_list|)
operator|)
condition|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
name|module
operator|->
name|version
operator|>
name|OBJC_VERSION
condition|)
name|code
operator|=
name|OBJC_ERR_OBJC_VERSION
expr_stmt|;
elseif|else
if|if
condition|(
name|module
operator|->
name|version
operator|<
name|OBJC_VERSION
condition|)
name|code
operator|=
name|OBJC_ERR_GCC_VERSION
expr_stmt|;
else|else
name|code
operator|=
name|OBJC_ERR_MODULE_SIZE
expr_stmt|;
name|objc_error
argument_list|(
name|nil
argument_list|,
name|code
argument_list|,
literal|"Module %s version %d doesn't match runtime %d\n"
argument_list|,
name|module
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|module
operator|->
name|version
argument_list|,
name|OBJC_VERSION
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_init_protocols
parameter_list|(
name|struct
name|objc_protocol_list
modifier|*
name|protos
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|Class
name|proto_class
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|protos
condition|)
return|return;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proto_class
condition|)
name|proto_class
operator|=
name|objc_lookup_class
argument_list|(
literal|"Protocol"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proto_class
condition|)
block|{
name|unclaimed_proto_list
operator|=
name|list_cons
argument_list|(
name|protos
argument_list|,
name|unclaimed_proto_list
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|assert (protos->next == 0);
comment|/* only single ones allowed */
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|protos
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|objc_protocol
modifier|*
name|aProto
init|=
name|protos
operator|->
name|list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|aProto
operator|->
name|class_pointer
operator|)
operator|==
name|PROTOCOL_VERSION
condition|)
block|{
comment|/* assign class pointer */
name|aProto
operator|->
name|class_pointer
operator|=
name|proto_class
expr_stmt|;
comment|/* init super protocols */
name|__objc_init_protocols
argument_list|(
name|aProto
operator|->
name|protocol_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|protos
operator|->
name|list
index|[
name|i
index|]
operator|->
name|class_pointer
operator|!=
name|proto_class
condition|)
block|{
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_PROTOCOL_VERSION
argument_list|,
literal|"Version %d doesn't match runtime protocol version %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|protos
operator|->
name|list
index|[
name|i
index|]
operator|->
name|class_pointer
operator|-
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
argument_list|,
name|PROTOCOL_VERSION
argument_list|)
expr_stmt|;
block|}
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_class_add_protocols
parameter_list|(
name|Class
name|class
parameter_list|,
name|struct
name|objc_protocol_list
modifier|*
name|protos
parameter_list|)
block|{
comment|/* Well... */
if|if
condition|(
operator|!
name|protos
condition|)
return|return;
comment|/* Add it... */
name|protos
operator|->
name|next
operator|=
name|class
operator|->
name|protocols
expr_stmt|;
name|class
operator|->
name|protocols
operator|=
name|protos
expr_stmt|;
block|}
end_function

end_unit

