begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The implementation of exception handling primitives for Objective-C.    Copyright (C) 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled    with GCC to produce an executable, this does not cause the resulting    executable to be covered by the GNU General Public License.  This    exception does not however invalidate any other reasons why the    executable file might be covered by the GNU General Public License. */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"objc/objc-api.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_include
include|#
directive|include
file|"unwind-pe.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This is the exception class we report -- "GNUCOBJC".  */
end_comment

begin_define
define|#
directive|define
name|__objc_exception_class
define|\
value|((((((((_Unwind_Exception_Class) 'G'		\<< 8 | (_Unwind_Exception_Class) 'N')	\<< 8 | (_Unwind_Exception_Class) 'U')	\<< 8 | (_Unwind_Exception_Class) 'C')	\<< 8 | (_Unwind_Exception_Class) 'O')	\<< 8 | (_Unwind_Exception_Class) 'B')	\<< 8 | (_Unwind_Exception_Class) 'J')	\<< 8 | (_Unwind_Exception_Class) 'C')
end_define

begin_comment
comment|/* This is the object that is passed around by the Objective C runtime    to represent the exception in flight.  */
end_comment

begin_struct
struct|struct
name|ObjcException
block|{
comment|/* This bit is needed in order to interact with the unwind runtime.  */
name|struct
name|_Unwind_Exception
name|base
decl_stmt|;
comment|/* The actual object we want to throw.  */
name|id
name|value
decl_stmt|;
comment|/* Cache some internal unwind data between phase 1 and phase 2.  */
name|_Unwind_Ptr
name|landingPad
decl_stmt|;
name|int
name|handlerSwitchValue
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_struct
struct|struct
name|lsda_header_info
block|{
name|_Unwind_Ptr
name|Start
decl_stmt|;
name|_Unwind_Ptr
name|LPStart
decl_stmt|;
name|_Unwind_Ptr
name|ttype_base
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|TType
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|action_table
decl_stmt|;
name|unsigned
name|char
name|ttype_encoding
decl_stmt|;
name|unsigned
name|char
name|call_site_encoding
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|parse_lsda_header
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|lsda_header_info
modifier|*
name|info
parameter_list|)
block|{
name|_Unwind_Word
name|tmp
decl_stmt|;
name|unsigned
name|char
name|lpstart_encoding
decl_stmt|;
name|info
operator|->
name|Start
operator|=
operator|(
name|context
condition|?
name|_Unwind_GetRegionStart
argument_list|(
name|context
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Find @LPStart, the base to which landing pad offsets are relative.  */
name|lpstart_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|lpstart_encoding
operator|!=
name|DW_EH_PE_omit
condition|)
name|p
operator|=
name|read_encoded_value
argument_list|(
name|context
argument_list|,
name|lpstart_encoding
argument_list|,
name|p
argument_list|,
operator|&
name|info
operator|->
name|LPStart
argument_list|)
expr_stmt|;
else|else
name|info
operator|->
name|LPStart
operator|=
name|info
operator|->
name|Start
expr_stmt|;
comment|/* Find @TType, the base of the handler and exception spec type data.  */
name|info
operator|->
name|ttype_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|ttype_encoding
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|info
operator|->
name|TType
operator|=
name|p
operator|+
name|tmp
expr_stmt|;
block|}
else|else
name|info
operator|->
name|TType
operator|=
literal|0
expr_stmt|;
comment|/* The encoding and length of the call-site table; the action table      immediately follows.  */
name|info
operator|->
name|call_site_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|info
operator|->
name|action_table
operator|=
name|p
operator|+
name|tmp
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|Class
name|get_ttype_entry
parameter_list|(
name|struct
name|lsda_header_info
modifier|*
name|info
parameter_list|,
name|_Unwind_Word
name|i
parameter_list|)
block|{
name|_Unwind_Ptr
name|ptr
decl_stmt|;
name|i
operator|*=
name|size_of_encoded_value
argument_list|(
name|info
operator|->
name|ttype_encoding
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|info
operator|->
name|ttype_encoding
argument_list|,
name|info
operator|->
name|ttype_base
argument_list|,
name|info
operator|->
name|TType
operator|-
name|i
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
comment|/* NULL ptr means catch-all.  */
if|if
condition|(
name|ptr
condition|)
return|return
name|objc_get_class
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ptr
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like unto the method of the same name on Object, but takes an id.  */
end_comment

begin_comment
comment|/* ??? Does this bork the meta-type system?  Can/should we look up an    isKindOf method on the id?  */
end_comment

begin_function
specifier|static
name|int
name|isKindOf
parameter_list|(
name|id
name|value
parameter_list|,
name|Class
name|target
parameter_list|)
block|{
name|Class
name|c
decl_stmt|;
comment|/* NULL target is catch-all.  */
if|if
condition|(
name|target
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|c
operator|=
name|value
operator|->
name|class_pointer
init|;
name|c
condition|;
name|c
operator|=
name|class_get_super_class
argument_list|(
name|c
argument_list|)
control|)
if|if
condition|(
name|c
operator|==
name|target
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Using a different personality function name causes link failures    when trying to mix code using different exception handling models.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SJLJ_EXCEPTIONS
end_ifdef

begin_define
define|#
directive|define
name|PERSONALITY_FUNCTION
value|__gnu_objc_personality_sj0
end_define

begin_define
define|#
directive|define
name|__builtin_eh_return_data_regno
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERSONALITY_FUNCTION
value|__gnu_objc_personality_v0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|_Unwind_Reason_Code
name|PERSONALITY_FUNCTION
parameter_list|(
name|int
name|version
parameter_list|,
name|_Unwind_Action
name|actions
parameter_list|,
name|_Unwind_Exception_Class
name|exception_class
parameter_list|,
name|struct
name|_Unwind_Exception
modifier|*
name|ue_header
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|ObjcException
modifier|*
name|xh
init|=
operator|(
expr|struct
name|ObjcException
operator|*
operator|)
name|ue_header
decl_stmt|;
name|struct
name|lsda_header_info
name|info
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|language_specific_data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|action_record
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|_Unwind_Ptr
name|landing_pad
decl_stmt|,
name|ip
decl_stmt|;
name|int
name|handler_switch_value
decl_stmt|;
name|int
name|saw_cleanup
init|=
literal|0
decl_stmt|,
name|saw_handler
decl_stmt|;
name|void
modifier|*
name|return_object
decl_stmt|;
comment|/* Interface version check.  */
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
return|return
name|_URC_FATAL_PHASE1_ERROR
return|;
comment|/* Shortcut for phase 2 found handler for domestic exception.  */
if|if
condition|(
name|actions
operator|==
operator|(
name|_UA_CLEANUP_PHASE
operator||
name|_UA_HANDLER_FRAME
operator|)
operator|&&
name|exception_class
operator|==
name|__objc_exception_class
condition|)
block|{
name|handler_switch_value
operator|=
name|xh
operator|->
name|handlerSwitchValue
expr_stmt|;
name|landing_pad
operator|=
name|xh
operator|->
name|landingPad
expr_stmt|;
goto|goto
name|install_context
goto|;
block|}
name|language_specific_data
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_Unwind_GetLanguageSpecificData
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* If no LSDA, then there are no handlers or cleanups.  */
if|if
condition|(
operator|!
name|language_specific_data
condition|)
return|return
name|_URC_CONTINUE_UNWIND
return|;
comment|/* Parse the LSDA header.  */
name|p
operator|=
name|parse_lsda_header
argument_list|(
name|context
argument_list|,
name|language_specific_data
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|ttype_base
operator|=
name|base_of_encoded_value
argument_list|(
name|info
operator|.
name|ttype_encoding
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|ip
operator|=
name|_Unwind_GetIP
argument_list|(
name|context
argument_list|)
operator|-
literal|1
expr_stmt|;
name|landing_pad
operator|=
literal|0
expr_stmt|;
name|action_record
operator|=
literal|0
expr_stmt|;
name|handler_switch_value
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SJLJ_EXCEPTIONS
comment|/* The given "IP" is an index into the call-site table, with two      exceptions -- -1 means no-action, and 0 means terminate.  But      since we're using uleb128 values, we've not got random access      to the array.  */
if|if
condition|(
operator|(
name|int
operator|)
name|ip
operator|<
literal|0
condition|)
return|return
name|_URC_CONTINUE_UNWIND
return|;
else|else
block|{
name|_Unwind_Word
name|cs_lp
decl_stmt|,
name|cs_action
decl_stmt|;
do|do
block|{
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|cs_lp
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|cs_action
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ip
condition|)
do|;
comment|/* Can never have null landing pad for sjlj -- that would have          been indicated by a -1 call site index.  */
name|landing_pad
operator|=
name|cs_lp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cs_action
condition|)
name|action_record
operator|=
name|info
operator|.
name|action_table
operator|+
name|cs_action
operator|-
literal|1
expr_stmt|;
goto|goto
name|found_something
goto|;
block|}
else|#
directive|else
comment|/* Search the call-site table for the action associated with this IP.  */
while|while
condition|(
name|p
operator|<
name|info
operator|.
name|action_table
condition|)
block|{
name|_Unwind_Ptr
name|cs_start
decl_stmt|,
name|cs_len
decl_stmt|,
name|cs_lp
decl_stmt|;
name|_Unwind_Word
name|cs_action
decl_stmt|;
comment|/* Note that all call-site encodings are "absolute" displacements.  */
name|p
operator|=
name|read_encoded_value
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|call_site_encoding
argument_list|,
name|p
argument_list|,
operator|&
name|cs_start
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_encoded_value
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|call_site_encoding
argument_list|,
name|p
argument_list|,
operator|&
name|cs_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_encoded_value
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|call_site_encoding
argument_list|,
name|p
argument_list|,
operator|&
name|cs_lp
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|cs_action
argument_list|)
expr_stmt|;
comment|/* The table is sorted, so if we've passed the ip, stop.  */
if|if
condition|(
name|ip
operator|<
name|info
operator|.
name|Start
operator|+
name|cs_start
condition|)
name|p
operator|=
name|info
operator|.
name|action_table
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|<
name|info
operator|.
name|Start
operator|+
name|cs_start
operator|+
name|cs_len
condition|)
block|{
if|if
condition|(
name|cs_lp
condition|)
name|landing_pad
operator|=
name|info
operator|.
name|LPStart
operator|+
name|cs_lp
expr_stmt|;
if|if
condition|(
name|cs_action
condition|)
name|action_record
operator|=
name|info
operator|.
name|action_table
operator|+
name|cs_action
operator|-
literal|1
expr_stmt|;
goto|goto
name|found_something
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* SJLJ_EXCEPTIONS  */
comment|/* If ip is not present in the table, C++ would call terminate.  */
comment|/* ??? As with Java, it's perhaps better to tweek the LSDA to      that no-action is mapped to no-entry.  */
return|return
name|_URC_CONTINUE_UNWIND
return|;
name|found_something
label|:
name|saw_cleanup
operator|=
literal|0
expr_stmt|;
name|saw_handler
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|landing_pad
operator|==
literal|0
condition|)
block|{
comment|/* If ip is present, and has a null landing pad, there are 	 no cleanups or handlers to be run.  */
block|}
elseif|else
if|if
condition|(
name|action_record
operator|==
literal|0
condition|)
block|{
comment|/* If ip is present, has a non-null landing pad, and a null          action table offset, then there are only cleanups present.          Cleanups use a zero switch value, as set above.  */
name|saw_cleanup
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise we have a catch handler.  */
name|_Unwind_Sword
name|ar_filter
decl_stmt|,
name|ar_disp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|action_record
expr_stmt|;
name|p
operator|=
name|read_sleb128
argument_list|(
name|p
argument_list|,
operator|&
name|ar_filter
argument_list|)
expr_stmt|;
name|read_sleb128
argument_list|(
name|p
argument_list|,
operator|&
name|ar_disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar_filter
operator|==
literal|0
condition|)
block|{
comment|/* Zero filter values are cleanups.  */
name|saw_cleanup
operator|=
literal|1
expr_stmt|;
block|}
comment|/* During forced unwinding, we only run cleanups.  With a 	     foreign exception class, we have no class info to match.  */
elseif|else
if|if
condition|(
operator|(
name|actions
operator|&
name|_UA_FORCE_UNWIND
operator|)
operator|||
name|exception_class
operator|!=
name|__objc_exception_class
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ar_filter
operator|>
literal|0
condition|)
block|{
comment|/* Positive filter values are handlers.  */
name|Class
name|catch_type
init|=
name|get_ttype_entry
argument_list|(
operator|&
name|info
argument_list|,
name|ar_filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|isKindOf
argument_list|(
name|xh
operator|->
name|value
argument_list|,
name|catch_type
argument_list|)
condition|)
block|{
name|handler_switch_value
operator|=
name|ar_filter
expr_stmt|;
name|saw_handler
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Negative filter values are exception specifications, 	         which Objective-C does not use.  */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ar_disp
operator|==
literal|0
condition|)
break|break;
name|action_record
operator|=
name|p
operator|+
name|ar_disp
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|saw_handler
operator|&&
operator|!
name|saw_cleanup
condition|)
return|return
name|_URC_CONTINUE_UNWIND
return|;
if|if
condition|(
name|actions
operator|&
name|_UA_SEARCH_PHASE
condition|)
block|{
if|if
condition|(
operator|!
name|saw_handler
condition|)
return|return
name|_URC_CONTINUE_UNWIND
return|;
comment|/* For domestic exceptions, we cache data from phase 1 for phase 2.  */
if|if
condition|(
name|exception_class
operator|==
name|__objc_exception_class
condition|)
block|{
name|xh
operator|->
name|handlerSwitchValue
operator|=
name|handler_switch_value
expr_stmt|;
name|xh
operator|->
name|landingPad
operator|=
name|landing_pad
expr_stmt|;
block|}
return|return
name|_URC_HANDLER_FOUND
return|;
block|}
name|install_context
label|:
if|if
condition|(
name|saw_cleanup
operator|==
literal|0
condition|)
block|{
name|return_object
operator|=
name|xh
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|actions
operator|&
name|_UA_SEARCH_PHASE
operator|)
condition|)
name|_Unwind_DeleteException
argument_list|(
operator|&
name|xh
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|__builtin_eh_return_data_regno
argument_list|(
literal|0
argument_list|)
argument_list|,
name|__builtin_extend_pointer
argument_list|(
name|saw_cleanup
condition|?
name|xh
else|:
name|return_object
argument_list|)
argument_list|)
expr_stmt|;
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|__builtin_eh_return_data_regno
argument_list|(
literal|1
argument_list|)
argument_list|,
name|handler_switch_value
argument_list|)
expr_stmt|;
name|_Unwind_SetIP
argument_list|(
name|context
argument_list|,
name|landing_pad
argument_list|)
expr_stmt|;
return|return
name|_URC_INSTALL_CONTEXT
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|__objc_exception_cleanup
argument_list|(
name|_Unwind_Reason_Code
name|code
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
expr|struct
name|_Unwind_Exception
operator|*
name|exc
argument_list|)
block|{
name|free
argument_list|(
name|exc
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|objc_exception_throw
parameter_list|(
name|id
name|value
parameter_list|)
block|{
name|struct
name|ObjcException
modifier|*
name|header
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|)
decl_stmt|;
name|header
operator|->
name|base
operator|.
name|exception_class
operator|=
name|__objc_exception_class
expr_stmt|;
name|header
operator|->
name|base
operator|.
name|exception_cleanup
operator|=
name|__objc_exception_cleanup
expr_stmt|;
name|header
operator|->
name|value
operator|=
name|value
expr_stmt|;
ifdef|#
directive|ifdef
name|SJLJ_EXCEPTIONS
name|_Unwind_SjLj_RaiseException
argument_list|(
operator|&
name|header
operator|->
name|base
argument_list|)
expr_stmt|;
else|#
directive|else
name|_Unwind_RaiseException
argument_list|(
operator|&
name|header
operator|->
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Some sort of unwinding error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

