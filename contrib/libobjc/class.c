begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime class related functions    Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.    Contributed by Kresten Krab Thorup and Dennis Glatting.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_comment
comment|/* the kitchen sink */
end_comment

begin_include
include|#
directive|include
file|"sarray.h"
end_include

begin_comment
comment|/* The table of classname->class.  Used for objc_lookup_class and friends */
end_comment

begin_decl_stmt
specifier|static
name|cache_ptr
name|__objc_class_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:MUTEX */
end_comment

begin_comment
comment|/* This is a hook which is called by objc_get_class and     objc_lookup_class if the runtime is not able to find the class.    This may e.g. try to load in the class using dynamic loading */
end_comment

begin_function_decl
name|Class
function_decl|(
modifier|*
name|_objc_lookup_class
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_comment
comment|/* !T:SAFE */
end_comment

begin_comment
comment|/* True when class links has been resolved */
end_comment

begin_decl_stmt
name|BOOL
name|__objc_class_links_resolved
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !T:UNUSED */
end_comment

begin_comment
comment|/* Initial number of buckets size of class hash table. */
end_comment

begin_define
define|#
directive|define
name|CLASS_HASH_SIZE
value|32
end_define

begin_function
name|void
name|__objc_init_class_tables
parameter_list|()
block|{
comment|/* Allocate the class hash table */
if|if
condition|(
name|__objc_class_hash
condition|)
return|return;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
name|__objc_class_hash
operator|=
name|hash_new
argument_list|(
name|CLASS_HASH_SIZE
argument_list|,
operator|(
name|hash_func_type
operator|)
name|hash_string
argument_list|,
operator|(
name|compare_func_type
operator|)
name|compare_strings
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function adds a class to the class hash table, and assigns the     class a number, unless it's already known */
end_comment

begin_function
name|void
name|__objc_add_class_to_hash
parameter_list|(
name|Class
name|class
parameter_list|)
block|{
name|Class
name|h_class
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* make sure the table is there */
name|assert
argument_list|(
name|__objc_class_hash
argument_list|)
expr_stmt|;
comment|/* make sure it's not a meta class */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if the class is already in the hash table.  */
name|h_class
operator|=
name|hash_value_for_key
argument_list|(
name|__objc_class_hash
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_class
condition|)
block|{
comment|/* The class isn't in the hash table.  Add the class and assign a class          number.  */
specifier|static
name|unsigned
name|int
name|class_number
init|=
literal|1
decl_stmt|;
name|CLS_SETNUMBER
argument_list|(
name|class
argument_list|,
name|class_number
argument_list|)
expr_stmt|;
name|CLS_SETNUMBER
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|,
name|class_number
argument_list|)
expr_stmt|;
operator|++
name|class_number
expr_stmt|;
name|hash_add
argument_list|(
operator|&
name|__objc_class_hash
argument_list|,
name|class
operator|->
name|name
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the class object for the class named NAME.  If NAME does not    identify a known class, the hook _objc_lookup_class is called.  If    this fails, nil is returned */
end_comment

begin_function
name|Class
name|objc_lookup_class
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Class
name|class
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* Make sure the class hash table exists.  */
name|assert
argument_list|(
name|__objc_class_hash
argument_list|)
expr_stmt|;
name|class
operator|=
name|hash_value_for_key
argument_list|(
name|__objc_class_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
condition|)
return|return
name|class
return|;
if|if
condition|(
name|_objc_lookup_class
condition|)
return|return
call|(
modifier|*
name|_objc_lookup_class
call|)
argument_list|(
name|name
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the class object for the class named NAME.  If NAME does not    identify a known class, the hook _objc_lookup_class is called.  If    this fails,  an error message is issued and the system aborts */
end_comment

begin_function
name|Class
name|objc_get_class
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Class
name|class
decl_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* Make sure the class hash table exists.  */
name|assert
argument_list|(
name|__objc_class_hash
argument_list|)
expr_stmt|;
name|class
operator|=
name|hash_value_for_key
argument_list|(
name|__objc_class_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
condition|)
return|return
name|class
return|;
if|if
condition|(
name|_objc_lookup_class
condition|)
name|class
operator|=
call|(
modifier|*
name|_objc_lookup_class
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
condition|)
return|return
name|class
return|;
name|objc_error
argument_list|(
name|nil
argument_list|,
name|OBJC_ERR_BAD_CLASS
argument_list|,
literal|"objc runtime: cannot find class %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|MetaClass
name|objc_get_meta_class
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|objc_get_class
argument_list|(
name|name
argument_list|)
operator|->
name|class_pointer
return|;
block|}
end_function

begin_comment
comment|/* This function provides a way to enumerate all the classes in the    executable.  Pass *ENUM_STATE == NULL to start the enumeration.  The    function will return 0 when there are no more classes.      For example:         id class;         void *es = NULL;        while ((class = objc_next_class(&es)))          ... do something with class;  */
end_comment

begin_function
name|Class
name|objc_next_class
parameter_list|(
name|void
modifier|*
modifier|*
name|enum_state
parameter_list|)
block|{
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* make sure the table is there */
name|assert
argument_list|(
name|__objc_class_hash
argument_list|)
expr_stmt|;
operator|*
operator|(
name|node_ptr
operator|*
operator|)
name|enum_state
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
operator|*
operator|(
name|node_ptr
operator|*
operator|)
name|enum_state
argument_list|)
expr_stmt|;
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|node_ptr
operator|*
operator|)
name|enum_state
condition|)
return|return
operator|(
operator|*
operator|(
name|node_ptr
operator|*
operator|)
name|enum_state
operator|)
operator|->
name|value
return|;
return|return
operator|(
name|Class
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Resolve super/subclass links for all classes.  The only thing we     can be sure of is that the class_pointer for class objects point     to the right meta class objects */
end_comment

begin_function
name|void
name|__objc_resolve_class_links
parameter_list|()
block|{
name|node_ptr
name|node
decl_stmt|;
name|Class
name|object_class
init|=
name|objc_get_class
argument_list|(
literal|"Object"
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|object_class
argument_list|)
expr_stmt|;
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* Assign subclass links */
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Class
name|class1
init|=
name|node
operator|->
name|value
decl_stmt|;
comment|/* Make sure we have what we think we have.  */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISMETA
argument_list|(
name|class1
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The class_pointer of all meta classes point to Object's meta class. */
name|class1
operator|->
name|class_pointer
operator|->
name|class_pointer
operator|=
name|object_class
operator|->
name|class_pointer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CLS_ISRESOLV
argument_list|(
name|class1
argument_list|)
operator|)
condition|)
block|{
name|CLS_SETRESOLV
argument_list|(
name|class1
argument_list|)
expr_stmt|;
name|CLS_SETRESOLV
argument_list|(
name|class1
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|class1
operator|->
name|super_class
condition|)
block|{
name|Class
name|a_super_class
init|=
name|objc_get_class
argument_list|(
operator|(
name|char
operator|*
operator|)
name|class1
operator|->
name|super_class
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|a_super_class
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"making class connections for: %s\n"
argument_list|,
name|class1
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* assign subclass links for superclass */
name|class1
operator|->
name|sibling_class
operator|=
name|a_super_class
operator|->
name|subclass_list
expr_stmt|;
name|a_super_class
operator|->
name|subclass_list
operator|=
name|class1
expr_stmt|;
comment|/* Assign subclass links for meta class of superclass */
if|if
condition|(
name|a_super_class
operator|->
name|class_pointer
condition|)
block|{
name|class1
operator|->
name|class_pointer
operator|->
name|sibling_class
operator|=
name|a_super_class
operator|->
name|class_pointer
operator|->
name|subclass_list
expr_stmt|;
name|a_super_class
operator|->
name|class_pointer
operator|->
name|subclass_list
operator|=
name|class1
operator|->
name|class_pointer
expr_stmt|;
block|}
block|}
else|else
comment|/* a root class, make its meta object */
comment|/* be a subclass of Object */
block|{
name|class1
operator|->
name|class_pointer
operator|->
name|sibling_class
operator|=
name|object_class
operator|->
name|subclass_list
expr_stmt|;
name|object_class
operator|->
name|subclass_list
operator|=
name|class1
operator|->
name|class_pointer
expr_stmt|;
block|}
block|}
block|}
comment|/* Assign superclass links */
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Class
name|class1
init|=
name|node
operator|->
name|value
decl_stmt|;
name|Class
name|sub_class
decl_stmt|;
for|for
control|(
name|sub_class
operator|=
name|class1
operator|->
name|subclass_list
init|;
name|sub_class
condition|;
name|sub_class
operator|=
name|sub_class
operator|->
name|sibling_class
control|)
block|{
name|sub_class
operator|->
name|super_class
operator|=
name|class1
expr_stmt|;
if|if
condition|(
name|CLS_ISCLASS
argument_list|(
name|sub_class
argument_list|)
condition|)
name|sub_class
operator|->
name|class_pointer
operator|->
name|super_class
operator|=
name|class1
operator|->
name|class_pointer
expr_stmt|;
block|}
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CLASSOF
parameter_list|(
name|c
parameter_list|)
value|((c)->class_pointer)
end_define

begin_function
name|Class
name|class_pose_as
parameter_list|(
name|Class
name|impostor
parameter_list|,
name|Class
name|super_class
parameter_list|)
block|{
name|node_ptr
name|node
decl_stmt|;
name|Class
name|class1
decl_stmt|;
if|if
condition|(
operator|!
name|CLS_ISRESOLV
argument_list|(
name|impostor
argument_list|)
condition|)
name|__objc_resolve_class_links
argument_list|()
expr_stmt|;
comment|/* preconditions */
name|assert
argument_list|(
name|impostor
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|super_class
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|impostor
operator|->
name|super_class
operator|==
name|super_class
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|impostor
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|super_class
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|impostor
operator|->
name|instance_size
operator|==
name|super_class
operator|->
name|instance_size
argument_list|)
expr_stmt|;
block|{
name|Class
modifier|*
name|subclass
init|=
operator|&
operator|(
name|super_class
operator|->
name|subclass_list
operator|)
decl_stmt|;
comment|/* move subclasses of super_class to impostor */
while|while
condition|(
operator|*
name|subclass
condition|)
block|{
name|Class
name|nextSub
init|=
operator|(
operator|*
name|subclass
operator|)
operator|->
name|sibling_class
decl_stmt|;
if|if
condition|(
operator|*
name|subclass
operator|!=
name|impostor
condition|)
block|{
name|Class
name|sub
init|=
operator|*
name|subclass
decl_stmt|;
comment|/* classes */
name|sub
operator|->
name|sibling_class
operator|=
name|impostor
operator|->
name|subclass_list
expr_stmt|;
name|sub
operator|->
name|super_class
operator|=
name|impostor
expr_stmt|;
name|impostor
operator|->
name|subclass_list
operator|=
name|sub
expr_stmt|;
comment|/* It will happen that SUB is not a class object if it is  	       the top of the meta class hierarchy chain.  (root 	       meta-class objects inherit their class object)  If that is 	       the case... don't mess with the meta-meta class. */
if|if
condition|(
name|CLS_ISCLASS
argument_list|(
name|sub
argument_list|)
condition|)
block|{
comment|/* meta classes */
name|CLASSOF
argument_list|(
name|sub
argument_list|)
operator|->
name|sibling_class
operator|=
name|CLASSOF
argument_list|(
name|impostor
argument_list|)
operator|->
name|subclass_list
expr_stmt|;
name|CLASSOF
argument_list|(
name|sub
argument_list|)
operator|->
name|super_class
operator|=
name|CLASSOF
argument_list|(
name|impostor
argument_list|)
expr_stmt|;
name|CLASSOF
argument_list|(
name|impostor
argument_list|)
operator|->
name|subclass_list
operator|=
name|CLASSOF
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|subclass
operator|=
name|nextSub
expr_stmt|;
block|}
comment|/* set subclasses of superclass to be impostor only */
name|super_class
operator|->
name|subclass_list
operator|=
name|impostor
expr_stmt|;
name|CLASSOF
argument_list|(
name|super_class
argument_list|)
operator|->
name|subclass_list
operator|=
name|CLASSOF
argument_list|(
name|impostor
argument_list|)
expr_stmt|;
comment|/* set impostor to have no sibling classes */
name|impostor
operator|->
name|sibling_class
operator|=
literal|0
expr_stmt|;
name|CLASSOF
argument_list|(
name|impostor
argument_list|)
operator|->
name|sibling_class
operator|=
literal|0
expr_stmt|;
block|}
comment|/* check relationship of impostor and super_class is kept. */
name|assert
argument_list|(
name|impostor
operator|->
name|super_class
operator|==
name|super_class
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLASSOF
argument_list|(
name|impostor
argument_list|)
operator|->
name|super_class
operator|==
name|CLASSOF
argument_list|(
name|super_class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is how to update the lookup table. Regardless of      what the keys of the hashtable is, change all values that are      superclass into impostor. */
name|objc_mutex_lock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|node
argument_list|)
control|)
block|{
name|class1
operator|=
operator|(
name|Class
operator|)
name|node
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|class1
operator|==
name|super_class
condition|)
block|{
name|node
operator|->
name|value
operator|=
name|impostor
expr_stmt|;
comment|/* change hash table value */
block|}
block|}
name|objc_mutex_unlock
argument_list|(
name|__objc_runtime_mutex
argument_list|)
expr_stmt|;
comment|/* next, we update the dispatch tables... */
name|__objc_update_dispatch_table_for_class
argument_list|(
name|CLASSOF
argument_list|(
name|impostor
argument_list|)
argument_list|)
expr_stmt|;
name|__objc_update_dispatch_table_for_class
argument_list|(
name|impostor
argument_list|)
expr_stmt|;
return|return
name|impostor
return|;
block|}
end_function

end_unit

