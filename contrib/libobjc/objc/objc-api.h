begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective-C Runtime API.    Copyright (C) 1993, 1995, 1996, 1997, 2002, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled    with GCC to produce an executable, this does not cause the resulting    executable to be covered by the GNU General Public License.  This    exception does not however invalidate any other reasons why the    executable file might be covered by the GNU General Public License. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__objc_api_INCLUDE_GNU
end_ifndef

begin_define
define|#
directive|define
name|__objc_api_INCLUDE_GNU
end_define

begin_include
include|#
directive|include
file|"objc.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"thr.h"
end_include

begin_include
include|#
directive|include
file|"objc-decls.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
comment|/* For functions which return Method_t */
define|#
directive|define
name|METHOD_NULL
value|(Method_t)0
comment|/* Boolean typedefs */
comment|/* ** Method descriptor returned by introspective Object methods. ** This is really just the first part of the more complete objc_method ** structure defined below and used internally by the runtime. */
struct|struct
name|objc_method_description
block|{
name|SEL
name|name
decl_stmt|;
comment|/* this is a selector, not a string */
name|char
modifier|*
name|types
decl_stmt|;
comment|/* type encoding */
block|}
struct|;
comment|/* Filer types used to describe Ivars and Methods.  */
define|#
directive|define
name|_C_ID
value|'@'
define|#
directive|define
name|_C_CLASS
value|'#'
define|#
directive|define
name|_C_SEL
value|':'
define|#
directive|define
name|_C_CHR
value|'c'
define|#
directive|define
name|_C_UCHR
value|'C'
define|#
directive|define
name|_C_SHT
value|'s'
define|#
directive|define
name|_C_USHT
value|'S'
define|#
directive|define
name|_C_INT
value|'i'
define|#
directive|define
name|_C_UINT
value|'I'
define|#
directive|define
name|_C_LNG
value|'l'
define|#
directive|define
name|_C_ULNG
value|'L'
define|#
directive|define
name|_C_LNG_LNG
value|'q'
define|#
directive|define
name|_C_ULNG_LNG
value|'Q'
define|#
directive|define
name|_C_FLT
value|'f'
define|#
directive|define
name|_C_DBL
value|'d'
define|#
directive|define
name|_C_BFLD
value|'b'
define|#
directive|define
name|_C_BOOL
value|'B'
define|#
directive|define
name|_C_VOID
value|'v'
define|#
directive|define
name|_C_UNDEF
value|'?'
define|#
directive|define
name|_C_PTR
value|'^'
define|#
directive|define
name|_C_CHARPTR
value|'*'
define|#
directive|define
name|_C_ATOM
value|'%'
define|#
directive|define
name|_C_ARY_B
value|'['
define|#
directive|define
name|_C_ARY_E
value|']'
define|#
directive|define
name|_C_UNION_B
value|'('
define|#
directive|define
name|_C_UNION_E
value|')'
define|#
directive|define
name|_C_STRUCT_B
value|'{'
define|#
directive|define
name|_C_STRUCT_E
value|'}'
define|#
directive|define
name|_C_VECTOR
value|'!'
define|#
directive|define
name|_C_COMPLEX
value|'j'
comment|/* ** Error handling ** ** Call objc_error() or objc_verror() to record an error; this error ** routine will generally exit the program but not necessarily if the ** user has installed his own error handler. ** ** Call objc_set_error_handler to assign your own function for ** handling errors.  The function should return YES if it is ok ** to continue execution, or return NO or just abort if the ** program should be stopped.  The default error handler is just to ** print a message on stderr. ** ** The error handler function should be of type objc_error_handler ** The first parameter is an object instance of relevance. ** The second parameter is an error code. ** The third parameter is a format string in the printf style. ** The fourth parameter is a variable list of arguments. */
specifier|extern
name|void
name|objc_error
parameter_list|(
name|id
name|object
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
specifier|extern
name|void
name|objc_verror
parameter_list|(
name|id
name|object
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|;
typedef|typedef
name|BOOL
function_decl|(
modifier|*
name|objc_error_handler
function_decl|)
parameter_list|(
name|id
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|;
specifier|extern
name|objc_error_handler
name|objc_set_error_handler
parameter_list|(
name|objc_error_handler
name|func
parameter_list|)
function_decl|;
comment|/* ** Error codes ** These are used by the runtime library, and your ** error handling may use them to determine if the error is ** hard or soft thus whether execution can continue or abort. */
define|#
directive|define
name|OBJC_ERR_UNKNOWN
value|0
comment|/* Generic error */
define|#
directive|define
name|OBJC_ERR_OBJC_VERSION
value|1
comment|/* Incorrect runtime version */
define|#
directive|define
name|OBJC_ERR_GCC_VERSION
value|2
comment|/* Incorrect compiler version */
define|#
directive|define
name|OBJC_ERR_MODULE_SIZE
value|3
comment|/* Bad module size */
define|#
directive|define
name|OBJC_ERR_PROTOCOL_VERSION
value|4
comment|/* Incorrect protocol version */
define|#
directive|define
name|OBJC_ERR_MEMORY
value|10
comment|/* Out of memory */
define|#
directive|define
name|OBJC_ERR_RECURSE_ROOT
value|20
comment|/* Attempt to archive the root 					  object more than once. */
define|#
directive|define
name|OBJC_ERR_BAD_DATA
value|21
comment|/* Didn't read expected data */
define|#
directive|define
name|OBJC_ERR_BAD_KEY
value|22
comment|/* Bad key for object */
define|#
directive|define
name|OBJC_ERR_BAD_CLASS
value|23
comment|/* Unknown class */
define|#
directive|define
name|OBJC_ERR_BAD_TYPE
value|24
comment|/* Bad type specification */
define|#
directive|define
name|OBJC_ERR_NO_READ
value|25
comment|/* Cannot read stream */
define|#
directive|define
name|OBJC_ERR_NO_WRITE
value|26
comment|/* Cannot write stream */
define|#
directive|define
name|OBJC_ERR_STREAM_VERSION
value|27
comment|/* Incorrect stream version */
define|#
directive|define
name|OBJC_ERR_BAD_OPCODE
value|28
comment|/* Bad opcode */
define|#
directive|define
name|OBJC_ERR_UNIMPLEMENTED
value|30
comment|/* Method is not implemented */
define|#
directive|define
name|OBJC_ERR_BAD_STATE
value|40
comment|/* Bad thread state */
comment|/* ** Set this variable nonzero to print a line describing each ** message that is sent.  (this is currently disabled) */
specifier|extern
name|BOOL
name|objc_trace
decl_stmt|;
comment|/* For every class which happens to have statically allocated instances in    this module, one OBJC_STATIC_INSTANCES is allocated by the compiler.    INSTANCES is NULL terminated and points to all statically allocated    instances of this class.  */
struct|struct
name|objc_static_instances
block|{
name|char
modifier|*
name|class_name
decl_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
name|id
name|instances
index|[
literal|1
index|]
decl_stmt|;
else|#
directive|else
name|id
name|instances
index|[
literal|0
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
comment|/* ** Whereas a Module (defined further down) is the root (typically) of a file, ** a Symtab is the root of the class and category definitions within the ** module.   **  ** A Symtab contains a variable length array of pointers to classes and ** categories  defined in the module.  */
typedef|typedef
struct|struct
name|objc_symtab
block|{
name|unsigned
name|long
name|sel_ref_cnt
decl_stmt|;
comment|/* Unknown. */
name|SEL
name|refs
decl_stmt|;
comment|/* Unknown. */
name|unsigned
name|short
name|cls_def_cnt
decl_stmt|;
comment|/* Number of classes compiled                                                   (defined) in the module. */
name|unsigned
name|short
name|cat_def_cnt
decl_stmt|;
comment|/* Number of categories                                                    compiled (defined) in the                                                    module. */
name|void
modifier|*
name|defs
index|[
literal|1
index|]
decl_stmt|;
comment|/* Variable array of pointers.                                                   cls_def_cnt of type Class                                                    followed by cat_def_cnt of                                                   type Category_t, followed 						  by a NULL terminated array 						  of objc_static_instances. */
block|}
name|Symtab
operator|,
typedef|*
name|Symtab_t
typedef|;
comment|/* ** The compiler generates one of these structures for each module that ** composes the executable (eg main.m).   **  ** This data structure is the root of the definition tree for the module.   **  ** A collect program runs between ld stages and creates a ObjC ctor array.  ** That array holds a pointer to each module structure of the executable.  */
typedef|typedef
struct|struct
name|objc_module
block|{
name|unsigned
name|long
name|version
decl_stmt|;
comment|/* Compiler revision. */
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* sizeof(Module). */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of the file where the                                                    module was generated.   The                                                    name includes the path. */
name|Symtab_t
name|symtab
decl_stmt|;
comment|/* Pointer to the Symtab of                                                   the module.  The Symtab                                                   holds an array of  						  pointers to                                                    the classes and categories                                                    defined in the module. */
block|}
name|Module
operator|,
typedef|*
name|Module_t
typedef|;
comment|/* ** The compiler generates one of these structures for a class that has ** instance variables defined in its specification.  */
typedef|typedef
struct|struct
name|objc_ivar
block|{
specifier|const
name|char
modifier|*
name|ivar_name
decl_stmt|;
comment|/* Name of the instance                                                   variable as entered in the                                                   class definition. */
specifier|const
name|char
modifier|*
name|ivar_type
decl_stmt|;
comment|/* Description of the Ivar's                                                   type.  Useful for                                                    debuggers. */
name|int
name|ivar_offset
decl_stmt|;
comment|/* Byte offset from the base                                                    address of the instance                                                    structure to the variable. */
block|}
typedef|*
name|Ivar_t
typedef|;
typedef|typedef
struct|struct
name|objc_ivar_list
block|{
name|int
name|ivar_count
decl_stmt|;
comment|/* Number of structures (Ivar)                                                    contained in the list.  One                                                   structure per instance                                                    variable defined in the                                                   class. */
name|struct
name|objc_ivar
name|ivar_list
index|[
literal|1
index|]
decl_stmt|;
comment|/* Variable length                                                    structure. */
block|}
name|IvarList
operator|,
typedef|*
name|IvarList_t
typedef|;
comment|/* ** The compiler generates one (or more) of these structures for a class that ** has methods defined in its specification.  **  ** The implementation of a class can be broken into separate pieces in a file ** and categories can break them across modules. To handle this problem is a ** singly linked list of methods.  */
typedef|typedef
struct|struct
name|objc_method
block|{
name|SEL
name|method_name
decl_stmt|;
comment|/* This variable is the method's                                                 name.  It is a char*.                                                 The unique integer passed to                                                 objc_msg_send is a char* too.                                                  It is compared against                                                 method_name using strcmp. */
specifier|const
name|char
modifier|*
name|method_types
decl_stmt|;
comment|/* Description of the method's                                                parameter list.  Useful for                                                debuggers. */
name|IMP
name|method_imp
decl_stmt|;
comment|/* Address of the method in the                                                 executable. */
block|}
name|Method
operator|,
typedef|*
name|Method_t
typedef|;
typedef|typedef
struct|struct
name|objc_method_list
block|{
name|struct
name|objc_method_list
modifier|*
name|method_next
decl_stmt|;
comment|/* This variable is used to link                                                 a method list to another.  It                                                 is a singly linked list. */
name|int
name|method_count
decl_stmt|;
comment|/* Number of methods defined in                                                 this structure. */
name|Method
name|method_list
index|[
literal|1
index|]
decl_stmt|;
comment|/* Variable length                                                 structure. */
block|}
name|MethodList
operator|,
typedef|*
name|MethodList_t
typedef|;
struct|struct
name|objc_protocol_list
block|{
name|struct
name|objc_protocol_list
modifier|*
name|next
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|Protocol
modifier|*
name|list
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
comment|/* ** This is used to assure consistent access to the info field of  ** classes */
ifndef|#
directive|ifndef
name|HOST_BITS_PER_LONG
define|#
directive|define
name|HOST_BITS_PER_LONG
value|(sizeof(long)*8)
endif|#
directive|endif
define|#
directive|define
name|__CLS_INFO
parameter_list|(
name|cls
parameter_list|)
value|((cls)->info)
define|#
directive|define
name|__CLS_ISINFO
parameter_list|(
name|cls
parameter_list|,
name|mask
parameter_list|)
value|((__CLS_INFO(cls)&mask)==mask)
define|#
directive|define
name|__CLS_SETINFO
parameter_list|(
name|cls
parameter_list|,
name|mask
parameter_list|)
value|(__CLS_INFO(cls) |= mask)
comment|/* The structure is of type MetaClass */
define|#
directive|define
name|_CLS_META
value|0x2L
define|#
directive|define
name|CLS_ISMETA
parameter_list|(
name|cls
parameter_list|)
value|((cls)&&__CLS_ISINFO(cls, _CLS_META))
comment|/* The structure is of type Class */
define|#
directive|define
name|_CLS_CLASS
value|0x1L
define|#
directive|define
name|CLS_ISCLASS
parameter_list|(
name|cls
parameter_list|)
value|((cls)&&__CLS_ISINFO(cls, _CLS_CLASS))
comment|/* ** The class is initialized within the runtime.  This means that  ** it has had correct super and sublinks assigned */
define|#
directive|define
name|_CLS_RESOLV
value|0x8L
define|#
directive|define
name|CLS_ISRESOLV
parameter_list|(
name|cls
parameter_list|)
value|__CLS_ISINFO(cls, _CLS_RESOLV)
define|#
directive|define
name|CLS_SETRESOLV
parameter_list|(
name|cls
parameter_list|)
value|__CLS_SETINFO(cls, _CLS_RESOLV)
comment|/* ** The class has been send a +initialize message or a such is not  ** defined for this class */
define|#
directive|define
name|_CLS_INITIALIZED
value|0x04L
define|#
directive|define
name|CLS_ISINITIALIZED
parameter_list|(
name|cls
parameter_list|)
value|__CLS_ISINFO(cls, _CLS_INITIALIZED)
define|#
directive|define
name|CLS_SETINITIALIZED
parameter_list|(
name|cls
parameter_list|)
value|__CLS_SETINFO(cls, _CLS_INITIALIZED)
comment|/* ** The class number of this class.  This must be the same for both the  ** class and its meta class object */
define|#
directive|define
name|CLS_GETNUMBER
parameter_list|(
name|cls
parameter_list|)
value|(__CLS_INFO(cls)>> (HOST_BITS_PER_LONG/2))
define|#
directive|define
name|CLS_SETNUMBER
parameter_list|(
name|cls
parameter_list|,
name|num
parameter_list|)
define|\
value|({ (cls)->info<<= (HOST_BITS_PER_LONG/2); \      (cls)->info>>= (HOST_BITS_PER_LONG/2); \      __CLS_SETINFO(cls, (((unsigned long)num)<< (HOST_BITS_PER_LONG/2))); })
comment|/* ** The compiler generates one of these structures for each category.  A class ** may have many categories and contain both instance and factory methods.   */
typedef|typedef
struct|struct
name|objc_category
block|{
specifier|const
name|char
modifier|*
name|category_name
decl_stmt|;
comment|/* Name of the category.  Name                                                 contained in the () of the                                                 category definition. */
specifier|const
name|char
modifier|*
name|class_name
decl_stmt|;
comment|/* Name of the class to which                                                 the category belongs. */
name|MethodList_t
name|instance_methods
decl_stmt|;
comment|/* Linked list of instance                                                 methods defined in the                                                  category. NULL indicates no                                                 instance methods defined. */
name|MethodList_t
name|class_methods
decl_stmt|;
comment|/* Linked list of factory                                                  methods defined in the                                                 category.  NULL indicates no                                                 class methods defined. */
name|struct
name|objc_protocol_list
modifier|*
name|protocols
decl_stmt|;
comment|/* List of Protocols  					         conformed to */
block|}
name|Category
operator|,
typedef|*
name|Category_t
typedef|;
comment|/* ** Structure used when a message is send to a class's super class.  The ** compiler generates one of these structures and passes it to ** objc_msg_super. */
typedef|typedef
struct|struct
name|objc_super
block|{
name|id
name|self
decl_stmt|;
comment|/* Id of the object sending                                                 the message. */
ifdef|#
directive|ifdef
name|__cplusplus
name|Class
name|super_class
decl_stmt|;
else|#
directive|else
name|Class
name|class
decl_stmt|;
comment|/* Object's super class. */
endif|#
directive|endif
block|}
name|Super
operator|,
typedef|*
name|Super_t
typedef|;
name|IMP
name|objc_msg_lookup_super
parameter_list|(
name|Super_t
name|super
parameter_list|,
name|SEL
name|sel
parameter_list|)
function_decl|;
name|retval_t
name|objc_msg_sendv
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
name|arglist_t
parameter_list|)
function_decl|;
comment|/* ** This is a hook which is called by objc_lookup_class and ** objc_get_class if the runtime is not able to find the class. ** This may e.g. try to load in the class using dynamic loading. ** The function is guaranteed to be passed a non-NULL name string. */
name|objc_EXPORT
name|Class
function_decl|(
modifier|*
name|_objc_lookup_class
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* ** This is a hook which is called by __objc_exec_class every time a class ** or a category is loaded into the runtime.  This may e.g. help a ** dynamic loader determine the classes that have been loaded when ** an object file is dynamically linked in. */
name|objc_EXPORT
name|void
function_decl|(
modifier|*
name|_objc_load_callback
function_decl|)
parameter_list|(
name|Class
name|_class
parameter_list|,
name|Category
modifier|*
name|category
parameter_list|)
function_decl|;
comment|/* ** Hook functions for allocating, copying and disposing of instances */
name|objc_EXPORT
name|id
function_decl|(
modifier|*
name|_objc_object_alloc
function_decl|)
parameter_list|(
name|Class
name|_class
parameter_list|)
function_decl|;
name|objc_EXPORT
name|id
function_decl|(
modifier|*
name|_objc_object_copy
function_decl|)
parameter_list|(
name|id
name|object
parameter_list|)
function_decl|;
name|objc_EXPORT
name|id
function_decl|(
modifier|*
name|_objc_object_dispose
function_decl|)
parameter_list|(
name|id
name|object
parameter_list|)
function_decl|;
comment|/* ** Standard functions for memory allocation and disposal. ** Users should use these functions in their ObjC programs so ** that they work properly with garbage collectors as well as ** can take advantage of the exception/error handling available. */
name|void
modifier|*
name|objc_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|objc_atomic_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|objc_valloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|objc_realloc
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|objc_calloc
parameter_list|(
name|size_t
name|nelem
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|objc_free
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
function_decl|;
comment|/* ** Hook functions for memory allocation and disposal. ** This makes it easy to substitute garbage collection systems ** such as Boehm's GC by assigning these function pointers ** to the GC's allocation routines.  By default these point ** to the ANSI standard malloc, realloc, free, etc. ** ** Users should call the normal objc routines above for ** memory allocation and disposal within their programs. */
name|objc_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|_objc_malloc
function_decl|)
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
name|objc_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|_objc_atomic_malloc
function_decl|)
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
name|objc_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|_objc_valloc
function_decl|)
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
name|objc_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|_objc_realloc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|objc_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|_objc_calloc
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|objc_EXPORT
name|void
function_decl|(
modifier|*
name|_objc_free
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* **  Hook for method forwarding. This makes it easy to substitute a **  library, such as ffcall, that implements closures, thereby avoiding **  gcc's __builtin_apply problems. */
name|objc_EXPORT
name|IMP
function_decl|(
modifier|*
name|__objc_msg_forward
function_decl|)
parameter_list|(
name|SEL
parameter_list|)
function_decl|;
name|Method_t
name|class_get_class_method
parameter_list|(
name|MetaClass
name|_class
parameter_list|,
name|SEL
name|aSel
parameter_list|)
function_decl|;
name|Method_t
name|class_get_instance_method
parameter_list|(
name|Class
name|_class
parameter_list|,
name|SEL
name|aSel
parameter_list|)
function_decl|;
name|Class
name|class_pose_as
parameter_list|(
name|Class
name|impostor
parameter_list|,
name|Class
name|superclass
parameter_list|)
function_decl|;
name|Class
name|objc_get_class
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|Class
name|objc_lookup_class
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|Class
name|objc_next_class
parameter_list|(
name|void
modifier|*
modifier|*
name|enum_state
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|sel_get_name
parameter_list|(
name|SEL
name|selector
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|sel_get_type
parameter_list|(
name|SEL
name|selector
parameter_list|)
function_decl|;
name|SEL
name|sel_get_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|SEL
name|sel_get_any_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|SEL
name|sel_get_any_typed_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|SEL
name|sel_get_typed_uid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|SEL
name|sel_register_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|SEL
name|sel_register_typed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
function_decl|;
name|BOOL
name|sel_is_mapped
parameter_list|(
name|SEL
name|aSel
parameter_list|)
function_decl|;
specifier|extern
name|id
name|class_create_instance
parameter_list|(
name|Class
name|_class
parameter_list|)
function_decl|;
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|class_get_class_name
parameter_list|(
name|Class
name|_class
parameter_list|)
block|{
return|return
name|CLS_ISCLASS
argument_list|(
name|_class
argument_list|)
condition|?
name|_class
operator|->
name|name
else|:
operator|(
operator|(
name|_class
operator|==
name|Nil
operator|)
condition|?
literal|"Nil"
else|:
literal|0
operator|)
return|;
block|}
specifier|static
specifier|inline
name|long
name|class_get_instance_size
parameter_list|(
name|Class
name|_class
parameter_list|)
block|{
return|return
name|CLS_ISCLASS
argument_list|(
name|_class
argument_list|)
condition|?
name|_class
operator|->
name|instance_size
else|:
literal|0
return|;
block|}
specifier|static
specifier|inline
name|MetaClass
name|class_get_meta_class
parameter_list|(
name|Class
name|_class
parameter_list|)
block|{
return|return
name|CLS_ISCLASS
argument_list|(
name|_class
argument_list|)
condition|?
name|_class
operator|->
name|class_pointer
else|:
name|Nil
return|;
block|}
specifier|static
specifier|inline
name|Class
name|class_get_super_class
parameter_list|(
name|Class
name|_class
parameter_list|)
block|{
return|return
name|CLS_ISCLASS
argument_list|(
name|_class
argument_list|)
condition|?
name|_class
operator|->
name|super_class
else|:
name|Nil
return|;
block|}
specifier|static
specifier|inline
name|int
name|class_get_version
parameter_list|(
name|Class
name|_class
parameter_list|)
block|{
return|return
name|CLS_ISCLASS
argument_list|(
name|_class
argument_list|)
condition|?
name|_class
operator|->
name|version
else|:
operator|-
literal|1
return|;
block|}
specifier|static
specifier|inline
name|BOOL
name|class_is_class
parameter_list|(
name|Class
name|_class
parameter_list|)
block|{
return|return
name|CLS_ISCLASS
argument_list|(
name|_class
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|BOOL
name|class_is_meta_class
parameter_list|(
name|Class
name|_class
parameter_list|)
block|{
return|return
name|CLS_ISMETA
argument_list|(
name|_class
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|void
name|class_set_version
parameter_list|(
name|Class
name|_class
parameter_list|,
name|long
name|version
parameter_list|)
block|{
if|if
condition|(
name|CLS_ISCLASS
argument_list|(
name|_class
argument_list|)
condition|)
name|_class
operator|->
name|version
operator|=
name|version
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
modifier|*
name|class_get_gc_object_type
parameter_list|(
name|Class
name|_class
parameter_list|)
block|{
return|return
name|CLS_ISCLASS
argument_list|(
name|_class
argument_list|)
condition|?
name|_class
operator|->
name|gc_object_type
else|:
name|NULL
return|;
block|}
comment|/* Mark the instance variable as innaccessible to the garbage collector */
specifier|extern
name|void
name|class_ivar_set_gcinvisible
parameter_list|(
name|Class
name|_class
parameter_list|,
specifier|const
name|char
modifier|*
name|ivarname
parameter_list|,
name|BOOL
name|gcInvisible
parameter_list|)
function_decl|;
specifier|static
specifier|inline
name|IMP
name|method_get_imp
parameter_list|(
name|Method_t
name|method
parameter_list|)
block|{
return|return
operator|(
name|method
operator|!=
name|METHOD_NULL
operator|)
condition|?
name|method
operator|->
name|method_imp
else|:
operator|(
name|IMP
operator|)
literal|0
return|;
block|}
name|IMP
name|get_imp
parameter_list|(
name|Class
name|_class
parameter_list|,
name|SEL
name|sel
parameter_list|)
function_decl|;
comment|/* Redefine on NeXTSTEP so as not to conflict with system function */
ifdef|#
directive|ifdef
name|__NeXT__
define|#
directive|define
name|object_copy
value|gnu_object_copy
define|#
directive|define
name|object_dispose
value|gnu_object_dispose
endif|#
directive|endif
name|id
name|object_copy
parameter_list|(
name|id
name|object
parameter_list|)
function_decl|;
name|id
name|object_dispose
parameter_list|(
name|id
name|object
parameter_list|)
function_decl|;
specifier|static
specifier|inline
name|Class
name|object_get_class
parameter_list|(
name|id
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
name|object
operator|!=
name|nil
operator|)
condition|?
operator|(
name|CLS_ISCLASS
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
name|object
operator|->
name|class_pointer
else|:
operator|(
name|CLS_ISMETA
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
operator|(
name|Class
operator|)
name|object
else|:
name|Nil
operator|)
operator|)
else|:
name|Nil
operator|)
return|;
block|}
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|object_get_class_name
parameter_list|(
name|id
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
name|object
operator|!=
name|nil
operator|)
condition|?
operator|(
name|CLS_ISCLASS
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
name|object
operator|->
name|class_pointer
operator|->
name|name
else|:
operator|(
operator|(
name|Class
operator|)
name|object
operator|)
operator|->
name|name
operator|)
else|:
literal|"Nil"
operator|)
return|;
block|}
specifier|static
specifier|inline
name|MetaClass
name|object_get_meta_class
parameter_list|(
name|id
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
name|object
operator|!=
name|nil
operator|)
condition|?
operator|(
name|CLS_ISCLASS
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
name|object
operator|->
name|class_pointer
operator|->
name|class_pointer
else|:
operator|(
name|CLS_ISMETA
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
name|object
operator|->
name|class_pointer
else|:
name|Nil
operator|)
operator|)
else|:
name|Nil
operator|)
return|;
block|}
specifier|static
specifier|inline
name|Class
name|object_get_super_class
parameter_list|(
name|id
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
name|object
operator|!=
name|nil
operator|)
condition|?
operator|(
name|CLS_ISCLASS
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
name|object
operator|->
name|class_pointer
operator|->
name|super_class
else|:
operator|(
name|CLS_ISMETA
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
operator|(
operator|(
name|Class
operator|)
name|object
operator|)
operator|->
name|super_class
else|:
name|Nil
operator|)
operator|)
else|:
name|Nil
operator|)
return|;
block|}
specifier|static
specifier|inline
name|BOOL
name|object_is_class
parameter_list|(
name|id
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
name|object
operator|!=
name|nil
operator|)
operator|&&
name|CLS_ISMETA
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
operator|)
return|;
block|}
specifier|static
specifier|inline
name|BOOL
name|object_is_instance
parameter_list|(
name|id
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
name|object
operator|!=
name|nil
operator|)
operator|&&
name|CLS_ISCLASS
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
operator|)
return|;
block|}
specifier|static
specifier|inline
name|BOOL
name|object_is_meta_class
parameter_list|(
name|id
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
name|object
operator|!=
name|nil
operator|)
operator|&&
operator|!
name|object_is_instance
argument_list|(
name|object
argument_list|)
operator|&&
operator|!
name|object_is_class
argument_list|(
name|object
argument_list|)
operator|)
return|;
block|}
name|struct
name|sarray
modifier|*
name|objc_get_uninstalled_dtable
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __cplusplus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __objc_api_INCLUDE_GNU */
end_comment

end_unit

