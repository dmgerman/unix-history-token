begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.    This file is part of the GNU IO Library.    Written by Per Bothner<bothner@cygnus.com>.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_if
if|#
directive|if
name|_IO_HAVE_SYS_WAIT
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_fork
end_ifndef

begin_define
define|#
directive|define
name|_IO_fork
value|vfork
end_define

begin_comment
comment|/* defined in libiberty, if needed */
end_comment

begin_decl_stmt
specifier|extern
name|_IO_pid_t
name|_IO_fork
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _IO_HAVE_SYS_WAIT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_pipe
end_ifndef

begin_define
define|#
directive|define
name|_IO_pipe
value|pipe
end_define

begin_decl_stmt
specifier|extern
name|int
name|_IO_pipe
name|__P
argument_list|(
operator|(
name|int
name|des
index|[
literal|2
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_dup2
end_ifndef

begin_define
define|#
directive|define
name|_IO_dup2
value|dup2
end_define

begin_decl_stmt
specifier|extern
name|int
name|_IO_dup2
name|__P
argument_list|(
operator|(
name|int
name|fd
operator|,
name|int
name|fd2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_waitpid
end_ifndef

begin_define
define|#
directive|define
name|_IO_waitpid
value|waitpid
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_execl
end_ifndef

begin_define
define|#
directive|define
name|_IO_execl
value|execl
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IO__exit
end_ifndef

begin_define
define|#
directive|define
name|_IO__exit
value|_exit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_close
end_ifndef

begin_define
define|#
directive|define
name|_IO_close
value|close
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|_IO_proc_file
block|{
name|struct
name|_IO_FILE_plus
name|file
decl_stmt|;
comment|/* Following fields must match those in class procbuf (procbuf.h) */
name|_IO_pid_t
name|pid
decl_stmt|;
name|struct
name|_IO_proc_file
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|_IO_proc_file
name|_IO_proc_file
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|_IO_proc_file
modifier|*
name|proc_file_chain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|_IO_FILE
modifier|*
name|_IO_proc_open
parameter_list|(
name|fp
parameter_list|,
name|command
parameter_list|,
name|mode
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|command
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
if|#
directive|if
name|_IO_HAVE_SYS_WAIT
specifier|volatile
name|int
name|read_or_write
decl_stmt|;
specifier|volatile
name|int
name|parent_end
decl_stmt|,
name|child_end
decl_stmt|;
name|int
name|pipe_fds
index|[
literal|2
index|]
decl_stmt|;
name|_IO_pid_t
name|child_pid
decl_stmt|;
if|if
condition|(
name|_IO_file_is_open
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|_IO_pipe
argument_list|(
name|pipe_fds
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
block|{
name|parent_end
operator|=
name|pipe_fds
index|[
literal|0
index|]
expr_stmt|;
name|child_end
operator|=
name|pipe_fds
index|[
literal|1
index|]
expr_stmt|;
name|read_or_write
operator|=
name|_IO_NO_WRITES
expr_stmt|;
block|}
else|else
block|{
name|parent_end
operator|=
name|pipe_fds
index|[
literal|1
index|]
expr_stmt|;
name|child_end
operator|=
name|pipe_fds
index|[
literal|0
index|]
expr_stmt|;
name|read_or_write
operator|=
name|_IO_NO_READS
expr_stmt|;
block|}
operator|(
operator|(
name|_IO_proc_file
operator|*
operator|)
name|fp
operator|)
operator|->
name|pid
operator|=
name|child_pid
operator|=
name|_IO_fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|child_pid
operator|==
literal|0
condition|)
block|{
name|int
name|child_std_end
init|=
name|mode
index|[
literal|0
index|]
operator|==
literal|'r'
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|_IO_close
argument_list|(
name|parent_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_end
operator|!=
name|child_std_end
condition|)
block|{
name|_IO_dup2
argument_list|(
name|child_end
argument_list|,
name|child_std_end
argument_list|)
expr_stmt|;
name|_IO_close
argument_list|(
name|child_end
argument_list|)
expr_stmt|;
block|}
comment|/* POSIX.2:  "popen() shall ensure that any streams from previous          popen() calls that remain open in the parent process are closed 	 in the new child process." */
while|while
condition|(
name|proc_file_chain
condition|)
block|{
name|_IO_close
argument_list|(
name|_IO_fileno
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|proc_file_chain
argument_list|)
argument_list|)
expr_stmt|;
name|proc_file_chain
operator|=
name|proc_file_chain
operator|->
name|next
expr_stmt|;
block|}
name|_IO_execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|command
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|_IO__exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|_IO_close
argument_list|(
name|child_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_pid
operator|<
literal|0
condition|)
block|{
name|_IO_close
argument_list|(
name|parent_end
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|_IO_fileno
argument_list|(
name|fp
argument_list|)
operator|=
name|parent_end
expr_stmt|;
comment|/* Link into proc_file_chain. */
operator|(
operator|(
name|_IO_proc_file
operator|*
operator|)
name|fp
operator|)
operator|->
name|next
operator|=
name|proc_file_chain
expr_stmt|;
name|proc_file_chain
operator|=
operator|(
name|_IO_proc_file
operator|*
operator|)
name|fp
expr_stmt|;
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
name|read_or_write
argument_list|,
name|_IO_NO_READS
operator||
name|_IO_NO_WRITES
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
else|#
directive|else
comment|/* !_IO_HAVE_SYS_WAIT */
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|_IO_FILE
modifier|*
name|_IO_popen
parameter_list|(
name|command
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|command
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
struct|struct
name|locked_FILE
block|{
name|struct
name|_IO_proc_file
name|fpx
decl_stmt|;
ifdef|#
directive|ifdef
name|_IO_MTSAFE_IO
name|_IO_lock_t
name|lock
decl_stmt|;
endif|#
directive|endif
block|}
modifier|*
name|new_f
struct|;
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|new_f
operator|=
operator|(
expr|struct
name|locked_FILE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|locked_FILE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_f
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|_IO_MTSAFE_IO
name|new_f
operator|->
name|fpx
operator|.
name|file
operator|.
name|file
operator|.
name|_lock
operator|=
operator|&
name|new_f
operator|->
name|lock
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
operator|(
name|_IO_FILE
operator|*
operator|)
operator|&
name|new_f
operator|->
name|fpx
expr_stmt|;
name|_IO_init
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_IO_JUMPS
argument_list|(
name|fp
argument_list|)
operator|=
operator|&
name|_IO_proc_jumps
expr_stmt|;
name|_IO_file_init
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|_IO_UNIFIED_JUMPTABLES
operator|(
operator|(
expr|struct
name|_IO_FILE_plus
operator|*
operator|)
name|fp
operator|)
operator|->
name|vtable
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|_IO_proc_open
argument_list|(
name|fp
argument_list|,
name|command
argument_list|,
name|mode
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
name|free
argument_list|(
name|new_f
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|strong_alias
end_ifdef

begin_expr_stmt
name|strong_alias
argument_list|(
name|_IO_popen
argument_list|,
name|popen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|_IO_proc_close
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
comment|/* This is not name-space clean. FIXME! */
if|#
directive|if
name|_IO_HAVE_SYS_WAIT
name|int
name|wstatus
decl_stmt|;
name|_IO_proc_file
modifier|*
modifier|*
name|ptr
init|=
operator|&
name|proc_file_chain
decl_stmt|;
name|_IO_pid_t
name|wait_pid
decl_stmt|;
name|int
name|status
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Unlink from proc_file_chain. */
for|for
control|(
init|;
operator|*
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
operator|(
name|_IO_proc_file
operator|*
operator|)
name|fp
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
operator|*
name|ptr
operator|)
operator|->
name|next
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|<
literal|0
operator|||
name|_IO_close
argument_list|(
name|_IO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* POSIX.2 Rationale:  "Some historical implementations either block      or ignore the signals SIGINT, SIGQUIT, and SIGHUP while waiting      for the child process to terminate.  Since this behavior is not      described in POSIX.2, such implementations are not conforming." */
do|do
block|{
name|wait_pid
operator|=
name|_IO_waitpid
argument_list|(
operator|(
operator|(
name|_IO_proc_file
operator|*
operator|)
name|fp
operator|)
operator|->
name|pid
argument_list|,
operator|&
name|wstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|wait_pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|wait_pid
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|wstatus
return|;
else|#
directive|else
comment|/* !_IO_HAVE_SYS_WAIT */
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|struct
name|_IO_jump_t
name|_IO_proc_jumps
init|=
block|{
name|JUMP_INIT_DUMMY
block|,
name|JUMP_INIT
argument_list|(
name|finish
argument_list|,
name|_IO_file_finish
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|overflow
argument_list|,
name|_IO_file_overflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|underflow
argument_list|,
name|_IO_file_underflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|uflow
argument_list|,
name|_IO_default_uflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|pbackfail
argument_list|,
name|_IO_default_pbackfail
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsputn
argument_list|,
name|_IO_file_xsputn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsgetn
argument_list|,
name|_IO_default_xsgetn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekoff
argument_list|,
name|_IO_file_seekoff
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekpos
argument_list|,
name|_IO_default_seekpos
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|setbuf
argument_list|,
name|_IO_file_setbuf
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|sync
argument_list|,
name|_IO_file_sync
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|doallocate
argument_list|,
name|_IO_file_doallocate
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|read
argument_list|,
name|_IO_file_read
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|write
argument_list|,
name|_IO_file_write
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seek
argument_list|,
name|_IO_file_seek
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|close
argument_list|,
name|_IO_proc_close
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
argument|stat
argument_list|,
argument|_IO_file_stat
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

