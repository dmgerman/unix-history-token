begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.    This file is part of the GNU IO Library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__set_errno
end_ifndef

begin_define
define|#
directive|define
name|__set_errno
parameter_list|(
name|Val
parameter_list|)
value|errno = (Val)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|__GLIBC__
operator|&&
name|__GLIBC__
operator|>=
literal|2
end_if

begin_if
if|#
directive|if
name|__GLIBC_MINOR__
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<bits/libc-lock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<libc-lock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*# include<comthread.h>*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"iolibio.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|_IO_seek_set
value|0
define|#
directive|define
name|_IO_seek_cur
value|1
define|#
directive|define
name|_IO_seek_end
value|2
comment|/* THE JUMPTABLE FUNCTIONS.   * The _IO_FILE type is used to implement the FILE type in GNU libc,  * as well as the streambuf class in GNU iostreams for C++.  * These are all the same, just used differently.  * An _IO_FILE (or FILE) object is allows followed by a pointer to  * a jump table (of pointers to functions).  The pointer is accessed  * with the _IO_JUMPS macro.  The jump table has a eccentric format,  * so as to be compatible with the layout of a C++ virtual function table.  * (as implemented by g++).  When a pointer to a streambuf object is  * coerced to an (_IO_FILE*), then _IO_JUMPS on the result just  * happens to point to the virtual function table of the streambuf.  * Thus the _IO_JUMPS function table used for C stdio/libio does  * double duty as the virtual function table for C++ streambuf.  *  * The entries in the _IO_JUMPS function table (and hence also the  * virtual functions of a streambuf) are described below.  * The first parameter of each function entry is the _IO_FILE/streambuf  * object being acted on (i.e. the 'this' parameter).  */
define|#
directive|define
name|_IO_JUMPS
parameter_list|(
name|THIS
parameter_list|)
value|((struct _IO_FILE_plus *) (THIS))->vtable
ifdef|#
directive|ifdef
name|_G_USING_THUNKS
define|#
directive|define
name|JUMP_FIELD
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
value|TYPE NAME
define|#
directive|define
name|JUMP0
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|)
value|_IO_JUMPS(THIS)->FUNC (THIS)
define|#
directive|define
name|JUMP1
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|)
value|_IO_JUMPS(THIS)->FUNC (THIS, X1)
define|#
directive|define
name|JUMP2
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|)
value|_IO_JUMPS(THIS)->FUNC (THIS, X1, X2)
define|#
directive|define
name|JUMP3
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|,
name|X3
parameter_list|)
value|_IO_JUMPS(THIS)->FUNC (THIS, X1,X2, X3)
define|#
directive|define
name|JUMP_INIT
parameter_list|(
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|VALUE
define|#
directive|define
name|JUMP_INIT_DUMMY
value|JUMP_INIT(dummy, 0), JUMP_INIT (dummy2, 0)
else|#
directive|else
comment|/* These macros will change when we re-implement vtables to use "thunks"! */
define|#
directive|define
name|JUMP_FIELD
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
value|struct { short delta1, delta2; TYPE pfn; } NAME
define|#
directive|define
name|JUMP0
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|)
value|_IO_JUMPS(THIS)->FUNC.pfn (THIS)
define|#
directive|define
name|JUMP1
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|)
value|_IO_JUMPS(THIS)->FUNC.pfn (THIS, X1)
define|#
directive|define
name|JUMP2
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|)
value|_IO_JUMPS(THIS)->FUNC.pfn (THIS, X1, X2)
define|#
directive|define
name|JUMP3
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|,
name|X3
parameter_list|)
value|_IO_JUMPS(THIS)->FUNC.pfn (THIS, X1,X2,X3)
define|#
directive|define
name|JUMP_INIT
parameter_list|(
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|{0, 0, VALUE}
define|#
directive|define
name|JUMP_INIT_DUMMY
value|JUMP_INIT(dummy, 0)
endif|#
directive|endif
comment|/* The 'finish' function does any final cleaning up of an _IO_FILE object.    It does not delete (free) it, but does everything else to finalize it/    It matches the streambuf::~streambuf virtual destructor.  */
typedef|typedef
name|void
argument_list|(
argument|*_IO_finish_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* finalize */
define|#
directive|define
name|_IO_FINISH
parameter_list|(
name|FP
parameter_list|)
value|JUMP1 (__finish, FP, 0)
comment|/* The 'overflow' hook flushes the buffer.    The second argument is a character, or EOF.    It matches the streambuf::overflow virtual function. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_overflow_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_OVERFLOW
parameter_list|(
name|FP
parameter_list|,
name|CH
parameter_list|)
value|JUMP1 (__overflow, FP, CH)
comment|/* The 'underflow' hook tries to fills the get buffer.    It returns the next character (as an unsigned char) or EOF.  The next    character remains in the get buffer, and the get position is not changed.    It matches the streambuf::underflow virtual function. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_underflow_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_UNDERFLOW
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__underflow, FP)
comment|/* The 'uflow' hook returns the next character in the input stream    (cast to unsigned char), and increments the read position;    EOF is returned on failure.    It matches the streambuf::uflow virtual function, which is not in the    cfront implementation, but was added to C++ by the ANSI/ISO committee. */
define|#
directive|define
name|_IO_UFLOW
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__uflow, FP)
comment|/* The 'pbackfail' hook handles backing up.    It matches the streambuf::pbackfail virtual function. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_pbackfail_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_PBACKFAIL
parameter_list|(
name|FP
parameter_list|,
name|CH
parameter_list|)
value|JUMP1 (__pbackfail, FP, CH)
comment|/* The 'xsputn' hook writes upto N characters from buffer DATA.    Returns the number of character actually written.    It matches the streambuf::xsputn virtual function. */
typedef|typedef
name|_IO_size_t
argument_list|(
argument|*_IO_xsputn_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|FP
operator|,
specifier|const
name|void
operator|*
name|DATA
operator|,
name|_IO_size_t
name|N
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_XSPUTN
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|N
parameter_list|)
value|JUMP2 (__xsputn, FP, DATA, N)
comment|/* The 'xsgetn' hook reads upto N characters into buffer DATA.    Returns the number of character actually read.    It matches the streambuf::xsgetn virtual function. */
typedef|typedef
name|_IO_size_t
argument_list|(
argument|*_IO_xsgetn_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|FP
operator|,
name|void
operator|*
name|DATA
operator|,
name|_IO_size_t
name|N
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_XSGETN
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|N
parameter_list|)
value|JUMP2 (__xsgetn, FP, DATA, N)
comment|/* The 'seekoff' hook moves the stream position to a new position    relative to the start of the file (if DIR==0), the current position    (MODE==1), or the end of the file (MODE==2).    It matches the streambuf::seekoff virtual function.    It is also used for the ANSI fseek function. */
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
typedef|typedef
name|_IO_fpos64_t
argument_list|(
argument|*_IO_seekoff_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|FP
operator|,
name|_IO_off64_t
name|OFF
operator|,
name|int
name|DIR
operator|,
name|int
name|MODE
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
typedef|typedef
name|_IO_fpos_t
argument_list|(
argument|*_IO_seekoff_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|FP
operator|,
name|_IO_off_t
name|OFF
operator|,
name|int
name|DIR
operator|,
name|int
name|MODE
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|_IO_SEEKOFF
parameter_list|(
name|FP
parameter_list|,
name|OFF
parameter_list|,
name|DIR
parameter_list|,
name|MODE
parameter_list|)
value|JUMP3 (__seekoff, FP, OFF, DIR, MODE)
comment|/* The 'seekpos' hook also moves the stream position,    but to an absolute position given by a fpos_t (seekpos).    It matches the streambuf::seekpos virtual function.    It is also used for the ANSI fgetpos and fsetpos functions.  */
comment|/* The _IO_seek_cur and _IO_seek_end options are not allowed. */
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
typedef|typedef
name|_IO_fpos64_t
argument_list|(
argument|*_IO_seekpos_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos64_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
typedef|typedef
name|_IO_fpos_t
argument_list|(
argument|*_IO_seekpos_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|_IO_SEEKPOS
parameter_list|(
name|FP
parameter_list|,
name|POS
parameter_list|,
name|FLAGS
parameter_list|)
value|JUMP2 (__seekpos, FP, POS, FLAGS)
comment|/* The 'setbuf' hook gives a buffer to the file.    It matches the streambuf::setbuf virtual function. */
typedef|typedef
name|_IO_FILE
operator|*
operator|(
operator|*
name|_IO_setbuf_t
operator|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SETBUF
parameter_list|(
name|FP
parameter_list|,
name|BUFFER
parameter_list|,
name|LENGTH
parameter_list|)
value|JUMP2 (__setbuf, FP, BUFFER, LENGTH)
comment|/* The 'sync' hook attempts to synchronize the internal data structures    of the file with the external state.    It matches the streambuf::sync virtual function. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_sync_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SYNC
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__sync, FP)
comment|/* The 'doallocate' hook is used to tell the file to allocate a buffer.    It matches the streambuf::doallocate virtual function, which is not    in the ANSI/ISO C++ standard, but is part traditional implementations. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_doallocate_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_DOALLOCATE
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__doallocate, FP)
comment|/* The following four hooks (sysread, syswrite, sysclose, sysseek, and    sysstat) are low-level hooks specific to this implementation.    There is no correspondence in the ANSI/ISO C++ standard library.    The hooks basically correspond to the Unix system functions    (read, write, close, lseek, and stat) except that a _IO_FILE*    parameter is used instead of a integer file descriptor;  the default    implementation used for normal files just calls those functions.    The advantage of overriding these functions instead of the higher-level    ones (underflow, overflow etc) is that you can leave all the buffering    higher-level functions.  */
comment|/* The 'sysread' hook is used to read data from the external file into    an existing buffer.  It generalizes the Unix read(2) function.    It matches the streambuf::sys_read virtual function, which is    specific to this implementation. */
typedef|typedef
name|_IO_ssize_t
argument_list|(
argument|*_IO_read_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SYSREAD
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|LEN
parameter_list|)
value|JUMP2 (__read, FP, DATA, LEN)
comment|/* The 'syswrite' hook is used to write data from an existing buffer    to an external file.  It generalizes the Unix write(2) function.    It matches the streambuf::sys_write virtual function, which is    specific to this implementation. */
typedef|typedef
name|_IO_ssize_t
argument_list|(
argument|*_IO_write_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SYSWRITE
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|LEN
parameter_list|)
value|JUMP2 (__write, FP, DATA, LEN)
comment|/* The 'sysseek' hook is used to re-position an external file.    It generalizes the Unix lseek(2) function.    It matches the streambuf::sys_seek virtual function, which is    specific to this implementation. */
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
typedef|typedef
name|_IO_fpos64_t
argument_list|(
argument|*_IO_seek_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
typedef|typedef
name|_IO_fpos_t
argument_list|(
argument|*_IO_seek_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|_IO_SYSSEEK
parameter_list|(
name|FP
parameter_list|,
name|OFFSET
parameter_list|,
name|MODE
parameter_list|)
value|JUMP2 (__seek, FP, OFFSET, MODE)
comment|/* The 'sysclose' hook is used to finalize (close, finish up) an    external file.  It generalizes the Unix close(2) function.    It matches the streambuf::sys_close virtual function, which is    specific to this implementation. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_close_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* finalize */
define|#
directive|define
name|_IO_SYSCLOSE
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__close, FP)
comment|/* The 'sysstat' hook is used to get information about an external file    into a struct stat buffer.  It generalizes the Unix fstat(2) call.    It matches the streambuf::sys_stat virtual function, which is    specific to this implementation. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_stat_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SYSSTAT
parameter_list|(
name|FP
parameter_list|,
name|BUF
parameter_list|)
value|JUMP1 (__stat, FP, BUF)
if|#
directive|if
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
comment|/* The 'showmany' hook can be used to get an image how much input is    available.  In many cases the answer will be 0 which means unknown    but some cases one can provide real information.  */
typedef|typedef
name|int
argument_list|(
argument|*_IO_showmanyc_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SHOWMANYC
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__showmanyc, FP)
comment|/* The 'imbue' hook is used to get information about the currently    installed locales.  */
typedef|typedef
name|void
argument_list|(
argument|*_IO_imbue_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_IMBUE
parameter_list|(
name|FP
parameter_list|,
name|LOCALE
parameter_list|)
value|JUMP1 (__imbue, FP, LOCALE)
endif|#
directive|endif
define|#
directive|define
name|_IO_CHAR_TYPE
value|char
comment|/* unsigned char ? */
define|#
directive|define
name|_IO_INT_TYPE
value|int
struct|struct
name|_IO_jump_t
block|{
name|JUMP_FIELD
argument_list|(
name|_G_size_t
argument_list|,
name|__dummy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_G_USING_THUNKS
name|JUMP_FIELD
argument_list|(
name|_G_size_t
argument_list|,
name|__dummy2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|JUMP_FIELD
argument_list|(
name|_IO_finish_t
argument_list|,
name|__finish
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_overflow_t
argument_list|,
name|__overflow
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_underflow_t
argument_list|,
name|__underflow
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_underflow_t
argument_list|,
name|__uflow
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_pbackfail_t
argument_list|,
name|__pbackfail
argument_list|)
expr_stmt|;
comment|/* showmany */
name|JUMP_FIELD
argument_list|(
name|_IO_xsputn_t
argument_list|,
name|__xsputn
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_xsgetn_t
argument_list|,
name|__xsgetn
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_seekoff_t
argument_list|,
name|__seekoff
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_seekpos_t
argument_list|,
name|__seekpos
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_setbuf_t
argument_list|,
name|__setbuf
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_sync_t
argument_list|,
name|__sync
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_doallocate_t
argument_list|,
name|__doallocate
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_read_t
argument_list|,
name|__read
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_write_t
argument_list|,
name|__write
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_seek_t
argument_list|,
name|__seek
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_close_t
argument_list|,
name|__close
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_stat_t
argument_list|,
name|__stat
argument_list|)
expr_stmt|;
if|#
directive|if
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
name|JUMP_FIELD
argument_list|(
name|_IO_showmanyc_t
argument_list|,
name|__showmanyc
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_imbue_t
argument_list|,
name|__imbue
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|get_column;     set_column;
endif|#
directive|endif
block|}
struct|;
comment|/* We always allocate an extra word following an _IO_FILE.    This contains a pointer to the function jump table used.    This is for compatibility with C++ streambuf; the word can    be used to smash to a pointer to a virtual function table. */
struct|struct
name|_IO_FILE_plus
block|{
name|_IO_FILE
name|file
decl_stmt|;
specifier|const
name|struct
name|_IO_jump_t
modifier|*
name|vtable
decl_stmt|;
block|}
struct|;
comment|/* Generic functions */
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
specifier|extern
name|_IO_fpos64_t
name|_IO_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_fpos64_t
name|_IO_seekpos
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos64_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|extern
name|_IO_fpos_t
name|_IO_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_fpos_t
name|_IO_seekpos
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|void
name|_IO_switch_to_main_get_area
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_switch_to_backup_area
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_switch_to_get_mode
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_init
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_sputbackc
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_sungetc
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_un_link
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_link_in
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_doallocbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_unsave_markers
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_setb
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|unsigned
name|_IO_adjust_column
name|__P
argument_list|(
operator|(
name|unsigned
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|_IO_sputn
parameter_list|(
name|__fp
parameter_list|,
name|__s
parameter_list|,
name|__n
parameter_list|)
value|_IO_XSPUTN (__fp, __s, __n)
comment|/* Marker-related function. */
specifier|extern
name|void
name|_IO_init_marker
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|,
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_remove_marker
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_marker_difference
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|,
expr|struct
name|_IO_marker
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_marker_delta
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_seekmark
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
expr|struct
name|_IO_marker
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Default jumptable functions. */
specifier|extern
name|int
name|_IO_default_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_default_uflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_default_doallocate
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_default_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_default_pbackfail
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_default_setbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_default_xsputn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_default_xsgetn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
specifier|extern
name|_IO_fpos64_t
name|_IO_default_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_fpos64_t
name|_IO_default_seekpos
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos64_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|extern
name|_IO_fpos_t
name|_IO_default_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_fpos_t
name|_IO_default_seekpos
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|_IO_ssize_t
name|_IO_default_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_default_read
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_default_stat
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
specifier|extern
name|_IO_fpos64_t
name|_IO_default_seek
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|extern
name|_IO_fpos_t
name|_IO_default_seek
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|_IO_default_sync
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|_IO_default_close
value|((_IO_close_t) _IO_default_sync)
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_file_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_streambuf_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_proc_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_str_jumps
decl_stmt|;
specifier|extern
name|int
name|_IO_do_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_flush_all
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_cleanup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_flush_all_linebuffered
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|_IO_do_flush
parameter_list|(
name|_f
parameter_list|)
define|\
value|_IO_do_write(_f, (_f)->_IO_write_base, \ 	       (_f)->_IO_write_ptr-(_f)->_IO_write_base)
define|#
directive|define
name|_IO_in_put_mode
parameter_list|(
name|_fp
parameter_list|)
value|((_fp)->_flags& _IO_CURRENTLY_PUTTING)
define|#
directive|define
name|_IO_mask_flags
parameter_list|(
name|fp
parameter_list|,
name|f
parameter_list|,
name|mask
parameter_list|)
define|\
value|((fp)->_flags = ((fp)->_flags& ~(mask)) | ((f)& (mask)))
define|#
directive|define
name|_IO_setg
parameter_list|(
name|fp
parameter_list|,
name|eb
parameter_list|,
name|g
parameter_list|,
name|eg
parameter_list|)
value|((fp)->_IO_read_base = (eb),\ 	(fp)->_IO_read_ptr = (g), (fp)->_IO_read_end = (eg))
define|#
directive|define
name|_IO_setp
parameter_list|(
name|__fp
parameter_list|,
name|__p
parameter_list|,
name|__ep
parameter_list|)
define|\
value|((__fp)->_IO_write_base = (__fp)->_IO_write_ptr = __p, (__fp)->_IO_write_end = (__ep))
define|#
directive|define
name|_IO_have_backup
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_IO_save_base != NULL)
define|#
directive|define
name|_IO_in_backup
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_flags& _IO_IN_BACKUP)
define|#
directive|define
name|_IO_have_markers
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_markers != NULL)
define|#
directive|define
name|_IO_blen
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_IO_buf_end - (fp)->_IO_buf_base)
comment|/* Jumptable functions for files. */
specifier|extern
name|int
name|_IO_file_doallocate
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_file_setbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
specifier|extern
name|_IO_fpos64_t
name|_IO_file_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_fpos64_t
name|_IO_file_seek
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|extern
name|_IO_fpos_t
name|_IO_file_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_fpos_t
name|_IO_file_seek
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|_IO_size_t
name|_IO_file_xsputn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_stat
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_close
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_overflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|_IO_file_is_open
parameter_list|(
name|__fp
parameter_list|)
value|((__fp)->_fileno>= 0)
specifier|extern
name|void
name|_IO_file_init
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_file_attach
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_file_open
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_file_fopen
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_file_fopen
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|_IO_ssize_t
name|_IO_file_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_file_read
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_sync
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_close_it
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_file_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Jumptable functions for proc_files. */
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_proc_open
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_proc_close
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Jumptable functions for strfiles. */
specifier|extern
name|int
name|_IO_str_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_str_overflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_str_pbackfail
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
specifier|extern
name|_IO_fpos64_t
name|_IO_str_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|extern
name|_IO_fpos_t
name|_IO_str_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|void
name|_IO_str_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Other strfile functions */
specifier|extern
name|void
name|_IO_str_init_static
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_str_init_readonly
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_str_count
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_vasprintf
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|result_ptr
operator|,
name|__const
name|char
operator|*
name|format
operator|,
name|_IO_va_list
name|args
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_vdprintf
name|__P
argument_list|(
operator|(
name|int
name|d
operator|,
name|__const
name|char
operator|*
name|format
operator|,
name|_IO_va_list
name|arg
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_vsnprintf
name|__P
argument_list|(
operator|(
name|char
operator|*
name|string
operator|,
name|_IO_size_t
name|maxlen
operator|,
name|__const
name|char
operator|*
name|format
operator|,
name|_IO_va_list
name|args
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_getline
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_size_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_getline_info
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_size_t
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_getdelim
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|_IO_size_t
operator|*
operator|,
name|int
operator|,
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|double
name|_IO_strtod
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|_IO_dtoa
name|__P
argument_list|(
operator|(
name|double
name|__d
operator|,
name|int
name|__mode
operator|,
name|int
name|__ndigits
operator|,
name|int
operator|*
name|__decpt
operator|,
name|int
operator|*
name|__sign
operator|,
name|char
operator|*
operator|*
name|__rve
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_outfloat
name|__P
argument_list|(
operator|(
name|double
name|__value
operator|,
name|_IO_FILE
operator|*
name|__sb
operator|,
name|int
name|__type
operator|,
name|int
name|__width
operator|,
name|int
name|__precision
operator|,
name|int
name|__flags
operator|,
name|int
name|__sign_mode
operator|,
name|int
name|__fill
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_list_all
decl_stmt|;
extern|extern void (*_IO_cleanup_registration_needed
block|)
name|__PMT
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_extern

begin_ifndef
ifndef|#
directive|ifndef
name|EOF
end_ifndef

begin_define
define|#
directive|define
name|EOF
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_if
if|#
directive|if
name|defined
name|__GNUG__
operator|&&
expr|\
operator|(
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|8
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|NULL
value|(__null)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_define
define|#
directive|define
name|NULL
value|((void*)0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|_G_HAVE_MMAP
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|EXEC_PAGESIZE
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|_G_HAVE_MMAP
end_undef

begin_define
define|#
directive|define
name|_G_HAVE_MMAP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _G_HAVE_MMAP */
end_comment

begin_if
if|#
directive|if
name|_G_HAVE_MMAP
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* When using this code in the GNU libc we must not pollute the name space.  */
end_comment

begin_define
define|#
directive|define
name|mmap
value|__mmap
end_define

begin_define
define|#
directive|define
name|munmap
value|__munmap
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ROUND_TO_PAGE
parameter_list|(
name|_S
parameter_list|)
define|\
value|(((_S) + EXEC_PAGESIZE - 1)& ~(EXEC_PAGESIZE - 1))
end_define

begin_define
define|#
directive|define
name|FREE_BUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|)
define|\
value|munmap ((_B), ROUND_TO_PAGE (_S))
end_define

begin_define
define|#
directive|define
name|ALLOC_BUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|,
name|_R
parameter_list|)
define|\
value|do {								      \ 	  (_B) = (char *) mmap (0, ROUND_TO_PAGE (_S),			      \ 				PROT_READ | PROT_WRITE,			      \ 				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);	      \ 	  if ((_B) == (char *) -1)					      \ 	    return (_R);						      \        } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _G_HAVE_MMAP */
end_comment

begin_define
define|#
directive|define
name|FREE_BUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|)
define|\
value|free(_B)
end_define

begin_define
define|#
directive|define
name|ALLOC_BUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|,
name|_R
parameter_list|)
define|\
value|do {								      \ 	  (_B) = (char*)malloc(_S);					      \ 	  if ((_B) == NULL)						      \ 	    return (_R);						      \        } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _G_HAVE_MMAP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OS_FSTAT
end_ifndef

begin_define
define|#
directive|define
name|OS_FSTAT
value|fstat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|stat
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|extern
name|_IO_ssize_t
name|_IO_read
name|__P
argument_list|(
operator|(
name|int
operator|,
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|_IO_ssize_t
name|_IO_write
name|__P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|_IO_off_t
name|_IO_lseek
name|__P
argument_list|(
operator|(
name|int
operator|,
name|_IO_off_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_IO_close
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_IO_fstat
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_IO_vscanf
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|_IO_va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Operations on _IO_fpos_t.    Normally, these are trivial, but we provide hooks for configurations    where an _IO_fpos_t is a struct.    Note that _IO_off_t must be an integral type. */
end_comment

begin_comment
comment|/* _IO_pos_BAD is an _IO_fpos_t value indicating error, unknown, or EOF. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_pos_BAD
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
end_if

begin_define
define|#
directive|define
name|_IO_pos_BAD
value|((_IO_fpos64_t) -1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IO_pos_BAD
value|((_IO_fpos_t) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _IO_pos_as_off converts an _IO_fpos_t value to an _IO_off_t value. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_pos_as_off
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
end_if

begin_define
define|#
directive|define
name|_IO_pos_as_off
parameter_list|(
name|__pos
parameter_list|)
value|((_IO_off64_t) (__pos))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IO_pos_as_off
parameter_list|(
name|__pos
parameter_list|)
value|((_IO_off_t) (__pos))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _IO_pos_adjust adjust an _IO_fpos_t by some number of bytes. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_pos_adjust
end_ifndef

begin_define
define|#
directive|define
name|_IO_pos_adjust
parameter_list|(
name|__pos
parameter_list|,
name|__delta
parameter_list|)
value|((__pos) += (__delta))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _IO_pos_0 is an _IO_fpos_t value indicating beginning of file. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_pos_0
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
end_if

begin_define
define|#
directive|define
name|_IO_pos_0
value|((_IO_fpos64_t) 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IO_pos_0
value|((_IO_fpos_t) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_IO_MTSAFE_IO
end_ifdef

begin_comment
comment|/* check following! */
end_comment

begin_define
define|#
directive|define
name|FILEBUF_LITERAL
parameter_list|(
name|CHAIN
parameter_list|,
name|FLAGS
parameter_list|,
name|FD
parameter_list|)
define|\
value|{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \ 	   0, 0, 0, 0, { 0 },&_IO_stdfile_##FD##_lock }
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* check following! */
end_comment

begin_define
define|#
directive|define
name|FILEBUF_LITERAL
parameter_list|(
name|CHAIN
parameter_list|,
name|FLAGS
parameter_list|,
name|FD
parameter_list|)
define|\
value|{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \ 	   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VTABLE_LABEL defines NAME as of the CLASS class.    CNLENGTH is strlen(#CLASS).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_if
if|#
directive|if
name|_G_VTABLE_LABEL_HAS_LENGTH
end_if

begin_define
define|#
directive|define
name|VTABLE_LABEL
parameter_list|(
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|CNLENGTH
parameter_list|)
define|\
value|extern char NAME[] asm (_G_VTABLE_LABEL_PREFIX #CNLENGTH #CLASS);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VTABLE_LABEL
parameter_list|(
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|CNLENGTH
parameter_list|)
define|\
value|extern char NAME[] asm (_G_VTABLE_LABEL_PREFIX #CLASS);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|builtinbuf_vtable
argument_list|)
operator|&&
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_expr_stmt
unit|VTABLE_LABEL
operator|(
name|builtinbuf_vtable
operator|,
name|builtinbuf
operator|,
literal|10
operator|)
else|#
directive|else
if|#
directive|if
name|_G_VTABLE_LABEL_HAS_LENGTH
define|#
directive|define
name|builtinbuf_vtable
value|_G_VTABLE_LABEL_PREFIX_ID##10builtinbuf
else|#
directive|else
define|#
directive|define
name|builtinbuf_vtable
value|_G_VTABLE_LABEL_PREFIX_ID##builtinbuf
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* !defined(builtinbuf_vtable)&& defined(__cplusplus) */
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
define|#
directive|define
name|_IO_va_start
parameter_list|(
name|args
parameter_list|,
name|last
parameter_list|)
value|va_start(args, last)
else|#
directive|else
define|#
directive|define
name|_IO_va_start
parameter_list|(
name|args
parameter_list|,
name|last
parameter_list|)
value|va_start(args)
endif|#
directive|endif
specifier|extern
expr|struct
name|_IO_fake_stdiobuf
name|_IO_stdin_buf
operator|,
name|_IO_stdout_buf
operator|,
name|_IO_stderr_buf
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|COERCE_FILE
parameter_list|(
name|FILE
parameter_list|)
end_define

begin_comment
comment|/* Nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* This is part of the kludge for binary compatibility with old stdio. */
end_comment

begin_define
define|#
directive|define
name|COERCE_FILE
parameter_list|(
name|FILE
parameter_list|)
define|\
value|(((FILE)->_IO_file_flags& _IO_MAGIC_MASK) == _OLD_MAGIC_MASK \&& (FILE) = *(FILE**)&((int*)fp)[1])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EINVAL
end_ifdef

begin_define
define|#
directive|define
name|MAYBE_SET_EINVAL
value|__set_errno (EINVAL)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAYBE_SET_EINVAL
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IO_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|CHECK_FILE
parameter_list|(
name|FILE
parameter_list|,
name|RET
parameter_list|)
define|\
value|if ((FILE) == NULL) { MAYBE_SET_EINVAL; return RET; } \ 	else { COERCE_FILE(FILE); \ 	       if (((FILE)->_IO_file_flags& _IO_MAGIC_MASK) != _IO_MAGIC) \ 	  { MAYBE_SET_EINVAL; return RET; }}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_FILE
parameter_list|(
name|FILE
parameter_list|,
name|RET
parameter_list|)
value|COERCE_FILE (FILE)
end_define

begin_endif
endif|#
directive|endif
end_endif

end_unit

