begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1993, 1995, 1997, 1998 Free Software Foundation, Inc.    This file is part of the GNU IO Library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* Generic or default I/O operations. */
end_comment

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function
name|void
name|_IO_un_link
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_LINKED
condition|)
block|{
name|_IO_FILE
modifier|*
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
operator|&
name|_IO_list_all
init|;
operator|*
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
operator|&
operator|(
operator|*
name|f
operator|)
operator|->
name|_chain
control|)
block|{
if|if
condition|(
operator|*
name|f
operator|==
name|fp
condition|)
block|{
operator|*
name|f
operator|=
name|fp
operator|->
name|_chain
expr_stmt|;
break|break;
block|}
block|}
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_LINKED
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_IO_link_in
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_LINKED
operator|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|_flags
operator||=
name|_IO_LINKED
expr_stmt|;
name|fp
operator|->
name|_chain
operator|=
name|_IO_list_all
expr_stmt|;
name|_IO_list_all
operator|=
name|fp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return minimum _pos markers    Assumes the current get area is the main get area. */
end_comment

begin_decl_stmt
specifier|static
name|_IO_size_t
name|_IO_least_marker
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|_IO_size_t
name|_IO_least_marker
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|_IO_ssize_t
name|least_so_far
init|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
decl_stmt|;
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
for|for
control|(
name|mark
operator|=
name|fp
operator|->
name|_markers
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
if|if
condition|(
name|mark
operator|->
name|_pos
operator|<
name|least_so_far
condition|)
name|least_so_far
operator|=
name|mark
operator|->
name|_pos
expr_stmt|;
return|return
name|least_so_far
return|;
block|}
end_function

begin_comment
comment|/* Switch current get area from backup buffer to (start of) main get area. */
end_comment

begin_function
name|void
name|_IO_switch_to_main_get_area
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_IN_BACKUP
expr_stmt|;
comment|/* Swap _IO_read_end and _IO_save_end. */
name|tmp
operator|=
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_save_end
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|tmp
expr_stmt|;
comment|/* Swap _IO_read_base and _IO_save_base. */
name|tmp
operator|=
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_save_base
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|tmp
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch current get area from main get area to (end of) backup area. */
end_comment

begin_function
name|void
name|_IO_switch_to_backup_area
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|fp
operator|->
name|_flags
operator||=
name|_IO_IN_BACKUP
expr_stmt|;
comment|/* Swap _IO_read_end and _IO_save_end. */
name|tmp
operator|=
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_save_end
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|tmp
expr_stmt|;
comment|/* Swap _gbase and _IO_save_base. */
name|tmp
operator|=
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_save_base
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|tmp
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_IO_switch_to_get_mode
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_write_base
condition|)
if|if
condition|(
name|_IO_OVERFLOW
argument_list|(
name|fp
argument_list|,
name|EOF
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_backup_base
expr_stmt|;
else|else
block|{
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_read_end
condition|)
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_write_ptr
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_write_ptr
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|_IO_free_backup_area
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_main_get_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Just in case. */
name|free
argument_list|(
name|fp
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_backup_base
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int _IO_switch_to_put_mode (fp)      _IO_FILE *fp; {   fp->_IO_write_base = fp->_IO_read_ptr;   fp->_IO_write_ptr = fp->_IO_read_ptr;
comment|/* Following is wrong if line- or un-buffered? */
end_comment

begin_endif
unit|fp->_IO_write_end = (fp->_flags& _IO_IN_BACKUP 		       ? fp->_IO_read_end : fp->_IO_buf_end);    fp->_IO_read_ptr = fp->_IO_read_end;   fp->_IO_read_base = fp->_IO_read_end;    fp->_flags |= _IO_CURRENTLY_PUTTING;   return 0; }
endif|#
directive|endif
end_endif

begin_function
name|int
name|__overflow
parameter_list|(
name|f
parameter_list|,
name|ch
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
return|return
name|_IO_OVERFLOW
argument_list|(
name|f
argument_list|,
name|ch
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|save_for_backup
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|save_for_backup
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
comment|/* Append [_IO_read_base.._IO_read_end] to backup area. */
name|int
name|least_mark
init|=
name|_IO_least_marker
argument_list|(
name|fp
argument_list|)
decl_stmt|;
comment|/* needed_size is how much space we need in the backup area. */
name|int
name|needed_size
init|=
operator|(
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
operator|)
operator|-
name|least_mark
decl_stmt|;
name|int
name|current_Bsize
init|=
name|fp
operator|->
name|_IO_save_end
operator|-
name|fp
operator|->
name|_IO_save_base
decl_stmt|;
name|int
name|avail
decl_stmt|;
comment|/* Extra space available for future expansion. */
name|int
name|delta
decl_stmt|;
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|needed_size
operator|>
name|current_Bsize
condition|)
block|{
name|char
modifier|*
name|new_buffer
decl_stmt|;
name|avail
operator|=
literal|100
expr_stmt|;
name|new_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|avail
operator|+
name|needed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buffer
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
comment|/* FIXME */
if|if
condition|(
name|least_mark
operator|<
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_IO_save_end
operator|+
name|least_mark
argument_list|,
operator|-
name|least_mark
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|avail
operator|-
name|least_mark
argument_list|,
name|fp
operator|->
name|_IO_read_base
argument_list|,
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_IO_read_base
operator|+
name|least_mark
argument_list|,
name|needed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_save_base
condition|)
name|free
argument_list|(
name|fp
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|new_buffer
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|new_buffer
operator|+
name|avail
operator|+
name|needed_size
expr_stmt|;
block|}
else|else
block|{
name|avail
operator|=
name|current_Bsize
operator|-
name|needed_size
expr_stmt|;
if|if
condition|(
name|least_mark
operator|<
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|fp
operator|->
name|_IO_save_base
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_IO_save_end
operator|+
name|least_mark
argument_list|,
operator|-
name|least_mark
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fp
operator|->
name|_IO_save_base
operator|+
name|avail
operator|-
name|least_mark
argument_list|,
name|fp
operator|->
name|_IO_read_base
argument_list|,
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|needed_size
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|fp
operator|->
name|_IO_save_base
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_IO_read_base
operator|+
name|least_mark
argument_list|,
name|needed_size
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: Dubious arithmetic if pointers are NULL */
name|fp
operator|->
name|_IO_backup_base
operator|=
name|fp
operator|->
name|_IO_save_base
operator|+
name|avail
expr_stmt|;
comment|/* Adjust all the streammarkers. */
name|delta
operator|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
for|for
control|(
name|mark
operator|=
name|fp
operator|->
name|_markers
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|_pos
operator|-=
name|delta
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|__underflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
if|if
condition|(
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|_IO_switch_to_main_get_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
return|;
block|}
if|if
condition|(
name|_IO_have_markers
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|save_for_backup
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
block|}
elseif|else
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_free_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|_IO_UNDERFLOW
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|__uflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
if|if
condition|(
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
operator|++
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|_IO_switch_to_main_get_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
operator|++
return|;
block|}
if|if
condition|(
name|_IO_have_markers
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|save_for_backup
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
block|}
elseif|else
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_free_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|_IO_UFLOW
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|_IO_setb
parameter_list|(
name|f
parameter_list|,
name|b
parameter_list|,
name|eb
parameter_list|,
name|a
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|eb
decl_stmt|;
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|_IO_buf_base
operator|&&
operator|!
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
operator|)
condition|)
name|FREE_BUF
argument_list|(
name|f
operator|->
name|_IO_buf_base
argument_list|,
name|_IO_blen
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|_IO_buf_base
operator|=
name|b
expr_stmt|;
name|f
operator|->
name|_IO_buf_end
operator|=
name|eb
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|f
operator|->
name|_flags
operator|&=
operator|~
name|_IO_USER_BUF
expr_stmt|;
else|else
name|f
operator|->
name|_flags
operator||=
name|_IO_USER_BUF
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_IO_doallocbuf
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_UNBUFFERED
operator|)
condition|)
if|if
condition|(
name|_IO_DOALLOCATE
argument_list|(
name|fp
argument_list|)
operator|!=
name|EOF
condition|)
return|return;
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_shortbuf
argument_list|,
name|fp
operator|->
name|_shortbuf
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_IO_default_underflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
return|return
name|EOF
return|;
block|}
end_function

begin_function
name|int
name|_IO_default_uflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|ch
init|=
name|_IO_UNDERFLOW
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
operator|++
return|;
block|}
end_function

begin_function
name|_IO_size_t
name|_IO_default_xsputn
parameter_list|(
name|f
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|n
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|data
decl_stmt|;
name|_IO_size_t
name|more
init|=
name|n
decl_stmt|;
if|if
condition|(
name|more
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Space available. */
name|_IO_ssize_t
name|count
init|=
name|f
operator|->
name|_IO_write_end
operator|-
name|f
operator|->
name|_IO_write_ptr
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|_IO_size_t
operator|)
name|count
operator|>
name|more
condition|)
name|count
operator|=
name|more
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|20
condition|)
block|{
name|memcpy
argument_list|(
name|f
operator|->
name|_IO_write_ptr
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|+=
name|count
expr_stmt|;
name|f
operator|->
name|_IO_write_ptr
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
init|=
name|f
operator|->
name|_IO_write_ptr
decl_stmt|;
name|_IO_ssize_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|f
operator|->
name|_IO_write_ptr
operator|=
name|p
expr_stmt|;
block|}
name|more
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|more
operator|==
literal|0
operator|||
name|__overflow
argument_list|(
name|f
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|++
argument_list|)
operator|==
name|EOF
condition|)
break|break;
name|more
operator|--
expr_stmt|;
block|}
return|return
name|n
operator|-
name|more
return|;
block|}
end_function

begin_function
name|_IO_size_t
name|_IO_sgetn
parameter_list|(
name|fp
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|n
decl_stmt|;
block|{
comment|/* FIXME handle putback buffer here! */
return|return
name|_IO_XSGETN
argument_list|(
name|fp
argument_list|,
name|data
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_function
name|_IO_size_t
name|_IO_default_xsgetn
parameter_list|(
name|fp
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|n
decl_stmt|;
block|{
name|_IO_size_t
name|more
init|=
name|n
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|data
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Data available. */
name|_IO_ssize_t
name|count
init|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|_IO_size_t
operator|)
name|count
operator|>
name|more
condition|)
name|count
operator|=
name|more
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|20
condition|)
block|{
name|memcpy
argument_list|(
name|s
argument_list|,
name|fp
operator|->
name|_IO_read_ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|+=
name|count
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
init|=
name|fp
operator|->
name|_IO_read_ptr
decl_stmt|;
name|int
name|i
init|=
operator|(
name|int
operator|)
name|count
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|p
expr_stmt|;
block|}
name|more
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|more
operator|==
literal|0
operator|||
name|__underflow
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
break|break;
block|}
return|return
name|n
operator|-
name|more
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Seems not to be needed. --drepper */
end_comment

begin_endif
unit|int _IO_sync (fp)      _IO_FILE *fp; {   return 0; }
endif|#
directive|endif
end_endif

begin_function
name|_IO_FILE
modifier|*
name|_IO_default_setbuf
parameter_list|(
name|fp
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|_IO_ssize_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|_IO_SYNC
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|_flags
operator||=
name|_IO_UNBUFFERED
expr_stmt|;
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_shortbuf
argument_list|,
name|fp
operator|->
name|_shortbuf
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_UNBUFFERED
expr_stmt|;
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_end
operator|=
literal|0
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|_IO_pos_t
name|_IO_default_seekpos
parameter_list|(
name|fp
parameter_list|,
name|pos
parameter_list|,
name|mode
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_pos_t
name|pos
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
return|return
name|_IO_SEEKOFF
argument_list|(
name|fp
argument_list|,
name|_IO_pos_as_off
argument_list|(
name|pos
argument_list|)
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_IO_default_doallocate
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|ALLOC_BUF
argument_list|(
name|buf
argument_list|,
name|_IO_BUFSIZ
argument_list|,
name|EOF
argument_list|)
expr_stmt|;
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
name|_IO_BUFSIZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|_IO_init
parameter_list|(
name|fp
parameter_list|,
name|flags
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|fp
operator|->
name|_flags
operator|=
name|_IO_MAGIC
operator||
name|flags
expr_stmt|;
name|fp
operator|->
name|_IO_buf_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_buf_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_chain
operator|=
name|NULL
expr_stmt|;
comment|/* Not necessary. */
name|fp
operator|->
name|_IO_save_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_backup_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_markers
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_cur_column
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_IO_MTSAFE_IO
name|_IO_lock_init
argument_list|(
operator|*
name|fp
operator|->
name|_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|_IO_default_sync
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The way the C++ classes are mapped into the C functions in the    current implementation, this function can get called twice! */
end_comment

begin_function
name|void
name|_IO_default_finish
parameter_list|(
name|fp
parameter_list|,
name|dummy
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|dummy
decl_stmt|;
block|{
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|&&
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
operator|)
condition|)
block|{
name|FREE_BUF
argument_list|(
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|_IO_blen
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_buf_base
operator|=
name|fp
operator|->
name|_IO_buf_end
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|mark
operator|=
name|fp
operator|->
name|_markers
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|_sbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_save_base
condition|)
block|{
name|free
argument_list|(
name|fp
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_IO_MTSAFE_IO
name|_IO_lock_fini
argument_list|(
operator|*
name|fp
operator|->
name|_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_IO_un_link
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|_IO_pos_t
name|_IO_default_seekoff
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|,
name|dir
parameter_list|,
name|mode
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_off_t
name|offset
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
return|return
name|_IO_pos_BAD
return|;
block|}
end_function

begin_function
name|int
name|_IO_sputbackc
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|>
name|fp
operator|->
name|_IO_read_base
operator|&&
operator|(
name|unsigned
name|char
operator|)
name|fp
operator|->
name|_IO_read_ptr
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|c
condition|)
block|{
name|fp
operator|->
name|_IO_read_ptr
operator|--
expr_stmt|;
name|result
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
block|}
else|else
name|result
operator|=
name|_IO_PBACKFAIL
argument_list|(
name|fp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|EOF
condition|)
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_EOF_SEEN
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|_IO_sungetc
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|>
name|fp
operator|->
name|_IO_read_base
condition|)
block|{
name|fp
operator|->
name|_IO_read_ptr
operator|--
expr_stmt|;
name|result
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
block|}
else|else
name|result
operator|=
name|_IO_PBACKFAIL
argument_list|(
name|fp
argument_list|,
name|EOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|EOF
condition|)
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_EOF_SEEN
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Work in progress */
end_comment

begin_comment
comment|/* Seems not to be needed.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|void _IO_set_column (fp, c)      _IO_FILE *fp;      int c; {   if (c == -1)     fp->_column = -1;   else     fp->_column = c - (fp->_IO_write_ptr - fp->_IO_write_base); }
else|#
directive|else
end_else

begin_endif
unit|int _IO_set_column (fp, i)      _IO_FILE *fp;      int i; {   fp->_cur_column = i + 1;   return 0; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|_IO_adjust_column
parameter_list|(
name|start
parameter_list|,
name|line
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|line
operator|+
name|count
decl_stmt|;
while|while
condition|(
name|ptr
operator|>
name|line
condition|)
if|if
condition|(
operator|*
operator|--
name|ptr
operator|==
literal|'\n'
condition|)
return|return
name|line
operator|+
name|count
operator|-
name|ptr
operator|-
literal|1
return|;
return|return
name|start
operator|+
name|count
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Seems not to be needed. --drepper */
end_comment

begin_endif
unit|int _IO_get_column (fp)      _IO_FILE *fp; {   if (fp->_cur_column)     return _IO_adjust_column (fp->_cur_column - 1, 			      fp->_IO_write_base, 			      fp->_IO_write_ptr - fp->_IO_write_base);   return -1; }
endif|#
directive|endif
end_endif

begin_function
name|int
name|_IO_flush_all
parameter_list|()
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_IO_list_all
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|_chain
control|)
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_write_base
operator|&&
name|_IO_OVERFLOW
argument_list|(
name|fp
argument_list|,
name|EOF
argument_list|)
operator|==
name|EOF
condition|)
name|result
operator|=
name|EOF
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|_IO_flush_all_linebuffered
parameter_list|()
block|{
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_IO_list_all
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|_chain
control|)
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_WRITES
operator|)
operator|==
literal|0
operator|&&
name|fp
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
condition|)
name|_IO_OVERFLOW
argument_list|(
name|fp
argument_list|,
name|EOF
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|_IO_unbuffer_all
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|_IO_unbuffer_all
parameter_list|()
block|{
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_IO_list_all
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|_chain
control|)
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_UNBUFFERED
operator|)
condition|)
name|_IO_SETBUF
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_IO_cleanup
parameter_list|()
block|{
name|_IO_flush_all
argument_list|()
expr_stmt|;
comment|/* We currently don't have a reliable mechanism for making sure that      C++ static destructors are executed in the correct order.      So it is possible that other static destructors might want to      write to cout - and they're supposed to be able to do so.       The following will make the standard streambufs be unbuffered,      which forces any output from late destructors to be written out. */
name|_IO_unbuffer_all
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_IO_init_marker
parameter_list|(
name|marker
parameter_list|,
name|fp
parameter_list|)
name|struct
name|_IO_marker
modifier|*
name|marker
decl_stmt|;
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|marker
operator|->
name|_sbuf
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|marker
operator|->
name|_pos
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
else|else
name|marker
operator|->
name|_pos
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
comment|/* Should perhaps sort the chain? */
name|marker
operator|->
name|_next
operator|=
name|fp
operator|->
name|_markers
expr_stmt|;
name|fp
operator|->
name|_markers
operator|=
name|marker
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_IO_remove_marker
parameter_list|(
name|marker
parameter_list|)
name|struct
name|_IO_marker
modifier|*
name|marker
decl_stmt|;
block|{
comment|/* Unlink from sb's chain. */
name|struct
name|_IO_marker
modifier|*
modifier|*
name|ptr
init|=
operator|&
name|marker
operator|->
name|_sbuf
operator|->
name|_markers
decl_stmt|;
for|for
control|(
init|;
condition|;
name|ptr
operator|=
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|_next
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
name|NULL
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
name|marker
condition|)
block|{
operator|*
name|ptr
operator|=
name|marker
operator|->
name|_next
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
literal|0
block|if _sbuf has a backup area that is no longer needed, should we delete     it now, or wait until the next underflow?
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|BAD_DELTA
value|EOF
end_define

begin_function
name|int
name|_IO_marker_difference
parameter_list|(
name|mark1
parameter_list|,
name|mark2
parameter_list|)
name|struct
name|_IO_marker
modifier|*
name|mark1
decl_stmt|;
name|struct
name|_IO_marker
modifier|*
name|mark2
decl_stmt|;
block|{
return|return
name|mark1
operator|->
name|_pos
operator|-
name|mark2
operator|->
name|_pos
return|;
block|}
end_function

begin_comment
comment|/* Return difference between MARK and current position of MARK's stream. */
end_comment

begin_function
name|int
name|_IO_marker_delta
parameter_list|(
name|mark
parameter_list|)
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
block|{
name|int
name|cur_pos
decl_stmt|;
if|if
condition|(
name|mark
operator|->
name|_sbuf
operator|==
name|NULL
condition|)
return|return
name|BAD_DELTA
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|mark
operator|->
name|_sbuf
argument_list|)
condition|)
name|cur_pos
operator|=
name|mark
operator|->
name|_sbuf
operator|->
name|_IO_read_ptr
operator|-
name|mark
operator|->
name|_sbuf
operator|->
name|_IO_read_end
expr_stmt|;
else|else
name|cur_pos
operator|=
name|mark
operator|->
name|_sbuf
operator|->
name|_IO_read_ptr
operator|-
name|mark
operator|->
name|_sbuf
operator|->
name|_IO_read_base
expr_stmt|;
return|return
name|mark
operator|->
name|_pos
operator|-
name|cur_pos
return|;
block|}
end_function

begin_function
name|int
name|_IO_seekmark
parameter_list|(
name|fp
parameter_list|,
name|mark
parameter_list|,
name|delta
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
name|int
name|delta
decl_stmt|;
block|{
if|if
condition|(
name|mark
operator|->
name|_sbuf
operator|!=
name|fp
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|mark
operator|->
name|_pos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_main_get_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|mark
operator|->
name|_pos
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_end
operator|+
name|mark
operator|->
name|_pos
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|_IO_unsave_markers
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|_IO_marker
modifier|*
name|mark
init|=
name|fp
operator|->
name|_markers
decl_stmt|;
if|if
condition|(
name|mark
condition|)
block|{
ifdef|#
directive|ifdef
name|TODO
name|streampos
name|offset
init|=
name|seekoff
argument_list|(
literal|0
argument_list|,
name|ios
operator|::
name|cur
argument_list|,
name|ios
operator|::
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
name|EOF
condition|)
block|{
name|offset
operator|+=
name|eGptr
argument_list|()
operator|-
name|Gbase
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|set_streampos
argument_list|(
name|mark
operator|->
name|_pos
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|set_streampos
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fp
operator|->
name|_markers
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_free_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Seems not to be needed. --drepper */
end_comment

begin_endif
unit|int _IO_nobackup_pbackfail (fp, c)      _IO_FILE *fp;      int c; {   if (fp->_IO_read_ptr> fp->_IO_read_base) 	fp->_IO_read_ptr--;   if (c != EOF&& *fp->_IO_read_ptr != c)       *fp->_IO_read_ptr = c;   return (unsigned char) c; }
endif|#
directive|endif
end_endif

begin_function
name|int
name|_IO_default_pbackfail
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<=
name|fp
operator|->
name|_IO_read_base
condition|)
block|{
comment|/* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/* No backup buffer: allocate one. */
comment|/* Use nshort buffer, if unused? (probably not)  FIXME */
name|int
name|backup_size
init|=
literal|128
decl_stmt|;
name|char
modifier|*
name|bbuf
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|backup_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|bbuf
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|bbuf
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|fp
operator|->
name|_IO_save_base
operator|+
name|backup_size
expr_stmt|;
name|fp
operator|->
name|_IO_backup_base
operator|=
name|fp
operator|->
name|_IO_save_end
expr_stmt|;
name|_IO_switch_to_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<=
name|fp
operator|->
name|_IO_read_base
condition|)
block|{
comment|/* Increase size of existing backup buffer. */
name|_IO_size_t
name|new_size
decl_stmt|;
name|_IO_size_t
name|old_size
init|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
decl_stmt|;
name|char
modifier|*
name|new_buf
decl_stmt|;
name|new_size
operator|=
literal|2
operator|*
name|old_size
expr_stmt|;
name|new_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buf
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
name|memcpy
argument_list|(
name|new_buf
operator|+
operator|(
name|new_size
operator|-
name|old_size
operator|)
argument_list|,
name|fp
operator|->
name|_IO_read_base
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|new_buf
argument_list|,
name|new_buf
operator|+
operator|(
name|new_size
operator|-
name|old_size
operator|)
argument_list|,
name|new_buf
operator|+
name|new_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_backup_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
block|}
block|}
operator|--
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|*
name|fp
operator|->
name|_IO_read_ptr
operator|!=
name|c
condition|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
return|;
block|}
end_function

begin_function
name|_IO_pos_t
name|_IO_default_seek
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|,
name|dir
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_off_t
name|offset
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
return|return
name|_IO_pos_BAD
return|;
block|}
end_function

begin_function
name|int
name|_IO_default_stat
parameter_list|(
name|fp
parameter_list|,
name|st
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|st
decl_stmt|;
block|{
return|return
name|EOF
return|;
block|}
end_function

begin_function
name|_IO_ssize_t
name|_IO_default_read
parameter_list|(
name|fp
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_ssize_t
name|n
decl_stmt|;
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|_IO_ssize_t
name|_IO_default_write
parameter_list|(
name|fp
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_ssize_t
name|n
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TODO
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_define
define|#
directive|define
name|IO_CLEANUP
value|;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IO_CLEANUP
end_ifdef

begin_macro
name|IO_CLEANUP
end_macro

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|__io_defs
block|{
name|__io_defs
argument_list|()
block|{ }
operator|~
name|__io_defs
argument_list|()
block|{
name|_IO_cleanup
argument_list|()
block|; }
block|}
struct|;
end_struct

begin_decl_stmt
name|__io_defs
name|io_defs__
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TODO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|_IO_cleanup
argument_list|,
argument|_cleanup
argument_list|)
end_macro

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_G_STDIO_USES_LIBIO
argument_list|)
operator|&&
name|defined
argument_list|(
name|_G_HAVE_WEAK_SYMBOL
argument_list|)
end_elif

begin_function_decl
name|void
name|_cleanup
parameter_list|()
function_decl|__attribute__
parameter_list|(
function_decl|(weak
operator|,
function_decl|alias
parameter_list|(
function_decl|"_IO_cleanup"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|text_set_element
end_ifdef

begin_expr_stmt
name|text_set_element
argument_list|(
name|__libc_atexit
argument_list|,
name|_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

