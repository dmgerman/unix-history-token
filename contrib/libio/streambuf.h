begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This is part of libio/iostream, providing -*- C++ -*- input/output. Copyright (C) 1993 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this library; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_STREAMBUF_H
end_ifndef

begin_define
define|#
directive|define
name|_STREAMBUF_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUG__
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|interface
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define _G_IO_THROW */
end_comment

begin_comment
comment|/* Not implemented:  ios::failure */
end_comment

begin_define
define|#
directive|define
name|_IO_NEW_STREAMS
end_define

begin_comment
comment|// new optimizated stream representation
end_comment

begin_extern
extern|extern
literal|"C"
block|{
include|#
directive|include
file|<libio.h>
block|}
end_extern

begin_comment
comment|//#include<_G_config.h>
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_G_NEED_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_va_list
end_ifndef

begin_define
define|#
directive|define
name|_IO_va_list
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EOF
end_ifndef

begin_define
define|#
directive|define
name|EOF
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUG__
end_ifdef

begin_define
define|#
directive|define
name|NULL
value|(__null)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_wchar_t
end_ifndef

begin_if
if|#
directive|if
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
end_if

begin_define
define|#
directive|define
name|_IO_wchar_t
value|_G_wchar_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IO_wchar_t
value|short
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern
literal|"C++"
block|{
name|class
name|istream
decl_stmt|;
comment|/* Work-around for a g++ name mangling bug. Fixed in 2.6. */
name|class
name|ostream
decl_stmt|;
name|class
name|streambuf
decl_stmt|;
comment|// In case some header files defines these as macros.
undef|#
directive|undef
name|open
undef|#
directive|undef
name|close
if|#
directive|if
name|defined
argument_list|(
name|_G_IO_IO_FILE_VERSION
argument_list|)
operator|&&
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
typedef|typedef
name|_IO_off64_t
name|streamoff
typedef|;
typedef|typedef
name|_IO_off64_t
name|streampos
typedef|;
else|#
directive|else
typedef|typedef
name|_IO_off_t
name|streamoff
typedef|;
typedef|typedef
name|_IO_off_t
name|streampos
typedef|;
endif|#
directive|endif
typedef|typedef
name|_IO_ssize_t
name|streamsize
typedef|;
typedef|typedef
name|unsigned
name|long
name|__fmtflags
typedef|;
typedef|typedef
name|unsigned
name|char
name|__iostate
typedef|;
struct|struct
name|_ios_fields
block|{
comment|// The data members of an ios.
name|streambuf
modifier|*
name|_strbuf
decl_stmt|;
name|ostream
modifier|*
name|_tie
decl_stmt|;
name|int
name|_width
decl_stmt|;
name|__fmtflags
name|_flags
decl_stmt|;
name|_IO_wchar_t
name|_fill
decl_stmt|;
name|__iostate
name|_state
decl_stmt|;
name|__iostate
name|_exceptions
decl_stmt|;
name|int
name|_precision
decl_stmt|;
name|void
modifier|*
name|_arrays
decl_stmt|;
comment|/* Support for ios::iword and ios::pword. */
block|}
struct|;
define|#
directive|define
name|_IOS_GOOD
value|0
define|#
directive|define
name|_IOS_EOF
value|1
define|#
directive|define
name|_IOS_FAIL
value|2
define|#
directive|define
name|_IOS_BAD
value|4
define|#
directive|define
name|_IO_INPUT
value|1
define|#
directive|define
name|_IO_OUTPUT
value|2
define|#
directive|define
name|_IO_ATEND
value|4
define|#
directive|define
name|_IO_APPEND
value|8
define|#
directive|define
name|_IO_TRUNC
value|16
define|#
directive|define
name|_IO_NOCREATE
value|32
define|#
directive|define
name|_IO_NOREPLACE
value|64
define|#
directive|define
name|_IO_BIN
value|128
ifdef|#
directive|ifdef
name|_STREAM_COMPAT
enum|enum
name|state_value
block|{
name|_good
init|=
name|_IOS_GOOD
block|,
name|_eof
init|=
name|_IOS_EOF
block|,
name|_fail
init|=
name|_IOS_FAIL
block|,
name|_bad
init|=
name|_IOS_BAD
block|}
enum|;
enum|enum
name|open_mode
block|{
name|input
init|=
name|_IO_INPUT
block|,
name|output
init|=
name|_IO_OUTPUT
block|,
name|atend
init|=
name|_IO_ATEND
block|,
name|append
init|=
name|_IO_APPEND
block|}
enum|;
endif|#
directive|endif
name|class
name|ios
range|:
name|public
name|_ios_fields
block|{
name|ios
operator|&
name|operator
operator|=
operator|(
name|ios
operator|&
operator|)
block|;
comment|/* Not allowed! */
name|ios
argument_list|(
specifier|const
name|ios
operator|&
argument_list|)
block|;
comment|/* Not allowed! */
name|public
operator|:
typedef|typedef
name|__fmtflags
name|fmtflags
typedef|;
typedef|typedef
name|int
name|iostate
typedef|;
typedef|typedef
name|int
name|openmode
typedef|;
typedef|typedef
name|_IO_ssize_t
name|streamsize
typedef|;
enum|enum
name|io_state
block|{
name|goodbit
init|=
name|_IOS_GOOD
block|,
name|eofbit
init|=
name|_IOS_EOF
block|,
name|failbit
init|=
name|_IOS_FAIL
block|,
name|badbit
init|=
name|_IOS_BAD
block|}
enum|;
enum|enum
name|open_mode
block|{
name|in
init|=
name|_IO_INPUT
block|,
name|out
init|=
name|_IO_OUTPUT
block|,
name|ate
init|=
name|_IO_ATEND
block|,
name|app
init|=
name|_IO_APPEND
block|,
name|trunc
init|=
name|_IO_TRUNC
block|,
name|nocreate
init|=
name|_IO_NOCREATE
block|,
name|noreplace
init|=
name|_IO_NOREPLACE
block|,
name|bin
init|=
name|_IOS_BIN
block|,
comment|// Deprecated - ANSI uses ios::binary.
name|binary
init|=
name|_IOS_BIN
block|}
enum|;
enum|enum
name|seek_dir
block|{
name|beg
block|,
name|cur
block|,
name|end
block|}
enum|;
typedef|typedef
name|enum
name|seek_dir
name|seekdir
typedef|;
comment|// NOTE: If adding flags here, before to update ios::bitalloc().
enum|enum
block|{
name|skipws
init|=
name|_IO_SKIPWS
block|,
name|left
init|=
name|_IO_LEFT
block|,
name|right
init|=
name|_IO_RIGHT
block|,
name|internal
init|=
name|_IO_INTERNAL
block|,
name|dec
init|=
name|_IO_DEC
block|,
name|oct
init|=
name|_IO_OCT
block|,
name|hex
init|=
name|_IO_HEX
block|,
name|showbase
init|=
name|_IO_SHOWBASE
block|,
name|showpoint
init|=
name|_IO_SHOWPOINT
block|,
name|uppercase
init|=
name|_IO_UPPERCASE
block|,
name|showpos
init|=
name|_IO_SHOWPOS
block|,
name|scientific
init|=
name|_IO_SCIENTIFIC
block|,
name|fixed
init|=
name|_IO_FIXED
block|,
name|unitbuf
init|=
name|_IO_UNITBUF
block|,
name|stdio
init|=
name|_IO_STDIO
ifndef|#
directive|ifndef
name|_IO_NEW_STREAMS
block|,
name|dont_close
init|=
name|_IO_DONT_CLOSE
comment|// Don't delete streambuf on stream destruction
endif|#
directive|endif
block|}
enum|;
enum|enum
block|{
comment|// Masks.
name|basefield
init|=
name|dec
operator|+
name|oct
operator|+
name|hex
block|,
name|floatfield
init|=
name|scientific
operator|+
name|fixed
block|,
name|adjustfield
init|=
name|left
operator|+
name|right
operator|+
name|internal
block|}
enum|;
ifdef|#
directive|ifdef
name|_IO_THROW
name|class
name|failure
range|:
name|public
name|xmsg
block|{
name|ios
operator|*
name|_stream
block|;
name|public
operator|:
name|failure
argument_list|(
argument|ios* stream
argument_list|)
block|{
name|_stream
operator|=
name|stream
block|; }
name|failure
argument_list|(
argument|string cause
argument_list|,
argument|ios* stream
argument_list|)
block|{
name|_stream
operator|=
name|stream
block|; }
name|ios
operator|*
name|rdios
argument_list|()
specifier|const
block|{
return|return
name|_stream
return|;
block|}
expr|}
block|;
endif|#
directive|endif
name|ostream
operator|*
name|tie
argument_list|()
specifier|const
block|{
return|return
name|_tie
return|;
block|}
name|ostream
operator|*
name|tie
argument_list|(
argument|ostream* val
argument_list|)
block|{
name|ostream
operator|*
name|save
operator|=
name|_tie
block|;
name|_tie
operator|=
name|val
block|;
return|return
name|save
return|;
block|}
comment|// Methods to change the format state.
name|_IO_wchar_t
name|fill
argument_list|()
specifier|const
block|{
return|return
name|_fill
return|;
block|}
name|_IO_wchar_t
name|fill
argument_list|(
argument|_IO_wchar_t newf
argument_list|)
block|{
name|_IO_wchar_t
name|oldf
operator|=
name|_fill
block|;
name|_fill
operator|=
name|newf
block|;
return|return
name|oldf
return|;
block|}
name|fmtflags
name|flags
argument_list|()
specifier|const
block|{
return|return
name|_flags
return|;
block|}
name|fmtflags
name|flags
argument_list|(
argument|fmtflags new_val
argument_list|)
block|{
name|fmtflags
name|old_val
operator|=
name|_flags
block|;
name|_flags
operator|=
name|new_val
block|;
return|return
name|old_val
return|;
block|}
name|int
name|precision
argument_list|()
specifier|const
block|{
return|return
name|_precision
return|;
block|}
name|int
name|precision
argument_list|(
argument|int newp
argument_list|)
block|{
name|unsigned
name|short
name|oldp
operator|=
name|_precision
block|;
name|_precision
operator|=
operator|(
name|unsigned
name|short
operator|)
name|newp
block|;
return|return
name|oldp
return|;
block|}
name|fmtflags
name|setf
argument_list|(
argument|fmtflags val
argument_list|)
block|{
name|fmtflags
name|oldbits
operator|=
name|_flags
block|;
name|_flags
operator||=
name|val
block|;
return|return
name|oldbits
return|;
block|}
name|fmtflags
name|setf
argument_list|(
argument|fmtflags val
argument_list|,
argument|fmtflags mask
argument_list|)
block|{
name|fmtflags
name|oldbits
operator|=
name|_flags
block|;
name|_flags
operator|=
operator|(
name|_flags
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|val
operator|&
name|mask
operator|)
block|;
return|return
name|oldbits
return|;
block|}
name|fmtflags
name|unsetf
argument_list|(
argument|fmtflags mask
argument_list|)
block|{
name|fmtflags
name|oldbits
operator|=
name|_flags
block|;
name|_flags
operator|&=
operator|~
name|mask
block|;
return|return
name|oldbits
return|;
block|}
name|int
name|width
argument_list|()
specifier|const
block|{
return|return
name|_width
return|;
block|}
name|int
name|width
argument_list|(
argument|int val
argument_list|)
block|{
name|int
name|save
operator|=
name|_width
block|;
name|_width
operator|=
name|val
block|;
return|return
name|save
return|;
block|}
ifdef|#
directive|ifdef
name|_IO_THROW
name|void
name|_throw_failure
argument_list|()
specifier|const
block|{
name|throw
name|new
name|ios
operator|::
name|failure
argument_list|(
name|this
argument_list|)
block|; }
else|#
directive|else
name|void
name|_throw_failure
argument_list|()
specifier|const
block|{ }
endif|#
directive|endif
name|void
name|clear
argument_list|(
argument|iostate state =
literal|0
argument_list|)
block|{
name|_state
operator|=
name|_strbuf
operator|?
name|state
operator|:
name|state
operator||
name|badbit
block|;
if|if
condition|(
name|_state
operator|&
name|_exceptions
condition|)
name|_throw_failure
argument_list|()
expr_stmt|;
block|}
name|void
name|set
argument_list|(
argument|iostate flag
argument_list|)
block|{
name|_state
operator||=
name|flag
block|;
if|if
condition|(
name|_state
operator|&
name|_exceptions
condition|)
name|_throw_failure
argument_list|()
expr_stmt|;
block|}
name|void
name|setstate
argument_list|(
argument|iostate flag
argument_list|)
block|{
name|_state
operator||=
name|flag
block|;
comment|// ANSI
if|if
condition|(
name|_state
operator|&
name|_exceptions
condition|)
name|_throw_failure
argument_list|()
expr_stmt|;
block|}
name|int
name|good
argument_list|()
specifier|const
block|{
return|return
name|_state
operator|==
literal|0
return|;
block|}
name|int
name|eof
argument_list|()
specifier|const
block|{
return|return
name|_state
operator|&
name|ios
operator|::
name|eofbit
return|;
block|}
name|int
name|fail
argument_list|()
specifier|const
block|{
return|return
name|_state
operator|&
operator|(
name|ios
operator|::
name|badbit
operator||
name|ios
operator|::
name|failbit
operator|)
return|;
block|}
name|int
name|bad
argument_list|()
specifier|const
block|{
return|return
name|_state
operator|&
name|ios
operator|::
name|badbit
return|;
block|}
name|iostate
name|rdstate
argument_list|()
specifier|const
block|{
return|return
name|_state
return|;
block|}
name|operator
name|void
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|fail
argument_list|()
operator|?
operator|(
name|void
operator|*
operator|)
literal|0
operator|:
operator|(
name|void
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|int
name|operator
operator|!
operator|(
operator|)
specifier|const
block|{
return|return
name|fail
argument_list|()
return|;
block|}
name|iostate
name|exceptions
argument_list|()
specifier|const
block|{
return|return
name|_exceptions
return|;
block|}
name|void
name|exceptions
argument_list|(
argument|iostate enable
argument_list|)
block|{
name|_exceptions
operator|=
name|enable
block|;
if|if
condition|(
name|_state
operator|&
name|_exceptions
condition|)
name|_throw_failure
argument_list|()
expr_stmt|;
block|}
name|streambuf
operator|*
name|rdbuf
argument_list|()
specifier|const
block|{
return|return
name|_strbuf
return|;
block|}
name|streambuf
operator|*
name|rdbuf
argument_list|(
argument|streambuf *_s
argument_list|)
block|{
name|streambuf
operator|*
name|_old
operator|=
name|_strbuf
block|;
name|_strbuf
operator|=
name|_s
block|;
name|clear
argument_list|()
block|;
return|return
name|_old
return|;
block|}
specifier|static
name|int
name|sync_with_stdio
argument_list|(
argument|int on
argument_list|)
block|;
specifier|static
name|void
name|sync_with_stdio
argument_list|()
block|{
name|sync_with_stdio
argument_list|(
literal|1
argument_list|)
block|; }
specifier|static
name|fmtflags
name|bitalloc
argument_list|()
block|;
specifier|static
name|int
name|xalloc
argument_list|()
block|;
name|void
operator|*
operator|&
name|pword
argument_list|(
name|int
argument_list|)
block|;
name|void
operator|*
name|pword
argument_list|(
argument|int
argument_list|)
specifier|const
block|;
name|long
operator|&
name|iword
argument_list|(
name|int
argument_list|)
block|;
name|long
name|iword
argument_list|(
argument|int
argument_list|)
specifier|const
block|;
ifdef|#
directive|ifdef
name|_STREAM_COMPAT
name|void
name|unset
argument_list|(
argument|state_value flag
argument_list|)
block|{
name|_state
operator|&=
operator|~
name|flag
block|; }
name|void
name|close
argument_list|()
block|;
name|int
name|is_open
argument_list|()
block|;
name|int
name|readable
argument_list|()
block|;
name|int
name|writable
argument_list|()
block|;
endif|#
directive|endif
comment|// Used to initialize standard streams. Not needed in this implementation.
name|class
name|Init
block|{
name|public
operator|:
name|Init
argument_list|()
block|{ }
block|}
block|;
name|protected
operator|:
specifier|inline
name|ios
argument_list|(
name|streambuf
operator|*
name|sb
operator|=
literal|0
argument_list|,
name|ostream
operator|*
name|tie_to
operator|=
literal|0
argument_list|)
block|;
specifier|inline
name|virtual
operator|~
name|ios
argument_list|()
block|;
specifier|inline
name|void
name|init
argument_list|(
name|streambuf
operator|*
name|sb
argument_list|,
name|ostream
operator|*
name|tie
operator|=
literal|0
argument_list|)
block|; }
decl_stmt|;
if|#
directive|if
name|__GNUG__
operator|==
literal|1
typedef|typedef
name|int
name|_seek_dir
typedef|;
else|#
directive|else
typedef|typedef
name|ios
operator|::
name|seek_dir
name|_seek_dir
expr_stmt|;
endif|#
directive|endif
comment|// Magic numbers and bits for the _flags field.
comment|// The magic numbers use the high-order bits of _flags;
comment|// the remaining bits are abailable for variable flags.
comment|// Note: The magic numbers must all be negative if stdio
comment|// emulation is desired.
comment|// A streammarker remembers a position in a buffer.
comment|// You are guaranteed to be able to seek back to it if it is saving().
name|class
name|streammarker
range|:
name|private
name|_IO_marker
block|{
name|friend
name|class
name|streambuf
block|;
name|void
name|set_offset
argument_list|(
argument|int offset
argument_list|)
block|{
name|_pos
operator|=
name|offset
block|; }
name|public
operator|:
name|streammarker
argument_list|(
name|streambuf
operator|*
name|sb
argument_list|)
block|;
operator|~
name|streammarker
argument_list|()
block|;
name|int
name|saving
argument_list|()
block|{
return|return
literal|1
return|;
block|}
name|int
name|delta
argument_list|(
name|streammarker
operator|&
argument_list|)
block|;
name|int
name|delta
argument_list|()
block|; }
decl_stmt|;
name|struct
name|streambuf
range|:
name|public
name|_IO_FILE
block|{
comment|// protected??
name|friend
name|class
name|ios
block|;
name|friend
name|class
name|istream
block|;
name|friend
name|class
name|ostream
block|;
name|friend
name|class
name|streammarker
block|;
specifier|const
name|void
operator|*
operator|&
name|_vtable
argument_list|()
block|{
return|return
operator|*
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|protected
operator|:
specifier|static
name|streambuf
operator|*
name|_list_all
block|;
comment|/* List of open streambufs. */
name|_IO_FILE
operator|*
operator|&
name|xchain
argument_list|()
block|{
return|return
name|_chain
return|;
block|}
name|void
name|_un_link
argument_list|()
block|;
name|void
name|_link_in
argument_list|()
block|;
name|char
operator|*
name|gptr
argument_list|()
specifier|const
block|{
return|return
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
operator|?
name|_IO_save_base
operator|:
name|_IO_read_ptr
return|;
block|}
name|char
operator|*
name|pptr
argument_list|()
specifier|const
block|{
return|return
name|_IO_write_ptr
return|;
block|}
name|char
operator|*
name|egptr
argument_list|()
specifier|const
block|{
return|return
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
condition|?
name|_IO_save_end
else|:
name|_IO_read_end
return|;
block|}
name|char
operator|*
name|epptr
argument_list|()
specifier|const
block|{
return|return
name|_IO_write_end
return|;
block|}
name|char
operator|*
name|pbase
argument_list|()
specifier|const
block|{
return|return
name|_IO_write_base
return|;
block|}
name|char
operator|*
name|eback
argument_list|()
specifier|const
block|{
return|return
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
condition|?
name|_IO_save_base
else|:
name|_IO_read_base
return|;
block|}
name|char
operator|*
name|base
argument_list|()
specifier|const
block|{
return|return
name|_IO_buf_base
return|;
block|}
name|char
operator|*
name|ebuf
argument_list|()
specifier|const
block|{
return|return
name|_IO_buf_end
return|;
block|}
name|int
name|blen
argument_list|()
specifier|const
block|{
return|return
name|_IO_buf_end
operator|-
name|_IO_buf_base
return|;
block|}
name|void
name|xput_char
argument_list|(
argument|char c
argument_list|)
block|{
operator|*
name|_IO_write_ptr
operator|++
operator|=
name|c
block|; }
name|int
name|xflags
argument_list|()
block|{
return|return
name|_IO_file_flags
return|;
block|}
name|int
name|xflags
argument_list|(
argument|int f
argument_list|)
block|{
name|int
name|fl
operator|=
name|_IO_file_flags
block|;
name|_IO_file_flags
operator|=
name|f
block|;
return|return
name|fl
return|;
block|}
name|void
name|xsetflags
argument_list|(
argument|int f
argument_list|)
block|{
name|_IO_file_flags
operator||=
name|f
block|; }
name|void
name|xsetflags
argument_list|(
argument|int f
argument_list|,
argument|int mask
argument_list|)
block|{
name|_IO_file_flags
operator|=
operator|(
name|_IO_file_flags
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|f
operator|&
name|mask
operator|)
block|; }
name|void
name|gbump
argument_list|(
argument|int n
argument_list|)
block|{
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
condition|?
operator|(
name|_IO_save_base
operator|+=
name|n
operator|)
else|:
operator|(
name|_IO_read_ptr
operator|+=
name|n
operator|)
block|;}
name|void
name|pbump
argument_list|(
argument|int n
argument_list|)
block|{
name|_IO_write_ptr
operator|+=
name|n
block|; }
name|void
name|setb
argument_list|(
argument|char* b
argument_list|,
argument|char* eb
argument_list|,
argument|int a=
literal|0
argument_list|)
block|;
name|void
name|setp
argument_list|(
argument|char* p
argument_list|,
argument|char* ep
argument_list|)
block|{
name|_IO_write_base
operator|=
name|_IO_write_ptr
operator|=
name|p
block|;
name|_IO_write_end
operator|=
name|ep
block|; }
name|void
name|setg
argument_list|(
argument|char* eb
argument_list|,
argument|char* g
argument_list|,
argument|char *eg
argument_list|)
block|{
if|if
condition|(
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
condition|)
name|_IO_free_backup_area
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|_IO_read_base
operator|=
name|eb
block|;
name|_IO_read_ptr
operator|=
name|g
block|;
name|_IO_read_end
operator|=
name|eg
block|; }
name|char
operator|*
name|shortbuf
argument_list|()
block|{
return|return
name|_shortbuf
return|;
block|}
name|int
name|in_backup
parameter_list|()
block|{
return|return
name|_flags
operator|&
name|_IO_IN_BACKUP
return|;
block|}
comment|// The start of the main get area:  FIXME:  wrong for write-mode filebuf?
name|char
modifier|*
name|Gbase
parameter_list|()
block|{
return|return
name|in_backup
argument_list|()
condition|?
name|_IO_save_base
else|:
name|_IO_read_base
return|;
block|}
comment|// The end of the main get area:
name|char
modifier|*
name|eGptr
parameter_list|()
block|{
return|return
name|in_backup
argument_list|()
condition|?
name|_IO_save_end
else|:
name|_IO_read_end
return|;
block|}
comment|// The start of the backup area:
name|char
modifier|*
name|Bbase
parameter_list|()
block|{
return|return
name|in_backup
argument_list|()
condition|?
name|_IO_read_base
else|:
name|_IO_save_base
return|;
block|}
name|char
modifier|*
name|Bptr
parameter_list|()
block|{
return|return
name|_IO_backup_base
return|;
block|}
comment|// The end of the backup area:
name|char
modifier|*
name|eBptr
parameter_list|()
block|{
return|return
name|in_backup
argument_list|()
condition|?
name|_IO_read_end
else|:
name|_IO_save_end
return|;
block|}
name|char
modifier|*
name|Nbase
parameter_list|()
block|{
return|return
name|_IO_save_base
return|;
block|}
name|char
modifier|*
name|eNptr
parameter_list|()
block|{
return|return
name|_IO_save_end
return|;
block|}
name|int
name|have_backup
parameter_list|()
block|{
return|return
name|_IO_save_base
operator|!=
name|NULL
return|;
block|}
name|int
name|have_markers
parameter_list|()
block|{
return|return
name|_markers
operator|!=
name|NULL
return|;
block|}
name|void
name|free_backup_area
parameter_list|()
function_decl|;
name|void
name|unsave_markers
parameter_list|()
function_decl|;
comment|// Make all streammarkers !saving().
name|int
name|put_mode
parameter_list|()
block|{
return|return
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
return|;
block|}
name|int
name|switch_to_get_mode
parameter_list|()
function_decl|;
name|streambuf
argument_list|(
argument|int flags=
literal|0
argument_list|)
empty_stmt|;
name|public
label|:
specifier|static
name|int
name|flush_all
parameter_list|()
function_decl|;
specifier|static
name|void
name|flush_all_linebuffered
parameter_list|()
function_decl|;
comment|// Flush all line buffered files.
name|virtual
operator|~
name|streambuf
argument_list|()
expr_stmt|;
name|virtual
name|int
name|overflow
parameter_list|(
name|int
name|c
init|=
name|EOF
parameter_list|)
function_decl|;
comment|// Leave public for now
name|virtual
name|int
name|underflow
parameter_list|()
function_decl|;
comment|// Leave public for now
name|virtual
name|int
name|uflow
parameter_list|()
function_decl|;
comment|// Leave public for now
name|virtual
name|int
name|pbackfail
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
comment|//    virtual int showmany ();
name|virtual
name|streamsize
name|xsputn
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|streamsize
name|n
parameter_list|)
function_decl|;
name|virtual
name|streamsize
name|xsgetn
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|streamsize
name|n
parameter_list|)
function_decl|;
name|virtual
name|streampos
name|seekoff
parameter_list|(
name|streamoff
parameter_list|,
name|_seek_dir
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
function_decl|;
name|virtual
name|streampos
name|seekpos
parameter_list|(
name|streampos
name|pos
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
function_decl|;
name|streampos
name|pubseekoff
parameter_list|(
name|streamoff
name|o
parameter_list|,
name|_seek_dir
name|d
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
block|{
return|return
name|_IO_seekoff
argument_list|(
name|this
argument_list|,
name|o
argument_list|,
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
name|streampos
name|pubseekpos
parameter_list|(
name|streampos
name|pos
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
block|{
return|return
name|_IO_seekpos
argument_list|(
name|this
argument_list|,
name|pos
argument_list|,
name|mode
argument_list|)
return|;
block|}
name|streampos
name|sseekoff
parameter_list|(
name|streamoff
parameter_list|,
name|_seek_dir
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
function_decl|;
name|streampos
name|sseekpos
parameter_list|(
name|streampos
name|pos
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
function_decl|;
name|virtual
name|streambuf
modifier|*
name|setbuf
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|virtual
name|int
name|sync
parameter_list|()
function_decl|;
name|virtual
name|int
name|doallocate
parameter_list|()
function_decl|;
name|int
name|seekmark
parameter_list|(
name|streammarker
modifier|&
name|mark
parameter_list|,
name|int
name|delta
init|=
literal|0
parameter_list|)
function_decl|;
name|int
name|sputbackc
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|int
name|sungetc
parameter_list|()
function_decl|;
name|int
name|unbuffered
parameter_list|()
block|{
return|return
name|_flags
operator|&
name|_IO_UNBUFFERED
condition|?
literal|1
else|:
literal|0
return|;
block|}
name|int
name|linebuffered
parameter_list|()
block|{
return|return
name|_flags
operator|&
name|_IO_LINE_BUF
condition|?
literal|1
else|:
literal|0
return|;
block|}
name|void
name|unbuffered
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
condition|)
name|_flags
operator||=
name|_IO_UNBUFFERED
expr_stmt|;
else|else
name|_flags
operator|&=
operator|~
name|_IO_UNBUFFERED
expr_stmt|;
block|}
name|void
name|linebuffered
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
condition|)
name|_flags
operator||=
name|_IO_LINE_BUF
expr_stmt|;
else|else
name|_flags
operator|&=
operator|~
name|_IO_LINE_BUF
expr_stmt|;
block|}
name|int
name|allocate
parameter_list|()
block|{
comment|// For AT&T compatibility
if|if
condition|(
name|base
argument_list|()
operator|||
name|unbuffered
argument_list|()
condition|)
return|return
literal|0
return|;
else|else
return|return
name|doallocate
argument_list|()
return|;
block|}
comment|// Allocate a buffer if needed; use _shortbuf if appropriate.
name|void
name|allocbuf
parameter_list|()
block|{
if|if
condition|(
name|base
argument_list|()
operator|==
name|NULL
condition|)
name|doallocbuf
argument_list|()
expr_stmt|;
block|}
name|void
name|doallocbuf
parameter_list|()
function_decl|;
name|int
name|in_avail
parameter_list|()
block|{
return|return
name|_IO_read_end
operator|-
name|_IO_read_ptr
return|;
block|}
name|int
name|out_waiting
parameter_list|()
block|{
return|return
name|_IO_write_ptr
operator|-
name|_IO_write_base
return|;
block|}
name|streamsize
name|sputn
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|streamsize
name|n
parameter_list|)
block|{
return|return
name|xsputn
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
return|;
block|}
name|streamsize
name|padn
parameter_list|(
name|char
name|pad
parameter_list|,
name|streamsize
name|n
parameter_list|)
block|{
return|return
name|_IO_padn
argument_list|(
name|this
argument_list|,
name|pad
argument_list|,
name|n
argument_list|)
return|;
block|}
name|streamsize
name|sgetn
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|streamsize
name|n
parameter_list|)
block|{
return|return
name|_IO_sgetn
argument_list|(
name|this
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
return|;
block|}
name|int
name|ignore
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|int
name|get_column
parameter_list|()
function_decl|;
name|int
name|set_column
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|long
name|sgetline
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|_IO_size_t
name|n
parameter_list|,
name|char
name|delim
parameter_list|,
name|int
name|putback_delim
parameter_list|)
function_decl|;
name|int
name|sputc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|_IO_putc
argument_list|(
name|c
argument_list|,
name|this
argument_list|)
return|;
block|}
name|int
name|sbumpc
parameter_list|()
block|{
return|return
name|_IO_getc
argument_list|(
name|this
argument_list|)
return|;
block|}
name|int
name|sgetc
parameter_list|()
block|{
return|return
name|_IO_peekc
argument_list|(
name|this
argument_list|)
return|;
block|}
name|int
name|snextc
parameter_list|()
block|{
if|if
condition|(
name|_IO_read_ptr
operator|>=
name|_IO_read_end
operator|&&
name|__underflow
argument_list|(
name|this
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
else|else
return|return
name|_IO_read_ptr
operator|++
operator|,
name|sgetc
argument_list|()
return|;
block|}
name|void
name|stossc
parameter_list|()
block|{
if|if
condition|(
name|_IO_read_ptr
operator|<
name|_IO_read_end
condition|)
name|_IO_read_ptr
operator|++
expr_stmt|;
block|}
name|int
name|vscan
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt0
parameter_list|,
name|_IO_va_list
name|ap
parameter_list|,
name|ios
modifier|*
name|stream
init|=
name|NULL
parameter_list|)
function_decl|;
name|int
name|scan
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt0
modifier|...
parameter_list|)
function_decl|;
name|int
name|vform
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt0
parameter_list|,
name|_IO_va_list
name|ap
parameter_list|)
function_decl|;
name|int
name|form
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt0
modifier|...
parameter_list|)
function_decl|;
if|#
directive|if
literal|0
comment|/* Work in progress */
block|int column();
comment|// Current column number (of put pointer). -1 is unknown.
block|void column(int c);
comment|// Set column number of put pointer to c.
endif|#
directive|endif
name|virtual
name|streamsize
name|sys_read
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|streamsize
name|size
parameter_list|)
function_decl|;
name|virtual
name|streamsize
name|sys_write
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|streamsize
parameter_list|)
function_decl|;
name|virtual
name|streampos
name|sys_seek
parameter_list|(
name|streamoff
parameter_list|,
name|_seek_dir
parameter_list|)
function_decl|;
name|virtual
name|int
name|sys_close
parameter_list|()
function_decl|;
name|virtual
name|int
name|sys_stat
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|// Actually, a (struct stat*)
if|#
directive|if
name|_G_IO_IO_FILE_VERSION
operator|==
literal|0x20001
name|virtual
name|int
name|showmanyc
parameter_list|()
function_decl|;
name|virtual
name|void
name|imbue
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
block|}
end_extern

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// A backupbuf is a streambuf with full backup and savepoints on reading.
end_comment

begin_comment
comment|// All standard streambufs in the GNU iostream library are backupbufs.
end_comment

begin_decl_stmt
name|class
name|filebuf
range|:
name|public
name|streambuf
block|{
name|protected
operator|:
name|void
name|init
argument_list|()
block|;
name|public
operator|:
specifier|static
specifier|const
name|int
name|openprot
block|;
comment|// Non-ANSI AT&T-ism:  Default open protection.
name|filebuf
argument_list|()
block|;
name|filebuf
argument_list|(
argument|int fd
argument_list|)
block|;
name|filebuf
argument_list|(
argument|int fd
argument_list|,
argument|char* p
argument_list|,
argument|int len
argument_list|)
block|;
if|#
directive|if
operator|!
name|_IO_UNIFIED_JUMPTABLES
specifier|static
name|filebuf
operator|*
name|__new
argument_list|()
block|;
endif|#
directive|endif
operator|~
name|filebuf
argument_list|()
block|;
name|filebuf
operator|*
name|attach
argument_list|(
argument|int fd
argument_list|)
block|;
name|filebuf
operator|*
name|open
argument_list|(
specifier|const
name|char
operator|*
name|filename
argument_list|,
specifier|const
name|char
operator|*
name|mode
argument_list|)
block|;
name|filebuf
operator|*
name|open
argument_list|(
argument|const char *filename
argument_list|,
argument|ios::openmode mode
argument_list|,
argument|int prot =
literal|0664
argument_list|)
block|;
name|virtual
name|int
name|underflow
argument_list|()
block|;
name|virtual
name|int
name|overflow
argument_list|(
argument|int c = EOF
argument_list|)
block|;
name|int
name|is_open
argument_list|()
specifier|const
block|{
return|return
name|_fileno
operator|>=
literal|0
return|;
block|}
name|int
name|fd
argument_list|()
specifier|const
block|{
return|return
name|is_open
argument_list|()
operator|?
name|_fileno
operator|:
name|EOF
return|;
block|}
name|filebuf
operator|*
name|close
argument_list|()
block|;
name|virtual
name|int
name|doallocate
argument_list|()
block|;
name|virtual
name|streampos
name|seekoff
argument_list|(
argument|streamoff
argument_list|,
argument|_seek_dir
argument_list|,
argument|int mode=ios::in|ios::out
argument_list|)
block|;
name|virtual
name|streambuf
operator|*
name|setbuf
argument_list|(
argument|char* p
argument_list|,
argument|int len
argument_list|)
block|;
name|streamsize
name|xsputn
argument_list|(
argument|const char* s
argument_list|,
argument|streamsize n
argument_list|)
block|;
name|streamsize
name|xsgetn
argument_list|(
argument|char* s
argument_list|,
argument|streamsize n
argument_list|)
block|;
name|virtual
name|int
name|sync
argument_list|()
block|;
name|protected
operator|:
comment|// See documentation in filebuf.C.
comment|//    virtual int pbackfail(int c);
name|int
name|is_reading
argument_list|()
block|{
return|return
name|eback
argument_list|()
operator|!=
name|egptr
argument_list|()
return|;
block|}
name|char
operator|*
name|cur_ptr
argument_list|()
block|{
return|return
name|is_reading
argument_list|()
condition|?
name|gptr
argument_list|()
else|:
name|pptr
argument_list|()
return|;
block|}
comment|/* System's idea of pointer */
name|char
operator|*
name|file_ptr
argument_list|()
block|{
return|return
name|eGptr
argument_list|()
return|;
block|}
comment|// Low-level operations (Usually invoke system calls.)
name|virtual
name|streamsize
name|sys_read
argument_list|(
argument|char* buf
argument_list|,
argument|streamsize size
argument_list|)
block|;
name|virtual
name|streampos
name|sys_seek
argument_list|(
name|streamoff
argument_list|,
name|_seek_dir
argument_list|)
block|;
name|virtual
name|streamsize
name|sys_write
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|streamsize
argument_list|)
block|;
name|virtual
name|int
name|sys_stat
argument_list|(
name|void
operator|*
argument_list|)
block|;
comment|// Actually, a (struct stat*)
name|virtual
name|int
name|sys_close
argument_list|()
block|;
if|#
directive|if
literal|0
block|virtual uflow;     virtual showmany;
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|inline
name|void
name|ios
operator|::
name|init
argument_list|(
argument|streambuf* sb
argument_list|,
argument|ostream* tie_to
argument_list|)
block|{
name|_state
operator|=
name|sb
operator|?
name|ios
operator|::
name|goodbit
operator|:
name|ios
operator|::
name|badbit
block|;
name|_exceptions
operator|=
literal|0
block|;
name|_strbuf
operator|=
name|sb
block|;
name|_tie
operator|=
name|tie_to
block|;
name|_width
operator|=
literal|0
block|;
name|_fill
operator|=
literal|' '
block|;
ifdef|#
directive|ifdef
name|_IO_NEW_STREAMS
name|_flags
operator|=
name|ios
operator|::
name|skipws
operator||
name|ios
operator|::
name|dec
block|;
else|#
directive|else
name|_flags
operator|=
name|ios
operator|::
name|skipws
operator||
name|ios
operator|::
name|dec
operator||
name|ios
operator|::
name|dont_close
block|;
endif|#
directive|endif
name|_precision
operator|=
literal|6
block|;
name|_arrays
operator|=
literal|0
block|; }
specifier|inline
name|ios
operator|::
name|ios
argument_list|(
argument|streambuf* sb
argument_list|,
argument|ostream* tie_to
argument_list|)
block|{
name|init
argument_list|(
name|sb
argument_list|,
name|tie_to
argument_list|)
block|; }
specifier|inline
name|ios
operator|::
operator|~
name|ios
argument_list|()
block|{
ifndef|#
directive|ifndef
name|_IO_NEW_STREAMS
if|if
condition|(
operator|!
operator|(
name|_flags
operator|&
operator|(
name|unsigned
name|int
operator|)
name|ios
operator|::
name|dont_close
operator|)
condition|)
name|delete
name|rdbuf
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|// It is safe to use naked operator delete[] as we know elements have no
comment|// dtor, and g++ does not add a new[] cookie for such cases.
name|operator
name|delete
index|[]
operator|(
name|_arrays
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|} }
comment|// extern "C++"
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _STREAMBUF_H */
end_comment

end_unit

