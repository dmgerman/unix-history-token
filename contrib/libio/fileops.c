begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.    This file is part of the GNU IO Library.    Written by Per Bothner<bothner@cygnus.com>.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|open
parameter_list|(
name|Name
parameter_list|,
name|Flags
parameter_list|,
name|Prot
parameter_list|)
value|__open (Name, Flags, Prot)
end_define

begin_define
define|#
directive|define
name|close
parameter_list|(
name|FD
parameter_list|)
value|__close (FD)
end_define

begin_define
define|#
directive|define
name|fstat
parameter_list|(
name|FD
parameter_list|,
name|Statbuf
parameter_list|)
value|__fstat (FD, Statbuf)
end_define

begin_define
define|#
directive|define
name|lseek
parameter_list|(
name|FD
parameter_list|,
name|Offset
parameter_list|,
name|Whence
parameter_list|)
value|__lseek (FD, Offset, Whence)
end_define

begin_define
define|#
directive|define
name|read
parameter_list|(
name|FD
parameter_list|,
name|Buf
parameter_list|,
name|NBytes
parameter_list|)
value|__read (FD, Buf, NBytes)
end_define

begin_define
define|#
directive|define
name|write
parameter_list|(
name|FD
parameter_list|,
name|Buf
parameter_list|,
name|NBytes
parameter_list|)
value|__write (FD, Buf, NBytes)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* An fstream can be in at most one of put mode, get mode, or putback mode.    Putback mode is a variant of get mode.     In a filebuf, there is only one current position, instead of two    separate get and put pointers.  In get mode, the current position    is that of gptr(); in put mode that of pptr().     The position in the buffer that corresponds to the position    in external file system is normally _IO_read_end, except in putback    mode, when it is _IO_save_end.    If the field _fb._offset is>= 0, it gives the offset in    the file as a whole corresponding to eGptr(). (?)     PUT MODE:    If a filebuf is in put mode, then all of _IO_read_ptr, _IO_read_end,    and _IO_read_base are equal to each other.  These are usually equal    to _IO_buf_base, though not necessarily if we have switched from    get mode to put mode.  (The reason is to maintain the invariant    that _IO_read_end corresponds to the external file position.)    _IO_write_base is non-NULL and usually equal to _IO_base_base.    We also have _IO_write_end == _IO_buf_end, but only in fully buffered mode.    The un-flushed character are those between _IO_write_base and _IO_write_ptr.     GET MODE:    If a filebuf is in get or putback mode, eback() != egptr().    In get mode, the unread characters are between gptr() and egptr().    The OS file position corresponds to that of egptr().     PUTBACK MODE:    Putback mode is used to remember "excess" characters that have    been sputbackc'd in a separate putback buffer.    In putback mode, the get buffer points to the special putback buffer.    The unread characters are the characters between gptr() and egptr()    in the putback buffer, as well as the area between save_gptr()    and save_egptr(), which point into the original reserve buffer.    (The pointers save_gptr() and save_egptr() are the values    of gptr() and egptr() at the time putback mode was entered.)    The OS position corresponds to that of save_egptr().     LINE BUFFERED OUTPUT:    During line buffered output, _IO_write_base==base()&& epptr()==base().    However, ptr() may be anywhere between base() and ebuf().    This forces a call to filebuf::overflow(int C) on every put.    If there is more space in the buffer, and C is not a '\n',    then C is inserted, and pptr() incremented.     UNBUFFERED STREAMS:    If a filebuf is unbuffered(), the _shortbuf[1] is used as the buffer. */
end_comment

begin_define
define|#
directive|define
name|CLOSED_FILEBUF_FLAGS
define|\
value|(_IO_IS_FILEBUF+_IO_NO_READS+_IO_NO_WRITES+_IO_TIED_PUT_GET)
end_define

begin_function
name|void
name|_IO_file_init
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
comment|/* POSIX.1 allows another file handle to be used to change the position      of our file descriptor.  Hence we actually don't know the actual      position before we do the first fseek (and until a following fflush). */
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_BAD
expr_stmt|;
name|fp
operator|->
name|_IO_file_flags
operator||=
name|CLOSED_FILEBUF_FLAGS
expr_stmt|;
name|_IO_link_in
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_fileno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_IO_file_close_it
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|write_status
decl_stmt|,
name|close_status
decl_stmt|;
if|if
condition|(
operator|!
name|_IO_file_is_open
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
name|write_status
operator|=
name|_IO_do_flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|_IO_unsave_markers
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|close_status
operator|=
name|_IO_SYSCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Free buffer. */
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_IO_un_link
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_flags
operator|=
name|_IO_MAGIC
operator||
name|CLOSED_FILEBUF_FLAGS
expr_stmt|;
name|fp
operator|->
name|_fileno
operator|=
name|EOF
expr_stmt|;
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_BAD
expr_stmt|;
return|return
name|close_status
condition|?
name|close_status
else|:
name|write_status
return|;
block|}
end_function

begin_function
name|void
name|_IO_file_finish
parameter_list|(
name|fp
parameter_list|,
name|dummy
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|dummy
decl_stmt|;
block|{
if|if
condition|(
name|_IO_file_is_open
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|_IO_do_flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_DELETE_DONT_CLOSE
operator|)
condition|)
name|_IO_SYSCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|_IO_default_finish
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|_IO_FILE
modifier|*
name|_IO_file_fopen
parameter_list|(
name|fp
parameter_list|,
name|filename
parameter_list|,
name|mode
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|oflags
init|=
literal|0
decl_stmt|,
name|omode
decl_stmt|;
name|int
name|read_write
decl_stmt|,
name|fdesc
decl_stmt|;
name|int
name|oprot
init|=
literal|0666
decl_stmt|;
if|if
condition|(
name|_IO_file_is_open
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
operator|*
name|mode
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
name|omode
operator|=
name|O_RDONLY
expr_stmt|;
name|read_write
operator|=
name|_IO_NO_WRITES
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|omode
operator|=
name|O_WRONLY
expr_stmt|;
name|oflags
operator|=
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
name|read_write
operator|=
name|_IO_NO_READS
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|omode
operator|=
name|O_WRONLY
expr_stmt|;
name|oflags
operator|=
name|O_CREAT
operator||
name|O_APPEND
expr_stmt|;
name|read_write
operator|=
name|_IO_NO_READS
operator||
name|_IO_IS_APPENDING
expr_stmt|;
break|break;
default|default:
name|__set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
operator|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'b'
operator|&&
name|mode
index|[
literal|1
index|]
operator|==
literal|'+'
operator|)
condition|)
block|{
name|omode
operator|=
name|O_RDWR
expr_stmt|;
name|read_write
operator|&=
name|_IO_IS_APPENDING
expr_stmt|;
block|}
name|fdesc
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|omode
operator||
name|oflags
argument_list|,
name|oprot
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdesc
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|fp
operator|->
name|_fileno
operator|=
name|fdesc
expr_stmt|;
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
name|read_write
argument_list|,
name|_IO_NO_READS
operator|+
name|_IO_NO_WRITES
operator|+
name|_IO_IS_APPENDING
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_write
operator|&
name|_IO_IS_APPENDING
condition|)
if|if
condition|(
name|_IO_SEEKOFF
argument_list|(
name|fp
argument_list|,
operator|(
name|_IO_off_t
operator|)
literal|0
argument_list|,
name|_IO_seek_end
argument_list|,
name|_IOS_INPUT
operator||
name|_IOS_OUTPUT
argument_list|)
operator|==
name|_IO_pos_BAD
operator|&&
name|errno
operator|!=
name|ESPIPE
condition|)
return|return
name|NULL
return|;
name|_IO_link_in
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|_IO_FILE
modifier|*
name|_IO_file_attach
parameter_list|(
name|fp
parameter_list|,
name|fd
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|_IO_file_is_open
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|NULL
return|;
name|fp
operator|->
name|_fileno
operator|=
name|fd
expr_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
operator|(
name|_IO_NO_READS
operator|+
name|_IO_NO_WRITES
operator|)
expr_stmt|;
name|fp
operator|->
name|_flags
operator||=
name|_IO_DELETE_DONT_CLOSE
expr_stmt|;
comment|/* Get the current position of the file. */
comment|/* We have to do that since that may be junk. */
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_BAD
expr_stmt|;
if|if
condition|(
name|_IO_SEEKOFF
argument_list|(
name|fp
argument_list|,
operator|(
name|_IO_off_t
operator|)
literal|0
argument_list|,
name|_IO_seek_cur
argument_list|,
name|_IOS_INPUT
operator||
name|_IOS_OUTPUT
argument_list|)
operator|==
name|_IO_pos_BAD
operator|&&
name|errno
operator|!=
name|ESPIPE
condition|)
return|return
name|NULL
return|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|_IO_FILE
modifier|*
name|_IO_file_setbuf
parameter_list|(
name|fp
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|_IO_ssize_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|_IO_default_setbuf
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Write TO_DO bytes from DATA to FP.    Then mark FP as having empty buffers. */
end_comment

begin_function
name|int
name|_IO_do_write
parameter_list|(
name|fp
parameter_list|,
name|data
parameter_list|,
name|to_do
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|to_do
decl_stmt|;
block|{
name|_IO_size_t
name|count
decl_stmt|;
if|if
condition|(
name|to_do
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_IS_APPENDING
condition|)
comment|/* On a system without a proper O_APPEND implementation,        you would need to sys_seek(0, SEEK_END) here, but it        is not needed nor desirable for Unix- or Posix-like systems.        Instead, just indicate that offset (before and after) is        unpredictable. */
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_BAD
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|_IO_read_end
operator|!=
name|fp
operator|->
name|_IO_write_base
condition|)
block|{
name|_IO_pos_t
name|new_pos
init|=
name|_IO_SYSSEEK
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_write_base
operator|-
name|fp
operator|->
name|_IO_read_end
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_pos
operator|==
name|_IO_pos_BAD
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_offset
operator|=
name|new_pos
expr_stmt|;
block|}
name|count
operator|=
name|_IO_SYSWRITE
argument_list|(
name|fp
argument_list|,
name|data
argument_list|,
name|to_do
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_cur_column
condition|)
name|fp
operator|->
name|_cur_column
operator|=
name|_IO_adjust_column
argument_list|(
name|fp
operator|->
name|_cur_column
operator|-
literal|1
argument_list|,
name|data
argument_list|,
name|to_do
argument_list|)
operator|+
literal|1
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
operator|(
operator|(
name|fp
operator|->
name|_flags
operator|&
operator|(
name|_IO_LINE_BUF
operator|+
name|_IO_UNBUFFERED
operator|)
operator|)
condition|?
name|fp
operator|->
name|_IO_buf_base
else|:
name|fp
operator|->
name|_IO_buf_end
operator|)
expr_stmt|;
return|return
name|count
operator|!=
name|to_do
condition|?
name|EOF
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_underflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|_IO_ssize_t
name|count
decl_stmt|;
if|#
directive|if
literal|0
comment|/* SysV does not make this test; take it out for compatibility */
block|if (fp->_flags& _IO_EOF_SEEN)     return (EOF);
endif|#
directive|endif
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_READS
condition|)
block|{
name|__set_errno
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
return|;
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|==
name|NULL
condition|)
name|_IO_doallocbuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Flush all line buffered files before reading. */
comment|/* FIXME This can/should be moved to genops ?? */
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
operator|(
name|_IO_LINE_BUF
operator||
name|_IO_UNBUFFERED
operator|)
condition|)
name|_IO_flush_all_linebuffered
argument_list|()
expr_stmt|;
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* This is very tricky. We have to adjust those      pointers before we call _IO_SYSREAD () since      we may longjump () out while waiting for      input. Those pointers may be screwed up. H.J. */
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
name|count
operator|=
name|_IO_SYSREAD
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|fp
operator|->
name|_flags
operator||=
name|_IO_EOF_SEEN
expr_stmt|;
else|else
name|fp
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
operator|,
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_read_end
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|fp
operator|->
name|_offset
operator|!=
name|_IO_pos_BAD
condition|)
name|_IO_pos_adjust
argument_list|(
name|fp
operator|->
name|_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_overflow
parameter_list|(
name|f
parameter_list|,
name|ch
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|_flags
operator|&
name|_IO_NO_WRITES
condition|)
comment|/* SET ERROR */
block|{
name|f
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
expr_stmt|;
name|__set_errno
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
return|return
name|EOF
return|;
block|}
comment|/* If currently reading or no buffer allocated. */
if|if
condition|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Allocate a buffer if needed. */
if|if
condition|(
name|f
operator|->
name|_IO_write_base
operator|==
literal|0
condition|)
block|{
name|_IO_doallocbuf
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|_IO_setg
argument_list|(
name|f
argument_list|,
name|f
operator|->
name|_IO_buf_base
argument_list|,
name|f
operator|->
name|_IO_buf_base
argument_list|,
name|f
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise must be currently reading. 	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end, 	 logically slide the buffer forwards one block (by setting the 	 read pointers to all point at the beginning of the block).  This 	 makes room for subsequent output. 	 Otherwise, set the read pointers to _IO_read_end (leaving that 	 alone, so it can continue to correspond to the external position). */
if|if
condition|(
name|f
operator|->
name|_IO_read_ptr
operator|==
name|f
operator|->
name|_IO_buf_end
condition|)
name|f
operator|->
name|_IO_read_end
operator|=
name|f
operator|->
name|_IO_read_ptr
operator|=
name|f
operator|->
name|_IO_buf_base
expr_stmt|;
name|f
operator|->
name|_IO_write_ptr
operator|=
name|f
operator|->
name|_IO_read_ptr
expr_stmt|;
name|f
operator|->
name|_IO_write_base
operator|=
name|f
operator|->
name|_IO_write_ptr
expr_stmt|;
name|f
operator|->
name|_IO_write_end
operator|=
name|f
operator|->
name|_IO_buf_end
expr_stmt|;
name|f
operator|->
name|_IO_read_base
operator|=
name|f
operator|->
name|_IO_read_ptr
operator|=
name|f
operator|->
name|_IO_read_end
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|_flags
operator|&
operator|(
name|_IO_LINE_BUF
operator|+
name|_IO_UNBUFFERED
operator|)
condition|)
name|f
operator|->
name|_IO_write_end
operator|=
name|f
operator|->
name|_IO_write_ptr
expr_stmt|;
name|f
operator|->
name|_flags
operator||=
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|_IO_do_flush
argument_list|(
name|f
argument_list|)
return|;
if|if
condition|(
name|f
operator|->
name|_IO_write_ptr
operator|==
name|f
operator|->
name|_IO_buf_end
condition|)
comment|/* Buffer is really full */
if|if
condition|(
name|_IO_do_flush
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
operator|*
name|f
operator|->
name|_IO_write_ptr
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_UNBUFFERED
operator|)
operator|||
operator|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
operator|)
operator|&&
name|ch
operator|==
literal|'\n'
operator|)
condition|)
if|if
condition|(
name|_IO_do_flush
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
return|return
operator|(
name|unsigned
name|char
operator|)
name|ch
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_sync
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|_IO_size_t
name|delta
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|_IO_cleanup_region_start
argument_list|(
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
operator|)
name|_IO_funlockfile
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|_IO_flockfile
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/*    char* ptr = cur_ptr(); */
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_write_base
condition|)
if|if
condition|(
name|_IO_do_flush
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
name|delta
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TODO
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|delta
operator|-=
name|eGptr
argument_list|()
operator|-
name|Gbase
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_IO_off_t
name|new_pos
init|=
name|_IO_SYSSEEK
argument_list|(
name|fp
argument_list|,
name|delta
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_pos
operator|!=
operator|(
name|_IO_off_t
operator|)
name|EOF
condition|)
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|ESPIPE
elseif|else
if|if
condition|(
name|errno
operator|==
name|ESPIPE
condition|)
empty_stmt|;
comment|/* Ignore error from unseekable devices. */
endif|#
directive|endif
else|else
name|retval
operator|=
name|EOF
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|EOF
condition|)
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_BAD
expr_stmt|;
comment|/* FIXME: Cleanup - can this be shared? */
comment|/*    setg(base(), ptr, ptr); */
name|_IO_cleanup_region_end
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|_IO_pos_t
name|_IO_file_seekoff
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|,
name|dir
parameter_list|,
name|mode
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_off_t
name|offset
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|_IO_pos_t
name|result
decl_stmt|;
name|_IO_off_t
name|delta
decl_stmt|,
name|new_offset
decl_stmt|;
name|long
name|count
decl_stmt|;
comment|/* POSIX.1 8.2.3.7 says that after a call the fflush() the file      offset of the underlying file must be exact.  */
name|int
name|must_be_exact
init|=
operator|(
name|fp
operator|->
name|_IO_read_base
operator|==
name|fp
operator|->
name|_IO_read_end
operator|&&
name|fp
operator|->
name|_IO_write_base
operator|==
name|fp
operator|->
name|_IO_write_ptr
operator|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|dir
operator|=
name|_IO_seek_cur
operator|,
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Don't move any pointers. */
comment|/* Flush unwritten characters.      (This may do an unneeded write if we seek within the buffer.      But to be able to switch to reading, we would need to set      egptr to ptr.  That can't be done in the current design,      which assumes file_ptr() is eGptr.  Anyway, since we probably      end up flushing when we close(), it doesn't make much difference.)      FIXME: simulate mem-papped files. */
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_write_base
operator|||
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
if|if
condition|(
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|==
name|NULL
condition|)
block|{
name|_IO_doallocbuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|_IO_seek_cur
case|:
comment|/* Adjust for read-ahead (bytes is buffer). */
name|offset
operator|-=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_offset
operator|==
name|_IO_pos_BAD
condition|)
goto|goto
name|dumb
goto|;
comment|/* Make offset absolute, assuming current pointer is file_ptr(). */
name|offset
operator|+=
name|_IO_pos_as_off
argument_list|(
name|fp
operator|->
name|_offset
argument_list|)
expr_stmt|;
name|dir
operator|=
name|_IO_seek_set
expr_stmt|;
break|break;
case|case
name|_IO_seek_set
case|:
break|break;
case|case
name|_IO_seek_end
case|:
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|_IO_SYSSTAT
argument_list|(
name|fp
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|st
operator|.
name|st_size
expr_stmt|;
name|dir
operator|=
name|_IO_seek_set
expr_stmt|;
block|}
else|else
goto|goto
name|dumb
goto|;
block|}
block|}
comment|/* At this point, dir==_IO_seek_set. */
comment|/* If destination is within current buffer, optimize: */
if|if
condition|(
name|fp
operator|->
name|_offset
operator|!=
name|_IO_pos_BAD
operator|&&
name|fp
operator|->
name|_IO_read_base
operator|!=
name|NULL
operator|&&
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/* Offset relative to start of main get area. */
name|_IO_pos_t
name|rel_offset
init|=
operator|(
name|offset
operator|-
name|fp
operator|->
name|_offset
operator|+
operator|(
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|rel_offset
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|if (_IO_in_backup (fp)) 	    _IO_switch_to_main_get_area (fp);
endif|#
directive|endif
if|if
condition|(
name|rel_offset
operator|<=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
condition|)
block|{
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
operator|+
name|rel_offset
argument_list|,
name|fp
operator|->
name|_IO_read_end
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
ifdef|#
directive|ifdef
name|TODO
comment|/* If we have streammarkers, seek forward by reading ahead. */
if|if
condition|(
name|_IO_have_markers
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|int
name|to_skip
init|=
name|rel_offset
operator|-
operator|(
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_base
operator|)
decl_stmt|;
if|if
condition|(
name|ignore
argument_list|(
name|to_skip
argument_list|)
operator|!=
name|to_skip
condition|)
goto|goto
name|dumb
goto|;
return|return
name|offset
return|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TODO
if|if
condition|(
name|rel_offset
operator|<
literal|0
operator|&&
name|rel_offset
operator|>=
name|Bbase
argument_list|()
operator|-
name|Bptr
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|gbump
argument_list|(
name|fp
operator|->
name|_IO_read_end
operator|+
name|rel_offset
operator|-
name|fp
operator|->
name|_IO_read_ptr
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TODO
name|_IO_unsave_markers
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_READS
condition|)
goto|goto
name|dumb
goto|;
comment|/* Try to seek to a block boundary, to improve kernel page management. */
name|new_offset
operator|=
name|offset
operator|&
operator|~
operator|(
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
operator|-
literal|1
operator|)
expr_stmt|;
name|delta
operator|=
name|offset
operator|-
name|new_offset
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
condition|)
block|{
name|new_offset
operator|=
name|offset
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
block|}
name|result
operator|=
name|_IO_SYSSEEK
argument_list|(
name|fp
argument_list|,
name|new_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|count
operator|=
name|_IO_SYSREAD
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
operator|(
name|must_be_exact
condition|?
name|delta
else|:
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|delta
condition|)
block|{
comment|/* We weren't allowed to read, but try to seek the remainder. */
name|offset
operator|=
name|count
operator|==
name|EOF
condition|?
name|delta
else|:
name|delta
operator|-
name|count
expr_stmt|;
name|dir
operator|=
name|_IO_seek_cur
expr_stmt|;
goto|goto
name|dumb
goto|;
block|}
block|}
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
operator|+
name|delta
argument_list|,
name|fp
operator|->
name|_IO_buf_base
operator|+
name|count
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_offset
operator|=
name|result
operator|+
name|count
expr_stmt|;
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|_IO_EOF_SEEN
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
name|dumb
label|:
name|_IO_unsave_markers
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|result
operator|=
name|_IO_SYSSEEK
argument_list|(
name|fp
argument_list|,
name|offset
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|EOF
condition|)
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|_IO_EOF_SEEN
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_offset
operator|=
name|result
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|_IO_ssize_t
name|_IO_file_read
parameter_list|(
name|fp
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|_IO_ssize_t
name|size
decl_stmt|;
block|{
return|return
name|read
argument_list|(
name|fp
operator|->
name|_fileno
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|_IO_pos_t
name|_IO_file_seek
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|,
name|dir
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_off_t
name|offset
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
return|return
name|lseek
argument_list|(
name|fp
operator|->
name|_fileno
argument_list|,
name|offset
argument_list|,
name|dir
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_stat
parameter_list|(
name|fp
parameter_list|,
name|st
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|st
decl_stmt|;
block|{
return|return
name|fstat
argument_list|(
name|fp
operator|->
name|_fileno
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|st
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_close
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
return|return
name|close
argument_list|(
name|fp
operator|->
name|_fileno
argument_list|)
return|;
block|}
end_function

begin_function
name|_IO_ssize_t
name|_IO_file_write
parameter_list|(
name|f
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_ssize_t
name|n
decl_stmt|;
block|{
name|_IO_ssize_t
name|to_do
init|=
name|n
decl_stmt|;
while|while
condition|(
name|to_do
operator|>
literal|0
condition|)
block|{
name|_IO_ssize_t
name|count
init|=
name|write
argument_list|(
name|f
operator|->
name|_fileno
argument_list|,
name|data
argument_list|,
name|to_do
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|EOF
condition|)
block|{
name|f
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
expr_stmt|;
break|break;
block|}
name|to_do
operator|-=
name|count
expr_stmt|;
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|count
operator|)
expr_stmt|;
block|}
name|n
operator|-=
name|to_do
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|_offset
operator|>=
literal|0
condition|)
name|f
operator|->
name|_offset
operator|+=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|_IO_size_t
name|_IO_file_xsputn
parameter_list|(
name|f
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|n
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|data
decl_stmt|;
name|_IO_size_t
name|to_do
init|=
name|n
decl_stmt|;
name|int
name|must_flush
init|=
literal|0
decl_stmt|;
name|_IO_size_t
name|count
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* This is an optimized implementation.      If the amount to be written straddles a block boundary      (or the filebuf is unbuffered), use sys_write directly. */
comment|/* First figure out how much space is available in the buffer. */
name|count
operator|=
name|f
operator|->
name|_IO_write_end
operator|-
name|f
operator|->
name|_IO_write_ptr
expr_stmt|;
comment|/* Space available. */
if|if
condition|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
operator|)
operator|&&
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
condition|)
block|{
name|count
operator|=
name|f
operator|->
name|_IO_buf_end
operator|-
name|f
operator|->
name|_IO_write_ptr
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|n
condition|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|+
name|n
init|;
name|p
operator|>
name|s
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'\n'
condition|)
block|{
name|count
operator|=
name|p
operator|-
name|s
operator|+
literal|1
expr_stmt|;
name|must_flush
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Then fill the buffer. */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
name|to_do
condition|)
name|count
operator|=
name|to_do
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|20
condition|)
block|{
name|memcpy
argument_list|(
name|f
operator|->
name|_IO_write_ptr
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|+=
name|count
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|f
operator|->
name|_IO_write_ptr
decl_stmt|;
specifier|register
name|int
name|i
init|=
operator|(
name|int
operator|)
name|count
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|f
operator|->
name|_IO_write_ptr
operator|+=
name|count
expr_stmt|;
name|to_do
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|to_do
operator|+
name|must_flush
operator|>
literal|0
condition|)
block|{
name|_IO_size_t
name|block_size
decl_stmt|,
name|dont_write
decl_stmt|;
comment|/* Next flush the (full) buffer. */
if|if
condition|(
name|__overflow
argument_list|(
name|f
argument_list|,
name|EOF
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|n
operator|-
name|to_do
return|;
comment|/* Try to maintain alignment: write a whole number of blocks. 	 dont_write is what gets left over. */
name|block_size
operator|=
name|f
operator|->
name|_IO_buf_end
operator|-
name|f
operator|->
name|_IO_buf_base
expr_stmt|;
name|dont_write
operator|=
name|block_size
operator|>=
literal|128
condition|?
name|to_do
operator|%
name|block_size
else|:
literal|0
expr_stmt|;
name|count
operator|=
name|to_do
operator|-
name|dont_write
expr_stmt|;
if|if
condition|(
name|_IO_do_write
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|n
operator|-
name|to_do
return|;
name|to_do
operator|=
name|dont_write
expr_stmt|;
comment|/* Now write out the remainder.  Normally, this will fit in the 	 buffer, but it's somewhat messier for line-buffered files, 	 so we let _IO_default_xsputn handle the general case. */
if|if
condition|(
name|dont_write
condition|)
name|to_do
operator|-=
name|_IO_default_xsputn
argument_list|(
name|f
argument_list|,
name|s
operator|+
name|count
argument_list|,
name|dont_write
argument_list|)
expr_stmt|;
block|}
return|return
name|n
operator|-
name|to_do
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Work in progress */
end_comment

begin_comment
unit|_IO_size_t _IO_file_xsgetn (fp, data, n)      _IO_FILE *fp;      void *data;      _IO_size_t n; {   register _IO_size_t more = n;   register char *s = data;   for (;;)     {
comment|/* Data available. */
end_comment

begin_if
unit|_IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr;       if (count> 0) 	{ 	  if (count> more) 	    count = more; 	  if (count> 20) 	    { 	      memcpy (s, fp->_IO_read_ptr, count); 	      s += count; 	      fp->_IO_read_ptr += count; 	    } 	  else if (count<= 0) 	    count = 0; 	  else 	    { 	      register char *p = fp->_IO_read_ptr; 	      register int i = (int) count; 	      while (--i>= 0) 		*s++ = *p++; 	      fp->_IO_read_ptr = p;             }             more -= count;         }
if|#
directive|if
literal|0
end_if

begin_comment
unit|if (! _IO_in put_mode (fp)&& ! _IO_have_markers (fp)&& ! IO_have_backup (fp)) 	{
comment|/* This is an optimization of _IO_file_underflow */
end_comment

begin_comment
unit|if (fp->_flags& _IO_NO_READS) 	    break;
comment|/* If we're reading a lot of data, don't bother allocating 	     a buffer.  But if we're only reading a bit, perhaps we should ??*/
end_comment

begin_endif
unit|if (count<= 512&& fp->_IO_buf_base == NULL) 	    _IO_doallocbuf (fp); 	  if (fp->_flags& (_IO_LINE_BUF|_IO_UNBUFFERED)) 	    _IO_flush_all_linebuffered ();  	  _IO_switch_to_get_mode (fp); ???; 	  count = _IO_SYSREAD (fp, s, more); 	  if (count<= 0) 	     { 	       if (count == 0) 		 fp->_flags |= _IO_EOF_SEEN; 	       else 		 fp->_flags |= _IO_ERR_SEEN, count = 0; 	     }  	  s += count; 	  more -= count; 	}
endif|#
directive|endif
end_endif

begin_endif
unit|if (more == 0 || __underflow (fp) == EOF) 	break;     }   return n - more; }
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|_IO_jump_t
name|_IO_file_jumps
init|=
block|{
name|JUMP_INIT_DUMMY
block|,
name|JUMP_INIT
argument_list|(
name|finish
argument_list|,
name|_IO_file_finish
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|overflow
argument_list|,
name|_IO_file_overflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|underflow
argument_list|,
name|_IO_file_underflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|uflow
argument_list|,
name|_IO_default_uflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|pbackfail
argument_list|,
name|_IO_default_pbackfail
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsputn
argument_list|,
name|_IO_file_xsputn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsgetn
argument_list|,
name|_IO_default_xsgetn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekoff
argument_list|,
name|_IO_file_seekoff
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekpos
argument_list|,
name|_IO_default_seekpos
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|setbuf
argument_list|,
name|_IO_file_setbuf
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|sync
argument_list|,
name|_IO_file_sync
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|doallocate
argument_list|,
name|_IO_file_doallocate
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|read
argument_list|,
name|_IO_file_read
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|write
argument_list|,
name|_IO_file_write
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seek
argument_list|,
name|_IO_file_seek
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|close
argument_list|,
name|_IO_file_close
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
argument|stat
argument_list|,
argument|_IO_file_stat
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

