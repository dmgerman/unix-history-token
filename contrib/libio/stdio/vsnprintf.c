begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.    This file is part of the GNU IO Library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_include
include|#
directive|include
file|"strfile.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|_IO_strfile
name|f
decl_stmt|;
comment|/* This is used for the characters which do not fit in the buffer      provided by the user.  */
name|char
name|overflow_buf
index|[
literal|64
index|]
decl_stmt|;
block|}
name|_IO_strnfile
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|_IO_strn_overflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|fp
operator|,
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|_IO_strn_overflow
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
comment|/* When we come to here this means the user supplied buffer is      filled.  But since we must return the number of characters which      would have been written in total we must provide a buffer for      further use.  We can do this by writing on and on in the overflow      buffer in the _IO_strnfile structure.  */
name|_IO_strnfile
modifier|*
name|snf
init|=
operator|(
name|_IO_strnfile
operator|*
operator|)
name|fp
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|!=
name|snf
operator|->
name|overflow_buf
condition|)
block|{
comment|/* Terminate the string.  We know that there is room for at 	 least one more character since we initialized the stream with 	 a size to make this possible.  */
operator|*
name|fp
operator|->
name|_IO_write_ptr
operator|=
literal|'\0'
expr_stmt|;
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|snf
operator|->
name|overflow_buf
argument_list|,
name|snf
operator|->
name|overflow_buf
operator|+
sizeof|sizeof
argument_list|(
name|snf
operator|->
name|overflow_buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|snf
operator|->
name|overflow_buf
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|snf
operator|->
name|overflow_buf
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|snf
operator|->
name|overflow_buf
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|snf
operator|->
name|overflow_buf
operator|+
sizeof|sizeof
argument_list|(
name|snf
operator|->
name|overflow_buf
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|snf
operator|->
name|overflow_buf
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
name|snf
operator|->
name|overflow_buf
expr_stmt|;
comment|/* Since we are not really interested in storing the characters      which do not fit in the buffer we simply ignore it.  */
return|return
name|c
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|_IO_jump_t
name|_IO_strn_jumps
init|=
block|{
name|JUMP_INIT_DUMMY
block|,
name|JUMP_INIT
argument_list|(
name|finish
argument_list|,
name|_IO_str_finish
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|overflow
argument_list|,
name|_IO_strn_overflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|underflow
argument_list|,
name|_IO_str_underflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|uflow
argument_list|,
name|_IO_default_uflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|pbackfail
argument_list|,
name|_IO_str_pbackfail
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsputn
argument_list|,
name|_IO_default_xsputn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsgetn
argument_list|,
name|_IO_default_xsgetn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekoff
argument_list|,
name|_IO_str_seekoff
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekpos
argument_list|,
name|_IO_default_seekpos
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|setbuf
argument_list|,
name|_IO_default_setbuf
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|sync
argument_list|,
name|_IO_default_sync
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|doallocate
argument_list|,
name|_IO_default_doallocate
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|read
argument_list|,
name|_IO_default_read
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|write
argument_list|,
name|_IO_default_write
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seek
argument_list|,
name|_IO_default_seek
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|close
argument_list|,
name|_IO_default_close
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
argument|stat
argument_list|,
argument|_IO_default_stat
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_IO_vsnprintf
parameter_list|(
name|string
parameter_list|,
name|maxlen
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|_IO_size_t
name|maxlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|_IO_va_list
name|args
decl_stmt|;
block|{
name|_IO_strnfile
name|sf
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|_IO_MTSAFE_IO
name|_IO_lock_t
name|lock
decl_stmt|;
name|sf
operator|.
name|f
operator|.
name|_sbf
operator|.
name|_f
operator|.
name|_lock
operator|=
operator|&
name|lock
expr_stmt|;
endif|#
directive|endif
comment|/* We need to handle the special case where MAXLEN is 0.  Use the      overflow buffer right from the start.  */
if|if
condition|(
name|maxlen
operator|==
literal|0
condition|)
block|{
name|string
operator|=
name|sf
operator|.
name|overflow_buf
expr_stmt|;
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|sf
operator|.
name|overflow_buf
argument_list|)
expr_stmt|;
block|}
name|_IO_init
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
operator|&
name|sf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_IO_JUMPS
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
operator|&
name|sf
argument_list|)
operator|=
operator|&
name|_IO_strn_jumps
expr_stmt|;
name|_IO_str_init_static
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
operator|&
name|sf
argument_list|,
name|string
argument_list|,
name|maxlen
operator|-
literal|1
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_IO_vfprintf
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
operator|&
name|sf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|.
name|f
operator|.
name|_sbf
operator|.
name|_f
operator|.
name|_IO_buf_base
operator|!=
name|sf
operator|.
name|overflow_buf
condition|)
operator|*
name|sf
operator|.
name|f
operator|.
name|_sbf
operator|.
name|_f
operator|.
name|_IO_write_ptr
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|_IO_vsnprintf
argument_list|,
argument|__vsnprintf
argument_list|)
end_macro

begin_macro
name|weak_alias
argument_list|(
argument|_IO_vsnprintf
argument_list|,
argument|vsnprintf
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

end_unit

