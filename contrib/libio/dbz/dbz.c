begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  dbz.c  V3.2  Copyright 1988 Jon Zeeff (zeeff@b-tech.ann-arbor.mi.us) You can use this code in any manner, as long as you leave my name on it and don't hold me responsible for any problems with it.  Hacked on by gdb@ninja.UUCP (David Butler); Sun Jun  5 00:27:08 CDT 1988  Various improvments + INCORE by moraes@ai.toronto.edu (Mark Moraes)  Major reworking by Henry Spencer as part of the C News project.  These routines replace dbm as used by the usenet news software (it's not a full dbm replacement by any means).  It's fast and simple.  It contains no AT&T code.  In general, dbz's files are 1/20 the size of dbm's.  Lookup performance is somewhat better, while file creation is spectacularly faster, especially if the incore facility is used.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dbz.h>
end_include

begin_comment
comment|/*  * #ifdef index.  "LIA" = "leave it alone unless you know what you're doing".  *  * FUNNYSEEKS	SEEK_SET is not 0, get it from<unistd.h>  * INDEX_SIZE	backward compatibility with old dbz; avoid using this  * NMEMORY	number of days of memory for use in sizing new table (LIA)  * INCORE	backward compatibility with old dbz; use dbzincore() instead  * DBZDEBUG	enable debugging  * DEFSIZE	default table size (not as critical as in old dbz)  * OLDBNEWS	default case mapping as in old B News; set NOBUFFER  * BNEWS	default case mapping as in current B News; set NOBUFFER  * DEFCASE	default case-map algorithm selector  * NOTAGS	fseek offsets are strange, do not do tagging (see below)  * NPAGBUF	size of .pag buffer, in longs (LIA)  * SHISTBUF	size of ASCII-file buffer, in bytes (LIA)  * MAXRUN	length of run which shifts to next table (see below) (LIA)  * OVERFLOW	long-int arithmetic overflow must be avoided, will trap  * NOBUFFER	do not buffer hash-table i/o, B News locking is defective  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FUNNYSEEKS
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OVERFLOW
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|dbzversion
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for validating .dir file format */
end_comment

begin_comment
comment|/*  * The dbz database exploits the fact that when news stores a<key,value>  * tuple, the `value' part is a seek offset into a text file, pointing to  * a copy of the `key' part.  This avoids the need to store a copy of  * the key in the dbz files.  However, the text file *must* exist and be  * consistent with the dbz files, or things will fail.  *  * The basic format of the database is a simple hash table containing the  * values.  A value is stored by indexing into the table using a hash value  * computed from the key; collisions are resolved by linear probing (just  * search forward for an empty slot, wrapping around to the beginning of  * the table if necessary).  Linear probing is a performance disaster when  * the table starts to get full, so a complication is introduced.  The  * database is actually one *or more* tables, stored sequentially in the  * .pag file, and the length of linear-probe sequences is limited.  The  * search (for an existing item or an empty slot) always starts in the  * first table, and whenever MAXRUN probes have been done in table N,  * probing continues in table N+1.  This behaves reasonably well even in  * cases of massive overflow.  There are some other small complications  * added, see comments below.  *  * The table size is fixed for any particular database, but is determined  * dynamically when a database is rebuilt.  The strategy is to try to pick  * the size so the first table will be no more than 2/3 full, that being  * slightly before the point where performance starts to degrade.  (It is  * desirable to be a bit conservative because the overflow strategy tends  * to produce files with holes in them, which is a nuisance.)  */
end_comment

begin_comment
comment|/*  * The following is for backward compatibility.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INDEX_SIZE
end_ifdef

begin_define
define|#
directive|define
name|DEFSIZE
value|INDEX_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ANSI C says the offset argument to fseek is a long, not an off_t, for some  * reason.  Let's use off_t anyway.  */
end_comment

begin_define
define|#
directive|define
name|SOF
value|(sizeof(off_t))
end_define

begin_comment
comment|/*  * We assume that unused areas of a binary file are zeros, and that the  * bit pattern of `(off_t)0' is all zeros.  The alternative is rather  * painful file initialization.  Note that okayvalue(), if OVERFLOW is  * defined, knows what value of an offset would cause overflow.  */
end_comment

begin_define
define|#
directive|define
name|VACANT
value|((off_t)0)
end_define

begin_define
define|#
directive|define
name|BIAS
parameter_list|(
name|o
parameter_list|)
value|((o)+1)
end_define

begin_comment
comment|/* make any valid off_t non-VACANT */
end_comment

begin_define
define|#
directive|define
name|UNBIAS
parameter_list|(
name|o
parameter_list|)
value|((o)-1)
end_define

begin_comment
comment|/* reverse BIAS() effect */
end_comment

begin_comment
comment|/*  * In a Unix implementation, or indeed any in which an off_t is a byte  * count, there are a bunch of high bits free in an off_t.  There is a  * use for them.  Checking a possible hit by looking it up in the base  * file is relatively expensive, and the cost can be dramatically reduced  * by using some of those high bits to tag the value with a few more bits  * of the key's hash.  This detects most false hits without the overhead of  * seek+read+strcmp.  We use the top bit to indicate whether the value is  * tagged or not, and don't tag a value which is using the tag bits itself.  * We're in trouble if the off_t representation wants to use the top bit.  * The actual bitmasks and offset come from the configuration stuff,  * which permits fiddling with them as necessary, and also suppressing  * them completely (by defining the masks to 0).  We build pre-shifted  * versions of the masks for efficiency.  */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|tagbits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pre-shifted tag mask */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|taghere
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pre-shifted tag-enable bit */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|tagboth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tagbits|taghere */
end_comment

begin_define
define|#
directive|define
name|HASTAG
parameter_list|(
name|o
parameter_list|)
value|((o)&taghere)
end_define

begin_define
define|#
directive|define
name|TAG
parameter_list|(
name|o
parameter_list|)
value|((o)&tagbits)
end_define

begin_define
define|#
directive|define
name|NOTAG
parameter_list|(
name|o
parameter_list|)
value|((o)&~tagboth)
end_define

begin_define
define|#
directive|define
name|CANTAG
parameter_list|(
name|o
parameter_list|)
value|(((o)&tagboth) == 0)
end_define

begin_define
define|#
directive|define
name|MKTAG
parameter_list|(
name|v
parameter_list|)
value|(((v)<<conf.tagshift)&tagbits)
end_define

begin_comment
comment|/*  * A new, from-scratch database, not built as a rebuild of an old one,  * needs to know table size, casemap algorithm, and tagging.  Normally  * the user supplies this info, but there have to be defaults.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFSIZE
end_ifndef

begin_define
define|#
directive|define
name|DEFSIZE
value|120011
end_define

begin_comment
comment|/* 300007 might be better */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OLDBNEWS
end_ifdef

begin_define
define|#
directive|define
name|DEFCASE
value|'0'
end_define

begin_comment
comment|/* B2.10 -- no mapping */
end_comment

begin_define
define|#
directive|define
name|NOBUFFER
end_define

begin_comment
comment|/* B News locking is defective */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BNEWS
end_ifdef

begin_define
define|#
directive|define
name|DEFCASE
value|'='
end_define

begin_comment
comment|/* B2.11 -- all mapped */
end_comment

begin_define
define|#
directive|define
name|NOBUFFER
end_define

begin_comment
comment|/* B News locking is defective */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFCASE
end_ifndef

begin_comment
comment|/* C News compatibility is the default */
end_comment

begin_define
define|#
directive|define
name|DEFCASE
value|'C'
end_define

begin_comment
comment|/* C News -- RFC822 mapping */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NOTAGS
end_ifndef

begin_define
define|#
directive|define
name|TAGENB
value|0x80
end_define

begin_comment
comment|/* tag enable is top bit, tag is next 7 */
end_comment

begin_define
define|#
directive|define
name|TAGMASK
value|0x7f
end_define

begin_define
define|#
directive|define
name|TAGSHIFT
value|24
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TAGENB
value|0
end_define

begin_comment
comment|/* no tags */
end_comment

begin_define
define|#
directive|define
name|TAGMASK
value|0
end_define

begin_define
define|#
directive|define
name|TAGSHIFT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We read configuration info from the .dir file into this structure,  * so we can avoid wired-in assumptions for an existing database.  *  * Among the info is a record of recent peak usages, so that a new table  * size can be chosen intelligently when rebuilding.  10 is a good  * number of usages to keep, since news displays marked fluctuations  * in volume on a 7-day cycle.  */
end_comment

begin_struct
struct|struct
name|dbzconfig
block|{
name|int
name|olddbz
decl_stmt|;
comment|/* .dir file empty but .pag not? */
name|off_t
name|tsize
decl_stmt|;
comment|/* table size */
ifndef|#
directive|ifndef
name|NMEMORY
define|#
directive|define
name|NMEMORY
value|10
comment|/* # days of use info to remember */
endif|#
directive|endif
define|#
directive|define
name|NUSEDS
value|(1+NMEMORY)
name|off_t
name|used
index|[
name|NUSEDS
index|]
decl_stmt|;
comment|/* entries used today, yesterday, ... */
name|int
name|valuesize
decl_stmt|;
comment|/* size of table values, == SOF */
name|int
name|bytemap
index|[
name|SOF
index|]
decl_stmt|;
comment|/* byte-order map */
name|char
name|casemap
decl_stmt|;
comment|/* case-mapping algorithm (see cipoint()) */
name|char
name|fieldsep
decl_stmt|;
comment|/* field separator in base file, if any */
name|off_t
name|tagenb
decl_stmt|;
comment|/* unshifted tag-enable bit */
name|off_t
name|tagmask
decl_stmt|;
comment|/* unshifted tag mask */
name|int
name|tagshift
decl_stmt|;
comment|/* shift count for tagmask and tagenb */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|dbzconfig
name|conf
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|getconf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|getno
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|putconf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mybytemap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|bytemap
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*   * For a program that makes many, many references to the database, it  * is a large performance win to keep the table in core, if it will fit.  * Note that this does hurt robustness in the event of crashes, and  * dbmclose() *must* be called to flush the in-core database to disk.  * The code is prepared to deal with the possibility that there isn't  * enough memory.  There *is* an assumption that a size_t is big enough  * to hold the size (in bytes) of one table, so dbminit() tries to figure  * out whether this is possible first.  *  * The preferred way to ask for an in-core table is to do dbzincore(1)  * before dbminit().  The default is not to do it, although -DINCORE  * overrides this for backward compatibility with old dbz.  *  * We keep only the first table in core.  This greatly simplifies the  * code, and bounds memory demand.  Furthermore, doing this is a large  * performance win even in the event of massive overflow.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INCORE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|incore
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|incore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Stdio buffer for .pag reads.  Buffering more than about 16 does not help  * significantly at the densities we try to maintain, and the much larger  * buffers that most stdios default to are much more expensive to fill.  * With small buffers, stdio is performance-competitive with raw read(),  * and it's much more portable.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NPAGBUF
end_ifndef

begin_define
define|#
directive|define
name|NPAGBUF
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NOBUFFER
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_IOFBF
end_ifdef

begin_decl_stmt
specifier|static
name|off_t
name|pagbuf
index|[
name|NPAGBUF
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* only needed if !NOBUFFER&& _IOFBF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Stdio buffer for base-file reads.  Message-IDs (all news ever needs to  * read) are essentially never longer than 64 bytes, and the typical stdio  * buffer is so much larger that it is much more expensive to fill.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHISTBUF
end_ifndef

begin_define
define|#
directive|define
name|SHISTBUF
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_IOFBF
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|basebuf
index|[
name|SHISTBUF
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* only needed if _IOFBF exists */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Data structure for recording info about searches.  */
end_comment

begin_struct
struct|struct
name|searcher
block|{
name|off_t
name|place
decl_stmt|;
comment|/* current location in file */
name|int
name|tabno
decl_stmt|;
comment|/* which table we're in */
name|int
name|run
decl_stmt|;
comment|/* how long we'll stay in this table */
ifndef|#
directive|ifndef
name|MAXRUN
define|#
directive|define
name|MAXRUN
value|100
endif|#
directive|endif
name|long
name|hash
decl_stmt|;
comment|/* the key's hash code (for optimization) */
name|off_t
name|tag
decl_stmt|;
comment|/* tag we are looking for */
name|int
name|seen
decl_stmt|;
comment|/* have we examined current location? */
name|int
name|aborted
decl_stmt|;
comment|/* has i/o error aborted search? */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|start
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FRESH
value|((struct searcher *)NULL)
end_define

begin_function_decl
specifier|static
name|off_t
name|search
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NOTFOUND
value|((off_t)-1)
end_define

begin_function_decl
specifier|static
name|int
name|okayvalue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Arguably the searcher struct for a given routine ought to be local to  * it, but a fetch() is very often immediately followed by a store(), and  * in some circumstances it is a useful performance win to remember where  * the fetch() completed.  So we use a global struct and remember whether  * it is current.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|searcher
name|srch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|searcher
modifier|*
name|prevp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*&srch or FRESH */
end_comment

begin_comment
comment|/* byte-ordering stuff */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mybmap
index|[
name|SOF
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* my byte order (see mybytemap()) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bytesame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is database order same as mine? */
end_comment

begin_define
define|#
directive|define
name|MAPIN
parameter_list|(
name|o
parameter_list|)
value|((bytesame) ? (o) : bytemap((o), conf.bytemap, mybmap))
end_define

begin_define
define|#
directive|define
name|MAPOUT
parameter_list|(
name|o
parameter_list|)
value|((bytesame) ? (o) : bytemap((o), mybmap, conf.bytemap))
end_define

begin_comment
comment|/*  * The double parentheses needed to make this work are ugly, but the  * alternative (under most compilers) is to pack around 2K of unused  * strings -- there's just no way to get rid of them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* controlled by dbzdebug() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DBZDEBUG
end_ifdef

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|args
parameter_list|)
value|if (debug) { (void) printf args ; }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|args
parameter_list|)
value|;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* externals used */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ANSI C; some old implementations say int */
end_comment

begin_function_decl
specifier|extern
name|int
name|atoi
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|atol
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* misc. forwards */
end_comment

begin_function_decl
specifier|static
name|long
name|hash
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|crcinit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|cipoint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|mapcase
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isprime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|latebase
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* file-naming stuff */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dir
index|[]
init|=
literal|".dir"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pag
index|[]
init|=
literal|".pag"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|enstring
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* central data structures */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|basef
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* descriptor for base file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|basefname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name for not-yet-opened base file */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|dirf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* descriptor for .dir file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dirronly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dirf open read-only? */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|pagf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* descriptor for .pag file */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|pagpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* posn in pagf; only search may set != -1 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pagronly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pagf open read-only? */
end_comment

begin_decl_stmt
specifier|static
name|off_t
modifier|*
name|corepag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* incore version of .pag file, if any */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bufpagf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* well-buffered pagf, for incore rewrite */
end_comment

begin_function_decl
specifier|static
name|off_t
modifier|*
name|getcore
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|putcore
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|written
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* has a store() been done? */
end_comment

begin_comment
comment|/*  - dbzfresh - set up a new database, no historical info  */
end_comment

begin_function
name|int
comment|/* 0 success, -1 failure */
name|dbzfresh
parameter_list|(
name|name
parameter_list|,
name|size
parameter_list|,
name|fs
parameter_list|,
name|cmap
parameter_list|,
name|tagmask
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* base name; .dir and .pag must exist */
name|long
name|size
decl_stmt|;
comment|/* table size (0 means default) */
name|int
name|fs
decl_stmt|;
comment|/* field-separator character in base file */
name|int
name|cmap
decl_stmt|;
comment|/* case-map algorithm (0 means default) */
name|off_t
name|tagmask
decl_stmt|;
comment|/* 0 default, 1 no tags */
block|{
specifier|register
name|char
modifier|*
name|fn
decl_stmt|;
name|struct
name|dbzconfig
name|c
decl_stmt|;
specifier|register
name|off_t
name|m
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|pagf
operator|!=
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzfresh: database already open\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|!=
literal|0
operator|&&
name|size
operator|<
literal|2
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzfresh: preposterous size (%ld)\n"
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* get default configuration */
if|if
condition|(
name|getconf
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* "can't happen" */
comment|/* and mess with it as specified */
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
name|c
operator|.
name|tsize
operator|=
name|size
expr_stmt|;
name|c
operator|.
name|fieldsep
operator|=
name|fs
expr_stmt|;
switch|switch
condition|(
name|cmap
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|'0'
case|:
case|case
literal|'B'
case|:
comment|/* 2.10 compat */
name|c
operator|.
name|casemap
operator|=
literal|'0'
expr_stmt|;
comment|/* '\0' nicer, but '0' printable! */
break|break;
case|case
literal|'='
case|:
case|case
literal|'b'
case|:
comment|/* 2.11 compat */
name|c
operator|.
name|casemap
operator|=
literal|'='
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|c
operator|.
name|casemap
operator|=
literal|'C'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|c
operator|.
name|casemap
operator|=
name|DEFCASE
expr_stmt|;
break|break;
default|default:
name|DEBUG
argument_list|(
operator|(
literal|"dbzfresh case map `%c' unknown\n"
operator|,
name|cmap
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
switch|switch
condition|(
name|tagmask
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
break|break;
case|case
literal|1
case|:
comment|/* no tags */
name|c
operator|.
name|tagshift
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|tagmask
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|tagenb
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|m
operator|=
name|tagmask
expr_stmt|;
name|c
operator|.
name|tagshift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|m
operator|&
literal|01
operator|)
condition|)
block|{
name|m
operator|>>=
literal|1
expr_stmt|;
name|c
operator|.
name|tagshift
operator|++
expr_stmt|;
block|}
name|c
operator|.
name|tagmask
operator|=
name|m
expr_stmt|;
name|c
operator|.
name|tagenb
operator|=
operator|(
name|m
operator|<<
literal|1
operator|)
operator|&
operator|~
name|m
expr_stmt|;
break|break;
block|}
comment|/* write it out */
name|fn
operator|=
name|enstring
argument_list|(
name|name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzfresh: unable to write config\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|putconf
argument_list|(
name|f
argument_list|,
operator|&
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzfresh: fclose failure\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* create/truncate .pag */
name|fn
operator|=
name|enstring
argument_list|(
name|name
argument_list|,
name|pag
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzfresh: unable to create/truncate .pag file\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* and punt to dbminit for the hard work */
return|return
operator|(
name|dbminit
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dbzsize - what's a good table size to hold this many entries?  */
end_comment

begin_function
name|long
name|dbzsize
parameter_list|(
name|contents
parameter_list|)
name|long
name|contents
decl_stmt|;
comment|/* 0 means what's the default */
block|{
specifier|register
name|long
name|n
decl_stmt|;
if|if
condition|(
name|contents
operator|<=
literal|0
condition|)
block|{
comment|/* foulup or default inquiry */
name|DEBUG
argument_list|(
operator|(
literal|"dbzsize: preposterous input (%ld)\n"
operator|,
name|contents
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DEFSIZE
operator|)
return|;
block|}
name|n
operator|=
operator|(
name|contents
operator|/
literal|2
operator|)
operator|*
literal|3
expr_stmt|;
comment|/* try to keep table at most 2/3 full */
if|if
condition|(
operator|!
operator|(
name|n
operator|&
literal|01
operator|)
condition|)
comment|/* make it odd */
name|n
operator|++
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"dbzsize: tentative size %ld\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|isprime
argument_list|(
name|n
argument_list|)
condition|)
comment|/* and look for a prime */
name|n
operator|+=
literal|2
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"dbzsize: final size %ld\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - isprime - is a number prime?  *  * This is not a terribly efficient approach.  */
end_comment

begin_function
specifier|static
name|int
comment|/* predicate */
name|isprime
parameter_list|(
name|x
parameter_list|)
specifier|register
name|long
name|x
decl_stmt|;
block|{
specifier|static
name|int
name|quick
index|[]
init|=
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|,
literal|13
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|29
block|,
literal|31
block|,
literal|37
block|,
literal|0
block|}
decl_stmt|;
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
specifier|register
name|long
name|div
decl_stmt|;
specifier|register
name|long
name|stop
decl_stmt|;
comment|/* hit the first few primes quickly to eliminate easy ones */
comment|/* this incidentally prevents ridiculously small tables */
for|for
control|(
name|ip
operator|=
name|quick
init|;
operator|(
name|div
operator|=
operator|*
name|ip
operator|)
operator|!=
literal|0
condition|;
name|ip
operator|++
control|)
if|if
condition|(
name|x
operator|%
name|div
operator|==
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"isprime: quick result on %ld\n"
operator|,
operator|(
name|long
operator|)
name|x
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* approximate square root of x */
for|for
control|(
name|stop
operator|=
name|x
init|;
name|x
operator|/
name|stop
operator|<
name|stop
condition|;
name|stop
operator|>>=
literal|1
control|)
continue|continue;
name|stop
operator|<<=
literal|1
expr_stmt|;
comment|/* try odd numbers up to stop */
for|for
control|(
name|div
operator|=
operator|*
operator|--
name|ip
init|;
name|div
operator|<
name|stop
condition|;
name|div
operator|+=
literal|2
control|)
if|if
condition|(
name|x
operator|%
name|div
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dbzagain - set up a new database to be a rebuild of an old one  */
end_comment

begin_function
name|int
comment|/* 0 success, -1 failure */
name|dbzagain
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* base name; .dir and .pag must exist */
name|char
modifier|*
name|oldname
decl_stmt|;
comment|/* base name; all must exist */
block|{
specifier|register
name|char
modifier|*
name|fn
decl_stmt|;
name|struct
name|dbzconfig
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|top
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|newtable
decl_stmt|;
specifier|register
name|off_t
name|newsize
decl_stmt|;
if|if
condition|(
name|pagf
operator|!=
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzagain: database already open\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* pick up the old configuration */
name|fn
operator|=
name|enstring
argument_list|(
name|oldname
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzagain: cannot open old .dir file\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|i
operator|=
name|getconf
argument_list|(
name|f
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzagain: getconf failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* tinker with it */
name|top
operator|=
literal|0
expr_stmt|;
name|newtable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUSEDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|top
operator|<
name|c
operator|.
name|used
index|[
name|i
index|]
condition|)
name|top
operator|=
name|c
operator|.
name|used
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|used
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|newtable
operator|=
literal|1
expr_stmt|;
comment|/* hasn't got full usage history yet */
block|}
if|if
condition|(
name|top
operator|==
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzagain: old table has no contents!\n"
operator|)
argument_list|)
expr_stmt|;
name|newtable
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|NUSEDS
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|c
operator|.
name|used
index|[
name|i
index|]
operator|=
name|c
operator|.
name|used
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c
operator|.
name|used
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|newsize
operator|=
name|dbzsize
argument_list|(
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newtable
operator|||
name|newsize
operator|>
name|c
operator|.
name|tsize
condition|)
comment|/* don't shrink new table */
name|c
operator|.
name|tsize
operator|=
name|newsize
expr_stmt|;
comment|/* write it out */
name|fn
operator|=
name|enstring
argument_list|(
name|name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzagain: unable to write new .dir\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|i
operator|=
name|putconf
argument_list|(
name|f
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzagain: putconf failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* create/truncate .pag */
name|fn
operator|=
name|enstring
argument_list|(
name|name
argument_list|,
name|pag
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzagain: unable to create/truncate .pag file\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* and let dbminit do the work */
return|return
operator|(
name|dbminit
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dbminit - open a database, creating it (using defaults) if necessary  *  * We try to leave errno set plausibly, to the extent that underlying  * functions permit this, since many people consult it if dbminit() fails.  */
end_comment

begin_function
name|int
comment|/* 0 success, -1 failure */
name|dbminit
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|size_t
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|dirfname
decl_stmt|;
specifier|register
name|char
modifier|*
name|pagfname
decl_stmt|;
if|if
condition|(
name|pagf
operator|!=
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbminit: dbminit already called once\n"
operator|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* open the .dir file */
name|dirfname
operator|=
name|enstring
argument_list|(
name|name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirfname
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dirf
operator|=
name|fopen
argument_list|(
name|dirfname
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirf
operator|==
name|NULL
condition|)
block|{
name|dirf
operator|=
name|fopen
argument_list|(
name|dirfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|dirronly
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|dirronly
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|dirfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirf
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbminit: can't open .dir file\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* open the .pag file */
name|pagfname
operator|=
name|enstring
argument_list|(
name|name
argument_list|,
name|pag
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagfname
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dirf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pagf
operator|=
name|fopen
argument_list|(
name|pagfname
argument_list|,
literal|"r+b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagf
operator|==
name|NULL
condition|)
block|{
name|pagf
operator|=
name|fopen
argument_list|(
name|pagfname
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagf
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbminit: .pag open failed\n"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dirf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pagfname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pagronly
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirronly
condition|)
name|pagronly
operator|=
literal|1
expr_stmt|;
else|else
name|pagronly
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NOBUFFER
comment|/* 	 * B News does not do adequate locking on its database accesses. 	 * Why it doesn't get into trouble using dbm is a mystery.  In any 	 * case, doing unbuffered i/o does not cure the problem, but does 	 * enormously reduce its incidence. 	 */
operator|(
name|void
operator|)
name|setbuf
argument_list|(
name|pagf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_IOFBF
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|pagf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pagbuf
argument_list|,
name|_IOFBF
argument_list|,
sizeof|sizeof
argument_list|(
name|pagbuf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|pagpos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't free pagfname, need it below */
comment|/* open the base file */
name|basef
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|basef
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbminit: basefile open failed\n"
operator|)
argument_list|)
expr_stmt|;
name|basefname
operator|=
name|enstring
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|basefname
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pagf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dirf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pagfname
argument_list|)
expr_stmt|;
name|pagf
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
name|basefname
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|_IOFBF
if|if
condition|(
name|basef
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|basef
argument_list|,
name|basebuf
argument_list|,
name|_IOFBF
argument_list|,
sizeof|sizeof
argument_list|(
name|basebuf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* pick up configuration */
if|if
condition|(
name|getconf
argument_list|(
name|dirf
argument_list|,
name|pagf
argument_list|,
operator|&
name|conf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbminit: getconf failure\n"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|basef
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pagf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dirf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pagfname
argument_list|)
expr_stmt|;
name|pagf
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
name|EDOM
expr_stmt|;
comment|/* kind of a kludge, but very portable */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tagbits
operator|=
name|conf
operator|.
name|tagmask
operator|<<
name|conf
operator|.
name|tagshift
expr_stmt|;
name|taghere
operator|=
name|conf
operator|.
name|tagenb
operator|<<
name|conf
operator|.
name|tagshift
expr_stmt|;
name|tagboth
operator|=
name|tagbits
operator||
name|taghere
expr_stmt|;
name|mybytemap
argument_list|(
name|mybmap
argument_list|)
expr_stmt|;
name|bytesame
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOF
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mybmap
index|[
name|i
index|]
operator|!=
name|conf
operator|.
name|bytemap
index|[
name|i
index|]
condition|)
name|bytesame
operator|=
literal|0
expr_stmt|;
comment|/* get first table into core, if it looks desirable and feasible */
name|s
operator|=
operator|(
name|size_t
operator|)
name|conf
operator|.
name|tsize
operator|*
name|SOF
expr_stmt|;
if|if
condition|(
name|incore
operator|&&
call|(
name|off_t
call|)
argument_list|(
name|s
operator|/
name|SOF
argument_list|)
operator|==
name|conf
operator|.
name|tsize
condition|)
block|{
name|bufpagf
operator|=
name|fopen
argument_list|(
name|pagfname
argument_list|,
operator|(
name|pagronly
operator|)
condition|?
literal|"rb"
else|:
literal|"r+b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufpagf
operator|!=
name|NULL
condition|)
name|corepag
operator|=
name|getcore
argument_list|(
name|bufpagf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufpagf
operator|=
name|NULL
expr_stmt|;
name|corepag
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|pagfname
argument_list|)
expr_stmt|;
comment|/* misc. setup */
name|crcinit
argument_list|()
expr_stmt|;
name|written
operator|=
literal|0
expr_stmt|;
name|prevp
operator|=
name|FRESH
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"dbminit: succeeded\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - enstring - concatenate two strings into a malloced area  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* NULL if malloc fails */
name|enstring
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
operator|(
name|size_t
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|p
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
operator|(
literal|"enstring(%s, %s) out of memory\n"
operator|,
name|s1
operator|,
name|s2
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dbmclose - close a database  */
end_comment

begin_function
name|int
name|dbmclose
parameter_list|()
block|{
specifier|register
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pagf
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbmclose: not opened!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|pagf
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbmclose: fclose(pagf) failed\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|pagf
operator|=
name|basef
expr_stmt|;
comment|/* ensure valid pointer; dbzsync checks it */
if|if
condition|(
name|dbzsync
argument_list|()
operator|<
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bufpagf
operator|!=
name|NULL
operator|&&
name|fclose
argument_list|(
name|bufpagf
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbmclose: fclose(bufpagf) failed\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|corepag
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|corepag
argument_list|)
expr_stmt|;
name|corepag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|basef
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbmclose: fclose(basef) failed\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|basefname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|basefname
argument_list|)
expr_stmt|;
name|basef
operator|=
name|NULL
expr_stmt|;
name|pagf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|dirf
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbmclose: fclose(dirf) failed\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|DEBUG
argument_list|(
operator|(
literal|"dbmclose: %s\n"
operator|,
operator|(
name|ret
operator|==
literal|0
operator|)
condition|?
literal|"succeeded"
else|:
literal|"failed"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dbzsync - push all in-core data out to disk  */
end_comment

begin_function
name|int
name|dbzsync
parameter_list|()
block|{
specifier|register
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pagf
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzsync: not opened!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|written
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|corepag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|putcore
argument_list|(
name|corepag
argument_list|,
name|bufpagf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzsync: putcore failed\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|conf
operator|.
name|olddbz
condition|)
if|if
condition|(
name|putconf
argument_list|(
name|dirf
argument_list|,
operator|&
name|conf
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"dbzsync: %s\n"
operator|,
operator|(
name|ret
operator|==
literal|0
operator|)
condition|?
literal|"succeeded"
else|:
literal|"failed"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dbzcancel - cancel writing of in-core data  * Mostly for use from child processes.  * Note that we don't need to futz around with stdio buffers, because we  * always fflush them immediately anyway and so they never have stale data.  */
end_comment

begin_function
name|int
name|dbzcancel
parameter_list|()
block|{
if|if
condition|(
name|pagf
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzcancel: not opened!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|written
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dbzfetch - fetch() with case mapping built in  */
end_comment

begin_function
name|datum
name|dbzfetch
parameter_list|(
name|key
parameter_list|)
name|datum
name|key
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|DBZMAXKEY
operator|+
literal|1
index|]
decl_stmt|;
name|datum
name|mappedkey
decl_stmt|;
specifier|register
name|size_t
name|keysize
decl_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"dbzfetch: (%s)\n"
operator|,
name|key
operator|.
name|dptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Key is supposed to be less than DBZMAXKEY */
name|keysize
operator|=
name|key
operator|.
name|dsize
expr_stmt|;
if|if
condition|(
name|keysize
operator|>=
name|DBZMAXKEY
condition|)
block|{
name|keysize
operator|=
name|DBZMAXKEY
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"keysize is %d - truncated to %d\n"
operator|,
name|key
operator|.
name|dsize
operator|,
name|DBZMAXKEY
operator|)
argument_list|)
expr_stmt|;
block|}
name|mappedkey
operator|.
name|dptr
operator|=
name|mapcase
argument_list|(
name|buffer
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|keysize
argument_list|)
expr_stmt|;
name|buffer
index|[
name|keysize
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just a debug aid */
name|mappedkey
operator|.
name|dsize
operator|=
name|keysize
expr_stmt|;
return|return
operator|(
name|fetch
argument_list|(
name|mappedkey
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - fetch - get an entry from the database  *  * Disgusting fine point, in the name of backward compatibility:  if the  * last character of "key" is a NUL, that character is (effectively) not  * part of the comparison against the stored keys.  */
end_comment

begin_function
name|datum
comment|/* dptr NULL, dsize 0 means failure */
name|fetch
parameter_list|(
name|key
parameter_list|)
name|datum
name|key
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|DBZMAXKEY
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|off_t
name|key_ptr
decl_stmt|;
comment|/* return value points here */
name|datum
name|output
decl_stmt|;
specifier|register
name|size_t
name|keysize
decl_stmt|;
specifier|register
name|size_t
name|cmplen
decl_stmt|;
specifier|register
name|char
modifier|*
name|sepp
decl_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"fetch: (%s)\n"
operator|,
name|key
operator|.
name|dptr
operator|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|dptr
operator|=
name|NULL
expr_stmt|;
name|output
operator|.
name|dsize
operator|=
literal|0
expr_stmt|;
name|prevp
operator|=
name|FRESH
expr_stmt|;
comment|/* Key is supposed to be less than DBZMAXKEY */
name|keysize
operator|=
name|key
operator|.
name|dsize
expr_stmt|;
if|if
condition|(
name|keysize
operator|>=
name|DBZMAXKEY
condition|)
block|{
name|keysize
operator|=
name|DBZMAXKEY
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"keysize is %d - truncated to %d\n"
operator|,
name|key
operator|.
name|dsize
operator|,
name|DBZMAXKEY
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pagf
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"fetch: database not open!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|output
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|basef
operator|==
name|NULL
condition|)
block|{
comment|/* basef didn't exist yet */
name|basef
operator|=
name|latebase
argument_list|()
expr_stmt|;
if|if
condition|(
name|basef
operator|==
name|NULL
condition|)
return|return
operator|(
name|output
operator|)
return|;
block|}
name|cmplen
operator|=
name|keysize
expr_stmt|;
name|sepp
operator|=
operator|&
name|conf
operator|.
name|fieldsep
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|dptr
index|[
name|keysize
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|cmplen
operator|--
expr_stmt|;
name|sepp
operator|=
operator|&
name|buffer
index|[
name|keysize
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|start
argument_list|(
operator|&
name|srch
argument_list|,
operator|&
name|key
argument_list|,
name|FRESH
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|key_ptr
operator|=
name|search
argument_list|(
operator|&
name|srch
argument_list|)
operator|)
operator|!=
name|NOTFOUND
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"got 0x%lx\n"
operator|,
name|key_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* fetch the key */
if|if
condition|(
name|fseek
argument_list|(
name|basef
argument_list|,
name|key_ptr
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"fetch: seek failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|output
operator|)
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|keysize
argument_list|,
name|basef
argument_list|)
operator|!=
name|keysize
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"fetch: read failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|output
operator|)
return|;
block|}
comment|/* try it */
name|buffer
index|[
name|keysize
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminated for DEBUG */
operator|(
name|void
operator|)
name|mapcase
argument_list|(
name|buffer
argument_list|,
name|buffer
argument_list|,
name|keysize
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"fetch: buffer (%s) looking for (%s) size = %d\n"
operator|,
name|buffer
operator|,
name|key
operator|.
name|dptr
operator|,
name|keysize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|key
operator|.
name|dptr
argument_list|,
name|buffer
argument_list|,
name|cmplen
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|sepp
operator|==
name|conf
operator|.
name|fieldsep
operator|||
operator|*
name|sepp
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* we found it */
name|output
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|key_ptr
expr_stmt|;
name|output
operator|.
name|dsize
operator|=
name|SOF
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"fetch: successful\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|output
operator|)
return|;
block|}
block|}
comment|/* we didn't find it */
name|DEBUG
argument_list|(
operator|(
literal|"fetch: failed\n"
operator|)
argument_list|)
expr_stmt|;
name|prevp
operator|=
operator|&
name|srch
expr_stmt|;
comment|/* remember where we stopped */
return|return
operator|(
name|output
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - latebase - try to open a base file that wasn't there at the start  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|latebase
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|it
decl_stmt|;
if|if
condition|(
name|basefname
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"latebase: name foulup\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|it
operator|=
name|fopen
argument_list|(
name|basefname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"latebase: still can't open base\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
operator|(
literal|"latebase: late open succeeded\n"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basefname
argument_list|)
expr_stmt|;
name|basefname
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|_IOFBF
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|it
argument_list|,
name|basebuf
argument_list|,
name|_IOFBF
argument_list|,
sizeof|sizeof
argument_list|(
name|basebuf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|it
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dbzstore - store() with case mapping built in  */
end_comment

begin_function
name|int
name|dbzstore
parameter_list|(
name|key
parameter_list|,
name|data
parameter_list|)
name|datum
name|key
decl_stmt|;
name|datum
name|data
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|DBZMAXKEY
operator|+
literal|1
index|]
decl_stmt|;
name|datum
name|mappedkey
decl_stmt|;
specifier|register
name|size_t
name|keysize
decl_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"dbzstore: (%s)\n"
operator|,
name|key
operator|.
name|dptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Key is supposed to be less than DBZMAXKEY */
name|keysize
operator|=
name|key
operator|.
name|dsize
expr_stmt|;
if|if
condition|(
name|keysize
operator|>=
name|DBZMAXKEY
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"dbzstore: key size too big (%d)\n"
operator|,
name|key
operator|.
name|dsize
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mappedkey
operator|.
name|dptr
operator|=
name|mapcase
argument_list|(
name|buffer
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|keysize
argument_list|)
expr_stmt|;
name|buffer
index|[
name|keysize
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just a debug aid */
name|mappedkey
operator|.
name|dsize
operator|=
name|keysize
expr_stmt|;
return|return
operator|(
name|store
argument_list|(
name|mappedkey
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - store - add an entry to the database  */
end_comment

begin_function
name|int
comment|/* 0 success, -1 failure */
name|store
parameter_list|(
name|key
parameter_list|,
name|data
parameter_list|)
name|datum
name|key
decl_stmt|;
name|datum
name|data
decl_stmt|;
block|{
name|off_t
name|value
decl_stmt|;
if|if
condition|(
name|pagf
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"store: database not open!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|basef
operator|==
name|NULL
condition|)
block|{
comment|/* basef didn't exist yet */
name|basef
operator|=
name|latebase
argument_list|()
expr_stmt|;
if|if
condition|(
name|basef
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pagronly
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"store: database open read-only\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|data
operator|.
name|dsize
operator|!=
name|SOF
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"store: value size wrong (%d)\n"
operator|,
name|data
operator|.
name|dsize
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|key
operator|.
name|dsize
operator|>=
name|DBZMAXKEY
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"store: key size too big (%d)\n"
operator|,
name|key
operator|.
name|dsize
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* copy the value in to ensure alignment */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
name|data
operator|.
name|dptr
argument_list|,
name|SOF
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"store: (%s, %ld)\n"
operator|,
name|key
operator|.
name|dptr
operator|,
operator|(
name|long
operator|)
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|okayvalue
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"store: reserved bit or overflow in 0x%lx\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* find the place, exploiting previous search if possible */
name|start
argument_list|(
operator|&
name|srch
argument_list|,
operator|&
name|key
argument_list|,
name|prevp
argument_list|)
expr_stmt|;
while|while
condition|(
name|search
argument_list|(
operator|&
name|srch
argument_list|)
operator|!=
name|NOTFOUND
condition|)
continue|continue;
name|prevp
operator|=
name|FRESH
expr_stmt|;
name|conf
operator|.
name|used
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"store: used count %ld\n"
operator|,
name|conf
operator|.
name|used
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|written
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|set
argument_list|(
operator|&
name|srch
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dbzincore - control attempts to keep .pag file in core  */
end_comment

begin_function
name|int
comment|/* old setting */
name|dbzincore
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
specifier|register
name|int
name|old
init|=
name|incore
decl_stmt|;
name|incore
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - getconf - get configuration from .dir file  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0 success, -1 failure */
name|getconf
parameter_list|(
name|df
parameter_list|,
name|pf
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|df
decl_stmt|;
comment|/* NULL means just give me the default */
specifier|register
name|FILE
modifier|*
name|pf
decl_stmt|;
comment|/* NULL means don't care about .pag */
specifier|register
name|struct
name|dbzconfig
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|c
operator|=
operator|(
name|df
operator|!=
name|NULL
operator|)
condition|?
name|getc
argument_list|(
name|df
argument_list|)
else|:
name|EOF
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* empty file, no configuration known */
name|cp
operator|->
name|olddbz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|df
operator|!=
name|NULL
operator|&&
name|pf
operator|!=
name|NULL
operator|&&
name|getc
argument_list|(
name|pf
argument_list|)
operator|!=
name|EOF
condition|)
name|cp
operator|->
name|olddbz
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|tsize
operator|=
name|DEFSIZE
expr_stmt|;
name|cp
operator|->
name|fieldsep
operator|=
literal|'\t'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUSEDS
condition|;
name|i
operator|++
control|)
name|cp
operator|->
name|used
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|valuesize
operator|=
name|SOF
expr_stmt|;
name|mybytemap
argument_list|(
name|cp
operator|->
name|bytemap
argument_list|)
expr_stmt|;
name|cp
operator|->
name|casemap
operator|=
name|DEFCASE
expr_stmt|;
name|cp
operator|->
name|tagenb
operator|=
name|TAGENB
expr_stmt|;
name|cp
operator|->
name|tagmask
operator|=
name|TAGMASK
expr_stmt|;
name|cp
operator|->
name|tagshift
operator|=
name|TAGSHIFT
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"getconf: defaults (%ld, %c, (0x%lx/0x%lx<<%d))\n"
operator|,
name|cp
operator|->
name|tsize
operator|,
name|cp
operator|->
name|casemap
operator|,
name|cp
operator|->
name|tagenb
operator|,
name|cp
operator|->
name|tagmask
operator|,
name|cp
operator|->
name|tagshift
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|df
argument_list|)
expr_stmt|;
comment|/* first line, the vital stuff */
if|if
condition|(
name|getc
argument_list|(
name|df
argument_list|)
operator|!=
literal|'d'
operator|||
name|getc
argument_list|(
name|df
argument_list|)
operator|!=
literal|'b'
operator|||
name|getc
argument_list|(
name|df
argument_list|)
operator|!=
literal|'z'
condition|)
name|err
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|getno
argument_list|(
name|df
argument_list|,
operator|&
name|err
argument_list|)
operator|!=
name|dbzversion
condition|)
name|err
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|->
name|tsize
operator|=
name|getno
argument_list|(
name|df
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
name|cp
operator|->
name|fieldsep
operator|=
name|getno
argument_list|(
name|df
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|df
argument_list|)
operator|)
operator|==
literal|' '
condition|)
continue|continue;
name|cp
operator|->
name|casemap
operator|=
name|c
expr_stmt|;
name|cp
operator|->
name|tagenb
operator|=
name|getno
argument_list|(
name|df
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
name|cp
operator|->
name|tagmask
operator|=
name|getno
argument_list|(
name|df
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
name|cp
operator|->
name|tagshift
operator|=
name|getno
argument_list|(
name|df
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
name|cp
operator|->
name|valuesize
operator|=
name|getno
argument_list|(
name|df
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|valuesize
operator|!=
name|SOF
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"getconf: wrong off_t size (%d)\n"
operator|,
name|cp
operator|->
name|valuesize
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|->
name|valuesize
operator|=
name|SOF
expr_stmt|;
comment|/* to protect the loops below */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cp
operator|->
name|valuesize
condition|;
name|i
operator|++
control|)
name|cp
operator|->
name|bytemap
index|[
name|i
index|]
operator|=
name|getno
argument_list|(
name|df
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|getc
argument_list|(
name|df
argument_list|)
operator|!=
literal|'\n'
condition|)
name|err
operator|=
operator|-
literal|1
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"size %ld, sep %d, cmap %c, tags 0x%lx/0x%lx<<%d, "
operator|,
name|cp
operator|->
name|tsize
operator|,
name|cp
operator|->
name|fieldsep
operator|,
name|cp
operator|->
name|casemap
operator|,
name|cp
operator|->
name|tagenb
operator|,
name|cp
operator|->
name|tagmask
operator|,
name|cp
operator|->
name|tagshift
operator|)
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"bytemap (%d)"
operator|,
name|cp
operator|->
name|valuesize
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cp
operator|->
name|valuesize
condition|;
name|i
operator|++
control|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|" %d"
operator|,
name|cp
operator|->
name|bytemap
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|DEBUG
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* second line, the usages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUSEDS
condition|;
name|i
operator|++
control|)
name|cp
operator|->
name|used
index|[
name|i
index|]
operator|=
name|getno
argument_list|(
name|df
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|getc
argument_list|(
name|df
argument_list|)
operator|!=
literal|'\n'
condition|)
name|err
operator|=
operator|-
literal|1
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"used %ld %ld %ld...\n"
operator|,
name|cp
operator|->
name|used
index|[
literal|0
index|]
operator|,
name|cp
operator|->
name|used
index|[
literal|1
index|]
operator|,
name|cp
operator|->
name|used
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"getconf error\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - getno - get a long  */
end_comment

begin_function
specifier|static
name|long
name|getno
parameter_list|(
name|f
parameter_list|,
name|ep
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|MAXN
value|50
name|char
name|getbuf
index|[
name|MAXN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
literal|' '
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"getno: missing number\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
name|getbuf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|' '
condition|)
if|if
condition|(
name|p
operator|<
operator|&
name|getbuf
index|[
name|MAXN
operator|-
literal|1
index|]
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"getno: EOF\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strspn
argument_list|(
name|getbuf
argument_list|,
literal|"-1234567890"
argument_list|)
operator|!=
name|strlen
argument_list|(
name|getbuf
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"getno: `%s' non-numeric\n"
operator|,
name|getbuf
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|atol
argument_list|(
name|getbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - putconf - write configuration to .dir file  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0 success, -1 failure */
name|putconf
parameter_list|(
name|f
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|struct
name|dbzconfig
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"fseek failure in putconf\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"dbz %d %ld %d %c %ld %ld %d %d"
argument_list|,
name|dbzversion
argument_list|,
operator|(
name|long
operator|)
name|cp
operator|->
name|tsize
argument_list|,
name|cp
operator|->
name|fieldsep
argument_list|,
name|cp
operator|->
name|casemap
argument_list|,
operator|(
name|long
operator|)
name|cp
operator|->
name|tagenb
argument_list|,
operator|(
name|long
operator|)
name|cp
operator|->
name|tagmask
argument_list|,
name|cp
operator|->
name|tagshift
argument_list|,
name|cp
operator|->
name|valuesize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cp
operator|->
name|valuesize
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %d"
argument_list|,
name|cp
operator|->
name|bytemap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUSEDS
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%ld%c"
argument_list|,
operator|(
name|long
operator|)
name|cp
operator|->
name|used
index|[
name|i
index|]
argument_list|,
operator|(
name|i
operator|<
name|NUSEDS
operator|-
literal|1
operator|)
condition|?
literal|' '
else|:
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"putconf status %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - getcore - try to set up an in-core copy of .pag file  */
end_comment

begin_function
specifier|static
name|off_t
modifier|*
comment|/* pointer to copy, or NULL */
name|getcore
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|off_t
modifier|*
name|p
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
specifier|register
name|size_t
name|nread
decl_stmt|;
specifier|register
name|char
modifier|*
name|it
decl_stmt|;
name|it
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|conf
operator|.
name|tsize
operator|*
name|SOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"getcore: malloc failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nread
operator|=
name|fread
argument_list|(
name|it
argument_list|,
name|SOF
argument_list|,
operator|(
name|size_t
operator|)
name|conf
operator|.
name|tsize
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"getcore: read failed\n"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|it
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|=
operator|(
name|off_t
operator|*
operator|)
name|it
operator|+
name|nread
expr_stmt|;
name|i
operator|=
operator|(
name|size_t
operator|)
name|conf
operator|.
name|tsize
operator|-
name|nread
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|VACANT
expr_stmt|;
return|return
operator|(
operator|(
name|off_t
operator|*
operator|)
name|it
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - putcore - try to rewrite an in-core table  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0 okay, -1 fail */
name|putcore
parameter_list|(
name|tab
parameter_list|,
name|f
parameter_list|)
name|off_t
modifier|*
name|tab
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"fseek failure in putcore\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|SOF
argument_list|,
operator|(
name|size_t
operator|)
name|conf
operator|.
name|tsize
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|ferror
argument_list|(
name|f
argument_list|)
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - start - set up to start or restart a search  */
end_comment

begin_function
specifier|static
name|void
name|start
parameter_list|(
name|sp
parameter_list|,
name|kp
parameter_list|,
name|osp
parameter_list|)
specifier|register
name|struct
name|searcher
modifier|*
name|sp
decl_stmt|;
specifier|register
name|datum
modifier|*
name|kp
decl_stmt|;
specifier|register
name|struct
name|searcher
modifier|*
name|osp
decl_stmt|;
comment|/* may be FRESH, i.e. NULL */
block|{
specifier|register
name|long
name|h
decl_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|kp
operator|->
name|dptr
argument_list|,
name|kp
operator|->
name|dsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|osp
operator|!=
name|FRESH
operator|&&
name|osp
operator|->
name|hash
operator|==
name|h
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|osp
condition|)
operator|*
name|sp
operator|=
operator|*
name|osp
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"search restarted\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|hash
operator|=
name|h
expr_stmt|;
name|sp
operator|->
name|tag
operator|=
name|MKTAG
argument_list|(
name|h
operator|/
name|conf
operator|.
name|tsize
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"tag 0x%lx\n"
operator|,
name|sp
operator|->
name|tag
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|place
operator|=
name|h
operator|%
name|conf
operator|.
name|tsize
expr_stmt|;
name|sp
operator|->
name|tabno
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|run
operator|=
operator|(
name|conf
operator|.
name|olddbz
operator|)
condition|?
name|conf
operator|.
name|tsize
else|:
name|MAXRUN
expr_stmt|;
name|sp
operator|->
name|aborted
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|->
name|seen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - search - conduct part of a search  */
end_comment

begin_function
specifier|static
name|off_t
comment|/* NOTFOUND if we hit VACANT or error */
name|search
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|struct
name|searcher
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|off_t
name|dest
decl_stmt|;
specifier|register
name|off_t
name|value
decl_stmt|;
name|off_t
name|val
decl_stmt|;
comment|/* buffer for value (can't fread register) */
specifier|register
name|off_t
name|place
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|aborted
condition|)
return|return
operator|(
name|NOTFOUND
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* determine location to be examined */
name|place
operator|=
name|sp
operator|->
name|place
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seen
condition|)
block|{
comment|/* go to next location */
if|if
condition|(
operator|--
name|sp
operator|->
name|run
operator|<=
literal|0
condition|)
block|{
name|sp
operator|->
name|tabno
operator|++
expr_stmt|;
name|sp
operator|->
name|run
operator|=
name|MAXRUN
expr_stmt|;
block|}
name|place
operator|=
operator|(
name|place
operator|+
literal|1
operator|)
operator|%
name|conf
operator|.
name|tsize
operator|+
name|sp
operator|->
name|tabno
operator|*
name|conf
operator|.
name|tsize
expr_stmt|;
name|sp
operator|->
name|place
operator|=
name|place
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|seen
operator|=
literal|1
expr_stmt|;
comment|/* now looking at current location */
name|DEBUG
argument_list|(
operator|(
literal|"search @ %ld\n"
operator|,
name|place
operator|)
argument_list|)
expr_stmt|;
comment|/* get the tagged value */
if|if
condition|(
name|corepag
operator|!=
name|NULL
operator|&&
name|place
operator|<
name|conf
operator|.
name|tsize
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"search: in core\n"
operator|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|MAPIN
argument_list|(
name|corepag
index|[
name|place
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* seek, if necessary */
name|dest
operator|=
name|place
operator|*
name|SOF
expr_stmt|;
if|if
condition|(
name|pagpos
operator|!=
name|dest
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|pagf
argument_list|,
name|dest
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"search: seek failed\n"
operator|)
argument_list|)
expr_stmt|;
name|pagpos
operator|=
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|aborted
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NOTFOUND
operator|)
return|;
block|}
name|pagpos
operator|=
name|dest
expr_stmt|;
block|}
comment|/* read it */
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
name|pagf
argument_list|)
operator|==
literal|1
condition|)
name|value
operator|=
name|MAPIN
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|pagf
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"search: read failed\n"
operator|)
argument_list|)
expr_stmt|;
name|pagpos
operator|=
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|aborted
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NOTFOUND
operator|)
return|;
block|}
else|else
name|value
operator|=
name|VACANT
expr_stmt|;
comment|/* and finish up */
name|pagpos
operator|+=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* vacant slot is always cause to return */
if|if
condition|(
name|value
operator|==
name|VACANT
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"search: empty slot\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTFOUND
operator|)
return|;
block|}
empty_stmt|;
comment|/* check the tag */
name|value
operator|=
name|UNBIAS
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"got 0x%lx\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HASTAG
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"tagless\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|TAG
argument_list|(
name|value
argument_list|)
operator|==
name|sp
operator|->
name|tag
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"match\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTAG
argument_list|(
name|value
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
operator|(
literal|"mismatch 0x%lx\n"
operator|,
name|TAG
argument_list|(
name|value
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  - okayvalue - check that a value can be stored  */
end_comment

begin_function
specifier|static
name|int
comment|/* predicate */
name|okayvalue
parameter_list|(
name|value
parameter_list|)
name|off_t
name|value
decl_stmt|;
block|{
if|if
condition|(
name|HASTAG
argument_list|(
name|value
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|OVERFLOW
if|if
condition|(
name|value
operator|==
name|LONG_MAX
condition|)
comment|/* BIAS() and UNBIAS() will overflow */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - set - store a value into a location previously found by search  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0 success, -1 failure */
name|set
parameter_list|(
name|sp
parameter_list|,
name|value
parameter_list|)
specifier|register
name|struct
name|searcher
modifier|*
name|sp
decl_stmt|;
name|off_t
name|value
decl_stmt|;
block|{
specifier|register
name|off_t
name|place
init|=
name|sp
operator|->
name|place
decl_stmt|;
specifier|register
name|off_t
name|v
init|=
name|value
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|aborted
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|CANTAG
argument_list|(
name|v
argument_list|)
operator|&&
operator|!
name|conf
operator|.
name|olddbz
condition|)
block|{
name|v
operator||=
name|sp
operator|->
name|tag
operator||
name|taghere
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|UNBIAS
argument_list|(
name|VACANT
argument_list|)
condition|)
comment|/* BIAS(v) won't look VACANT */
ifdef|#
directive|ifdef
name|OVERFLOW
if|if
condition|(
name|v
operator|!=
name|LONG_MAX
condition|)
comment|/* and it won't overflow */
endif|#
directive|endif
name|value
operator|=
name|v
expr_stmt|;
block|}
name|DEBUG
argument_list|(
operator|(
literal|"tagged value is 0x%lx\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|BIAS
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|MAPOUT
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* If we have the index file in memory, use it */
if|if
condition|(
name|corepag
operator|!=
name|NULL
operator|&&
name|place
operator|<
name|conf
operator|.
name|tsize
condition|)
block|{
name|corepag
index|[
name|place
index|]
operator|=
name|value
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
literal|"set: incore\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* seek to spot */
name|pagpos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* invalidate position memory */
if|if
condition|(
name|fseek
argument_list|(
name|pagf
argument_list|,
name|place
operator|*
name|SOF
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"set: seek failed\n"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|aborted
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* write in data */
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
name|SOF
argument_list|,
literal|1
argument_list|,
name|pagf
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"set: write failed\n"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|aborted
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* fflush improves robustness, and buffer re-use is rare anyway */
if|if
condition|(
name|fflush
argument_list|(
name|pagf
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
literal|"set: fflush failed\n"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|aborted
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DEBUG
argument_list|(
operator|(
literal|"set: succeeded\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - mybytemap - determine this machine's byte map  *  * A byte map is an array of ints, sizeof(off_t) of them.  The 0th int  * is the byte number of the high-order byte in my off_t, and so forth.  */
end_comment

begin_function
specifier|static
name|void
name|mybytemap
parameter_list|(
name|map
parameter_list|)
name|int
name|map
index|[]
decl_stmt|;
comment|/* -> int[SOF] */
block|{
union|union
block|{
name|off_t
name|o
decl_stmt|;
name|char
name|c
index|[
name|SOF
index|]
decl_stmt|;
block|}
name|u
union|;
specifier|register
name|int
modifier|*
name|mp
init|=
operator|&
name|map
index|[
name|SOF
index|]
decl_stmt|;
specifier|register
name|int
name|ntodo
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|u
operator|.
name|o
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ntodo
operator|=
operator|(
name|int
operator|)
name|SOF
init|;
name|ntodo
operator|>
literal|0
condition|;
name|ntodo
operator|--
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOF
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|u
operator|.
name|c
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|SOF
condition|)
block|{
comment|/* trouble -- set it to *something* consistent */
name|DEBUG
argument_list|(
operator|(
literal|"mybytemap: nonexistent byte %d!!!\n"
operator|,
name|ntodo
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOF
condition|;
name|i
operator|++
control|)
name|map
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
return|return;
block|}
name|DEBUG
argument_list|(
operator|(
literal|"mybytemap: byte %d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|--
name|mp
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|u
operator|.
name|c
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|u
operator|.
name|o
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  - bytemap - transform an off_t from byte ordering map1 to map2  */
end_comment

begin_function
specifier|static
name|off_t
comment|/* transformed result */
name|bytemap
parameter_list|(
name|ino
parameter_list|,
name|map1
parameter_list|,
name|map2
parameter_list|)
name|off_t
name|ino
decl_stmt|;
name|int
modifier|*
name|map1
decl_stmt|;
name|int
modifier|*
name|map2
decl_stmt|;
block|{
union|union
name|oc
block|{
name|off_t
name|o
decl_stmt|;
name|char
name|c
index|[
name|SOF
index|]
decl_stmt|;
block|}
union|;
name|union
name|oc
name|in
decl_stmt|;
name|union
name|oc
name|out
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|in
operator|.
name|o
operator|=
name|ino
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOF
condition|;
name|i
operator|++
control|)
name|out
operator|.
name|c
index|[
name|map2
index|[
name|i
index|]
index|]
operator|=
name|in
operator|.
name|c
index|[
name|map1
index|[
name|i
index|]
index|]
expr_stmt|;
return|return
operator|(
name|out
operator|.
name|o
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is a simplified version of the pathalias hashing function.  * Thanks to Steve Belovin and Peter Honeyman  *  * hash a string into a long int.  31 bit crc (from andrew appel).  * the crc table is computed at run time by crcinit() -- we could  * precompute, but it takes 1 clock tick on a 750.  *  * This fast table calculation works only if POLY is a prime polynomial  * in the field of integers modulo 2.  Since the coefficients of a  * 32-bit polynomial won't fit in a 32-bit word, the high-order bit is  * implicit.  IT MUST ALSO BE THE CASE that the coefficients of orders  * 31 down to 25 are zero.  Happily, we have candidates, from  * E. J.  Watson, "Primitive Polynomials (Mod 2)", Math. Comp. 16 (1962):  *	x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + x^0  *	x^31 + x^3 + x^0  *  * We reverse the bits to get:  *	111101010000000000000000000000001 but drop the last 1  *         f   5   0   0   0   0   0   0  *	010010000000000000000000000000001 ditto, for 31-bit crc  *	   4   8   0   0   0   0   0   0  */
end_comment

begin_define
define|#
directive|define
name|POLY
value|0x48000000L
end_define

begin_comment
comment|/* 31-bit polynomial (avoids sign problems) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|CrcTable
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  - crcinit - initialize tables for hash function  */
end_comment

begin_function
specifier|static
name|void
name|crcinit
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|long
name|sum
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|=
literal|0L
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|7
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|i
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|sum
operator|^=
name|POLY
operator|>>
name|j
expr_stmt|;
name|CrcTable
index|[
name|i
index|]
operator|=
name|sum
expr_stmt|;
block|}
name|DEBUG
argument_list|(
operator|(
literal|"crcinit: done\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - hash - Honeyman's nice hashing function  */
end_comment

begin_function
specifier|static
name|long
name|hash
parameter_list|(
name|name
parameter_list|,
name|size
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|long
name|sum
init|=
literal|0L
decl_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|7
operator|)
operator|^
name|CrcTable
index|[
operator|(
name|sum
operator|^
operator|(
operator|*
name|name
operator|++
operator|)
operator|)
operator|&
literal|0x7f
index|]
expr_stmt|;
block|}
name|DEBUG
argument_list|(
operator|(
literal|"hash: returns (%ld)\n"
operator|,
name|sum
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * case-mapping stuff  *  * Borrowed from C News, by permission of the authors.  Somewhat modified.  *  * We exploit the fact that we are dealing only with headers here, and  * headers are limited to the ASCII characters by RFC822.  It is barely  * possible that we might be dealing with a translation into another  * character set, but in particular it's very unlikely for a header  * character to be outside -128..255.  *  * Life would be a whole lot simpler if tolower() could safely and portably  * be applied to any char.  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|128
end_define

begin_comment
comment|/* avoid trouble with negative chars */
end_comment

begin_comment
comment|/* must call casencmp before invoking TOLOW... */
end_comment

begin_define
define|#
directive|define
name|TOLOW
parameter_list|(
name|c
parameter_list|)
value|(cmap[(c)+OFFSET])
end_define

begin_comment
comment|/* ...but the use of it in CISTREQN is safe without the preliminary call (!) */
end_comment

begin_comment
comment|/* CISTREQN is an optimised case-insensitive strncmp(a,b,n)==0; n> 0 */
end_comment

begin_define
define|#
directive|define
name|CISTREQN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|(TOLOW((a)[0]) == TOLOW((b)[0])&& casencmp(a, b, n) == 0)
end_define

begin_define
define|#
directive|define
name|MAPSIZE
value|(256+OFFSET)
end_define

begin_decl_stmt
specifier|static
name|char
name|cmap
index|[
name|MAPSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* relies on init to '\0' */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mprimed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* has cmap been set up? */
end_comment

begin_comment
comment|/*  - mapprime - set up case-mapping stuff  */
end_comment

begin_function
specifier|static
name|void
name|mapprime
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|char
modifier|*
name|up
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|lower
index|[]
init|=
literal|"abcdefghijklmnopqrstuvwxyz"
decl_stmt|;
specifier|static
name|char
name|upper
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|lower
operator|,
name|up
operator|=
name|upper
init|;
operator|*
name|lp
operator|!=
literal|'\0'
condition|;
name|lp
operator|++
operator|,
name|up
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|lp
expr_stmt|;
name|cmap
index|[
name|c
operator|+
name|OFFSET
index|]
operator|=
name|c
expr_stmt|;
name|cmap
index|[
operator|*
name|up
operator|+
name|OFFSET
index|]
operator|=
name|c
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAPSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cmap
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
name|cmap
index|[
name|i
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|i
operator|-
name|OFFSET
argument_list|)
expr_stmt|;
name|mprimed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - casencmp - case-independent strncmp  */
end_comment

begin_function
specifier|static
name|int
comment|/*< ==> 0 */
name|casencmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|mprimed
condition|)
name|mapprime
argument_list|()
expr_stmt|;
name|p1
operator|=
name|s1
expr_stmt|;
name|p2
operator|=
name|s2
expr_stmt|;
name|n
operator|=
name|len
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
operator|*
name|p1
operator|!=
literal|'\0'
operator|&&
name|TOLOW
argument_list|(
operator|*
name|p1
argument_list|)
operator|==
name|TOLOW
argument_list|(
operator|*
name|p2
argument_list|)
condition|)
block|{
name|p1
operator|++
expr_stmt|;
name|p2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The following case analysis is necessary so that characters 	 * which look negative collate low against normal characters but 	 * high against the end-of-string NUL. 	 */
if|if
condition|(
operator|*
name|p1
operator|==
literal|'\0'
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|p1
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|p2
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|TOLOW
argument_list|(
operator|*
name|p1
argument_list|)
operator|-
name|TOLOW
argument_list|(
operator|*
name|p2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - mapcase - do case-mapped copy  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* returns src or dst */
name|mapcase
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|siz
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* destination, used only if mapping needed */
name|char
modifier|*
name|src
decl_stmt|;
comment|/* source; src == dst is legal */
name|size_t
name|siz
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|c
decl_stmt|;
comment|/* case break */
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
comment|/* end of source */
name|c
operator|=
name|cipoint
argument_list|(
name|src
argument_list|,
name|siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
operator|(
name|src
operator|)
return|;
if|if
condition|(
operator|!
name|mprimed
condition|)
name|mapprime
argument_list|()
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
name|e
operator|=
name|s
operator|+
name|siz
expr_stmt|;
name|d
operator|=
name|dst
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|c
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
operator|*
name|d
operator|++
operator|=
name|TOLOW
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - cipoint - where in this message-ID does it become case-insensitive?  *  * The RFC822 code is not quite complete.  Absolute, total, full RFC822  * compliance requires a horrible parsing job, because of the arcane  * quoting conventions -- abc"def"ghi is not equivalent to abc"DEF"ghi,  * for example.  There are three or four things that might occur in the  * domain part of a message-id that are case-sensitive.  They don't seem  * to ever occur in real news, thank Cthulhu.  (What?  You were expecting  * a merciful and forgiving deity to be invoked in connection with RFC822?  * Forget it; none of them would come near it.)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* pointer into s, or NULL for "nowhere" */
name|cipoint
parameter_list|(
name|s
parameter_list|,
name|siz
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|siz
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|post
index|[]
init|=
literal|"postmaster"
decl_stmt|;
specifier|static
name|int
name|plen
init|=
sizeof|sizeof
argument_list|(
name|post
argument_list|)
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|conf
operator|.
name|casemap
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* unmapped, sensible */
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
literal|'C'
case|:
comment|/* C News, RFC 822 conformant (approx.) */
name|p
operator|=
name|memchr
argument_list|(
name|s
argument_list|,
literal|'@'
argument_list|,
name|siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* no local/domain split */
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* assume all local */
elseif|else
if|if
condition|(
name|p
operator|-
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
name|plen
operator|&&
name|CISTREQN
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|post
argument_list|,
name|plen
argument_list|)
condition|)
block|{
comment|/* crazy -- "postmaster" is case-insensitive */
return|return
operator|(
name|s
operator|)
return|;
block|}
else|else
return|return
operator|(
name|p
operator|)
return|;
break|break;
case|case
literal|'='
case|:
comment|/* 2.11, neither sensible nor conformant */
return|return
operator|(
name|s
operator|)
return|;
comment|/* all case-insensitive */
break|break;
block|}
name|DEBUG
argument_list|(
operator|(
literal|"cipoint: unknown case mapping `%c'\n"
operator|,
name|conf
operator|.
name|casemap
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* just leave it alone */
block|}
end_function

begin_comment
comment|/*  - dbzdebug - control dbz debugging at run time  */
end_comment

begin_function
name|int
comment|/* old value */
name|dbzdebug
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBZDEBUG
specifier|register
name|int
name|old
init|=
name|debug
decl_stmt|;
name|debug
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

end_unit

