begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1993 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this library; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_IO_USE_DTOA
end_ifdef

begin_comment
comment|/* Format floating-point number and print them.    Return number of chars printed, or EOF on error.     sign_mode == '+' : print "-" or "+"    sign_mode == ' ' : print "-" or " "    sign_mode == '\0' : print "-' or "" */
end_comment

begin_function
name|int
name|_IO_outfloat
parameter_list|(
name|value
parameter_list|,
name|sb
parameter_list|,
name|type
parameter_list|,
name|width
parameter_list|,
name|precision
parameter_list|,
name|flags
parameter_list|,
name|sign_mode
parameter_list|,
name|fill
parameter_list|)
name|double
name|value
decl_stmt|;
name|_IO_FILE
modifier|*
name|sb
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|sign_mode
decl_stmt|;
name|int
name|fill
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|PUT
parameter_list|(
name|x
parameter_list|)
value|do {if (_IO_putc(x, sb)< 0) goto error; count++;} while (0)
define|#
directive|define
name|PUTN
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|do {int _n=n; count+=_n; if (_IO_sputn(sb, p,_n) != _n) goto error;} while(0)
define|#
directive|define
name|PADN
parameter_list|(
name|fill
parameter_list|,
name|n
parameter_list|)
define|\
value|do {int _n = n; count+=_n; if (_IO_padn(sb, fill, _n) != _n) goto error;} while (0)
name|int
name|pad_kind
init|=
name|flags
operator|&
operator|(
name|_IO_LEFT
operator||
name|_IO_RIGHT
operator||
name|_IO_INTERNAL
operator|)
decl_stmt|;
name|int
name|skip_zeroes
init|=
literal|0
decl_stmt|;
name|int
name|show_dot
init|=
operator|(
name|flags
operator|&
name|_IO_SHOWPOINT
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|decpt
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|exponent_size
decl_stmt|;
name|int
name|print_sign
decl_stmt|;
name|int
name|trailing_zeroes
decl_stmt|,
name|useful_digits
decl_stmt|;
name|int
name|padding
decl_stmt|,
name|unpadded_width
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|exponent_start
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
define|#
directive|define
name|EBUF_SIZE
value|12
define|#
directive|define
name|EBUF_END
value|&ebuf[EBUF_SIZE]
name|char
name|ebuf
index|[
name|EBUF_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|exp
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|mode
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|exp
operator|=
name|type
expr_stmt|;
name|mode
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|precision
operator|!=
literal|999
condition|)
name|precision
operator|++
expr_stmt|;
comment|/* Add one to include digit before decimal point. */
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|exp
operator|=
name|type
operator|==
literal|'g'
condition|?
literal|'e'
else|:
literal|'E'
expr_stmt|;
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
name|precision
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|_IO_SHOWPOINT
operator|)
condition|)
name|skip_zeroes
operator|=
literal|1
expr_stmt|;
name|type
operator|=
literal|'g'
expr_stmt|;
name|mode
operator|=
literal|2
expr_stmt|;
break|break;
block|}
comment|/* Do the actual convension */
if|if
condition|(
name|precision
operator|==
literal|999
operator|&&
name|mode
operator|!=
literal|3
condition|)
name|mode
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|_IO_dtoa
argument_list|(
name|value
argument_list|,
name|mode
argument_list|,
name|precision
argument_list|,
operator|&
name|decpt
argument_list|,
operator|&
name|sign
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|useful_digits
operator|=
name|end
operator|-
name|p
expr_stmt|;
name|exponent_start
operator|=
name|EBUF_END
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|precision
operator|=
name|useful_digits
expr_stmt|;
comment|/* Check if we need to emit an exponent. */
if|if
condition|(
name|mode
operator|!=
literal|3
operator|&&
name|decpt
operator|!=
literal|9999
condition|)
block|{
name|i
operator|=
name|decpt
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
literal|'g'
operator|&&
name|type
operator|!=
literal|'F'
operator|)
operator|||
name|i
operator|<
operator|-
literal|4
operator|||
name|i
operator|>=
name|precision
condition|)
block|{
comment|/* Print the exponent into ebuf. 	     We write ebuf in reverse order (right-to-left). */
name|char
name|sign
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|sign
operator|=
literal|'+'
expr_stmt|;
else|else
name|sign
operator|=
literal|'-'
operator|,
name|i
operator|=
operator|-
name|i
expr_stmt|;
comment|/* Note: ANSI requires at least 2 exponent digits. */
do|do
block|{
operator|*
operator|--
name|exponent_start
operator|=
operator|(
name|i
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|>=
literal|10
condition|)
do|;
operator|*
operator|--
name|exponent_start
operator|=
name|i
operator|+
literal|'0'
expr_stmt|;
operator|*
operator|--
name|exponent_start
operator|=
name|sign
expr_stmt|;
operator|*
operator|--
name|exponent_start
operator|=
name|exp
expr_stmt|;
block|}
block|}
name|exponent_size
operator|=
name|EBUF_END
operator|-
name|exponent_start
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
name|precision
operator|=
literal|1
expr_stmt|;
comment|/* If we print an exponent, always show just one digit before point. */
if|if
condition|(
name|exponent_size
condition|)
name|decpt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|decpt
operator|==
literal|9999
condition|)
block|{
comment|/* Infinity or NaN */
name|decpt
operator|=
name|useful_digits
expr_stmt|;
name|precision
operator|=
literal|0
expr_stmt|;
name|show_dot
operator|=
literal|0
expr_stmt|;
block|}
comment|/* dtoa truncates trailing zeroes.  Set the variable trailing_zeroes to      the number of 0's we have to add (after the decimal point). */
if|if
condition|(
name|skip_zeroes
condition|)
name|trailing_zeroes
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|'f'
condition|)
name|trailing_zeroes
operator|=
name|useful_digits
operator|<=
name|decpt
condition|?
name|precision
else|:
name|precision
operator|-
operator|(
name|useful_digits
operator|-
name|decpt
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exponent_size
condition|)
comment|/* 'e' 'E' or 'g' format using exponential notation*/
name|trailing_zeroes
operator|=
name|precision
operator|-
name|useful_digits
expr_stmt|;
else|else
comment|/* 'g' format not using exponential notation. */
name|trailing_zeroes
operator|=
name|useful_digits
operator|<=
name|decpt
condition|?
name|precision
operator|-
name|decpt
else|:
name|precision
operator|-
name|useful_digits
expr_stmt|;
if|if
condition|(
name|trailing_zeroes
operator|<
literal|0
condition|)
name|trailing_zeroes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|trailing_zeroes
operator|!=
literal|0
operator|||
name|useful_digits
operator|>
name|decpt
condition|)
name|show_dot
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sign_mode
operator|==
literal|0
condition|)
name|print_sign
operator|=
name|sign
condition|?
literal|'-'
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sign_mode
operator|==
literal|'+'
condition|)
name|print_sign
operator|=
name|sign
condition|?
literal|'-'
else|:
literal|'+'
expr_stmt|;
else|else
comment|/* if (sign_mode == ' ') */
name|print_sign
operator|=
name|sign
condition|?
literal|'-'
else|:
literal|' '
expr_stmt|;
comment|/* Calculate the width (before padding). */
name|unpadded_width
operator|=
operator|(
name|print_sign
operator|!=
literal|0
operator|)
operator|+
name|trailing_zeroes
operator|+
name|exponent_size
operator|+
name|show_dot
operator|+
name|useful_digits
operator|+
operator|(
name|decpt
operator|>
name|useful_digits
condition|?
name|decpt
operator|-
name|useful_digits
else|:
name|decpt
operator|>
literal|0
condition|?
literal|0
else|:
literal|1
operator|-
name|decpt
operator|)
expr_stmt|;
name|padding
operator|=
name|width
operator|>
name|unpadded_width
condition|?
name|width
operator|-
name|unpadded_width
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|padding
operator|>
literal|0
operator|&&
name|pad_kind
operator|!=
name|_IO_LEFT
operator|&&
name|pad_kind
operator|!=
name|_IO_INTERNAL
condition|)
name|PADN
argument_list|(
name|fill
argument_list|,
name|padding
argument_list|)
expr_stmt|;
comment|/* Default (right) adjust */
if|if
condition|(
name|print_sign
condition|)
name|PUT
argument_list|(
name|print_sign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad_kind
operator|==
name|_IO_INTERNAL
operator|&&
name|padding
operator|>
literal|0
condition|)
name|PADN
argument_list|(
name|fill
argument_list|,
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|decpt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|useful_digits
operator|>=
name|decpt
condition|)
name|PUTN
argument_list|(
name|p
argument_list|,
name|decpt
argument_list|)
expr_stmt|;
else|else
block|{
name|PUTN
argument_list|(
name|p
argument_list|,
name|useful_digits
argument_list|)
expr_stmt|;
name|PADN
argument_list|(
literal|'0'
argument_list|,
name|decpt
operator|-
name|useful_digits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_dot
condition|)
block|{
name|PUT
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
comment|/* Print digits after the decimal point. */
if|if
condition|(
name|useful_digits
operator|>
name|decpt
condition|)
name|PUTN
argument_list|(
name|p
operator|+
name|decpt
argument_list|,
name|useful_digits
operator|-
name|decpt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|PUT
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_dot
condition|)
block|{
name|PUT
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|PADN
argument_list|(
literal|'0'
argument_list|,
operator|-
name|decpt
argument_list|)
expr_stmt|;
comment|/* Print digits after the decimal point. */
name|PUTN
argument_list|(
name|p
argument_list|,
name|useful_digits
argument_list|)
expr_stmt|;
block|}
block|}
name|PADN
argument_list|(
literal|'0'
argument_list|,
name|trailing_zeroes
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent_size
condition|)
name|PUTN
argument_list|(
name|exponent_start
argument_list|,
name|exponent_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad_kind
operator|==
name|_IO_LEFT
operator|&&
name|padding
operator|>
literal|0
condition|)
comment|/* Left adjustment*/
name|PADN
argument_list|(
name|fill
argument_list|,
name|padding
argument_list|)
expr_stmt|;
return|return
name|count
return|;
name|error
label|:
return|return
name|EOF
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

