begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1993, 1997, 1998 Free Software Foundation, Inc.    This file is part of the GNU IO Library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"strfile.h"
end_include

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The following definitions are for exposition only.    They map the terminology used in the ANSI/ISO C++ draft standard    to the implementation. */
end_comment

begin_comment
comment|/* allocated:  set  when a dynamic array object has been allocated, and    hence should be freed by the destructor for the strstreambuf object. */
end_comment

begin_define
define|#
directive|define
name|ALLOCATED
parameter_list|(
name|FP
parameter_list|)
value|((FP)->_f._IO_buf_base&& DYNAMIC(FP))
end_define

begin_comment
comment|/* constant:  set when the array object has const elements,    so the output sequence cannot be written. */
end_comment

begin_define
define|#
directive|define
name|CONSTANT
parameter_list|(
name|FP
parameter_list|)
value|((FP)->_f._IO_file_flags& _IO_NO_WRITES)
end_define

begin_comment
comment|/* alsize:  the suggested minimum size for a dynamic array object. */
end_comment

begin_define
define|#
directive|define
name|ALSIZE
parameter_list|(
name|FP
parameter_list|)
value|???
end_define

begin_comment
comment|/* not stored */
end_comment

begin_comment
comment|/* palloc: points to the function to call to allocate a dynamic array object.*/
end_comment

begin_define
define|#
directive|define
name|PALLOC
parameter_list|(
name|FP
parameter_list|)
define|\
value|((FP)->_s._allocate_buffer == default_alloc ? 0 : (FP)->_s._allocate_buffer)
end_define

begin_comment
comment|/* pfree: points  to  the  function  to call to free a dynamic array object. */
end_comment

begin_define
define|#
directive|define
name|PFREE
parameter_list|(
name|FP
parameter_list|)
define|\
value|((FP)->_s._free_buffer == default_free ? 0 : (FP)->_s._free_buffer)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TODO
end_ifdef

begin_comment
comment|/* An "unbounded buffer" is when a buffer is supplied, but with no    specified length.  An example is the buffer argument to sprintf.    */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_IO_str_init_static
parameter_list|(
name|fp
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|,
name|pstart
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|pstart
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* If size is negative 'the characters are assumed to 	 continue indefinitely.'  This is kind of messy ... */
name|int
name|s
decl_stmt|;
name|size
operator|=
literal|512
expr_stmt|;
comment|/* Try increasing powers of 2, as long as we don't wrap around. */
for|for
control|(
init|;
name|s
operator|=
literal|2
operator|*
name|size
operator|,
name|s
operator|>
literal|0
operator|&&
name|ptr
operator|+
name|s
operator|>
name|ptr
operator|&&
name|s
operator|<
literal|0x4000000L
condition|;
control|)
name|size
operator|=
name|s
expr_stmt|;
comment|/* Try increasing size as much as we can without wrapping around. */
for|for
control|(
name|s
operator|=
name|size
operator|>>
literal|1
init|;
name|s
operator|>
literal|0
condition|;
name|s
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|ptr
operator|+
name|size
operator|+
name|s
operator|>
name|ptr
condition|)
name|size
operator|+=
name|s
expr_stmt|;
block|}
block|}
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|ptr
argument_list|,
name|ptr
operator|+
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|ptr
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|ptr
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|pstart
condition|)
block|{
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|pstart
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
name|ptr
operator|+
name|size
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|pstart
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|ptr
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
name|ptr
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|ptr
operator|+
name|size
expr_stmt|;
block|}
comment|/* A null _allocate_buffer function flags the strfile as being static. */
operator|(
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
name|fp
operator|)
operator|->
name|_s
operator|.
name|_allocate_buffer
operator|)
operator|=
operator|(
name|_IO_alloc_type
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_IO_str_init_readonly
parameter_list|(
name|fp
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|_IO_str_init_static
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_file_flags
operator||=
name|_IO_NO_WRITES
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_IO_str_overflow
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|int
name|flush_only
init|=
name|c
operator|==
name|EOF
decl_stmt|;
name|_IO_size_t
name|pos
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_WRITES
condition|)
return|return
name|flush_only
condition|?
literal|0
else|:
name|EOF
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_TIED_PUT_GET
operator|)
operator|&&
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
condition|)
block|{
name|fp
operator|->
name|_flags
operator||=
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
block|}
name|pos
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
call|(
name|_IO_size_t
call|)
argument_list|(
name|_IO_blen
argument_list|(
name|fp
argument_list|)
operator|+
name|flush_only
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
condition|)
comment|/* not allowed to enlarge */
return|return
name|EOF
return|;
else|else
block|{
name|char
modifier|*
name|new_buf
decl_stmt|;
name|char
modifier|*
name|old_buf
init|=
name|fp
operator|->
name|_IO_buf_base
decl_stmt|;
name|_IO_size_t
name|new_size
init|=
literal|2
operator|*
name|_IO_blen
argument_list|(
name|fp
argument_list|)
operator|+
literal|100
decl_stmt|;
name|new_buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
name|fp
operator|)
operator|->
name|_s
operator|.
name|_allocate_buffer
operator|)
operator|(
name|new_size
operator|)
expr_stmt|;
if|if
condition|(
name|new_buf
operator|==
name|NULL
condition|)
block|{
comment|/*	  __ferror(fp) = 1; */
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
condition|)
block|{
name|memcpy
argument_list|(
name|new_buf
argument_list|,
name|old_buf
argument_list|,
name|_IO_blen
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
name|fp
operator|)
operator|->
name|_s
operator|.
name|_free_buffer
operator|)
operator|(
name|fp
operator|->
name|_IO_buf_base
operator|)
expr_stmt|;
comment|/* Make sure _IO_setb won't try to delete _IO_buf_base. */
name|fp
operator|->
name|_IO_buf_base
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (lenp ==&LEN(fp))
comment|/* use '\0'-filling */
block|memset (new_buf + pos, 0, blen() - pos);
endif|#
directive|endif
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|new_buf
argument_list|,
name|new_buf
operator|+
name|new_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|new_buf
operator|+
operator|(
name|fp
operator|->
name|_IO_read_base
operator|-
name|old_buf
operator|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|new_buf
operator|+
operator|(
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|old_buf
operator|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|new_buf
operator|+
operator|(
name|fp
operator|->
name|_IO_read_end
operator|-
name|old_buf
operator|)
expr_stmt|;
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|new_buf
operator|+
operator|(
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|old_buf
operator|)
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|new_buf
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_IO_buf_end
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|flush_only
condition|)
operator|*
name|fp
operator|->
name|_IO_write_ptr
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_read_end
condition|)
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_write_ptr
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|int
name|_IO_str_underflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_read_end
condition|)
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_write_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_TIED_PUT_GET
operator|)
operator|&&
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
condition|)
block|{
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_write_ptr
expr_stmt|;
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
operator|)
return|;
else|else
return|return
name|EOF
return|;
block|}
end_function

begin_comment
comment|/* The size of the valid part of the buffer.  */
end_comment

begin_function
name|_IO_ssize_t
name|_IO_str_count
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_read_end
condition|?
name|fp
operator|->
name|_IO_write_ptr
else|:
name|fp
operator|->
name|_IO_read_end
operator|)
operator|-
name|fp
operator|->
name|_IO_read_base
operator|)
return|;
block|}
end_function

begin_function
name|_IO_pos_t
name|_IO_str_seekoff
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|,
name|dir
parameter_list|,
name|mode
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_off_t
name|offset
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|_IO_ssize_t
name|cur_size
init|=
name|_IO_str_count
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|_IO_pos_t
name|new_pos
init|=
name|EOF
decl_stmt|;
comment|/* Move the get pointer, if requested. */
if|if
condition|(
name|mode
operator|&
name|_IOS_INPUT
condition|)
block|{
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|_IO_seek_end
case|:
name|offset
operator|+=
name|cur_size
expr_stmt|;
break|break;
case|case
name|_IO_seek_cur
case|:
name|offset
operator|+=
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
break|break;
default|default:
comment|/* case _IO_seek_set: */
break|break;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
operator|(
name|_IO_ssize_t
operator|)
name|offset
operator|>
name|cur_size
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|offset
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|cur_size
expr_stmt|;
name|new_pos
operator|=
name|offset
expr_stmt|;
block|}
comment|/* Move the put pointer, if requested. */
if|if
condition|(
name|mode
operator|&
name|_IOS_OUTPUT
condition|)
block|{
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|_IO_seek_end
case|:
name|offset
operator|+=
name|cur_size
expr_stmt|;
break|break;
case|case
name|_IO_seek_cur
case|:
name|offset
operator|+=
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
expr_stmt|;
break|break;
default|default:
comment|/* case _IO_seek_set: */
break|break;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
operator|(
name|_IO_ssize_t
operator|)
name|offset
operator|>
name|cur_size
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_base
operator|+
name|offset
expr_stmt|;
name|new_pos
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|new_pos
return|;
block|}
end_function

begin_function
name|int
name|_IO_str_pbackfail
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_WRITES
operator|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
return|return
name|EOF
return|;
return|return
name|_IO_default_pbackfail
argument_list|(
name|fp
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|_IO_str_finish
parameter_list|(
name|fp
parameter_list|,
name|dummy
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|dummy
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|&&
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
operator|)
condition|)
operator|(
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
name|fp
operator|)
operator|->
name|_s
operator|.
name|_free_buffer
operator|)
operator|(
name|fp
operator|->
name|_IO_buf_base
operator|)
expr_stmt|;
name|fp
operator|->
name|_IO_buf_base
operator|=
name|NULL
expr_stmt|;
name|_IO_default_finish
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|_IO_jump_t
name|_IO_str_jumps
init|=
block|{
name|JUMP_INIT_DUMMY
block|,
name|JUMP_INIT
argument_list|(
name|finish
argument_list|,
name|_IO_str_finish
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|overflow
argument_list|,
name|_IO_str_overflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|underflow
argument_list|,
name|_IO_str_underflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|uflow
argument_list|,
name|_IO_default_uflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|pbackfail
argument_list|,
name|_IO_str_pbackfail
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsputn
argument_list|,
name|_IO_default_xsputn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsgetn
argument_list|,
name|_IO_default_xsgetn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekoff
argument_list|,
name|_IO_str_seekoff
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekpos
argument_list|,
name|_IO_default_seekpos
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|setbuf
argument_list|,
name|_IO_default_setbuf
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|sync
argument_list|,
name|_IO_default_sync
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|doallocate
argument_list|,
name|_IO_default_doallocate
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|read
argument_list|,
name|_IO_default_read
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|write
argument_list|,
name|_IO_default_write
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seek
argument_list|,
name|_IO_default_seek
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|close
argument_list|,
name|_IO_default_close
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
argument|stat
argument_list|,
argument|_IO_default_stat
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

