begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- SelectionDAGBuilder.h - Selection-DAG building --------*- C++ -*---===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This implements routines for translating from LLVM IR into SelectionDAG IR.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_CODEGEN_SELECTIONDAG_SELECTIONDAGBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_CODEGEN_SELECTIONDAG_SELECTIONDAGBUILDER_H
end_define

begin_include
include|#
directive|include
file|"StatepointLowering.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/Analysis.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAG.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAGNodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/CallSite.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Statepoint.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetLowering.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|AddrSpaceCastInst
decl_stmt|;
name|class
name|AliasAnalysis
decl_stmt|;
name|class
name|AllocaInst
decl_stmt|;
name|class
name|BasicBlock
decl_stmt|;
name|class
name|BitCastInst
decl_stmt|;
name|class
name|BranchInst
decl_stmt|;
name|class
name|CallInst
decl_stmt|;
name|class
name|DbgValueInst
decl_stmt|;
name|class
name|ExtractElementInst
decl_stmt|;
name|class
name|ExtractValueInst
decl_stmt|;
name|class
name|FCmpInst
decl_stmt|;
name|class
name|FPExtInst
decl_stmt|;
name|class
name|FPToSIInst
decl_stmt|;
name|class
name|FPToUIInst
decl_stmt|;
name|class
name|FPTruncInst
decl_stmt|;
name|class
name|Function
decl_stmt|;
name|class
name|FunctionLoweringInfo
decl_stmt|;
name|class
name|GetElementPtrInst
decl_stmt|;
name|class
name|GCFunctionInfo
decl_stmt|;
name|class
name|ICmpInst
decl_stmt|;
name|class
name|IntToPtrInst
decl_stmt|;
name|class
name|IndirectBrInst
decl_stmt|;
name|class
name|InvokeInst
decl_stmt|;
name|class
name|InsertElementInst
decl_stmt|;
name|class
name|InsertValueInst
decl_stmt|;
name|class
name|Instruction
decl_stmt|;
name|class
name|LoadInst
decl_stmt|;
name|class
name|MachineBasicBlock
decl_stmt|;
name|class
name|MachineInstr
decl_stmt|;
name|class
name|MachineRegisterInfo
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|class
name|MVT
decl_stmt|;
name|class
name|PHINode
decl_stmt|;
name|class
name|PtrToIntInst
decl_stmt|;
name|class
name|ReturnInst
decl_stmt|;
name|class
name|SDDbgValue
decl_stmt|;
name|class
name|SExtInst
decl_stmt|;
name|class
name|SelectInst
decl_stmt|;
name|class
name|ShuffleVectorInst
decl_stmt|;
name|class
name|SIToFPInst
decl_stmt|;
name|class
name|StoreInst
decl_stmt|;
name|class
name|SwitchInst
decl_stmt|;
name|class
name|DataLayout
decl_stmt|;
name|class
name|TargetLibraryInfo
decl_stmt|;
name|class
name|TargetLowering
decl_stmt|;
name|class
name|TruncInst
decl_stmt|;
name|class
name|UIToFPInst
decl_stmt|;
name|class
name|UnreachableInst
decl_stmt|;
name|class
name|VAArgInst
decl_stmt|;
name|class
name|ZExtInst
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|/// SelectionDAGBuilder - This is the common target-independent lowering
comment|/// implementation that is parameterized by a TargetLowering object.
comment|///
name|class
name|SelectionDAGBuilder
block|{
comment|/// CurInst - The current instruction being visited
specifier|const
name|Instruction
modifier|*
name|CurInst
decl_stmt|;
name|DenseMap
operator|<
specifier|const
name|Value
operator|*
operator|,
name|SDValue
operator|>
name|NodeMap
expr_stmt|;
comment|/// UnusedArgNodeMap - Maps argument value for unused arguments. This is used
comment|/// to preserve debug information for incoming arguments.
name|DenseMap
operator|<
specifier|const
name|Value
operator|*
operator|,
name|SDValue
operator|>
name|UnusedArgNodeMap
expr_stmt|;
comment|/// DanglingDebugInfo - Helper type for DanglingDebugInfoMap.
name|class
name|DanglingDebugInfo
block|{
specifier|const
name|DbgValueInst
modifier|*
name|DI
decl_stmt|;
name|DebugLoc
name|dl
decl_stmt|;
name|unsigned
name|SDNodeOrder
decl_stmt|;
name|public
label|:
name|DanglingDebugInfo
argument_list|()
operator|:
name|DI
argument_list|(
name|nullptr
argument_list|)
operator|,
name|dl
argument_list|(
name|DebugLoc
argument_list|()
argument_list|)
operator|,
name|SDNodeOrder
argument_list|(
literal|0
argument_list|)
block|{ }
name|DanglingDebugInfo
argument_list|(
argument|const DbgValueInst *di
argument_list|,
argument|DebugLoc DL
argument_list|,
argument|unsigned SDNO
argument_list|)
operator|:
name|DI
argument_list|(
name|di
argument_list|)
operator|,
name|dl
argument_list|(
name|DL
argument_list|)
operator|,
name|SDNodeOrder
argument_list|(
argument|SDNO
argument_list|)
block|{ }
specifier|const
name|DbgValueInst
operator|*
name|getDI
argument_list|()
block|{
return|return
name|DI
return|;
block|}
name|DebugLoc
name|getdl
parameter_list|()
block|{
return|return
name|dl
return|;
block|}
name|unsigned
name|getSDNodeOrder
parameter_list|()
block|{
return|return
name|SDNodeOrder
return|;
block|}
block|}
empty_stmt|;
comment|/// DanglingDebugInfoMap - Keeps track of dbg_values for which we have not
comment|/// yet seen the referent.  We defer handling these until we do see it.
name|DenseMap
operator|<
specifier|const
name|Value
operator|*
operator|,
name|DanglingDebugInfo
operator|>
name|DanglingDebugInfoMap
expr_stmt|;
name|public
label|:
comment|/// PendingLoads - Loads are not emitted to the program immediately.  We bunch
comment|/// them up and then emit token factor nodes when possible.  This allows us to
comment|/// get simple disambiguation between loads without worrying about alias
comment|/// analysis.
name|SmallVector
operator|<
name|SDValue
operator|,
literal|8
operator|>
name|PendingLoads
expr_stmt|;
comment|/// State used while lowering a statepoint sequence (gc_statepoint,
comment|/// gc_relocate, and gc_result).  See StatepointLowering.hpp/cpp for details.
name|StatepointLoweringState
name|StatepointLowering
decl_stmt|;
name|private
label|:
comment|/// PendingExports - CopyToReg nodes that copy values to virtual registers
comment|/// for export to other blocks need to be emitted before any terminator
comment|/// instruction, but they have no other ordering requirements. We bunch them
comment|/// up and the emit a single tokenfactor for them just before terminator
comment|/// instructions.
name|SmallVector
operator|<
name|SDValue
operator|,
literal|8
operator|>
name|PendingExports
expr_stmt|;
comment|/// SDNodeOrder - A unique monotonically increasing number used to order the
comment|/// SDNodes we create.
name|unsigned
name|SDNodeOrder
decl_stmt|;
enum|enum
name|CaseClusterKind
block|{
comment|/// A cluster of adjacent case labels with the same destination, or just one
comment|/// case.
name|CC_Range
block|,
comment|/// A cluster of cases suitable for jump table lowering.
name|CC_JumpTable
block|,
comment|/// A cluster of cases suitable for bit test lowering.
name|CC_BitTests
block|}
enum|;
comment|/// A cluster of case labels.
struct|struct
name|CaseCluster
block|{
name|CaseClusterKind
name|Kind
decl_stmt|;
specifier|const
name|ConstantInt
modifier|*
name|Low
decl_stmt|,
modifier|*
name|High
decl_stmt|;
union|union
block|{
name|MachineBasicBlock
modifier|*
name|MBB
decl_stmt|;
name|unsigned
name|JTCasesIndex
decl_stmt|;
name|unsigned
name|BTCasesIndex
decl_stmt|;
block|}
union|;
name|uint32_t
name|Weight
decl_stmt|;
specifier|static
name|CaseCluster
name|range
parameter_list|(
specifier|const
name|ConstantInt
modifier|*
name|Low
parameter_list|,
specifier|const
name|ConstantInt
modifier|*
name|High
parameter_list|,
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|,
name|uint32_t
name|Weight
parameter_list|)
block|{
name|CaseCluster
name|C
decl_stmt|;
name|C
operator|.
name|Kind
operator|=
name|CC_Range
expr_stmt|;
name|C
operator|.
name|Low
operator|=
name|Low
expr_stmt|;
name|C
operator|.
name|High
operator|=
name|High
expr_stmt|;
name|C
operator|.
name|MBB
operator|=
name|MBB
expr_stmt|;
name|C
operator|.
name|Weight
operator|=
name|Weight
expr_stmt|;
return|return
name|C
return|;
block|}
specifier|static
name|CaseCluster
name|jumpTable
parameter_list|(
specifier|const
name|ConstantInt
modifier|*
name|Low
parameter_list|,
specifier|const
name|ConstantInt
modifier|*
name|High
parameter_list|,
name|unsigned
name|JTCasesIndex
parameter_list|,
name|uint32_t
name|Weight
parameter_list|)
block|{
name|CaseCluster
name|C
decl_stmt|;
name|C
operator|.
name|Kind
operator|=
name|CC_JumpTable
expr_stmt|;
name|C
operator|.
name|Low
operator|=
name|Low
expr_stmt|;
name|C
operator|.
name|High
operator|=
name|High
expr_stmt|;
name|C
operator|.
name|JTCasesIndex
operator|=
name|JTCasesIndex
expr_stmt|;
name|C
operator|.
name|Weight
operator|=
name|Weight
expr_stmt|;
return|return
name|C
return|;
block|}
specifier|static
name|CaseCluster
name|bitTests
parameter_list|(
specifier|const
name|ConstantInt
modifier|*
name|Low
parameter_list|,
specifier|const
name|ConstantInt
modifier|*
name|High
parameter_list|,
name|unsigned
name|BTCasesIndex
parameter_list|,
name|uint32_t
name|Weight
parameter_list|)
block|{
name|CaseCluster
name|C
decl_stmt|;
name|C
operator|.
name|Kind
operator|=
name|CC_BitTests
expr_stmt|;
name|C
operator|.
name|Low
operator|=
name|Low
expr_stmt|;
name|C
operator|.
name|High
operator|=
name|High
expr_stmt|;
name|C
operator|.
name|BTCasesIndex
operator|=
name|BTCasesIndex
expr_stmt|;
name|C
operator|.
name|Weight
operator|=
name|Weight
expr_stmt|;
return|return
name|C
return|;
block|}
block|}
struct|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|CaseCluster
operator|>
name|CaseClusterVector
expr_stmt|;
typedef|typedef
name|CaseClusterVector
operator|::
name|iterator
name|CaseClusterIt
expr_stmt|;
struct|struct
name|CaseBits
block|{
name|uint64_t
name|Mask
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|BB
decl_stmt|;
name|unsigned
name|Bits
decl_stmt|;
name|uint32_t
name|ExtraWeight
decl_stmt|;
name|CaseBits
argument_list|(
argument|uint64_t mask
argument_list|,
argument|MachineBasicBlock* bb
argument_list|,
argument|unsigned bits
argument_list|,
argument|uint32_t Weight
argument_list|)
block|:
name|Mask
argument_list|(
name|mask
argument_list|)
operator|,
name|BB
argument_list|(
name|bb
argument_list|)
operator|,
name|Bits
argument_list|(
name|bits
argument_list|)
operator|,
name|ExtraWeight
argument_list|(
argument|Weight
argument_list|)
block|{ }
name|CaseBits
argument_list|()
operator|:
name|Mask
argument_list|(
literal|0
argument_list|)
operator|,
name|BB
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Bits
argument_list|(
literal|0
argument_list|)
operator|,
name|ExtraWeight
argument_list|(
literal|0
argument_list|)
block|{}
block|}
struct|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|CaseBits
operator|>
name|CaseBitsVector
expr_stmt|;
comment|/// Sort Clusters and merge adjacent cases.
name|void
name|sortAndRangeify
parameter_list|(
name|CaseClusterVector
modifier|&
name|Clusters
parameter_list|)
function_decl|;
comment|/// CaseBlock - This structure is used to communicate between
comment|/// SelectionDAGBuilder and SDISel for the code generation of additional basic
comment|/// blocks needed by multi-case switch statements.
struct|struct
name|CaseBlock
block|{
name|CaseBlock
argument_list|(
argument|ISD::CondCode cc
argument_list|,
argument|const Value *cmplhs
argument_list|,
argument|const Value *cmprhs
argument_list|,
argument|const Value *cmpmiddle
argument_list|,
argument|MachineBasicBlock *truebb
argument_list|,
argument|MachineBasicBlock *falsebb
argument_list|,
argument|MachineBasicBlock *me
argument_list|,
argument|uint32_t trueweight =
literal|0
argument_list|,
argument|uint32_t falseweight =
literal|0
argument_list|)
block|:
name|CC
argument_list|(
name|cc
argument_list|)
operator|,
name|CmpLHS
argument_list|(
name|cmplhs
argument_list|)
operator|,
name|CmpMHS
argument_list|(
name|cmpmiddle
argument_list|)
operator|,
name|CmpRHS
argument_list|(
name|cmprhs
argument_list|)
operator|,
name|TrueBB
argument_list|(
name|truebb
argument_list|)
operator|,
name|FalseBB
argument_list|(
name|falsebb
argument_list|)
operator|,
name|ThisBB
argument_list|(
name|me
argument_list|)
operator|,
name|TrueWeight
argument_list|(
name|trueweight
argument_list|)
operator|,
name|FalseWeight
argument_list|(
argument|falseweight
argument_list|)
block|{ }
comment|// CC - the condition code to use for the case block's setcc node
name|ISD
operator|::
name|CondCode
name|CC
expr_stmt|;
comment|// CmpLHS/CmpRHS/CmpMHS - The LHS/MHS/RHS of the comparison to emit.
comment|// Emit by default LHS op RHS. MHS is used for range comparisons:
comment|// If MHS is not null: (LHS<= MHS) and (MHS<= RHS).
specifier|const
name|Value
modifier|*
name|CmpLHS
decl_stmt|,
modifier|*
name|CmpMHS
decl_stmt|,
modifier|*
name|CmpRHS
decl_stmt|;
comment|// TrueBB/FalseBB - the block to branch to if the setcc is true/false.
name|MachineBasicBlock
modifier|*
name|TrueBB
decl_stmt|,
modifier|*
name|FalseBB
decl_stmt|;
comment|// ThisBB - the block into which to emit the code for the setcc and branches
name|MachineBasicBlock
modifier|*
name|ThisBB
decl_stmt|;
comment|// TrueWeight/FalseWeight - branch weights.
name|uint32_t
name|TrueWeight
decl_stmt|,
name|FalseWeight
decl_stmt|;
block|}
struct|;
struct|struct
name|JumpTable
block|{
name|JumpTable
argument_list|(
argument|unsigned R
argument_list|,
argument|unsigned J
argument_list|,
argument|MachineBasicBlock *M
argument_list|,
argument|MachineBasicBlock *D
argument_list|)
block|:
name|Reg
argument_list|(
name|R
argument_list|)
operator|,
name|JTI
argument_list|(
name|J
argument_list|)
operator|,
name|MBB
argument_list|(
name|M
argument_list|)
operator|,
name|Default
argument_list|(
argument|D
argument_list|)
block|{}
comment|/// Reg - the virtual register containing the index of the jump table entry
comment|//. to jump to.
name|unsigned
name|Reg
expr_stmt|;
comment|/// JTI - the JumpTableIndex for this jump table in the function.
name|unsigned
name|JTI
decl_stmt|;
comment|/// MBB - the MBB into which to emit the code for the indirect jump.
name|MachineBasicBlock
modifier|*
name|MBB
decl_stmt|;
comment|/// Default - the MBB of the default bb, which is a successor of the range
comment|/// check MBB.  This is when updating PHI nodes in successors.
name|MachineBasicBlock
modifier|*
name|Default
decl_stmt|;
block|}
struct|;
struct|struct
name|JumpTableHeader
block|{
name|JumpTableHeader
argument_list|(
argument|APInt F
argument_list|,
argument|APInt L
argument_list|,
argument|const Value *SV
argument_list|,
argument|MachineBasicBlock *H
argument_list|,
argument|bool E = false
argument_list|)
block|:
name|First
argument_list|(
name|F
argument_list|)
operator|,
name|Last
argument_list|(
name|L
argument_list|)
operator|,
name|SValue
argument_list|(
name|SV
argument_list|)
operator|,
name|HeaderBB
argument_list|(
name|H
argument_list|)
operator|,
name|Emitted
argument_list|(
argument|E
argument_list|)
block|{}
name|APInt
name|First
expr_stmt|;
name|APInt
name|Last
decl_stmt|;
specifier|const
name|Value
modifier|*
name|SValue
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|HeaderBB
decl_stmt|;
name|bool
name|Emitted
decl_stmt|;
block|}
struct|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|JumpTableHeader
operator|,
name|JumpTable
operator|>
name|JumpTableBlock
expr_stmt|;
struct|struct
name|BitTestCase
block|{
name|BitTestCase
argument_list|(
argument|uint64_t M
argument_list|,
argument|MachineBasicBlock* T
argument_list|,
argument|MachineBasicBlock* Tr
argument_list|,
argument|uint32_t Weight
argument_list|)
block|:
name|Mask
argument_list|(
name|M
argument_list|)
operator|,
name|ThisBB
argument_list|(
name|T
argument_list|)
operator|,
name|TargetBB
argument_list|(
name|Tr
argument_list|)
operator|,
name|ExtraWeight
argument_list|(
argument|Weight
argument_list|)
block|{ }
name|uint64_t
name|Mask
expr_stmt|;
name|MachineBasicBlock
modifier|*
name|ThisBB
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|TargetBB
decl_stmt|;
name|uint32_t
name|ExtraWeight
decl_stmt|;
block|}
struct|;
typedef|typedef
name|SmallVector
operator|<
name|BitTestCase
operator|,
literal|3
operator|>
name|BitTestInfo
expr_stmt|;
struct|struct
name|BitTestBlock
block|{
name|BitTestBlock
argument_list|(
argument|APInt F
argument_list|,
argument|APInt R
argument_list|,
argument|const Value* SV
argument_list|,
argument|unsigned Rg
argument_list|,
argument|MVT RgVT
argument_list|,
argument|bool E
argument_list|,
argument|MachineBasicBlock* P
argument_list|,
argument|MachineBasicBlock* D
argument_list|,
argument|BitTestInfo C
argument_list|)
block|:
name|First
argument_list|(
name|F
argument_list|)
operator|,
name|Range
argument_list|(
name|R
argument_list|)
operator|,
name|SValue
argument_list|(
name|SV
argument_list|)
operator|,
name|Reg
argument_list|(
name|Rg
argument_list|)
operator|,
name|RegVT
argument_list|(
name|RgVT
argument_list|)
operator|,
name|Emitted
argument_list|(
name|E
argument_list|)
operator|,
name|Parent
argument_list|(
name|P
argument_list|)
operator|,
name|Default
argument_list|(
name|D
argument_list|)
operator|,
name|Cases
argument_list|(
argument|std::move(C)
argument_list|)
block|{ }
name|APInt
name|First
expr_stmt|;
name|APInt
name|Range
decl_stmt|;
specifier|const
name|Value
modifier|*
name|SValue
decl_stmt|;
name|unsigned
name|Reg
decl_stmt|;
name|MVT
name|RegVT
decl_stmt|;
name|bool
name|Emitted
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|Parent
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|Default
decl_stmt|;
name|BitTestInfo
name|Cases
decl_stmt|;
block|}
struct|;
comment|/// Minimum jump table density, in percent.
enum|enum
block|{
name|MinJumpTableDensity
init|=
literal|40
block|}
enum|;
comment|/// Check whether a range of clusters is dense enough for a jump table.
name|bool
name|isDense
parameter_list|(
specifier|const
name|CaseClusterVector
modifier|&
name|Clusters
parameter_list|,
name|unsigned
modifier|*
name|TotalCases
parameter_list|,
name|unsigned
name|First
parameter_list|,
name|unsigned
name|Last
parameter_list|)
function_decl|;
comment|/// Build a jump table cluster from Clusters[First..Last]. Returns false if it
comment|/// decides it's not a good idea.
name|bool
name|buildJumpTable
parameter_list|(
name|CaseClusterVector
modifier|&
name|Clusters
parameter_list|,
name|unsigned
name|First
parameter_list|,
name|unsigned
name|Last
parameter_list|,
specifier|const
name|SwitchInst
modifier|*
name|SI
parameter_list|,
name|MachineBasicBlock
modifier|*
name|DefaultMBB
parameter_list|,
name|CaseCluster
modifier|&
name|JTCluster
parameter_list|)
function_decl|;
comment|/// Find clusters of cases suitable for jump table lowering.
name|void
name|findJumpTables
parameter_list|(
name|CaseClusterVector
modifier|&
name|Clusters
parameter_list|,
specifier|const
name|SwitchInst
modifier|*
name|SI
parameter_list|,
name|MachineBasicBlock
modifier|*
name|DefaultMBB
parameter_list|)
function_decl|;
comment|/// Check whether the range [Low,High] fits in a machine word.
name|bool
name|rangeFitsInWord
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Low
parameter_list|,
specifier|const
name|APInt
modifier|&
name|High
parameter_list|)
function_decl|;
comment|/// Check whether these clusters are suitable for lowering with bit tests based
comment|/// on the number of destinations, comparison metric, and range.
name|bool
name|isSuitableForBitTests
parameter_list|(
name|unsigned
name|NumDests
parameter_list|,
name|unsigned
name|NumCmps
parameter_list|,
specifier|const
name|APInt
modifier|&
name|Low
parameter_list|,
specifier|const
name|APInt
modifier|&
name|High
parameter_list|)
function_decl|;
comment|/// Build a bit test cluster from Clusters[First..Last]. Returns false if it
comment|/// decides it's not a good idea.
name|bool
name|buildBitTests
parameter_list|(
name|CaseClusterVector
modifier|&
name|Clusters
parameter_list|,
name|unsigned
name|First
parameter_list|,
name|unsigned
name|Last
parameter_list|,
specifier|const
name|SwitchInst
modifier|*
name|SI
parameter_list|,
name|CaseCluster
modifier|&
name|BTCluster
parameter_list|)
function_decl|;
comment|/// Find clusters of cases suitable for bit test lowering.
name|void
name|findBitTestClusters
parameter_list|(
name|CaseClusterVector
modifier|&
name|Clusters
parameter_list|,
specifier|const
name|SwitchInst
modifier|*
name|SI
parameter_list|)
function_decl|;
struct|struct
name|SwitchWorkListItem
block|{
name|MachineBasicBlock
modifier|*
name|MBB
decl_stmt|;
name|CaseClusterIt
name|FirstCluster
decl_stmt|;
name|CaseClusterIt
name|LastCluster
decl_stmt|;
specifier|const
name|ConstantInt
modifier|*
name|GE
decl_stmt|;
specifier|const
name|ConstantInt
modifier|*
name|LT
decl_stmt|;
block|}
struct|;
typedef|typedef
name|SmallVector
operator|<
name|SwitchWorkListItem
operator|,
literal|4
operator|>
name|SwitchWorkList
expr_stmt|;
comment|/// Determine the rank by weight of CC in [First,Last]. If CC has more weight
comment|/// than each cluster in the range, its rank is 0.
specifier|static
name|unsigned
name|caseClusterRank
parameter_list|(
specifier|const
name|CaseCluster
modifier|&
name|CC
parameter_list|,
name|CaseClusterIt
name|First
parameter_list|,
name|CaseClusterIt
name|Last
parameter_list|)
function_decl|;
comment|/// Emit comparison and split W into two subtrees.
name|void
name|splitWorkItem
parameter_list|(
name|SwitchWorkList
modifier|&
name|WorkList
parameter_list|,
specifier|const
name|SwitchWorkListItem
modifier|&
name|W
parameter_list|,
name|Value
modifier|*
name|Cond
parameter_list|,
name|MachineBasicBlock
modifier|*
name|SwitchMBB
parameter_list|)
function_decl|;
comment|/// Lower W.
name|void
name|lowerWorkItem
parameter_list|(
name|SwitchWorkListItem
name|W
parameter_list|,
name|Value
modifier|*
name|Cond
parameter_list|,
name|MachineBasicBlock
modifier|*
name|SwitchMBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|DefaultMBB
parameter_list|)
function_decl|;
comment|/// A class which encapsulates all of the information needed to generate a
comment|/// stack protector check and signals to isel via its state being initialized
comment|/// that a stack protector needs to be generated.
comment|///
comment|/// *NOTE* The following is a high level documentation of SelectionDAG Stack
comment|/// Protector Generation. The reason that it is placed here is for a lack of
comment|/// other good places to stick it.
comment|///
comment|/// High Level Overview of SelectionDAG Stack Protector Generation:
comment|///
comment|/// Previously, generation of stack protectors was done exclusively in the
comment|/// pre-SelectionDAG Codegen LLVM IR Pass "Stack Protector". This necessitated
comment|/// splitting basic blocks at the IR level to create the success/failure basic
comment|/// blocks in the tail of the basic block in question. As a result of this,
comment|/// calls that would have qualified for the sibling call optimization were no
comment|/// longer eligible for optimization since said calls were no longer right in
comment|/// the "tail position" (i.e. the immediate predecessor of a ReturnInst
comment|/// instruction).
comment|///
comment|/// Then it was noticed that since the sibling call optimization causes the
comment|/// callee to reuse the caller's stack, if we could delay the generation of
comment|/// the stack protector check until later in CodeGen after the sibling call
comment|/// decision was made, we get both the tail call optimization and the stack
comment|/// protector check!
comment|///
comment|/// A few goals in solving this problem were:
comment|///
comment|///   1. Preserve the architecture independence of stack protector generation.
comment|///
comment|///   2. Preserve the normal IR level stack protector check for platforms like
comment|///      OpenBSD for which we support platform-specific stack protector
comment|///      generation.
comment|///
comment|/// The main problem that guided the present solution is that one can not
comment|/// solve this problem in an architecture independent manner at the IR level
comment|/// only. This is because:
comment|///
comment|///   1. The decision on whether or not to perform a sibling call on certain
comment|///      platforms (for instance i386) requires lower level information
comment|///      related to available registers that can not be known at the IR level.
comment|///
comment|///   2. Even if the previous point were not true, the decision on whether to
comment|///      perform a tail call is done in LowerCallTo in SelectionDAG which
comment|///      occurs after the Stack Protector Pass. As a result, one would need to
comment|///      put the relevant callinst into the stack protector check success
comment|///      basic block (where the return inst is placed) and then move it back
comment|///      later at SelectionDAG/MI time before the stack protector check if the
comment|///      tail call optimization failed. The MI level option was nixed
comment|///      immediately since it would require platform-specific pattern
comment|///      matching. The SelectionDAG level option was nixed because
comment|///      SelectionDAG only processes one IR level basic block at a time
comment|///      implying one could not create a DAG Combine to move the callinst.
comment|///
comment|/// To get around this problem a few things were realized:
comment|///
comment|///   1. While one can not handle multiple IR level basic blocks at the
comment|///      SelectionDAG Level, one can generate multiple machine basic blocks
comment|///      for one IR level basic block. This is how we handle bit tests and
comment|///      switches.
comment|///
comment|///   2. At the MI level, tail calls are represented via a special return
comment|///      MIInst called "tcreturn". Thus if we know the basic block in which we
comment|///      wish to insert the stack protector check, we get the correct behavior
comment|///      by always inserting the stack protector check right before the return
comment|///      statement. This is a "magical transformation" since no matter where
comment|///      the stack protector check intrinsic is, we always insert the stack
comment|///      protector check code at the end of the BB.
comment|///
comment|/// Given the aforementioned constraints, the following solution was devised:
comment|///
comment|///   1. On platforms that do not support SelectionDAG stack protector check
comment|///      generation, allow for the normal IR level stack protector check
comment|///      generation to continue.
comment|///
comment|///   2. On platforms that do support SelectionDAG stack protector check
comment|///      generation:
comment|///
comment|///     a. Use the IR level stack protector pass to decide if a stack
comment|///        protector is required/which BB we insert the stack protector check
comment|///        in by reusing the logic already therein. If we wish to generate a
comment|///        stack protector check in a basic block, we place a special IR
comment|///        intrinsic called llvm.stackprotectorcheck right before the BB's
comment|///        returninst or if there is a callinst that could potentially be
comment|///        sibling call optimized, before the call inst.
comment|///
comment|///     b. Then when a BB with said intrinsic is processed, we codegen the BB
comment|///        normally via SelectBasicBlock. In said process, when we visit the
comment|///        stack protector check, we do not actually emit anything into the
comment|///        BB. Instead, we just initialize the stack protector descriptor
comment|///        class (which involves stashing information/creating the success
comment|///        mbbb and the failure mbb if we have not created one for this
comment|///        function yet) and export the guard variable that we are going to
comment|///        compare.
comment|///
comment|///     c. After we finish selecting the basic block, in FinishBasicBlock if
comment|///        the StackProtectorDescriptor attached to the SelectionDAGBuilder is
comment|///        initialized, we first find a splice point in the parent basic block
comment|///        before the terminator and then splice the terminator of said basic
comment|///        block into the success basic block. Then we code-gen a new tail for
comment|///        the parent basic block consisting of the two loads, the comparison,
comment|///        and finally two branches to the success/failure basic blocks. We
comment|///        conclude by code-gening the failure basic block if we have not
comment|///        code-gened it already (all stack protector checks we generate in
comment|///        the same function, use the same failure basic block).
name|class
name|StackProtectorDescriptor
block|{
name|public
label|:
name|StackProtectorDescriptor
argument_list|()
operator|:
name|ParentMBB
argument_list|(
name|nullptr
argument_list|)
operator|,
name|SuccessMBB
argument_list|(
name|nullptr
argument_list|)
operator|,
name|FailureMBB
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Guard
argument_list|(
name|nullptr
argument_list|)
operator|,
name|GuardReg
argument_list|(
literal|0
argument_list|)
block|{ }
comment|/// Returns true if all fields of the stack protector descriptor are
comment|/// initialized implying that we should/are ready to emit a stack protector.
name|bool
name|shouldEmitStackProtector
argument_list|()
specifier|const
block|{
return|return
name|ParentMBB
operator|&&
name|SuccessMBB
operator|&&
name|FailureMBB
operator|&&
name|Guard
return|;
block|}
comment|/// Initialize the stack protector descriptor structure for a new basic
comment|/// block.
name|void
name|initialize
parameter_list|(
specifier|const
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|,
specifier|const
name|CallInst
modifier|&
name|StackProtCheckCall
parameter_list|)
block|{
comment|// Make sure we are not initialized yet.
name|assert
argument_list|(
operator|!
name|shouldEmitStackProtector
argument_list|()
operator|&&
literal|"Stack Protector Descriptor is "
literal|"already initialized!"
argument_list|)
expr_stmt|;
name|ParentMBB
operator|=
name|MBB
expr_stmt|;
name|SuccessMBB
operator|=
name|AddSuccessorMBB
argument_list|(
name|BB
argument_list|,
name|MBB
argument_list|,
comment|/* IsLikely */
name|true
argument_list|)
expr_stmt|;
name|FailureMBB
operator|=
name|AddSuccessorMBB
argument_list|(
name|BB
argument_list|,
name|MBB
argument_list|,
comment|/* IsLikely */
name|false
argument_list|,
name|FailureMBB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Guard
condition|)
name|Guard
operator|=
name|StackProtCheckCall
operator|.
name|getArgOperand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/// Reset state that changes when we handle different basic blocks.
comment|///
comment|/// This currently includes:
comment|///
comment|/// 1. The specific basic block we are generating a
comment|/// stack protector for (ParentMBB).
comment|///
comment|/// 2. The successor machine basic block that will contain the tail of
comment|/// parent mbb after we create the stack protector check (SuccessMBB). This
comment|/// BB is visited only on stack protector check success.
name|void
name|resetPerBBState
parameter_list|()
block|{
name|ParentMBB
operator|=
name|nullptr
expr_stmt|;
name|SuccessMBB
operator|=
name|nullptr
expr_stmt|;
block|}
comment|/// Reset state that only changes when we switch functions.
comment|///
comment|/// This currently includes:
comment|///
comment|/// 1. FailureMBB since we reuse the failure code path for all stack
comment|/// protector checks created in an individual function.
comment|///
comment|/// 2.The guard variable since the guard variable we are checking against is
comment|/// always the same.
name|void
name|resetPerFunctionState
parameter_list|()
block|{
name|FailureMBB
operator|=
name|nullptr
expr_stmt|;
name|Guard
operator|=
name|nullptr
expr_stmt|;
block|}
name|MachineBasicBlock
modifier|*
name|getParentMBB
parameter_list|()
block|{
return|return
name|ParentMBB
return|;
block|}
name|MachineBasicBlock
modifier|*
name|getSuccessMBB
parameter_list|()
block|{
return|return
name|SuccessMBB
return|;
block|}
name|MachineBasicBlock
modifier|*
name|getFailureMBB
parameter_list|()
block|{
return|return
name|FailureMBB
return|;
block|}
specifier|const
name|Value
modifier|*
name|getGuard
parameter_list|()
block|{
return|return
name|Guard
return|;
block|}
name|unsigned
name|getGuardReg
argument_list|()
specifier|const
block|{
return|return
name|GuardReg
return|;
block|}
name|void
name|setGuardReg
parameter_list|(
name|unsigned
name|R
parameter_list|)
block|{
name|GuardReg
operator|=
name|R
expr_stmt|;
block|}
name|private
label|:
comment|/// The basic block for which we are generating the stack protector.
comment|///
comment|/// As a result of stack protector generation, we will splice the
comment|/// terminators of this basic block into the successor mbb SuccessMBB and
comment|/// replace it with a compare/branch to the successor mbbs
comment|/// SuccessMBB/FailureMBB depending on whether or not the stack protector
comment|/// was violated.
name|MachineBasicBlock
modifier|*
name|ParentMBB
decl_stmt|;
comment|/// A basic block visited on stack protector check success that contains the
comment|/// terminators of ParentMBB.
name|MachineBasicBlock
modifier|*
name|SuccessMBB
decl_stmt|;
comment|/// This basic block visited on stack protector check failure that will
comment|/// contain a call to __stack_chk_fail().
name|MachineBasicBlock
modifier|*
name|FailureMBB
decl_stmt|;
comment|/// The guard variable which we will compare against the stored value in the
comment|/// stack protector stack slot.
specifier|const
name|Value
modifier|*
name|Guard
decl_stmt|;
comment|/// The virtual register holding the stack guard value.
name|unsigned
name|GuardReg
decl_stmt|;
comment|/// Add a successor machine basic block to ParentMBB. If the successor mbb
comment|/// has not been created yet (i.e. if SuccMBB = 0), then the machine basic
comment|/// block will be created. Assign a large weight if IsLikely is true.
name|MachineBasicBlock
modifier|*
name|AddSuccessorMBB
parameter_list|(
specifier|const
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|ParentMBB
parameter_list|,
name|bool
name|IsLikely
parameter_list|,
name|MachineBasicBlock
modifier|*
name|SuccMBB
init|=
name|nullptr
parameter_list|)
function_decl|;
block|}
empty_stmt|;
name|private
label|:
specifier|const
name|TargetMachine
modifier|&
name|TM
decl_stmt|;
name|public
label|:
comment|/// Lowest valid SDNodeOrder. The special case 0 is reserved for scheduling
comment|/// nodes without a corresponding SDNode.
specifier|static
specifier|const
name|unsigned
name|LowestSDNodeOrder
init|=
literal|1
decl_stmt|;
name|SelectionDAG
modifier|&
name|DAG
decl_stmt|;
specifier|const
name|DataLayout
modifier|*
name|DL
decl_stmt|;
name|AliasAnalysis
modifier|*
name|AA
decl_stmt|;
specifier|const
name|TargetLibraryInfo
modifier|*
name|LibInfo
decl_stmt|;
comment|/// SwitchCases - Vector of CaseBlock structures used to communicate
comment|/// SwitchInst code generation information.
name|std
operator|::
name|vector
operator|<
name|CaseBlock
operator|>
name|SwitchCases
expr_stmt|;
comment|/// JTCases - Vector of JumpTable structures used to communicate
comment|/// SwitchInst code generation information.
name|std
operator|::
name|vector
operator|<
name|JumpTableBlock
operator|>
name|JTCases
expr_stmt|;
comment|/// BitTestCases - Vector of BitTestBlock structures used to communicate
comment|/// SwitchInst code generation information.
name|std
operator|::
name|vector
operator|<
name|BitTestBlock
operator|>
name|BitTestCases
expr_stmt|;
comment|/// A StackProtectorDescriptor structure used to communicate stack protector
comment|/// information in between SelectBasicBlock and FinishBasicBlock.
name|StackProtectorDescriptor
name|SPDescriptor
decl_stmt|;
comment|// Emit PHI-node-operand constants only once even if used by multiple
comment|// PHI nodes.
name|DenseMap
operator|<
specifier|const
name|Constant
operator|*
operator|,
name|unsigned
operator|>
name|ConstantsOut
expr_stmt|;
comment|/// FuncInfo - Information about the function as a whole.
comment|///
name|FunctionLoweringInfo
modifier|&
name|FuncInfo
decl_stmt|;
comment|/// OptLevel - What optimization level we're generating code for.
comment|///
name|CodeGenOpt
operator|::
name|Level
name|OptLevel
expr_stmt|;
comment|/// GFI - Garbage collection metadata for the function.
name|GCFunctionInfo
modifier|*
name|GFI
decl_stmt|;
comment|/// LPadToCallSiteMap - Map a landing pad to the call site indexes.
name|DenseMap
operator|<
name|MachineBasicBlock
operator|*
operator|,
name|SmallVector
operator|<
name|unsigned
operator|,
literal|4
operator|>
expr|>
name|LPadToCallSiteMap
expr_stmt|;
comment|/// HasTailCall - This is set to true if a call in the current
comment|/// block has been translated as a tail call. In this case,
comment|/// no subsequent DAG nodes should be created.
comment|///
name|bool
name|HasTailCall
decl_stmt|;
name|LLVMContext
modifier|*
name|Context
decl_stmt|;
name|SelectionDAGBuilder
argument_list|(
argument|SelectionDAG&dag
argument_list|,
argument|FunctionLoweringInfo&funcinfo
argument_list|,
argument|CodeGenOpt::Level ol
argument_list|)
block|:
name|CurInst
argument_list|(
name|nullptr
argument_list|)
operator|,
name|SDNodeOrder
argument_list|(
name|LowestSDNodeOrder
argument_list|)
operator|,
name|TM
argument_list|(
name|dag
operator|.
name|getTarget
argument_list|()
argument_list|)
operator|,
name|DAG
argument_list|(
name|dag
argument_list|)
operator|,
name|FuncInfo
argument_list|(
name|funcinfo
argument_list|)
operator|,
name|OptLevel
argument_list|(
name|ol
argument_list|)
operator|,
name|HasTailCall
argument_list|(
argument|false
argument_list|)
block|{   }
name|void
name|init
argument_list|(
name|GCFunctionInfo
operator|*
name|gfi
argument_list|,
name|AliasAnalysis
operator|&
name|aa
argument_list|,
specifier|const
name|TargetLibraryInfo
operator|*
name|li
argument_list|)
expr_stmt|;
comment|/// clear - Clear out the current SelectionDAG and the associated
comment|/// state and prepare this SelectionDAGBuilder object to be used
comment|/// for a new block. This doesn't clear out information about
comment|/// additional blocks that are needed to complete switch lowering
comment|/// or PHI node updating; that information is cleared out as it is
comment|/// consumed.
name|void
name|clear
parameter_list|()
function_decl|;
comment|/// clearDanglingDebugInfo - Clear the dangling debug information
comment|/// map. This function is separated from the clear so that debug
comment|/// information that is dangling in a basic block can be properly
comment|/// resolved in a different basic block. This allows the
comment|/// SelectionDAG to resolve dangling debug information attached
comment|/// to PHI nodes.
name|void
name|clearDanglingDebugInfo
parameter_list|()
function_decl|;
comment|/// getRoot - Return the current virtual root of the Selection DAG,
comment|/// flushing any PendingLoad items. This must be done before emitting
comment|/// a store or any other node that may need to be ordered after any
comment|/// prior load instructions.
comment|///
name|SDValue
name|getRoot
parameter_list|()
function_decl|;
comment|/// getControlRoot - Similar to getRoot, but instead of flushing all the
comment|/// PendingLoad items, flush all the PendingExports items. It is necessary
comment|/// to do this before emitting a terminator instruction.
comment|///
name|SDValue
name|getControlRoot
parameter_list|()
function_decl|;
name|SDLoc
name|getCurSDLoc
argument_list|()
specifier|const
block|{
return|return
name|SDLoc
argument_list|(
name|CurInst
argument_list|,
name|SDNodeOrder
argument_list|)
return|;
block|}
name|DebugLoc
name|getCurDebugLoc
argument_list|()
specifier|const
block|{
return|return
name|CurInst
operator|?
name|CurInst
operator|->
name|getDebugLoc
argument_list|()
operator|:
name|DebugLoc
argument_list|()
return|;
block|}
name|unsigned
name|getSDNodeOrder
argument_list|()
specifier|const
block|{
return|return
name|SDNodeOrder
return|;
block|}
name|void
name|CopyValueToVirtualRegister
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
name|unsigned
name|Reg
parameter_list|)
function_decl|;
name|void
name|visit
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visit
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// getCopyFromRegs - If there was virtual register allocated for the value V
comment|/// emit CopyFromReg of the specified type Ty. Return empty SDValue() otherwise.
name|SDValue
name|getCopyFromRegs
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
comment|// resolveDanglingDebugInfo - if we saw an earlier dbg_value referring to V,
comment|// generate the debug data structures now that we've seen its definition.
name|void
name|resolveDanglingDebugInfo
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
name|SDValue
name|Val
parameter_list|)
function_decl|;
name|SDValue
name|getValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
name|bool
name|findValue
argument_list|(
specifier|const
name|Value
operator|*
name|V
argument_list|)
decl|const
decl_stmt|;
name|SDValue
name|getNonRegisterValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
name|SDValue
name|getValueImpl
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
name|void
name|setValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
name|SDValue
name|NewN
parameter_list|)
block|{
name|SDValue
modifier|&
name|N
init|=
name|NodeMap
index|[
name|V
index|]
decl_stmt|;
name|assert
argument_list|(
operator|!
name|N
operator|.
name|getNode
argument_list|()
operator|&&
literal|"Already set a value for this node!"
argument_list|)
expr_stmt|;
name|N
operator|=
name|NewN
expr_stmt|;
block|}
name|void
name|setUnusedArgValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
name|SDValue
name|NewN
parameter_list|)
block|{
name|SDValue
modifier|&
name|N
init|=
name|UnusedArgNodeMap
index|[
name|V
index|]
decl_stmt|;
name|assert
argument_list|(
operator|!
name|N
operator|.
name|getNode
argument_list|()
operator|&&
literal|"Already set a value for this node!"
argument_list|)
expr_stmt|;
name|N
operator|=
name|NewN
expr_stmt|;
block|}
name|void
name|FindMergedConditions
parameter_list|(
specifier|const
name|Value
modifier|*
name|Cond
parameter_list|,
name|MachineBasicBlock
modifier|*
name|TBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|FBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|CurBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|SwitchBB
parameter_list|,
name|unsigned
name|Opc
parameter_list|,
name|uint32_t
name|TW
parameter_list|,
name|uint32_t
name|FW
parameter_list|)
function_decl|;
name|void
name|EmitBranchForMergedCondition
parameter_list|(
specifier|const
name|Value
modifier|*
name|Cond
parameter_list|,
name|MachineBasicBlock
modifier|*
name|TBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|FBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|CurBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|SwitchBB
parameter_list|,
name|uint32_t
name|TW
parameter_list|,
name|uint32_t
name|FW
parameter_list|)
function_decl|;
name|bool
name|ShouldEmitAsBranches
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|CaseBlock
operator|>
operator|&
name|Cases
argument_list|)
decl_stmt|;
name|bool
name|isExportableFromCurrentBlock
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
specifier|const
name|BasicBlock
modifier|*
name|FromBB
parameter_list|)
function_decl|;
name|void
name|CopyToExportRegsIfNeeded
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
name|void
name|ExportFromCurrentBlock
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
name|void
name|LowerCallTo
parameter_list|(
name|ImmutableCallSite
name|CS
parameter_list|,
name|SDValue
name|Callee
parameter_list|,
name|bool
name|IsTailCall
parameter_list|,
name|MachineBasicBlock
modifier|*
name|LandingPad
init|=
name|nullptr
parameter_list|)
function_decl|;
name|std
operator|::
name|pair
operator|<
name|SDValue
operator|,
name|SDValue
operator|>
name|lowerCallOperands
argument_list|(
argument|ImmutableCallSite CS
argument_list|,
argument|unsigned ArgIdx
argument_list|,
argument|unsigned NumArgs
argument_list|,
argument|SDValue Callee
argument_list|,
argument|Type *ReturnTy
argument_list|,
argument|MachineBasicBlock *LandingPad = nullptr
argument_list|,
argument|bool IsPatchPoint = false
argument_list|)
expr_stmt|;
comment|/// UpdateSplitBlock - When an MBB was split during scheduling, update the
comment|/// references that need to refer to the last resulting block.
name|void
name|UpdateSplitBlock
parameter_list|(
name|MachineBasicBlock
modifier|*
name|First
parameter_list|,
name|MachineBasicBlock
modifier|*
name|Last
parameter_list|)
function_decl|;
comment|// This function is responsible for the whole statepoint lowering process.
comment|// It uniformly handles invoke and call statepoints.
name|void
name|LowerStatepoint
parameter_list|(
name|ImmutableStatepoint
name|Statepoint
parameter_list|,
name|MachineBasicBlock
modifier|*
name|LandingPad
init|=
name|nullptr
parameter_list|)
function_decl|;
name|private
label|:
name|std
operator|::
name|pair
operator|<
name|SDValue
operator|,
name|SDValue
operator|>
name|lowerInvokable
argument_list|(
name|TargetLowering
operator|::
name|CallLoweringInfo
operator|&
name|CLI
argument_list|,
name|MachineBasicBlock
operator|*
name|LandingPad
argument_list|)
expr_stmt|;
comment|// Terminator instructions.
name|void
name|visitRet
parameter_list|(
specifier|const
name|ReturnInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitBr
parameter_list|(
specifier|const
name|BranchInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitSwitch
parameter_list|(
specifier|const
name|SwitchInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitIndirectBr
parameter_list|(
specifier|const
name|IndirectBrInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitUnreachable
parameter_list|(
specifier|const
name|UnreachableInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|uint32_t
name|getEdgeWeight
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|Src
argument_list|,
specifier|const
name|MachineBasicBlock
operator|*
name|Dst
argument_list|)
decl|const
decl_stmt|;
name|void
name|addSuccessorWithWeight
parameter_list|(
name|MachineBasicBlock
modifier|*
name|Src
parameter_list|,
name|MachineBasicBlock
modifier|*
name|Dst
parameter_list|,
name|uint32_t
name|Weight
init|=
literal|0
parameter_list|)
function_decl|;
name|public
label|:
name|void
name|visitSwitchCase
parameter_list|(
name|CaseBlock
modifier|&
name|CB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|SwitchBB
parameter_list|)
function_decl|;
name|void
name|visitSPDescriptorParent
parameter_list|(
name|StackProtectorDescriptor
modifier|&
name|SPD
parameter_list|,
name|MachineBasicBlock
modifier|*
name|ParentBB
parameter_list|)
function_decl|;
name|void
name|visitSPDescriptorFailure
parameter_list|(
name|StackProtectorDescriptor
modifier|&
name|SPD
parameter_list|)
function_decl|;
name|void
name|visitBitTestHeader
parameter_list|(
name|BitTestBlock
modifier|&
name|B
parameter_list|,
name|MachineBasicBlock
modifier|*
name|SwitchBB
parameter_list|)
function_decl|;
name|void
name|visitBitTestCase
parameter_list|(
name|BitTestBlock
modifier|&
name|BB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|NextMBB
parameter_list|,
name|uint32_t
name|BranchWeightToNext
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|BitTestCase
modifier|&
name|B
parameter_list|,
name|MachineBasicBlock
modifier|*
name|SwitchBB
parameter_list|)
function_decl|;
name|void
name|visitJumpTable
parameter_list|(
name|JumpTable
modifier|&
name|JT
parameter_list|)
function_decl|;
name|void
name|visitJumpTableHeader
parameter_list|(
name|JumpTable
modifier|&
name|JT
parameter_list|,
name|JumpTableHeader
modifier|&
name|JTH
parameter_list|,
name|MachineBasicBlock
modifier|*
name|SwitchBB
parameter_list|)
function_decl|;
name|unsigned
name|visitLandingPadClauseBB
parameter_list|(
name|GlobalValue
modifier|*
name|ClauseGV
parameter_list|,
name|MachineBasicBlock
modifier|*
name|LPadMBB
parameter_list|)
function_decl|;
name|private
label|:
comment|// These all get lowered before this pass.
name|void
name|visitInvoke
parameter_list|(
specifier|const
name|InvokeInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitResume
parameter_list|(
specifier|const
name|ResumeInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitBinary
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|,
name|unsigned
name|OpCode
parameter_list|)
function_decl|;
name|void
name|visitShift
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|,
name|unsigned
name|Opcode
parameter_list|)
function_decl|;
name|void
name|visitAdd
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|ADD
argument_list|)
expr_stmt|;
block|}
name|void
name|visitFAdd
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|FADD
argument_list|)
expr_stmt|;
block|}
name|void
name|visitSub
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SUB
argument_list|)
expr_stmt|;
block|}
name|void
name|visitFSub
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitMul
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|MUL
argument_list|)
expr_stmt|;
block|}
name|void
name|visitFMul
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|FMUL
argument_list|)
expr_stmt|;
block|}
name|void
name|visitURem
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|UREM
argument_list|)
expr_stmt|;
block|}
name|void
name|visitSRem
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SREM
argument_list|)
expr_stmt|;
block|}
name|void
name|visitFRem
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|FREM
argument_list|)
expr_stmt|;
block|}
name|void
name|visitUDiv
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|UDIV
argument_list|)
expr_stmt|;
block|}
name|void
name|visitSDiv
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFDiv
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|FDIV
argument_list|)
expr_stmt|;
block|}
name|void
name|visitAnd
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|AND
argument_list|)
expr_stmt|;
block|}
name|void
name|visitOr
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|OR
argument_list|)
expr_stmt|;
block|}
name|void
name|visitXor
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|XOR
argument_list|)
expr_stmt|;
block|}
name|void
name|visitShl
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitShift
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SHL
argument_list|)
expr_stmt|;
block|}
name|void
name|visitLShr
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitShift
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SRL
argument_list|)
expr_stmt|;
block|}
name|void
name|visitAShr
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitShift
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SRA
argument_list|)
expr_stmt|;
block|}
name|void
name|visitICmp
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFCmp
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
comment|// Visit the conversion instructions
name|void
name|visitTrunc
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitZExt
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitSExt
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFPTrunc
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFPExt
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFPToUI
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFPToSI
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitUIToFP
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitSIToFP
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitPtrToInt
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitIntToPtr
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitBitCast
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitAddrSpaceCast
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitExtractElement
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitInsertElement
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitShuffleVector
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitExtractValue
parameter_list|(
specifier|const
name|ExtractValueInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitInsertValue
parameter_list|(
specifier|const
name|InsertValueInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitLandingPad
parameter_list|(
specifier|const
name|LandingPadInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitGetElementPtr
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitSelect
parameter_list|(
specifier|const
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitAlloca
parameter_list|(
specifier|const
name|AllocaInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitLoad
parameter_list|(
specifier|const
name|LoadInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitStore
parameter_list|(
specifier|const
name|StoreInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitMaskedLoad
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitMaskedStore
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitMaskedGather
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitMaskedScatter
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitAtomicCmpXchg
parameter_list|(
specifier|const
name|AtomicCmpXchgInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitAtomicRMW
parameter_list|(
specifier|const
name|AtomicRMWInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFence
parameter_list|(
specifier|const
name|FenceInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitPHI
parameter_list|(
specifier|const
name|PHINode
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|visitMemCmpCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|visitMemChrCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|visitStrCpyCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|,
name|bool
name|isStpcpy
parameter_list|)
function_decl|;
name|bool
name|visitStrCmpCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|visitStrLenCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|visitStrNLenCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|visitUnaryFloatCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|,
name|unsigned
name|Opcode
parameter_list|)
function_decl|;
name|bool
name|visitBinaryFloatCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|,
name|unsigned
name|Opcode
parameter_list|)
function_decl|;
name|void
name|visitAtomicLoad
parameter_list|(
specifier|const
name|LoadInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitAtomicStore
parameter_list|(
specifier|const
name|StoreInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitInlineAsm
parameter_list|(
name|ImmutableCallSite
name|CS
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|visitIntrinsicCall
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|,
name|unsigned
name|Intrinsic
parameter_list|)
function_decl|;
name|void
name|visitTargetIntrinsic
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|,
name|unsigned
name|Intrinsic
parameter_list|)
function_decl|;
name|void
name|visitVAStart
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitVAArg
parameter_list|(
specifier|const
name|VAArgInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitVAEnd
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitVACopy
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitStackmap
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitPatchpoint
parameter_list|(
name|ImmutableCallSite
name|CS
parameter_list|,
name|MachineBasicBlock
modifier|*
name|LandingPad
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|// These three are implemented in StatepointLowering.cpp
name|void
name|visitStatepoint
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitGCRelocate
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitGCResult
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitUserOp1
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"UserOp1 should not exist at instruction selection time!"
argument_list|)
expr_stmt|;
block|}
name|void
name|visitUserOp2
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"UserOp2 should not exist at instruction selection time!"
argument_list|)
expr_stmt|;
block|}
name|void
name|processIntegerCallValue
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|I
parameter_list|,
name|SDValue
name|Value
parameter_list|,
name|bool
name|IsSigned
parameter_list|)
function_decl|;
name|void
name|HandlePHINodesInSuccessorBlocks
parameter_list|(
specifier|const
name|BasicBlock
modifier|*
name|LLVMBB
parameter_list|)
function_decl|;
comment|/// EmitFuncArgumentDbgValue - If V is an function argument then create
comment|/// corresponding DBG_VALUE machine instruction for it now. At the end of
comment|/// instruction selection, they will be inserted to the entry BB.
name|bool
name|EmitFuncArgumentDbgValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
name|DILocalVariable
modifier|*
name|Variable
parameter_list|,
name|DIExpression
modifier|*
name|Expr
parameter_list|,
name|DILocation
modifier|*
name|DL
parameter_list|,
name|int64_t
name|Offset
parameter_list|,
name|bool
name|IsIndirect
parameter_list|,
specifier|const
name|SDValue
modifier|&
name|N
parameter_list|)
function_decl|;
comment|/// Return the next block after MBB, or nullptr if there is none.
name|MachineBasicBlock
modifier|*
name|NextBlock
parameter_list|(
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|)
function_decl|;
comment|/// Update the DAG and DAG builder with the relevant information after
comment|/// a new root node has been created which could be a tail call.
name|void
name|updateDAGForMaybeTailCall
parameter_list|(
name|SDValue
name|MaybeTC
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// RegsForValue - This struct represents the registers (physical or virtual)
comment|/// that a particular set of values is assigned, and the type information about
comment|/// the value. The most common situation is to represent one value at a time,
comment|/// but struct or array values are handled element-wise as multiple values.  The
comment|/// splitting of aggregates is performed recursively, so that we never have
comment|/// aggregate-typed registers. The values at this point do not necessarily have
comment|/// legal types, so each value may require one or more registers of some legal
comment|/// type.
comment|///
struct|struct
name|RegsForValue
block|{
comment|/// ValueVTs - The value types of the values, which may not be legal, and
comment|/// may need be promoted or synthesized from one or more registers.
comment|///
name|SmallVector
operator|<
name|EVT
operator|,
literal|4
operator|>
name|ValueVTs
expr_stmt|;
comment|/// RegVTs - The value types of the registers. This is the same size as
comment|/// ValueVTs and it records, for each value, what the type of the assigned
comment|/// register or registers are. (Individual values are never synthesized
comment|/// from more than one type of register.)
comment|///
comment|/// With virtual registers, the contents of RegVTs is redundant with TLI's
comment|/// getRegisterType member function, however when with physical registers
comment|/// it is necessary to have a separate record of the types.
comment|///
name|SmallVector
operator|<
name|MVT
operator|,
literal|4
operator|>
name|RegVTs
expr_stmt|;
comment|/// Regs - This list holds the registers assigned to the values.
comment|/// Each legal or promoted value requires one register, and each
comment|/// expanded value requires multiple registers.
comment|///
name|SmallVector
operator|<
name|unsigned
operator|,
literal|4
operator|>
name|Regs
expr_stmt|;
name|RegsForValue
argument_list|()
expr_stmt|;
name|RegsForValue
argument_list|(
argument|const SmallVector<unsigned
argument_list|,
literal|4
argument|>&regs
argument_list|,
argument|MVT regvt
argument_list|,
argument|EVT valuevt
argument_list|)
empty_stmt|;
name|RegsForValue
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|const TargetLowering&tli
argument_list|,
argument|unsigned Reg
argument_list|,
argument|Type *Ty
argument_list|)
empty_stmt|;
comment|/// append - Add the specified values to this one.
name|void
name|append
parameter_list|(
specifier|const
name|RegsForValue
modifier|&
name|RHS
parameter_list|)
block|{
name|ValueVTs
operator|.
name|append
argument_list|(
name|RHS
operator|.
name|ValueVTs
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|ValueVTs
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|RegVTs
operator|.
name|append
argument_list|(
name|RHS
operator|.
name|RegVTs
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|RegVTs
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Regs
operator|.
name|append
argument_list|(
name|RHS
operator|.
name|Regs
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|Regs
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// getCopyFromRegs - Emit a series of CopyFromReg nodes that copies from
comment|/// this value and returns the result as a ValueVTs value.  This uses
comment|/// Chain/Flag as the input and updates them for the output Chain/Flag.
comment|/// If the Flag pointer is NULL, no flag is used.
name|SDValue
name|getCopyFromRegs
argument_list|(
name|SelectionDAG
operator|&
name|DAG
argument_list|,
name|FunctionLoweringInfo
operator|&
name|FuncInfo
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|SDValue
operator|&
name|Chain
argument_list|,
name|SDValue
operator|*
name|Flag
argument_list|,
specifier|const
name|Value
operator|*
name|V
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
comment|/// getCopyToRegs - Emit a series of CopyToReg nodes that copies the specified
comment|/// value into the registers specified by this object.  This uses Chain/Flag
comment|/// as the input and updates them for the output Chain/Flag.  If the Flag
comment|/// pointer is nullptr, no flag is used.  If V is not nullptr, then it is used
comment|/// in printing better diagnostic messages on error.
name|void
name|getCopyToRegs
argument_list|(
name|SDValue
name|Val
argument_list|,
name|SelectionDAG
operator|&
name|DAG
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|SDValue
operator|&
name|Chain
argument_list|,
name|SDValue
operator|*
name|Flag
argument_list|,
specifier|const
name|Value
operator|*
name|V
operator|=
name|nullptr
argument_list|,
name|ISD
operator|::
name|NodeType
name|PreferredExtendType
operator|=
name|ISD
operator|::
name|ANY_EXTEND
argument_list|)
decl|const
decl_stmt|;
comment|/// AddInlineAsmOperands - Add this value to the specified inlineasm node
comment|/// operand list.  This adds the code marker, matching input operand index
comment|/// (if applicable), and includes the number of values added into it.
name|void
name|AddInlineAsmOperands
argument_list|(
name|unsigned
name|Kind
argument_list|,
name|bool
name|HasMatching
argument_list|,
name|unsigned
name|MatchingIdx
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|SelectionDAG
operator|&
name|DAG
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SDValue
operator|>
operator|&
name|Ops
argument_list|)
decl|const
decl_stmt|;
block|}
struct|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

