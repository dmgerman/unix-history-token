begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/CodeGen/VirtRegMap.h - Virtual Register Map -*- C++ -*--------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements a virtual register map. This maps virtual registers to
end_comment

begin_comment
comment|// physical registers and virtual registers to stack slots. It is created and
end_comment

begin_comment
comment|// updated by a register allocator and then used by a machine code rewriter that
end_comment

begin_comment
comment|// adds spill code and rewrites virtual into physical register references.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_VIRTREGMAP_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_VIRTREGMAP_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunctionPass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/LiveInterval.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetRegisterInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/BitVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/IndexedMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|LiveIntervals
decl_stmt|;
name|class
name|MachineInstr
decl_stmt|;
name|class
name|MachineFunction
decl_stmt|;
name|class
name|MachineRegisterInfo
decl_stmt|;
name|class
name|TargetInstrInfo
decl_stmt|;
name|class
name|TargetRegisterInfo
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|VirtRegMap
range|:
name|public
name|MachineFunctionPass
block|{
name|public
operator|:
expr|enum
block|{
name|NO_PHYS_REG
operator|=
literal|0
block|,
name|NO_STACK_SLOT
operator|=
operator|(
literal|1L
operator|<<
literal|30
operator|)
operator|-
literal|1
block|,
name|MAX_STACK_SLOT
operator|=
operator|(
literal|1L
operator|<<
literal|18
operator|)
operator|-
literal|1
block|}
block|;      enum
name|ModRef
block|{
name|isRef
operator|=
literal|1
block|,
name|isMod
operator|=
literal|2
block|,
name|isModRef
operator|=
literal|3
block|}
block|;
typedef|typedef
name|std
operator|::
name|multimap
operator|<
name|MachineInstr
operator|*
operator|,
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|ModRef
operator|>
expr|>
name|MI2VirtMapTy
expr_stmt|;
name|private
operator|:
name|MachineRegisterInfo
operator|*
name|MRI
decl_stmt|;
specifier|const
name|TargetInstrInfo
modifier|*
name|TII
decl_stmt|;
specifier|const
name|TargetRegisterInfo
modifier|*
name|TRI
decl_stmt|;
name|MachineFunction
modifier|*
name|MF
decl_stmt|;
name|DenseMap
operator|<
specifier|const
name|TargetRegisterClass
operator|*
operator|,
name|BitVector
operator|>
name|allocatableRCRegs
expr_stmt|;
comment|/// Virt2PhysMap - This is a virtual to physical register
comment|/// mapping. Each virtual register is required to have an entry in
comment|/// it; even spilled virtual registers (the register mapped to a
comment|/// spilled register is the temporary used to load it from the
comment|/// stack).
name|IndexedMap
operator|<
name|unsigned
operator|,
name|VirtReg2IndexFunctor
operator|>
name|Virt2PhysMap
expr_stmt|;
comment|/// Virt2StackSlotMap - This is virtual register to stack slot
comment|/// mapping. Each spilled virtual register has an entry in it
comment|/// which corresponds to the stack slot this register is spilled
comment|/// at.
name|IndexedMap
operator|<
name|int
operator|,
name|VirtReg2IndexFunctor
operator|>
name|Virt2StackSlotMap
expr_stmt|;
comment|/// Virt2ReMatIdMap - This is virtual register to rematerialization id
comment|/// mapping. Each spilled virtual register that should be remat'd has an
comment|/// entry in it which corresponds to the remat id.
name|IndexedMap
operator|<
name|int
operator|,
name|VirtReg2IndexFunctor
operator|>
name|Virt2ReMatIdMap
expr_stmt|;
comment|/// Virt2SplitMap - This is virtual register to splitted virtual register
comment|/// mapping.
name|IndexedMap
operator|<
name|unsigned
operator|,
name|VirtReg2IndexFunctor
operator|>
name|Virt2SplitMap
expr_stmt|;
comment|/// Virt2SplitKillMap - This is splitted virtual register to its last use
comment|/// (kill) index mapping.
name|IndexedMap
operator|<
name|SlotIndex
operator|>
name|Virt2SplitKillMap
expr_stmt|;
comment|/// ReMatMap - This is virtual register to re-materialized instruction
comment|/// mapping. Each virtual register whose definition is going to be
comment|/// re-materialized has an entry in it.
name|IndexedMap
operator|<
name|MachineInstr
operator|*
operator|,
name|VirtReg2IndexFunctor
operator|>
name|ReMatMap
expr_stmt|;
comment|/// MI2VirtMap - This is MachineInstr to virtual register
comment|/// mapping. In the case of memory spill code being folded into
comment|/// instructions, we need to know which virtual register was
comment|/// read/written by this instruction.
name|MI2VirtMapTy
name|MI2VirtMap
decl_stmt|;
comment|/// SpillPt2VirtMap - This records the virtual registers which should
comment|/// be spilled right after the MachineInstr due to live interval
comment|/// splitting.
name|std
operator|::
name|map
operator|<
name|MachineInstr
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|bool
operator|>
expr|>
operator|>
name|SpillPt2VirtMap
expr_stmt|;
comment|/// RestorePt2VirtMap - This records the virtual registers which should
comment|/// be restored right before the MachineInstr due to live interval
comment|/// splitting.
name|std
operator|::
name|map
operator|<
name|MachineInstr
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
expr|>
name|RestorePt2VirtMap
expr_stmt|;
comment|/// EmergencySpillMap - This records the physical registers that should
comment|/// be spilled / restored around the MachineInstr since the register
comment|/// allocator has run out of registers.
name|std
operator|::
name|map
operator|<
name|MachineInstr
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
expr|>
name|EmergencySpillMap
expr_stmt|;
comment|/// EmergencySpillSlots - This records emergency spill slots used to
comment|/// spill physical registers when the register allocator runs out of
comment|/// registers. Ideally only one stack slot is used per function per
comment|/// register class.
name|std
operator|::
name|map
operator|<
specifier|const
name|TargetRegisterClass
operator|*
operator|,
name|int
operator|>
name|EmergencySpillSlots
expr_stmt|;
comment|/// ReMatId - Instead of assigning a stack slot to a to be rematerialized
comment|/// virtual register, an unique id is being assigned. This keeps track of
comment|/// the highest id used so far. Note, this starts at (1<<18) to avoid
comment|/// conflicts with stack slot numbers.
name|int
name|ReMatId
decl_stmt|;
comment|/// LowSpillSlot, HighSpillSlot - Lowest and highest spill slot indexes.
name|int
name|LowSpillSlot
decl_stmt|,
name|HighSpillSlot
decl_stmt|;
comment|/// SpillSlotToUsesMap - Records uses for each register spill slot.
name|SmallVector
operator|<
name|SmallPtrSet
operator|<
name|MachineInstr
operator|*
operator|,
literal|4
operator|>
operator|,
literal|8
operator|>
name|SpillSlotToUsesMap
expr_stmt|;
comment|/// ImplicitDefed - One bit for each virtual register. If set it indicates
comment|/// the register is implicitly defined.
name|BitVector
name|ImplicitDefed
decl_stmt|;
comment|/// UnusedRegs - A list of physical registers that have not been used.
name|BitVector
name|UnusedRegs
decl_stmt|;
name|VirtRegMap
argument_list|(
specifier|const
name|VirtRegMap
operator|&
argument_list|)
expr_stmt|;
comment|// DO NOT IMPLEMENT
name|void
name|operator
init|=
operator|(
specifier|const
name|VirtRegMap
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
name|public
label|:
specifier|static
name|char
name|ID
decl_stmt|;
name|VirtRegMap
argument_list|()
operator|:
name|MachineFunctionPass
argument_list|(
operator|&
name|ID
argument_list|)
operator|,
name|Virt2PhysMap
argument_list|(
name|NO_PHYS_REG
argument_list|)
operator|,
name|Virt2StackSlotMap
argument_list|(
name|NO_STACK_SLOT
argument_list|)
operator|,
name|Virt2ReMatIdMap
argument_list|(
name|NO_STACK_SLOT
argument_list|)
operator|,
name|Virt2SplitMap
argument_list|(
literal|0
argument_list|)
operator|,
name|Virt2SplitKillMap
argument_list|(
name|SlotIndex
argument_list|()
argument_list|)
operator|,
name|ReMatMap
argument_list|(
name|NULL
argument_list|)
operator|,
name|ReMatId
argument_list|(
name|MAX_STACK_SLOT
operator|+
literal|1
argument_list|)
operator|,
name|LowSpillSlot
argument_list|(
name|NO_STACK_SLOT
argument_list|)
operator|,
name|HighSpillSlot
argument_list|(
argument|NO_STACK_SLOT
argument_list|)
block|{ }
name|virtual
name|bool
name|runOnMachineFunction
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|)
expr_stmt|;
name|virtual
name|void
name|getAnalysisUsage
argument_list|(
name|AnalysisUsage
operator|&
name|AU
argument_list|)
decl|const
block|{
name|AU
operator|.
name|setPreservesAll
argument_list|()
expr_stmt|;
name|MachineFunctionPass
operator|::
name|getAnalysisUsage
argument_list|(
name|AU
argument_list|)
expr_stmt|;
block|}
name|void
name|grow
parameter_list|()
function_decl|;
comment|/// @brief returns true if the specified virtual register is
comment|/// mapped to a physical register
name|bool
name|hasPhys
argument_list|(
name|unsigned
name|virtReg
argument_list|)
decl|const
block|{
return|return
name|getPhys
argument_list|(
name|virtReg
argument_list|)
operator|!=
name|NO_PHYS_REG
return|;
block|}
comment|/// @brief returns the physical register mapped to the specified
comment|/// virtual register
name|unsigned
name|getPhys
argument_list|(
name|unsigned
name|virtReg
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|TargetRegisterInfo
operator|::
name|isVirtualRegister
argument_list|(
name|virtReg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Virt2PhysMap
index|[
name|virtReg
index|]
return|;
block|}
comment|/// @brief creates a mapping for the specified virtual register to
comment|/// the specified physical register
name|void
name|assignVirt2Phys
parameter_list|(
name|unsigned
name|virtReg
parameter_list|,
name|unsigned
name|physReg
parameter_list|)
block|{
name|assert
argument_list|(
name|TargetRegisterInfo
operator|::
name|isVirtualRegister
argument_list|(
name|virtReg
argument_list|)
operator|&&
name|TargetRegisterInfo
operator|::
name|isPhysicalRegister
argument_list|(
name|physReg
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Virt2PhysMap
index|[
name|virtReg
index|]
operator|==
name|NO_PHYS_REG
operator|&&
literal|"attempt to assign physical register to already mapped "
literal|"virtual register"
argument_list|)
expr_stmt|;
name|Virt2PhysMap
index|[
name|virtReg
index|]
operator|=
name|physReg
expr_stmt|;
block|}
comment|/// @brief clears the specified virtual register's, physical
comment|/// register mapping
name|void
name|clearVirt
parameter_list|(
name|unsigned
name|virtReg
parameter_list|)
block|{
name|assert
argument_list|(
name|TargetRegisterInfo
operator|::
name|isVirtualRegister
argument_list|(
name|virtReg
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Virt2PhysMap
index|[
name|virtReg
index|]
operator|!=
name|NO_PHYS_REG
operator|&&
literal|"attempt to clear a not assigned virtual register"
argument_list|)
expr_stmt|;
name|Virt2PhysMap
index|[
name|virtReg
index|]
operator|=
name|NO_PHYS_REG
expr_stmt|;
block|}
comment|/// @brief clears all virtual to physical register mappings
name|void
name|clearAllVirt
parameter_list|()
block|{
name|Virt2PhysMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|grow
argument_list|()
expr_stmt|;
block|}
comment|/// @brief returns the register allocation preference.
name|unsigned
name|getRegAllocPref
parameter_list|(
name|unsigned
name|virtReg
parameter_list|)
function_decl|;
comment|/// @brief records virtReg is a split live interval from SReg.
name|void
name|setIsSplitFromReg
parameter_list|(
name|unsigned
name|virtReg
parameter_list|,
name|unsigned
name|SReg
parameter_list|)
block|{
name|Virt2SplitMap
index|[
name|virtReg
index|]
operator|=
name|SReg
expr_stmt|;
block|}
comment|/// @brief returns the live interval virtReg is split from.
name|unsigned
name|getPreSplitReg
parameter_list|(
name|unsigned
name|virtReg
parameter_list|)
block|{
return|return
name|Virt2SplitMap
index|[
name|virtReg
index|]
return|;
block|}
comment|/// @brief returns true if the specified virtual register is not
comment|/// mapped to a stack slot or rematerialized.
name|bool
name|isAssignedReg
argument_list|(
name|unsigned
name|virtReg
argument_list|)
decl|const
block|{
if|if
condition|(
name|getStackSlot
argument_list|(
name|virtReg
argument_list|)
operator|==
name|NO_STACK_SLOT
operator|&&
name|getReMatId
argument_list|(
name|virtReg
argument_list|)
operator|==
name|NO_STACK_SLOT
condition|)
return|return
name|true
return|;
comment|// Split register can be assigned a physical register as well as a
comment|// stack slot or remat id.
return|return
operator|(
name|Virt2SplitMap
index|[
name|virtReg
index|]
operator|&&
name|Virt2PhysMap
index|[
name|virtReg
index|]
operator|!=
name|NO_PHYS_REG
operator|)
return|;
block|}
comment|/// @brief returns the stack slot mapped to the specified virtual
comment|/// register
name|int
name|getStackSlot
argument_list|(
name|unsigned
name|virtReg
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|TargetRegisterInfo
operator|::
name|isVirtualRegister
argument_list|(
name|virtReg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Virt2StackSlotMap
index|[
name|virtReg
index|]
return|;
block|}
comment|/// @brief returns the rematerialization id mapped to the specified virtual
comment|/// register
name|int
name|getReMatId
argument_list|(
name|unsigned
name|virtReg
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|TargetRegisterInfo
operator|::
name|isVirtualRegister
argument_list|(
name|virtReg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Virt2ReMatIdMap
index|[
name|virtReg
index|]
return|;
block|}
comment|/// @brief create a mapping for the specifed virtual register to
comment|/// the next available stack slot
name|int
name|assignVirt2StackSlot
parameter_list|(
name|unsigned
name|virtReg
parameter_list|)
function_decl|;
comment|/// @brief create a mapping for the specified virtual register to
comment|/// the specified stack slot
name|void
name|assignVirt2StackSlot
parameter_list|(
name|unsigned
name|virtReg
parameter_list|,
name|int
name|frameIndex
parameter_list|)
function_decl|;
comment|/// @brief assign an unique re-materialization id to the specified
comment|/// virtual register.
name|int
name|assignVirtReMatId
parameter_list|(
name|unsigned
name|virtReg
parameter_list|)
function_decl|;
comment|/// @brief assign an unique re-materialization id to the specified
comment|/// virtual register.
name|void
name|assignVirtReMatId
parameter_list|(
name|unsigned
name|virtReg
parameter_list|,
name|int
name|id
parameter_list|)
function_decl|;
comment|/// @brief returns true if the specified virtual register is being
comment|/// re-materialized.
name|bool
name|isReMaterialized
argument_list|(
name|unsigned
name|virtReg
argument_list|)
decl|const
block|{
return|return
name|ReMatMap
index|[
name|virtReg
index|]
operator|!=
name|NULL
return|;
block|}
comment|/// @brief returns the original machine instruction being re-issued
comment|/// to re-materialize the specified virtual register.
name|MachineInstr
modifier|*
name|getReMaterializedMI
argument_list|(
name|unsigned
name|virtReg
argument_list|)
decl|const
block|{
return|return
name|ReMatMap
index|[
name|virtReg
index|]
return|;
block|}
comment|/// @brief records the specified virtual register will be
comment|/// re-materialized and the original instruction which will be re-issed
comment|/// for this purpose.  If parameter all is true, then all uses of the
comment|/// registers are rematerialized and it's safe to delete the definition.
name|void
name|setVirtIsReMaterialized
parameter_list|(
name|unsigned
name|virtReg
parameter_list|,
name|MachineInstr
modifier|*
name|def
parameter_list|)
block|{
name|ReMatMap
index|[
name|virtReg
index|]
operator|=
name|def
expr_stmt|;
block|}
comment|/// @brief record the last use (kill) of a split virtual register.
name|void
name|addKillPoint
parameter_list|(
name|unsigned
name|virtReg
parameter_list|,
name|SlotIndex
name|index
parameter_list|)
block|{
name|Virt2SplitKillMap
index|[
name|virtReg
index|]
operator|=
name|index
expr_stmt|;
block|}
name|SlotIndex
name|getKillPoint
argument_list|(
name|unsigned
name|virtReg
argument_list|)
decl|const
block|{
return|return
name|Virt2SplitKillMap
index|[
name|virtReg
index|]
return|;
block|}
comment|/// @brief remove the last use (kill) of a split virtual register.
name|void
name|removeKillPoint
parameter_list|(
name|unsigned
name|virtReg
parameter_list|)
block|{
name|Virt2SplitKillMap
index|[
name|virtReg
index|]
operator|=
name|SlotIndex
argument_list|()
expr_stmt|;
block|}
comment|/// @brief returns true if the specified MachineInstr is a spill point.
name|bool
name|isSpillPt
argument_list|(
name|MachineInstr
operator|*
name|Pt
argument_list|)
decl|const
block|{
return|return
name|SpillPt2VirtMap
operator|.
name|find
argument_list|(
name|Pt
argument_list|)
operator|!=
name|SpillPt2VirtMap
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// @brief returns the virtual registers that should be spilled due to
comment|/// splitting right after the specified MachineInstr.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|bool
operator|>
expr|>
operator|&
name|getSpillPtSpills
argument_list|(
argument|MachineInstr *Pt
argument_list|)
block|{
return|return
name|SpillPt2VirtMap
index|[
name|Pt
index|]
return|;
block|}
comment|/// @brief records the specified MachineInstr as a spill point for virtReg.
name|void
name|addSpillPoint
parameter_list|(
name|unsigned
name|virtReg
parameter_list|,
name|bool
name|isKill
parameter_list|,
name|MachineInstr
modifier|*
name|Pt
parameter_list|)
block|{
name|std
operator|::
name|map
operator|<
name|MachineInstr
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|bool
operator|>
expr|>
operator|>
operator|::
name|iterator
name|I
operator|=
name|SpillPt2VirtMap
operator|.
name|find
argument_list|(
name|Pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|!=
name|SpillPt2VirtMap
operator|.
name|end
argument_list|()
condition|)
name|I
operator|->
name|second
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|virtReg
argument_list|,
name|isKill
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|bool
operator|>
expr|>
name|Virts
expr_stmt|;
name|Virts
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|virtReg
argument_list|,
name|isKill
argument_list|)
argument_list|)
expr_stmt|;
name|SpillPt2VirtMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Pt
argument_list|,
name|Virts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// @brief - transfer spill point information from one instruction to
comment|/// another.
name|void
name|transferSpillPts
parameter_list|(
name|MachineInstr
modifier|*
name|Old
parameter_list|,
name|MachineInstr
modifier|*
name|New
parameter_list|)
block|{
name|std
operator|::
name|map
operator|<
name|MachineInstr
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|bool
operator|>
expr|>
operator|>
operator|::
name|iterator
name|I
operator|=
name|SpillPt2VirtMap
operator|.
name|find
argument_list|(
name|Old
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|SpillPt2VirtMap
operator|.
name|end
argument_list|()
condition|)
return|return;
while|while
condition|(
operator|!
name|I
operator|->
name|second
operator|.
name|empty
argument_list|()
condition|)
block|{
name|unsigned
name|virtReg
init|=
name|I
operator|->
name|second
operator|.
name|back
argument_list|()
operator|.
name|first
decl_stmt|;
name|bool
name|isKill
init|=
name|I
operator|->
name|second
operator|.
name|back
argument_list|()
operator|.
name|second
decl_stmt|;
name|I
operator|->
name|second
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|addSpillPoint
argument_list|(
name|virtReg
argument_list|,
name|isKill
argument_list|,
name|New
argument_list|)
expr_stmt|;
block|}
name|SpillPt2VirtMap
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
comment|/// @brief returns true if the specified MachineInstr is a restore point.
name|bool
name|isRestorePt
argument_list|(
name|MachineInstr
operator|*
name|Pt
argument_list|)
decl|const
block|{
return|return
name|RestorePt2VirtMap
operator|.
name|find
argument_list|(
name|Pt
argument_list|)
operator|!=
name|RestorePt2VirtMap
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// @brief returns the virtual registers that should be restoreed due to
comment|/// splitting right after the specified MachineInstr.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|getRestorePtRestores
argument_list|(
argument|MachineInstr *Pt
argument_list|)
block|{
return|return
name|RestorePt2VirtMap
index|[
name|Pt
index|]
return|;
block|}
comment|/// @brief records the specified MachineInstr as a restore point for virtReg.
name|void
name|addRestorePoint
parameter_list|(
name|unsigned
name|virtReg
parameter_list|,
name|MachineInstr
modifier|*
name|Pt
parameter_list|)
block|{
name|std
operator|::
name|map
operator|<
name|MachineInstr
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
expr|>
operator|::
name|iterator
name|I
operator|=
name|RestorePt2VirtMap
operator|.
name|find
argument_list|(
name|Pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|!=
name|RestorePt2VirtMap
operator|.
name|end
argument_list|()
condition|)
name|I
operator|->
name|second
operator|.
name|push_back
argument_list|(
name|virtReg
argument_list|)
expr_stmt|;
else|else
block|{
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|Virts
expr_stmt|;
name|Virts
operator|.
name|push_back
argument_list|(
name|virtReg
argument_list|)
expr_stmt|;
name|RestorePt2VirtMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Pt
argument_list|,
name|Virts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// @brief - transfer restore point information from one instruction to
comment|/// another.
name|void
name|transferRestorePts
parameter_list|(
name|MachineInstr
modifier|*
name|Old
parameter_list|,
name|MachineInstr
modifier|*
name|New
parameter_list|)
block|{
name|std
operator|::
name|map
operator|<
name|MachineInstr
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
expr|>
operator|::
name|iterator
name|I
operator|=
name|RestorePt2VirtMap
operator|.
name|find
argument_list|(
name|Old
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|RestorePt2VirtMap
operator|.
name|end
argument_list|()
condition|)
return|return;
while|while
condition|(
operator|!
name|I
operator|->
name|second
operator|.
name|empty
argument_list|()
condition|)
block|{
name|unsigned
name|virtReg
init|=
name|I
operator|->
name|second
operator|.
name|back
argument_list|()
decl_stmt|;
name|I
operator|->
name|second
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|addRestorePoint
argument_list|(
name|virtReg
argument_list|,
name|New
argument_list|)
expr_stmt|;
block|}
name|RestorePt2VirtMap
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
comment|/// @brief records that the specified physical register must be spilled
comment|/// around the specified machine instr.
name|void
name|addEmergencySpill
parameter_list|(
name|unsigned
name|PhysReg
parameter_list|,
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
if|if
condition|(
name|EmergencySpillMap
operator|.
name|find
argument_list|(
name|MI
argument_list|)
operator|!=
name|EmergencySpillMap
operator|.
name|end
argument_list|()
condition|)
name|EmergencySpillMap
index|[
name|MI
index|]
operator|.
name|push_back
argument_list|(
name|PhysReg
argument_list|)
expr_stmt|;
else|else
block|{
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|PhysRegs
expr_stmt|;
name|PhysRegs
operator|.
name|push_back
argument_list|(
name|PhysReg
argument_list|)
expr_stmt|;
name|EmergencySpillMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|MI
argument_list|,
name|PhysRegs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// @brief returns true if one or more physical registers must be spilled
comment|/// around the specified instruction.
name|bool
name|hasEmergencySpills
argument_list|(
name|MachineInstr
operator|*
name|MI
argument_list|)
decl|const
block|{
return|return
name|EmergencySpillMap
operator|.
name|find
argument_list|(
name|MI
argument_list|)
operator|!=
name|EmergencySpillMap
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// @brief returns the physical registers to be spilled and restored around
comment|/// the instruction.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|getEmergencySpills
argument_list|(
argument|MachineInstr *MI
argument_list|)
block|{
return|return
name|EmergencySpillMap
index|[
name|MI
index|]
return|;
block|}
comment|/// @brief - transfer emergency spill information from one instruction to
comment|/// another.
name|void
name|transferEmergencySpills
parameter_list|(
name|MachineInstr
modifier|*
name|Old
parameter_list|,
name|MachineInstr
modifier|*
name|New
parameter_list|)
block|{
name|std
operator|::
name|map
operator|<
name|MachineInstr
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
expr|>
operator|::
name|iterator
name|I
operator|=
name|EmergencySpillMap
operator|.
name|find
argument_list|(
name|Old
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|EmergencySpillMap
operator|.
name|end
argument_list|()
condition|)
return|return;
while|while
condition|(
operator|!
name|I
operator|->
name|second
operator|.
name|empty
argument_list|()
condition|)
block|{
name|unsigned
name|virtReg
init|=
name|I
operator|->
name|second
operator|.
name|back
argument_list|()
decl_stmt|;
name|I
operator|->
name|second
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|addEmergencySpill
argument_list|(
name|virtReg
argument_list|,
name|New
argument_list|)
expr_stmt|;
block|}
name|EmergencySpillMap
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
comment|/// @brief return or get a emergency spill slot for the register class.
name|int
name|getEmergencySpillSlot
parameter_list|(
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|)
function_decl|;
comment|/// @brief Return lowest spill slot index.
name|int
name|getLowSpillSlot
argument_list|()
specifier|const
block|{
return|return
name|LowSpillSlot
return|;
block|}
comment|/// @brief Return highest spill slot index.
name|int
name|getHighSpillSlot
argument_list|()
specifier|const
block|{
return|return
name|HighSpillSlot
return|;
block|}
comment|/// @brief Records a spill slot use.
name|void
name|addSpillSlotUse
parameter_list|(
name|int
name|FrameIndex
parameter_list|,
name|MachineInstr
modifier|*
name|MI
parameter_list|)
function_decl|;
comment|/// @brief Returns true if spill slot has been used.
name|bool
name|isSpillSlotUsed
argument_list|(
name|int
name|FrameIndex
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|FrameIndex
operator|>=
literal|0
operator|&&
literal|"Spill slot index should not be negative!"
argument_list|)
expr_stmt|;
return|return
operator|!
name|SpillSlotToUsesMap
index|[
name|FrameIndex
operator|-
name|LowSpillSlot
index|]
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// @brief Mark the specified register as being implicitly defined.
name|void
name|setIsImplicitlyDefined
parameter_list|(
name|unsigned
name|VirtReg
parameter_list|)
block|{
name|ImplicitDefed
operator|.
name|set
argument_list|(
name|VirtReg
operator|-
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Returns true if the virtual register is implicitly defined.
name|bool
name|isImplicitlyDefined
argument_list|(
name|unsigned
name|VirtReg
argument_list|)
decl|const
block|{
return|return
name|ImplicitDefed
index|[
name|VirtReg
operator|-
name|TargetRegisterInfo
operator|::
name|FirstVirtualRegister
index|]
return|;
block|}
comment|/// @brief Updates information about the specified virtual register's value
comment|/// folded into newMI machine instruction.
name|void
name|virtFolded
parameter_list|(
name|unsigned
name|VirtReg
parameter_list|,
name|MachineInstr
modifier|*
name|OldMI
parameter_list|,
name|MachineInstr
modifier|*
name|NewMI
parameter_list|,
name|ModRef
name|MRInfo
parameter_list|)
function_decl|;
comment|/// @brief Updates information about the specified virtual register's value
comment|/// folded into the specified machine instruction.
name|void
name|virtFolded
parameter_list|(
name|unsigned
name|VirtReg
parameter_list|,
name|MachineInstr
modifier|*
name|MI
parameter_list|,
name|ModRef
name|MRInfo
parameter_list|)
function_decl|;
comment|/// @brief returns the virtual registers' values folded in memory
comment|/// operands of this instruction
name|std
operator|::
name|pair
operator|<
name|MI2VirtMapTy
operator|::
name|const_iterator
operator|,
name|MI2VirtMapTy
operator|::
name|const_iterator
operator|>
name|getFoldedVirts
argument_list|(
argument|MachineInstr* MI
argument_list|)
specifier|const
block|{
return|return
name|MI2VirtMap
operator|.
name|equal_range
argument_list|(
name|MI
argument_list|)
return|;
block|}
comment|/// RemoveMachineInstrFromMaps - MI is being erased, remove it from the
comment|/// the folded instruction map and spill point map.
name|void
name|RemoveMachineInstrFromMaps
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|)
function_decl|;
comment|/// FindUnusedRegisters - Gather a list of allocatable registers that
comment|/// have not been allocated to any virtual register.
name|bool
name|FindUnusedRegisters
parameter_list|(
name|LiveIntervals
modifier|*
name|LIs
parameter_list|)
function_decl|;
comment|/// HasUnusedRegisters - Return true if there are any allocatable registers
comment|/// that have not been allocated to any virtual register.
name|bool
name|HasUnusedRegisters
argument_list|()
specifier|const
block|{
return|return
operator|!
name|UnusedRegs
operator|.
name|none
argument_list|()
return|;
block|}
comment|/// setRegisterUsed - Remember the physical register is now used.
name|void
name|setRegisterUsed
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
name|UnusedRegs
operator|.
name|reset
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
block|}
comment|/// isRegisterUnused - Return true if the physical register has not been
comment|/// used.
name|bool
name|isRegisterUnused
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
block|{
return|return
name|UnusedRegs
index|[
name|Reg
index|]
return|;
block|}
comment|/// getFirstUnusedRegister - Return the first physical register that has not
comment|/// been used.
name|unsigned
name|getFirstUnusedRegister
parameter_list|(
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|)
block|{
name|int
name|Reg
init|=
name|UnusedRegs
operator|.
name|find_first
argument_list|()
decl_stmt|;
while|while
condition|(
name|Reg
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|allocatableRCRegs
index|[
name|RC
index|]
index|[
name|Reg
index|]
condition|)
return|return
operator|(
name|unsigned
operator|)
name|Reg
return|;
name|Reg
operator|=
name|UnusedRegs
operator|.
name|find_next
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|VirtRegMap
operator|&
name|VRM
operator|)
block|{
name|VRM
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

