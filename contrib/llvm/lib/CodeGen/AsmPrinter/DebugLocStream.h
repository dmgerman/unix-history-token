begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- lib/CodeGen/DebugLocStream.h - DWARF debug_loc stream --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCSTREAM_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCSTREAM_H
end_define

begin_include
include|#
directive|include
file|"ByteStreamer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|AsmPrinter
decl_stmt|;
name|class
name|DbgVariable
decl_stmt|;
name|class
name|DwarfCompileUnit
decl_stmt|;
name|class
name|MachineInstr
decl_stmt|;
name|class
name|MCSymbol
decl_stmt|;
comment|/// \brief Byte stream of .debug_loc entries.
comment|///
comment|/// Stores a unified stream of .debug_loc entries.  There's \a List for each
comment|/// variable/inlined-at pair, and an \a Entry for each \a DebugLocEntry.
comment|///
comment|/// FIXME: Do we need all these temp symbols?
comment|/// FIXME: Why not output directly to the output stream?
name|class
name|DebugLocStream
block|{
name|public
label|:
struct|struct
name|List
block|{
name|DwarfCompileUnit
modifier|*
name|CU
decl_stmt|;
name|MCSymbol
modifier|*
name|Label
init|=
name|nullptr
decl_stmt|;
name|size_t
name|EntryOffset
decl_stmt|;
name|List
argument_list|(
argument|DwarfCompileUnit *CU
argument_list|,
argument|size_t EntryOffset
argument_list|)
block|:
name|CU
argument_list|(
name|CU
argument_list|)
operator|,
name|EntryOffset
argument_list|(
argument|EntryOffset
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|Entry
block|{
specifier|const
name|MCSymbol
modifier|*
name|BeginSym
decl_stmt|;
specifier|const
name|MCSymbol
modifier|*
name|EndSym
decl_stmt|;
name|size_t
name|ByteOffset
decl_stmt|;
name|size_t
name|CommentOffset
decl_stmt|;
name|Entry
argument_list|(
argument|const MCSymbol *BeginSym
argument_list|,
argument|const MCSymbol *EndSym
argument_list|,
argument|size_t ByteOffset
argument_list|,
argument|size_t CommentOffset
argument_list|)
block|:
name|BeginSym
argument_list|(
name|BeginSym
argument_list|)
operator|,
name|EndSym
argument_list|(
name|EndSym
argument_list|)
operator|,
name|ByteOffset
argument_list|(
name|ByteOffset
argument_list|)
operator|,
name|CommentOffset
argument_list|(
argument|CommentOffset
argument_list|)
block|{}
block|}
struct|;
name|private
label|:
name|SmallVector
operator|<
name|List
operator|,
literal|4
operator|>
name|Lists
expr_stmt|;
name|SmallVector
operator|<
name|Entry
operator|,
literal|32
operator|>
name|Entries
expr_stmt|;
name|SmallString
operator|<
literal|256
operator|>
name|DWARFBytes
expr_stmt|;
name|SmallVector
operator|<
name|std
operator|::
name|string
operator|,
literal|32
operator|>
name|Comments
expr_stmt|;
comment|/// \brief Only verbose textual output needs comments.  This will be set to
comment|/// true for that case, and false otherwise.
name|bool
name|GenerateComments
decl_stmt|;
name|public
label|:
name|DebugLocStream
argument_list|(
argument|bool GenerateComments
argument_list|)
block|:
name|GenerateComments
argument_list|(
argument|GenerateComments
argument_list|)
block|{ }
name|size_t
name|getNumLists
argument_list|()
specifier|const
block|{
return|return
name|Lists
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|List
modifier|&
name|getList
argument_list|(
name|size_t
name|LI
argument_list|)
decl|const
block|{
return|return
name|Lists
index|[
name|LI
index|]
return|;
block|}
name|ArrayRef
operator|<
name|List
operator|>
name|getLists
argument_list|()
specifier|const
block|{
return|return
name|Lists
return|;
block|}
name|class
name|ListBuilder
decl_stmt|;
name|class
name|EntryBuilder
decl_stmt|;
name|private
label|:
comment|/// \brief Start a new .debug_loc entry list.
comment|///
comment|/// Start a new .debug_loc entry list.  Return the new list's index so it can
comment|/// be retrieved later via \a getList().
comment|///
comment|/// Until the next call, \a startEntry() will add entries to this list.
name|size_t
name|startList
parameter_list|(
name|DwarfCompileUnit
modifier|*
name|CU
parameter_list|)
block|{
name|size_t
name|LI
init|=
name|Lists
operator|.
name|size
argument_list|()
decl_stmt|;
name|Lists
operator|.
name|emplace_back
argument_list|(
name|CU
argument_list|,
name|Entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|LI
return|;
block|}
comment|/// Finalize a .debug_loc entry list.
comment|///
comment|/// If there are no entries in this list, delete it outright.  Otherwise,
comment|/// create a label with \a Asm.
comment|///
comment|/// \return false iff the list is deleted.
name|bool
name|finalizeList
parameter_list|(
name|AsmPrinter
modifier|&
name|Asm
parameter_list|)
function_decl|;
comment|/// \brief Start a new .debug_loc entry.
comment|///
comment|/// Until the next call, bytes added to the stream will be added to this
comment|/// entry.
name|void
name|startEntry
parameter_list|(
specifier|const
name|MCSymbol
modifier|*
name|BeginSym
parameter_list|,
specifier|const
name|MCSymbol
modifier|*
name|EndSym
parameter_list|)
block|{
name|Entries
operator|.
name|emplace_back
argument_list|(
name|BeginSym
argument_list|,
name|EndSym
argument_list|,
name|DWARFBytes
operator|.
name|size
argument_list|()
argument_list|,
name|Comments
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// Finalize a .debug_loc entry, deleting if it's empty.
name|void
name|finalizeEntry
parameter_list|()
function_decl|;
name|public
label|:
name|BufferByteStreamer
name|getStreamer
parameter_list|()
block|{
return|return
name|BufferByteStreamer
argument_list|(
name|DWARFBytes
argument_list|,
name|Comments
argument_list|,
name|GenerateComments
argument_list|)
return|;
block|}
name|ArrayRef
operator|<
name|Entry
operator|>
name|getEntries
argument_list|(
argument|const List&L
argument_list|)
specifier|const
block|{
name|size_t
name|LI
operator|=
name|getIndex
argument_list|(
name|L
argument_list|)
block|;
return|return
name|makeArrayRef
argument_list|(
name|Entries
argument_list|)
operator|.
name|slice
argument_list|(
name|Lists
index|[
name|LI
index|]
operator|.
name|EntryOffset
argument_list|,
name|getNumEntries
argument_list|(
name|LI
argument_list|)
argument_list|)
return|;
block|}
name|ArrayRef
operator|<
name|char
operator|>
name|getBytes
argument_list|(
argument|const Entry&E
argument_list|)
specifier|const
block|{
name|size_t
name|EI
operator|=
name|getIndex
argument_list|(
name|E
argument_list|)
block|;
return|return
name|makeArrayRef
argument_list|(
name|DWARFBytes
operator|.
name|begin
argument_list|()
argument_list|,
name|DWARFBytes
operator|.
name|end
argument_list|()
argument_list|)
operator|.
name|slice
argument_list|(
name|Entries
index|[
name|EI
index|]
operator|.
name|ByteOffset
argument_list|,
name|getNumBytes
argument_list|(
name|EI
argument_list|)
argument_list|)
return|;
block|}
name|ArrayRef
operator|<
name|std
operator|::
name|string
operator|>
name|getComments
argument_list|(
argument|const Entry&E
argument_list|)
specifier|const
block|{
name|size_t
name|EI
operator|=
name|getIndex
argument_list|(
name|E
argument_list|)
block|;
return|return
name|makeArrayRef
argument_list|(
name|Comments
argument_list|)
operator|.
name|slice
argument_list|(
name|Entries
index|[
name|EI
index|]
operator|.
name|CommentOffset
argument_list|,
name|getNumComments
argument_list|(
name|EI
argument_list|)
argument_list|)
return|;
block|}
name|private
label|:
name|size_t
name|getIndex
argument_list|(
specifier|const
name|List
operator|&
name|L
argument_list|)
decl|const
block|{
name|assert
argument_list|(
operator|&
name|Lists
operator|.
name|front
argument_list|()
operator|<=
operator|&
name|L
operator|&&
operator|&
name|L
operator|<=
operator|&
name|Lists
operator|.
name|back
argument_list|()
operator|&&
literal|"Expected valid list"
argument_list|)
expr_stmt|;
return|return
operator|&
name|L
operator|-
operator|&
name|Lists
operator|.
name|front
argument_list|()
return|;
block|}
name|size_t
name|getIndex
argument_list|(
specifier|const
name|Entry
operator|&
name|E
argument_list|)
decl|const
block|{
name|assert
argument_list|(
operator|&
name|Entries
operator|.
name|front
argument_list|()
operator|<=
operator|&
name|E
operator|&&
operator|&
name|E
operator|<=
operator|&
name|Entries
operator|.
name|back
argument_list|()
operator|&&
literal|"Expected valid entry"
argument_list|)
expr_stmt|;
return|return
operator|&
name|E
operator|-
operator|&
name|Entries
operator|.
name|front
argument_list|()
return|;
block|}
name|size_t
name|getNumEntries
argument_list|(
name|size_t
name|LI
argument_list|)
decl|const
block|{
if|if
condition|(
name|LI
operator|+
literal|1
operator|==
name|Lists
operator|.
name|size
argument_list|()
condition|)
return|return
name|Entries
operator|.
name|size
argument_list|()
operator|-
name|Lists
index|[
name|LI
index|]
operator|.
name|EntryOffset
return|;
return|return
name|Lists
index|[
name|LI
operator|+
literal|1
index|]
operator|.
name|EntryOffset
operator|-
name|Lists
index|[
name|LI
index|]
operator|.
name|EntryOffset
return|;
block|}
name|size_t
name|getNumBytes
argument_list|(
name|size_t
name|EI
argument_list|)
decl|const
block|{
if|if
condition|(
name|EI
operator|+
literal|1
operator|==
name|Entries
operator|.
name|size
argument_list|()
condition|)
return|return
name|DWARFBytes
operator|.
name|size
argument_list|()
operator|-
name|Entries
index|[
name|EI
index|]
operator|.
name|ByteOffset
return|;
return|return
name|Entries
index|[
name|EI
operator|+
literal|1
index|]
operator|.
name|ByteOffset
operator|-
name|Entries
index|[
name|EI
index|]
operator|.
name|ByteOffset
return|;
block|}
name|size_t
name|getNumComments
argument_list|(
name|size_t
name|EI
argument_list|)
decl|const
block|{
if|if
condition|(
name|EI
operator|+
literal|1
operator|==
name|Entries
operator|.
name|size
argument_list|()
condition|)
return|return
name|Comments
operator|.
name|size
argument_list|()
operator|-
name|Entries
index|[
name|EI
index|]
operator|.
name|CommentOffset
return|;
return|return
name|Entries
index|[
name|EI
operator|+
literal|1
index|]
operator|.
name|CommentOffset
operator|-
name|Entries
index|[
name|EI
index|]
operator|.
name|CommentOffset
return|;
block|}
block|}
empty_stmt|;
comment|/// Builder for DebugLocStream lists.
name|class
name|DebugLocStream
operator|::
name|ListBuilder
block|{
name|DebugLocStream
operator|&
name|Locs
block|;
name|AsmPrinter
operator|&
name|Asm
block|;
name|DbgVariable
operator|&
name|V
block|;
specifier|const
name|MachineInstr
operator|&
name|MI
block|;
name|size_t
name|ListIndex
block|;
name|public
operator|:
name|ListBuilder
argument_list|(
name|DebugLocStream
operator|&
name|Locs
argument_list|,
name|DwarfCompileUnit
operator|&
name|CU
argument_list|,
name|AsmPrinter
operator|&
name|Asm
argument_list|,
name|DbgVariable
operator|&
name|V
argument_list|,
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
operator|:
name|Locs
argument_list|(
name|Locs
argument_list|)
block|,
name|Asm
argument_list|(
name|Asm
argument_list|)
block|,
name|V
argument_list|(
name|V
argument_list|)
block|,
name|MI
argument_list|(
name|MI
argument_list|)
block|,
name|ListIndex
argument_list|(
argument|Locs.startList(&CU)
argument_list|)
block|{}
comment|/// Finalize the list.
comment|///
comment|/// If the list is empty, delete it.  Otherwise, finalize it by creating a
comment|/// temp symbol in \a Asm and setting up the \a DbgVariable.
operator|~
name|ListBuilder
argument_list|()
block|;
name|DebugLocStream
operator|&
name|getLocs
argument_list|()
block|{
return|return
name|Locs
return|;
block|}
expr|}
block|;
comment|/// Builder for DebugLocStream entries.
name|class
name|DebugLocStream
operator|::
name|EntryBuilder
block|{
name|DebugLocStream
operator|&
name|Locs
block|;
name|public
operator|:
name|EntryBuilder
argument_list|(
name|ListBuilder
operator|&
name|List
argument_list|,
specifier|const
name|MCSymbol
operator|*
name|Begin
argument_list|,
specifier|const
name|MCSymbol
operator|*
name|End
argument_list|)
operator|:
name|Locs
argument_list|(
argument|List.getLocs()
argument_list|)
block|{
name|Locs
operator|.
name|startEntry
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
block|;   }
comment|/// Finalize the entry, deleting it if it's empty.
operator|~
name|EntryBuilder
argument_list|()
block|{
name|Locs
operator|.
name|finalizeEntry
argument_list|()
block|; }
name|BufferByteStreamer
name|getStreamer
argument_list|()
block|{
return|return
name|Locs
operator|.
name|getStreamer
argument_list|()
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

