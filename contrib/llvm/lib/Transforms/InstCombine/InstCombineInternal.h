begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- InstCombineInternal.h - InstCombine pass internals -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This file provides internal interfaces used to implement the InstCombine.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H
end_define

begin_include
include|#
directive|include
file|"llvm/Analysis/AliasAnalysis.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/AssumptionCache.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/InstructionSimplify.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/LoopInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetFolder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/ValueTracking.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DIBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Dominators.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IRBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/InstVisitor.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IntrinsicInst.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Operator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/PatternMatch.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Dwarf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/KnownBits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Transforms/InstCombine/InstCombineWorklist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Transforms/Utils/Local.h"
end_include

begin_define
define|#
directive|define
name|DEBUG_TYPE
value|"instcombine"
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|CallSite
decl_stmt|;
name|class
name|DataLayout
decl_stmt|;
name|class
name|DominatorTree
decl_stmt|;
name|class
name|TargetLibraryInfo
decl_stmt|;
name|class
name|DbgDeclareInst
decl_stmt|;
name|class
name|MemIntrinsic
decl_stmt|;
name|class
name|MemSetInst
decl_stmt|;
comment|/// Assign a complexity or rank value to LLVM Values. This is used to reduce
comment|/// the amount of pattern matching needed for compares and commutative
comment|/// instructions. For example, if we have:
comment|///   icmp ugt X, Constant
comment|/// or
comment|///   xor (add X, Constant), cast Z
comment|///
comment|/// We do not have to consider the commuted variants of these patterns because
comment|/// canonicalization based on complexity guarantees the above ordering.
comment|///
comment|/// This routine maps IR values to various complexity ranks:
comment|///   0 -> undef
comment|///   1 -> Constants
comment|///   2 -> Other non-instructions
comment|///   3 -> Arguments
comment|///   4 -> Cast and (f)neg/not instructions
comment|///   5 -> Other instructions
specifier|static
specifier|inline
name|unsigned
name|getComplexity
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
block|{
if|if
condition|(
name|isa
operator|<
name|Instruction
operator|>
operator|(
name|V
operator|)
condition|)
block|{
if|if
condition|(
name|isa
operator|<
name|CastInst
operator|>
operator|(
name|V
operator|)
operator|||
name|BinaryOperator
operator|::
name|isNeg
argument_list|(
name|V
argument_list|)
operator|||
name|BinaryOperator
operator|::
name|isFNeg
argument_list|(
name|V
argument_list|)
operator|||
name|BinaryOperator
operator|::
name|isNot
argument_list|(
name|V
argument_list|)
condition|)
return|return
literal|4
return|;
return|return
literal|5
return|;
block|}
if|if
condition|(
name|isa
operator|<
name|Argument
operator|>
operator|(
name|V
operator|)
condition|)
return|return
literal|3
return|;
return|return
name|isa
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|?
operator|(
name|isa
operator|<
name|UndefValue
operator|>
operator|(
name|V
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
else|:
literal|2
return|;
block|}
comment|/// Predicate canonicalization reduces the number of patterns that need to be
comment|/// matched by other transforms. For example, we may swap the operands of a
comment|/// conditional branch or select to create a compare with a canonical (inverted)
comment|/// predicate which is then more likely to be matched with other values.
specifier|static
specifier|inline
name|bool
name|isCanonicalPredicate
argument_list|(
name|CmpInst
operator|::
name|Predicate
name|Pred
argument_list|)
block|{
switch|switch
condition|(
name|Pred
condition|)
block|{
case|case
name|CmpInst
operator|::
name|ICMP_NE
case|:
case|case
name|CmpInst
operator|::
name|ICMP_ULE
case|:
case|case
name|CmpInst
operator|::
name|ICMP_SLE
case|:
case|case
name|CmpInst
operator|::
name|ICMP_UGE
case|:
case|case
name|CmpInst
operator|::
name|ICMP_SGE
case|:
comment|// TODO: There are 16 FCMP predicates. Should others be (not) canonical?
case|case
name|CmpInst
operator|::
name|FCMP_ONE
case|:
case|case
name|CmpInst
operator|::
name|FCMP_OLE
case|:
case|case
name|CmpInst
operator|::
name|FCMP_OGE
case|:
return|return
name|false
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
comment|/// \brief Add one to a Constant
specifier|static
specifier|inline
name|Constant
modifier|*
name|AddOne
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|)
block|{
return|return
name|ConstantExpr
operator|::
name|getAdd
argument_list|(
name|C
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|C
operator|->
name|getType
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Subtract one from a Constant
specifier|static
specifier|inline
name|Constant
modifier|*
name|SubOne
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|)
block|{
return|return
name|ConstantExpr
operator|::
name|getSub
argument_list|(
name|C
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|C
operator|->
name|getType
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Return true if the specified value is free to invert (apply ~ to).
comment|/// This happens in cases where the ~ can be eliminated.  If WillInvertAllUses
comment|/// is true, work under the assumption that the caller intends to remove all
comment|/// uses of V and only keep uses of ~V.
comment|///
specifier|static
specifier|inline
name|bool
name|IsFreeToInvert
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|bool
name|WillInvertAllUses
parameter_list|)
block|{
comment|// ~(~(X)) -> X.
if|if
condition|(
name|BinaryOperator
operator|::
name|isNot
argument_list|(
name|V
argument_list|)
condition|)
return|return
name|true
return|;
comment|// Constants can be considered to be not'ed values.
if|if
condition|(
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|true
return|;
comment|// A vector of constant integers can be inverted easily.
name|Constant
modifier|*
name|CV
decl_stmt|;
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isVectorTy
argument_list|()
operator|&&
name|match
argument_list|(
name|V
argument_list|,
name|PatternMatch
operator|::
name|m_Constant
argument_list|(
name|CV
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|NumElts
init|=
name|V
operator|->
name|getType
argument_list|()
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|NumElts
condition|;
operator|++
name|i
control|)
block|{
name|Constant
modifier|*
name|Elt
init|=
name|CV
operator|->
name|getAggregateElement
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Elt
condition|)
return|return
name|false
return|;
if|if
condition|(
name|isa
operator|<
name|UndefValue
operator|>
operator|(
name|Elt
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|Elt
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
comment|// Compares can be inverted if all of their uses are being modified to use the
comment|// ~V.
if|if
condition|(
name|isa
operator|<
name|CmpInst
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|WillInvertAllUses
return|;
comment|// If `V` is of the form `A + Constant` then `-1 - V` can be folded into `(-1
comment|// - Constant) - A` if we are willing to invert all of the uses.
if|if
condition|(
name|BinaryOperator
modifier|*
name|BO
init|=
name|dyn_cast
operator|<
name|BinaryOperator
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|BO
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Add
operator|||
name|BO
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Sub
condition|)
if|if
condition|(
name|isa
operator|<
name|Constant
operator|>
operator|(
name|BO
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|)
operator|||
name|isa
operator|<
name|Constant
operator|>
operator|(
name|BO
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
return|return
name|WillInvertAllUses
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Specific patterns of overflow check idioms that we match.
enum|enum
name|OverflowCheckFlavor
block|{
name|OCF_UNSIGNED_ADD
block|,
name|OCF_SIGNED_ADD
block|,
name|OCF_UNSIGNED_SUB
block|,
name|OCF_SIGNED_SUB
block|,
name|OCF_UNSIGNED_MUL
block|,
name|OCF_SIGNED_MUL
block|,
name|OCF_INVALID
block|}
enum|;
comment|/// \brief Returns the OverflowCheckFlavor corresponding to a overflow_with_op
comment|/// intrinsic.
specifier|static
specifier|inline
name|OverflowCheckFlavor
name|IntrinsicIDToOverflowCheckFlavor
parameter_list|(
name|unsigned
name|ID
parameter_list|)
block|{
switch|switch
condition|(
name|ID
condition|)
block|{
default|default:
return|return
name|OCF_INVALID
return|;
case|case
name|Intrinsic
operator|::
name|uadd_with_overflow
case|:
return|return
name|OCF_UNSIGNED_ADD
return|;
case|case
name|Intrinsic
operator|::
name|sadd_with_overflow
case|:
return|return
name|OCF_SIGNED_ADD
return|;
case|case
name|Intrinsic
operator|::
name|usub_with_overflow
case|:
return|return
name|OCF_UNSIGNED_SUB
return|;
case|case
name|Intrinsic
operator|::
name|ssub_with_overflow
case|:
return|return
name|OCF_SIGNED_SUB
return|;
case|case
name|Intrinsic
operator|::
name|umul_with_overflow
case|:
return|return
name|OCF_UNSIGNED_MUL
return|;
case|case
name|Intrinsic
operator|::
name|smul_with_overflow
case|:
return|return
name|OCF_SIGNED_MUL
return|;
block|}
block|}
comment|/// \brief The core instruction combiner logic.
comment|///
comment|/// This class provides both the logic to recursively visit instructions and
comment|/// combine them.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|InstCombiner
range|:
name|public
name|InstVisitor
operator|<
name|InstCombiner
decl_stmt|,
name|Instruction
modifier|*
decl|>
block|{
comment|// FIXME: These members shouldn't be public.
name|public
label|:
comment|/// \brief A worklist of the instructions that need to be simplified.
name|InstCombineWorklist
modifier|&
name|Worklist
decl_stmt|;
comment|/// \brief An IRBuilder that automatically inserts new instructions into the
comment|/// worklist.
typedef|typedef
name|IRBuilder
operator|<
name|TargetFolder
operator|,
name|IRBuilderCallbackInserter
operator|>
name|BuilderTy
expr_stmt|;
name|BuilderTy
modifier|*
name|Builder
decl_stmt|;
name|private
label|:
comment|// Mode in which we are running the combiner.
specifier|const
name|bool
name|MinimizeSize
decl_stmt|;
comment|/// Enable combines that trigger rarely but are costly in compiletime.
specifier|const
name|bool
name|ExpensiveCombines
decl_stmt|;
name|AliasAnalysis
modifier|*
name|AA
decl_stmt|;
comment|// Required analyses.
name|AssumptionCache
modifier|&
name|AC
decl_stmt|;
name|TargetLibraryInfo
modifier|&
name|TLI
decl_stmt|;
name|DominatorTree
modifier|&
name|DT
decl_stmt|;
specifier|const
name|DataLayout
modifier|&
name|DL
decl_stmt|;
specifier|const
name|SimplifyQuery
name|SQ
decl_stmt|;
comment|// Optional analyses. When non-null, these can both be used to do better
comment|// combining and will be updated to reflect any changes.
name|LoopInfo
modifier|*
name|LI
decl_stmt|;
name|bool
name|MadeIRChange
decl_stmt|;
name|public
label|:
name|InstCombiner
argument_list|(
argument|InstCombineWorklist&Worklist
argument_list|,
argument|BuilderTy *Builder
argument_list|,
argument|bool MinimizeSize
argument_list|,
argument|bool ExpensiveCombines
argument_list|,
argument|AliasAnalysis *AA
argument_list|,
argument|AssumptionCache&AC
argument_list|,
argument|TargetLibraryInfo&TLI
argument_list|,
argument|DominatorTree&DT
argument_list|,
argument|const DataLayout&DL
argument_list|,
argument|LoopInfo *LI
argument_list|)
block|:
name|Worklist
argument_list|(
name|Worklist
argument_list|)
operator|,
name|Builder
argument_list|(
name|Builder
argument_list|)
operator|,
name|MinimizeSize
argument_list|(
name|MinimizeSize
argument_list|)
operator|,
name|ExpensiveCombines
argument_list|(
name|ExpensiveCombines
argument_list|)
operator|,
name|AA
argument_list|(
name|AA
argument_list|)
operator|,
name|AC
argument_list|(
name|AC
argument_list|)
operator|,
name|TLI
argument_list|(
name|TLI
argument_list|)
operator|,
name|DT
argument_list|(
name|DT
argument_list|)
operator|,
name|DL
argument_list|(
name|DL
argument_list|)
operator|,
name|SQ
argument_list|(
name|DL
argument_list|,
operator|&
name|TLI
argument_list|,
operator|&
name|DT
argument_list|,
operator|&
name|AC
argument_list|)
operator|,
name|LI
argument_list|(
name|LI
argument_list|)
operator|,
name|MadeIRChange
argument_list|(
argument|false
argument_list|)
block|{}
comment|/// \brief Run the combiner over the entire worklist until it is empty.
comment|///
comment|/// \returns true if the IR is changed.
name|bool
name|run
argument_list|()
expr_stmt|;
name|AssumptionCache
operator|&
name|getAssumptionCache
argument_list|()
specifier|const
block|{
return|return
name|AC
return|;
block|}
specifier|const
name|DataLayout
operator|&
name|getDataLayout
argument_list|()
specifier|const
block|{
return|return
name|DL
return|;
block|}
name|DominatorTree
operator|&
name|getDominatorTree
argument_list|()
specifier|const
block|{
return|return
name|DT
return|;
block|}
name|LoopInfo
operator|*
name|getLoopInfo
argument_list|()
specifier|const
block|{
return|return
name|LI
return|;
block|}
name|TargetLibraryInfo
operator|&
name|getTargetLibraryInfo
argument_list|()
specifier|const
block|{
return|return
name|TLI
return|;
block|}
comment|// Visitation implementation - Implement instruction combining for different
comment|// instruction types.  The semantics are as follows:
comment|// Return Value:
comment|//    null        - No change was made
comment|//     I          - Change was made, I is still valid, I may be dead though
comment|//   otherwise    - Change was made, replace I with returned instruction
comment|//
name|Instruction
modifier|*
name|visitAdd
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFAdd
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|OptimizePointerDifference
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSub
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFSub
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitMul
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|foldFMulConst
parameter_list|(
name|Instruction
modifier|*
name|FMulOrDiv
parameter_list|,
name|Constant
modifier|*
name|C
parameter_list|,
name|Instruction
modifier|*
name|InsertBefore
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFMul
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitURem
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSRem
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFRem
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|SimplifyDivRemOfSelect
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonRemTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonIRemTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonDivTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonIDivTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitUDiv
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSDiv
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFDiv
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|simplifyRangeCheck
parameter_list|(
name|ICmpInst
modifier|*
name|Cmp0
parameter_list|,
name|ICmpInst
modifier|*
name|Cmp1
parameter_list|,
name|bool
name|Inverted
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldAndOfICmps
parameter_list|(
name|ICmpInst
modifier|*
name|LHS
parameter_list|,
name|ICmpInst
modifier|*
name|RHS
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldAndOfFCmps
parameter_list|(
name|FCmpInst
modifier|*
name|LHS
parameter_list|,
name|FCmpInst
modifier|*
name|RHS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAnd
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldOrOfICmps
parameter_list|(
name|ICmpInst
modifier|*
name|LHS
parameter_list|,
name|ICmpInst
modifier|*
name|RHS
parameter_list|,
name|Instruction
modifier|*
name|CxtI
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldOrOfFCmps
parameter_list|(
name|FCmpInst
modifier|*
name|LHS
parameter_list|,
name|FCmpInst
modifier|*
name|RHS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldOrWithConstants
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|,
name|Value
modifier|*
name|Op
parameter_list|,
name|Value
modifier|*
name|A
parameter_list|,
name|Value
modifier|*
name|B
parameter_list|,
name|Value
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldXorWithConstants
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|,
name|Value
modifier|*
name|Op
parameter_list|,
name|Value
modifier|*
name|A
parameter_list|,
name|Value
modifier|*
name|B
parameter_list|,
name|Value
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitOr
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitXor
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitShl
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAShr
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitLShr
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonShiftTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFCmpInst
parameter_list|(
name|FCmpInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitICmpInst
parameter_list|(
name|ICmpInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldShiftByConstant
parameter_list|(
name|Value
modifier|*
name|Op0
parameter_list|,
name|Constant
modifier|*
name|Op1
parameter_list|,
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonCastTransforms
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonPointerCastTransforms
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitTrunc
parameter_list|(
name|TruncInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitZExt
parameter_list|(
name|ZExtInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSExt
parameter_list|(
name|SExtInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFPTrunc
parameter_list|(
name|FPTruncInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFPExt
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFPToUI
parameter_list|(
name|FPToUIInst
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFPToSI
parameter_list|(
name|FPToSIInst
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitUIToFP
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSIToFP
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitPtrToInt
parameter_list|(
name|PtrToIntInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitIntToPtr
parameter_list|(
name|IntToPtrInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitBitCast
parameter_list|(
name|BitCastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAddrSpaceCast
parameter_list|(
name|AddrSpaceCastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldItoFPtoI
parameter_list|(
name|Instruction
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSelectInst
parameter_list|(
name|SelectInst
modifier|&
name|SI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitCallInst
parameter_list|(
name|CallInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitInvokeInst
parameter_list|(
name|InvokeInst
modifier|&
name|II
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|SliceUpIllegalIntegerPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitPHINode
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitGetElementPtrInst
parameter_list|(
name|GetElementPtrInst
modifier|&
name|GEP
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAllocaInst
parameter_list|(
name|AllocaInst
modifier|&
name|AI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAllocSite
parameter_list|(
name|Instruction
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFree
parameter_list|(
name|CallInst
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitLoadInst
parameter_list|(
name|LoadInst
modifier|&
name|LI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitStoreInst
parameter_list|(
name|StoreInst
modifier|&
name|SI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitBranchInst
parameter_list|(
name|BranchInst
modifier|&
name|BI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFenceInst
parameter_list|(
name|FenceInst
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSwitchInst
parameter_list|(
name|SwitchInst
modifier|&
name|SI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitReturnInst
parameter_list|(
name|ReturnInst
modifier|&
name|RI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitInsertValueInst
parameter_list|(
name|InsertValueInst
modifier|&
name|IV
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitInsertElementInst
parameter_list|(
name|InsertElementInst
modifier|&
name|IE
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitExtractElementInst
parameter_list|(
name|ExtractElementInst
modifier|&
name|EI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitShuffleVectorInst
parameter_list|(
name|ShuffleVectorInst
modifier|&
name|SVI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitExtractValueInst
parameter_list|(
name|ExtractValueInst
modifier|&
name|EV
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitLandingPadInst
parameter_list|(
name|LandingPadInst
modifier|&
name|LI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitVAStartInst
parameter_list|(
name|VAStartInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitVACopyInst
parameter_list|(
name|VACopyInst
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// Specify what to return for unhandled instructions.
name|Instruction
modifier|*
name|visitInstruction
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
return|return
name|nullptr
return|;
block|}
comment|/// True when DB dominates all uses of DI except UI.
comment|/// UI must be in the same block as DI.
comment|/// The routine checks that the DI parent and DB are different.
name|bool
name|dominatesAllUses
argument_list|(
specifier|const
name|Instruction
operator|*
name|DI
argument_list|,
specifier|const
name|Instruction
operator|*
name|UI
argument_list|,
specifier|const
name|BasicBlock
operator|*
name|DB
argument_list|)
decl|const
decl_stmt|;
comment|/// Try to replace select with select operand SIOpd in SI-ICmp sequence.
name|bool
name|replacedSelectWithOperand
parameter_list|(
name|SelectInst
modifier|*
name|SI
parameter_list|,
specifier|const
name|ICmpInst
modifier|*
name|Icmp
parameter_list|,
specifier|const
name|unsigned
name|SIOpd
parameter_list|)
function_decl|;
comment|/// Try to replace instruction \p I with value \p V which are pointers
comment|/// in different address space.
comment|/// \return true if successful.
name|bool
name|replacePointer
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|,
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
name|private
label|:
name|bool
name|shouldChangeType
argument_list|(
name|unsigned
name|FromBitWidth
argument_list|,
name|unsigned
name|ToBitWidth
argument_list|)
decl|const
decl_stmt|;
name|bool
name|shouldChangeType
argument_list|(
name|Type
operator|*
name|From
argument_list|,
name|Type
operator|*
name|To
argument_list|)
decl|const
decl_stmt|;
name|Value
modifier|*
name|dyn_castNegVal
argument_list|(
name|Value
operator|*
name|V
argument_list|)
decl|const
decl_stmt|;
name|Value
modifier|*
name|dyn_castFNegVal
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|bool
name|NoSignedZero
operator|=
name|false
argument_list|)
decl|const
decl_stmt|;
name|Type
modifier|*
name|FindElementAtOffset
argument_list|(
name|PointerType
operator|*
name|PtrTy
argument_list|,
name|int64_t
name|Offset
argument_list|,
name|SmallVectorImpl
operator|<
name|Value
operator|*
operator|>
operator|&
name|NewIndices
argument_list|)
decl_stmt|;
comment|/// Classify whether a cast is worth optimizing.
comment|///
comment|/// This is a helper to decide whether the simplification of
comment|/// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.
comment|///
comment|/// \param CI The cast we are interested in.
comment|///
comment|/// \return true if this cast actually results in any code being generated and
comment|/// if it cannot already be eliminated by some other transformation.
name|bool
name|shouldOptimizeCast
parameter_list|(
name|CastInst
modifier|*
name|CI
parameter_list|)
function_decl|;
comment|/// \brief Try to optimize a sequence of instructions checking if an operation
comment|/// on LHS and RHS overflows.
comment|///
comment|/// If this overflow check is done via one of the overflow check intrinsics,
comment|/// then CtxI has to be the call instruction calling that intrinsic.  If this
comment|/// overflow check is done by arithmetic followed by a compare, then CtxI has
comment|/// to be the arithmetic instruction.
comment|///
comment|/// If a simplification is possible, stores the simplified result of the
comment|/// operation in OperationResult and result of the overflow check in
comment|/// OverflowResult, and return true.  If no simplification is possible,
comment|/// returns false.
name|bool
name|OptimizeOverflowCheck
parameter_list|(
name|OverflowCheckFlavor
name|OCF
parameter_list|,
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|Instruction
modifier|&
name|CtxI
parameter_list|,
name|Value
modifier|*
modifier|&
name|OperationResult
parameter_list|,
name|Constant
modifier|*
modifier|&
name|OverflowResult
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitCallSite
parameter_list|(
name|CallSite
name|CS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|tryOptimizeCall
parameter_list|(
name|CallInst
modifier|*
name|CI
parameter_list|)
function_decl|;
name|bool
name|transformConstExprCastCall
parameter_list|(
name|CallSite
name|CS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|transformCallThroughTrampoline
parameter_list|(
name|CallSite
name|CS
parameter_list|,
name|IntrinsicInst
modifier|*
name|Tramp
parameter_list|)
function_decl|;
comment|/// Transform (zext icmp) to bitwise / integer operations in order to
comment|/// eliminate it.
comment|///
comment|/// \param ICI The icmp of the (zext icmp) pair we are interested in.
comment|/// \parem CI The zext of the (zext icmp) pair we are interested in.
comment|/// \param DoTransform Pass false to just test whether the given (zext icmp)
comment|/// would be transformed. Pass true to actually perform the transformation.
comment|///
comment|/// \return null if the transformation cannot be performed. If the
comment|/// transformation can be performed the new instruction that replaces the
comment|/// (zext icmp) pair will be returned (if \p DoTransform is false the
comment|/// unmodified \p ICI will be returned in this case).
name|Instruction
modifier|*
name|transformZExtICmp
parameter_list|(
name|ICmpInst
modifier|*
name|ICI
parameter_list|,
name|ZExtInst
modifier|&
name|CI
parameter_list|,
name|bool
name|DoTransform
init|=
name|true
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|transformSExtICmp
parameter_list|(
name|ICmpInst
modifier|*
name|ICI
parameter_list|,
name|Instruction
modifier|&
name|CI
parameter_list|)
function_decl|;
name|bool
name|WillNotOverflowSignedAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|Instruction
modifier|&
name|CxtI
parameter_list|)
block|{
return|return
name|computeOverflowForSignedAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
operator|&
name|CxtI
argument_list|)
operator|==
name|OverflowResult
operator|::
name|NeverOverflows
return|;
block|}
empty_stmt|;
name|bool
name|willNotOverflowUnsignedAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|Instruction
modifier|&
name|CxtI
parameter_list|)
block|{
return|return
name|computeOverflowForUnsignedAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
operator|&
name|CxtI
argument_list|)
operator|==
name|OverflowResult
operator|::
name|NeverOverflows
return|;
block|}
empty_stmt|;
name|bool
name|WillNotOverflowSignedSub
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|Instruction
modifier|&
name|CxtI
parameter_list|)
function_decl|;
name|bool
name|WillNotOverflowUnsignedSub
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|Instruction
modifier|&
name|CxtI
parameter_list|)
function_decl|;
name|bool
name|WillNotOverflowSignedMul
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|Instruction
modifier|&
name|CxtI
parameter_list|)
function_decl|;
name|bool
name|willNotOverflowUnsignedMul
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|Instruction
modifier|&
name|CxtI
parameter_list|)
block|{
return|return
name|computeOverflowForUnsignedMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
operator|&
name|CxtI
argument_list|)
operator|==
name|OverflowResult
operator|::
name|NeverOverflows
return|;
block|}
empty_stmt|;
name|Value
modifier|*
name|EmitGEPOffset
parameter_list|(
name|User
modifier|*
name|GEP
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|scalarizePHI
parameter_list|(
name|ExtractElementInst
modifier|&
name|EI
parameter_list|,
name|PHINode
modifier|*
name|PN
parameter_list|)
function_decl|;
name|Value
modifier|*
name|EvaluateInDifferentElementOrder
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|ArrayRef
operator|<
name|int
operator|>
name|Mask
argument_list|)
decl_stmt|;
name|Instruction
modifier|*
name|foldCastedBitwiseLogic
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|shrinkBitwiseLogic
parameter_list|(
name|TruncInst
modifier|&
name|Trunc
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|optimizeBitCastFromPhi
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|,
name|PHINode
modifier|*
name|PN
parameter_list|)
function_decl|;
comment|/// Determine if a pair of casts can be replaced by a single cast.
comment|///
comment|/// \param CI1 The first of a pair of casts.
comment|/// \param CI2 The second of a pair of casts.
comment|///
comment|/// \return 0 if the cast pair cannot be eliminated, otherwise returns an
comment|/// Instruction::CastOps value for a cast that can replace the pair, casting
comment|/// CI1->getSrcTy() to CI2->getDstTy().
comment|///
comment|/// \see CastInst::isEliminableCastPair
name|Instruction
operator|::
name|CastOps
name|isEliminableCastPair
argument_list|(
specifier|const
name|CastInst
operator|*
name|CI1
argument_list|,
specifier|const
name|CastInst
operator|*
name|CI2
argument_list|)
expr_stmt|;
name|public
label|:
comment|/// \brief Inserts an instruction \p New before instruction \p Old
comment|///
comment|/// Also adds the new instruction to the worklist and returns \p New so that
comment|/// it is suitable for use as the return from the visitation patterns.
name|Instruction
modifier|*
name|InsertNewInstBefore
parameter_list|(
name|Instruction
modifier|*
name|New
parameter_list|,
name|Instruction
modifier|&
name|Old
parameter_list|)
block|{
name|assert
argument_list|(
name|New
operator|&&
operator|!
name|New
operator|->
name|getParent
argument_list|()
operator|&&
literal|"New instruction already inserted into a basic block!"
argument_list|)
expr_stmt|;
name|BasicBlock
modifier|*
name|BB
init|=
name|Old
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|BB
operator|->
name|getInstList
argument_list|()
operator|.
name|insert
argument_list|(
name|Old
operator|.
name|getIterator
argument_list|()
argument_list|,
name|New
argument_list|)
expr_stmt|;
comment|// Insert inst
name|Worklist
operator|.
name|Add
argument_list|(
name|New
argument_list|)
expr_stmt|;
return|return
name|New
return|;
block|}
comment|/// \brief Same as InsertNewInstBefore, but also sets the debug loc.
name|Instruction
modifier|*
name|InsertNewInstWith
parameter_list|(
name|Instruction
modifier|*
name|New
parameter_list|,
name|Instruction
modifier|&
name|Old
parameter_list|)
block|{
name|New
operator|->
name|setDebugLoc
argument_list|(
name|Old
operator|.
name|getDebugLoc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|InsertNewInstBefore
argument_list|(
name|New
argument_list|,
name|Old
argument_list|)
return|;
block|}
comment|/// \brief A combiner-aware RAUW-like routine.
comment|///
comment|/// This method is to be used when an instruction is found to be dead,
comment|/// replaceable with another preexisting expression. Here we add all uses of
comment|/// I to the worklist, replace all uses of I with the new value, then return
comment|/// I, so that the inst combiner will know that I was modified.
name|Instruction
modifier|*
name|replaceInstUsesWith
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|,
name|Value
modifier|*
name|V
parameter_list|)
block|{
comment|// If there are no uses to replace, then we return nullptr to indicate that
comment|// no changes were made to the program.
if|if
condition|(
name|I
operator|.
name|use_empty
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|Worklist
operator|.
name|AddUsersToWorkList
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Add all modified instrs to worklist.
comment|// If we are replacing the instruction with itself, this must be in a
comment|// segment of unreachable code, so just clobber the instruction.
if|if
condition|(
operator|&
name|I
operator|==
name|V
condition|)
name|V
operator|=
name|UndefValue
operator|::
name|get
argument_list|(
name|I
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"IC: Replacing "
operator|<<
name|I
operator|<<
literal|"\n"
operator|<<
literal|"    with "
operator|<<
operator|*
name|V
operator|<<
literal|'\n'
argument_list|)
expr_stmt|;
name|I
operator|.
name|replaceAllUsesWith
argument_list|(
name|V
argument_list|)
expr_stmt|;
return|return
operator|&
name|I
return|;
block|}
comment|/// Creates a result tuple for an overflow intrinsic \p II with a given
comment|/// \p Result and a constant \p Overflow value.
name|Instruction
modifier|*
name|CreateOverflowTuple
parameter_list|(
name|IntrinsicInst
modifier|*
name|II
parameter_list|,
name|Value
modifier|*
name|Result
parameter_list|,
name|Constant
modifier|*
name|Overflow
parameter_list|)
block|{
name|Constant
modifier|*
name|V
index|[]
init|=
block|{
name|UndefValue
operator|::
name|get
argument_list|(
name|Result
operator|->
name|getType
argument_list|()
argument_list|)
block|,
name|Overflow
block|}
decl_stmt|;
name|StructType
modifier|*
name|ST
init|=
name|cast
operator|<
name|StructType
operator|>
operator|(
name|II
operator|->
name|getType
argument_list|()
operator|)
decl_stmt|;
name|Constant
modifier|*
name|Struct
init|=
name|ConstantStruct
operator|::
name|get
argument_list|(
name|ST
argument_list|,
name|V
argument_list|)
decl_stmt|;
return|return
name|InsertValueInst
operator|::
name|Create
argument_list|(
name|Struct
argument_list|,
name|Result
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/// \brief Combiner aware instruction erasure.
comment|///
comment|/// When dealing with an instruction that has side effects or produces a void
comment|/// value, we can't rely on DCE to delete the instruction. Instead, visit
comment|/// methods should return the value returned by this function.
name|Instruction
modifier|*
name|eraseInstFromFunction
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"IC: ERASE "
operator|<<
name|I
operator|<<
literal|'\n'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|.
name|use_empty
argument_list|()
operator|&&
literal|"Cannot erase instruction that is used!"
argument_list|)
expr_stmt|;
name|salvageDebugInfo
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Make sure that we reprocess all operands now that we reduced their
comment|// use counts.
if|if
condition|(
name|I
operator|.
name|getNumOperands
argument_list|()
operator|<
literal|8
condition|)
block|{
for|for
control|(
name|Use
modifier|&
name|Operand
range|:
name|I
operator|.
name|operands
argument_list|()
control|)
if|if
condition|(
name|auto
operator|*
name|Inst
operator|=
name|dyn_cast
operator|<
name|Instruction
operator|>
operator|(
name|Operand
operator|)
condition|)
name|Worklist
operator|.
name|Add
argument_list|(
name|Inst
argument_list|)
expr_stmt|;
block|}
name|Worklist
operator|.
name|Remove
argument_list|(
operator|&
name|I
argument_list|)
expr_stmt|;
name|I
operator|.
name|eraseFromParent
argument_list|()
expr_stmt|;
name|MadeIRChange
operator|=
name|true
expr_stmt|;
return|return
name|nullptr
return|;
comment|// Don't do anything with FI
block|}
name|void
name|computeKnownBits
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|KnownBits
operator|&
name|Known
argument_list|,
name|unsigned
name|Depth
argument_list|,
name|Instruction
operator|*
name|CxtI
argument_list|)
decl|const
block|{
name|llvm
operator|::
name|computeKnownBits
argument_list|(
name|V
argument_list|,
name|Known
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
operator|&
name|AC
argument_list|,
name|CxtI
argument_list|,
operator|&
name|DT
argument_list|)
expr_stmt|;
block|}
name|KnownBits
name|computeKnownBits
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|unsigned
name|Depth
argument_list|,
name|Instruction
operator|*
name|CxtI
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|computeKnownBits
argument_list|(
name|V
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
operator|&
name|AC
argument_list|,
name|CxtI
argument_list|,
operator|&
name|DT
argument_list|)
return|;
block|}
name|bool
name|MaskedValueIsZero
argument_list|(
name|Value
operator|*
name|V
argument_list|,
specifier|const
name|APInt
operator|&
name|Mask
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|,
name|Instruction
operator|*
name|CxtI
operator|=
name|nullptr
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|MaskedValueIsZero
argument_list|(
name|V
argument_list|,
name|Mask
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
operator|&
name|AC
argument_list|,
name|CxtI
argument_list|,
operator|&
name|DT
argument_list|)
return|;
block|}
name|unsigned
name|ComputeNumSignBits
argument_list|(
name|Value
operator|*
name|Op
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|,
name|Instruction
operator|*
name|CxtI
operator|=
name|nullptr
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|ComputeNumSignBits
argument_list|(
name|Op
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
operator|&
name|AC
argument_list|,
name|CxtI
argument_list|,
operator|&
name|DT
argument_list|)
return|;
block|}
name|OverflowResult
name|computeOverflowForUnsignedMul
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|CxtI
parameter_list|)
block|{
return|return
name|llvm
operator|::
name|computeOverflowForUnsignedMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|DL
argument_list|,
operator|&
name|AC
argument_list|,
name|CxtI
argument_list|,
operator|&
name|DT
argument_list|)
return|;
block|}
name|OverflowResult
name|computeOverflowForUnsignedAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|CxtI
parameter_list|)
block|{
return|return
name|llvm
operator|::
name|computeOverflowForUnsignedAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|DL
argument_list|,
operator|&
name|AC
argument_list|,
name|CxtI
argument_list|,
operator|&
name|DT
argument_list|)
return|;
block|}
name|OverflowResult
name|computeOverflowForSignedAdd
argument_list|(
specifier|const
name|Value
operator|*
name|LHS
argument_list|,
specifier|const
name|Value
operator|*
name|RHS
argument_list|,
specifier|const
name|Instruction
operator|*
name|CxtI
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|computeOverflowForSignedAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|DL
argument_list|,
operator|&
name|AC
argument_list|,
name|CxtI
argument_list|,
operator|&
name|DT
argument_list|)
return|;
block|}
comment|/// Maximum size of array considered when transforming.
name|uint64_t
name|MaxArraySizeForCombine
decl_stmt|;
name|private
label|:
comment|/// \brief Performs a few simplifications for operators which are associative
comment|/// or commutative.
name|bool
name|SimplifyAssociativeOrCommutative
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// \brief Tries to simplify binary operations which some other binary
comment|/// operation distributes over.
comment|///
comment|/// It does this by either by factorizing out common terms (eg "(A*B)+(A*C)"
comment|/// -> "A*(B+C)") or expanding out if this results in simplifications (eg: "A
comment|///& (B | C) -> (A&B) | (A&C)" if this is a win).  Returns the simplified
comment|/// value, or null if it didn't simplify.
name|Value
modifier|*
name|SimplifyUsingDistributiveLaws
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// This tries to simplify binary operations by factorizing out common terms
comment|/// (e. g. "(A*B)+(A*C)" -> "A*(B+C)").
name|Value
modifier|*
name|tryFactorization
argument_list|(
name|InstCombiner
operator|::
name|BuilderTy
operator|*
argument_list|,
name|BinaryOperator
operator|&
argument_list|,
name|Instruction
operator|::
name|BinaryOps
argument_list|,
name|Value
operator|*
argument_list|,
name|Value
operator|*
argument_list|,
name|Value
operator|*
argument_list|,
name|Value
operator|*
argument_list|)
decl_stmt|;
comment|/// \brief Attempts to replace V with a simpler value based on the demanded
comment|/// bits.
name|Value
modifier|*
name|SimplifyDemandedUseBits
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|KnownBits
modifier|&
name|Known
parameter_list|,
name|unsigned
name|Depth
parameter_list|,
name|Instruction
modifier|*
name|CxtI
parameter_list|)
function_decl|;
name|bool
name|SimplifyDemandedBits
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|,
name|unsigned
name|Op
parameter_list|,
specifier|const
name|APInt
modifier|&
name|DemandedMask
parameter_list|,
name|KnownBits
modifier|&
name|Known
parameter_list|,
name|unsigned
name|Depth
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne
comment|/// bits. It also tries to handle simplifications that can be done based on
comment|/// DemandedMask, but without modifying the Instruction.
name|Value
modifier|*
name|SimplifyMultipleUseDemandedBits
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|,
specifier|const
name|APInt
modifier|&
name|DemandedMask
parameter_list|,
name|KnownBits
modifier|&
name|Known
parameter_list|,
name|unsigned
name|Depth
parameter_list|,
name|Instruction
modifier|*
name|CxtI
parameter_list|)
function_decl|;
comment|/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded
comment|/// bit for "r1 = shr x, c1; r2 = shl r1, c2" instruction sequence.
name|Value
modifier|*
name|simplifyShrShlDemandedBits
parameter_list|(
name|Instruction
modifier|*
name|Shr
parameter_list|,
specifier|const
name|APInt
modifier|&
name|ShrOp1
parameter_list|,
name|Instruction
modifier|*
name|Shl
parameter_list|,
specifier|const
name|APInt
modifier|&
name|ShlOp1
parameter_list|,
specifier|const
name|APInt
modifier|&
name|DemandedMask
parameter_list|,
name|KnownBits
modifier|&
name|Known
parameter_list|)
function_decl|;
comment|/// \brief Tries to simplify operands to an integer instruction based on its
comment|/// demanded bits.
name|bool
name|SimplifyDemandedInstructionBits
parameter_list|(
name|Instruction
modifier|&
name|Inst
parameter_list|)
function_decl|;
name|Value
modifier|*
name|SimplifyDemandedVectorElts
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|APInt
name|DemandedElts
parameter_list|,
name|APInt
modifier|&
name|UndefElts
parameter_list|,
name|unsigned
name|Depth
init|=
literal|0
parameter_list|)
function_decl|;
name|Value
modifier|*
name|SimplifyVectorOp
parameter_list|(
name|BinaryOperator
modifier|&
name|Inst
parameter_list|)
function_decl|;
name|Value
modifier|*
name|SimplifyBSwap
parameter_list|(
name|BinaryOperator
modifier|&
name|Inst
parameter_list|)
function_decl|;
comment|/// Given a binary operator, cast instruction, or select which has a PHI node
comment|/// as operand #0, see if we can fold the instruction into the PHI (which is
comment|/// only possible if all operands to the PHI are constants).
name|Instruction
modifier|*
name|foldOpIntoPhi
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|,
name|PHINode
modifier|*
name|PN
parameter_list|)
function_decl|;
comment|/// Given an instruction with a select as one operand and a constant as the
comment|/// other operand, try to fold the binary operator into the select arguments.
comment|/// This also works for Cast instructions, which obviously do not have a
comment|/// second operand.
name|Instruction
modifier|*
name|FoldOpIntoSelect
parameter_list|(
name|Instruction
modifier|&
name|Op
parameter_list|,
name|SelectInst
modifier|*
name|SI
parameter_list|)
function_decl|;
comment|/// This is a convenience wrapper function for the above two functions.
name|Instruction
modifier|*
name|foldOpWithConstantIntoOperand
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// \brief Try to rotate an operation below a PHI node, using PHI nodes for
comment|/// its operands.
name|Instruction
modifier|*
name|FoldPHIArgOpIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgBinOpIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgGEPIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgLoadIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgZextsIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
comment|/// Helper function for FoldPHIArgXIntoPHI() to get debug location for the
comment|/// folded operation.
name|DebugLoc
name|PHIArgMergedDebugLoc
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldGEPICmp
argument_list|(
name|GEPOperator
operator|*
name|GEPLHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|ICmpInst
operator|::
name|Predicate
name|Cond
argument_list|,
name|Instruction
operator|&
name|I
argument_list|)
decl_stmt|;
name|Instruction
modifier|*
name|foldAllocaCmp
parameter_list|(
name|ICmpInst
modifier|&
name|ICI
parameter_list|,
specifier|const
name|AllocaInst
modifier|*
name|Alloca
parameter_list|,
specifier|const
name|Value
modifier|*
name|Other
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldCmpLoadFromIndexedGlobal
parameter_list|(
name|GetElementPtrInst
modifier|*
name|GEP
parameter_list|,
name|GlobalVariable
modifier|*
name|GV
parameter_list|,
name|CmpInst
modifier|&
name|ICI
parameter_list|,
name|ConstantInt
modifier|*
name|AndCst
init|=
name|nullptr
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldFCmpIntToFPConst
parameter_list|(
name|FCmpInst
modifier|&
name|I
parameter_list|,
name|Instruction
modifier|*
name|LHSI
parameter_list|,
name|Constant
modifier|*
name|RHSC
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpAddOpConst
argument_list|(
name|Instruction
operator|&
name|ICI
argument_list|,
name|Value
operator|*
name|X
argument_list|,
name|ConstantInt
operator|*
name|CI
argument_list|,
name|ICmpInst
operator|::
name|Predicate
name|Pred
argument_list|)
decl_stmt|;
name|Instruction
modifier|*
name|foldICmpWithCastAndCast
parameter_list|(
name|ICmpInst
modifier|&
name|ICI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpUsingKnownBits
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpWithConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpInstWithConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpInstWithConstantNotInt
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpBinOp
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpEquality
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpTruncConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|Instruction
modifier|*
name|Trunc
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpAndConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|And
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpXorConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|Xor
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpOrConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|Or
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpMulConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|Mul
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpShlConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|Shl
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpShrConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|Shr
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpUDivConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|UDiv
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpDivConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|Div
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpSubConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|Sub
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpAddConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|Add
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpAndConstConst
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|And
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C1
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpAndShift
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|And
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C1
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C2
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpShrConstConst
parameter_list|(
name|ICmpInst
modifier|&
name|I
parameter_list|,
name|Value
modifier|*
name|ShAmt
parameter_list|,
specifier|const
name|APInt
modifier|&
name|C1
parameter_list|,
specifier|const
name|APInt
modifier|&
name|C2
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpShlConstConst
parameter_list|(
name|ICmpInst
modifier|&
name|I
parameter_list|,
name|Value
modifier|*
name|ShAmt
parameter_list|,
specifier|const
name|APInt
modifier|&
name|C1
parameter_list|,
specifier|const
name|APInt
modifier|&
name|C2
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpBinOpEqualityWithConstant
parameter_list|(
name|ICmpInst
modifier|&
name|Cmp
parameter_list|,
name|BinaryOperator
modifier|*
name|BO
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldICmpIntrinsicWithConstant
parameter_list|(
name|ICmpInst
modifier|&
name|ICI
parameter_list|,
specifier|const
name|APInt
modifier|*
name|C
parameter_list|)
function_decl|;
comment|// Helpers of visitSelectInst().
name|Instruction
modifier|*
name|foldSelectExtConst
parameter_list|(
name|SelectInst
modifier|&
name|Sel
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldSelectOpOp
parameter_list|(
name|SelectInst
modifier|&
name|SI
parameter_list|,
name|Instruction
modifier|*
name|TI
parameter_list|,
name|Instruction
modifier|*
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldSelectIntoOp
parameter_list|(
name|SelectInst
modifier|&
name|SI
parameter_list|,
name|Value
modifier|*
parameter_list|,
name|Value
modifier|*
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldSPFofSPF
parameter_list|(
name|Instruction
modifier|*
name|Inner
parameter_list|,
name|SelectPatternFlavor
name|SPF1
parameter_list|,
name|Value
modifier|*
name|A
parameter_list|,
name|Value
modifier|*
name|B
parameter_list|,
name|Instruction
modifier|&
name|Outer
parameter_list|,
name|SelectPatternFlavor
name|SPF2
parameter_list|,
name|Value
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|foldSelectInstWithICmp
parameter_list|(
name|SelectInst
modifier|&
name|SI
parameter_list|,
name|ICmpInst
modifier|*
name|ICI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|OptAndOp
parameter_list|(
name|BinaryOperator
modifier|*
name|Op
parameter_list|,
name|ConstantInt
modifier|*
name|OpRHS
parameter_list|,
name|ConstantInt
modifier|*
name|AndRHS
parameter_list|,
name|BinaryOperator
modifier|&
name|TheAnd
parameter_list|)
function_decl|;
name|Value
modifier|*
name|insertRangeTest
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
specifier|const
name|APInt
modifier|&
name|Lo
parameter_list|,
specifier|const
name|APInt
modifier|&
name|Hi
parameter_list|,
name|bool
name|isSigned
parameter_list|,
name|bool
name|Inside
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|PromoteCastOfAllocation
parameter_list|(
name|BitCastInst
modifier|&
name|CI
parameter_list|,
name|AllocaInst
modifier|&
name|AI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|MatchBSwap
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|SimplifyStoreAtEndOfBlock
parameter_list|(
name|StoreInst
modifier|&
name|SI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|SimplifyElementAtomicMemCpy
parameter_list|(
name|ElementAtomicMemCpyInst
modifier|*
name|AMI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|SimplifyMemTransfer
parameter_list|(
name|MemIntrinsic
modifier|*
name|MI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|SimplifyMemSet
parameter_list|(
name|MemSetInst
modifier|*
name|MI
parameter_list|)
function_decl|;
name|Value
modifier|*
name|EvaluateInDifferentType
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|isSigned
parameter_list|)
function_decl|;
comment|/// \brief Returns a value X such that Val = X * Scale, or null if none.
comment|///
comment|/// If the multiplication is known not to overflow then NoSignedWrap is set.
name|Value
modifier|*
name|Descale
parameter_list|(
name|Value
modifier|*
name|Val
parameter_list|,
name|APInt
name|Scale
parameter_list|,
name|bool
modifier|&
name|NoSignedWrap
parameter_list|)
function_decl|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm.
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG_TYPE
end_undef

begin_endif
endif|#
directive|endif
end_endif

end_unit

